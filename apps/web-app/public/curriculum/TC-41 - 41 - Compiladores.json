{
  "formatVersion": "1.0",
  "exportDate": "2025-12-04T22:37:24.606Z",
  "appVersion": "1.0",
  "curriculumData": {
    "metadata": {
      "baseOn": "Catálogo dos Cursos de Graduação 2025 - TC-41",
      "lastUpdated": "2025-12-04",
      "totalAtomicSkills": 334
    },
    "areas": [
      {
        "id": "10",
        "name": "Ciência da Computação",
        "description": "Área dedicada ao estudo de fundamentos teóricos e práticos da computação, incluindo linguagens de programação, algoritmos e sistemas.",
        "disciplines": [
          {
            "id": "10.1",
            "name": "Compiladores",
            "description": "Análise léxica. Análise sintática: metodologias top-down e bottom-up. Organização de tabelas de símbolos. Tratamento de erros. Análise semântica. Geração de código intermediário e de código objeto. Meta-compiladores e ferramentas automáticas para construção de compiladores.",
            "mainTopics": [
              {
                "id": "10.1.1",
                "name": "Análise Léxica",
                "description": "Estudo dos processos iniciais de análise do código-fonte, identificando tokens e estruturas básicas da linguagem.",
                "totalSkills": 59,
                "atomicTopics": [
                  {
                    "id": "10.1.1.1",
                    "name": "Definição e Propósito da Análise Léxica",
                    "description": "Processo inicial que transforma o código-fonte em uma sequência de tokens, removendo espaços e comentários.",
                    "individualConcepts": [
                      {
                        "id": "10.1.1.1.1.1",
                        "name": "Definição da Análise Léxica",
                        "description": "A análise léxica é o processo inicial de compilação que lê o código-fonte como uma sequência de caracteres e o transforma em uma sequência de tokens, identificando unidades léxicas básicas da linguagem.",
                        "specificSkills": [
                          {
                            "id": "10.1.1.1.1.1.1",
                            "name": "Definir análise léxica",
                            "description": "Explicar com precisão o conceito de análise léxica, destacando que ela é a primeira fase do compilador e atua como scanner ou lexer, convertendo texto fonte em tokens sem interpretação semântica.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o contexto dos compiladores e suas fases",
                                  "subSteps": [
                                    "Pesquisar a definição de compilador e sua função principal.",
                                    "Identificar e listar as fases principais de um compilador (léxica, sintática, semântica, etc.).",
                                    "Desenhar um diagrama simples do fluxo de um compilador.",
                                    "Explicar brevemente o propósito geral de cada fase.",
                                    "Comparar compilador com interpretador."
                                  ],
                                  "verification": "Diagrama completo com fases corretas e explicações curtas por fase.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Acesso à internet ou livro-texto sobre compiladores (ex: 'Compilers: Principles, Techniques, and Tools')",
                                    "Papel e caneta para diagrama"
                                  ],
                                  "tips": "Use diagramas visuais para fixar o fluxo; foque em como o código fonte é transformado progressivamente.",
                                  "learningObjective": "Entender o pipeline de um compilador e posicionar a análise léxica como primeira fase.",
                                  "commonMistakes": [
                                    "Confundir fases ou inverter a ordem (léxica vem antes da sintática)",
                                    "Ignorar que compiladores geram código objeto"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Definir precisamente o conceito de análise léxica",
                                  "subSteps": [
                                    "Ler definições padrão de análise léxica em fontes confiáveis.",
                                    "Anotar os termos chave: scanner, lexer, tokens, texto fonte.",
                                    "Escrever uma definição própria em 2-3 frases.",
                                    "Destacar que não há interpretação semântica.",
                                    "Memorizar a posição como primeira fase do compilador."
                                  ],
                                  "verification": "Definição escrita que inclui todos os elementos chave sem erros.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Documentação ou slides sobre compiladores",
                                    "Bloco de notas"
                                  ],
                                  "tips": "Use sinônimos como 'lexer' para reforçar compreensão; evite definições vagas.",
                                  "learningObjective": "Formular uma definição precisa e concisa de análise léxica.",
                                  "commonMistakes": [
                                    "Incluir análise semântica na definição",
                                    "Confundir com análise sintática"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explorar o funcionamento do scanner ou lexer",
                                  "subSteps": [
                                    "Estudar como o lexer converte texto fonte em tokens.",
                                    "Identificar tipos de tokens (keywords, identificadores, operadores, etc.).",
                                    "Simular manualmente a tokenização de um trecho de código simples.",
                                    "Explicar o processo de matching de padrões regulares.",
                                    "Discutir o que acontece com comentários e espaços em branco."
                                  ],
                                  "verification": "Tokenização manual correta de um exemplo de código com lista de tokens gerados.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Exemplo de código fonte simples (ex: 'if (x > 0) {...}' )",
                                    "Ferramenta online de lexer se disponível"
                                  ],
                                  "tips": "Pratique com códigos curtos; ignore semântica e foque só na divisão em tokens.",
                                  "learningObjective": "Compreender o mecanismo de conversão de caracteres em tokens.",
                                  "commonMistakes": [
                                    "Interpretar o valor dos tokens (ex: avaliar se x é variável)",
                                    "Esquecer de filtrar whitespaces"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Diferenciar análise léxica de outras fases e consolidar",
                                  "subSteps": [
                                    "Comparar análise léxica com análise sintática (estrutura vs. tokens).",
                                    "Exemplificar erros léxicos vs. sintáticos.",
                                    "Revisar toda a definição e adicionar exemplos reais.",
                                    "Criar um resumo em bullet points.",
                                    "Testar explicando para si mesmo ou gravar áudio."
                                  ],
                                  "verification": "Resumo em bullets e gravação de explicação clara (1-2 minutos).",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Exemplos de erros em códigos",
                                    "Gravador de voz ou app de notas"
                                  ],
                                  "tips": "Use analogia: lexer é como dividir um livro em palavras, sem entender frases.",
                                  "learningObjective": "Distinguir análise léxica de fases subsequentes e internalizar o conceito.",
                                  "commonMistakes": [
                                    "Misturar léxica com semântica",
                                    "Subestimar o filtro de irrelevantes como comentários"
                                  ]
                                }
                              ],
                              "practicalExample": "Dado o código fonte 'int main() { if (x > 0) return 1; }', o lexer identifica tokens como: KEYWORD(int), KEYWORD(main), SYMBOL(()), SYMBOL()), SYMBOL({), KEYWORD(if), IDENTIFIER(x), OPERATOR(>), NUMBER(0), KEYWORD(return), NUMBER(1), SYMBOL(;) e SYMBOL(}), ignorando espaços e comentários.",
                              "finalVerifications": [
                                "Explicar verbalmente a definição completa em menos de 1 minuto.",
                                "Tokenizar corretamente um código fonte curto fornecido.",
                                "Identificar análise léxica em um diagrama de compilador.",
                                "Diferenciar lexer de parser com exemplos.",
                                "Listar 3 funções principais do lexer."
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição (menção a primeira fase, scanner/lexer, tokens, sem semântica).",
                                "Correta tokenização em exemplos práticos.",
                                "Compreensão das limitações (sem interpretação de significado).",
                                "Uso correto de terminologia técnica.",
                                "Capacidade de diferenciar de outras fases do compilador.",
                                "Clareza na explicação oral ou escrita."
                              ],
                              "crossCurricularConnections": [
                                "Linguística: Similar à análise morfológica e tokenização em processamento de linguagem natural (NLP).",
                                "Matemática: Uso de expressões regulares e autômatos finitos.",
                                "Engenharia de Software: Parsing de arquivos de configuração (JSON, YAML).",
                                "Inteligência Artificial: Pré-processamento em chatbots e analisadores de texto."
                              ],
                              "realWorldApplication": "A análise léxica é essencial em compiladores como GCC (para C/C++), Javac (Java) e até interpretadores Python, além de editores de código (VS Code syntax highlighting) e ferramentas de linting que detectam erros antes da compilação."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.1.1.1.2",
                            "name": "Identificar entrada e saída da análise léxica",
                            "description": "Descrever a entrada como o código-fonte (sequência de caracteres) e a saída como uma lista de tokens, diferenciando de fases subsequentes como análise sintática.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a entrada da análise léxica",
                                  "subSteps": [
                                    "Ler a definição de código-fonte como texto escrito em uma linguagem de programação.",
                                    "Identificar exemplos de código-fonte simples, como 'int main() { return 0; }'.",
                                    "Reconhecer que a entrada é tratada como uma sequência bruta de caracteres (stream de chars).",
                                    "Analisar como espaços, quebras de linha e caracteres especiais são parte dessa sequência.",
                                    "Diferenciar código-fonte de binários ou objetos compilados."
                                  ],
                                  "verification": "Escreva uma frase descrevendo a entrada e forneça um exemplo de código-fonte de 1 linha.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Documentação de linguagens de programação (ex: C ou Python)",
                                    "Editor de texto simples"
                                  ],
                                  "tips": "Sempre pense na entrada como 'texto puro' antes de qualquer processamento.",
                                  "learningObjective": "Identificar e descrever a entrada da análise léxica como código-fonte em formato de caracteres.",
                                  "commonMistakes": [
                                    "Confundir com o código já tokenizado",
                                    "Ignorar caracteres não alfanuméricos como espaços"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Compreender a saída da análise léxica: tokens",
                                  "subSteps": [
                                    "Definir token como a menor unidade significativa após remoção de irrelevâncias (espaços, comentários).",
                                    "Classificar tipos de tokens: palavras-chave (ex: int), identificadores (ex: x), operadores (ex: =), literais (ex: 5).",
                                    "Exemplificar com um código simples e listar seus tokens.",
                                    "Entender que tokens incluem tipo e valor (ex: {tipo: 'NUMBER', valor: '5'}).",
                                    "Visualizar tokens como uma lista ou sequência numerada."
                                  ],
                                  "verification": "Converta um código-fonte curto em uma lista de 5-10 tokens com tipos.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Exemplos de código-fonte",
                                    "Tabela de tokens de uma linguagem (ex: especificação C)"
                                  ],
                                  "tips": "Ignore espaços e comentários ao formar tokens; foque em unidades lógicas.",
                                  "learningObjective": "Descrever tokens como saída da análise léxica e listar exemplos corretos.",
                                  "commonMistakes": [
                                    "Incluir espaços como tokens",
                                    "Confundir tokens com expressões sintáticas"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Entender o processo básico de análise léxica",
                                  "subSteps": [
                                    "Descrever o fluxo: entrada (chars) -> scanner/lexer -> saída (tokens).",
                                    "Explicar remoção de whitespaces e comentários durante o scan.",
                                    "Simular manualmente o processo em um código de 2 linhas.",
                                    "Identificar padrões regulares usados para reconhecer tokens.",
                                    "Comparar com divisão de palavras em um texto natural."
                                  ],
                                  "verification": "Desenhe um diagrama simples: entrada -> lexer -> tokens, com um exemplo.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Papel e caneta para diagrama",
                                    "Ferramenta online de lexer (ex: JFlex demo)"
                                  ],
                                  "tips": "Pense no lexer como um 'divisor de palavras' inteligente para código.",
                                  "learningObjective": "Mapear entrada para saída através do processo de análise léxica.",
                                  "commonMistakes": [
                                    "Achar que lexer interpreta significado",
                                    "Pular a remoção de irrelevâncias"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Diferenciar análise léxica de fases subsequentes",
                                  "subSteps": [
                                    "Comparar saída léxica (tokens isolados) com entrada sintática (sequência de tokens).",
                                    "Explicar que análise sintática usa tokens para formar árvore de parsing.",
                                    "Dar exemplo: tokens de 'int x=5;' não formam estrutura; sintaxe verifica 'declaração válida'.",
                                    "Discutir fases: léxica -> sintática -> semântica.",
                                    "Identificar erros léxicos (ex: char inválido) vs. sintáticos (ex: falta ';')."
                                  ],
                                  "verification": "Classifique 3 erros em um código como léxico ou sintático e explique.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Exemplos de códigos com erros léxicos e sintáticos"
                                  ],
                                  "tips": "Léxica é 'quebra em pedaços'; sintática é 'monta o quebra-cabeça'.",
                                  "learningObjective": "Distinguir análise léxica de análise sintática pela entrada/saída.",
                                  "commonMistakes": [
                                    "Confundir tokens com nós de árvore sintática",
                                    "Achar léxica responsável por tipos"
                                  ]
                                }
                              ],
                              "practicalExample": "Código-fonte de entrada: 'int x = 5;'\nSaída tokens: [{tipo: 'KEYWORD', valor: 'int'}, {tipo: 'IDENTIFIER', valor: 'x'}, {tipo: 'OPERATOR', valor: '='}, {tipo: 'NUMBER', valor: '5'}, {tipo: 'PUNCTUATION', valor: ';'}]\n(Esquema e espaços ignorados pelo lexer).",
                              "finalVerifications": [
                                "Descreva corretamente a entrada como sequência de caracteres do código-fonte.",
                                "Liste todos os tokens de um código-fonte fornecido, com tipos.",
                                "Explique a diferença entre saída léxica e entrada sintática.",
                                "Identifique um erro léxico em um código e ignore erros sintáticos.",
                                "Desenhe o fluxo entrada -> tokens -> parser.",
                                "Diferencie lexer de parser em termos de função."
                              ],
                              "assessmentCriteria": [
                                "Precisão na descrição de entrada (código-fonte como chars).",
                                "Correção na identificação e classificação de tokens.",
                                "Clareza na diferenciação léxica vs. sintática.",
                                "Completude do processo descrito (removal de whitespaces).",
                                "Uso de exemplos concretos e diagramas.",
                                "Ausência de confusões com fases semânticas."
                              ],
                              "crossCurricularConnections": [
                                "Linguística: Similar à tokenização de palavras e morfemas em textos.",
                                "Processamento de Linguagem Natural: Pré-processamento em NLP (tokenizers).",
                                "Matemática: Expressões regulares como autômatos finitos.",
                                "Engenharia de Software: Parsers em ferramentas como IDEs e linters."
                              ],
                              "realWorldApplication": "Em compiladores como GCC ou Clang, o lexer (ex: flex) converte código-fonte em tokens para análise posterior; usado em editores como VS Code para syntax highlighting e autocompletar."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.1.1.1.3",
                            "name": "Posicionar a análise léxica no pipeline do compilador",
                            "description": "Explicar a posição da análise léxica como etapa inicial, precedendo a análise sintática, semântica e geração de código, conforme descrito em livros como Aho et al.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a estrutura geral do pipeline de compilação",
                                  "subSteps": [
                                    "Ler a definição clássica de pipeline de compilador de livros como 'Compilers: Principles, Techniques, and Tools' de Aho et al.",
                                    "Listar as fases principais: análise léxica, sintática, semântica, otimização e geração de código.",
                                    "Identificar as divisões frontend (análise) e backend (síntese).",
                                    "Pesquisar exemplos reais como o pipeline do GCC ou LLVM.",
                                    "Anotar dependências entre fases."
                                  ],
                                  "verification": "Criar uma lista numerada das 5-6 fases principais do pipeline com descrições breves.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Livro 'Compilers: Principles, Techniques, and Tools' (cap. 1), diagrama online do pipeline GCC, caderno para anotações"
                                  ],
                                  "tips": "Use diagramas visuais para memorizar a sequência; foque no fluxo linear das fases.",
                                  "learningObjective": "Identificar e descrever todas as fases principais do pipeline de compilação.",
                                  "commonMistakes": [
                                    "Confundir análise léxica com sintática; ignorar fases de otimização no backend."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Definir e caracterizar a análise léxica",
                                  "subSteps": [
                                    "Explicar que a análise léxica (lexer) converte código fonte em tokens (palavras-chave, identificadores, etc.).",
                                    "Estudar expressões regulares e autômatos finitos como base do lexer.",
                                    "Diferenciar tokens de caracteres brutos.",
                                    "Analisar um exemplo de código fonte simples e tokenizá-lo manualmente.",
                                    "Comparar com pré-processador em linguagens como C."
                                  ],
                                  "verification": "Tokenizar um trecho de código fonte de 10 linhas e listar os tokens produzidos.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Exemplo de código C simples, ferramenta online de lexer como regex101, vídeo tutorial sobre lexers (5 min)"
                                  ],
                                  "tips": "Pratique tokenização manual para internalizar o processo; ignore espaços e comentários inicialmente.",
                                  "learningObjective": "Compreender o papel da análise léxica na quebra de código em unidades mínimas.",
                                  "commonMistakes": [
                                    "Tratar strings como múltiplos tokens; esquecer de lidar com comentários."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar a precedência da análise léxica no pipeline",
                                  "subSteps": [
                                    "Explicar por que léxica precede sintática: parser precisa de tokens, não caracteres.",
                                    "Discutir dependências: semântica requer árvore sintática, que vem após parser.",
                                    "Estudar razões de eficiência: lexer é mais simples e rápido.",
                                    "Mapear entrada (código fonte) → lexer → parser → etc.",
                                    "Revisar citações de Aho et al. sobre o fluxo sequencial."
                                  ],
                                  "verification": "Escrever um parágrafo explicando 'por que lexer é a primeira fase' com 3 razões justificadas.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Trechos do livro Aho et al. (cap. 3), fluxograma editável online como draw.io"
                                  ],
                                  "tips": "Pense em analogia: lexer como 'dividir texto em palavras' antes de analisar gramática.",
                                  "learningObjective": "Justificar a posição inicial da análise léxica com base em dependências lógicas.",
                                  "commonMistakes": [
                                    "Achar que lexer pode ser pulado; confundir ordem com paralelismo."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Visualizar e diagramar o pipeline completo",
                                  "subSteps": [
                                    "Desenhar um diagrama linear do pipeline destacando a posição do lexer.",
                                    "Incluir setas de fluxo e entradas/saídas de cada fase.",
                                    "Simular o fluxo com um exemplo de código curto.",
                                    "Comparar pipelines de compiladores reais (ex: Java vs. C).",
                                    "Autoavaliar o diagrama contra referências padrão."
                                  ],
                                  "verification": "Produzir um diagrama final com lexer corretamente posicionado e legendado.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Ferramenta draw.io ou papel/lápis, exemplos de código, imagens de pipelines online"
                                  ],
                                  "tips": "Use cores para frontend/backend; mantenha simples com 6 blocos principais.",
                                  "learningObjective": "Representar visualmente a integração da análise léxica no pipeline.",
                                  "commonMistakes": [
                                    "Colocar lexer após parser; omitir fases intermediárias."
                                  ]
                                }
                              ],
                              "practicalExample": "Considere o código C: 'int main() { return 0; }'. O lexer primeiro produz tokens: [INT, MAIN, LPAREN, RPAREN, LBRACE, RETURN, 0, RBRACE, SEMICOLON], que são passados ao parser para análise sintática, semântica e geração de código assembly.",
                              "finalVerifications": [
                                "Desenhar corretamente o pipeline com lexer como primeira fase.",
                                "Explicar verbalmente 3 razões para a posição inicial do lexer.",
                                "Tokenizar um código fonte novo sem erros.",
                                "Diferenciar saídas de lexer vs. parser.",
                                "Identificar lexer em documentação de compiladores reais como GCC.",
                                "Listar fases subsequentes sem confusões."
                              ],
                              "assessmentCriteria": [
                                "Precisão na posição e justificativa da análise léxica (30%)",
                                "Compreensão das dependências entre fases (25%)",
                                "Qualidade do diagrama e tokenização prática (20%)",
                                "Uso correto de referências teóricas como Aho et al. (15%)",
                                "Clareza na explicação oral/escrita (10%)"
                              ],
                              "crossCurricularConnections": [
                                "Teoria da Computação: Autômatos finitos para implementação de lexers.",
                                "Engenharia de Software: Pipelines modulares em ferramentas DevOps.",
                                "Processamento de Linguagem Natural: Tokenização em NLP pré-treinamento.",
                                "Design de Sistemas: Fluxos sequenciais em processadores de dados."
                              ],
                              "realWorldApplication": "Em compiladores como GCC ou Clang, o lexer (gerado por Flex) é a porta de entrada, permitindo syntax highlighting em IDEs como VS Code e análise estática em ferramentas como ESLint, essencial para desenvolvimento de software escalável."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.1.1.1.2",
                        "name": "Propósito da Análise Léxica",
                        "description": "O propósito principal é simplificar o código-fonte para as fases seguintes, removendo elementos irrelevantes e padronizando unidades léxicas para facilitar a análise sintática.",
                        "specificSkills": [
                          {
                            "id": "10.1.1.1.1.2.1",
                            "name": "Listar os propósitos principais",
                            "description": "Enumerar e justificar os objetivos como tokenização, remoção de ruído (espaços, comentários) e detecção inicial de erros léxicos, melhorando a eficiência do compilador.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar a Definição Básica de Análise Léxica",
                                  "subSteps": [
                                    "Leia a definição de análise léxica como a primeira fase do compilador que processa o código fonte caractere por caractere.",
                                    "Identifique o input (código fonte como string) e output (sequência de tokens).",
                                    "Compare com fases subsequentes como análise sintática para entender o escopo.",
                                    "Anote exemplos de tokens: keywords (if, while), identificadores, operadores (+, =).",
                                    "Desenhe um diagrama simples do fluxo: código fonte → lexer → tokens → parser."
                                  ],
                                  "verification": "Crie um resumo de 3-5 frases explicando o papel da análise léxica e compartilhe com um par para feedback.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Livro-texto de compiladores (ex: 'Compilers: Principles, Techniques, and Tools'), diagrama em branco.",
                                  "tips": "Use analogia com 'ler um livro e separar palavras ignorando espaços' para fixar o conceito.",
                                  "learningObjective": "Compreender o escopo e posição da análise léxica no pipeline do compilador.",
                                  "commonMistakes": "Confundir análise léxica com sintática (lexer não verifica estrutura de frases, só palavras)."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar e Listar os Propósitos Principais",
                                  "subSteps": [
                                    "Liste os 4 propósitos principais: (1) tokenização, (2) remoção de ruído, (3) detecção de erros léxicos, (4) melhoria de eficiência.",
                                    "Para cada um, escreva uma frase curta definindo-o (ex: tokenização = quebrar em unidades mínimas de significado).",
                                    "Pesquise em fontes confiáveis para confirmar a lista e adicione sinônimos se aplicável.",
                                    "Crie uma tabela com colunas: Propósito, Descrição Breve, Exemplo.",
                                    "Priorize propósitos baseados em frequência em textos acadêmicos."
                                  ],
                                  "verification": "Produza uma lista numerada de pelo menos 4 propósitos com exemplos; revise se cobre tokenização, ruído, erros e eficiência.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Notas de aula, PDF de capítulo sobre compiladores, ferramenta de tabela (Google Sheets ou papel).",
                                  "tips": "Memorize com acrônimo 'TRED' (Tokenize, Remove noise, Error detection, Drive efficiency).",
                                  "learningObjective": "Enumerar precisamente os propósitos principais da análise léxica.",
                                  "commonMistakes": "Omitir remoção de ruído ou confundi-la com otimização semântica."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Justificar Cada Propósito com Exemplos",
                                  "subSteps": [
                                    "Para tokenização: explique como simplifica o parser (ex: 'if(x>0)' → tokens: if, (, x, >, 0, ) ).",
                                    "Para remoção de ruído: justifique ignorar espaços e comentários para focar em conteúdo (ex: remover /* comentário */).",
                                    "Para detecção de erros léxicos: descreva identificação precoce de chars inválidos, evitando processamento desnecessário.",
                                    "Para eficiência: argumente que tokens padronizados aceleram fases seguintes, reduzindo complexidade.",
                                    "Escreva 1-2 parágrafos por propósito ligando à descrição geral."
                                  ],
                                  "verification": "Escreva justificativas para cada propósito e valide com um exemplo de código fonte transformado em tokens.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Editor de texto com snippet de código exemplo, highlighter para tokens.",
                                  "tips": "Use before/after: mostre código com ruído vs. stream de tokens limpo.",
                                  "learningObjective": "Justificar cada propósito com raciocínio lógico e exemplos concretos.",
                                  "commonMistakes": "Justificativas vagas sem ligação ao compilador (ex: focar só em 'limpeza' sem eficiência)."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Sintetizar e Relacionar com o Compilador",
                                  "subSteps": [
                                    "Resuma todos os propósitos em um parágrafo coeso.",
                                    "Desenhe o pipeline do compilador destacando como lexer melhora o todo.",
                                    "Discuta cenários sem lexer (ex: parser lidando com chars crus = lento e propenso a erros).",
                                    "Crie flashcards: frente 'Propósito X?', verso 'Justificativa + exemplo'.",
                                    "Teste-se recitando a lista e justificativas em voz alta."
                                  ],
                                  "verification": "Apresente uma síntese oral ou escrita de 200 palavras cobrindo todos os propósitos e benefícios.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Flashcards (Anki app), quadro branco para pipeline.",
                                  "tips": "Pratique ensino reverso: explique para um 'aluno imaginário' para reforçar.",
                                  "learningObjective": "Integrar os propósitos em uma visão holística do compilador.",
                                  "commonMistakes": "Ignorar impacto na eficiência global do compilador."
                                }
                              ],
                              "practicalExample": "Considere o código fonte: '/* Comentário */ if (x > 0) { y = 1; }'. O lexer: remove /* Comentário */, tokeniza em: keyword:if, (, identifier:x, >, number:0, ), {, identifier:y, =, number:1, ;, }. Detecta erro se houver '@' inválido, produzindo tokens limpos para o parser, economizando tempo.",
                              "finalVerifications": [
                                "Pode listar espontaneamente os 4 propósitos principais sem consultar notas?",
                                "Justifica cada propósito com um exemplo de código fonte?",
                                "Explica como a análise léxica melhora a eficiência do compilador?",
                                "Identifica corretamente tokenização vs. remoção de ruído em um exemplo?",
                                "Descreve detecção de erros léxicos sem confundir com erros sintáticos?",
                                "Desenha o fluxo lexer → parser corretamente?"
                              ],
                              "assessmentCriteria": [
                                "Lista completa e precisa dos 4 propósitos principais (100% cobertura).",
                                "Justificativas lógicas e bem fundamentadas para cada propósito.",
                                "Uso de exemplos concretos e relevantes de código fonte.",
                                "Demonstração clara da relação com eficiência do compilador.",
                                "Ausência de confusões conceituais (ex: léxico vs. sintático).",
                                "Síntese coesa integrando todos os elementos."
                              ],
                              "crossCurricularConnections": [
                                "Linguística: Similar à análise morfológica em processamento de linguagem natural.",
                                "Processamento de Texto: Técnicas de parsing em NLP e search engines.",
                                "Engenharia de Software: Pré-processamento em pipelines de dados.",
                                "Matemática: Autômatos finitos (regex) usados em lexers."
                              ],
                              "realWorldApplication": "Em IDEs como VS Code ou IntelliJ, o lexer realça sintaxe em tempo real, detecta erros de digitação (ex: char inválido) e acelera autocompletar, permitindo desenvolvedores escreverem código mais rápido e com menos bugs."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.1.1.2.2",
                            "name": "Explicar a simplificação para análise sintática",
                            "description": "Descrever como a análise léxica reduz a complexidade do código-fonte, fornecendo tokens que servem como entrada para o parser sintático, evitando processamento de caracteres individuais.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os Fundamentos da Análise Léxica e Tokens",
                                  "subSteps": [
                                    "Defina análise léxica como o processo de dividir o código-fonte em tokens significativos, como palavras-chave, identificadores e operadores.",
                                    "Explique que tokens são unidades atômicas de significado, ignorando espaços, comentários e formatação irrelevante.",
                                    "Diferencie tokens de caracteres brutos: caracteres são bytes individuais (ex: 'i', 'f'), tokens são sequências agrupadas (ex: 'if').",
                                    "Liste tipos comuns de tokens: keywords (if, while), identifiers (variáveis), literals (números, strings), symbols (+, =).",
                                    "Descreva o papel do lexer/scanner como o primeiro estágio do compilador."
                                  ],
                                  "verification": "Escreva definições curtas para 5 tipos de tokens e identifique-os em uma linha de código simples.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Diagrama de fases do compilador",
                                    "Exemplos de código-fonte simples em C ou Python"
                                  ],
                                  "tips": [
                                    "Use analogia com divisão de texto em palavras para facilitar compreensão.",
                                    "Visualize tokens como 'palavras' em uma linguagem de programação."
                                  ],
                                  "learningObjective": "Entender o que são tokens e o papel básico da análise léxica.",
                                  "commonMistakes": [
                                    "Confundir tokens com caracteres individuais.",
                                    "Ignorar que lexer remove whitespaces e comentários."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar o Fluxo de Processamento: Fonte para Tokens",
                                  "subSteps": [
                                    "Desenhe o fluxo: código-fonte (string de chars) → lexer → stream de tokens → parser.",
                                    "Simule manualmente a tokenização de uma linha de código, agrupando chars em tokens.",
                                    "Explique como o lexer usa regras regulares ou autômatos finitos para reconhecer padrões de tokens.",
                                    "Compare entrada do parser: sem lexer (milhares de chars), com lexer (dezenas de tokens).",
                                    "Discuta como tokens incluem metadados como tipo, valor e posição no fonte."
                                  ],
                                  "verification": "Tokenize manualmente o código 'int x = 5;' e liste os tokens com tipos.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Ferramenta online de lexer (ex: JFlex demo)",
                                    "Papel e caneta para simulação manual"
                                  ],
                                  "tips": [
                                    "Comece com código simples sem comentários para evitar distrações.",
                                    "Anote posições de início/fim de cada token."
                                  ],
                                  "learningObjective": "Mapear o fluxo de entrada bruta para tokens estruturados.",
                                  "commonMistakes": [
                                    "Esquecer de classificar tipos de tokens corretamente.",
                                    "Processar whitespaces como tokens válidos."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explicar a Redução de Complexidade para Análise Sintática",
                                  "subSteps": [
                                    "Descreva a complexidade do parser sem lexer: teria que lidar com chars isolados, gerenciando estados para cada possível sequência.",
                                    "Com lexer: parser recebe tokens pré-classificados, focando apenas em gramática (estrutura de frases).",
                                    "Quantifique redução: de O(n) chars para O(m) tokens onde m << n, simplificando autômatos e tabelas de parsing.",
                                    "Ilustre com estado: parser sem lexer precisa de milhares de transições; com tokens, centenas.",
                                    "Aborde benefícios: detecção precoce de erros léxicos, otimização de performance."
                                  ],
                                  "verification": "Escreva um parágrafo comparando complexidade com e sem lexer, citando métricas qualitativas.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Artigo ou vídeo sobre fases de compilador (ex: Dragon Book capítulo)",
                                    "Gráfico comparativo de estados FSM"
                                  ],
                                  "tips": [
                                    "Use termos como 'pré-processamento' para enfatizar simplificação.",
                                    "Pense em parser como 'leitor de palavras' vs 'leitor de letras'."
                                  ],
                                  "learningObjective": "Articular como tokens simplificam o trabalho do parser sintático.",
                                  "commonMistakes": [
                                    "Subestimar o impacto na redução de estados do autômato.",
                                    "Confundir análise léxica com pré-processador."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar e Sintetizar o Conceito com Exemplos Práticos",
                                  "subSteps": [
                                    "Escolha um exemplo real: tokenização de 'while (x > 0) { ... }'.",
                                    "Simule parser recebendo chars vs tokens e note diferenças em regras.",
                                    "Discuta extensões: como lexer lida com nested comments ou strings com aspas.",
                                    "Crie uma tabela: Colunas 'Sem Lexer' vs 'Com Lexer' para complexidade, erros e performance.",
                                    "Reflita: por que essa separação é essencial em compiladores modernos."
                                  ],
                                  "verification": "Crie e explique uma tabela comparativa para um snippet de código dado.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Editor de texto com syntax highlighting",
                                    "Compilador com flags de debug lexer (ex: gcc -E)"
                                  ],
                                  "tips": [
                                    "Teste com código inválido para ver erros léxicos vs sintáticos.",
                                    "Registre tempo de processamento manual para ilustrar eficiência."
                                  ],
                                  "learningObjective": "Sintetizar benefícios da simplificação em contexto prático.",
                                  "commonMistakes": [
                                    "Focar só em exemplos válidos, ignorar edge cases.",
                                    "Não quantificar a redução de complexidade."
                                  ]
                                }
                              ],
                              "practicalExample": "Considere o código 'if (x == 5) { return true; }'. Sem lexer: parser processa ~20 chars individualmente, gerenciando aspas, parênteses e espaços. Com lexer: tokens ['if', '(', 'id:x', '==', 'int:5', ')', '{', 'return', 'bool:true', ';', '}'], reduzindo para 11 unidades. O parser agora aplica regras gramaticais simples como 'if (expr) stmt', sem se preocupar com chars brutos.",
                              "finalVerifications": [
                                "Explica corretamente tokens como entrada simplificada para parser.",
                                "Identifica pelo menos 5 tipos de tokens em um código dado.",
                                "Compara fluxos com e sem lexer, destacando redução de complexidade.",
                                "Descreve regras de tokenização para keywords e identificadores.",
                                "Cita benefícios como performance e detecção de erros.",
                                "Aplica conceito a um exemplo real sem erros."
                              ],
                              "assessmentCriteria": [
                                "Precisão conceitual: definições corretas de lexer e tokens (30%)",
                                "Profundidade na redução de complexidade: compara estados e performance (25%)",
                                "Uso de exemplos: ilustrações claras e corretas (20%)",
                                "Clareza na explicação: linguagem acessível e estruturada (15%)",
                                "Completude: cobre fluxo, benefícios e edge cases (10%)"
                              ],
                              "crossCurricularConnections": [
                                "Linguística: Similar à tokenização em análise morfológica de textos naturais.",
                                "Processamento de Linguagem Natural (PLN): Tokenizers em NLP (ex: BERT tokenizer).",
                                "Engenharia de Software: Parsers em ferramentas como ANTLR ou yacc.",
                                "Matemática: Autômatos finitos e expressões regulares."
                              ],
                              "realWorldApplication": "Em compiladores como GCC ou Clang, o lexer (cpp para pré-processamento) converte código C++ em tokens, permitindo que o parser Yacc/Bison foque em sintaxe, acelerando compilação de milhões de linhas de código em projetos como Linux kernel."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.1.1.1.1.1"
                            ]
                          },
                          {
                            "id": "10.1.1.1.1.2.3",
                            "name": "Relacionar com tratamento de erros iniciais",
                            "description": "Explicar o papel na detecção precoce de erros léxicos, como identificadores inválidos, permitindo recuperação e continuação da compilação.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender Fundamentos da Análise Léxica e Erros Léxicos",
                                  "subSteps": [
                                    "Defina análise léxica como o processo de transformar código fonte em tokens válidos ou identificar violações das regras léxicas.",
                                    "Identifique erros léxicos comuns, como identificadores iniciando com dígitos (ex: 1abc), caracteres especiais inválidos ou literais malformados.",
                                    "Explique a posição do lexer na pipeline de compilação: primeira etapa após pré-processamento.",
                                    "Diferencie erros léxicos de erros sintáticos ou semânticos."
                                  ],
                                  "verification": "Liste e descreva pelo menos 3 exemplos de erros léxicos com código fonte ilustrativo.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Documentação de linguagens como C ou Java sobre regras léxicas",
                                    "Editor de texto com syntax highlighting",
                                    "Exemplos de código fonte simples"
                                  ],
                                  "tips": "Use diagramas de fluxo da pipeline de compilação para visualizar o papel do lexer.",
                                  "learningObjective": "Dominar conceitos básicos de análise léxica e classificar erros léxicos precisamente.",
                                  "commonMistakes": [
                                    "Confundir análise léxica com análise sintática",
                                    "Subestimar a granularidade dos tokens (ex: ignorar espaços e comentários)"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar a Detecção Precoce de Erros pelo Lexer",
                                  "subSteps": [
                                    "Explique por que a análise léxica permite detecção na fase inicial, antes de parsing ou análise semântica.",
                                    "Discuta benefícios: feedback rápido ao programador e prevenção de cascades de erros posteriores.",
                                    "Examine exemplo: em 'int @variavel = 10;', o lexer detecta '@' como inválido em identificador.",
                                    "Compare cenários com e sem detecção léxica precoce."
                                  ],
                                  "verification": "Forneça um exemplo de código onde um erro léxico precoce impede erros falsos em fases posteriores.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Ferramenta lexer online como JFlex ou flex demo",
                                    "Código fonte com erros intencionais"
                                  ],
                                  "tips": "Teste códigos em um lexer real para observar mensagens de erro imediatas.",
                                  "learningObjective": "Entender e justificar a importância estratégica da detecção precoce de erros léxicos.",
                                  "commonMistakes": [
                                    "Acreditar que erros léxicos só afetam tokens isolados, ignorando impacto na compilação",
                                    "Confundir detecção com correção automática"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explorar Estratégias de Recuperação de Erros Léxicos",
                                  "subSteps": [
                                    "Descreva técnicas de recuperação: pular tokens inválidos, inserir tokens fictícios ou sincronizar no próximo delimitador.",
                                    "Analise recuperação para identificadores inválidos: reportar erro e tratar como token inválido ou pular até ';'.",
                                    "Implemente pseudocódigo simples para recuperação em um lexer.",
                                    "Avalie trade-offs: precisão vs. tolerância a erros para diagnósticos úteis."
                                  ],
                                  "verification": "Escreva pseudocódigo de um lexer que recupera de um identificador inválido e continua.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Pseudocódigo de lexers (ex: Dragon Book exemplos)",
                                    "Ferramentas como ANTLR ou flex para testes"
                                  ],
                                  "tips": "Priorize recuperação mínima para evitar mascarar múltiplos erros.",
                                  "learningObjective": "Aplicar e avaliar mecanismos de recuperação de erros no contexto léxico.",
                                  "commonMistakes": [
                                    "Recuperação agressiva que ignora erros reais",
                                    "Não considerar contexto do token para recuperação inteligente"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Relacionar Recuperação com Continuação da Compilação",
                                  "subSteps": [
                                    "Explique como recuperação léxica permite que o parser receba stream de tokens viável.",
                                    "Discuta exemplos reais: compiladores como GCC reportam erros léxicos mas compilam o resto.",
                                    "Analise impacto: diagnósticos múltiplos em uma única compilação.",
                                    "Sintetize o papel na usabilidade de ferramentas de desenvolvimento."
                                  ],
                                  "verification": "Descreva um fluxo completo: código com erro léxico → detecção → recuperação → continuação.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Logs de compilação de GCC/Clang com -Wall",
                                    "Documentação de error recovery em compiladores"
                                  ],
                                  "tips": "Compile códigos com erros em compiladores reais para observar comportamento.",
                                  "learningObjective": "Integrar detecção, recuperação e continuação no ciclo de compilação.",
                                  "commonMistakes": [
                                    "Assumir que erro léxico para toda compilação",
                                    "Ignorar configurações de verbosity em compiladores"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Sintetizar e Aplicar Conceitos em um Caso Prático",
                                  "subSteps": [
                                    "Crie um lexer simples em Python que detecta e recupera erros em identificadores.",
                                    "Teste com inputs variados: válidos, inválidos isolados e múltiplos erros.",
                                    "Avalie saída: relatórios de erro e tokens produzidos.",
                                    "Reflita sobre melhorias para cenários reais."
                                  ],
                                  "verification": "Demonstre o lexer processando código com identificador inválido e produzindo tokens parciais corretos.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Python ou JavaScript para protótipo lexer",
                                    "Exemplos de código com erros"
                                  ],
                                  "tips": "Mantenha o lexer minimalista para focar em error handling.",
                                  "learningObjective": "Construir e validar uma implementação prática relacionando conceitos.",
                                  "commonMistakes": [
                                    "Lexer muito complexo distraindo do foco em erros",
                                    "Não testar edge cases como EOF após erro"
                                  ]
                                }
                              ],
                              "practicalExample": "Considere o código fonte: 'int 1invalidVar@ = 42; printf(\"Hello\");'. O lexer detecta '1invalidVar@' como identificador inválido (inicia com dígito e tem @), reporta erro léxico, recupera pulando até ';', produz tokens para 'int', token inválido, '=', '42', ';', e continua com 'printf(\"Hello\");', permitindo análise parcial do resto.",
                              "finalVerifications": [
                                "Explicar com precisão o papel da análise léxica na detecção precoce de erros como identificadores inválidos.",
                                "Fornecer pelo menos 2 exemplos concretos de recuperação de erros léxicos.",
                                "Descrever o fluxo de continuação da compilação após recuperação.",
                                "Identificar benefícios para o desenvolvedor em termos de feedback rápido.",
                                "Implementar ou simular um lexer com error recovery básico."
                              ],
                              "assessmentCriteria": [
                                "Precisão conceitual: definições e relações corretas sem confusões (30%)",
                                "Profundidade de exemplos: práticos e relevantes (25%)",
                                "Clareza na explicação de recuperação e continuação (20%)",
                                "Aplicação prática: viabilidade de protótipos ou simulações (15%)",
                                "Análise de trade-offs e limitações (10%)"
                              ],
                              "crossCurricularConnections": [
                                "Engenharia de Software: Práticas de debugging e error handling em pipelines de build.",
                                "Matemática Discreta: Autômatos finitos e expressões regulares para reconhecimento léxico.",
                                "Lógica e Algoritmos: Estratégias de parsing robusto e sincronização de erros.",
                                "Desenvolvimento de Software: Integração em IDEs para linting em tempo real."
                              ],
                              "realWorldApplication": "Em compiladores como GCC ou Clang, a detecção e recuperação léxica permite relatar múltiplos erros em uma compilação, acelerando o ciclo de desenvolvimento. IDEs como Visual Studio usam isso para syntax highlighting e sugestões instantâneas, melhorando produtividade em projetos grandes."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.1.1.1.1.1"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "10.1.1.1.1.3",
                        "name": "Processo de Transformação e Remoção de Elementos",
                        "description": "O processo envolve a leitura sequencial do código-fonte, identificação de tokens e eliminação de espaços em branco e comentários para gerar apenas elementos relevantes.",
                        "specificSkills": [
                          {
                            "id": "10.1.1.1.1.3.1",
                            "name": "Descrever a geração de tokens",
                            "description": "Explicar o que são tokens (palavras-chave, identificadores, operadores, literais) e como o analisador léxico os produz a partir do fluxo de caracteres.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a Definição e Tipos de Tokens",
                                  "subSteps": [
                                    "Defina um token como a unidade básica de significado reconhecida pelo analisador léxico, derivada do código-fonte.",
                                    "Identifique os principais tipos: palavras-chave (ex: 'if', 'while'), identificadores (nomes de variáveis/funções), operadores (ex: '+', '=', '==') e literais (ex: números, strings).",
                                    "Explique que tokens abstraem sequências de caracteres em símbolos simbólicos para fases posteriores do compilador.",
                                    "Diferencie tokens de caracteres brutos, destacando que múltiplos caracteres formam um token.",
                                    "Liste exemplos concretos para cada tipo de token."
                                  ],
                                  "verification": "Escreva definições e liste pelo menos 3 exemplos por tipo de token corretamente.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Papel e caneta ou editor de texto simples; tabela de referência de tokens de uma linguagem como C.",
                                  "tips": "Use mnemônicos: Keywords=comandos fixos, Identifiers=nomes inventados, Operators=ações, Literals=valores constantes.",
                                  "learningObjective": "Dominar os conceitos fundamentais de tokens e suas categorias.",
                                  "commonMistakes": "Confundir identificadores com keywords ou ignorar que literais incluem strings e booleanos."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar o Fluxo de Entrada de Caracteres",
                                  "subSteps": [
                                    "Descreva o código-fonte como um fluxo contínuo de caracteres (stream) lido sequencialmente pelo lexer.",
                                    "Identifique elementos irrelevantes: espaços em branco, quebras de linha e comentários, que são removidos ou ignorados.",
                                    "Explique o papel do lexer em normalizar o stream, agrupando caracteres em potenciais tokens.",
                                    "Discuta estados iniciais do lexer, como 'modo normal' vs 'dentro de string' ou 'comentário'.",
                                    "Simule leitura manual de um trecho curto de código, marcando cada caractere."
                                  ],
                                  "verification": "Anote um stream de 20 caracteres e destaque elementos a serem removidos.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Exemplo de código-fonte curto (ex: 'int x = 5; // comentário'); régua ou marcador para simulação.",
                                  "tips": "Pense no lexer como um 'leitor veloz' que pula 'lixo' (espaços/comentários) e agrupa 'palavras'.",
                                  "learningObjective": "Entender como o input raw é preparado para tokenização.",
                                  "commonMistakes": "Subestimar o impacto de comentários aninhados ou strings com escapes."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Descrever o Processo de Geração de Tokens pelo Lexer",
                                  "subSteps": [
                                    "Explique o scanning: lexer avança no stream, matching padrões via tabela de transições ou regex.",
                                    "Detalhe reconhecimento: longest match rule para ambiguidades (ex: 'if' vs 'iff') e produção do token.",
                                    "Descreva saída: cada token tem tipo, valor léxico e possivelmente posição/linha.",
                                    "Aborde remoção: após matching, avance ponteiro e ignore delimitadores.",
                                    "Integre com pipeline: tokens alimentam o parser sintático."
                                  ],
                                  "verification": "Desenhe um fluxograma simples do processo para um exemplo dado.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Ferramenta de desenho (ex: Draw.io ou papel); pseudocódigo de um lexer simples.",
                                  "tips": "Visualize como uma máquina de estados finitos: cada char muda o estado até 'aceitar' um token.",
                                  "learningObjective": "Mapear o algoritmo passo-a-passo de stream para tokens.",
                                  "commonMistakes": "Esquecer a regra de 'longest match' ou não mencionar retorno de tokens ao parser."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar e Sintetizar o Conhecimento",
                                  "subSteps": [
                                    "Analise um código completo, listando todos os tokens gerados sequencialmente.",
                                    "Identifique e explique remoções (espaços, comentários).",
                                    "Compare com saída real de um lexer (ex: flex ou online tokenizer).",
                                    "Resuma o processo em 3-5 frases chave.",
                                    "Crie um diagrama de antes/depois: stream vs lista de tokens."
                                  ],
                                  "verification": "Gere lista de tokens para um snippet e valide contra ferramenta externa.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Lexer online (ex: para C ou JavaScript); código de teste como 'if (x > 0) { return true; }'.",
                                  "tips": "Teste com edge cases como '// comentário multiline' ou '\"string com \" escape\"'.",
                                  "learningObjective": "Integrar conceitos em uma descrição fluida e precisa.",
                                  "commonMistakes": "Listar tokens incorretos em strings ou operadores compostos (ex: '>>' como dois '>')."
                                }
                              ],
                              "practicalExample": "Para o código 'int main() { x = 42; } // fim', o lexer gera: keyword 'int', keyword 'main', '(', ')', '{', identifier 'x', '=', literal '42', ';', '}', ignorando espaços e '// fim'.",
                              "finalVerifications": [
                                "Pode definir token e listar 4 tipos com exemplos?",
                                "Explica corretamente a remoção de espaços e comentários?",
                                "Descreve o processo de matching e produção sequencial?",
                                "Identifica longest match em ambiguidades?",
                                "Liga tokens ao parser?",
                                "Simula geração para um snippet curto?"
                              ],
                              "assessmentCriteria": [
                                "Precisão nas definições de tokens e tipos (90% correto).",
                                "Descrição clara do stream de chars para tokens.",
                                "Sequência lógica do processo de scanning.",
                                "Inclusão de remoção de elementos irrelevantes.",
                                "Uso de exemplos concretos e diagramas.",
                                "Ausência de confusões comuns como chars vs tokens."
                              ],
                              "crossCurricularConnections": [
                                "Linguística: Tokens como morfemas ou palavras em análise sintática de linguagem natural.",
                                "Teoria da Computação: Máquinas de estados finitos para reconhecimento de padrões.",
                                "Processamento de Texto: Similar a tokenizers em NLP ou regex em editores.",
                                "Engenharia de Software: Parsers em ferramentas como ANTLR ou yacc."
                              ],
                              "realWorldApplication": "Em compiladores como GCC/Clang para C++, ou interpreters de Python/JavaScript, onde lexers eficientes aceleram compilação; também em editores IDE para highlighting de sintaxe e autocompletar."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.1.1.1.1.2"
                            ]
                          },
                          {
                            "id": "10.1.1.1.1.3.2",
                            "name": "Explicar remoção de espaços em branco",
                            "description": "Detalhar como espaços, tabs e quebras de linha são ignorados durante a tokenização, exceto quando fazem parte de literais como strings.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o conceito de espaços em branco",
                                  "subSteps": [
                                    "Defina espaços em branco: espaço (ASCII 32), tabulação (ASCII 9) e quebras de linha (ASCII 10 e 13).",
                                    "Identifique exemplos em código fonte: 'int x = 1;   int y = 2;' versus 'intx=1;inty=2;'.",
                                    "Explique o papel dos espaços em branco na legibilidade humana versus irrelevância para a máquina.",
                                    "Pesquise representações Unicode de whitespace para casos avançados.",
                                    "Crie uma tabela comparativa de caracteres whitespace comuns."
                                  ],
                                  "verification": "Liste corretamente pelo menos 5 caracteres whitespace com seus códigos ASCII e dê um exemplo de código com eles.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Documentação ASCII/Unicode",
                                    "Editor de texto com visualização de caracteres"
                                  ],
                                  "tips": "Use um editor que mostre caracteres invisíveis para visualizar tabs e quebras.",
                                  "learningObjective": "Identificar e classificar diferentes tipos de espaços em branco em código fonte.",
                                  "commonMistakes": [
                                    "Confundir quebras de linha com fim de token sem contexto",
                                    "Ignorar tabs como whitespace",
                                    "Achar que todos os whitespace são sempre ignorados"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Explicar o processo de remoção na tokenização",
                                  "subSteps": [
                                    "Descreva a análise léxica: scanner lê caracteres e agrupa em tokens, ignorando whitespace entre tokens.",
                                    "Simule manualmente: leia 'hello   world' → tokens ['hello', 'world'], whitespace descartado.",
                                    "Discuta o algoritmo: avance caractere por caractere, pule whitespace até encontrar não-whitespace.",
                                    "Compare com pseudocódigo de um lexer simples que usa loop while(isWhitespace(c)) skip().",
                                    "Teste com input múltiplas linhas: ignore newlines entre statements."
                                  ],
                                  "verification": "Simule tokenização de um código com excessos de whitespace e liste os tokens corretos sem eles.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Pseudocódigo de lexer básico",
                                    "Papel e caneta para simulação manual"
                                  ],
                                  "tips": "Pense no lexer como um 'limpador' que só para em conteúdo significativo.",
                                  "learningObjective": "Descrever o mecanismo de skipping de whitespace durante a fase de scanning.",
                                  "commonMistakes": [
                                    "Achar que whitespace é tokenizado como 'WHITESPACE'",
                                    "Não perceber que remoção é seletiva",
                                    "Confundir com pré-processamento"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar exceções onde whitespace é preservado",
                                  "subSteps": [
                                    "Explique literais de string: \"hello   world\" preserva espaços internos como token STRING.",
                                    "Discuta comentários: /* com   espaços */ ou // linha, mas foco em strings conforme descrição.",
                                    "Simule tokenização dentro de string: pare no delimitador, inclua todo conteúdo.",
                                    "Compare: 'int x=1' (sem ws) vs \"int x= 1\" (preserva ws dentro).",
                                    "Identifique outros casos raros: character literals como '\\t'."
                                  ],
                                  "verification": "Tokenize corretamente um código com strings contendo whitespace e explique por quê foram preservados.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Exemplos de código com strings e comentários",
                                    "Compilador online para verificação"
                                  ],
                                  "tips": "Lembre: contexto importa – dentro de string literal, whitespace é payload.",
                                  "learningObjective": "Reconhecer contextos onde whitespace não é ignorado, como literais.",
                                  "commonMistakes": [
                                    "Ignorar ws em strings",
                                    "Tratar ws em comentários como tokens",
                                    "Não diferenciar estados do lexer"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Implementar e testar um simulador simples de remoção",
                                  "subSteps": [
                                    "Escreva um script Python simples para simular lexer que remove ws exceto em strings.",
                                    "Implemente função is_whitespace(c) e estado 'in_string'.",
                                    "Teste com inputs: código com ws excessivo, strings com ws, misturado.",
                                    "Compare output com tokenização esperada.",
                                    "Debugue casos falhos, como strings escapadas."
                                  ],
                                  "verification": "Execute o script em 3 exemplos variados e produza tokens corretos sem ws externos.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Python ou similar",
                                    "Editor de código"
                                  ],
                                  "tips": "Use finite state machine mental: normal vs string mode.",
                                  "learningObjective": "Aplicar conceitualmente a remoção de ws em uma implementação prática.",
                                  "commonMistakes": [
                                    "Não alternar estados corretamente",
                                    "Remover ws dentro de strings",
                                    "Erros em escaping"
                                  ]
                                }
                              ],
                              "practicalExample": "Considere o código: 'int main() { printf(\"Hello   World\\n\"); }   // comentário'. Tokenização: [INT, MAIN, LPAREN, RPAREN, LBRACE, PRINTF, LPAREN, STRING(\"Hello   World\\n\"), RPAREN, RBRACE, COMMENT]. Ws entre tokens removidos, mas preservado na string.",
                              "finalVerifications": [
                                "Explicar por que 'a + b' e 'a+ b ' geram tokens idênticos ['a', '+', 'b'].",
                                "Identificar ws preservado em '\"spa ce\"'.",
                                "Simular tokenização manual de 10 linhas com ws excessivo.",
                                "Diferenciar tratamento de ws em lexer vs parser.",
                                "Citar 3 caracteres ws e seu impacto.",
                                "Prever tokens de código minificado vs indentado."
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição e exemplos de ws (90% correto).",
                                "Correta distinção entre ws ignorado e preservado.",
                                "Qualidade da simulação/manual tokenização (sem erros lógicos).",
                                "Implementação funcional do simulador (testes passam).",
                                "Explicação clara de exceções em literais.",
                                "Uso de terminologia técnica apropriada (token, lexer, etc.)."
                              ],
                              "crossCurricularConnections": [
                                "Linguística: Analogia com morfemas e separadores ignoráveis em fonemas.",
                                "Matemática: Padronização de expressões como remoção de parênteses redundantes.",
                                "Engenharia de Software: Otimização de código (minificação JS/CSS).",
                                "Processamento de Texto: Similar a regex \\s+ em parsing de logs."
                              ],
                              "realWorldApplication": "Em compiladores como GCC/Clang, remove ws para eficiência; em minificadores JS (UglifyJS), reduz tamanho de arquivos web; parsers de logs ignoram ws para matching padrões."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.1.1.3.3",
                            "name": "Descrever remoção de comentários",
                            "description": "Explicar o tratamento de comentários (ex.: // ou /* */) como elementos descartáveis, garantindo que não interfiram na formação de tokens.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os Tipos de Comentários na Linguagem",
                                  "subSteps": [
                                    "Estudar a sintaxe de comentários de linha, iniciados por '//' até o final da linha.",
                                    "Analisar comentários de bloco, delimitados por '/*' e '*/', que podem abranger múltiplas linhas.",
                                    "Identificar regras específicas: comentários não aninhados em blocos e precedência sobre strings.",
                                    "Revisar exemplos de código fonte para observar ocorrências reais.",
                                    "Diferenciar comentários de outros elementos como strings literais."
                                  ],
                                  "verification": "Criar uma tabela comparativa dos dois tipos de comentários com exemplos.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Documentação da linguagem de programação (ex: C/C++ manual)",
                                    "Editor de texto com exemplos de código"
                                  ],
                                  "tips": "Use cores de sintaxe no editor para visualizar comentários claramente.",
                                  "learningObjective": "Diferenciar precisamente comentários de linha e bloco, entendendo suas regras sintáticas.",
                                  "commonMistakes": [
                                    "Confundir comentários de bloco com strings multiline",
                                    "Ignorar que comentários de linha terminam no fim da linha",
                                    "Assumir aninhamento em comentários de bloco"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar Detecção e Remoção de Comentários de Linha",
                                  "subSteps": [
                                    "No scanner léxico, verificar se o caractere atual é '/' seguido de '/' ao ler o input.",
                                    "Ao detectar '//', consumir caracteres até encontrar o caractere de nova linha ('\\n') ou fim do arquivo.",
                                    "Descartar os caracteres consumidos sem gerar tokens.",
                                    "Reiniciar o processo de tokenização após o comentário.",
                                    "Tratar casos edge como '//' no meio de uma linha com código válido antes."
                                  ],
                                  "verification": "Testar com código contendo '// comentário' e confirmar que não gera tokens para o comentário.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Pseudocódigo de scanner léxico",
                                    "Ferramenta de teste como Flex ou editor com debugger"
                                  ],
                                  "tips": "Implemente em pseudocódigo primeiro para visualizar o fluxo de controle.",
                                  "learningObjective": "Desenvolver lógica para ignorar comentários de linha durante a formação de tokens.",
                                  "commonMistakes": [
                                    "Parar de consumir após o primeiro '/', sem verificar o segundo",
                                    "Gerar token vazio após remoção",
                                    "Não tratar EOF dentro do comentário"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar Detecção e Remoção de Comentários de Bloco",
                                  "subSteps": [
                                    "Verificar sequencialmente '/' seguido de '*' para iniciar detecção de bloco.",
                                    "Ao detectar '/*', consumir caracteres até encontrar '*/', pulando qualquer conteúdo interno.",
                                    "Contabilizar corretamente o par '*/' sem aninhamento, consumindo até o primeiro fechamento.",
                                    "Tratar casos de bloco multiline e bloco em uma única linha.",
                                    "Integrar com detecção de linha: priorizar bloco sobre linha se '/' seguido de '*'.",
                                    "Reiniciar tokenização após '*/'."
                                  ],
                                  "verification": "Aplicar em código com /* comentário multiline */ e verificar ausência de tokens para o bloco.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Exemplos de código com comentários de bloco",
                                    "Simulador de scanner ou código fonte de compilador open-source"
                                  ],
                                  "tips": "Use um loop while para consumir até encontrar '*/', verificando pares de caracteres.",
                                  "learningObjective": "Criar mecanismo robusto para remover comentários de bloco sem interferir em tokens.",
                                  "commonMistakes": [
                                    "Permitir aninhamento não suportado",
                                    "Confundir '*/' dentro de strings",
                                    "Não consumir após '/*' em EOF"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Integrar Remoção de Comentários no Fluxo de Análise Léxica e Testar",
                                  "subSteps": [
                                    "Incorporar lógica de comentários no loop principal do scanner léxico.",
                                    "Priorizar verificações: bloco > linha > outros tokens.",
                                    "Testar interações com strings, identificadores e outros elementos.",
                                    "Executar testes unitários com códigos variados contendo ambos tipos de comentários.",
                                    "Analisar output de tokens para garantir que comentários foram removidos corretamente.",
                                    "Otimizar para eficiência, evitando backtracking desnecessário."
                                  ],
                                  "verification": "Gerar lista de tokens de um código completo e confirmar ausência de comentários nos tokens.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Suite de testes com códigos edge cases",
                                    "Ferramenta de linting ou debugger léxico"
                                  ],
                                  "tips": "Crie casos de teste automatizados para regressão rápida.",
                                  "learningObjective": "Garantir que remoção de comentários preserve integridade da tokenização geral.",
                                  "commonMistakes": [
                                    "Remover acidentalmente conteúdo de strings que se parecem com comentários",
                                    "Priorizar incorretamente tipos de comentários",
                                    "Deixar resíduo de caracteres após remoção"
                                  ]
                                }
                              ],
                              "practicalExample": "Código de entrada: int main() { // Isso é um comentário de linha\n   /* Comentário\n   de bloco multiline */ printf(\"Olá\"); }\nSaída de tokens após remoção: [int, main, (, ), {, printf, (, \"Olá\", ), ;, }]",
                              "finalVerifications": [
                                "Explicar verbalmente o processo de remoção para um código com ambos tipos de comentários.",
                                "Identificar e remover manualmente comentários de um trecho de código fornecido.",
                                "Implementar um scanner simples que ignore comentários e gere tokens corretos.",
                                "Detectar erros em um scanner buggy que falha na remoção de blocos multiline.",
                                "Comparar output de tokens antes e após implementação da remoção.",
                                "Discutir impacto na formação de tokens se comentários não forem removidos."
                              ],
                              "assessmentCriteria": [
                                "Precisão na detecção de ambos tipos de comentários (100% de acerto em testes).",
                                "Completude da lógica: tratamento de edge cases como EOF e multiline.",
                                "Eficiência: tempo de execução linear no tamanho do input.",
                                "Correção na integração: tokens adjacentes preservados sem interferência.",
                                "Clareza na explicação do processo e justificativa das regras.",
                                "Robustez: não remover conteúdo de strings ou outros tokens válidos."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Modelagem com autômatos finitos para estados de detecção de comentários.",
                                "Língua Portuguesa: Análise sintática de texto e parsing de estruturas delimitadas.",
                                "Programação Geral: Higiene de código e práticas de edição em IDEs.",
                                "Engenharia de Software: Tratamento de input não essencial em parsers."
                              ],
                              "realWorldApplication": "Em compiladores como GCC ou Clang, a remoção de comentários garante que apenas código executável forme tokens, permitindo análise eficiente em projetos reais como kernels de SO ou aplicativos web, evitando erros de parsing e otimizando performance."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.1.2",
                    "name": "Classes de Tokens",
                    "description": "Identificação de tokens como palavras-chave, identificadores, literais, operadores e símbolos de pontuação.",
                    "individualConcepts": [
                      {
                        "id": "10.1.1.2.1",
                        "name": "Palavras-chave",
                        "description": "Palavras reservadas na linguagem de programação que possuem significado pré-definido pelo compilador e não podem ser utilizadas como nomes de variáveis ou funções.",
                        "specificSkills": [
                          {
                            "id": "10.1.1.2.1.1",
                            "name": "Definir palavras-chave",
                            "description": "Explicar o conceito de palavras-chave na análise léxica, destacando que elas são tokens fixos reconhecidos pelo analisador léxico, como 'if', 'else', 'int' e 'while' em linguagens como C ou Java.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o Conceito Básico de Análise Léxica e Tokens",
                                  "subSteps": [
                                    "Estude a definição de análise léxica como o processo inicial de um compilador que divide o código-fonte em tokens.",
                                    "Aprenda que tokens são as unidades mínimas de significado, como identificadores, operadores e palavras-chave.",
                                    "Identifique o papel do analisador léxico (lexer) em escanear o código caractere por caractere.",
                                    "Revise exemplos de tokens em linguagens como C: 'int', '+', 'main'.",
                                    "Anote a importância de palavras-chave como tokens fixos e reservados."
                                  ],
                                  "verification": "Escreva um parágrafo resumindo análise léxica e dê 3 exemplos de tokens.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Documentação oficial de compiladores (ex: Dragon Book capítulo 3)",
                                    "Exemplos de código fonte em C ou Java"
                                  ],
                                  "tips": [
                                    "Comece com fluxogramas do processo de tokenização para visualização clara."
                                  ],
                                  "learningObjective": "Dominar os fundamentos da análise léxica e identificar tokens básicos.",
                                  "commonMistakes": [
                                    "Confundir análise léxica com análise sintática (parsing).",
                                    "Achar que todos os tokens são variáveis."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar e Listar Exemplos de Palavras-Chave",
                                  "subSteps": [
                                    "Pesquise listas de palavras-chave em C: 'if', 'else', 'int', 'while', 'return'.",
                                    "Compare com Java: 'public', 'class', 'void', 'for', 'boolean'.",
                                    "Classifique palavras-chave por categoria: controle de fluxo ('if', 'while'), tipos ('int', 'float'), etc.",
                                    "Crie uma tabela comparativa entre 2 linguagens.",
                                    "Memorize pelo menos 10 palavras-chave comuns."
                                  ],
                                  "verification": "Liste 8 palavras-chave de C e explique o propósito de 3 delas.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Referência de sintaxe C (cppreference.com)",
                                    "Documentação Java (Oracle docs)"
                                  ],
                                  "tips": [
                                    "Use mnemônicos para lembrar grupos, como 'if-else-while' para controle."
                                  ],
                                  "learningObjective": "Reconhecer e categorizar palavras-chave em linguagens específicas.",
                                  "commonMistakes": [
                                    "Incluir identificadores como 'main' como keywords.",
                                    "Ignorar variações case-sensitive."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Diferenciar Palavras-Chave de Outros Tokens como Identificadores",
                                  "subSteps": [
                                    "Defina identificadores como nomes definidos pelo programador (ex: 'minhaVar').",
                                    "Explique que palavras-chave são reservadas e não podem ser usadas como identificadores.",
                                    "Analise exemplos: 'int' é keyword, mas 'minhaInt' é identificador.",
                                    "Estude regras de reconhecimento: correspondência exata, case-sensitivity.",
                                    "Simule tokenização manual de trechos de código."
                                  ],
                                  "verification": "Classifique 10 tokens de um código amostra como keyword ou identificador.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Editor de texto com syntax highlighting",
                                    "Snippets de código C/Java"
                                  ],
                                  "tips": [
                                    "Teste em um IDE para ver highlighting imediato de keywords."
                                  ],
                                  "learningObjective": "Distinguir precisamente palavras-chave de identificadores e outros tokens.",
                                  "commonMistakes": [
                                    "Permitir uso de keywords como variáveis.",
                                    "Confundir com literais de string."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Explorar o Processo de Reconhecimento de Palavras-Chave no Lexer",
                                  "subSteps": [
                                    "Descreva o algoritmo: buffer de caracteres, matching exato com tabela de keywords.",
                                    "Implemente pseudocódigo para checar se uma sequência é keyword.",
                                    "Discuta tratamento de case: geralmente case-sensitive em C/Java.",
                                    "Analise erros comuns como keywords parciais (ex: 'if' vs 'iff').",
                                    "Teste com ferramenta online de lexer (ex: JFlex demo)."
                                  ],
                                  "verification": "Escreva pseudocódigo simples para reconhecer 'int' como keyword.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Pseudocódigo templates",
                                    "Ferramentas online como regex101 para matching"
                                  ],
                                  "tips": [
                                    "Use tabelas hash para lookup eficiente em implementações reais."
                                  ],
                                  "learningObjective": "Entender mecanicamente como o lexer detecta palavras-chave.",
                                  "commonMistakes": [
                                    "Ignorar contexto (ex: keywords em comentários).",
                                    "Não considerar longest match rule."
                                  ]
                                }
                              ],
                              "practicalExample": "Em um lexer para C, ao escanear 'int x = 5;', a sequência 'int' é matched exatamente contra a tabela de keywords, emitindo TOKEN_INT, enquanto 'x' vai para TOKEN_ID.",
                              "finalVerifications": [
                                "Liste corretamente 10 palavras-chave de C ou Java sem erros.",
                                "Explique a diferença entre 'if' (keyword) e 'If' em linguagens case-sensitive.",
                                "Simule tokenização de um trecho de código com pelo menos 3 keywords.",
                                "Identifique por que 'while' não pode ser usado como nome de variável.",
                                "Descreva o processo de lookup de keyword em um lexer."
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição: 100% correta sem confusões com outros tokens.",
                                "Exemplos relevantes: Pelo menos 5 keywords com contextos corretos.",
                                "Diferenciação clara: Sem sobreposição entre keywords e identificadores.",
                                "Compreensão processual: Descreve corretamente o matching no lexer.",
                                "Aplicação prática: Tokeniza código simples sem erros."
                              ],
                              "crossCurricularConnections": [
                                "Linguística: Palavras reservadas semelhantes a vocabulário fixo em gramáticas naturais.",
                                "Matemática: Linguagens regulares e autômatos finitos para reconhecimento de keywords.",
                                "Programação: Uso em syntax highlighting de IDEs como VS Code.",
                                "Engenharia de Software: Importância em parsers de DSLs e scripts."
                              ],
                              "realWorldApplication": "Em compiladores como GCC ou Javac, palavras-chave garantem parsing correto, previnem erros semânticos e habilitam features como autocompletar em IDEs, impactando desenvolvimento de software diário."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.2.1.2",
                            "name": "Listar exemplos de palavras-chave",
                            "description": "Identificar e listar palavras-chave comuns em linguagens de programação, explicando seu papel na estrutura da linguagem, como controle de fluxo ou declaração de tipos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender o conceito de palavras-chave em linguagens de programação",
                                  "subSteps": [
                                    "Defina palavras-chave como identificadores reservados pela linguagem que têm significados especiais e não podem ser usados como nomes de variáveis ou funções.",
                                    "Explique que elas são reconhecidas durante a análise léxica no compilador.",
                                    "Diferencie palavras-chave de identificadores comuns e literais.",
                                    "Discuta por que elas são case-sensitive em linguagens como C ou Java.",
                                    "Pesquise a lista oficial de palavras-chave em uma linguagem de referência, como C."
                                  ],
                                  "verification": "Escreva uma definição precisa de palavras-chave e cite pelo menos 3 exemplos iniciais de C (ex: if, int, while).",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Documentação oficial da linguagem C (padrão ANSI C)",
                                    "Notebook para anotações",
                                    "Editor de texto simples"
                                  ],
                                  "tips": [
                                    "Use fontes oficiais como cppreference.com para evitar confusões com extensões de compiladores.",
                                    "Anote diferenças entre linguagens para reforçar o aprendizado."
                                  ],
                                  "learningObjective": "Compreender o papel fundamental das palavras-chave na estrutura sintática de linguagens de programação.",
                                  "commonMistakes": [
                                    "Confundir palavras-chave com funções da biblioteca padrão (ex: printf não é keyword).",
                                    "Ignorar sensibilidade a maiúsculas/minúsculas."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar e categorizar palavras-chave comuns",
                                  "subSteps": [
                                    "Liste categorias principais: declaração de tipos (int, float), controle de fluxo (if, else, for, while), modificadores (static, const), estrutura de programas (main, return).",
                                    "Selecione uma linguagem exemplo (C) e agrupe 10-15 palavras-chave por categoria.",
                                    "Compare com outra linguagem (ex: Python: def, class, if, for) para notar similaridades.",
                                    "Crie uma tabela com colunas: Categoria, Keyword, Linguagem.",
                                    "Explique como o analisador léxico as tokeniza como TOKEN_KEYWORD."
                                  ],
                                  "verification": "Crie uma tabela com pelo menos 3 categorias e 5 keywords cada, explicando uma função por categoria.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Planilha ou tabela em Markdown/Google Sheets",
                                    "Referências: cppreference.com para C, docs.python.org para Python"
                                  ],
                                  "tips": [
                                    "Comece com categorias amplas para facilitar memorização.",
                                    "Use cores para diferenciar categorias na tabela."
                                  ],
                                  "learningObjective": "Classificar palavras-chave por função na estrutura da linguagem.",
                                  "commonMistakes": [
                                    "Listar funções built-in como keywords (ex: print em Python).",
                                    "Omitir keywords menos comuns como 'auto' ou 'register' em C."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explicar o papel das palavras-chave com exemplos de código",
                                  "subSteps": [
                                    "Para cada categoria, escreva um snippet de código mínimo demonstrando o uso (ex: if-else para controle de fluxo).",
                                    "Analise como o compilador interpreta: keyword → token → sintaxe.",
                                    "Teste snippets em um compilador online para ver erros se usadas como identificadores.",
                                    "Discuta evoluções: keywords adicionadas em versões (ex: auto em C++11).",
                                    "Crie flashcards com keyword, categoria e exemplo."
                                  ],
                                  "verification": "Compile e execute 3 snippets válidos e 1 inválido (usando keyword como variável), documentando erros.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Compilador online como Replit ou Godbolt.org",
                                    "Editor de código (VS Code)",
                                    "Flashcard app como Anki"
                                  ],
                                  "tips": [
                                    "Mantenha snippets curtos (menos de 10 linhas) para foco.",
                                    "Copie erros de compilação para estudo."
                                  ],
                                  "learningObjective": "Associar palavras-chave a seus papéis concretos via exemplos práticos.",
                                  "commonMistakes": [
                                    "Escrever código inválido sem testar.",
                                    "Confundir keywords com operadores (ex: && não é keyword)."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Praticar listagem e verificação em múltiplas linguagens",
                                  "subSteps": [
                                    "Liste 20 keywords de C e 15 de Python, categorizando-as.",
                                    "Crie um quiz auto-aplicado: embaralhe e identifique categoria/papel.",
                                    "Compare com Java ou outra linguagem para padrões comuns.",
                                    "Simule análise léxica: dado um código, destaque keywords.",
                                    "Revise lista oficial e adicione 3 keywords obscuras por linguagem."
                                  ],
                                  "verification": "Responda corretamente a um quiz de 20 itens sobre keywords e seus papéis.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Quiz gerado em papel ou Google Forms",
                                    "Códigos de exemplo de múltiplas linguagens"
                                  ],
                                  "tips": [
                                    "Use mnemônicos para grupos (ex: 'I F W S' para if, for, while, switch).",
                                    "Teste em linguagens diferentes para generalização."
                                  ],
                                  "learningObjective": "Dominar listagem fluida e explicação contextual de palavras-chave.",
                                  "commonMistakes": [
                                    "Memorizar sem categorizar, levando a esquecimento rápido.",
                                    "Ignorar variações entre dialetos (ex: keywords em C99 vs C11)."
                                  ]
                                }
                              ],
                              "practicalExample": "Em C, palavras-chave como 'int' (declaração de tipo), 'if' (controle de fluxo), 'for' (loop), 'return' (saída de função). Exemplo de código: int main() { if (1) { for(int i=0; i<5; i++) return 0; } } – Aqui, o lexer identifica 'int', 'if', 'for', 'return' como tokens de keyword.",
                              "finalVerifications": [
                                "Liste pelo menos 15 palavras-chave de C com categorias corretas.",
                                "Explique o papel de 5 keywords em controle de fluxo com exemplos.",
                                "Identifique erros em código onde keywords são usadas como variáveis.",
                                "Compare 5 keywords comuns entre C e Python.",
                                "Simule tokenização de um snippet curto destacando keywords.",
                                "Crie uma tabela completa de categorias sem consultar referências."
                              ],
                              "assessmentCriteria": [
                                "Precisão na listagem (nomes exatos, sem built-ins confundidos).",
                                "Correta categorização por função (controle de fluxo, tipos, etc.).",
                                "Explicações claras do papel na estrutura da linguagem.",
                                "Uso de exemplos de código válidos e análise de erros.",
                                "Generalização para múltiplas linguagens.",
                                "Completude da tabela/quiz (cobertura de 80% das keywords principais)."
                              ],
                              "crossCurricularConnections": [
                                "Linguística: Similar a palavras reservadas em gramáticas naturais.",
                                "Matemática: Lógica booleana em keywords de controle de fluxo (if, while).",
                                "Inglês: Compreensão de termos técnicos em documentação.",
                                "História da Computação: Evolução de keywords desde Fortran.",
                                "Design de Software: Escolha de keywords em DSLs (Domain-Specific Languages)."
                              ],
                              "realWorldApplication": "Desenvolvedores usam esse conhecimento para evitar erros de sintaxe, criar parsers personalizados em ferramentas como IDEs (ex: VS Code syntax highlighting), e contribuir em compiladores open-source como GCC, onde análise léxica depende de reconhecimento preciso de keywords."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.2.1.3",
                            "name": "Diferenciar palavras-chave de identificadores",
                            "description": "Comparar palavras-chave com identificadores, enfatizando que palavras-chave não podem ser redefinidas pelo programador e são tratadas como tokens especiais pelo lexer.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o conceito de palavras-chave",
                                  "subSteps": [
                                    "Defina palavras-chave como tokens reservados na linguagem de programação.",
                                    "Liste exemplos comuns como 'if', 'while', 'int' em linguagens como C ou Python.",
                                    "Explique que o lexer as reconhece como tokens especiais independentes do contexto.",
                                    "Note que palavras-chave não podem ser usadas como nomes de variáveis ou funções.",
                                    "Pesquise a lista oficial de palavras-chave para uma linguagem específica (ex: Python)."
                                  ],
                                  "verification": "Crie uma lista de pelo menos 5 palavras-chave e justifique por que elas são reservadas.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Documentação oficial da linguagem (ex: Python docs)",
                                    "Editor de texto simples"
                                  ],
                                  "tips": "Sempre consulte a especificação da linguagem para listas atualizadas de keywords.",
                                  "learningObjective": "Identificar e definir palavras-chave como tokens fixos e imutáveis pelo programador.",
                                  "commonMistakes": [
                                    "Confundir com funções built-in que podem ser sobrescritas",
                                    "Ignorar case-sensitivity em algumas linguagens"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Compreender o conceito de identificadores",
                                  "subSteps": [
                                    "Defina identificadores como nomes criados pelo programador para variáveis, funções etc.",
                                    "Descreva regras: começam com letra ou underscore, seguem com alfanuméricos.",
                                    "Diferencie de keywords: podem ser redefinidos e não são tokens especiais.",
                                    "Examine como o lexer os trata: sequências de caracteres válidos não-keywords.",
                                    "Teste criando identificadores que coincidam com keywords em maiúsculas (se aplicável)."
                                  ],
                                  "verification": "Gere 5 identificadores válidos e explique por que não são keywords.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Regras de sintaxe da linguagem",
                                    "Compilador ou interpretador online"
                                  ],
                                  "tips": "Verifique regras de nomenclatura específicas da linguagem para evitar erros.",
                                  "learningObjective": "Reconhecer identificadores como entidades mutáveis definidas pelo usuário.",
                                  "commonMistakes": [
                                    "Usar keywords como identificadores sem aspas",
                                    "Esquecer regras de comprimento máximo"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Comparar e contrastar palavras-chave e identificadores",
                                  "subSteps": [
                                    "Crie uma tabela comparativa: reserva, redefinição, tratamento pelo lexer.",
                                    "Analise diferenças no processo de tokenização: keywords como TOKEN_KEYWORD vs IDENTIFIER.",
                                    "Discuta impactos: erro de sintaxe se keyword usada como identificador.",
                                    "Examine exceções: namespaces ou qualificadores em linguagens avançadas.",
                                    "Simule tokenização manual de um trecho de código misto."
                                  ],
                                  "verification": "Preencha uma tabela de comparação com 4 critérios chave e 3 exemplos.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Planilha ou papel para tabela",
                                    "Exemplos de código fonte"
                                  ],
                                  "tips": "Use diagramas de fluxo para visualizar o processo de decisão do lexer.",
                                  "learningObjective": "Diferenciar precisamente keywords de identificadores no fluxo léxico.",
                                  "commonMistakes": [
                                    "Achar que identificadores são sempre tokens fixos",
                                    "Ignorar contexto de case em linguagens como Pascal"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar diferenciação em análise de código real",
                                  "subSteps": [
                                    "Pegue um código fonte simples e anote todos os tokens como keyword ou identifier.",
                                    "Compile ou execute o código alterando um identifier para keyword e observe erros.",
                                    "Use um lexer online ou ferramenta para validar sua análise manual.",
                                    "Crie um código com identificadores semelhantes a keywords (ex: If vs if).",
                                    "Documente lições aprendidas sobre ambiguidade léxica."
                                  ],
                                  "verification": "Analise um código de 20 linhas e classifique corretamente 100% dos tokens relevantes.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Código fonte exemplo (ex: hello world com loops)",
                                    "Ferramenta lexer online como replit ou flex demo"
                                  ],
                                  "tips": "Comece com códigos simples para construir confiança antes de complexos.",
                                  "learningObjective": "Aplicar conceitos na prática para tokenizar código corretamente.",
                                  "commonMistakes": [
                                    "Classificar built-ins como keywords imutáveis",
                                    "Não considerar strings ou comentários"
                                  ]
                                }
                              ],
                              "practicalExample": "Em Python: 'if x == 0:' – 'if' é keyword (token especial, não redefinível), 'x' é identifier (pode ser x = 5). Tente: if = 1 → SyntaxError, pois keyword não pode ser atribuída.",
                              "finalVerifications": [
                                "Liste 5 keywords e 5 identifiers de um código exemplo sem erros.",
                                "Explique por que 'while' não pode ser uma variável.",
                                "Tokenize manualmente: int main() { int x; } identificando todos.",
                                "Identifique erro em: for = 10; print(for).",
                                "Diferencie 'def' (keyword) de 'def_var' (identifier).",
                                "Confirme com lexer que keywords são tokens únicos."
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição e exemplos de keywords vs identifiers (90%+ correto).",
                                "Capacidade de criar tabela comparativa completa e precisa.",
                                "Análise correta de código real com classificação de tokens.",
                                "Identificação de erros comuns em tentativas de redefinição de keywords.",
                                "Explicação clara do papel do lexer na diferenciação.",
                                "Uso de exemplos concretos em todas as respostas."
                              ],
                              "crossCurricularConnections": [
                                "Linguística: Analogia com palavras reservadas em gramáticas naturais.",
                                "Programação Geral: Impacto em sintaxe e depuração de código.",
                                "Matemática: Teoria de linguagens formais e autômatos finitos no lexer.",
                                "Design de Software: Escolha de nomes em APIs para evitar conflitos com keywords."
                              ],
                              "realWorldApplication": "Em compiladores como GCC ou interpretadores Python, o lexer usa essa diferenciação para parsing eficiente; editores como VS Code highlight keywords em cores fixas vs identifiers customizáveis, auxiliando desenvolvedores a evitar erros de sintaxe."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.1.2.2",
                        "name": "Identificadores",
                        "description": "Sequências de caracteres usadas para nomear variáveis, funções e outros elementos programáveis, seguindo regras específicas de formação definidas pela linguagem.",
                        "specificSkills": [
                          {
                            "id": "10.1.1.2.2.1",
                            "name": "Definir identificadores",
                            "description": "Descrever identificadores como tokens variáveis compostos por letras, dígitos e underscores, iniciando sempre por letra ou underscore, sem coincidir com palavras-chave.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os componentes básicos de um identificador",
                                  "subSteps": [
                                    "Identifique os caracteres permitidos: letras (a-z, A-Z), dígitos (0-9) e underscore (_).",
                                    "Revise exemplos de cada componente em contextos reais de programação.",
                                    "Diferencie entre caracteres alfanuméricos e especiais.",
                                    "Crie uma tabela listando caracteres válidos e inválidos.",
                                    "Explique por que apenas esses caracteres são usados em identificadores."
                                  ],
                                  "verification": "Crie uma lista de 10 caracteres e classifique cada um como válido ou inválido para identificadores.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Papel e caneta ou editor de texto simples",
                                  "tips": "Use convenções de nomenclatura como camelCase para visualizar melhor.",
                                  "learningObjective": "Dominar os caracteres constituintes de identificadores.",
                                  "commonMistakes": "Confundir hífen (-) ou ponto (.) com underscore (_)."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Aprender as regras de formação e início do identificador",
                                  "subSteps": [
                                    "Memorize a regra principal: deve iniciar com letra ou underscore.",
                                    "Teste exemplos: valide 'var1' (válido), '1var' (inválido), '_var' (válido).",
                                    "Escreva uma expressão regular simples para capturar identificadores iniciais.",
                                    "Analise comprimento máximo típico (ex: 31 caracteres em algumas linguagens).",
                                    "Pratique convertendo nomes inválidos em válidos."
                                  ],
                                  "verification": "Gere 5 exemplos de identificadores e justifique a validade de cada um.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Editor de texto com suporte a regex (ex: VS Code)",
                                  "tips": "Sempre teste o primeiro caractere separadamente.",
                                  "learningObjective": "Aplicar regras de início e formação sequencial.",
                                  "commonMistakes": "Permitir início com dígito, comum em linguagens não estritas."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Diferenciar identificadores de palavras-chave",
                                  "subSteps": [
                                    "Liste palavras-chave comuns (ex: if, while, int em C).",
                                    "Compare sintaxe: identificadores não podem ser idênticos a keywords.",
                                    "Crie um conjunto de regras para checagem de conflito.",
                                    "Simule um scanner que rejeita identificadores matching keywords.",
                                    "Pesquise keywords de pelo menos duas linguagens (Python, Java)."
                                  ],
                                  "verification": "Classifique 10 tokens como identificador ou keyword com justificativa.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Documentação de linguagens de programação online",
                                  "tips": "Keywords são case-sensitive em muitas linguagens; verifique.",
                                  "learningObjective": "Distinguir tokens variáveis de reservados.",
                                  "commonMistakes": "Ignorar case-sensitivity, tratando 'If' como keyword diferente de 'if'."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Praticar definição em contexto de análise léxica",
                                  "subSteps": [
                                    "Escreva pseudocódigo para um lexer que reconhece identificadores.",
                                    "Implemente uma regex completa: /^[a-zA-Z_][a-zA-Z0-9_]*$/",
                                    "Teste com strings de input contendo identificadores misturados.",
                                    "Debugue casos edge: identificadores vazios ou com caracteres especiais.",
                                    "Documente o processo em um fluxograma simples."
                                  ],
                                  "verification": "Desenvolva um script simples que valide 20 identificadores de teste.",
                                  "estimatedTime": "40 minutos",
                                  "materials": "Ambiente de programação (Python ou JavaScript REPL)",
                                  "tips": "Use ferramentas online como regex101.com para testes rápidos.",
                                  "learningObjective": "Integrar definição em um analisador léxico básico.",
                                  "commonMistakes": "Regex muito permissiva, aceitando starts com dígitos."
                                }
                              ],
                              "practicalExample": "Em um lexer para uma linguagem fictícia 'MiniLang', defina identificadores para variáveis como 'userName', '_temp', 'score123'. O lexer deve rejeitar '123score', 'user-name' e 'if' (keyword), tokenizando corretamente em um input como: 'let userName = 10; if (true) {}'",
                              "finalVerifications": [
                                "Pode listar corretamente todos os caracteres permitidos e suas restrições.",
                                "Valida 100% de 20 exemplos de identificadores válidos/inválidos.",
                                "Distingue identificadores de keywords em pelo menos 3 linguagens.",
                                "Escreve uma regex precisa para matching de identificadores.",
                                "Implementa um validador simples sem erros em casos edge.",
                                "Explica o impacto de regras em compiladores reais."
                              ],
                              "assessmentCriteria": [
                                "Precisão na descrição de componentes (letras, dígitos, _): 20%",
                                "Correta aplicação de regra de início: 20%",
                                "Diferenciação clara de keywords: 20%",
                                "Qualidade da regex ou pseudocódigo: 20%",
                                "Profundidade em exemplos e verificações: 10%",
                                "Clareza na documentação e avoidance de erros comuns: 10%"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Expressões regulares e autômatos finitos.",
                                "Linguística: Sintaxe e morfologia de tokens em linguagens formais.",
                                "Programação: Nomenclatura de variáveis em múltiplas linguagens.",
                                "Lógica: Regras de validação e detecção de conflitos."
                              ],
                              "realWorldApplication": "Em compiladores e interpretadores (ex: GCC, Python lexer), identificadores definem nomes de variáveis, funções e classes, garantindo código legível e sem ambiguidades com comandos reservados, essencial para desenvolvimento de software robusto."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.2.2.2",
                            "name": "Aplicar regras de formação de identificadores",
                            "description": "Analisar regras como comprimento máximo, caracteres permitidos e sensibilidade a maiúsculas/minúsculas, validando exemplos como 'var1' (válido) e '2var' (inválido).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Memorizar as regras padrão de formação de identificadores",
                                  "subSteps": [
                                    "Leia e anote a regra 1: Identificador deve iniciar com letra (a-z, A-Z) ou underscore (_).",
                                    "Leia e anote a regra 2: Após o primeiro caractere, pode conter letras, dígitos (0-9) ou underscore.",
                                    "Leia e anote a regra 3: Comprimento máximo de 32 caracteres.",
                                    "Leia e anote a regra 4: Sensível a maiúsculas/minúsculas (case-sensitive), mas isso não afeta a validade de formação.",
                                    "Repita as regras em voz alta 3 vezes para fixação."
                                  ],
                                  "verification": "Escreva as 4 regras de memória sem consultar notas; compare com a fonte original.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Referência de regras de identificadores (ex: manual de uma linguagem como C ou Python)"
                                  ],
                                  "tips": "Use mnemônicos como 'Letra ou Underline inicia, Letras/Dígitos/Underline seguem' (LU-LDU).",
                                  "learningObjective": "Internalizar as regras exatas para aplicação imediata.",
                                  "commonMistakes": [
                                    "Confundir com regras de números (permitir início com dígito)",
                                    "Ignorar limite de comprimento",
                                    "Esquecer underscore como válido no início"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Classificar caracteres permitidos e proibidos",
                                  "subSteps": [
                                    "Liste 5 caracteres válidos para posição inicial: a, A, _, b, Z.",
                                    "Liste 5 caracteres válidos para posições subsequentes: 1, x, _, 9, Y.",
                                    "Liste 5 caracteres inválidos em qualquer posição: @, $, #, espaço, ponto.",
                                    "Crie uma tabela dividindo: Inicial | Válido | Inválido; Subsequente | Válido | Inválido.",
                                    "Teste com exemplos mistos como '_abc1' e 'a#bc'."
                                  ],
                                  "verification": "Classifique corretamente 10 caracteres aleatórios em posições inicial e subsequente.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Planilha ou papel para tabela",
                                    "Lista de caracteres ASCII comuns"
                                  ],
                                  "tips": "Pense em identificadores como 'nomes de variáveis': começam como nomes próprios ou sublinhados.",
                                  "learningObjective": "Distinguir precisamente caracteres por posição no identificador.",
                                  "commonMistakes": [
                                    "Permitir dígitos no início",
                                    "Confundir hífen (-) com underscore (_)",
                                    "Achar acentos válidos sem especificação"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Validar exemplos práticos de identificadores",
                                  "subSteps": [
                                    "Pegue 'var1': Verifique início (v=letra), corpo (a,r,1=letras/dígitos), comprimento (<32) → Válido.",
                                    "Pegue '2var': Verifique início (2=dígito) → Inválido; explique razão.",
                                    "Pegue 'my_variable_123': Verifique todas regras → Válido.",
                                    "Pegue 'a@bc': Detecte @ inválido → Inválido.",
                                    "Valide 5 exemplos adicionais fornecidos ou criados."
                                  ],
                                  "verification": "Valide um conjunto de 8 exemplos mistos (4 válidos, 4 inválidos) com explicação por regra violada/cumprida.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Lista de 10 exemplos de teste: válidos ('var1', '_id', 'UserName42') e inválidos ('2var', 'var@', 'a b c')"
                                  ],
                                  "tips": "Sempre comece pela posição inicial, depois corpo, depois comprimento.",
                                  "learningObjective": "Aplicar regras sequencialmente para julgar validade.",
                                  "commonMistakes": [
                                    "Não checar comprimento em strings longas",
                                    "Ignorar case-sensitivity na distinção, mas validar formação",
                                    "Validar acentos ou símbolos especiais por engano"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Criar e debugar identificadores em contexto léxico",
                                  "subSteps": [
                                    "Crie 3 identificadores válidos para variáveis: ex. 'contador', 'user_Id1', '_temp'.",
                                    "Crie 3 inválidos intencionalmente e corrija-os: ex. '1x' → 'x1'.",
                                    "Simule um scanner léxico: dado código 'int 2var = 1;', identifique erro no identificador.",
                                    "Escreva pseudocódigo para validador: if (inicioLetraOu_ && comprimentoOk && semInvalidos).",
                                    "Teste seu validador com 5 casos edge: comprimento=32, só _, maiúsc/minúsc."
                                  ],
                                  "verification": "Gere 6 identificadores (3 válidos corrigidos) e valide com pseudocódigo sem erros.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Editor de texto simples",
                                    "Pseudocódigo template para validador"
                                  ],
                                  "tips": "Use convenções reais como camelCase para prática autêntica.",
                                  "learningObjective": "Gerar e corrigir identificadores aplicando regras em cenários reais.",
                                  "commonMistakes": [
                                    "Criar inválidos sem correção explícita",
                                    "Esquecer case em distinções",
                                    "Exceder comprimento acidentalmente"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um scanner léxico de compilador, dado o token candidato 'userName_42' (comprimento 10), valide: inicia com 'u' (letra válida), corpo com letras, _, dígitos (válido), <32 → Válido. Para '42user': inicia com '4' (inválido) → Rejeitar como identificador, tratar como número.",
                              "finalVerifications": [
                                "Lista corretamente as 4 regras principais sem erros.",
                                "Valida 10 exemplos mistos com 100% acurácia e explicações.",
                                "Cria 5 identificadores válidos e corrige 5 inválidos.",
                                "Explica impacto de case-sensitivity na formação vs. distinção.",
                                "Simula scanner em 3 trechos de código simples.",
                                "Identifica erros comuns em naming conventions reais."
                              ],
                              "assessmentCriteria": [
                                "Precisão na aplicação de regras (100% em validações).",
                                "Explicações detalhadas por regra violada/cumprida.",
                                "Criatividade e correção em identificadores gerados.",
                                "Compreensão de case-sensitivity e limites.",
                                "Integração em contexto de análise léxica.",
                                "Tempo de resposta rápido (<1min por validação)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Expressões regulares básicas para padrões de strings.",
                                "Língua Portuguesa: Analogia com regras ortográficas e gramaticais.",
                                "Design de Software: Convenções de nomenclatura (camelCase, snake_case).",
                                "Lógica: Condições if-then para validação sequencial."
                              ],
                              "realWorldApplication": "Em compiladores e interpretadores (ex: GCC, Python lexer), para rejeitar código inválido como 'int 1var=0;' evitando erros de sintaxe; em IDEs para autocompletar e alertar naming inválido, garantindo código limpo e portável."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.2.2.3",
                            "name": "Reconhecer identificadores em código fonte",
                            "description": "Identificar tokens identificadores em trechos de código fonte, distinguindo-os de outras classes de tokens durante a análise léxica.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a definição e regras básicas de identificadores",
                                  "subSteps": [
                                    "Leia a definição: Identificadores são sequências de caracteres usadas para nomear variáveis, funções e outros elementos, começando com letra (a-z, A-Z) ou sublinhado (_) e seguidos por letras, dígitos (0-9) ou sublinhados.",
                                    "Memorize as regras padrão: Comprimento máximo típico (ex: 31 chars), case-sensitive, não pode iniciar com dígito.",
                                    "Estude exemplos válidos: 'var1', '_func', 'minhaVariavelComum'.",
                                    "Analise contraexemplos inválidos: '123abc' (inicia com dígito), 'var-name' (hífen não permitido), '2var' (inicia com número).",
                                    "Diferencie de keywords iniciais: Keywords como 'int' ou 'if' matcham o padrão mas são classificados separadamente."
                                  ],
                                  "verification": "Escreva a definição em suas palavras e liste 5 exemplos válidos e 3 inválidos.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Documentação de análise léxica (ex: Dragon Book capítulo 3)",
                                    "Tabela de regras de identificadores em linguagens como C ou Python"
                                  ],
                                  "tips": "Use expressões regulares para visualizar: /^[a-zA-Z_][a-zA-Z0-9_]*$/",
                                  "learningObjective": "Definir precisamente o que constitui um identificador válido na análise léxica.",
                                  "commonMistakes": [
                                    "Confundir identificadores com keywords sem distinção posterior",
                                    "Permitir caracteres especiais como hífen ou espaços",
                                    "Ignorar sensibilidade a maiúsculas/minúsculas"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar identificadores em trechos de código isolados",
                                  "subSteps": [
                                    "Pegue um trecho simples de código fonte sem contexto.",
                                    "Varra o código caractere por caractere, aplicando as regras de identificadores.",
                                    "Marque potenciais identificadores e valide contra o padrão regex.",
                                    "Ignore espaços, quebras de linha e outros tokens iniciais.",
                                    "Liste todos os identificadores encontrados em ordem de aparição."
                                  ],
                                  "verification": "Analise um trecho fornecido e submeta a lista de identificadores para revisão.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Editor de texto ou IDE com highlighting (ex: VS Code)",
                                    "Trechos de código simples em C ou pseudocódigo"
                                  ],
                                  "tips": "Comece do início do código e pause em símbolos não alfanuméricos para delimitar tokens.",
                                  "learningObjective": "Aplicar regras para extrair identificadores de código fonte bruto.",
                                  "commonMistakes": [
                                    "Marcar números como identificadores",
                                    "Quebrar identificadores em múltiplos tokens",
                                    "Omitir sublinhados iniciais"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Distinguir identificadores de outras classes de tokens",
                                  "subSteps": [
                                    "Revise outras classes: números (dígitos opcionais com ponto), strings (aspas delimitadas), operadores (+, -, =), keywords (lista fixa como 'int', 'if').",
                                    "Em um trecho misto, classifique cada token: ID vs número vs operador vs keyword.",
                                    "Para matches de ID, cheque lista de keywords e reclasse se necessário.",
                                    "Pratique com código contendo mistura: ex: 'int x = 10; if (x > 0)'.",
                                    "Crie uma tabela de classificação para o trecho."
                                  ],
                                  "verification": "Classifique todos tokens em um trecho misto e explique distinções.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Lista de keywords de uma linguagem (ex: C ANSI)",
                                    "Ferramenta online de lexer simples ou regex tester"
                                  ],
                                  "tips": "Keywords são identificadores 'reservados'; lexer os reconhece como ID primeiro.",
                                  "learningObjective": "Diferenciar identificadores de números, strings, operadores e keywords.",
                                  "commonMistakes": [
                                    "Classificar keywords como identificadores finais",
                                    "Confundir floats/decimais com IDs",
                                    "Ignorar delimitadores como parênteses"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar reconhecimento em código complexo e verificar",
                                  "subSteps": [
                                    "Analise um programa completo de 20-50 linhas.",
                                    "Extraia e liste todos identificadores, excluindo keywords.",
                                    "Compare com saída de um lexer real (ex: flex ou online tool).",
                                    "Identifique padrões comuns como nomes de variáveis vs funções.",
                                    "Autoavalie erros e refine análise."
                                  ],
                                  "verification": "Submeta lista completa de identificadores de um código complexo com justificativa.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Programa exemplo em C/Python (ex: Hello World com loops)",
                                    "Lexer online (ex: regex101.com ou flex simulator)"
                                  ],
                                  "tips": "Foque em contexto: funções chamadas são IDs, mas verifique sintaxe.",
                                  "learningObjective": "Reconhecer identificadores com precisão em cenários reais de análise léxica.",
                                  "commonMistakes": [
                                    "Perder IDs em comentários ou strings",
                                    "Confundir macros/preprocessador com IDs",
                                    "Sobrecarregar com tokens irrelevantes"
                                  ]
                                }
                              ],
                              "practicalExample": "Analise este trecho C-like: int main() { int x = 10; float _total = x + 3.14; if (x > 0) printf('OK'); } Identificadores: main, x, _total (keywords: int, float, if; número: 10, 3.14; operador: =, +, >; string implícita em printf).",
                              "finalVerifications": [
                                "Lista corretamente todos identificadores em trechos simples e complexos.",
                                "Distinque 100% dos casos de keywords, números e operadores.",
                                "Explica regras usadas para cada identificação.",
                                "Analisa código de 50 linhas em menos de 5 minutos.",
                                "Valida análise comparando com lexer automatizado.",
                                "Identifica erros comuns em exemplos fornecidos."
                              ],
                              "assessmentCriteria": [
                                "Precisão: Zero erros em identificação de IDs vs outros tokens.",
                                "Completude: Captura todos IDs sem omissões.",
                                "Explicação: Justificativa clara baseada em regras léxicas.",
                                "Eficiência: Tempo de análise proporcional ao tamanho do código.",
                                "Distinção: Correta separação de keywords e IDs potenciais.",
                                "Consistência: Mesma análise em múltiplos trechos semelhantes."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Uso de autômatos finitos e expressões regulares para reconhecimento de padrões.",
                                "Linguística: Análise morfológica e classificação de palavras em linguagens formais.",
                                "Lógica: Regras de inferência para classificação de tokens baseada em prefixos.",
                                "Engenharia de Software: Integração em ferramentas de parsing e IDEs."
                              ],
                              "realWorldApplication": "Em compiladores (GCC, Clang) para tokenização inicial; editores de código (VS Code syntax highlighting); linters (ESLint, pylint) para validar nomes de variáveis; depuradores que listam símbolos."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.1.2.3",
                        "name": "Literais",
                        "description": "Tokens que representam valores constantes diretamente no código fonte, como números, strings e booleanos, sem necessidade de declaração.",
                        "specificSkills": [
                          {
                            "id": "10.1.1.2.3.1",
                            "name": "Classificar tipos de literais",
                            "description": "Categorizar literais em numéricos (inteiros, floats), strings, caracteres e booleanos, com exemplos como 42, 3.14, \"hello\" e true.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o conceito de literais em linguagens de programação",
                                  "subSteps": [
                                    "Defina o que é um literal: um valor fixo escrito diretamente no código fonte.",
                                    "Identifique os principais tipos de literais: numéricos (inteiros e floats), strings, caracteres e booleanos.",
                                    "Analise exemplos básicos: 42 (inteiro), 3.14 (float), \"hello\" (string), 'a' (caractere), true (booleano).",
                                    "Diferencie literais de variáveis ou expressões.",
                                    "Estude representações em linguagens como C, Java ou Python."
                                  ],
                                  "verification": "Crie um resumo escrito listando definição e 5 exemplos de literais com seus tipos.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Documentação de linguagens de programação (ex: Python docs)",
                                    "Editor de texto para anotar exemplos"
                                  ],
                                  "tips": "Sempre observe as aspas ou ausência delas para identificar o tipo.",
                                  "learningObjective": "Ao final, o aluno definirá literais e listará seus tipos principais com exemplos.",
                                  "commonMistakes": [
                                    "Confundir literais com identificadores (variáveis)",
                                    "Ignorar diferenças entre aspas simples e duplas"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Classificar literais numéricos (inteiros e floats)",
                                  "subSteps": [
                                    "Estude literais inteiros: sequências de dígitos sem ponto decimal, ex: 42, -10, 0.",
                                    "Estude literais float: números com ponto decimal ou notação científica, ex: 3.14, -2.5e3.",
                                    "Pratique identificação: liste 10 exemplos e classifique cada um.",
                                    "Considere prefixos como 0x para hexadecimais (se aplicável ao contexto).",
                                    "Compare com outros tipos para reforçar distinções."
                                  ],
                                  "verification": "Classifique corretamente 10 literais numéricos mistos em um exercício escrito.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Lista de exemplos de código fonte",
                                    "Calculadora para validar valores"
                                  ],
                                  "tips": "Verifique se há ponto decimal: se sim, é float; caso contrário, inteiro.",
                                  "learningObjective": "O aluno identificará e diferenciará inteiros de floats com precisão.",
                                  "commonMistakes": [
                                    "Classificar 3.0 como inteiro",
                                    "Confundir notação científica com strings"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Classificar literais textuais (strings e caracteres)",
                                  "subSteps": [
                                    "Defina strings: sequências de caracteres entre aspas duplas, ex: \"hello world\".",
                                    "Defina caracteres: único caractere entre aspas simples, ex: 'a', '\\n'.",
                                    "Analise escape sequences: \\t, \\n em strings e chars.",
                                    "Pratique com exemplos: classifique \"abc\", 'x', \"123\".",
                                    "Discuta diferenças entre linguagens (ex: Python permite aspas simples para strings)."
                                  ],
                                  "verification": "Crie uma tabela comparando 8 exemplos de strings e chars.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Exemplos de código com escape sequences",
                                    "Compilador online para testar"
                                  ],
                                  "tips": "Conte o número de caracteres: 1 = char; múltiplos = string.",
                                  "learningObjective": "O aluno distinguirá strings de caracteres considerando delimitadores e conteúdo.",
                                  "commonMistakes": [
                                    "Tratar strings como chars",
                                    "Esquecer escape sequences como literais especiais"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Classificar literais booleanos e praticar classificação integrada",
                                  "subSteps": [
                                    "Estude booleanos: apenas true e false (minúsculas em muitas linguagens).",
                                    "Integre todos os tipos: crie fluxograma de classificação baseado em características.",
                                    "Realize exercícios mistos: classifique listas com 20 literais variados.",
                                    "Teste edge cases: 0 (inteiro, não booleano), \"true\" (string).",
                                    "Revise e corrija classificações erradas."
                                  ],
                                  "verification": "Classifique com 100% de acerto uma lista de 15 literais mistos.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Folha de exercícios com literais mistos",
                                    "Fluxograma em papel ou digital"
                                  ],
                                  "tips": "Booleanos são palavras-chave exatas: true/false, não valores numéricos.",
                                  "learningObjective": "O aluno classificará qualquer literal corretamente em contexto de análise léxica.",
                                  "commonMistakes": [
                                    "Confundir \"true\" (string) com true (booleano)",
                                    "Tratar 1/0 como booleanos"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um analisador léxico, dada a entrada: int x = 42; float y = 3.14; char c = 'a'; string s = \"hello\"; bool b = true; Classifique: 42 (inteiro), 3.14 (float), 'a' (caractere), \"hello\" (string), true (booleano).",
                              "finalVerifications": [
                                "Classifica corretamente todos os quatro tipos de literais com exemplos.",
                                "Diferencia inteiros de floats em casos com zero decimal.",
                                "Identifica strings vs. chars por delimitadores.",
                                "Reconhece booleanos apenas como true/false.",
                                "Cria fluxograma de classificação sem erros.",
                                "Resolve 20 exercícios mistos com >95% acerto."
                              ],
                              "assessmentCriteria": [
                                "Precisão na classificação de literais numéricos (>90%).",
                                "Correta distinção entre strings e caracteres (100%).",
                                "Identificação precisa de booleanos vs. strings semelhantes.",
                                "Uso correto de exemplos e edge cases.",
                                "Clareza no fluxograma ou tabela de classificação.",
                                "Tempo de resposta em exercícios <2 min por item."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: compreensão de números reais e inteiros.",
                                "Língua Portuguesa: análise de sequências textuais e delimitadores.",
                                "Lógica: valores verdadeiros/falsos em raciocínio booleano.",
                                "Física/Engenharia: representação numérica em simulações computacionais."
                              ],
                              "realWorldApplication": "Na análise léxica de compiladores (ex: GCC, Javac), classificar literais corretamente gera tokens precisos para o parser, evitando erros de sintaxe em programas reais como jogos, apps ou sistemas embarcados."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.2.3.2",
                            "name": "Reconhecer representações de literais",
                            "description": "Explicar notações específicas como prefixos (0x para hex), sufixos (f para float) e escape sequences em strings (\\n para nova linha).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender os conceitos básicos de literais e suas representações",
                                  "subSteps": [
                                    "Defina o que é um literal em análise léxica: um valor constante diretamente no código fonte.",
                                    "Classifique literais em tipos principais: inteiros, flutuantes, strings e booleanos.",
                                    "Identifique o papel do analisador léxico em reconhecer literais sem ambiguidade.",
                                    "Revise exemplos simples como 42 (decimal inteiro), 3.14 (float) e \"hello\" (string).",
                                    "Compare literais com identificadores para diferenciar (literais não começam com letra ou _)."
                                  ],
                                  "verification": "Liste 5 exemplos de literais básicos e explique por que cada um é um literal.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Documentação de linguagens como C ou Python sobre literais",
                                    "Editor de texto para anotar exemplos"
                                  ],
                                  "tips": "Sempre leia a especificação da linguagem para variações entre C, Java, Python.",
                                  "learningObjective": "Compreender a definição e classificação de literais na análise léxica.",
                                  "commonMistakes": "Confundir literais com variáveis; ignorar diferenças entre linguagens."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Reconhecer prefixos em literais numéricos",
                                  "subSteps": [
                                    "Estude prefixos para bases não-decimais: 0x para hexadecimal (ex: 0xFF), 0o para octal, 0b para binário em algumas linguagens.",
                                    "Analise como o prefixo sinaliza o analisador léxico para mudar o modo de parsing.",
                                    "Pratique convertendo valores: 0x10 = 16 decimal, valide com calculadora.",
                                    "Identifique regras: prefixo deve seguir imediatamente o zero inicial.",
                                    "Teste em código: compile ou interprete snippets com prefixos inválidos para ver erros."
                                  ],
                                  "verification": "Converta 5 literais com prefixos para decimal e identifique o tipo de base.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Calculadora de bases numéricas online",
                                    "Compilador C ou Python REPL"
                                  ],
                                  "tips": "Lembre-se: em C, 010 é octal, não decimal 10; teste sempre.",
                                  "learningObjective": "Identificar e interpretar prefixos numéricos em literais inteiros.",
                                  "commonMistakes": "Esquecer que 0xA é hex (letras A-F); confundir com strings."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Identificar sufixos em literais flutuantes e inteiros",
                                  "subSteps": [
                                    "Aprenda sufixos para floats: f ou F para single-precision (ex: 3.14f), L para long double.",
                                    "Estude sufixos inteiros: u para unsigned, l ou ll para long (ex: 42ULL).",
                                    "Observe como sufixos afetam o tipo inferido pelo compilador.",
                                    "Pratique em exemplos: 1.0f vs 1.0 (double por padrão).",
                                    "Verifique erros comuns como sufixo em inteiros sem ponto decimal."
                                  ],
                                  "verification": "Classifique o tipo exato de 10 literais com sufixos e explique o impacto.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Referência de tipos numéricos em C/C++",
                                    "Online compiler como Godbolt"
                                  ],
                                  "tips": "Sufixos são case-insensitive em muitas linguagens; use maiúsculas para clareza.",
                                  "learningObjective": "Reconhecer sufixos e seu papel na tipagem de literais numéricos.",
                                  "commonMistakes": "Aplicar sufixo float em inteiros; ignorar diferenças de precisão."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Dominar escape sequences em literais de string",
                                  "subSteps": [
                                    "Liste escape sequences comuns: \\n (nova linha), \\t (tab), \\\" (aspas), \\xHH (hex byte).",
                                    "Entenda o processamento: analisador léxico substitui sequências por caracteres reais.",
                                    "Construa strings complexas: \"Line1\\nLine2\" e visualize saída.",
                                    "Identifique sequências octais (\\123) e hex (\\x1A).",
                                    "Teste inválidos: \\z gera erro léxico."
                                  ],
                                  "verification": "Escreva 5 strings com escapes e prediga a saída renderizada.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Tabela ASCII/Unicode",
                                    "Editor com preview de strings"
                                  ],
                                  "tips": "Conte barras invertidas: \\\\ produz uma única \\ na string final.",
                                  "learningObjective": "Interpretar e validar escape sequences em strings literais.",
                                  "commonMistakes": "Confundir \\n com literal 'n'; esquecer escapes em aspas internas."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Integrar e praticar reconhecimento completo de literais",
                                  "subSteps": [
                                    "Analise trechos de código reais misturando todos os tipos de literais.",
                                    "Crie um fluxograma mental: ver prefixo/sufixo/escapes? Classificar tipo.",
                                    "Implemente um mini-lexer simples em pseudocódigo para literais.",
                                    "Debugue códigos com literais malformados.",
                                    "Compare representações entre linguagens (C vs Python)."
                                  ],
                                  "verification": "Parse 10 linhas de código e anote todos os literais com tipos e notações.",
                                  "estimatedTime": "50 minutos",
                                  "materials": [
                                    "Código fonte open-source (ex: Linux kernel snippets)",
                                    "Ferramenta de highlighting sintático"
                                  ],
                                  "tips": "Use regex para testar padrões: ^0[xob].* para prefixos.",
                                  "learningObjective": "Aplicar conhecimento integrado para reconhecer literais em contexto.",
                                  "commonMistakes": "Ignorar contexto (ex: literal em comentário); falhar em multi-linhas."
                                }
                              ],
                              "practicalExample": "Em C: int hex = 0xFF; float pi = 3.14159f; char* msg = \"Hello\\nWorld\\t!\"; Aqui, 0xFF é literal hex inteiro, 3.14159f é float com sufixo f, e a string usa \\n e \\t escapes. O lexer deve tokenizá-los corretamente sem erros.",
                              "finalVerifications": [
                                "Identifique todos os literais em um snippet de 20 linhas de código C/Python.",
                                "Converta literais hex/oct/bin para decimal corretamente em 10 exemplos.",
                                "Prediga saída de strings com 5+ escape sequences diferentes.",
                                "Explique por que 0x1p10 é inválido como inteiro mas válido como float em C.",
                                "Classifique tipos considerando sufixos ausentes (default rules).",
                                "Detecte e corrija 3 literais malformados em código fornecido."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de prefixos/sufixos/escapes (90%+ acerto).",
                                "Correta interpretação e conversão de valores numéricos.",
                                "Explicação clara do impacto léxico no tokenizador.",
                                "Detecção de erros léxicos em literais inválidos.",
                                "Integração com contexto de código (não confundir com outros tokens).",
                                "Uso correto de terminologia (ex: 'escape sequence' vs 'special char')."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Conversão de bases numéricas (hex/bin/oct para decimal).",
                                "Linguística: Processamento de sequências de escape similar a fonemas em linguagem natural.",
                                "Engenharia de Software: Parsing em ferramentas como JSON/YAML parsers.",
                                "História da Computação: Evolução de notações de William Shockley em assembly."
                              ],
                              "realWorldApplication": "Em compiladores como GCC/Clang, o lexer usa essas regras para tokenizar código fonte eficientemente; editores como VSCode destacam sintaxe baseada nisso; em embedded systems, literais hex otimizam memória para valores fixos como 0xDEADBEEF."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.2.3.3",
                            "name": "Validar literais em expressões",
                            "description": "Verificar a validade de literais em contextos de código, identificando erros léxicos como strings não fechadas ou números malformados.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os tipos de literais e suas regras básicas",
                                  "subSteps": [
                                    "Estude os tipos comuns de literais: strings (delimitadas por aspas), números inteiros, números de ponto flutuante, booleanos (true/false) e caracteres especiais.",
                                    "Liste as regras léxicas básicas para cada tipo, como escape sequences em strings (\\n, \\\") e separadores decimais em floats (.)",
                                    "Analise exemplos válidos e inválidos de cada tipo em uma linguagem como Python ou C.",
                                    "Crie uma tabela resumindo sintaxe válida e inválida para literais.",
                                    "Discuta o papel dos literais na análise léxica de compiladores."
                                  ],
                                  "verification": "Tabela de regras completada com pelo menos 5 exemplos por tipo e sem erros conceituais.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Documentação de linguagens (Python/C specs)",
                                    "Editor de texto para tabelas",
                                    "Exemplos de código léxico"
                                  ],
                                  "tips": "Use diagramas de fluxo para visualizar regras de validação.",
                                  "learningObjective": "Identificar e classificar diferentes tipos de literais e suas regras sintáticas básicas.",
                                  "commonMistakes": [
                                    "Confundir aspas simples e duplas",
                                    "Ignorar escape sequences",
                                    "Não diferenciar int de float"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar validação de literais de string",
                                  "subSteps": [
                                    "Escreva uma função que verifique se uma string está corretamente delimitada por aspas duplas ou simples.",
                                    "Implemente detecção de strings não fechadas e escape sequences inválidas (ex: \\z).",
                                    "Teste com casos como \"hello\\\"world\", \"não fechada e strings vazias \"\".",
                                    "Adicione suporte para multiline strings se aplicável (ex: \"\"\" em Python).",
                                    "Registre erros léxicos encontrados, como posição do erro."
                                  ],
                                  "verification": "Função passa em 10 testes unitários com strings válidas e inválidas.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Linguagem de programação (Python recomendado)",
                                    "Framework de testes (unittest)",
                                    "Exemplos de strings malformadas"
                                  ],
                                  "tips": "Use regex inicialmente para protótipo, mas implemente manualmente para entender o lexer.",
                                  "learningObjective": "Desenvolver lógica para validar strings literais e detectar erros léxicos comuns.",
                                  "commonMistakes": [
                                    "Não tratar escapes corretamente",
                                    "Falhar em strings com aspas internas",
                                    "Ignorar quebras de linha sem suporte"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Validar literais numéricos (inteiros e floats)",
                                  "subSteps": [
                                    "Defina regras para inteiros: dígitos 0-9, sem sinal opcional (+/-), sem decimais.",
                                    "Para floats: parte inteira, ponto decimal, parte fracionária, expoente opcional (e/E).",
                                    "Implemente uma função que parse e valide números, rejeitando malformados como 1.2.3 ou 1eG.",
                                    "Teste edge cases: 0, -0, 1e-10, números muito grandes.",
                                    "Integre com validação de strings para contextos mistos."
                                  ],
                                  "verification": "Função identifica corretamente 15 casos de números válidos e inválidos.",
                                  "estimatedTime": "50 minutos",
                                  "materials": [
                                    "Mesma linguagem do step 2",
                                    "Lista de casos de teste numéricos",
                                    "Calculadora para verificar valores"
                                  ],
                                  "tips": "Use estados finitos (FSM) para parsing sequencial de dígitos e símbolos.",
                                  "learningObjective": "Criar validador preciso para literais numéricos com detecção de erros léxicos.",
                                  "commonMistakes": [
                                    "Permitir múltiplos pontos decimais",
                                    "Confundir expoentes com letras",
                                    "Não validar overflow aproximado"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar validação em expressões completas e integrar",
                                  "subSteps": [
                                    "Crie um scanner simples que tokeniza uma expressão e valida literais durante o processo.",
                                    "Teste expressões como print(\"hello\", 123, 4.5e2) com erros inseridos.",
                                    "Implemente relatório de erros com posição (linha/coluna) do literal inválido.",
                                    "Valide booleanos e outros literais simples (null, true).",
                                    "Refatore código para um validador unificado de literais em expressões."
                                  ],
                                  "verification": "Scanner processa 8 expressões com 100% de detecção de literais inválidos.",
                                  "estimatedTime": "70 minutos",
                                  "materials": [
                                    "Código dos steps anteriores",
                                    "Editor IDE com debugger",
                                    "Conjunto de expressões teste"
                                  ],
                                  "tips": "Priorize detecção precoce de erros para melhor UX em compiladores.",
                                  "learningObjective": "Integrar validação de literais em um contexto de análise léxica real.",
                                  "commonMistakes": [
                                    "Não reportar posição exata do erro",
                                    "Falhar em expressões com múltiplos literais",
                                    "Ignorar contexto de operadores"
                                  ]
                                }
                              ],
                              "practicalExample": "Considere a expressão: print(\"Olá, mundo! 123.45.6 true). O validador deve detectar: string válida, float malformado (123.45.6), booleano válido, mas rejeitar pela falta de fechamento geral. Implemente para output: Erro léxico em posição 15: número malformado; Erro em posição 25: parêntese não fechado.",
                              "finalVerifications": [
                                "Identifica strings não fechadas em qualquer posição.",
                                "Rejeita números com múltiplos pontos ou expoentes inválidos.",
                                "Valida corretamente escapes em strings.",
                                "Reporta posição exata de erros léxicos.",
                                "Processa expressões mistas sem falsos positivos.",
                                "Diferencia literais de identificadores/operadores."
                              ],
                              "assessmentCriteria": [
                                "Precisão na detecção de erros (95%+ em testes).",
                                "Completude das regras para todos tipos de literais.",
                                "Eficiência do algoritmo (O(n) tempo).",
                                "Qualidade dos relatórios de erro (posição e descrição clara).",
                                "Cobertura de edge cases documentada.",
                                "Código limpo e modular."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Parsing de expressões numéricas e notação científica.",
                                "Língua Portuguesa: Análise sintática de strings e escapes.",
                                "Lógica e Algoritmos: Máquinas de estados finitos para lexers.",
                                "Inglês Técnico: Leitura de especificações de linguagens de programação."
                              ],
                              "realWorldApplication": "Em compiladores como GCC ou interpretadores Python, validação de literais previne erros em runtime; em IDEs como VSCode, fornece syntax highlighting e sugestões de correção em tempo real para desenvolvedores."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.1.2.4",
                        "name": "Operadores e Símbolos de Pontuação",
                        "description": "Tokens que representam operações matemáticas, lógicas ou relacionais, e símbolos que delimitam estruturas ou separam elementos no código.",
                        "specificSkills": [
                          {
                            "id": "10.1.1.2.4.1",
                            "name": "Classificar operadores",
                            "description": "Dividir operadores em aritméticos (+, -, *, /), relacionais (==, >, <), lógicos (&&, ||, !) e de atribuição (=, +=), com exemplos de uso.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender as categorias principais de operadores",
                                  "subSteps": [
                                    "Ler a definição de operadores na análise léxica de compiladores.",
                                    "Identificar as quatro categorias: aritméticos (+, -, *, /), relacionais (==, >, <), lógicos (&&, ||, !) e de atribuição (=, +=).",
                                    "Criar uma tabela com as categorias e exemplos iniciais.",
                                    "Explicar a função de cada categoria em expressões de programação.",
                                    "Discutir diferenças entre operadores unários, binários e ternários."
                                  ],
                                  "verification": "Recitar verbalmente ou por escrito as 4 categorias e pelo menos um exemplo de cada.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Material didático sobre análise léxica",
                                    "Folha em branco para tabela",
                                    "Referência de sintaxe de linguagens como C ou Java"
                                  ],
                                  "tips": "Use cores diferentes para cada categoria na tabela para facilitar a memorização visual.",
                                  "learningObjective": "Entender e listar as categorias de operadores com precisão.",
                                  "commonMistakes": [
                                    "Confundir operadores relacionais com aritméticos",
                                    "Esquecer operadores compostos como += ou !",
                                    "Ignorar contexto de uso em análise léxica"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Estudar operadores aritméticos e relacionais",
                                  "subSteps": [
                                    "Listar e memorizar operadores aritméticos: +, -, *, / com exemplos como 5 + 3.",
                                    "Listar operadores relacionais: ==, !=, >, <, >=, <= com exemplos como 5 > 3.",
                                    "Escrever 3 expressões mistas usando apenas esses operadores.",
                                    "Analisar como eles geram tokens na análise léxica.",
                                    "Comparar precedência entre aritméticos e relacionais."
                                  ],
                                  "verification": "Classificar corretamente 8 operadores aritméticos e relacionais em uma lista aleatória.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Editor de texto ou papel",
                                    "Exemplos de código simples",
                                    "Tabela de precedência de operadores"
                                  ],
                                  "tips": "Pratique com calculadora para validar resultados aritméticos antes de classificar.",
                                  "learningObjective": "Dominar identificação e uso de operadores aritméticos e relacionais.",
                                  "commonMistakes": [
                                    "Trocar == por = ",
                                    "Esquecer != como relacional",
                                    "Confundir / com divisão inteira vs. float"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Estudar operadores lógicos e de atribuição",
                                  "subSteps": [
                                    "Listar operadores lógicos: && (AND), || (OR), ! (NOT) com exemplos booleanos.",
                                    "Listar operadores de atribuição: =, +=, -=, *=, /= com exemplos como x += 1.",
                                    "Escrever expressões condicionais usando lógicos e atribuição.",
                                    "Explicar avaliação de curto-circuito em && e ||.",
                                    "Identificar como são tokenizados em compiladores."
                                  ],
                                  "verification": "Criar e classificar 5 expressões que combinem lógicos e atribuição.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Editor de código online",
                                    "Documentação de operadores lógicos",
                                    "Exemplos de condicionais if/while"
                                  ],
                                  "tips": "Teste expressões em um interpretador para ver resultados booleanos.",
                                  "learningObjective": "Identificar e aplicar operadores lógicos e de atribuição corretamente.",
                                  "commonMistakes": [
                                    "Confundir ! com negação numérica",
                                    "Usar = em vez de == em comparações",
                                    "Ignorar precedência de ! sobre &&"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Praticar classificação de operadores misturados",
                                  "subSteps": [
                                    "Coletar 20 operadores misturados de códigos reais.",
                                    "Classificar cada um em uma das 4 categorias sem consultar referências.",
                                    "Criar um fluxograma para decisão de classificação.",
                                    "Avaliar um código fonte fornecido, marcando todos os operadores.",
                                    "Discutir ambiguidades como - (aritmético ou unário)."
                                  ],
                                  "verification": "Acertar 95% em um quiz de 20 operadores misturados.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Quiz impresso ou online",
                                    "Código fonte exemplo de programa simples",
                                    "Fluxograma em branco"
                                  ],
                                  "tips": "Comece pela categoria mais óbvia (aritméticos) e elimine opções.",
                                  "learningObjective": "Classificar operadores de forma autônoma e precisa em contextos reais.",
                                  "commonMistakes": [
                                    "Classificar += apenas como atribuição sem notar composto",
                                    "Ignorar contexto léxico",
                                    "Confundir operadores de pontuação com operadores"
                                  ]
                                }
                              ],
                              "practicalExample": "Analise o código: int x = 10 + 5 * 2 > 15 && (y != 0); Classificação: = (atribuição), + (aritmético), * (aritmético), > (relacional), && (lógico), != (relacional). No lexer, cada um vira um token OPERATOR com subtipo.",
                              "finalVerifications": [
                                "Listar todos os operadores de cada categoria sem erros.",
                                "Classificar 15 operadores misturados com 100% de acerto.",
                                "Explicar uso de curto-circuito em lógicos com exemplo.",
                                "Identificar operadores compostos em atribuição.",
                                "Aplicar classificação em um trecho de código de 10 linhas.",
                                "Diferenciar operadores de símbolos de pontuação."
                              ],
                              "assessmentCriteria": [
                                "Precisão na classificação: 90%+ correto.",
                                "Compreensão de precedência e associatividade.",
                                "Capacidade de exemplificar uso em expressões.",
                                "Identificação correta de operadores unários vs. binários.",
                                "Explicação contextual em análise léxica.",
                                "Velocidade e confiança na classificação prática."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Operações aritméticas e relacionais.",
                                "Lógica Matemática: Operadores booleanos e tabelas-verdade.",
                                "Programação Geral: Uso em estruturas condicionais e loops.",
                                "Linguagens Formais: Reconhecimento de padrões em autômatos.",
                                "Engenharia de Software: Análise estática de código."
                              ],
                              "realWorldApplication": "Em compiladores como GCC ou LLVM, o analisador léxico classifica operadores para gerar tokens, permitindo parsing correto de expressões em linguagens como C++, Java ou Python, essencial para desenvolvimento de software e ferramentas de análise de código."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.2.4.2",
                            "name": "Identificar símbolos de pontuação",
                            "description": "Listar e exemplificar símbolos como ; (ponto e vírgula), , (vírgula), { } [ ] (chaves, colchetes), ( ) (parênteses) usados para delimitar blocos e argumentos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Memorizar os símbolos de pontuação principais e seus nomes",
                                  "subSteps": [
                                    "Liste os símbolos: ; (ponto e vírgula), , (vírgula), { } (chaves), [ ] (colchetes), ( ) (parênteses).",
                                    "Associe cada símbolo ao seu nome padrão em análise léxica.",
                                    "Crie um cartão de memória com símbolo de um lado e nome do outro.",
                                    "Repita a lista em voz alta 5 vezes, variando a ordem.",
                                    "Desenhe os símbolos em um papel para fixação visual."
                                  ],
                                  "verification": "Recite a lista completa sem erros, identificando nome e símbolo corretamente.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Papel, caneta, flashcards digitais (opcional como Anki)",
                                  "tips": "Use mnemônicos, como 'Vírgula separa, ponto e vírgula termina'.",
                                  "learningObjective": "Reconhecer e nomear instantaneamente os 6 símbolos de pontuação principais.",
                                  "commonMistakes": "Confundir chaves {} com colchetes [] ou parênteses (); ignorar espaços ao redor."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Entender os usos comuns desses símbolos em código fonte",
                                  "subSteps": [
                                    "Estude ; para terminar statements.",
                                    "Aprenda , para separar argumentos ou itens em listas.",
                                    "Analise { } para delimitar blocos de código (funções, loops).",
                                    "Examine [ ] para arrays ou índices.",
                                    "Revise ( ) para agrupar expressões, parâmetros de funções ou condições."
                                  ],
                                  "verification": "Explique verbalmente ou por escrito o propósito de cada símbolo com um exemplo simples.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Documentação de linguagens como C, JavaScript ou Python (páginas online gratuitas)",
                                  "tips": "Pense em código real: funções precisam de () para args e {} para corpo.",
                                  "learningObjective": "Associar cada símbolo à sua função semântica em análise léxica.",
                                  "commonMistakes": "Confundir usos contextuais, como , em listas vs argumentos; achar que [ ] é só para arrays."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Praticar identificação em trechos de código simples",
                                  "subSteps": [
                                    "Pegue um trecho de código curto e circule todos os símbolos de pontuação.",
                                    "Classifique cada ocorrência pelo nome e função.",
                                    "Compare com uma versão anotada.",
                                    "Repita com 3 trechos diferentes de linguagens variadas.",
                                    "Registre acertos e erros em um log."
                                  ],
                                  "verification": "Identifique corretamente 100% dos símbolos em um trecho de 10 linhas.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Editor de texto ou IDE online (como Replit), exemplos de código de compiladores ou linguagens comuns",
                                  "tips": "Ignore keywords e identifique só símbolos exatos; pratique em modo 'lexer mental'.",
                                  "learningObjective": "Localizar e categorizar símbolos de pontuação em contexto real de código.",
                                  "commonMistakes": "Marcar operadores como + ou = como pontuação; pular símbolos aninhados."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Diferenciar símbolos de pontuação de outros tokens e praticar análise léxica básica",
                                  "subSteps": [
                                    "Compare símbolos de pontuação com operadores (ex: + vs ,) e identificadores.",
                                    "Tokenize manualmente um código: separe em tokens e rotule pontuação.",
                                    "Identifique erros comuns como falta de ; ou } desbalanceado.",
                                    "Crie seu próprio código curto e auto-analise os símbolos.",
                                    "Resolva 5 exercícios de tokenização."
                                  ],
                                  "verification": "Tokenize um trecho de código completo sem erros de classificação.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Exercícios online de análise léxica (Flex/Bison tutoriais ou LeetCode-like), papel para tokenização manual",
                                  "tips": "Lembre: pontuação delimita, não opera; use scanner mental linha por linha.",
                                  "learningObjective": "Distinguir símbolos de pontuação de outros tokens em análise léxica.",
                                  "commonMistakes": "Classificar strings ou comentários como contendo pontuação livre; confundir com literais."
                                }
                              ],
                              "practicalExample": "Em JavaScript: function soma(a, b) { return a + b; } → Identifique: ( após function, , entre a e b, ) fechando args, { abrindo bloco, ; terminando return, } fechando bloco.",
                              "finalVerifications": [
                                "Lista todos os 6 símbolos com nomes corretos.",
                                "Exemplifica uso de cada um em código válido.",
                                "Tokeniza um trecho de 20 linhas sem erros.",
                                "Diferencia pontuação de operadores em 10 exemplos.",
                                "Detecta 5 usos desbalanceados ou faltantes.",
                                "Explica papel na análise léxica de compiladores."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação: 95%+ acertos.",
                                "Velocidade: tokeniza 10 linhas em <2 minutos.",
                                "Compreensão contextual: explica função corretamente.",
                                "Diferenciação: zero confusões com outros tokens.",
                                "Criatividade: gera exemplos próprios válidos.",
                                "Auto-correção: identifica e corrige erros próprios."
                              ],
                              "crossCurricularConnections": [
                                "Linguística: Pontuação em linguagem natural (vírgulas, parênteses para clareza).",
                                "Matemática: Delimitadores em expressões algébricas (parênteses para ordem).",
                                "Inglês: Uso similar de aspas e parênteses em escrita técnica.",
                                "Design: Hierarquia visual em diagramas de fluxo com chaves/colchetes."
                              ],
                              "realWorldApplication": "Em compiladores como GCC ou V8 (JS), o lexer identifica esses símbolos para parsear código corretamente; erros levam a syntax errors. Desenvolvedores usam para debugar código, e ferramentas como ESLint checam balanceamento."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.2.4.3",
                            "name": "Diferenciar operadores compostos",
                            "description": "Reconhecer operadores compostos como +=, == e >>=, explicando como o analisador léxico os distingue de sequências simples de tokens.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender operadores simples e compostos",
                                  "subSteps": [
                                    "Defina operador simples como um único token (ex: +, =)",
                                    "Liste operadores compostos comuns: +=, ==, >>=, <=, &&, ||",
                                    "Explique que compostos são tokens únicos, não sequências separadas",
                                    "Compare com exemplos: 'a += b' vs 'a + = b' (inválido)",
                                    "Estude regras de precedência léxica"
                                  ],
                                  "verification": "Liste corretamente 5 operadores compostos e explique por que não são dois tokens separados",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Documentação de lexer de linguagens como C ou Python; diagramas de tokens",
                                  "tips": "Use tabelas para categorizar operadores por tamanho (1, 2 ou 3 caracteres)",
                                  "learningObjective": "Identificar e classificar operadores simples vs compostos",
                                  "commonMistakes": "Confundir == com = seguido de =; ignorar contexto de linguagem"
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar mecanismos de distinção no analisador léxico",
                                  "subSteps": [
                                    "Aprenda o princípio 'maximal munch': consumir o token mais longo possível",
                                    "Estude lookahead: verificar próximo caractere sem consumi-lo",
                                    "Simule manualmente: para '+', cheque se próximo é '=' → +=",
                                    "Discuta estados finitos (DFA) para reconhecimento de operadores",
                                    "Compare com sequências inválidas como '+ =' (dois tokens)"
                                  ],
                                  "verification": "Descreva o processo de lookahead para identificar >>= de >> e =",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Pseudocódigo de lexer; ferramenta online como regex101 para padrões",
                                  "tips": "Desenhe fluxogramas para cada operador composto",
                                  "learningObjective": "Explicar como o lexer usa lookahead para distinguir tokens",
                                  "commonMistakes": "Assumir greedy matching sem contexto; esquecer whitespace"
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Praticar com exemplos de código fonte",
                                  "subSteps": [
                                    "Analise código: 'x == y; a += 5; b >>= 2;'",
                                    "Tokenize manualmente, marcando operadores compostos",
                                    "Teste variações: 'x = = y' (erro léxico)",
                                    "Use um lexer simples em Python ou JS para validar",
                                    "Registre saídas esperadas vs reais"
                                  ],
                                  "verification": "Tokenize corretamente um snippet de 10 linhas com mistos de operadores",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Editor de código; lexer online (ex: flex demo); snippets de C/Python",
                                  "tips": "Ignore semântica, foque só na fase léxica",
                                  "learningObjective": "Aplicar distinção em código real",
                                  "commonMistakes": "Separar += em + e =; confundir com comentários ou strings"
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Implementar e testar um mini-lexer para operadores",
                                  "subSteps": [
                                    "Escreva função que reconhece operadores usando switch ou if com lookahead",
                                    "Teste casos: +=, ==, >>=, + = (separado)",
                                    "Adicione logging para mostrar tokens emitidos",
                                    "Debug erros comuns como falta de lookahead",
                                    "Expanda para 10 operadores compostos"
                                  ],
                                  "verification": "Seu lexer tokeniza corretamente 5 testes unitários com operadores mistos",
                                  "estimatedTime": "90 minutos",
                                  "materials": "Ambiente de programação (Python/JS); testes unitários prontos",
                                  "tips": "Comece com string matching simples, evolua para DFA",
                                  "learningObjective": "Construir um reconhecedor prático de operadores compostos",
                                  "commonMistakes": "Não tratar fim de arquivo; ignorar escape sequences"
                                }
                              ],
                              "practicalExample": "Em um lexer para C-like: Entrada 'int x = 5; x += 3; if (x == 8)'. Saída tokens: ['int', 'x', '=', '5', ';', 'x', '+=', '3', ';', 'if', '(', 'x', '==', '8', ')']. Nota: += e == são tokens únicos, não '+ =' ou '= ='.",
                              "finalVerifications": [
                                "Lista e explica 8 operadores compostos corretamente",
                                "Simula lookahead para >>= manualmente",
                                "Tokeniza snippet com 90% acurácia sem erros",
                                "Identifica por que 'a + = b' falha léxicamente",
                                "Implementa mini-lexer que passa 5 testes",
                                "Discute maximal munch em 3 exemplos"
                              ],
                              "assessmentCriteria": [
                                "Precisão na distinção de tokens (90%+ correto)",
                                "Explicação clara de lookahead e maximal munch",
                                "Exemplos relevantes e variados",
                                "Implementação funcional do lexer",
                                "Identificação de erros comuns e soluções",
                                "Conexão com análise léxica geral"
                              ],
                              "crossCurricularConnections": [
                                "Linguística: Analogia com morfemas compostos em palavras",
                                "Matemática: Autômatos finitos e expressões regulares",
                                "Engenharia de Software: Parsing em ferramentas como ESLint",
                                "Lógica: Precedência e associatividade em expressões booleanas"
                              ],
                              "realWorldApplication": "Compiladores como GCC ou Clang usam isso para análise léxica eficiente, evitando ambiguidades em código; editores como VS Code destacam sintaxe corretamente; ferramentas de linting detectam erros como '==' vs '='."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.1.3",
                    "name": "Expressões Regulares para Tokens",
                    "description": "Especificação formal de padrões léxicos usando expressões regulares.",
                    "individualConcepts": [
                      {
                        "id": "10.1.1.3.1",
                        "name": "Operações Fundamentais em Expressões Regulares",
                        "description": "Apresenta as operações básicas de expressões regulares, incluindo união, concatenação, estrela de Kleene e quantificadores, essenciais para construir padrões complexos de tokens.",
                        "specificSkills": [
                          {
                            "id": "10.1.1.3.1.1",
                            "name": "União e Alternativa em ER",
                            "description": "Compreender e aplicar a operação de união (representada por |) para especificar padrões alternativos, como em operadores lógicos ou diferentes tipos de literais.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o Conceito de União e Alternativa em ER",
                                  "subSteps": [
                                    "Defina união em ER como a operação que permite combinar dois ou mais padrões alternativos usando o operador |.",
                                    "Compare com operadores lógicos OR em linguagens de programação.",
                                    "Identifique que a união seleciona o primeiro padrão que corresponder.",
                                    "Estude exemplos simples como 'a|b' que matches 'a' ou 'b'.",
                                    "Discuta precedência: | tem menor precedência que concatenação."
                                  ],
                                  "verification": "Explique em suas palavras o que significa união em ER e dê um exemplo verbal sem usar |.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Documentação de ER básica (regex101.com/help)",
                                    "Bloco de notas para anotações"
                                  ],
                                  "tips": "Visualize | como uma bifurcação em um fluxograma de matching.",
                                  "learningObjective": "Entender o significado semântico da união em expressões regulares.",
                                  "commonMistakes": [
                                    "Confundir com concatenação (ab vs a|b)",
                                    "Ignorar precedência, ex: ab|c como (ab)|c ao invés de a(b|c)"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Dominar a Sintaxe Básica do Operador |",
                                  "subSteps": [
                                    "Aprenda a sintaxe: padrão1 | padrão2, onde | separa alternativas.",
                                    "Pratique com literais simples: 'cat|dog' matches 'cat' ou 'dog'.",
                                    "Teste em ferramenta online: insira padrões e strings de teste.",
                                    "Explore agrupamento: (a|b)c para aplicar concatenação após união.",
                                    "Identifique escopo: | aplica-se ao nível mais baixo sem parênteses."
                                  ],
                                  "verification": "Crie e teste 3 padrões básicos com | em regex101.com e capture screenshots de matches.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "regex101.com ou regexr.com",
                                    "Lista de strings de teste: 'cat', 'dog', 'cats', 'dogs'"
                                  ],
                                  "tips": "Sempre use parênteses para controlar precedência em uniões complexas.",
                                  "learningObjective": "Aplicar corretamente a sintaxe do operador | em padrões simples.",
                                  "commonMistakes": [
                                    "Esquecer parênteses em uniões com concatenação",
                                    "Match parcial ao invés de exato (use ^ e $)"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Construir Padrões Alternativos Complexos",
                                  "subSteps": [
                                    "Combine | com outros operadores: (ab|cd)* para repetições alternativas.",
                                    "Crie padrões para tokens reais: 'if|else|while' para palavras-chave.",
                                    "Incorpore classes de caracteres: [a-zA-Z_][a-zA-Z0-9_]*|(if|else).",
                                    "Pratique aninhamento: (a(b|c))|(d(e|f)).",
                                    "Otimize: prefira uniões curtas à esquerda para eficiência."
                                  ],
                                  "verification": "Desenvolva 2 padrões complexos para tokens de linguagem e teste com 10 strings variadas.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Editor de código com suporte a regex (VS Code)",
                                    "Exemplos de tokens de compiladores (manuais de Flex/Lex)"
                                  ],
                                  "tips": "Ordene alternativas da mais específica para a menos para melhor performance.",
                                  "learningObjective": "Integrar união com outros operadores ER para padrões realistas.",
                                  "commonMistakes": [
                                    "Ambiguidade sem parênteses",
                                    "Uniões muito longas que degradam performance"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Testar e Validar Padrões de União",
                                  "subSteps": [
                                    "Crie suíte de testes: positivos (matches esperados) e negativos (non-matches).",
                                    "Use flags como /i para case-insensitive em testes.",
                                    "Analise explainers em regex101 para entender ordem de matching.",
                                    "Debug falhas: verifique precedência e escopo de |.",
                                    "Refatore padrões ineficientes identificados nos testes."
                                  ],
                                  "verification": "Execute testes completos em 3 padrões e documente taxa de acerto >95%.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "regex101.com com explainer",
                                    "Planilha de testes (Google Sheets)"
                                  ],
                                  "tips": "Comece testes com casos edge: strings vazias, longas, com caracteres especiais.",
                                  "learningObjective": "Validar robustez de padrões com união através de testes sistemáticos.",
                                  "commonMistakes": [
                                    "Não testar non-matches",
                                    "Ignorar backtracking excessivo em alternativos"
                                  ]
                                }
                              ],
                              "practicalExample": "Em análise léxica de compiladores, use 'int|float|string' para tokenizar tipos de dados primitivos em código fonte, permitindo que o lexer identifique 'int x;' ou 'float y;' corretamente.",
                              "finalVerifications": [
                                "Construa um padrão ER com | que tokeniza 5 palavras-chave sem falsos positivos.",
                                "Explique precedência em '(a|b)c|d'.",
                                "Teste e corrija um padrão falho fornecido.",
                                "Compare matching de 'a|b*' vs '(a|b)*'.",
                                "Otimize um padrão com múltiplas | para eficiência."
                              ],
                              "assessmentCriteria": [
                                "Precisão na construção de padrões (sem erros de sintaxe ou lógica).",
                                "Cobertura completa de casos de teste (positivos/negativos/edge).",
                                "Uso correto de parênteses para precedência.",
                                "Eficiência: matching rápido sem backtracking excessivo.",
                                "Explicação clara do raciocínio em padrões complexos.",
                                "Integração com outros operadores ER."
                              ],
                              "crossCurricularConnections": [
                                "Lógica Booleana: União como OR em expressões lógicas.",
                                "Teoria de Autômatos: | como união de linguagens regulares.",
                                "Programação: Similar a switch-case ou if-elif em código.",
                                "Linguística Computacional: Análise de padrões alternativos em NLP."
                              ],
                              "realWorldApplication": "Em compiladores e parsers (ex: Flex para lexer), união define tokens alternativos como operadores ('+|-|*|/') ou identificadores vs keywords, essencial para análise léxica eficiente em linguagens de programação."
                            },
                            "estimatedTime": "0.5 hora",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.3.1.2",
                            "name": "Concatenação de Padrões",
                            "description": "Utilizar a concatenação para combinar subpadrões sequenciais, como em identificadores que começam com letra seguida de dígitos ou underscores.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o Conceito de Concatenação em Expressões Regulares",
                                  "subSteps": [
                                    "Leia a definição de concatenação: combinação sequencial obrigatória de subpadrões.",
                                    "Analise exemplos básicos, como 'ab' que matches 'a' seguido de 'b'.",
                                    "Compare com alternância ('a|b') para destacar a diferença.",
                                    "Identifique quando usar concatenação em vez de outros operadores.",
                                    "Anote exemplos de concatenação em padrões reais."
                                  ],
                                  "verification": "Explique em suas próprias palavras o que é concatenação e dê um exemplo simples.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Documentação de Regex (MDN ou Python re docs)",
                                    "Bloco de notas"
                                  ],
                                  "tips": "Visualize concatenação como 'colar' padrões um após o outro sem espaços ou opções.",
                                  "learningObjective": "Dominar a definição e o propósito da concatenação como operação sequencial obrigatória.",
                                  "commonMistakes": [
                                    "Confundir com alternância (|)",
                                    "Adicionar espaços acidentais entre subpadrões",
                                    "Ignorar sensibilidade a maiúsculas/minúsculas"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Construir Padrões Simples com Concatenação",
                                  "subSteps": [
                                    "Crie um padrão para 'letra seguida de dígito': [a-z][0-9].",
                                    "Teste o padrão em strings como 'a1', 'b2' (válidas) e '1a', 'aa' (inválidas).",
                                    "Expanda para 'duas letras seguidas': [a-z][a-z].",
                                    "Adicione quantificadores básicos, como [a-z][a-z]? para opcional.",
                                    "Registre 5 testes manuais com resultados esperados."
                                  ],
                                  "verification": "Construa e teste manualmente 3 padrões concatenados simples sem erros.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Editor de texto ou playground online como regex101.com",
                                    "Lista de strings de teste"
                                  ],
                                  "tips": "Sempre teste com casos limite: strings vazias, longas ou com caracteres especiais.",
                                  "learningObjective": "Aplicar concatenação para formar padrões compostos de subpadrões básicos.",
                                  "commonMistakes": [
                                    "Esquecer de ancorar o padrão (^ e $)",
                                    "Usar . em vez de classes específicas",
                                    "Não considerar escapes para caracteres especiais"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Aplicar Concatenação a Identificadores",
                                  "subSteps": [
                                    "Defina o padrão de identificador: começa com letra [a-zA-Z], seguida de alfanuméricos ou _: [a-zA-Z0-9_]*.",
                                    "Escreva o regex completo: ^[a-zA-Z][a-zA-Z0-9_]*$.",
                                    "Teste com exemplos válidos: 'var1', '_invalid_start' (inválido), 'user_123' (válido).",
                                    "Modifique para suportar múltiplas palavras ou variações comuns.",
                                    "Compare com padrões de linguagens como C ou Python."
                                  ],
                                  "verification": "Crie um regex que valide corretamente 10 identificadores, 5 válidos e 5 inválidos.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Regex101.com ou Regexr.com",
                                    "Lista de identificadores de exemplo de código fonte"
                                  ],
                                  "tips": "Use classes de caracteres [a-zA-Z] para eficiência e legibilidade.",
                                  "learningObjective": "Construir regex complexo para tokens reais usando concatenação.",
                                  "commonMistakes": [
                                    "Permitir _ no início",
                                    "Esquecer o * para repetição",
                                    "Não usar ^ e $ para matching completo"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Testar e Refinar Padrões Concatenados",
                                  "subSteps": [
                                    "Use uma ferramenta de regex para testar o padrão de identificador em um conjunto de dados.",
                                    "Identifique falhas e refine o padrão (ex: adicionar suporte a Unicode se necessário).",
                                    "Integre o regex em um snippet de código Python ou JS para validação automática.",
                                    "Analise performance com strings longas.",
                                    "Documente o padrão final com explicação."
                                  ],
                                  "verification": "Execute testes automatizados que passem em 100% dos casos esperados.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Python ou JavaScript REPL",
                                    "Conjunto de 20 strings de teste (10 válidas, 10 inválidas)"
                                  ],
                                  "tips": "Sempre inclua testes para edge cases como identificadores de 1 char ou max length.",
                                  "learningObjective": "Validar e otimizar padrões concatenados em contextos reais de análise léxica.",
                                  "commonMistakes": [
                                    "Overfitting ao testar só casos felizes",
                                    "Ignorar diferenças entre engines de regex (PCRE vs Python)",
                                    "Não escapar caracteres regex acidentalmente"
                                  ]
                                }
                              ],
                              "practicalExample": "Crie um regex para validar identificadores de variáveis em uma linguagem de programação: ^[a-zA-Z][a-zA-Z0-9_]*$. Teste em 'myVar123' (válido), '123var' (inválido), '_private' (inválido). Em código Python: import re; re.match(r'^[a-zA-Z][a-zA-Z0-9_]*$', 'myVar123') != None.",
                              "finalVerifications": [
                                "Construir regex concatenado para identificador sem erros sintáticos.",
                                "Validar corretamente 90%+ de strings de teste (válidas e inválidas).",
                                "Explicar cada subpadrão no regex composto.",
                                "Integrar o regex em um validador simples de código.",
                                "Identificar e corrigir 3 erros comuns em padrões concatenados.",
                                "Comparar com regex de linguagens reais como JavaScript variables."
                              ],
                              "assessmentCriteria": [
                                "Precisão do regex: matches exatos sem falsos positivos/negativos.",
                                "Estrutura: uso correto e minimalista de concatenação.",
                                "Cobertura de casos: testes incluem edge cases.",
                                "Eficiência: padrão legível e performático.",
                                "Documentação: explicação clara dos subpadrões.",
                                "Aplicação: integração funcional em código."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Reconhecimento de sequências e padrões formais.",
                                "Linguística: Análise morfológica de palavras e tokens.",
                                "Programação: Parsing e tokenização em compiladores.",
                                "Lógica: Construção sequencial de expressões compostas."
                              ],
                              "realWorldApplication": "Em compiladores e analisadores léxicos (ex: lexers em GCC ou VS Code), validação de nomes de variáveis/usernames em apps web, sanitização de inputs em formulários para evitar injeções."
                            },
                            "estimatedTime": "0.5 hora",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.3.1.3",
                            "name": "Estrela de Kleene e Quantificadores",
                            "description": "Aplicar o fechamento de Kleene (*) e quantificadores (+, ?) para repetir padrões, como em comentários de múltiplas linhas ou sequências de dígitos em números.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o Fechamento de Kleene (*)",
                                  "subSteps": [
                                    "Estude a definição: * aplica-se a um padrão anterior e significa 'zero ou mais ocorrências'.",
                                    "Analise exemplos simples: 'a*' corresponde a '', 'a', 'aa', 'aaa', etc.",
                                    "Compare com ausência de *: 'a' só corresponde a uma 'a' exata.",
                                    "Teste em ferramenta online como regex101.com com strings variadas.",
                                    "Pratique escrevendo 3 padrões usando * em palavras com consoantes repetidas."
                                  ],
                                  "verification": "Consegue listar 5 strings que correspondem a 'ab*' e explicar por quê?",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Regex101.com ou Regexr.com",
                                    "Documentação de Regex básica (MDN ou Python re module)"
                                  ],
                                  "tips": "Lembre-se: * é 'greedy' por padrão, captura o máximo possível; use *? para non-greedy.",
                                  "learningObjective": "Dominar o conceito de zero ou mais repetições com * e diferenciá-lo de quantificadores fixos.",
                                  "commonMistakes": [
                                    "Confundir * com + (que requer pelo menos uma), achar que * sempre requer o padrão."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Explorar Quantificadores + e ?",
                                  "subSteps": [
                                    "Defina +: 'uma ou mais ocorrências' do padrão anterior, ex: 'a+' corresponde a 'a', 'aa', mas não ''.",
                                    "Defina ?: 'zero ou uma ocorrência', ex: 'colou?r' corresponde a 'color' e 'colr'.",
                                    "Compare os três: Crie tabela com exemplos para *, +, ? em padrões como 'dígito' (\\d).",
                                    "Teste interativamente: Use playground de regex para validar entradas como números de telefone.",
                                    "Escreva 4 regex usando cada quantificador em contextos simples."
                                  ],
                                  "verification": "Escreva regex para: (1) um ou mais dígitos, (2) 'am' opcional em 'team/amteam'."
                                },
                                "estimatedTime: ",
                                "materials: [",
                                "tips: ",
                                "learningObjective: ",
                                "commonMistakes: ["
                              ],
                              "practicalExample": "Em análise léxica de código C++, use `//[^*\\n]*(?:\\*(?!/)[^*\\n]*)*\\*/?` para comentários de múltiplas linhas (simplificado com * para repetir linhas não-*/); ou `\\d+` para tokens numéricos inteiros como 123 ou 4567.",
                              "finalVerifications": [
                                "Explicar verbalmente ou por escrito a diferença entre *, + e ? com exemplos.",
                                "Criar regex funcional para matching de comentários de linha única: '//.*'.",
                                "Validar sequência de dígitos opcionais em IDs: '[A-Z]\\d?'.",
                                "Testar e debugar uma regex com quantificadores em 5 strings de teste.",
                                "Converter um padrão sem quantificadores para usar * ou + corretamente."
                              ],
                              "assessmentCriteria": [
                                "Precisão conceitual: Correta distinção entre zero-mais, uma-mais e zero-uma (90% acerto).",
                                "Aplicação prática: Regexes criadas matcham 100% dos casos de teste fornecidos.",
                                "Eficiência: Evita quantificadores desnecessários ou excessivamente amplos.",
                                "Debugging: Identifica e corrige erros comuns como greedy matching em <5 min.",
                                "Criatividade: Propõe pelo menos 2 usos originais em tokens léxicos."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria de Autômatos Finitos e Linguagens Regulares (Kleene como operação de fechamento).",
                                "Linguística Computacional: Reconhecimento de padrões em textos naturais ou código fonte.",
                                "Programação: Integração em linguagens como Python (re module) ou JavaScript para parsing.",
                                "Engenharia de Software: Validação de inputs em formulários web ou logs de sistemas."
                              ],
                              "realWorldApplication": "Em compiladores (ex: lexer do GCC usa quantificadores para tokens como números e strings); editores como VS Code para highlight de sintaxe; validação de senhas/email em apps web; parsing de logs em DevOps para extrair padrões repetidos."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.3.1.4",
                            "name": "Classes de Caracteres e Literais",
                            "description": "Definir classes de caracteres ([a-z], \\d) e escapar literais especiais para representar conjuntos de símbolos válidos em tokens como operadores ou identificadores.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender Classes de Caracteres Básicas",
                                  "subSteps": [
                                    "Estude as classes POSIX shorthand: \\d (dígitos), \\w (word chars), \\s (espaços), e suas negações como \\D, \\W, \\S.",
                                    "Aprenda ranges: [a-z] para letras minúsculas, [A-Z] maiúsculas, [0-9] dígitos, e combinações como [a-zA-Z0-9_].",
                                    "Pratique negação com [^abc] para qualquer coisa exceto a, b, c.",
                                    "Liste 5 classes comuns e seus significados em um caderno.",
                                    "Teste em um playground online para ver matches."
                                  ],
                                  "verification": "Crie uma tabela com 5 classes, exemplos de match e non-match, e valide com um tester regex.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Documentação MDN ou regex101.com, caderno para anotações.",
                                  "tips": "Lembre-se: classes são atalhos para conjuntos eficientes; use [] para definir.",
                                  "learningObjective": "Identificar e usar classes de caracteres para representar conjuntos de símbolos comuns em tokens.",
                                  "commonMistakes": "Confundir \\d com [0-9] (são equivalentes, mas pratique ambos); esquecer que ranges são inclusivos."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Dominar Escapamento de Literais Especiais",
                                  "subSteps": [
                                    "Identifique caracteres especiais em regex: . * ? + ^ $ | () [] {} \\.",
                                    "Aprenda a escapar com \\: \\. para ponto literal, \\* para asterisco literal, etc.",
                                    "Pratique escapando strings como '.*+?' para torná-las literais: \\.\\*\\+\\?.",
                                    "Escreva 3 expressões com literais especiais escapados para matching exato.",
                                    "Teste diferenças entre escapado e não escapado em um tester."
                                  ],
                                  "verification": "Escreva uma regex que match 'op.*' literalmente e teste com strings contendo esses chars.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Regex cheat sheet (regexr.com), editor de texto com suporte regex.",
                                  "tips": "Sempre escape dentro de [] apenas se necessário (ex: ] precisa escapar, mas . não dentro de []).",
                                  "learningObjective": "Escapar corretamente caracteres com significado especial para tratá-los como literais em tokens.",
                                  "commonMistakes": "Esquecer de escapar ] em classes como [a-z]]; usar escape desnecessário fora de contexto."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Aplicar Classes e Escapamentos em Tokens de Identificadores",
                                  "subSteps": [
                                    "Defina padrão para identificadores: letra ou _ inicial, seguido de alfanuméricos ou _.",
                                    "Escreva regex: [a-zA-Z_][a-zA-Z0-9_]* (use classes para eficiência).",
                                    "Teste com exemplos: 'var', '_abc123', '1var' (deve falhar).",
                                    "Adicione âncoras ^ e $ para match completo: ^[a-zA-Z_][a-zA-Z0-9_]*$.",
                                    "Experimente variações com negações para excluir inválidos."
                                  ],
                                  "verification": "Crie 5 strings de teste (3 válidas, 2 inválidas) e confirme matches corretos.",
                                  "estimatedTime": "40 minutos",
                                  "materials": "regex101.com ou similar, lista de exemplos de identificadores de linguagens como C/Python.",
                                  "tips": "Use [a-zA-Z] em vez de A-Za-z para case-insensitive se aplicável, mas especifique.",
                                  "learningObjective": "Construir regex precisas para tokens como identificadores usando classes e escapes.",
                                  "commonMistakes": "Permitir dígito inicial [a-zA-Z0-9_] em vez de separar; esquecer * para zero ou mais."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar em Tokens de Operadores e Verificação Prática",
                                  "subSteps": [
                                    "Liste operadores comuns: +, -, *, /, =, (, ), etc., e escape especiais como * e /.",
                                    "Crie classe para operadores: [+\\-*/=()\\[\\]{}\\\\;,:] (escape - no meio ou fim).",
                                    "Teste regex ^[+\\-*/=()\\[\\]{}\\\\;,:]$ para match exato de um operador.",
                                    "Combine em um lexer simples: alternar entre identificador ou operador.",
                                    "Debug 3 casos de falha comum usando tester."
                                  ],
                                  "verification": "Implemente um matcher que classifique 10 tokens como ID ou OP corretamente.",
                                  "estimatedTime": "35 minutos",
                                  "materials": "Lexer online tester, exemplos de código fonte simples.",
                                  "tips": "Posicione - no final da classe para literal sem escape: [()+*-].",
                                  "learningObjective": "Usar classes e escapes para definir operadores e outros tokens simbólicos.",
                                  "commonMistakes": "Não escapar - em ranges como [a-z-] (vira range inválido); confusão com quantificadores."
                                }
                              ],
                              "practicalExample": "Para um lexer de mini-linguagem: Identificador /^[a-zA-Z_][a-zA-Z0-9_]*$/ matcha 'foo123'; Operador /^[\\+\\-*/=()]$ matcha '+' mas não '++' (trata como dois tokens). Teste em regex101.com com input 'x = 42 + y;' para destacar tokens.",
                              "finalVerifications": [
                                "Escreva regex para [a-z0-9] usando shorthand e range, teste com 'abc123'.",
                                "Escape '.+*?' e match literalmente em string contendo esses chars.",
                                "Crie regex para identificador válido/inválido e liste 3 exemplos cada.",
                                "Defina classe para operadores matemáticos [+\\-*/] e verifique matches.",
                                "Explique diferença entre \\d e [0-9], com negação.",
                                "Construa regex combinada para ID ou OP: ([a-zA-Z_][a-zA-Z0-9_]*|[+\\-*/=()]) e teste."
                              ],
                              "assessmentCriteria": [
                                "Precisão das classes: cobertura completa sem falsos positivos/negativos (90%+ acurácia em testes).",
                                "Correto uso de escapes: nenhum erro de interpretação de literais especiais.",
                                "Eficiência: preferência por shorthands como \\w sobre ranges longos.",
                                "Clareza: regex legíveis com comentários ou explicações.",
                                "Abrangência: lida com casos edge como início com _, operadores compostos não matchados.",
                                "Validação prática: todos testes passam em ferramenta online."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria de Conjuntos (classes como união/interseção de símbolos).",
                                "Linguística: Padrões morfológicos em palavras e símbolos de programação.",
                                "Processamento de Texto: Similar a grep/awk para busca em logs.",
                                "Desenvolvimento Web: Validação de forms (email patterns com classes).",
                                "Automação: Scripts shell com regex para parsing de arquivos."
                              ],
                              "realWorldApplication": "Em compiladores como GCC ou editores como VS Code (syntax highlighting), classes e escapes definem tokens para análise léxica, permitindo parsing eficiente de código fonte, validação de inputs em apps web e ferramentas de busca como grep."
                            },
                            "estimatedTime": "0.5 hora",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.1.3.1.2",
                        "name": "Padrões Regulares para Tokens Comuns",
                        "description": "Exemplifica a construção de expressões regulares específicas para tokens típicos de linguagens de programação, como identificadores, números e strings.",
                        "specificSkills": [
                          {
                            "id": "10.1.1.3.1.2.1",
                            "name": "ER para Identificadores",
                            "description": "Especificar padrões para identificadores, como [a-zA-Z_][a-zA-Z0-9_]* , garantindo que iniciem com letra ou underscore e sigam com alfanuméricos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a Estrutura de Identificadores em Linguagens de Programação",
                                  "subSteps": [
                                    "Defina o que é um identificador: nome dado a variáveis, funções ou labels.",
                                    "Identifique requisitos comuns: deve iniciar com letra ou underscore, seguido de alfanuméricos ou underscore.",
                                    "Pesquise exemplos em linguagens como C, Python ou Java.",
                                    "Analise por que não pode iniciar com dígito (evita ambiguidade com números).",
                                    "Discuta comprimento máximo típico (ex: 31 caracteres)."
                                  ],
                                  "verification": "Escreva uma definição clara e liste 3 exemplos válidos/inválidos.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Documentação de linguagens (Python, C specs)",
                                    "Papel e caneta para anotações"
                                  ],
                                  "tips": "Use exemplos reais de código para ilustrar.",
                                  "learningObjective": "Entender o propósito e convenções de identificadores.",
                                  "commonMistakes": [
                                    "Confundir com strings ou números",
                                    "Ignorar case-sensitivity"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Construir a Parte Inicial da Expressão Regular",
                                  "subSteps": [
                                    "Represente letras maiúsculas e minúsculas: [a-zA-Z]",
                                    "Adicione underscore: [a-zA-Z_]",
                                    "Teste com strings simples: 'abc', '_var', 'A1' (inválido).",
                                    "Explique o uso de colchetes para classes de caracteres.",
                                    "Garanta que capture exatamente um caractere inicial."
                                  ],
                                  "verification": "Escreva e teste a ER inicial em um validador online (ex: regex101.com).",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Ferramenta online de teste de regex (regex101, regexr)",
                                    "Exemplos de identificadores"
                                  ],
                                  "tips": "Sempre escape caracteres especiais se necessário, mas aqui não é.",
                                  "learningObjective": "Dominar classes de caracteres para o prefixo de identificadores.",
                                  "commonMistakes": [
                                    "Esquecer maiúsculas ou minúsculas",
                                    "Incluir dígitos no início"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Estender a ER para o Corpo do Identificador",
                                  "subSteps": [
                                    "Defina alfanuméricos e underscore: [a-zA-Z0-9_]",
                                    "Use quantificador *: zero ou mais ocorrências.",
                                    "Combine com inicial: [a-zA-Z_][a-zA-Z0-9_]*",
                                    "Teste casos: 'var', 'var123', '_', '123var' (inválido).",
                                    "Considere âncoras ^ e $ para matching completo."
                                  ],
                                  "verification": "Valide 5 identificadores válidos e 5 inválidos com a ER completa.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Validador de regex online",
                                    "Lista de testes pré-preparada"
                                  ],
                                  "tips": "O * permite identificadores de 1 caractere (ex: '_').",
                                  "learningObjective": "Aplicar quantificadores para sequências variáveis.",
                                  "commonMistakes": [
                                    "Usar + em vez de * (exclui single char)",
                                    "Permitir dígitos no início"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Validar e Refinar a Expressão Regular",
                                  "subSteps": [
                                    "Crie conjunto de testes: edge cases como '', 'a', 'a_b_c123'.",
                                    "Use ferramenta para matching e substituição.",
                                    "Ajuste para insensibilidade a case se necessário (flag i).",
                                    "Documente limitações (ex: não Unicode).",
                                    "Compare com ERs de linguagens reais."
                                  ],
                                  "verification": "Todos os 10+ testes passam; documente resultados.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Regex tester",
                                    "Especificações de linguagens"
                                  ],
                                  "tips": "Teste com flags como /i para case-insensitive.",
                                  "learningObjective": "Garantir robustez da ER através de testes exaustivos.",
                                  "commonMistakes": [
                                    "Não testar vazios ou longos",
                                    "Ignorar underscores múltiplos"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Aplicar em Contexto de Análise Léxica",
                                  "subSteps": [
                                    "Integre em scanner lexer fictício.",
                                    "Defina precedência sobre keywords.",
                                    "Gere tokens para matches.",
                                    "Simule input: 'int x=1;'",
                                    "Discuta conflitos com números ou keywords."
                                  ],
                                  "verification": "Implemente um matcher simples em Python/JS e teste.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Editor de código",
                                    "Biblioteca regex (re em Python)"
                                  ],
                                  "tips": "Priorize matches mais longos em lexers reais.",
                                  "learningObjective": "Conectar ER a pipeline de compilador.",
                                  "commonMistakes": [
                                    "Match parcial em vez de completo",
                                    "Confundir com keywords"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um lexer para mini-Python, use [a-zA-Z_][a-zA-Z0-9_]* para tokenizar 'myVar123' como ID('myVar123'), rejeitando '123var'. Teste input: 'if x=1;' → tokens: KEYWORD('if'), ID('x'), ASSIGN('='), NUM('1'), SEMI(';').",
                              "finalVerifications": [
                                "Escreve corretamente [a-zA-Z_][a-zA-Z0-9_]*",
                                "Valida 10+ exemplos corretamente",
                                "Explica por que inicia com letra/_",
                                "Identifica edge cases como '_' ou 'a'",
                                "Integra em exemplo de lexer",
                                "Documenta testes e resultados"
                              ],
                              "assessmentCriteria": [
                                "Precisão da ER (sem falsos positivos/negativos)",
                                "Cobertura de testes (válidos/inválidos/edge)",
                                "Clareza na explicação de componentes",
                                "Aplicação contextual em lexer",
                                "Robustez contra variações (case, length)"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria de Autômatos e Linguagens Formais (AFD para regex)",
                                "Linguística: Padrões morfológicos em nomes de variáveis",
                                "Lógica: Definição precisa de regras para evitar ambiguidades",
                                "Design de Software: Convenções de nomenclatura em programação"
                              ],
                              "realWorldApplication": "Usado em compiladores (GCC, Python interpreter), editores (VSCode syntax highlight), validadores de código (linters como ESLint), e ferramentas de refatoração para garantir conformidade com padrões de identificadores."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.1.3.1"
                            ]
                          },
                          {
                            "id": "10.1.1.3.1.2.2",
                            "name": "ER para Constantes Numéricas",
                            "description": "Construir expressões para inteiros (\\d+), reais (\\d+\\.\\d*) e notação científica, considerando opcionais como sinal e expoente.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar componentes básicos de constantes numéricas e expressões regulares",
                                  "subSteps": [
                                    "Identifique os componentes: dígitos (\\d), sinal opcional ([+-]?), parte inteira (\\d+), parte fracionária (\\.\\d*), expoente (e[+-]?\\d+).",
                                    "Estude exemplos: 123 (inteiro), -45.67 (real), 1.23e4 (científica).",
                                    "Pratique matching simples com \\d+ em ferramentas online como regex101.",
                                    "Liste diferenças entre inteiros, reais e notação científica.",
                                    "Anote padrões opcionais: sinal, ponto decimal, expoente."
                                  ],
                                  "verification": "Crie uma tabela listando 5 exemplos válidos e inválidos com seus componentes identificados corretamente.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Ferramenta online de teste de ER (regex101.com)",
                                    "Documentação de ER básica (MDN ou Python re module)"
                                  ],
                                  "tips": "Comece com os blocos mais simples (\\d+) antes de adicionar opcionais para evitar confusão.",
                                  "learningObjective": "Compreender e decompor os elementos constitutivos de constantes numéricas em termos de ER.",
                                  "commonMistakes": [
                                    "Confundir \\d (um dígito) com \\d+ (um ou mais)",
                                    "Ignorar que o sinal pode ser ausente",
                                    "Esquecer que o expoente é case-insensitive em alguns contextos (e/E)"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Construir ER para inteiros com sinal opcional",
                                  "subSteps": [
                                    "Escreva ER básica para inteiro positivo: \\d+.",
                                    "Torne o sinal opcional: [+-]?\\d+.",
                                    "Teste com exemplos: 42, -123, +0, 007.",
                                    "Adicione âncoras para precisão: ^[+-]?\\d+$.",
                                    "Valide contra inválidos: --5, 12a, .5."
                                  ],
                                  "verification": "A ER deve matchar exatamente 10 exemplos de inteiros (pos/neg) e rejeitar 5 inválidos em uma ferramenta de teste.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Regex101 ou Regexr",
                                    "Lista de 20 números de teste pré-preparada"
                                  ],
                                  "tips": "Use ? para opcional e + para um ou mais dígitos; teste sempre com bordas como zero e leading zeros.",
                                  "learningObjective": "Dominar a construção de ER para inteiros, incluindo sinal opcional.",
                                  "commonMistakes": [
                                    "Usar * em vez de + (permite vazio)",
                                    "Esquecer o ? no sinal",
                                    "Não ancorar a expressão (^ e $)"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Expandir para números reais (decimais)",
                                  "subSteps": [
                                    "Combine inteiro com opcional decimal: [+-]?\\d+(\\.\\d*)?.",
                                    "Garanta pelo menos um dígito antes ou depois do ponto: [+-]?(\\d+(\\.\\d*)?|\\.\\d+).",
                                    "Teste: 3.14, -0.5, 42., .75, mas rejeite ..1 ou 3..",
                                    "Refine para evitar ponto sozinho: [+-]?\\d*\\.?\\d+.",
                                    "Versão robusta: [+-]?((\\d+(\\.\\d*)?)|\\.\\d+)."
                                  ],
                                  "verification": "Crie e teste uma ER que matcha 8 reais válidos (incluindo .5 e 5.) e rejeita 6 inválidos como 3. ou .",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Ferramenta de ER",
                                    "Exemplos de números decimais de linguagens como JavaScript"
                                  ],
                                  "tips": "Use grupos ( ) para alternar entre parte.inteira e .fracao; priorize casos com ponto sem dígitos após.",
                                  "learningObjective": "Construir ER precisa para números reais, lidando com ponto decimal opcional.",
                                  "commonMistakes": [
                                    "Permitir ponto sem dígitos (\\.? permite 3.)",
                                    "Não cobrir .123",
                                    "Duplicar grupos desnecessariamente"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Incorporar notação científica",
                                  "subSteps": [
                                    "Adicione expoente opcional: [eE][+-]?\\d+ após a parte numérica.",
                                    "Combine: [+-]?((\\d+(\\.\\d*)?|\\.\\d+)([eE][+-]?\\d+)?).",
                                    "Teste: 1.23e4, -5E-2, 42e0, mas rejeite 1e, 1.2e+.",
                                    "Refine para expoente com pelo menos um dígito: [eE][+-]?\\d+.",
                                    "Versão final completa para todos os casos."
                                  ],
                                  "verification": "A ER matcha 10 exemplos mistos (int, real, sci) e rejeita 8 inválidos como 1e ou 3.14E.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Regex101 com flag i para case-insensitive",
                                    "Especificações de literais numéricos (ECMAScript ou C++)"
                                  ],
                                  "tips": "Torne [eE] case-insensitive com flag i; teste expoentes negativos e zero.",
                                  "learningObjective": "Integrar notação científica à ER de constantes numéricas.",
                                  "commonMistakes": [
                                    "Esquecer case E/e",
                                    "Permitir expoente vazio (e$)",
                                    "Não opcionalizar o expoente"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Testar, refinar e validar a ER completa",
                                  "subSteps": [
                                    "Escreva ER unificada: ^[+-]?((\\d+(\\.\\d*)?|\\.\\d+)([eE][+-]?\\d+)?)$.",
                                    "Crie suíte de testes: 50 casos (válidos/inválidos).",
                                    "Use ferramentas para debug: highlight matches, explain.",
                                    "Ajuste para edge cases: 0, -0.0e0, +1.E+2.",
                                    "Documente a ER com comentários."
                                  ],
                                  "verification": "100% acurácia em suíte de 30 testes; gere relatório de matches.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Regex101 com explain",
                                    "Lista expandida de testes incluindo NaN/Inf se aplicável"
                                  ],
                                  "tips": "Sempre use ^ $ para full match; itere testando um caso falho por vez.",
                                  "learningObjective": "Validar e otimizar ER completa para constantes numéricas.",
                                  "commonMistakes": [
                                    "Não testar leading/trailing zeros",
                                    "Ignorar overflow em expoentes grandes",
                                    "Match parcial sem âncoras"
                                  ]
                                }
                              ],
                              "practicalExample": "Construa e teste esta ER: ^[+-]?(?:\\d+(?:\\.\\d*)?|\\.\\d+)(?:[eE][+-]?\\d+)?$ para matchar '123', '-45.67', '1.23e-4', '5.0E+2' mas rejeitar '12.3.4', '1e', '.e3'. Use em um parser simples de input numérico.",
                              "finalVerifications": [
                                "A ER matcha todos os inteiros pos/neg com/ sem leading zeros.",
                                "Captura reais com/ sem parte inteira ou fracionária.",
                                "Reconhece notação científica com e/E, sinal e dígitos no expoente.",
                                "Rejeita inválidos: ponto duplo, expoente vazio, letras extras.",
                                "Full match com ^ $ sem sobras.",
                                "Funciona case-insensitive para E/e."
                              ],
                              "assessmentCriteria": [
                                "Precisão: 95%+ acerto em 50 testes variados.",
                                "Cobertura completa: inteiros, reais, científica com opcionais.",
                                "Eficiência: ER concisa sem redundâncias desnecessárias.",
                                "Robustez: Lida com edge cases como 0, .0, 1e0.",
                                "Documentação: Explicação clara dos grupos e escolhas.",
                                "Testes: Suíte documentada com válidos/inválidos."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Representações numéricas (inteiros, decimais, científica).",
                                "Física/Química: Notação científica para grandes/pequenos valores.",
                                "Programação: Parsing de input em linguagens (JSON, CSV parsers).",
                                "Lógica/Matemática Discreta: Autômatos finitos subjacentes às ER."
                              ],
                              "realWorldApplication": "Em compiladores e interpretadores (ex: Python, Java) para tokenizar literais numéricos durante análise léxica; validadores de formulários web para números científicos; processadores de dados científicos (CSV com floats em e-notação)."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.1.3.1"
                            ]
                          },
                          {
                            "id": "10.1.1.3.1.2.3",
                            "name": "ER para Literais de String e Comentários",
                            "description": "Definir padrões para strings \\\"[^\\\"]*\\\" e comentários como //.* ou /*.*?*/ , lidando com escapes e aninhamento simples.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender e Criar Regex Básica para Strings Literais Simples",
                                  "subSteps": [
                                    "Estude a estrutura básica de uma string literal: abertura com aspas duplas '\"', conteúdo sem aspas, fechamento com '\"'.",
                                    "Escreva a regex inicial: \\\"[^\\\"]*\\\" para capturar strings sem escapes.",
                                    "Teste com exemplos simples como \"hello\" e \"world\" em uma ferramenta online de regex.",
                                    "Identifique limitações: não lida com quebras de linha ou aspas internas.",
                                    "Ajuste para permitir quebras de linha opcionais se necessário no lexer."
                                  ],
                                  "verification": "A regex matches corretamente strings simples sem falhar em casos como \"abc\" ou \"123\", mas falha em \"a\\\"b\".",
                                  "estimatedTime": "30 minutes",
                                  "materials": [
                                    "Ferramenta de teste regex (regex101.com)",
                                    "Editor de texto como VS Code"
                                  ],
                                  "tips": "Use flags como 'g' para global matching e visualize grupos de captura.",
                                  "learningObjective": "Construir e validar regex básica para strings literais sem escapes.",
                                  "commonMistakes": [
                                    "Esquecer de escapar as aspas na regex",
                                    "Não testar com strings vazias como \"\""
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Incorporar Suporte a Escapes em Strings Literais",
                                  "subSteps": [
                                    "Aprenda escapes comuns: \\\" para aspas internas, \\\\ para barra, \\n para nova linha.",
                                    "Modifique a regex para \\\"([^\\\\\"]|\\\\.)*\\\" permitindo caracteres escapados.",
                                    "Teste com casos: \"He said \\\"hi\\\"\", \"path\\\\to\\\\file\", \"line1\\nline2\".",
                                    "Use grupos de não-captura (?:) para clareza e eficiência.",
                                    "Valide que escapes inválidos sejam tratados como erro no lexer posterior."
                                  ],
                                  "verification": "Regex captura strings com escapes corretos e ignora ou falha em escapes malformados.",
                                  "estimatedTime": "45 minutes",
                                  "materials": [
                                    "regex101.com com exemplos de código fonte",
                                    "Documentação ECMAScript regex"
                                  ],
                                  "tips": "Sempre escape a barra invertida como \\\\ na regex literal em JS/Python.",
                                  "learningObjective": "Estender regex de strings para lidar com sequências de escape de forma robusta.",
                                  "commonMistakes": [
                                    "Confundir escapes da linguagem com escapes da regex",
                                    "Permitir escapes infinitos sem limite"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Desenvolver Regex para Comentários de Linha Única (//)",
                                  "subSteps": [
                                    "Analise estrutura: // seguido de qualquer coisa até fim da linha (não incluindo \\n).",
                                    "Crie regex: //[^\n]* capturando até quebras de linha.",
                                    "Teste com: // this is a comment, // com \"aspas\", e linhas vazias //.",
                                    "Considere precedência: deve vir após strings para evitar matching prematuro.",
                                    "Adicione flag multiline (m) se aplicável para ^ e $ por linha."
                                  ],
                                  "verification": "Regex matches todo conteúdo após // até \\n, incluindo strings internas sem quebrar.",
                                  "estimatedTime": "25 minutes",
                                  "materials": [
                                    "Editor com syntax highlighting",
                                    "regex101.com com flag 'm'"
                                  ],
                                  "tips": "Use [^\r\n] para cobrir \\r\\n em Windows.",
                                  "learningObjective": "Criar regex precisa para comentários single-line sem invadir outras linhas.",
                                  "commonMistakes": [
                                    "Matching após strings: teste ordem no lexer",
                                    "Permitir // dentro de strings"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Criar Regex para Comentários Multi-Linha (/* */) com Aninhamento Simples",
                                  "subSteps": [
                                    "Entenda estrutura básica: /* conteúdo */ sem aninhamento completo (regex limitada).",
                                    "Regex inicial: /\\*.*?\\*/ com flag 's' (dotall) para nova linhas.",
                                    "Para aninhamento simples (um nível): adapte para /\\*(?:[^*/]|/\\*[^*/]*\\*/)*\\*/ mas teste limites.",
                                    "Teste: /* comment */, /* multi\nline */, /* nested /* simple */ */.",
                                    "Discuta limitações: regex não lida com aninhamento profundo; sugira parser para casos complexos."
                                  ],
                                  "verification": "Regex fecha corretamente em /* abc */ e /* /* inner */ outer */, mas falha em deeply nested.",
                                  "estimatedTime": "50 minutes",
                                  "materials": [
                                    "regex101.com com flag 's'",
                                    "Exemplos de código C/JS com comentários"
                                  ],
                                  "tips": "Use reluctant quantifier ? para evitar greediness excessiva.",
                                  "learningObjective": "Implementar regex para block comments com suporte básico a aninhamento.",
                                  "commonMistakes": [
                                    "Greedy matching que pula fechamentos",
                                    "Não testar com /* */*/"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Integrar e Testar Regex no Contexto de Lexer",
                                  "subSteps": [
                                    "Ordene padrões no lexer: strings primeiro, depois comentários, para evitar conflitos.",
                                    "Implemente um mini-lexer em Python/JS testando input com mix de tokens.",
                                    "Teste edge cases: \"//\" dentro string, /* \" */ */, fim de arquivo.",
                                    "Meça performance e ajuste com lookaheads se necessário.",
                                    "Documente regex finais com explicações."
                                  ],
                                  "verification": "Lexer tokeniza corretamente código com strings e comentários misturados sem erros.",
                                  "estimatedTime": "40 minutes",
                                  "materials": [
                                    "Python ou JS REPL",
                                    "Código de teste com 20+ linhas variadas"
                                  ],
                                  "tips": "Use named groups para facilitar debugging.",
                                  "learningObjective": "Aplicar todas regex em um lexer funcional e validar robustez.",
                                  "commonMistakes": [
                                    "Ordem errada de matching",
                                    "Ignorar EOF em comentários"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um lexer para uma linguagem como JS: input 'console.log(\"Hello \\\"world\\\"//comment\"); /* multi\nline */' deve tokenizar: ID('console'), DOT, ID('log'), LPAREN, STRING('Hello \"world\"'), RPAREN, SEMICOLON, COMMENT('//comment'), COMMENT('/* multi\nline */').",
                              "finalVerifications": [
                                "Regex para strings matches com escapes como \\\" e \\n corretamente.",
                                "Comentários single-line param em \\n sem invadir linhas seguintes.",
                                "Block comments fecham corretamente com aninhamento simples.",
                                "Nenhum falso positivo: \"//\" em string não é comentário.",
                                "Testes em 10+ edge cases passam sem falhas.",
                                "Performance aceitável em inputs de 1k linhas."
                              ],
                              "assessmentCriteria": [
                                "Precisão: 95%+ match correto em conjunto de testes padrão.",
                                "Cobertura de escapes: Suporte a \\, \\\", \\n, \\t.",
                                "Tratamento de bordas: Strings vazias, comentários vazios, EOF.",
                                "Eficiência: Regex não-backtracking excessivo.",
                                "Documentação: Cada regex explicada com exemplos.",
                                "Integração: Funciona em lexer sem conflitos."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria de Autômatos e Linguagens Formais (regex como AFN).",
                                "Linguística: Análise sintática e padrões morfológicos em código.",
                                "Engenharia de Software: Parsing e ferramentas de desenvolvimento.",
                                "Lógica: Precedência e resolução de ambiguidades em padrões."
                              ],
                              "realWorldApplication": "Essas regex são usadas em compiladores (GCC, V8), editores (VS Code syntax highlighting), linters (ESLint), e ferramentas de análise estática para ignorar comentários/strings ao processar código fonte."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.1.3.1"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "10.1.1.3.1.3",
                        "name": "Especificação Formal de Padrões Léxicos",
                        "description": "Integra expressões regulares em uma especificação léxica completa, abordando priorização de tokens, regra do match mais longo e exclusão de padrões inválidos.",
                        "specificSkills": [
                          {
                            "id": "10.1.1.3.1.3.1",
                            "name": "Construção de Léxico com ER",
                            "description": "Definir um conjunto de regras ER para todos os tokens de uma mini-linguagem, listando-as em ordem de prioridade para análise léxica.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Analisar a mini-linguagem e identificar todos os tokens necessários",
                                  "subSteps": [
                                    "Leia a especificação da mini-linguagem para entender sua sintaxe.",
                                    "Liste todas as categorias de tokens: palavras-chave, identificadores, literais numéricos, operadores, delimitadores e símbolos especiais.",
                                    "Classifique cada token com exemplos de strings válidas e inválidas.",
                                    "Crie uma tabela inicial com colunas: Categoria, Exemplos, Observações.",
                                    "Verifique se todos os elementos da gramática estão cobertos, sem omissões."
                                  ],
                                  "verification": "Tabela completa de tokens identificados, cobrindo 100% da especificação da linguagem.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Especificação da mini-linguagem",
                                    "Editor de texto ou planilha (Google Sheets)",
                                    "Papel e caneta para rascunhos"
                                  ],
                                  "tips": [
                                    "Comece pelas palavras-chave fixas, pois elas são mais simples.",
                                    "Anote ambiguidades potenciais entre categorias desde o início.",
                                    "Use exemplos reais da linguagem para validar a lista."
                                  ],
                                  "learningObjective": "Identificar e categorizar precisamente os tokens léxicos de uma linguagem de programação simples.",
                                  "commonMistakes": [
                                    "Esquecer tokens de whitespace ou comentários.",
                                    "Confundir tokens sintáticos com semânticos.",
                                    "Não considerar variações de case sensitivity."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Definir expressões regulares (ER) para cada categoria de token",
                                  "subSteps": [
                                    "Para cada categoria, escreva uma ER precisa que aceite apenas strings válidas daquela categoria.",
                                    "Teste a ER em uma ferramenta online como regex101.com com exemplos positivos e negativos.",
                                    "Refine a ER para evitar falsos positivos, usando âncoras (^ e $) se necessário.",
                                    "Garanta que a ER seja minimalista e eficiente, priorizando legibilidade.",
                                    "Documente cada ER com uma explicação breve do padrão."
                                  ],
                                  "verification": "Todas as ERs testadas e validadas com pelo menos 5 exemplos por categoria.",
                                  "estimatedTime": "1 hora e 30 minutos",
                                  "materials": [
                                    "Ferramenta de teste de regex (regex101.com ou similar)",
                                    "Editor de texto com suporte a regex",
                                    "Lista de tokens do passo 1"
                                  ],
                                  "tips": [
                                    "Use classes de caracteres como \\w ou [a-zA-Z] para simplicidade.",
                                    "Sempre teste com bordas: strings vazias, longas e com caracteres especiais.",
                                    "Prefira ERs não-greedy (?*) quando houver concatenações variáveis."
                                  ],
                                  "learningObjective": "Construir ERs robustas e testáveis para padrões léxicos específicos.",
                                  "commonMistakes": [
                                    "ERs muito permissivas que capturam tokens de outras categorias.",
                                    "Ignorar escape de caracteres especiais como . ou *.",
                                    "Não testar com inputs edge-case como números com expoentes."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Estabelecer a ordem de prioridade das regras ER",
                                  "subSteps": [
                                    "Identifique possíveis sobreposições ou ambiguidades entre ERs (ex: identificador vs. palavra-chave).",
                                    "Aplique o princípio de 'maximal munch' ou ordem de regras para resolver conflitos.",
                                    "Ordene as regras: priorize padrões mais específicos primeiro (ex: palavras-chave antes de identificadores).",
                                    "Crie uma lista numerada das regras em ordem de aplicação.",
                                    "Teste a ordem com strings ambíguas para confirmar resolução correta."
                                  ],
                                  "verification": "Lista ordenada testada sem ambiguidades em pelo menos 3 casos de conflito.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Lista de ERs do passo 2",
                                    "Ferramenta de teste de regex com múltiplas regras",
                                    "Exemplos ambíguos gerados manualmente"
                                  ],
                                  "tips": [
                                    "Palavras-chave e literais sempre antes de identificadores.",
                                    "Use comprimento máximo para desempate quando possível.",
                                    "Documente o motivo de cada prioridade na lista."
                                  ],
                                  "learningObjective": "Resolver conflitos léxicos através de ordenação prioritária de regras.",
                                  "commonMistakes": [
                                    "Ordenar por ordem alfabética em vez de especificidade.",
                                    "Ignorar o impacto de prefixos comuns entre tokens.",
                                    "Não testar a ordem com o analisador léxico simulado."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Validar e documentar o léxico completo",
                                  "subSteps": [
                                    "Compile todas as regras em um documento único: categoria, ER, prioridade e exemplos.",
                                    "Simule a análise léxica em 5-10 strings de código da mini-linguagem.",
                                    "Corrija discrepâncias identificadas nos testes.",
                                    "Verifique cobertura total: nenhum token sobrando ou fantasma.",
                                    "Gere um relatório final com o léxico pronto para uso em um scanner."
                                  ],
                                  "verification": "Simulação bem-sucedida de análise léxica em exemplos complexos sem erros.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Documento consolidado (Markdown ou Word)",
                                    "Simulador manual ou ferramenta como JFlex/Flex",
                                    "Strings de teste da mini-linguagem"
                                  ],
                                  "tips": [
                                    "Automatize testes se possível com scripts simples.",
                                    "Inclua regras para ignorar whitespace e comentários no final.",
                                    "Revise com um colega para feedback externo."
                                  ],
                                  "learningObjective": "Produzir um léxico formal validado e pronto para implementação em um compilador.",
                                  "commonMistakes": [
                                    "Esquecer regras para fim de arquivo ou erros léxicos.",
                                    "Não simular o fluxo completo de tokenização.",
                                    "Deixar ERs sem otimização para performance."
                                  ]
                                }
                              ],
                              "practicalExample": "Para uma mini-linguagem de expressões aritméticas: Tokens incluem: PALAVRAS_CHAVE: 'if', 'else'; IDENTIFICADOR: [a-zA-Z][a-zA-Z0-9]*; NUMERO: \\d+(\\.\\d+)?; OPERADORES: \\+ | - | \\* | /; DELIMITADORES: \\( | \\) | ;. Ordem: 1. PALAVRAS_CHAVE, 2. NUMERO, 3. OPERADORES, 4. IDENTIFICADOR, 5. DELIMITADORES. Teste: 'if(x+1)' → if, (, IDENTIFICADOR(x), (, NUMERO(1), ), )",
                              "finalVerifications": [
                                "Todas as categorias de tokens estão cobertas sem lacunas.",
                                "Nenhuma string válida é rejeitada ou mal tokenizada.",
                                "Conflitos resolvidos corretamente pela ordem de prioridade.",
                                "ERs são eficientes e testadas em múltiplos cenários.",
                                "Documentação inclui explicações e exemplos para cada regra.",
                                "Simulação de análise léxica em código completo da mini-linguagem funciona perfeitamente."
                              ],
                              "assessmentCriteria": [
                                "Completude: 100% dos tokens da especificação incluídos.",
                                "Precisão das ERs: Taxa de acerto >95% em testes automatizados.",
                                "Correção da priorização: Zero ambiguidades em casos de sobreposição.",
                                "Clareza da documentação: Fácil de implementar em um scanner.",
                                "Eficiência: ERs otimizadas sem backtracking excessivo.",
                                "Robustez: Lida com edge cases como strings vazias ou longas."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria de autômatos finitos e linguagens regulares.",
                                "Linguística: Análise morfológica e padrões fonéticos.",
                                "Engenharia de Software: Especificação formal de DSLs (Domain-Specific Languages).",
                                "Inteligência Artificial: Processamento de linguagem natural com regex.",
                                "Design de Sistemas: Modelagem de front-ends de compiladores."
                              ],
                              "realWorldApplication": "Em compiladores reais como GCC ou JavaCC, o léxico define como scanners (gerados por Flex/Lex) tokenizam código-fonte, garantindo análise eficiente em projetos de software em escala, como navegadores web ou sistemas operacionais."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.1.3.1",
                              "10.1.1.3.1.2"
                            ]
                          },
                          {
                            "id": "10.1.1.3.1.3.2",
                            "name": "Resolução de Ambiguidade em Tokens",
                            "description": "Aplicar regras como 'match mais longo' e ordem de especificação para resolver conflitos, como entre identificadores e palavras-chave.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender Conceitos Básicos de Ambiguidade em Análise Léxica",
                                  "subSteps": [
                                    "Defina ambiguidade léxica como situações onde múltiplos padrões de tokens podem coincidir com a mesma sequência de caracteres.",
                                    "Identifique exemplos comuns, como uma sequência que pode ser um identificador ou uma palavra-chave.",
                                    "Explique o impacto da ambiguidade não resolvida no processo de compilação.",
                                    "Revise expressões regulares básicas usadas em especificações léxicas.",
                                    "Discuta por que regras determinísticas são necessárias para scanners léxicos."
                                  ],
                                  "verification": "Escreva uma definição clara de ambiguidade léxica e liste 3 exemplos de entrada ambígua.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Documentação de análise léxica (ex: Dragon Book capítulo 3)",
                                    "Editor de texto para anotações"
                                  ],
                                  "tips": "Use diagramas de fluxo para visualizar como um scanner processa input ambíguo.",
                                  "learningObjective": "Entender o que causa ambiguidades em tokens e por que resolvê-las é crítico.",
                                  "commonMistakes": "Confundir ambiguidade léxica com sintática; assumir que todas as linguagens têm as mesmas regras."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Dominar a Regra do 'Match Mais Longo'",
                                  "subSteps": [
                                    "Estude a regra: o scanner deve escolher o token com o maior número de caracteres correspondentes.",
                                    "Aplique a regra a exemplos simples, como 'if' vs 'ifa' (escolher 'ifa' se for identificador).",
                                    "Implemente um scanner manual que priorize matches longos em pseudocódigo.",
                                    "Teste com sequências como '==>' onde '==' e '=' competem.",
                                    "Analise casos onde match mais longo previne prefixos indesejados."
                                  ],
                                  "verification": "Resolva 5 exemplos de input ambíguo aplicando apenas a regra de match mais longo e justifique cada escolha.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Ferramenta online de regex tester (ex: regex101.com)",
                                    "Papel e caneta para simular scanner"
                                  ],
                                  "tips": "Sempre comece do início da entrada e avance o máximo possível antes de recuar.",
                                  "learningObjective": "Aplicar corretamente a regra de match mais longo para resolver conflitos de prefixo.",
                                  "commonMistakes": "Escolher matches curtos por engano; ignorar que a regra se aplica sequencialmente."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar Ordem de Especificação de Padrões",
                                  "subSteps": [
                                    "Aprenda que padrões são testados na ordem de declaração na especificação léxica.",
                                    "Crie uma lista ordenada de padrões: palavras-chave primeiro, depois identificadores.",
                                    "Simule um scanner que itera padrões em ordem até encontrar o primeiro match.",
                                    "Combine com match mais longo: para cada posição, teste todos em ordem e pegue o mais longo que matcha.",
                                    "Debugue erros onde ordem errada causa tokens incorretos."
                                  ],
                                  "verification": "Reordene uma lista de 10 padrões e demonstre como a ordem afeta a tokenização de uma string de teste.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Flex ou JFlex para teste real (opcional)",
                                    "Pseudocódigo template para scanner"
                                  ],
                                  "tips": "Coloque padrões mais específicos (ex: palavras-chave) antes de genéricos (ex: identificadores).",
                                  "learningObjective": "Usar ordem de especificação para quebrar empates após match mais longo.",
                                  "commonMistakes": "Declarar identificadores antes de palavras-chave; esquecer de retestar após match parcial."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Integrar Regras e Aplicar em Cenários Complexos",
                                  "subSteps": [
                                    "Combine match mais longo e ordem em um algoritmo completo de resolução.",
                                    "Resolva casos reais como 'intx' (identificador, não 'int' + 'x') ou 'for=='.",
                                    "Implemente um mini-scanner em Python ou Java para uma gramática simples.",
                                    "Teste com inputs edge-case como strings vazias ou sequências longas.",
                                    "Otimize para eficiência, evitando backtracking desnecessário."
                                  ],
                                  "verification": "Tokenize corretamente 10 strings complexas usando as duas regras e valide contra saída esperada.",
                                  "estimatedTime": "90 minutos",
                                  "materials": [
                                    "Editor de código (VS Code)",
                                    "Exemplos de specs léxicas de linguagens reais (C, Python)"
                                  ],
                                  "tips": "Implemente como uma loop: posição atual, teste padrões em ordem, avance pelo comprimento do match.",
                                  "learningObjective": "Resolver ambiguidades reais integrando ambas as regras em um scanner funcional.",
                                  "commonMistakes": "Não resetar posição após falha; priorizar ordem sobre comprimento incorretamente."
                                }
                              ],
                              "practicalExample": "Considere a entrada 'ifx='. Especificação: 1. 'if' (palavra-chave), 2. identificador [a-z]+, 3. '='. Match mais longo em posição 0: 'ifx' (3 chars como id) > 'if' (2 chars), então tokeniza como identificador 'ifx' seguido de '='.",
                              "finalVerifications": [
                                "Tokenizar corretamente uma string com múltiplas ambiguidades usando as regras.",
                                "Explicar por que uma escolha específica foi feita em um caso dado.",
                                "Identificar e corrigir uma spec léxica mal ordenada.",
                                "Implementar um scanner simples que resolva ambiguidades sem erros.",
                                "Comparar tokenização antes/depois de aplicar regras.",
                                "Debugar falhas em tokenização causadas por violações de regras."
                              ],
                              "assessmentCriteria": [
                                "Precisão na aplicação de match mais longo (100% correto em testes).",
                                "Correta ordenação de padrões em specs propostas.",
                                "Explicações claras e justificadas para resoluções.",
                                "Eficiência do algoritmo implementado (sem backtracking excessivo).",
                                "Tratamento completo de edge cases.",
                                "Integração coerente das duas regras sem conflitos."
                              ],
                              "crossCurricularConnections": [
                                "Linguística: Análise morfológica e resolução de ambiguidade em parsers naturais.",
                                "Matemática: Teoria de autômatos finitos e expressões regulares.",
                                "Engenharia de Software: Design de DSLs e parsers customizados.",
                                "Inteligência Artificial: Tokenização em NLP e LLMs."
                              ],
                              "realWorldApplication": "Em compiladores como GCC ou clang, resolve ambiguidades para tokenizar código C++ corretamente (ex: 'class' como keyword vs identificador), permitindo builds confiáveis em projetos grandes como kernels Linux."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.1.3.1",
                              "10.1.1.3.1.2"
                            ]
                          },
                          {
                            "id": "10.1.1.3.1.3.3",
                            "name": "Uso de Ferramentas como Flex",
                            "description": "Escrever especificações em formato Flex/Lex usando ER para gerar analisadores léxicos automáticos, testando com entrada de exemplo.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Instalação e Configuração Inicial do Flex",
                                  "subSteps": [
                                    "Abra o terminal ou shell no seu sistema operacional (Linux, macOS ou Windows com WSL).",
                                    "Instale o Flex usando o gerenciador de pacotes: 'sudo apt install flex' no Ubuntu/Debian, 'brew install flex' no macOS, ou equivalente.",
                                    "Verifique a instalação executando 'flex --version' para confirmar a versão instalada.",
                                    "Instale dependências adicionais como gcc para compilação: 'sudo apt install build-essential'.",
                                    "Crie um diretório de projeto: 'mkdir lexer-project && cd lexer-project'."
                                  ],
                                  "verification": "Comando 'flex --version' retorna versão sem erros e diretório de projeto criado.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Terminal/shell",
                                    "Gerenciador de pacotes (apt, brew, yum)",
                                    "Editor de texto (VS Code, Vim)"
                                  ],
                                  "tips": "Use um ambiente virtual ou container Docker para isolar a instalação e evitar conflitos.",
                                  "learningObjective": "Configurar um ambiente de desenvolvimento funcional para Flex e ferramentas relacionadas.",
                                  "commonMistakes": [
                                    "Esquecer de usar 'sudo' em sistemas Linux",
                                    "Não instalar compilador C como gcc",
                                    "Ignorar verificação de versão levando a incompatibilidades"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Estruturação de um Arquivo de Especificação Flex Básico",
                                  "subSteps": [
                                    "Crie um arquivo 'lexer.l' com as três seções principais: definitions (%%), rules (%%) e user code.",
                                    "Na seção definitions, defina macros simples como DIGIT [0-9] e LETTER [a-zA-Z].",
                                    "Na seção rules, adicione regras básicas como {DIGIT}+ { printf(\"NUMBER\"); }.",
                                    "Na seção user code, inclua main() com yylex() e loop de leitura.",
                                    "Salve e revise sintaxe para evitar erros comuns de Flex."
                                  ],
                                  "verification": "Arquivo 'lexer.l' criado com estrutura completa e sem erros de sintaxe visíveis.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Editor de texto",
                                    "Documentação oficial do Flex (man flex ou online)"
                                  ],
                                  "tips": "Use comentários %{} para C code na seção definitions e teste regras isoladas primeiro.",
                                  "learningObjective": "Compreender e implementar a estrutura padrão de um arquivo Flex usando expressões regulares básicas.",
                                  "commonMistakes": [
                                    "Confundir ordem das seções (definitions antes de rules)",
                                    "Esquecer chaves {} nas ações",
                                    "Usar ER inválidas sem testar escaping"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Definição de Padrões Léxicos Complexos com Expressões Regulares",
                                  "subSteps": [
                                    "Expanda definitions com padrões como ID [a-zA-Z_][a-zA-Z0-9_]* e OP [+\\-*/].",
                                    "Adicione regras para tokens como identificadores, operadores, palavras-chave (ex: \"if\" { printf(\"IF\"); }) e whitespace ignorado.",
                                    "Implemente precedência com regras mais específicas primeiro (ex: palavras-chave antes de IDs).",
                                    "Adicione tratamento de erros para caracteres inválidos: . { printf(\"ERROR\"); }.",
                                    "Inclua opções de Flex como %option noyywrap para simplificar."
                                  ],
                                  "verification": "Arquivo atualizado reconhece pelo menos 5 tipos de tokens diferentes em simulação mental.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Documentação de ER (regex101.com)",
                                    "Exemplos de specs léxicas online"
                                  ],
                                  "tips": "Teste ER individualmente em ferramentas online antes de integrar no Flex para validar matches.",
                                  "learningObjective": "Escrever expressões regulares precisas para tokens reais, gerenciando ambiguidades e precedências.",
                                  "commonMistakes": [
                                    "Regras gerais antes de específicas causando matches errados",
                                    "Não escapar caracteres especiais como / ou *",
                                    "Ignorar case-sensitivity em IDs"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Compilação e Geração do Analisador Léxico",
                                  "subSteps": [
                                    "Execute 'flex lexer.l' para gerar lexer.c.",
                                    "Compile com gcc: 'gcc -o lexer lexer.c' (inclua -lfl se necessário para libfl).",
                                    "Execute o binário: './lexer < input.txt' com um arquivo de teste simples.",
                                    "Debug erros de compilação ajustando includes ou opções de Flex.",
                                    "Adicione headers como <stdio.h> na seção user code se ausentes."
                                  ],
                                  "verification": "Binário 'lexer' executa sem erros de segmentação e processa input básico.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Compilador gcc",
                                    "Arquivo de input de teste (input.txt)"
                                  ],
                                  "tips": "Use 'flex -d lexer.l' para debug com mais output e '-l' para libfl em linking.",
                                  "learningObjective": "Gerar e compilar código C automatizado a partir de especificação Flex.",
                                  "commonMistakes": [
                                    "Esquecer de linkar libfl com -lfl",
                                    "Input sem newline final causando hangs",
                                    "Não incluir main() completo"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Teste e Validação do Analisador Léxico",
                                  "subSteps": [
                                    "Crie 'input.txt' com exemplos: 'if x = 42 + y;' incluindo tokens variados.",
                                    "Execute './lexer < input.txt' e verifique output de tokens no terminal.",
                                    "Crie casos de teste edge: inputs vazios, inválidos, longos identificadores.",
                                    "Compare output esperado vs real, ajustando regras conforme necessário.",
                                    "Meça performance com inputs grandes e otimize ER se lento."
                                  ],
                                  "verification": "Todos tokens em 5+ casos de teste são classificados corretamente sem falsos positivos.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Arquivos de teste (input1.txt, input2.txt)",
                                    "Script de diff para automação"
                                  ],
                                  "tips": "Redirecione output para arquivo: './lexer < input.txt > output.txt' e use diff.",
                                  "learningObjective": "Validar robustez do lexer contra entradas reais e edge cases.",
                                  "commonMistakes": [
                                    "Não testar whitespace ou multi-line inputs",
                                    "Ignorar trailing characters",
                                    "Outputs sem newline confundindo parsing"
                                  ]
                                }
                              ],
                              "practicalExample": "Crie um lexer para uma mini-linguagem: reconheça palavras-chave 'if', 'while'; identificadores [a-zA-Z_][a-zA-Z0-9_]*; números [0-9]+; operadores +, -, *, /, =; ignore espaços e quebre linhas. Teste com input: 'if x = 42 + y while z < 10;' esperando output: IF ID = NUMBER + ID WHILE ID < NUMBER ;",
                              "finalVerifications": [
                                "Flex gera lexer.c sem warnings.",
                                "Binário compila e executa com input variado sem crashes.",
                                "Tokens são identificados corretamente em 90%+ dos casos de teste.",
                                "Edge cases como inputs vazios ou inválidos são tratados graciosamente.",
                                "Output inclui tipo e lexema para cada token.",
                                "Performance aceitável (<1s para 1000 linhas)."
                              ],
                              "assessmentCriteria": [
                                "Precisão e completude das ER (sem over/under-matching).",
                                "Estrutura correta do arquivo .l com todas seções.",
                                "Compilação limpa e execução estável.",
                                "Cobertura de testes incluindo edge cases.",
                                "Eficiência das regras (sem backtracking excessivo).",
                                "Documentação inline no código Flex."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria de Linguagens Formais e Autômatos Finitos.",
                                "Linguística Computacional: Reconhecimento de padrões em linguagem natural.",
                                "Engenharia de Software: Automação de parsing em pipelines de compilação.",
                                "Algoritmos: Otimização de scanners DFA.",
                                "Design de Sistemas: Integração com parsers como Bison/Yacc."
                              ],
                              "realWorldApplication": "Em compiladores profissionais como GCC/Clang, editores de código (syntax highlighting no VS Code), ferramentas de linting (ESLint), processadores de logs e validadores de formatos (JSON/XML parsers), onde lexers automáticos aceleram desenvolvimento e reduzem erros manuais."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.1.3.1",
                              "10.1.1.3.1.2"
                            ]
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.1.4",
                    "name": "Autômatos Finitos em Análise Léxica",
                    "description": "Uso de autômatos finitos não-determinísticos (AFN) e determinísticos (AFD) para reconhecimento de tokens.",
                    "individualConcepts": [
                      {
                        "id": "10.1.1.4.1",
                        "name": "Autômatos Finitos Não-Determinísticos (AFN)",
                        "description": "Autômatos finitos não-determinísticos (AFN) são modelos computacionais que reconhecem linguagens regulares, permitindo transições múltiplas para o mesmo símbolo, transições ε (vazias) e não-determinismo, ideais para descrever padrões léxicos de tokens de forma compacta.",
                        "specificSkills": [
                          {
                            "id": "10.1.1.4.1.1",
                            "name": "Definir componentes de um AFN",
                            "description": "Identificar e descrever os elementos formais de um AFN: conjunto de estados Q, alfabeto Σ, função de transição δ, estado inicial q0 e estados finais F, incluindo o papel das transições ε.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os Conceitos Básicos de Autômatos Finitos",
                                  "subSteps": [
                                    "Revise a definição formal de um autômato finito determinístico (AFD) para contrastar com AFN.",
                                    "Identifique as diferenças chave: não-determinismo permite múltiplas transições por símbolo.",
                                    "Estude o papel do não-determinismo em simplificar a construção de autômatos.",
                                    "Leia sobre a equivalência entre AFN e AFD em termos de linguagem reconhecida.",
                                    "Anote as vantagens do AFN na análise léxica de compiladores."
                                  ],
                                  "verification": "Escreva um resumo de 100 palavras comparando AFD e AFN, destacando quando usar AFN.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Livro de Teoria da Computação (ex: Sipser), notas de aula sobre autômatos"
                                  ],
                                  "tips": "Use diagramas para visualizar o não-determinismo desde o início.",
                                  "learningObjective": "Diferenciar AFN de AFD e justificar seu uso em compiladores.",
                                  "commonMistakes": "Confundir não-determinismo com aleatoriedade; lembre-se que é escolha não-única."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Definir os Componentes Formais Q, Σ, q0 e F",
                                  "subSteps": [
                                    "Defina Q como o conjunto finito de estados, explicando que inclui todos os nós do autômato.",
                                    "Descreva Σ como o alfabeto finito de símbolos de entrada (ex: {0,1} para binário).",
                                    "Explique q0 como o estado inicial único, de onde o processamento começa.",
                                    "Detalhe F como o conjunto de estados finais (aceitadores), podendo ser múltiplos.",
                                    "Crie exemplos simples para cada: Q={q0,q1}, Σ={a,b}, etc."
                                  ],
                                  "verification": "Liste os 4 componentes com definições precisas e um exemplo para cada.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Papel e caneta para diagramas, ferramenta online como JFLAP"
                                  ],
                                  "tips": "Sempre use notação matemática: AFN = (Q, Σ, δ, q0, F).",
                                  "learningObjective": "Memorizar e descrever precisamente Q, Σ, q0 e F.",
                                  "commonMistakes": "Esquecer que Q é finito ou que F pode ter múltiplos estados."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explorar a Função de Transição δ e Transições ε",
                                  "subSteps": [
                                    "Defina δ: Q × (Σ ∪ {ε}) → P(Q), onde P(Q) é o conjunto de potências de Q.",
                                    "Explique que δ permite múltiplos estados de destino por transição.",
                                    "Detalhe transições ε: movimentos sem consumir símbolo, δ(q, ε) = conjunto de estados.",
                                    "Discuta como ε-transições facilitam união e concatenação em expressões regulares.",
                                    "Pratique calculando δ* (fecho de transição) para um pequeno exemplo."
                                  ],
                                  "verification": "Calcule δ para um estado dado com símbolo e ε, mostrando múltiplos caminhos.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Simulador JFLAP ou Draw.io para diagramas, exemplos de AFN com ε"
                                  ],
                                  "tips": "Pense em ε como 'pule para outro estado gratuitamente'.",
                                  "learningObjective": "Entender o papel central de δ no não-determinismo e ε-transições.",
                                  "commonMistakes": "Confundir δ com função determinística; sempre indique P(Q)."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Integrar Componentes em uma Definição Completa de AFN",
                                  "subSteps": [
                                    "Monte um AFN completo usando todos os componentes: especifique Q, Σ, δ, q0, F.",
                                    "Desenhe o diagrama destacando transições ε com setas tracejadas.",
                                    "Simule a aceitação de uma string curta, rastreando todos os caminhos possíveis.",
                                    "Converta um AFN simples para AFD usando subconjuntos para validar compreensão.",
                                    "Explique o papel do AFN na análise léxica: tokenização flexível."
                                  ],
                                  "verification": "Construa e descreva um AFN que aceite {a, bb}, incluindo todos componentes.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "JFLAP ou papel para diagrama, exemplos de livros de compiladores"
                                  ],
                                  "tips": "Teste seu AFN com strings aceitas e rejeitadas.",
                                  "learningObjective": "Construir e validar uma definição formal completa de AFN.",
                                  "commonMistakes": "Omitir ε no domínio de δ ou esquecer estados inalcançáveis."
                                }
                              ],
                              "practicalExample": "Construa um AFN para reconhecer strings sobre Σ={a,b} que contenham 'a' ou 'bb': Q={q0,q1,q2,q3}, q0 inicial, F={q1,q3}. Transições: δ(q0,a)={q1}, δ(q0,b)={q0}, δ(q0,ε)={q2}, δ(q2,b)={q2,q3}, δ(q3,b)={q3}. Simule 'abb': caminhos levam a q3 ∈ F, aceito.",
                              "finalVerifications": [
                                "Liste corretamente os 5 componentes formais de um AFN.",
                                "Descreva o papel das transições ε com exemplo.",
                                "Defina δ matematicamente, incluindo P(Q).",
                                "Construa um diagrama simples de AFN com ε.",
                                "Explique equivalência AFN-AFD.",
                                "Simule aceitação/rejeição de uma string em AFN."
                              ],
                              "assessmentCriteria": [
                                "Precisão nas definições formais (100% dos componentes corretos).",
                                "Compreensão de não-determinismo e ε-transições demonstrada.",
                                "Capacidade de construir e simular AFN simples.",
                                "Uso correto de notação matemática.",
                                "Integração com contexto de análise léxica.",
                                "Identificação de erros comuns evitados."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria dos Conjuntos (P(Q), união).",
                                "Lógica: Não-determinismo como escolha não exclusiva.",
                                "Engenharia de Software: Modelagem de fluxos em compiladores.",
                                "Algoritmos: Conversão AFN para AFD via construção de subconjuntos."
                              ],
                              "realWorldApplication": "Em compiladores como GCC ou Flex, AFNs modelam analisadores léxicos para tokenizar código-fonte eficientemente, convertendo expressões regulares em AFNs via Thompson's construction para processar linguagens de programação."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.4.1.2",
                            "name": "Construir AFN para expressões regulares simples",
                            "description": "Criar um AFN a partir de expressões regulares básicas como união, concatenação e estrela de Kleene, usando o método de Thompson para padrões como identificadores ou números em análise léxica.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender e Construir NFA para Símbolo Literal",
                                  "subSteps": [
                                    "Crie dois estados: um inicial (i) e um final (f).",
                                    "Adicione uma transição direta de i para f rotulada com o símbolo literal (ex: 'a').",
                                    "Marque i como estado inicial e f como estado final (duplo círculo).",
                                    "Desenhe o diagrama usando setas para transições.",
                                    "Teste mentalmente: o NFA aceita apenas a string com esse símbolo único."
                                  ],
                                  "verification": "Verifique se o diagrama tem exatamente 2 estados, uma transição com o símbolo e aceita apenas o literal correspondente.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e lápis",
                                    "Ferramenta online como JFLAP ou draw.io"
                                  ],
                                  "tips": "Sempre use círculos simples para estados não-finais e duplos para finais; rotule transições claramente.",
                                  "learningObjective": "Construir o bloco básico de um NFA para um único símbolo usando Thompson.",
                                  "commonMistakes": [
                                    "Adicionar transições epsilon desnecessárias",
                                    "Esquecer de marcar o estado final",
                                    "Confundir inicial com final"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Construir NFA para Operação de União (A | B)",
                                  "subSteps": [
                                    "Construa NFAs separados para A e B usando o Step 1.",
                                    "Crie um novo estado inicial (i') com transições epsilon para os iniciais de A e B.",
                                    "Crie um novo estado final (f') e adicione transições epsilon dos finais de A e B para f'.",
                                    "Remova marcações iniciais/finais antigas; i' é inicial, f' é final.",
                                    "Desenhe e verifique: aceita strings de A ou B."
                                  ],
                                  "verification": "O NFA tem 4+ estados (2 novos + sub-NFAs), aceita 'a' ou 'b' para (a|b), sem caminhos diretos entre A e B exceto via epsilon.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Papel e lápis",
                                    "JFLAP para simulação"
                                  ],
                                  "tips": "Use ε para transições epsilon; evite sobrepor estados para clareza visual.",
                                  "learningObjective": "Implementar união com estados auxiliares e epsilons no método Thompson.",
                                  "commonMistakes": [
                                    "Conectar diretamente finais de A/B sem novo final",
                                    "Esquecer epsilons do novo inicial",
                                    "Manter múltiplos finais"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Construir NFA para Concatenação (AB)",
                                  "subSteps": [
                                    "Construa NFAs para A e B separadamente.",
                                    "Adicione uma transição epsilon do final de A para o inicial de B.",
                                    "Mantenha o inicial de A como inicial geral e final de B como final geral.",
                                    "Remova qualquer marcação extra nos sub-NFAs.",
                                    "Teste: aceita strings que são A seguido de B."
                                  ],
                                  "verification": "O NFA aceita concatenação (ex: 'ab' para a.b), mas não 'a' ou 'b' isolados; uma epsilon entre sub-NFAs.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e lápis",
                                    "Diagramas de exemplo impressos"
                                  ],
                                  "tips": "Concatenação é sequencial; visualize o fluxo linear com epsilon como 'pule para próximo'.",
                                  "learningObjective": "Combinar NFAs em sequência usando epsilon para fluidez.",
                                  "commonMistakes": [
                                    "Adicionar transição com símbolo em vez de epsilon",
                                    "Inverter ordem A-B",
                                    "Criar loop desnecessário"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Construir NFA para Estrela de Kleene (A*)",
                                  "subSteps": [
                                    "Construa NFA para A.",
                                    "Crie novo inicial i' com epsilon para inicial de A e direto para novo final f'.",
                                    "Adicione epsilon do final de A para inicial de A (loop) e para f'.",
                                    "Marque i' inicial e f' final.",
                                    "Verifique: aceita ε, A, AA, etc."
                                  ],
                                  "verification": "O NFA aceita a string vazia (ε), A, e repetições; caminhos com loops epsilon.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Papel e lápis",
                                    "JFLAP para execução"
                                  ],
                                  "tips": "Pense em 'zero ou mais': sempre bypass via ε e loop opcional.",
                                  "learningObjective": "Implementar repetição zero ou mais com loops e bypass epsilon.",
                                  "commonMistakes": [
                                    "Exigir pelo menos uma A (sem bypass direto)",
                                    "Esquecer loop de volta",
                                    "Múltiplas entradas/saídas confusas"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Combinar Operações para Regex Simples (ex: Identificador)",
                                  "subSteps": [
                                    "Defina regex: letra (letra | dígito)* para identificador.",
                                    "Construa sub-NFAs: literal 'letra', união (letra|dígito), kleene star.",
                                    "Concatene: inicial letra + star da união.",
                                    "Desenhe diagrama completo e minimize epsilons onde possível.",
                                    "Simule em JFLAP com strings como 'var', 'x1', rejeite '1var'."
                                  ],
                                  "verification": "AFN aceita identificadores válidos (inicia com letra, resto alfanum), rejeita inválidos; estrutura Thompson preservada.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "JFLAP ou similar",
                                    "Papel para rascunho",
                                    "Exemplos de tokens léxicos"
                                  ],
                                  "tips": "Decomponha regex em árvore: aplique Thompson recursivamente de baixo para cima.",
                                  "learningObjective": "Compor NFAs complexos para padrões reais em análise léxica.",
                                  "commonMistakes": [
                                    "Confundir ordem de concatenação",
                                    "Esquecer star para zero ou mais",
                                    "Não tratar união corretamente nos dígitos"
                                  ]
                                }
                              ],
                              "practicalExample": "Construa o AFN para identificadores em análise léxica: [a-zA-Z][a-zA-Z0-9]*. Comece com NFA para letra, crie união letra|dígito, aplique *, concatene com primeira letra. O resultado deve aceitar 'abc123', 'x', mas rejeitar '123abc' ou ''.",
                              "finalVerifications": [
                                "O AFN possui um único estado inicial e um único estado final.",
                                "Todas as transições usam símbolos ou ε, sem ambiguidades.",
                                "Simulação aceita todas as strings válidas da regex e rejeita inválidas.",
                                "Estrutura segue método Thompson: epsilons para composição.",
                                "Número de estados é mínimo pelo Thompson (cerca de 8-12 para identificador).",
                                "Diagrama é legível e rotulado corretamente."
                              ],
                              "assessmentCriteria": [
                                "Precisão na aplicação das regras Thompson para cada operação.",
                                "Correção funcional: aceita/rejeita strings conforme regex.",
                                "Clareza e organização do diagrama (estados numerados, setas claras).",
                                "Eficiência: sem estados ou transições redundantes além do necessário.",
                                "Capacidade de decompor regex em subcomponentes.",
                                "Explicação verbal da construção passo a passo."
                              ],
                              "crossCurricularConnections": [
                                "Teoria dos Grafos (Ciência da Computação): NFAs como grafos direcionados com ε-arcos.",
                                "Matemática Discreta: Teoria de Linguagens Formais e Autômatos.",
                                "Programação: Uso de regex em linguagens como Python (re module) ou Java.",
                                "Engenharia de Software: Análise léxica em compiladores e parsers."
                              ],
                              "realWorldApplication": "Em compiladores e analisadores léxicos (ex: Flex, Lex), NFAs de regex definem tokens como identificadores e números, convertidos a AFDs para scanning eficiente em editores de código, validadores de formulários e motores de busca."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.4.1.3",
                            "name": "Simular execução de AFN em strings",
                            "description": "Executar passo a passo a leitura de uma string em um AFN, gerenciando ramos não-determinísticos e transições ε para determinar se a string é aceita como token válido.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar o AFN e a string de entrada",
                                  "subSteps": [
                                    "Identifique os componentes do AFN: estados Q, alfabeto Σ, função de transição δ, estado inicial I, estados finais F.",
                                    "Desenhe ou liste o diagrama do AFN, destacando transições ε e não-determinísticas.",
                                    "Escolha ou forneça a string w a ser processada (ex: w = 'aba').",
                                    "Marque a posição inicial na string (índice 0).",
                                    "Liste todos os estados acessíveis inicialmente."
                                  ],
                                  "verification": "Confirme que todos os componentes do AFN estão corretamente identificados e a string está pronta para processamento.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Diagrama do AFN impresso ou digital",
                                    "Papel e caneta para anotações",
                                    "String de teste escrita"
                                  ],
                                  "tips": "Use cores diferentes para transições ε (ex: tracejadas) e normais para facilitar visualização.",
                                  "learningObjective": "Compreender a estrutura formal de um AFN e preparar inputs para simulação.",
                                  "commonMistakes": [
                                    "Ignorar transições ε no diagrama",
                                    "Confundir estados iniciais com finais",
                                    "Escolher string fora do alfabeto Σ"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Inicializar o conjunto de estados atuais com ε-fecho",
                                  "subSteps": [
                                    "Comece com o estado inicial I.",
                                    "Calcule o ε-fecho de I: adicione todos os estados alcançáveis apenas por transições ε.",
                                    "Registre o conjunto S0 de estados atuais.",
                                    "Verifique se algum estado final está em S0 (caso a string seja vazia).",
                                    "Anote o conjunto S0 em uma tabela ou pilha de estados."
                                  ],
                                  "verification": "O conjunto S0 inclui todos os estados do ε-fecho de I e nenhum outro.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Tabela de transição ε-fechos pré-calculada (opcional)",
                                    "Folha para registrar conjuntos de estados"
                                  ],
                                  "tips": "Use uma fila ou pilha para rastrear estados ε sem loops infinitos (assuma AFN sem ciclos ε).",
                                  "learningObjective": "Dominar o cálculo de ε-fechos para gerenciar não-determinismo inicial.",
                                  "commonMistakes": [
                                    "Esquecer de fechar ε recursivamente",
                                    "Incluir estados não alcançáveis por ε",
                                    "Loop infinito em ciclos ε"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Processar cada símbolo da string gerenciando não-determinismo",
                                  "subSteps": [
                                    "Para cada símbolo σ em w (posição i=1 a |w|):",
                                    "  Calcule o movimento δ(S_{i-1}, σ): todos os estados alvo de transições σ do conjunto atual.",
                                    "  Calcule o ε-fecho do movimento resultante para obter S_i.",
                                    "  Registre S_i e avance o índice i.",
                                    "  Se S_i ficar vazio em qualquer ponto, rejeite a string."
                                  ],
                                  "verification": "Todos os símbolos foram processados e cada conjunto S_i foi calculado corretamente sem vazios prematuros.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Tabela de transições do AFN",
                                    "Lista de ε-fechos para cada estado"
                                  ],
                                  "tips": "Mantenha uma tabela: linha = símbolo, coluna = posição na string, célula = conjunto S_i.",
                                  "learningObjective": "Executar transições não-determinísticas e ε-fechos sequencialmente para strings.",
                                  "commonMistakes": [
                                    "Aplicar ε antes do movimento σ",
                                    "Perder ramos não-determinísticos",
                                    "Não fechar ε após movimento"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificar aceitação final",
                                  "subSteps": [
                                    "Após processar toda a string, examine o conjunto final S_|w|.",
                                    "Verifique se S_|w| intersecta com os estados finais F.",
                                    "Se houver interseção, aceite; caso contrário, rejeite.",
                                    "Registre o caminho de aceitação (um possível ramo que leva a F).",
                                    "Opcional: Liste todos os ramos para compreensão completa."
                                  ],
                                  "verification": "Decisão de aceitação/rejeição está correta baseada na interseção com F.",
                                  "estimatedTime": "10 minutos",
                                  "materials": [
                                    "Lista final de estados S_|w|",
                                    "Estados finais F destacados"
                                  ],
                                  "tips": "AFN aceita se HOUVER PELO MENOS UM caminho aceitador, não todos.",
                                  "learningObjective": "Determinar corretamente a aceitação de uma string por um AFN.",
                                  "commonMistakes": [
                                    "Requerer todos os ramos aceitarem",
                                    "Esquecer ε-fecho no final",
                                    "Confundir rejeição com não-determinismo"
                                  ]
                                }
                              ],
                              "practicalExample": "Considere um AFN para strings terminando em 'ab' sobre Σ={a,b}: Estados {q0,q1,q2,q3}, I=q0, F={q3}. Transições: q0 -a/ε-> q1, q0 -b-> q0, q1 -b-> q2, q2 -ε-> q3. Para w='aab': S0={q0,q1}, após 'a': movimento a dá vazio? Não, ε-fecho mantém. Simule: aceita pois ramos levam a q3.",
                              "finalVerifications": [
                                "Conjuntos de estados S_i calculados corretamente para todo exemplo.",
                                "Tratamento correto de transições ε em inicialização e após movimentos.",
                                "Gerenciamento de múltiplos ramos não-determinísticos sem perda.",
                                "Decisão final de aceitação baseada apenas em interseção com F.",
                                "Identificação de pelo menos um caminho aceitador quando aplicável.",
                                "Rejeição correta para strings inválidas."
                              ],
                              "assessmentCriteria": [
                                "Precisão no cálculo de ε-fechos (100% dos estados corretos).",
                                "Correta sequência de movimentos e fechamentos para cada símbolo.",
                                "Tratamento exaustivo de não-determinismo (todos os ramos considerados).",
                                "Decisão final justificada com evidência de interseção.",
                                "Tempo de simulação eficiente sem erros de rastreamento.",
                                "Capacidade de explicar verbalmente um passo aleatório."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria de Grafos (AFN como grafo direcionado multiaresta).",
                                "Programação: Implementação em código (fila/sets para simulação NFA).",
                                "Lógica: Raciocínio não-determinístico e busca em árvores.",
                                "Engenharia de Software: Modelagem de analisadores léxicos em compiladores."
                              ],
                              "realWorldApplication": "Em compiladores (ex: Flex/Lex), simular AFN para tokenização rápida de código-fonte, gerenciando ambiguidades léxicas em linguagens como C++ ou Python, otimizando scanners antes da conversão para AFD."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.1.4.1.1"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "10.1.1.4.2",
                        "name": "Autômatos Finitos Determinísticos (AFD)",
                        "description": "Autômatos finitos determinísticos (AFD) são equivalentes aos AFN em poder expressivo, mas com uma única transição por símbolo e sem ε-transições, facilitando implementação eficiente em analisadores léxicos.",
                        "specificSkills": [
                          {
                            "id": "10.1.1.4.2.1",
                            "name": "Definir componentes de um AFD",
                            "description": "Descrever os elementos de um AFD: estados Q, alfabeto Σ, função de transição total δ, estado inicial e estados finais, destacando a determinística total para cada par (estado, símbolo).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o conjunto de estados Q",
                                  "subSteps": [
                                    "Definir Q como um conjunto finito não vazio de estados que representam as configurações internas do autômato.",
                                    "Explicar que cada estado captura a 'memória' do processamento até o momento.",
                                    "Listar exemplos simples, como Q = {q0, q1} para um AFD que conta paridade.",
                                    "Discutir a necessidade de estados finitos para computação finita.",
                                    "Visualizar estados como nós em um diagrama de transição."
                                  ],
                                  "verification": "Descreva verbalmente ou por escrito o que é Q e dê um exemplo com 3 estados.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Papel e caneta para diagramas",
                                    "Acesso a um editor de texto ou ferramenta de desenho como Draw.io"
                                  ],
                                  "tips": [
                                    "Pense nos estados como 'posições' ou 'situações' que o autômato pode estar durante a leitura da entrada.",
                                    "Comece sempre com estados mínimos para entender."
                                  ],
                                  "learningObjective": "Identificar e descrever precisamente o papel do conjunto Q em um AFD.",
                                  "commonMistakes": [
                                    "Confundir estados com símbolos de entrada (Σ)",
                                    "Achar que Q pode ser infinito, ignorando a finitude"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Compreender o alfabeto Σ",
                                  "subSteps": [
                                    "Definir Σ como um conjunto finito não vazio de símbolos de entrada.",
                                    "Explicar que Σ representa o vocabulário possível da linguagem de entrada.",
                                    "Dar exemplos, como Σ = {0, 1} para binário ou Σ = {a, b} para strings simples.",
                                    "Discutir como Σ determina as transições possíveis.",
                                    "Relacionar com análise léxica: símbolos como letras, dígitos, operadores."
                                  ],
                                  "verification": "Liste Σ para um AFD de reconhecimento de números binários e explique sua importância.",
                                  "estimatedTime": "10 minutos",
                                  "materials": [
                                    "Lista de exemplos de linguagens formais",
                                    "Quadro ou papel para anotar conjuntos"
                                  ],
                                  "tips": [
                                    "Σ é sempre finito e pequeno em aplicações práticas.",
                                    "Evite incluir o símbolo vazio ε, que é para AFN."
                                  ],
                                  "learningObjective": "Descrever o alfabeto Σ e seu papel fundamental nas transições.",
                                  "commonMistakes": [
                                    "Incluir ε em Σ para AFD",
                                    "Confundir Σ com a linguagem aceita pelo AFD"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Compreender a função de transição δ",
                                  "subSteps": [
                                    "Definir δ: Q × Σ → Q como uma função total e determinística.",
                                    "Explicar 'total': definida para todo par (q, a) ∈ Q × Σ.",
                                    "Explicar 'determinística': exatamente uma imagem por par (q, a).",
                                    "Escrever δ em tabela para um exemplo simples.",
                                    "Destacar diferença com AFN (não total, não única)."
                                  ],
                                  "verification": "Construa a tabela de δ para um AFD com Q={q0,q1}, Σ={0,1} e verifique totalidade.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Planilha ou tabela em papel",
                                    "Exemplos de diagramas de AFD"
                                  ],
                                  "tips": [
                                    "Use tabelas para visualizar δ e garantir totalidade.",
                                    "Sempre preencha todas as células da tabela."
                                  ],
                                  "learningObjective": "Definir formalmente δ e destacar suas propriedades determinística e total.",
                                  "commonMistakes": [
                                    "Deixar transições indefinidas (não total)",
                                    "Permitir múltiplas transições para o mesmo (q,a)"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Compreender o estado inicial q0 e os estados finais F",
                                  "subSteps": [
                                    "Definir q0 ∈ Q como o estado de partida antes de qualquer entrada.",
                                    "Definir F ⊆ Q como o conjunto de estados de aceitação.",
                                    "Explicar que aceitação ocorre se o autômato termina em F após ler toda a entrada.",
                                    "Dar exemplo: q0 inicial, F={q1} para strings terminando em 1.",
                                    "Discutir como q0 e F definem o comportamento de reconhecimento."
                                  ],
                                  "verification": "Identifique q0 e F em um diagrama de AFD dado e explique aceitação.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Diagramas de AFD impressos ou digitais",
                                    "Marcadores para destacar q0 e F"
                                  ],
                                  "tips": [
                                    "Marque q0 com seta de entrada e F com duplo círculo.",
                                    "F pode ser vazio, rejeitando tudo."
                                  ],
                                  "learningObjective": "Explicar o papel de q0 e F na definição de aceitação.",
                                  "commonMistakes": [
                                    "Confundir q0 com estados finais",
                                    "Achar que F deve conter q0 sempre"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Definir formalmente o AFD completo",
                                  "subSteps": [
                                    "Reunir todos: AFD = (Q, Σ, δ, q0, F).",
                                    "Escrever a definição textual destacando determinística total de δ.",
                                    "Validar com exemplo completo: listar cada componente.",
                                    "Comparar com definição informal vs. formal.",
                                    "Explicar uso em análise léxica de compiladores."
                                  ],
                                  "verification": "Escreva a definição completa de um AFD exemplo, listando todos os 5 componentes.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Modelo de definição formal",
                                    "Exemplo resolvido de AFD"
                                  ],
                                  "tips": [
                                    "Memorize a ordem: Q, Σ, δ, q0, F.",
                                    "Sempre verifique se δ é total."
                                  ],
                                  "learningObjective": "Sintetizar a definição integral de um AFD.",
                                  "commonMistakes": [
                                    "Omitir algum componente",
                                    "Esquecer a ênfase na totalidade de δ"
                                  ]
                                }
                              ],
                              "practicalExample": "Considere um AFD que aceita strings em Σ={0,1}* terminando em 0: Q={q0,q1}, onde q0 é paridade par de 1's até agora; Σ={0,1}; δ(q0,0)=q0, δ(q0,1)=q1, δ(q1,0)=q1, δ(q1,1)=q0 (total e determinística); q0 inicial; F={q0}.",
                              "finalVerifications": [
                                "Liste corretamente os 5 componentes de um AFD.",
                                "Explique por que δ deve ser total para cada (q,a).",
                                "Construa δ em tabela para um exemplo dado.",
                                "Identifique q0 e F em um diagrama.",
                                "Defina formalmente um AFD simples sem erros.",
                                "Diferencie AFD de AFN pelos componentes.",
                                "Aplique a definição a um caso de análise léxica."
                              ],
                              "assessmentCriteria": [
                                "Precisão na descrição de cada componente (Q, Σ, δ, q0, F).",
                                "Correta ênfase na totalidade e determinismo de δ.",
                                "Uso de notação formal matemática adequada.",
                                "Exemplos concretos e válidos fornecidos.",
                                "Explicação clara da interdependência dos componentes.",
                                "Ausência de confusões com AFN ou outros autômatos.",
                                "Capacidade de validar um AFD completo."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria de conjuntos (Q, Σ, F) e funções totais.",
                                "Lógica: Definições precisas e propriedades formais.",
                                "Programação: Implementação de tabelas de transição em scanners/parsers.",
                                "Engenharia de Software: Modelagem de estados finitos em sistemas reativos.",
                                "Física: Autômatos finitos em controladores de máquinas reais."
                              ],
                              "realWorldApplication": "Em compiladores, AFDs definem analisadores léxicos (scanners) que tokenizam código-fonte, identificando tokens como identificadores, números e operadores de forma eficiente e determinística, essencial para a fase de análise léxica."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.4.2.2",
                            "name": "Construir AFD diretamente para padrões léxicos",
                            "description": "Desenhar um AFD para tokens específicos como palavras-chave, operadores ou literais numéricos, garantindo cobertura total do alfabeto e minimizando estados.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Analisar o Padrão Léxico e Definir o Alfabeto",
                                  "subSteps": [
                                    "Identifique o token específico (ex: palavra-chave 'if', operador '+' ou literal numérico [0-9]+).",
                                    "Liste o alfabeto completo Σ da linguagem (letras, dígitos, símbolos).",
                                    "Classifique símbolos em válidos (que levam à aceitação) e inválidos (para sink).",
                                    "Defina o estado inicial q0.",
                                    "Crie um esboço inicial do diagrama com q0."
                                  ],
                                  "verification": "Alfabeto Σ documentado e símbolos válidos/inválidos listados claramente.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Ferramenta de desenho como draw.io ou Graphviz"
                                  ],
                                  "tips": "Sempre inclua o alfabeto total para evitar lacunas em transições.",
                                  "learningObjective": "Compreender a especificação exata do padrão e o escopo do alfabeto.",
                                  "commonMistakes": [
                                    "Ignorar case-sensitivity (maiúsculas/minúsculas)",
                                    "Esquecer símbolos especiais no alfabeto"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Construir Estados e Transições para Sequências Válidas",
                                  "subSteps": [
                                    "Crie estados sequenciais para cada prefixo do padrão (ex: q1 após 'i', q2 após 'if' para 'if').",
                                    "Adicione transições δ(q, a) para símbolos que avançam o match (ex: δ(q0, 'i') = q1).",
                                    "Garanta que o estado final seja marcado como aceitador F após match completo.",
                                    "Teste transições com a string exata do padrão.",
                                    "Adicione loops ou branches se o padrão permitir repetições (ex: para [0-9]*)."
                                  ],
                                  "verification": "O AFD aceita a string canônica do padrão via simulação manual.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Diagrama em andamento",
                                    "Exemplos de strings válidas"
                                  ],
                                  "tips": "Use estados mínimos: um por prefixo único para evitar redundância.",
                                  "learningObjective": "Modelar o caminho de aceitação com transições precisas.",
                                  "commonMistakes": [
                                    "Criar estados desnecessários para prefixos similares",
                                    "Esquecer de marcar o estado final"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Adicionar Sink State e Cobertura Total do Alfabeto",
                                  "subSteps": [
                                    "Crie um estado sink q_sink (não-aceitador) para rejeições.",
                                    "Para cada estado e símbolo sem transição, adicione δ(q, a) = q_sink.",
                                    "Do q_sink, defina δ(q_sink, a) = q_sink para todo a ∈ Σ.",
                                    "Verifique que todo estado tem exatamente |Σ| transições (determinismo).",
                                    "Simule strings inválidas para confirmar rejeição."
                                  ],
                                  "verification": "Nenhuma transição indefinida; todas levam a q0, estado aceitador ou q_sink.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Lista completa de Σ",
                                    "Simulador de autômato online (opcional)"
                                  ],
                                  "tips": "O sink garante totalidade sem exceções.",
                                  "learningObjective": "Assegurar determinismo e cobertura total do alfabeto.",
                                  "commonMistakes": [
                                    "Deixar transições indefinidas",
                                    "Fazer q_sink aceitador por engano"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificar, Minimizar e Validar o AFD",
                                  "subSteps": [
                                    "Simule múltiplas strings: válidas (aceitam), inválidas (rejeitam), prefixos.",
                                    "Aplique algoritmo de minimização (partições equivalentes) se houver estados redundantes.",
                                    "Confirme propriedades: determinístico, completo, mínimo número de estados.",
                                    "Documente o AFD com tabela de transições.",
                                    "Compare com regex equivalente para validação."
                                  ],
                                  "verification": "Tabela de transições completa e testes passam para 5+ strings.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Tabela de transições em planilha",
                                    "Ferramentas como JFLAP"
                                  ],
                                  "tips": "Teste bordas: strings vazia, prefixos longos, inválidos precoces.",
                                  "learningObjective": "Garantir correção, eficiência e minimalidade do AFD.",
                                  "commonMistakes": [
                                    "Não testar prefixos (ex: 'i' para 'if')",
                                    "Ignorar minimização levando a estados extras"
                                  ]
                                }
                              ],
                              "practicalExample": "Construa um AFD para a palavra-chave 'if' com Σ = {i,f,+,0-9,a-z}. Estados: q0 --i--> q1 --f--> q2 (F), todas outras de q0/q1 para q_sink; q_sink auto-loop.",
                              "finalVerifications": [
                                "AFD aceita exatamente as strings do padrão (ex: 'if') e rejeita outras.",
                                "Todo par (estado, símbolo) tem exatamente uma transição.",
                                "Número de estados é mínimo (sem equivalentes undistinguíveis).",
                                "Simulação manual confirma para 5 strings válidas/inválidas.",
                                "Tabela de transições cobre 100% do alfabeto.",
                                "Estado final é único e correto."
                              ],
                              "assessmentCriteria": [
                                "Cobertura total do alfabeto sem lacunas.",
                                "Estados minimizados (≤ comprimento do padrão + 2).",
                                "Determinismo estrito (uma transição por símbolo).",
                                "Correta aceitação/rejeição em testes.",
                                "Diagrama claro e legível.",
                                "Documentação de transições completa."
                              ],
                              "crossCurricularConnections": [
                                "Teoria dos Grafos: Estados como nós, transições como arestas etiquetadas.",
                                "Matemática Discreta: Funções de transição como relações totais.",
                                "Linguística Computacional: Reconhecimento de padrões morfológicos.",
                                "Engenharia de Software: Modelagem de parsers em compiladores."
                              ],
                              "realWorldApplication": "Em analisadores léxicos de compiladores (ex: GCC, Javac), AFDS otimizados tokenizam código-fonte rapidamente, identificando keywords, números e operadores para a próxima fase de análise sintática."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.1.4.1"
                            ]
                          },
                          {
                            "id": "10.1.1.4.2.3",
                            "name": "Implementar simulador de AFD",
                            "description": "Codificar um simulador simples de AFD em pseudocódigo ou linguagem de programação para processar fluxos de caracteres e identificar tokens válidos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Definir a estrutura de dados do AFD",
                                  "subSteps": [
                                    "Identifique os componentes essenciais de um AFD: conjunto de estados (Q), alfabeto (Σ), função de transição (δ), estado inicial (q0) e estados finais (F).",
                                    "Escolha uma representação em pseudocódigo: use um mapa ou dicionário para transições (estado atual x símbolo → próximo estado).",
                                    "Defina estruturas para estados iniciais e finais, como um booleano isFinal para cada estado.",
                                    "Crie variáveis para o estado atual e a string de entrada.",
                                    "Inicialize o AFD com um exemplo simples, como um autômato que aceita strings com 'a' seguida de 'b'."
                                  ],
                                  "verification": "Verifique se as estruturas de dados estão definidas corretamente e inicializadas sem erros de sintaxe.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Editor de texto ou IDE para pseudocódigo",
                                    "Documentação sobre AFDs",
                                    "Papel e caneta para diagramar o AFD exemplo"
                                  ],
                                  "tips": "Comece com um AFD pequeno (3-5 estados) para evitar complexidade inicial.",
                                  "learningObjective": "Compreender e representar programaticamente os componentes fundamentais de um AFD.",
                                  "commonMistakes": [
                                    "Esquecer de incluir estados finais",
                                    "Usar tipos de dados inadequados para transições (ex: array fixo em vez de mapa dinâmico)"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar a função de transição δ",
                                  "subSteps": [
                                    "Crie uma função delta(estadoAtual, simbolo) que retorne o próximo estado com base no mapa de transições.",
                                    "Adicione tratamento para símbolos não definidos (transição para estado de erro ou rejeição).",
                                    "Teste a função isoladamente com casos manuais: valide transições válidas e inválidas.",
                                    "Garanta que a função seja determinística: exatamente um próximo estado por par (estado, símbolo).",
                                    "Integre a função à estrutura principal do AFD."
                                  ],
                                  "verification": "Execute chamadas manuais à função delta e confirme que retorna estados corretos para pelo menos 5 pares de teste.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Pseudocódigo editor",
                                    "Exemplos de diagramas de AFD impressos"
                                  ],
                                  "tips": "Use estruturas como Map<String, Map<String, String>> para transições em pseudocódigo.",
                                  "learningObjective": "Implementar a lógica central de transição determinística de um AFD.",
                                  "commonMistakes": [
                                    "Não tratar símbolos ausentes na tabela de transições",
                                    "Confundir chaves do mapa (estado vs símbolo)"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Desenvolver o loop principal do simulador",
                                  "subSteps": [
                                    "Implemente uma função simulate(entradaString) que reseta para o estado inicial.",
                                    "Percorra cada caractere da string, aplicando delta(estadoAtual, char) e atualizando o estado.",
                                    "Registre o estado após cada transição para depuração.",
                                    "Ao final da string, verifique se o estado atual é final.",
                                    "Retorne 'aceito' ou 'rejeitado' baseado no estado final."
                                  ],
                                  "verification": "Teste o simulador com strings de entrada curtas e confirme aceitação/rejeição correta.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Testes unitários em pseudocódigo",
                                    "Strings de teste pré-definidas"
                                  ],
                                  "tips": "Adicione logs de depuração para mostrar transições: 'Estado q1 + 'a' → q2'.",
                                  "learningObjective": "Construir o algoritmo de simulação sequencial de um AFD sobre uma entrada.",
                                  "commonMistakes": [
                                    "Não resetar o estado inicial entre simulações",
                                    "Processar caracteres além do fim da string"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Adicionar detecção de tokens válidos e testes",
                                  "subSteps": [
                                    "Modifique para identificar o maior prefixo aceito como token (comum em analisadores léxicos).",
                                    "Implemente retrocesso: pare na transição que leva a rejeição e aceite o prefixo anterior.",
                                    "Crie uma suíte de testes com tokens válidos/inválidos para o AFD exemplo.",
                                    "Execute todos os testes e registre resultados.",
                                    "Refatore código para reutilização em múltiplos AFDs."
                                  ],
                                  "verification": "Todos os testes passam: pelo menos 80% de cobertura de casos (válidos, inválidos, borda).",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Lista de casos de teste para AFD de identificadores (ex: 'var', '123abc', 'ab_')"
                                  ],
                                  "tips": "Para tokens, use lookahead limitado (1 caractere) para eficiência.",
                                  "learningObjective": "Estender o simulador para uso prático em análise léxica com detecção de tokens.",
                                  "commonMistakes": [
                                    "Retrocesso incorreto levando a tokens parciais errados",
                                    "Ignorar casos de borda como strings vazias"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Validar e otimizar o simulador",
                                  "subSteps": [
                                    "Execute performance tests com strings longas (>100 chars).",
                                    "Otimize acessos ao mapa de transições se necessário.",
                                    "Adicione comentários e documentação ao código.",
                                    "Compare saída com simulação manual em papel.",
                                    "Prepare para integração em um compilador simples."
                                  ],
                                  "verification": "Código roda sem erros, performance aceitável (<1s para 1000 chars), documentado.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Ferramenta de profiling básica",
                                    "Versão manual do AFD"
                                  ],
                                  "tips": "Mantenha O(n) tempo linear na entrada.",
                                  "learningObjective": "Garantir robustez, eficiência e manutenibilidade do simulador.",
                                  "commonMistakes": [
                                    "Otimização prematura sem testes",
                                    "Falta de documentação obscurecendo lógica"
                                  ]
                                }
                              ],
                              "practicalExample": "Implemente um AFD que reconhece identificadores válidos (letras seguidas de letras/dígitos/underscore, sem começar com dígito). Teste com 'var12_abc' (aceito), '123var' (rejeitado após '123'), retornando o token '123' como inválido ou prefixo correto.",
                              "finalVerifications": [
                                "Simulador processa strings corretamente, retornando aceito/rejeitado.",
                                "Transições delta são determinísticas e tratam erros.",
                                "Detecção de tokens usa retrocesso para prefixos máximos.",
                                "Testes unitários cobrem >80% dos casos, incluindo borda.",
                                "Código é legível, comentado e executável em pseudocódigo.",
                                "Performance linear confirmada com entradas longas."
                              ],
                              "assessmentCriteria": [
                                "Correção: 100% dos testes passam.",
                                "Completude: Todos componentes do AFD implementados.",
                                "Eficiência: Tempo O(n) na entrada.",
                                "Robustez: Trata entradas inválidas sem crash.",
                                "Clareza: Código bem estruturado e documentado.",
                                "Extensibilidade: Fácil adicionar novo AFD."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria dos Autômatos e Linguagens Formais.",
                                "Programação: Estruturas de dados (mapas, grafos).",
                                "Engenharia de Software: Testes unitários e depuração.",
                                "Lógica: Estados e transições como grafos dirigidos."
                              ],
                              "realWorldApplication": "Em compiladores (ex: scanners léxicos do GCC ou JavaCC), processadores de texto (ex: editores de código destacando sintaxe), validadores de padrões (ex: regex engines simplificados em ferramentas de segurança)."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.1.4.2.1",
                              "10.1.1.4.2.2"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "10.1.1.4.3",
                        "name": "Conversão AFN para AFD e Aplicação em Reconhecimento de Tokens",
                        "description": "Processo de determinização via construção do subconjunto de estados e aplicação prática em analisadores léxicos para reconhecer sequências de tokens em código-fonte.",
                        "specificSkills": [
                          {
                            "id": "10.1.1.4.3.1",
                            "name": "Aplicar algoritmo de subconjuntos para conversão AFN-AFD",
                            "description": "Executar o algoritmo de powerset para converter um AFN em AFD equivalente, gerenciando estados não-determinísticos, fechamento ε e estados inalcançáveis.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Definir formalmente o Autômato Finito Não-Determinístico (AFN)",
                                  "subSteps": [
                                    "Liste o conjunto de estados Q, incluindo o estado inicial q0 e estados finais F.",
                                    "Especifique o alfabeto Σ.",
                                    "Descreva a função de transição δ, incluindo transições não-determinísticas e ε-transições.",
                                    "Desenhe o diagrama do AFN para visualização clara.",
                                    "Verifique se o AFN está completo e sem ambiguidades."
                                  ],
                                  "verification": "Todos os componentes do AFN (Q, Σ, δ, q0, F) estão explicitamente listados e diagramados corretamente.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Software de desenho como Draw.io ou Graphviz"
                                  ],
                                  "tips": "Use notação padrão: δ(q, a) = conjunto de estados para clareza em não-determinismo.",
                                  "learningObjective": "Representar precisamente um AFN para preparar a conversão.",
                                  "commonMistakes": [
                                    "Esquecer ε-transições",
                                    "Não identificar todos os estados finais",
                                    "Confundir símbolos do alfabeto"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Calcular o Fechamento ε do Estado Inicial e Criar o Primeiro Estado do AFD",
                                  "subSteps": [
                                    "Compute ε-closure(q0): todos os estados alcançáveis de q0 via ε-transições.",
                                    "Crie o Estado 0 do AFD como esse conjunto de estados.",
                                    "Marque-o como o estado inicial do AFD.",
                                    "Identifique se contém estados finais do AFN (torna-o final no AFD).",
                                    "Adicione à fila de estados pendentes."
                                  ],
                                  "verification": "ε-closure(q0) é calculado corretamente e listado como Estado 0.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Tabela de estados",
                                    "Lista de transições ε"
                                  ],
                                  "tips": "Use algoritmo recursivo ou fixpoint para ε-closure: adicione estados até não mudar.",
                                  "learningObjective": "Dominar o conceito de ε-closure para estados compostos.",
                                  "commonMistakes": [
                                    "Parar prematuramente no fechamento ε",
                                    "Ignorar ciclos ε",
                                    "Duplicar estados no conjunto"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Construir Iterativamente os Estados do AFD Usando o Algoritmo de Powerset",
                                  "subSteps": [
                                    "Pegue o próximo estado pendente (conjunto S).",
                                    "Para cada símbolo a em Σ, compute move(S, a): estados alcançáveis via a de qualquer estado em S.",
                                    "Compute ε-closure(move(S, a)) para cada a, criando novos estados.",
                                    "Adicione novos estados à fila se não existirem; marque transições.",
                                    "Repita até a fila estar vazia."
                                  ],
                                  "verification": "Todos os estados foram processados e transições para todos símbolos estão definidas.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Fila de estados pendentes",
                                    "Tabela de transições do AFD"
                                  ],
                                  "tips": "Represente estados como {q1,q2,...} e use um mapa para evitar duplicatas.",
                                  "learningObjective": "Aplicar powerset construction para gerar todos os subconjuntos relevantes.",
                                  "commonMistakes": [
                                    "Esquecer um símbolo do alfabeto",
                                    "Erro em move ou ε-closure",
                                    "Não fundir estados idênticos"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Finalizar o AFD: Identificar Estados Finais e Remover Inalcançáveis",
                                  "subSteps": [
                                    "Marque como finais os estados do AFD que contêm pelo menos um estado final do AFN.",
                                    "Realize uma busca em profundidade ou largura a partir do estado inicial para identificar estados alcançáveis.",
                                    "Remova estados inalcançáveis da tabela.",
                                    "Desenhe o diagrama final do AFD.",
                                    "Opcional: Minimize o AFD usando algoritmo de partição."
                                  ],
                                  "verification": "Diagrama do AFD completo com estados finais corretos e sem inalcançáveis.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Diagrama do AFD",
                                    "Lista de estados alcançáveis"
                                  ],
                                  "tips": "Estados finais: qualquer subconjunto intersecta F ≠ ∅.",
                                  "learningObjective": "Completar e otimizar o AFD equivalente ao AFN.",
                                  "commonMistakes": [
                                    "Marcar errado estados finais",
                                    "Deixar estados inalcançáveis",
                                    "Não verificar equivalência"
                                  ]
                                }
                              ],
                              "practicalExample": "Considere um AFN que aceita strings sobre {0,1} terminando em 01: Estados {0(init),1,2(final)}, δ(0,ε)={1}, δ(1,0)={1,2}, δ(2,1)={2}. Aplicando powerset: Estado0=ε-closure({0})={0,1}; move({0,1},0)={1,2} → Estado1={1,2}; etc. Resulta em AFD com 3 estados determinísticos.",
                              "finalVerifications": [
                                "O AFD aceita exatamente a mesma linguagem que o AFN original.",
                                "Número de estados no AFD ≤ 2^|Q| do AFN.",
                                "Todas as transições estão definidas para cada símbolo do alfabeto.",
                                "Estados finais estão corretamente identificados.",
                                "Não há estados inalcançáveis no AFD final.",
                                "ε-closures e moves foram computados sem erros em todos os passos."
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição inicial do AFN (10%)",
                                "Correção dos ε-closures e move computations (30%)",
                                "Completude da tabela de transições powerset (30%)",
                                "Identificação correta de estados finais e remoção de inalcançáveis (20%)",
                                "Clareza no diagrama e explicação do processo (10%)"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria de Conjuntos e Operações em Potências",
                                "Compiladores: Análise Léxica e Geração de Scanners (Flex/Lex)",
                                "Inteligência Artificial: Modelagem de Autômatos em Processamento de Linguagem Natural",
                                "Engenharia de Software: Otimização de Reconhecedores de Padrões"
                              ],
                              "realWorldApplication": "Em compiladores e analisadores léxicos (ex: Flex gera AFDs de expressões regulares para reconhecimento eficiente de tokens), reduzindo não-determinismo para execução em tempo linear em hardware determinístico."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.1.4.1.3",
                              "10.1.1.4.2.1"
                            ]
                          },
                          {
                            "id": "10.1.1.4.3.2",
                            "name": "Minimizar AFD para eficiência",
                            "description": "Aplicar o algoritmo de minimização de Hopcroft ou partições para reduzir o número de estados em um AFD, otimizando para uso em compiladores.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar o AFD para minimização",
                                  "subSteps": [
                                    "Identifique e remova estados inalcançáveis a partir do estado inicial usando busca em grafos (BFS ou DFS).",
                                    "Remova estados mortos (estados sem transição de saída ou que não levam a estados finais).",
                                    "Renumere os estados restantes para continuidade (Q0, Q1, etc.).",
                                    "Verifique se o AFD está completo: todo estado tem transição para cada símbolo do alfabeto.",
                                    "Documente o AFD preparado com diagrama."
                                  ],
                                  "verification": "Confirme que todos os estados são alcançáveis do inicial e levam a aceitação quando apropriado; compare com AFD original.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e lápis",
                                    "Ferramenta como JFLAP ou Graphviz",
                                    "Diagrama do AFD original"
                                  ],
                                  "tips": "Comece sempre pelo estado inicial; use cores para marcar estados removidos.",
                                  "learningObjective": "Entender a importância de limpar o autômato antes da minimização para evitar artefatos.",
                                  "commonMistakes": [
                                    "Esquecer transições implícitas para estado morto",
                                    "Não renumerar estados após remoção",
                                    "Ignorar símbolos ausentes no alfabeto"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Inicializar partições iniciais",
                                  "subSteps": [
                                    "Divida os estados em duas partições iniciais: P0 = estados finais, P1 = estados não-finais.",
                                    "Se houver estados iniciais especiais ou traps, ajuste partições conforme necessidade.",
                                    "Crie uma tabela de partições com estados listados em cada grupo.",
                                    "Marque estados distinguíveis inicialmente (baseado em final/não-final).",
                                    "Valide que a partição respeita a linguagem reconhecida."
                                  ],
                                  "verification": "Todas as partições iniciais separam corretamente estados finais de não-finais; teste com strings simples.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Tabela em papel ou planilha Excel",
                                    "Diagrama do AFD preparado"
                                  ],
                                  "tips": "Use abreviações como F para finais e NF para não-finais nas partições.",
                                  "learningObjective": "Dominar a distinção básica de equivalência de estados baseada em aceitação.",
                                  "commonMistakes": [
                                    "Colocar estado inicial em partição errada",
                                    "Ignorar múltiplos estados finais",
                                    "Confundir partição com cliques em grafos"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Refinar partições iterativamente (Algoritmo de Hopcroft ou Partições)",
                                  "subSteps": [
                                    "Para cada partição Pi e símbolo a, compute o conjunto inverso X = pre(Pi, a) dos estados que transitam para Pi via a.",
                                    "Para cada partição Pj, se Pj intersecta X de forma não-trivial, divida Pj em Pj1 (em X) e Pj2 (fora de X).",
                                    "Repita o refinamento até que nenhuma divisão ocorra (partições estáveis).",
                                    "Use uma fila para processar partições 'splitters' no estilo Hopcroft para eficiência.",
                                    "Registre iterações em tabela: mostre divisões por passo."
                                  ],
                                  "verification": "Partições não mudam mais após iteração; estados em mesma partição têm transições equivalentes.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Tabela de transições do AFD",
                                    "Fila ou pilha para splitters",
                                    "Software como Python com autômatos ou JFLAP"
                                  ],
                                  "tips": "Implemente Hopcroft para AFDs grandes; comece com partições básicas para aprendizado.",
                                  "learningObjective": "Aplicar refinamento para identificar estados equivalentes via distinção por strings.",
                                  "commonMistakes": [
                                    "Não usar inversos corretamente",
                                    "Parar refinamento prematuramente",
                                    "Confundir divisão com merge de partições"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Construir e validar o AFD minimizado",
                                  "subSteps": [
                                    "Atribua um estado equivalente por partição final (renumere Q0', Q1', etc.).",
                                    "Defina transições: δ(Qi', a) = Qj' onde Qj' é partição de destino de estados em Qi'.",
                                    "Marque o estado inicial e finais baseado nas partições originais.",
                                    "Desenhe o diagrama do AFD minimizado.",
                                    "Teste equivalência com strings de aceitação/rejeição do original."
                                  ],
                                  "verification": "AFD minimizado aceita/rejeita mesmas strings que original; número de estados ≤ original.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Diagrama final",
                                    "Ferramentas de teste como simulador de autômatos"
                                  ],
                                  "tips": "Verificadores online como regex101 para linguagens regulares simples.",
                                  "learningObjective": "Construir autômato otimizado e validar correção.",
                                  "commonMistakes": [
                                    "Erro na transição entre partições",
                                    "Perder estado inicial na mapeamento",
                                    "Não testar com strings fronteiriças"
                                  ]
                                }
                              ],
                              "practicalExample": "Considere AFD para {w | w tem número par de 'a's} sobre {a,b}: Estados Q0(inicial,final), Q1, Q2(final), Q3(trap). Após preparação, partições iniciais: {Q0,Q2} finais, {Q1,Q3} não-finais. Refinamento: Divide {Q1,Q3} em {Q1},{Q3} por transições. Final: 3 estados minimizados, usado em lexer para otimizar reconhecimento de tokens numéricos pares.",
                              "finalVerifications": [
                                "Número de estados reduzido sem perda de linguagem.",
                                "Todas transições definidas para alfabeto completo.",
                                "Estado inicial e finais corretamente mapeados.",
                                "Testes com 5+ strings confirmam equivalência.",
                                "Partições estáveis (sem refinamentos adicionais).",
                                "Diagrama minimizado sem estados redundantes."
                              ],
                              "assessmentCriteria": [
                                "Precisão no refinamento de partições (100% divisões corretas).",
                                "Redução correta de estados (mínimo possível alcançado).",
                                "Validação por testes de strings (pelo menos 80% cobertura).",
                                "Documentação clara de passos e tabelas.",
                                "Eficiência: uso de Hopcroft se aplicável (>5 estados).",
                                "Ausência de erros comuns como estados mortos."
                              ],
                              "crossCurricularConnections": [
                                "Teoria dos Grafos: Partições como coloração ou componentes fortemente conectados.",
                                "Algoritmos e Estruturas: BFS/DFS para inalcançáveis, filas em Hopcroft.",
                                "Otimização Computacional: Similar a minimização em redes neurais ou clustering.",
                                "Lógica e Linguagens Formais: Equivalência de autômatos canônica.",
                                "Engenharia de Software: Otimização de parsers em compiladores."
                              ],
                              "realWorldApplication": "Em compiladores como GCC ou Flex, AFDs minimizados aceleram analisadores léxicos, reduzindo tempo de scan de código-fonte em 20-50% para linguagens como C++ ou Java, economizando ciclos de CPU em builds grandes."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.1.4.3.1"
                            ]
                          },
                          {
                            "id": "10.1.1.4.3.3",
                            "name": "Usar AFD em analisador léxico para tokens múltiplos",
                            "description": "Combinar múltiplos AFD em um autômato global com estados finais associados a tipos de tokens, gerenciando prioridade e lookahead para reconhecimento preciso.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Projetar AFDs individuais para cada tipo de token",
                                  "subSteps": [
                                    "Identifique os tipos de tokens principais (ex: identificadores, números, operadores).",
                                    "Desenhe o AFN para cada token usando expressões regulares.",
                                    "Converta cada AFN para AFD usando o algoritmo de subconjuntos.",
                                    "Otimize os AFDs removendo estados inalcançáveis e minimizando.",
                                    "Documente transições e estados finais para cada AFD."
                                  ],
                                  "verification": "Verifique se cada AFD reconhece corretamente strings válidas e rejeita inválidas usando um simulador de autômato.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Papel e lápis ou ferramenta como JFLAP",
                                    "Lista de expressões regulares para tokens"
                                  ],
                                  "tips": "Comece com tokens simples como números antes de complexos como identificadores.",
                                  "learningObjective": "Dominar a construção de AFDs para padrões léxicos individuais.",
                                  "commonMistakes": [
                                    "Esquecer estados de erro",
                                    "Não converter AFN para AFD completamente",
                                    "Ignorar caracteres de escape"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Construir o AFD global via produto cartesiano",
                                  "subSteps": [
                                    "Crie o conjunto de estados como pares (estado_AFD1, estado_AFD2, ...).",
                                    "Defina transições para cada símbolo do alfabeto combinando transições individuais.",
                                    "Inclua o estado inicial como (inicial1, inicial2, ...).",
                                    "Elimine estados inalcançáveis usando BFS a partir do inicial.",
                                    "Otimize o autômato resultante."
                                  ],
                                  "verification": "Simule o AFD global em strings de teste mistas e confirme que alcança estados corretos.",
                                  "estimatedTime": "3 horas",
                                  "materials": [
                                    "Ferramenta JFLAP ou Python com bibliotecas de autômatos",
                                    "AFDs individuais prontos"
                                  ],
                                  "tips": "Use representações compactas para estados (ex: bitsets para subconjuntos).",
                                  "learningObjective": "Entender a combinação de múltiplos AFDs em um único autômato.",
                                  "commonMistakes": [
                                    "Explosão de estados sem otimização",
                                    "Transições incompletas para todos os símbolos",
                                    "Perder o estado inicial"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Associar estados finais a tipos de tokens",
                                  "subSteps": [
                                    "Identifique estados finais em cada AFD individual.",
                                    "Marque estados globais onde pelo menos um componente é final.",
                                    "Associe cada estado final global ao tipo de token do AFD que o ativou.",
                                    "Resolva conflitos onde múltiplos AFDs terminam (priorize por comprimento ou regras).",
                                    "Crie uma tabela de lookup para estado -> tipo de token."
                                  ],
                                  "verification": "Teste estados finais com strings que devem produzir tokens específicos.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Tabela de estados do AFD global",
                                    "Especificação de tokens"
                                  ],
                                  "tips": "Use herança de prioridade: tokens mais longos ou específicos primeiro.",
                                  "learningObjective": "Mapear estados do AFD global para classes de tokens.",
                                  "commonMistakes": [
                                    "Associações erradas em estados múltiplos-finais",
                                    "Ignorar precedência de tokens",
                                    "Estados finais sem associação"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Implementar gerenciamento de prioridade e lookahead",
                                  "subSteps": [
                                    "Defina regras de prioridade (ex: palavra-chave > ID, número inteiro > float).",
                                    "Implemente lookahead para consumir o token mais longo possível.",
                                    "Adicione lógica de retrocesso se necessário (embora AFD evite na maioria).",
                                    "Integre no loop do analisador: avance no input até estado final.",
                                    "Retorne o token e reinicie o autômato."
                                  ],
                                  "verification": "Execute em código de teste com ambiguidades e confirme tokens corretos.",
                                  "estimatedTime": "2.5 horas",
                                  "materials": [
                                    "Linguagem de programação (Python/Java)",
                                    "AFD global serializado"
                                  ],
                                  "tips": "Simule lookahead lendo 1-2 caracteres à frente sem consumir.",
                                  "learningObjective": "Gerenciar ambiguidades em reconhecimento léxico com AFD.",
                                  "commonMistakes": [
                                    "Prioridade errada causando tokens curtos",
                                    "Loop infinito em lookahead",
                                    "Não resetar estado após token"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Integrar e testar o analisador léxico completo",
                                  "subSteps": [
                                    "Implemente a classe Lexer com o AFD global.",
                                    "Adicione handling de whitespace e comentários ignorados.",
                                    "Teste com suíte de casos: válidos, inválidos, ambíguos.",
                                    "Meça performance e otimize se necessário.",
                                    "Gere relatório de cobertura de tokens."
                                  ],
                                  "verification": "Lexer processa código fonte completo sem erros e produz tokens esperados.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Código fonte de teste",
                                    "Framework de testes (JUnit/Pytest)"
                                  ],
                                  "tips": "Use logging para depurar transições de estado.",
                                  "learningObjective": "Aplicar AFD em um analisador léxico funcional.",
                                  "commonMistakes": [
                                    "Não pular whitespaces",
                                    "Erro em EOF handling",
                                    "Tokens malformados em bordas"
                                  ]
                                }
                              ],
                              "practicalExample": "Para uma mini-linguagem com tokens: ID ([a-z]+), NUM ([0-9]+), OP (+|-). Construa AFDs individuais, combine em global, e lex 'var1+123' → ID('var1'), OP('+'), NUM('123'). Use lookahead para distinguir ID de palavra-chave 'if'.",
                              "finalVerifications": [
                                "O AFD global reconhece todos os tokens corretamente em strings mistas.",
                                "Prioridade resolve ambiguidades (ex: 'if' como palavra-chave, não ID).",
                                "Lookahead consome tokens mais longos (ex: '123.45' como FLOAT).",
                                "Lexer processa arquivo fonte completo sem rejeitar input válido.",
                                "Performance aceitável: <1ms por token em média.",
                                "Cobertura de testes >90% para casos edge."
                              ],
                              "assessmentCriteria": [
                                "Precisão no reconhecimento de tokens múltiplos (sem falsos positivos/negativos).",
                                "Correta implementação de produto cartesiano sem estados extras desnecessários.",
                                "Gerenciamento eficaz de prioridade e lookahead demonstrado em testes.",
                                "Código limpo, modular e documentado.",
                                "Otimização do AFD (estados minimizados).",
                                "Relatório de testes abrangente com evidências."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria de Autômatos e Linguagens Formais.",
                                "Engenharia de Software: Design de Parsers e Compiladores.",
                                "Algoritmos: Grafos e Busca em Espaço de Estados.",
                                "Lógica: Resolução de Conflitos e Precedência.",
                                "Programação: Implementação de Máquinas de Estados Finitos."
                              ],
                              "realWorldApplication": "Em compiladores como GCC ou JavaCC, analisadores léxicos usam AFDs combinados para tokenizar código fonte eficientemente, lidando com milhares de linhas por segundo em linguagens como C++ ou Java, garantindo reconhecimento preciso de sintaxe ambígua."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.1.4.2.3",
                              "10.1.1.4.3.1",
                              "10.1.1.4.3.2"
                            ]
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.1.5",
                    "name": "Implementação do Analisador Léxico",
                    "description": "Construção de scanners manuais ou com ferramentas como Lex/Flex.",
                    "individualConcepts": [
                      {
                        "id": "10.1.1.5.1",
                        "name": "Implementação Manual do Analisador Léxico",
                        "description": "Desenvolvimento de um scanner manual utilizando linguagens de programação como C ou Java, com estruturas de controle para reconhecimento de padrões regulares simples e gerenciamento de entrada.",
                        "specificSkills": [
                          {
                            "id": "10.1.1.5.1.1",
                            "name": "Reconhecer e classificar tokens básicos",
                            "description": "Implementar lógica para identificar tokens como identificadores, números, operadores e palavras-chave, utilizando tabelas de transição ou switch-case para processar caracteres de entrada.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os tipos básicos de tokens em análise léxica",
                                  "subSteps": [
                                    "Estude a definição de token como a menor unidade léxica de uma linguagem de programação.",
                                    "Identifique os tipos principais: identificadores (ex: variáveis), números (inteiros ou reais), operadores (ex: +, =) e palavras-chave (ex: if, int).",
                                    "Analise exemplos de código fonte simples para mapear caracteres a tokens.",
                                    "Crie uma tabela resumindo características de cada tipo de token (início, fim, caracteres válidos).",
                                    "Desenhe um diagrama de máquina de estados finita (FSM) básica para visualizar transições."
                                  ],
                                  "verification": "Tabela e diagrama completos com pelo menos 5 exemplos por tipo de token.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Documentação de análise léxica (ex: Dragon Book capítulo 3)",
                                    "Editor de texto ou papel para diagramas",
                                    "Exemplos de código em C ou Python"
                                  ],
                                  "tips": "Comece com linguagens simples como uma sublinguagem de expressões aritméticas para evitar sobrecarga.",
                                  "learningObjective": "Dominar a classificação conceitual de tokens básicos e suas regras de formação.",
                                  "commonMistakes": [
                                    "Confundir identificadores com palavras-chave sem tabela de símbolos",
                                    "Ignorar caracteres especiais como underscores em identificadores",
                                    "Não considerar números com ponto decimal"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar reconhecimento de identificadores e palavras-chave",
                                  "subSteps": [
                                    "Defina regras: identificadores começam com letra ou _, seguidos de alfanuméricos.",
                                    "Crie uma estrutura de dados para palavras-chave (ex: conjunto ou mapa).",
                                    "Implemente lógica com switch-case ou if-else para ler caracteres e acumular o lexema.",
                                    "Ao fim do identificador, verifique se está na lista de palavras-chave; senão, classifique como identificador.",
                                    "Teste com entradas como 'int', 'x', '_var' e retorne token apropriado."
                                  ],
                                  "verification": "Função que corretamente classifica 'int' como palavra-chave e 'minhaVar' como identificador em testes unitários.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "IDE com suporte a C/Python (ex: VS Code)",
                                    "Lista de palavras-chave de uma linguagem modelo"
                                  ],
                                  "tips": "Use um buffer para acumular caracteres e avance o ponteiro de entrada apenas quando token for completo.",
                                  "learningObjective": "Desenvolver código para detectar e diferenciar identificadores de palavras-chave.",
                                  "commonMistakes": [
                                    "Não consumir todos os caracteres válidos do lexema",
                                    "Case-sensitive incorreto",
                                    "Buffer não resetado entre tokens"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar reconhecimento de números e operadores",
                                  "subSteps": [
                                    "Defina regras para números: sequências de dígitos opcionais com ponto decimal ou expoente.",
                                    "Para operadores: mapeie caracteres únicos (+, -, *, /) ou compostos (==, +=).",
                                    "Use switch-case no caractere atual para ramificar: dígito -> acumular número; símbolo -> operador direto.",
                                    "Implemente lookahead para operadores compostos (ex: verificar próximo char após =).",
                                    "Teste com '123', '3.14', '+', '==' e entradas mistas."
                                  ],
                                  "verification": "Código processa corretamente números como '42.5' e operadores como '>=' sem erros.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Mesma IDE do passo anterior",
                                    "Casos de teste em arquivo .txt com strings de entrada"
                                  ],
                                  "tips": "Priorize o operador mais longo primeiro (ex: == antes de =) para evitar matching parcial.",
                                  "learningObjective": "Criar lógica robusta para tokens numéricos e simbólicos com lookahead.",
                                  "commonMistakes": [
                                    "Não lidar com números negativos (confundir - com operador)",
                                    "Falhar em decimais sem dígitos após ponto",
                                    "Matching greedy em operadores"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Integrar componentes em um analisador léxico manual com tabela de transição",
                                  "subSteps": [
                                    "Crie uma tabela de transição: linhas=estado atual, colunas=char classe (letra, dígito, etc.), células=próximo estado ou ação.",
                                    "Implemente loop principal: leia char, consulte tabela, acumule lexema, emita token quando estado final.",
                                    "Adicione estados para erro e whitespace (ignorar ou token separador).",
                                    "Integre todas as lógicas anteriores via estados compartilhados.",
                                    "Execute em código completo e depure com entrada multi-token."
                                  ],
                                  "verification": "Analisador processa 'int x = 5;' emitindo tokens: palavra-chave(int), identificador(x), operador(=), número(5).",
                                  "estimatedTime": "50 minutos",
                                  "materials": [
                                    "Planilha para prototipar tabela de transição",
                                    "Código dos passos anteriores",
                                    "Ferramenta de debug como printf ou print"
                                  ],
                                  "tips": "Comece com switch-case gigante se tabela for complexa; evolua para array 2D depois.",
                                  "learningObjective": "Construir um analisador léxico coeso usando FSM tabular.",
                                  "commonMistakes": [
                                    "Loop infinito sem avançar ponteiro",
                                    "Não resetar estado/lexema por token",
                                    "Estados não finais emitindo tokens prematuros"
                                  ]
                                }
                              ],
                              "practicalExample": "Dada a entrada 'int x=42;', o analisador deve emitir: TOKEN_KEYWORD('int'), TOKEN_ID('x'), TOKEN_OP('='), TOKEN_NUMBER('42'), TOKEN_EOF. Implemente em Python ou C e teste com print de cada token emitido.",
                              "finalVerifications": [
                                "Todos os tipos de tokens básicos são corretamente identificados em uma string de teste com 10+ tokens.",
                                "Nenhum lexema é cortado ou sobrescrito incorretamente.",
                                "Palavras-chave são priorizadas sobre identificadores.",
                                "Operadores compostos são reconhecidos antes dos simples.",
                                "Números com decimais e negativos são processados sem erro.",
                                "Whitespaces são ignorados adequadamente."
                              ],
                              "assessmentCriteria": [
                                "Precisão de classificação de tokens: 95%+ em conjunto de testes variados.",
                                "Eficiência: processa entrada sem loops infinitos ou vazamentos de buffer.",
                                "Robustez: lida com entradas inválidas emitindo erro sem crash.",
                                "Modularidade: código separado por tipo de token, fácil de estender.",
                                "Documentação: comentários explicando estados e transições.",
                                "Tempo de execução: <1s para 1000 chars em máquina padrão."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Autômatos Finitos e Teoria da Computação.",
                                "Lógica e Algoritmos: Estruturas de decisão (switch-case) e tabelas de lookup.",
                                "Engenharia de Software: Parsing e processamento de texto em PLs.",
                                "Linguística Computacional: Análise morfológica de código fonte."
                              ],
                              "realWorldApplication": "Desenvolvimento de compiladores (GCC, LLVM), interpretadores (Python tokenizer), editores de código com syntax highlighting (VS Code), e ferramentas de linting/validadores de código."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.5.1.2",
                            "name": "Gerenciar buffer de entrada e lookahead",
                            "description": "Criar um buffer circular para leitura eficiente do código-fonte, implementando mecanismos de lookahead para resolver ambiguidades em tokens como '==' vs '='.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Projetar e implementar a estrutura do buffer circular",
                                  "subSteps": [
                                    "Defina um array de caracteres com tamanho fixo (ex: 1024) para armazenar o código-fonte.",
                                    "Crie variáveis para índices de início (head), fim (tail) e contador de caracteres válidos.",
                                    "Implemente lógica para wrap-around usando módulo (ex: head = (head + 1) % tamanho).",
                                    "Adicione funções para verificar se o buffer está cheio ou vazio.",
                                    "Inicialize o buffer lendo os primeiros caracteres do arquivo de entrada."
                                  ],
                                  "verification": "Teste unitário confirma que o buffer armazena e recupera caracteres corretamente sem perda ou duplicação.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Linguagem de programação (C, Java ou Python)",
                                    "Editor de código (VS Code)",
                                    "Arquivo de teste com código-fonte simples"
                                  ],
                                  "tips": [
                                    "Use constantes para o tamanho do buffer para facilitar ajustes.",
                                    "Desenhe um diagrama do buffer em papel antes de codificar."
                                  ],
                                  "learningObjective": "Compreender e implementar os princípios fundamentais de um buffer circular para leitura eficiente de streams.",
                                  "commonMistakes": [
                                    "Confundir condições de buffer cheio (contador == tamanho) e vazio (contador == 0).",
                                    "Esquecer o operador módulo no wrap-around.",
                                    "Não tratar o caso de buffer inicial vazio."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar a função de leitura avançada (getNextChar)",
                                  "subSteps": [
                                    "Crie a função getNextChar() que retorna o próximo caractere do buffer.",
                                    "Se o buffer estiver vazio, leia do arquivo de entrada e preencha o buffer até um limite.",
                                    "Avance o índice head após retornar o caractere e decrementar o contador.",
                                    "Trate o fim do arquivo (EOF) retornando um caractere especial.",
                                    "Adicione recarga automática do buffer quando próximo do fim."
                                  ],
                                  "verification": "Simule leitura de um arquivo pequeno e verifique se todos os caracteres são lidos na ordem correta.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Código do Step 1",
                                    "Arquivo de teste com 100+ caracteres",
                                    "Ferramenta de debug (printf ou debugger)"
                                  ],
                                  "tips": [
                                    "Sempre verifique EOF antes de avançar.",
                                    "Preencha o buffer em blocos para eficiência."
                                  ],
                                  "learningObjective": "Desenvolver uma função de leitura que gerencie eficientemente o buffer circular e a entrada de arquivo.",
                                  "commonMistakes": [
                                    "Ler além do EOF causando loops infinitos.",
                                    "Não recarregar o buffer a tempo, causando perda de dados.",
                                    "Ignorar caracteres de nova linha ou whitespace."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar mecanismo de lookahead (ungetChar)",
                                  "subSteps": [
                                    "Crie a função ungetChar(c) que 'devolve' um caractere ao buffer.",
                                    "Decrementar o head (com wrap-around) e incrementar o contador.",
                                    "Limite o lookahead a 1-2 caracteres para eficiência (ex: para '==' vs '=').",
                                    "Garanta que ungetChar funcione mesmo se o buffer não estava vazio.",
                                    "Teste com sequências como '=' seguido de '='."
                                  ],
                                  "verification": "Execute getNextChar() seguido de ungetChar() e confirme que o caractere é recuperado corretamente.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Código dos Steps 1-2",
                                    "Casos de teste para lookahead (ex: código com '=', '==', '<=', etc.)"
                                  ],
                                  "tips": [
                                    "Mantenha lookahead simples: suporte apenas para 1 caractere de volta.",
                                    "Registre chamadas de ungetChar para debug."
                                  ],
                                  "learningObjective": "Implementar retrocesso controlado para permitir inspeção de caracteres futuros sem perda de estado.",
                                  "commonMistakes": [
                                    "Permitir múltiplos ungetChar sem limite, causando overflow.",
                                    "Erro no wrap-around ao retroceder.",
                                    "Não preservar o caractere devolvido corretamente."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Integrar lookahead na análise léxica e testar ambiguidades",
                                  "subSteps": [
                                    "No lexer principal, use lookahead para distinguir tokens: leia char1, se '=', leia char2, se '=', devolva char2 e retorne TOKEN_EQEQ, senão devolva char2 e retorne TOKEN_EQ.",
                                    "Aplique para outros casos como '<=', '!=' etc.",
                                    "Implemente a função nextToken() que usa getNextChar e ungetChar.",
                                    "Teste com código-fonte contendo ambiguidades (ex: if(a==b) vs if(a=b)).",
                                    "Meça performance e verifique ausência de vazamentos de buffer."
                                  ],
                                  "verification": "Parse completo de um arquivo de teste gera tokens corretos sem erros de buffer ou ambiguidades.",
                                  "estimatedTime": "50 minutos",
                                  "materials": [
                                    "Código completo dos steps anteriores",
                                    "Programa de teste com código-fonte realista (ex: snippet em C)",
                                    "Validador de tokens manual"
                                  ],
                                  "tips": [
                                    "Comece com apenas '==' e '=' para validar.",
                                    "Use logging para rastrear lookahead."
                                  ],
                                  "learningObjective": "Aplicar buffer e lookahead para resolver ambiguidades léxicas de forma eficiente e correta.",
                                  "commonMistakes": [
                                    "Devolver caractere errado após lookahead.",
                                    "Não resetar lookahead em novos tokens.",
                                    "Performance ruim por recargas excessivas do buffer."
                                  ]
                                }
                              ],
                              "practicalExample": "Em um lexer para uma linguagem simples, ao encontrar '=', chame getNextChar(): se for '=', use ungetChar('=') e retorne TOKEN_EQEQ; senão, ungetChar(char lido) e retorne TOKEN_EQ. Exemplo em pseudocódigo: char c = getNextChar(); if (c == '=') { char next = getNextChar(); if (next == '=') return TOKEN_EQEQ; else ungetChar(next); } ungetChar(c); return TOKEN_EQ; Teste com 'a=b;' (TOKEN_ID, TOKEN_EQ, TOKEN_ID, ';') vs 'a==b;' (TOKEN_ID, TOKEN_EQEQ, TOKEN_ID, ';').",
                              "finalVerifications": [
                                "Buffer circular gerencia wrap-around sem perda de dados em arquivos grandes (>10k chars).",
                                "Lookahead distingue corretamente '==' de '=' e similares sem retrocesso excessivo.",
                                "Função nextToken() produz sequência de tokens idêntica a um lexer manual sem buffer.",
                                "Não há transbordos, vazios prematuros ou EOF incorretos.",
                                "Performance: lê 1MB de código em <1s sem alocações dinâmicas excessivas.",
                                "Tratamento correto de EOF e arquivos vazios."
                              ],
                              "assessmentCriteria": [
                                "Correção: 100% de precisão em distinção de tokens ambíguos.",
                                "Eficiência: Tempo de leitura O(1) por caractere, sem bloqueios.",
                                "Robustez: Lida com edge cases como buffer exato no wrap-around ou EOF no meio de lookahead.",
                                "Clareza: Código comentado e modular com funções separadas.",
                                "Escalabilidade: Funciona com tamanhos de buffer variáveis.",
                                "Testabilidade: Unit tests para getNextChar, ungetChar e nextToken passam."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Aritmética modular e estruturas circulares (filas circulares).",
                                "Estruturas de Dados: Buffers, queues e gerenciamento de streams.",
                                "Algoritmos: Processamento de input/output em tempo real e finite state machines.",
                                "Engenharia de Software: Gerenciamento de estado e tratamento de erros em sistemas embarcados.",
                                "Sistemas Operacionais: Buffering em I/O de arquivos e pipes."
                              ],
                              "realWorldApplication": "Em compiladores profissionais como GCC/Clang (lexers YY_BUFFER_STATE no Flex), editores de texto (Vim/Sublime com syntax highlighting), interpretadores de linguagens de script (Python tokenizer), e ferramentas de análise estática de código (ESLint, SonarQube) para processar eficientemente grandes volumes de código-fonte sem carregar tudo na memória."
                            },
                            "estimatedTime": "3 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.5.1.3",
                            "name": "Implementar máquina de estados finitos determinística (DFA)",
                            "description": "Construir um autômato finito determinístico manualmente para reconhecer expressões regulares definidas na gramática da linguagem, retornando o tipo de token e seu lexema.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Analisar a gramática e definir expressões regulares para tokens",
                                  "subSteps": [
                                    "Identifique todos os tokens na gramática da linguagem (ex: identificadores, números, operadores).",
                                    "Escreva expressões regulares (regex) para cada token, considerando o alfabeto da linguagem.",
                                    "Defina estados iniciais, aceitadores e de erro para cada regex.",
                                    "Desenhe um diagrama preliminar de estados não determinísticos (NFA) para cada token.",
                                    "Priorize tokens e defina regras de prioridade para ambiguidades (ex: longest match)."
                                  ],
                                  "verification": "Lista completa de regex por token e diagrama NFA preliminar desenhado e documentado.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Papel e lápis ou ferramenta de diagrama como Draw.io",
                                    "Especificação da gramática da linguagem"
                                  ],
                                  "tips": "Comece com tokens simples como números antes de complexos como identificadores.",
                                  "learningObjective": "Compreender como mapear gramática para regex e estados iniciais.",
                                  "commonMistakes": [
                                    "Ignorar caracteres especiais no alfabeto",
                                    "Não considerar lookahead para longest match",
                                    "Esquecer estados de rejeição"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Construir o diagrama de estados do DFA",
                                  "subSteps": [
                                    "Converta NFAs individuais em um NFA combinado com estados aceitadores etiquetados por tipo de token.",
                                    "Aplique o algoritmo de subconjuntos para converter NFA em DFA, determinizando transições.",
                                    "Minimize o DFA usando o algoritmo de minimização de estados equivalentes.",
                                    "Desenhe o diagrama final do DFA com transições para todos os símbolos do alfabeto.",
                                    "Identifique estados finais com labels de token (ex: 'ID', 'NUMBER')."
                                  ],
                                  "verification": "Diagrama DFA completo com todos os estados, transições e labels de aceitação.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Ferramenta de diagrama (Draw.io ou Graphviz)",
                                    "Tabela de transição em planilha"
                                  ],
                                  "tips": "Use epsilon-remoção antes da determinização para simplificar.",
                                  "learningObjective": "Dominar construção e minimização de DFAs a partir de regex.",
                                  "commonMistakes": [
                                    "Erros na closure epsilon",
                                    "Não tratar transições ausentes como erro",
                                    "Sobrecarregar estados sem minimização"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar a tabela de transições do DFA em código",
                                  "subSteps": [
                                    "Represente estados como enums ou inteiros e crie uma matriz/tabela de transições (estado x símbolo -> próximo estado).",
                                    "Defina um mapa de estados finais para tipos de token.",
                                    "Implemente função para obter próximo estado dado estado atual e símbolo de input.",
                                    "Adicione handling para símbolos desconhecidos (ir para estado de erro).",
                                    "Teste a tabela manualmente com 3 sequências de input curtas."
                                  ],
                                  "verification": "Código da tabela de transições compilado e testes manuais passando.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Editor de código (VS Code)",
                                    "Linguagem de programação (Python ou C)",
                                    "Diagrama DFA do step anterior"
                                  ],
                                  "tips": "Use dicionários em Python para transições esparsas em alfabetos grandes.",
                                  "learningObjective": "Traduzir diagrama DFA em estrutura de dados programática eficiente.",
                                  "commonMistakes": [
                                    "Índices off-by-one em arrays",
                                    "Não mapear corretamente símbolos ASCII",
                                    "Falta de estado sink para erros"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Implementar o loop de reconhecimento e extração de lexema",
                                  "subSteps": [
                                    "Crie o loop principal: inicie em estado 0, avance consumindo input até estado final ou erro.",
                                    "Ao atingir estado final, capture o lexema (substring do input) e tipo de token.",
                                    "Implemente rollback para longest match se múltiplos estados finais.",
                                    "Retorne estrutura Token {tipo, lexema, linha, coluna}.",
                                    "Adicione suporte a múltiplos tokens em um stream de input."
                                  ],
                                  "verification": "Função lexer que processa string de input e retorna lista de tokens corretos.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Editor de código",
                                    "Exemplos de input de teste"
                                  ],
                                  "tips": "Mantenha posição no input com índices para extrair lexema precisamente.",
                                  "learningObjective": "Simular execução de DFA para tokenização real-time.",
                                  "commonMistakes": [
                                    "Não resetar estado após token",
                                    "Erros em cálculo de posição de linha/coluna",
                                    "Ignorar whitespace como separador"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Testar e depurar o DFA implementado",
                                  "subSteps": [
                                    "Crie suíte de testes: casos válidos, inválidos, edge cases (ex: input vazio, longest match).",
                                    "Execute lexer em programas de exemplo e compare tokens esperados vs. obtidos.",
                                    "Use debugger para rastrear estados durante execução.",
                                    "Meça performance em inputs grandes e otimize se necessário.",
                                    "Documente bugs encontrados e correções."
                                  ],
                                  "verification": "100% de pass em suíte de testes com cobertura de todos tokens.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Framework de testes (unittest em Python)",
                                    "Programas de teste em pseudo-código da linguagem"
                                  ],
                                  "tips": "Teste incremental: um token por vez antes de stream completo.",
                                  "learningObjective": "Validar robustez do DFA através de testes sistemáticos.",
                                  "commonMistakes": [
                                    "Testes insuficientes para ambiguidades",
                                    "Não testar EOF handling",
                                    "Assumir input sem erros de sintaxe"
                                  ]
                                }
                              ],
                              "practicalExample": "Para uma mini-linguagem com tokens ID ([a-z]+), NUMBER ([0-9]+), + e ; : Construa DFA com estados para ID (aceita em qualquer após letra), NUMBER (aceita após dígitos), transições para + e ; como estados finais unitários. Lexer em input 'x=42;' retorna tokens: ID('x'), =, NUMBER('42'), ;",
                              "finalVerifications": [
                                "DFA reconhece corretamente todos tokens definidos na gramática.",
                                "Longest match é aplicado para tokens sobrepostos.",
                                "Lexemas são extraídos precisamente com posições linha/coluna.",
                                "Input inválido leva a estado de erro sem crash.",
                                "Múltiplos tokens são processados sequencialmente em stream.",
                                "Performance aceitável (O(n) linear no input)."
                              ],
                              "assessmentCriteria": [
                                "Precisão da tabela de transições (sem estados mortos ou loops infinitos).",
                                "Correção na extração de lexema e tipo de token.",
                                "Tratamento robusto de erros e edge cases.",
                                "Eficiência da implementação (tempo e espaço).",
                                "Clareza e documentação do código e diagramas.",
                                "Cobertura completa de testes (pelo menos 10 casos)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria dos Autômatos e Linguagens Formais.",
                                "Engenharia de Software: Design de parsers e state machines em sistemas embarcados.",
                                "Algoritmos: Grafos e algoritmos de busca (BFS para determinização).",
                                "Lógica: Estados como predicados booleanos em verificação formal.",
                                "Inteligência Artificial: Modelos finitos em reconhecimento de padrões."
                              ],
                              "realWorldApplication": "Em compiladores como GCC ou LLVM, DFAs minimizados são usados em analisadores léxicos (gerados por ferramentas como Flex) para tokenizar código-fonte eficientemente, processando bilhões de linhas em projetos como Linux kernel."
                            },
                            "estimatedTime": "4 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.1.5.2",
                        "name": "Implementação com Ferramentas Lex/Flex",
                        "description": "Uso de geradores de analisadores léxicos como Lex ou Flex para automatizar a criação de scanners a partir de especificações em expressões regulares.",
                        "specificSkills": [
                          {
                            "id": "10.1.1.5.2.1",
                            "name": "Especificar regras léxicas em Lex/Flex",
                            "description": "Definir padrões regulares para tokens na seção de definições e regras do arquivo .l, incluindo ações associadas para retornar tokens ao parser.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender e configurar a estrutura básica do arquivo .l",
                                  "subSteps": [
                                    "Abra um editor de texto e crie um novo arquivo com extensão .l",
                                    "Identifique as três seções principais: definições, regras e código C usuário",
                                    "Adicione as diretivas iniciais %{ %} para includes e %option nolex",
                                    "Delimite as seções com %%",
                                    "Adicione uma seção de código C no final para funções auxiliares"
                                  ],
                                  "verification": "Verifique se o arquivo possui as três seções delimitadas corretamente e compila sem erros de sintaxe com 'flex arquivo.l'",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Editor de texto (VS Code, Vim)",
                                    "Flex instalado no sistema",
                                    "Documentação oficial do Flex"
                                  ],
                                  "tips": [
                                    "Use %{ %} para declarações C que não devem ser processadas pelo Flex",
                                    "Sempre termine seções com %%",
                                    "Teste compilação precoce para evitar erros acumulados"
                                  ],
                                  "learningObjective": "Entender a organização modular do arquivo Lex/Flex para facilitar a escrita de regras",
                                  "commonMistakes": [
                                    "Esquecer os delimitadores %%",
                                    "Colocar código C fora das seções apropriadas",
                                    "Não incluir <stdio.h> ou yylval"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Definir padrões regulares na seção de definições",
                                  "subSteps": [
                                    "Declare nomes para padrões comuns, como DIGIT [0-9], LETTER [a-zA-Z]",
                                    "Crie padrões compostos, ex: NUMBER {DIGIT}+(\\.{DIGIT}+)?",
                                    "Use operadores regulares: *, +, ?, |, [], ^, $ conforme necessário",
                                    "Inclua padrões para espaços em branco e comentários, ex: WS [ \\t\\n]+",
                                    "Teste padrões isoladamente com ferramentas como regex101"
                                  ],
                                  "verification": "Substitua regras temporárias pelas definições e compile; verifique se não há warnings de padrões indefinidos",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Ferramenta de teste de regex (regex101.com)",
                                    "Referência de sintaxe regex do Flex",
                                    "Exemplos de padrões de linguagens reais"
                                  ],
                                  "tips": [
                                    "Mantenha definições curtas e reutilizáveis",
                                    "Escape caracteres especiais como . e *",
                                    "Priorize padrões mais específicos primeiro nas regras"
                                  ],
                                  "learningObjective": "Dominar a definição e reutilização de expressões regulares para tokens complexos",
                                  "commonMistakes": [
                                    "Não ancorar padrões com ^ ou $ quando necessário",
                                    "Conflitos entre padrões ambíguos",
                                    "Esquecer de tratar casos maiúsculos/minúsculos"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Especificar regras léxicas com ações associadas",
                                  "subSteps": [
                                    "Escreva regras no formato: padrão { ação; }",
                                    "Para tokens simples: \"if\" { return IF; }",
                                    "Para tokens com valor: {NUMBER} { yylval.num = atoi(yytext); return NUMBER; }",
                                    "Ignore irrelevantes: {WS} { /* ignorar */ }",
                                    "Adicione regra catch-all: . { printf(\"Caractere ilegal: %s\\n\", yytext); }",
                                    "Defina yylval para passar atributos ao parser"
                                  ],
                                  "verification": "Compile e execute o lexer standalone com input de teste; observe tokens retornados via yylex()",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Compilador Flex (flex)",
                                    "GCC para linkar",
                                    "Arquivo de teste com tokens variados"
                                  ],
                                  "tips": [
                                    "Use yytext para acessar o texto reconhecido",
                                    "Retorne tokens simbólicos definidos no parser (Yacc)",
                                    "Mantenha ações curtas; mova lógica para funções auxiliares"
                                  ],
                                  "learningObjective": "Associar corretamente padrões a ações semânticas para integração com o parser",
                                  "commonMistakes": [
                                    "Retornar tokens errados ou duplicados",
                                    "Não inicializar yylval",
                                    "Regras em ordem errada (menos específicas primeiro)"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Compilar, testar e depurar o analisador léxico",
                                  "subSteps": [
                                    "Compile com: flex arquivo.l && gcc lex.yy.c -o lexer -lfl",
                                    "Crie um main() simples para testar: while(yylex());",
                                    "Forneça input via stdin ou arquivo e verifique saída",
                                    "Use opções -d para debug e rastreie yyin/yyout",
                                    "Corrija erros: ajuste regras para longest match e leftmost",
                                    "Integre com Yacc/Bison para teste completo"
                                  ],
                                  "verification": "O lexer processa input sem crashes, reconhece 100% dos tokens corretos e ignora irrelevantes",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Terminal com Flex e GCC",
                                    "Arquivos de teste (válido/inválido)",
                                    "Valgrind para memory leaks opcionais"
                                  ],
                                  "tips": [
                                    "Use yy_scan_string() para testes unitários",
                                    "Opção -l para linha/coluna de erros",
                                    "Compare saída com tokens esperados manualmente"
                                  ],
                                  "learningObjective": "Validar funcionalidade completa e preparar para integração em compilador",
                                  "commonMistakes": [
                                    "Não linkar -lfl",
                                    "Buffer overflow em yytext longo",
                                    "Regras não cobrindo todos os casos"
                                  ]
                                }
                              ],
                              "practicalExample": "Crie um lexer para mini-linguagem: tokens IF, NUMBER (123.45), ID (var123). Arquivo mini.l:\n%{ #include <stdlib.h> #define IF 258 #define NUMBER 259 #define ID 260 %}\nDIGIT [0-9]\nNUMBER {DIGIT}+(\\.{DIGIT}+)?\nID [a-zA-Z_][a-zA-Z0-9_]*\nWS [ \\t\\n]+\n%%\n\"if\" {return IF;}\n{NUMBER} {yylval.str = strdup(yytext); return NUMBER;}\n{ID} {yylval.str = strdup(yytext); return ID;}\n{WS} { }\n. { printf(\"Erro: %s\\n\", yytext); }\n%%\nint main() { yylex(); return 0; }\nCompile: flex mini.l && gcc lex.yy.c -o mini -lfl\nTeste: echo 'if var 123.4' | ./mini",
                              "finalVerifications": [
                                "Arquivo .l compila sem erros ou warnings com flex",
                                "Lexer reconhece todos os tokens definidos corretamente em input variado",
                                "Ações associadas preenchem yylval sem vazamentos",
                                "Espaços e comentários são ignorados adequadamente",
                                "Catch-all trata caracteres ilegais sem crash",
                                "Integração com parser Yacc retorna tokens esperados"
                              ],
                              "assessmentCriteria": [
                                "Precisão e completude das expressões regulares (sem ambiguidades)",
                                "Correta associação de ações semânticas aos tokens",
                                "Eficiência: regras priorizam match mais longo e esquerdo",
                                "Tratamento robusto de edge cases (vazios, longos, inválidos)",
                                "Código limpo, reutilizável e bem comentado",
                                "Tempo de execução eficiente em inputs grandes"
                              ],
                              "crossCurricularConnections": [
                                "Teoria da Computação: Autômatos Finitos e Expressões Regulares",
                                "Matemática: Álgebra de Linguagens Regulares",
                                "Engenharia de Software: Desenvolvimento de Tools e Parsers",
                                "Linguística Computacional: Análise Morfológica de Textos",
                                "Inteligência Artificial: Processadores de Linguagem Natural"
                              ],
                              "realWorldApplication": "Implementação de compiladores (GCC, Clang), analisadores de logs (ELK Stack), validadores de formulários web, editores de texto (Vim syntax highlighting) e ferramentas de segurança (detecção de padrões maliciosos em firewalls)."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.5.2.2",
                            "name": "Compilar e integrar o scanner gerado",
                            "description": "Executar o comando flex ou lex para gerar o código C, compilar com yacc/bison ou manualmente, e integrar ao compilador principal.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar e executar o comando flex para gerar o código C do scanner",
                                  "subSteps": [
                                    "Verifique se o arquivo de especificação léxica (ex: scanner.l) está completo e sem erros sintáticos.",
                                    "Abra o terminal no diretório do projeto e execute o comando 'flex scanner.l' para gerar o arquivo lex.yy.c.",
                                    "Confira se o arquivo lex.yy.c foi gerado corretamente, verificando seu tamanho e conteúdo inicial.",
                                    "Ajuste opções do flex se necessário, como 'flex -o scanner.c scanner.l' para nome personalizado.",
                                    "Execute 'flex --version' para confirmar a versão instalada e compatibilidade."
                                  ],
                                  "verification": "Arquivo lex.yy.c (ou nome customizado) existe e contém o código C gerado sem erros reportados pelo flex.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Flex instalado, editor de texto (VS Code ou Vim), terminal (Linux/Mac ou Git Bash no Windows), arquivo scanner.l",
                                  "tips": "Use a flag -l para suprimir o #include <unistd.h> se houver conflitos em alguns ambientes.",
                                  "learningObjective": "Entender o processo de geração automática de analisadores léxicos a partir de especificações.",
                                  "commonMistakes": "Esquecer de salvar o arquivo .l antes de executar flex; usar caminhos absolutos incorretos no terminal."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Compilar o código C gerado do scanner",
                                  "subSteps": [
                                    "Crie um Makefile simples ou compile manualmente com 'gcc -c lex.yy.c -o scanner.o'.",
                                    "Inclua headers necessários como 'stdio.h', 'stdlib.h' e o header do scanner se customizado.",
                                    "Compile com warnings ativados: 'gcc -Wall -c lex.yy.c -o scanner.o'.",
                                    "Resolva erros de compilação, como funções yywrap ou yylex não declaradas.",
                                    "Gere um executável standalone para teste: 'gcc lex.yy.c -o scanner_test -lfl'."
                                  ],
                                  "verification": "Arquivo objeto scanner.o ou executável scanner_test compila sem erros ou warnings críticos.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "GCC ou Clang instalado, biblioteca flex (libfl), arquivo lex.yy.c",
                                  "tips": "Sempre linke com -lfl para acessar funções do flex; teste o executável com input simples.",
                                  "learningObjective": "Dominar a compilação de código gerado por ferramentas léxicas em C.",
                                  "commonMistakes": "Omitir -lfl no linking, causando erros undefined reference; ignorar warnings sobre yyin/yyout."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Integrar o scanner com o parser gerado por yacc/bison",
                                  "subSteps": [
                                    "Gere o parser com 'bison -d parser.y' para criar parser.tab.c e parser.tab.h.",
                                    "Modifique o scanner.l para incluir 'parser.tab.h' e declarar yylex para retornar tokens do parser.",
                                    "Recompile o scanner após incluir o header do parser: 'flex scanner.l; gcc -c lex.yy.c'.",
                                    "Compile parser e scanner juntos: 'gcc parser.tab.c scanner.o -o parser_scanner -lfl -ly'.",
                                    "Defina yyparse() para chamar yylex() corretamente no parser.y."
                                  ],
                                  "verification": "Executável parser_scanner compila e executa sem segmentation faults em input de teste.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Bison instalado, arquivos parser.y e scanner.l atualizados, GCC",
                                  "tips": "Use extern int yylex(); no parser.y e retorne yylval para valores semânticos.",
                                  "learningObjective": "Aprender a interconectar analisadores léxicos e sintáticos gerados por ferramentas.",
                                  "commonMistakes": "Não incluir parser.tab.h no scanner.l, causando erros de tokens indefinidos; mismatch de yylval."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Integrar o scanner/parser ao compilador principal e testar",
                                  "subSteps": [
                                    "Crie um main.c que chame yyparse() e redirecione yyin para input do usuário.",
                                    "Atualize o Makefile para linkar todos: compilador_main.o + scanner.o + parser.tab.o -o compilador.",
                                    "Compile o compilador completo: 'make' ou gcc equivalente com todas as dependências.",
                                    "Teste com input válido e inválido, verificando tokens reconhecidos e erros léxicos.",
                                    "Adicione logs ou debug com yydebug=1 para rastrear a execução."
                                  ],
                                  "verification": "Compilador executa, processa código-fonte corretamente e gera saída esperada sem crashes.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Makefile, main.c do compilador, testes de input (.txt com código-fonte), debugger (gdb)",
                                  "tips": "Use '#define YYDEBUG 1' para ativar debug; version controle com git antes de integrar.",
                                  "learningObjective": "Integrar componentes modulares de um compilador em um sistema coeso.",
                                  "commonMistakes": "Conflitos de linking múltiplas libs; não tratar EOF corretamente em yywrap()."
                                }
                              ],
                              "practicalExample": "Para um compilador de mini-C, execute 'flex mini_c.l' gerando lex.yy.c, compile com 'gcc -c lex.yy.c -o scanner.o -lfl', integre com bison mini_c.y, e no main.c chame yyparse() em um arquivo fonte mini_c_prog.mc, produzindo tokens como IDENTIFIER, NUMBER corretamente.",
                              "finalVerifications": [
                                "Flex gera lex.yy.c sem erros.",
                                "Scanner compila isoladamente e reconhece tokens básicos.",
                                "Integração com parser compila e parseia gramáticas simples.",
                                "Compilador principal executa sem crashes em testes unitários.",
                                "Logs mostram fluxo correto de tokens do scanner para parser.",
                                "Tratamento de erros léxicos funciona (ex: caracteres inválidos)."
                              ],
                              "assessmentCriteria": [
                                "Código compila sem warnings ou erros em todas as etapas.",
                                "Scanner identifica 100% dos tokens esperados em exemplos padrão.",
                                "Integração não introduz vazamentos de memória (valgrind clean).",
                                "Tempo de execução é eficiente (<1s para inputs médios).",
                                "Documentação no README explica passos de build e integração.",
                                "Testes automatizados passam (usando diff em saídas esperadas)."
                              ],
                              "crossCurricularConnections": [
                                "Programação em C: Manipulação de ponteiros e arquivos (yyin/yyout).",
                                "Engenharia de Software: Uso de Makefiles e build systems modulares.",
                                "Sistemas Operacionais: Comandos shell, bibliotecas dinâmicas e linking.",
                                "Automação de Processos: Geração de código via ferramentas DSL (flex/bison)."
                              ],
                              "realWorldApplication": "Em projetos como GCC ou LLVM, scanners gerados por Flex são compilados e integrados ao frontend do compilador para processar código-fonte real, permitindo análise léxica escalável em linguagens como C++ ou Rust."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.5.2.3",
                            "name": "Personalizar ações e gerenciamento de erros",
                            "description": "Implementar rotinas personalizadas nas ações { }, lidar com yyinput/yytext para lexemas e reportar erros léxicos com posições no código-fonte.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Configurar ações personalizadas nas regras de Flex",
                                  "subSteps": [
                                    "Identifique as regras de padrões no arquivo .l (ex: \"[a-zA-Z_][a-zA-Z0-9_]*\" { /* ação */ })",
                                    "Defina ações simples como retornar um token (ex: return ID;) ou imprimir informações de debug",
                                    "Adicione lógica condicional nas ações, como contadores ou modificadores de estado (BEGIN/REJECT)",
                                    "Teste uma ação básica compilando com flex e executando com input simples"
                                  ],
                                  "verification": "Compile o lexer com 'flex arquivo.l && gcc lex.yy.c' e execute com input de teste; verifique se ações são executadas sem crashes",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Editor de texto (VS Code)",
                                    "Flex instalado",
                                    "GCC compiler",
                                    "Exemplo de arquivo .l básico"
                                  ],
                                  "tips": "Use { printf(\"Debug: %s\\n\", yytext); } para debug inicial nas ações",
                                  "learningObjective": "Compreender como ações { } executam após match de padrão e personalizá-las para processar tokens",
                                  "commonMistakes": [
                                    "Esquecer ponto-e-vírgula no final da ação",
                                    "Não incluir <stdio.h> para printf",
                                    "Ignorar yylval para valores semânticos"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Manipular yytext, yyleng e yyinput para lexemas",
                                  "subSteps": [
                                    "Acesse yytext para obter o texto do lexema matched (string null-terminated)",
                                    "Use yyleng para o comprimento exato do lexema e evite buffer overflow",
                                    "Implemente yyinput() customizado para ler input de fontes não-padrão (ex: arquivo ou stdin com buffer)",
                                    "Copie yytext para estruturas personalizadas (ex: strdup(yytext)) se necessário persistir"
                                  ],
                                  "verification": "Adicione printf(\"Lexema: '%s' (len=%d)\\n\", yytext, yyleng); e verifique output em input de teste com múltiplos tokens",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Flex manual (man flex)",
                                    "Exemplos de código Flex online",
                                    "Input de teste com strings variadas"
                                  ],
                                  "tips": "Sempre cheque yyleng > 0 antes de processar; use strndup(yytext, yyleng) para segurança",
                                  "learningObjective": "Dominar buffers de Flex (yytext/yyinput) para extração precisa de lexemas",
                                  "commonMistakes": [
                                    "Assumir yytext é persistente (é sobrescrito no próximo match)",
                                    "Não null-terminar cópias de yytext",
                                    "Usar fgets em yyinput sem alinhar com Flex buffers"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar detecção e reporte de erros léxicos com posições",
                                  "subSteps": [
                                    "Configure tracking de posição: adicione yylineno++ em '\\n'; track coluna com yytext/yyleng",
                                    "Crie regra catch-all para inválidos: .|[\\n] { report_error(yytext[0], yylineno, col); }",
                                    "Defina função report_error(char c, int line, int col) que imprime \"Erro léxico: char '%c' na linha %d, col %d\"",
                                    "Use REJECT ou yymore() para erros multi-char (ex: sequências inválidas)",
                                    "Integre ECHO para caracteres válidos não-token"
                                  ],
                                  "verification": "Teste com input contendo chars inválidos; verifique logs de erro com linha/coluna corretas",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Flex manual seção erros",
                                    "Código boilerplate para yylineno/coluna",
                                    "Test cases com erros injetados"
                                  ],
                                  "tips": "Atualize coluna: col += yyleng; if(yytext[yyleng-1]=='\\n') col=1;",
                                  "learningObjective": "Reportar erros léxicos de forma informativa com localização precisa no fonte",
                                  "commonMistakes": [
                                    "Não resetar coluna em \\n",
                                    "Reportar posição errada em REJECT (posição pré-match)",
                                    "Ignorar EOF em erros"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Integrar, testar e depurar o sistema completo",
                                  "subSteps": [
                                    "Combine ações personalizadas, manipulação de buffers e erros em um lexer funcional",
                                    "Crie suite de testes: inputs válidos (tokens corretos), inválidos (erros posicionados)",
                                    "Compile e rode testes; use valgrind para leaks em strdup",
                                    "Adicione suporte a yylval para passar lexemas ao parser (ex: yylval.str = strdup(yytext))"
                                  ],
                                  "verification": "100% pass em testes: tokens corretos sem erros falsos, todos erros reportados precisamente",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Script de teste bash",
                                    "Valgrind",
                                    "Parser stub simples (yylex() caller)"
                                  ],
                                  "tips": "Defina %option yylineno para auto-linha; debug com yy_flex_debug=1",
                                  "learningObjective": "Garantir robustez do lexer com personalização e error-handling integrados",
                                  "commonMistakes": [
                                    "Memory leaks em strdup sem free",
                                    "Estados incompatíveis em ações (BEGIN sem fim)",
                                    "Testes insuficientes para edge cases como EOF ou empty input"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Otimizar e estender para cenários avançados",
                                  "subSteps": [
                                    "Implemente yymore() para tokens multi-regra (ex: comentários nested)",
                                    "Adicione suporte a input interativo com yyinput() de stdin",
                                    "Otimize reportes com context (mostre snippet de código ao redor do erro)",
                                    "Documente o código com comentários sobre ações/erros"
                                  ],
                                  "verification": "Execute em input complexo (código fonte real com erros); verifique performance e precisão",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Código fonte de exemplo (mini-C ou JSON)",
                                    "Profiler simples (time)"
                                  ],
                                  "tips": "Use %option nodefault para evitar ECHO padrão em catch-all",
                                  "learningObjective": "Aplicar técnicas avançadas para production-ready lexer",
                                  "commonMistakes": [
                                    "yymore() sem reset de buffers",
                                    "Mostrar contexto sem bounds check",
                                    "Omitir documentação de estados custom"
                                  ]
                                }
                              ],
                              "practicalExample": "Crie um lexer para mini-linguagem: regras para ID: [a-z]+ { yylval.str = strdup(yytext); return ID; }, NUM: [0-9]+ { ... }, catch-all: . { fprintf(stderr, \"Erro: '%c' linha %d col %d\\n\", yytext[0], yylineno, yycolno); } . Teste com 'var123 abc ! @ linha2\\n' -> tokens ID/NUM, erros em !@ com pos.",
                              "finalVerifications": [
                                "Lexer compila e linka sem warnings",
                                "Processa input válido produzindo tokens corretos via yylex()",
                                "Reporta TODOS erros léxicos com linha/coluna precisa",
                                "Não crasha em EOF ou input vazio",
                                "Sem memory leaks (valgrind clean)",
                                "Debug prints mostram yytext/yyleng corretos"
                              ],
                              " ": [
                                "assessmentCriteria:["
                              ],
                              "Ações { } executam lógica personalizada corretamente (ex: contadores, yylval) (30%)": [
                                ""
                              ],
                              "Manipulação de yytext/yyinput captura lexemas sem overflow (25%)": [
                                ""
                              ],
                              "Erros léxicos reportados com posição exata e mensagem clara (25%)": [
                                ""
                              ],
                              "Testes abrangentes passam (valid/invalid/edge) (10%)": [
                                ""
                              ],
                              "Código limpo, comentado e sem leaks (10%)": [
                                ""
                              ],
                              "crossCurricularConnections": ":[",
                              "Matemática: Autômatos finitos e expressões regulares para padrões": [
                                ""
                              ],
                              "Engenharia de Software: Error-handling e logging em sistemas": [
                                ""
                              ],
                              "Lógica/Algoritmos: Parsing e estado machines": [
                                ""
                              ],
                              "Inglês Técnico: Documentação de erros e relatórios padronizados": [
                                ""
                              ],
                              "realWorldApplication": "}  Compiladores reais como GCC/Flex usam isso para tokenizar código-fonte com erros amigáveis (ex: 'syntax error at line 42'); editores como Vim/Emacs para syntax highlighting com error underlines; ferramentas CLI como grep/awk estendidas para custom lexers com diagnósticos posicionados."
                            },
                            "estimatedTime": "3 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.1.5.3",
                        "name": "Integração e Tratamento de Erros no Scanner",
                        "description": "Conexão do analisador léxico com o restante do compilador, incluindo tabelas de símbolos e estratégias para recuperação de erros léxicos.",
                        "specificSkills": [
                          {
                            "id": "10.1.1.5.3.1",
                            "name": "Integrar scanner com tabela de símbolos",
                            "description": "Implementar inserção e consulta de lexemas em tabelas de hash ou árvores para identificadores, evitando duplicatas e associando atributos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Definir e implementar a estrutura da Tabela de Símbolos",
                                  "subSteps": [
                                    "Escolha o tipo de estrutura: tabela hash ou árvore binária de busca.",
                                    "Defina a estrutura de um nó/símbolo com campos: lexema (string), tipo (enum), escopo, atributos adicionais (ex: linha de declaração).",
                                    "Implemente funções básicas: init_table(), insert_symbol(), lookup_symbol().",
                                    "Para hash: implemente hash_function() e trate colisões com chaining ou open addressing.",
                                    "Teste unitário simples para inserção e busca."
                                  ],
                                  "verification": "Compilar e executar testes unitários que inserem 5 símbolos e buscam 3, verificando acertos.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Linguagem C ou Python",
                                    "Editor de código (VS Code)",
                                    "Biblioteca stdlib para hash (ou implementar manualmente)"
                                  ],
                                  "tips": "Comece com tabela hash simples usando lista encadeada para colisões; evite árvores se iniciante.",
                                  "learningObjective": "Compreender representação de símbolos e estruturas de dados eficientes para lookup rápido.",
                                  "commonMistakes": [
                                    "Não tratar colisões adequadamente",
                                    "Vazamento de memória em alocações dinâmicas",
                                    "Hash function fraca levando a degradação O(n)"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Modificar o Scanner para detectar e inserir lexemas de identificadores",
                                  "subSteps": [
                                    "Identifique no scanner onde lexemas de ID são reconhecidos (padrão [a-zA-Z][a-zA-Z0-9]*).",
                                    "Após validar como ID válido, chame insert_symbol(lexema) passando ponteiro para tabela global.",
                                    "Se inserção falhar (erro interno), reporte erro léxico.",
                                    "Atualize o token retornado para incluir ponteiro do símbolo na estrutura Token.",
                                    "Registre linha/coluna para depuração."
                                  ],
                                  "verification": "Execute scanner em código fonte simples com 3 IDs novos; verifique se tabela foi populada corretamente.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Código base do scanner existente",
                                    "Exemplos de código fonte para teste (arquivo .c simples)"
                                  ],
                                  "tips": "Use variável global para tabela de símbolos acessível pelo scanner; passe como parâmetro se possível.",
                                  "learningObjective": "Integrar análise léxica com gerenciamento de símbolos em tempo real.",
                                  "commonMistakes": [
                                    "Inserir keywords como IDs",
                                    "Não copiar lexema corretamente (shallow copy)",
                                    "Inserir antes de validar comprimento máximo"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar consulta (lookup) de símbolos durante o scanning",
                                  "subSteps": [
                                    "No scanner, após reconhecer ID, chame lookup_symbol(lexema) ANTES de inserir.",
                                    "Se encontrado, retorne token com ponteiro existente (evita duplicata).",
                                    "Se não encontrado, prossiga para inserção.",
                                    "Atualize estrutura Token para carregar entry_symbol.",
                                    "Adicione logging para depuração: printf se hit/miss."
                                  ],
                                  "verification": "Teste com código fonte repetindo o mesmo ID duas vezes; confirme apenas uma entrada na tabela.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Código do scanner modificado",
                                    "Ferramenta de depuração (gdb ou printfs)"
                                  ],
                                  "tips": "Sempre lookup primeiro, insert só se miss; isso garante unicidade.",
                                  "learningObjective": "Otimizar para reutilização de símbolos existentes, simulando fases posteriores do compilador.",
                                  "commonMistakes": [
                                    "Lookup após insert sempre",
                                    "Comparação case-sensitive errada",
                                    "Não lidar com NULL return"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Associar atributos aos símbolos e tratar casos especiais",
                                  "subSteps": [
                                    "Expanda estrutura símbolo com atributos: tipo (int, char), é_constante, valor_inicial, etc.",
                                    "No scanner, para IDs iniciais, associe atributos básicos (ex: linha_decl = current_line).",
                                    "Diferencie keywords de IDs via lookup em tabela separada de keywords.",
                                    "Implemente delete_symbol() para escopos, mas foque em inserção por agora.",
                                    "Adicione suporte a case-insensitivity se necessário para a linguagem."
                                  ],
                                  "verification": "Insira ID com atributos; lookup e verifique se tipo/linha foram setados corretamente.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Estrutura símbolo expandida",
                                    "Documentação da linguagem alvo (ex: C subset)"
                                  ],
                                  "tips": "Use union para atributos variáveis; inicie com ponteiro NULL para extensibilidade.",
                                  "learningObjective": "Gerenciar metadados ricos associados a identificadores para uso em fases semânticas.",
                                  "commonMistakes": [
                                    "Sobrescrever atributos em redeclarações",
                                    "Não inicializar todos campos",
                                    "Confundir ID com keyword"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Testar e depurar a integração completa",
                                  "subSteps": [
                                    "Crie casos de teste: código com IDs duplicados, keywords, erros léxicos.",
                                    "Execute scanner full em arquivo .c pequeno (ex: 'int x=1; x=2;').",
                                    "Dump da tabela final: liste todos símbolos e atributos.",
                                    "Meça performance: tempo de scan com 1000 IDs.",
                                    "Corrija bugs via depurador."
                                  ],
                                  "verification": "Scanner processa 10 arquivos teste sem crashes; tabela reflete corretamente unicidade e atributos.",
                                  "estimatedTime": "2.5 horas",
                                  "materials": [
                                    "Suite de testes (10 arquivos fonte)",
                                    "Valgrind para memory leaks",
                                    "Script para dump da tabela"
                                  ],
                                  "tips": "Automatize testes com framework como Unity (C); compare dump esperado vs atual.",
                                  "learningObjective": "Garantir robustez da integração em cenários reais de compilação.",
                                  "commonMistakes": [
                                    "Memory leaks em inserts",
                                    "Stack overflow em recursão profunda (árvores)",
                                    "Ignorar edge cases como ID vazio"
                                  ]
                                }
                              ],
                              "practicalExample": "Considere o código fonte: 'int main() { int x = 10; x++; }'. O scanner reconhece 'int' (keyword, não insere), 'main' (ID novo, insere com tipo=function), 'x' (ID novo, insere com tipo=int linha=2), depois 'x' (lookup hit, reutiliza ponteiro). Tabela final: main{type=func,line=1}, x{type=int,line=2,val_init=10}.",
                              "finalVerifications": [
                                "Tabela contém apenas entradas únicas para IDs (sem duplicatas).",
                                "Lookup retorna ponteiro correto para símbolos existentes.",
                                "Atributos (tipo, linha) são associados precisamente.",
                                "Scanner não trava em colisões ou IDs longos.",
                                "Dump da tabela matches com análise manual do código fonte.",
                                "Nenhum memory leak detectado por Valgrind."
                              ],
                              "assessmentCriteria": [
                                "Correção: 100% acerto em inserções/lookups em testes.",
                                "Eficiência: Tempo O(1) médio para hash com load factor <0.7.",
                                "Robustez: Trata colisões, edge cases (IDs vazios, max length).",
                                "Extensibilidade: Estrutura permite adicionar escopo/atributos.",
                                "Clareza: Código comentado, funções modulares.",
                                "Documentação: README com dump exemplo."
                              ],
                              "crossCurricularConnections": [
                                "Estruturas de Dados: Tabelas hash e árvores BST para gerenciamento eficiente.",
                                "Algoritmos: Funções hash e resolução de colisões.",
                                "Banco de Dados: Índices e catálogos semelhantes a tabelas de símbolos.",
                                "Engenharia de Software: Integração modular e testes unitários.",
                                "Análise de Complexidade: Avaliar O(1) vs O(log n)."
                              ],
                              "realWorldApplication": "Em compiladores profissionais como GCC ou Clang, a tabela de símbolos integrada ao scanner gerencia milhões de identificadores em projetos grandes, permitindo detecção precoce de redeclarações e associação de tipos para otimização de código."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.5.3.2",
                            "name": "Implementar recuperação de erros léxicos",
                            "description": "Desenvolver estratégias como pular caracteres inválidos, inserir tokens fictícios ou reportar erros com linha/coluna, mantendo a análise sem crash.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Configurar rastreamento de posição (linha e coluna) no scanner",
                                  "subSteps": [
                                    "Adicione variáveis para rastrear linha atual (line) e coluna atual (column) no estado do scanner.",
                                    "Atualize essas variáveis ao processar quebras de linha ('\\n') e avance de coluna para outros caracteres.",
                                    "Inclua um método para obter a posição atual como string (ex: 'linha X, coluna Y').",
                                    "Teste o rastreamento com inputs simples contendo múltiplas linhas.",
                                    "Registre a posição inicial como linha 1, coluna 1."
                                  ],
                                  "verification": "Execute o scanner com um input de várias linhas e verifique se as posições são reportadas corretamente em logs.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Editor de código (VS Code ou similar)",
                                    "Linguagem de programação com suporte a scanners (ex: Python, Java, C++)",
                                    "Input de teste com quebras de linha"
                                  ],
                                  "tips": "Sempre incremente coluna após processar um caractere válido; reset coluna para 1 ao encontrar '\\n'.",
                                  "learningObjective": "Entender e implementar rastreamento preciso de posição para diagnósticos de erro.",
                                  "commonMistakes": [
                                    "Esquecer de resetar coluna em '\\n'",
                                    "Não incrementar coluna após caractere processado",
                                    "Iniciar contagem em 0 em vez de 1"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar detecção e relatório de erros léxicos",
                                  "subSteps": [
                                    "Defina uma função de relatório de erro que capture caractere inválido, posição e emita mensagem sem interromper o fluxo.",
                                    "No loop principal do scanner, ao encontrar caractere não reconhecido pelo autômato, chame o relatório.",
                                    "Use um enum ou string para tipos de erro (ex: 'CARACTERE_DESCONHECIDO').",
                                    "Garanta que o relatório não cause crash, apenas logue ou armazene em lista de erros.",
                                    "Teste com caracteres especiais como '@', '#', etc."
                                  ],
                                  "verification": "Insira caracteres inválidos no input e confirme que erros são reportados com posição correta sem parar o scanner.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Código do scanner base",
                                    "Inputs de teste com caracteres inválidos",
                                    "Ferramenta de logging (console.log ou print)"
                                  ],
                                  "tips": "Mantenha o relatório leve para não impactar performance; use stderr para erros.",
                                  "learningObjective": "Desenvolver mecanismo de detecção que informa erros sem interromper análise.",
                                  "commonMistakes": [
                                    "Causar exceção/throw no relatório",
                                    "Não incluir o caractere exato no relatório",
                                    "Perder posição após relatório"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Desenvolver estratégias de recuperação de erros",
                                  "subSteps": [
                                    "Implemente estratégia 1: pular caractere inválido e continuar do próximo.",
                                    "Implemente estratégia 2: inserir token fictício (ex: ERROR_TOKEN) e avançar.",
                                    "Implemente estratégia 3: pular até próximo espaço ou quebra de linha para sincronizar.",
                                    "Escolha estratégia baseada no contexto (ex: pular para keyword próxima).",
                                    "Atualize o buffer de lookahead se necessário após recuperação."
                                  ],
                                  "verification": "Teste cada estratégia individualmente com inputs malformados e verifique continuidade da análise.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Código atualizado do scanner",
                                    "Suite de testes com erros variados (ex: código fonte com typos)"
                                  ],
                                  "tips": "Priorize recuperação local para manter sincronia; evite loops infinitos no pulo.",
                                  "learningObjective": "Criar múltiplas opções de recuperação para tornar o scanner robusto.",
                                  "commonMistakes": [
                                    "Pular demais e perder tokens válidos",
                                    "Inserir token sem avançar posição",
                                    "Não testar com sequências de erros"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Integrar recuperação ao scanner e realizar testes abrangentes",
                                  "subSteps": [
                                    "Integre todas as estratégias em um switch ou if-else no loop principal.",
                                    "Adicione configuração para escolher estratégia (ex: modo 'panic' vs 'skip').",
                                    "Crie testes unitários para cenários: erro isolado, múltiplos erros, erros no fim do arquivo.",
                                    "Meça taxa de recuperação: % de input processado apesar de erros.",
                                    "Otimize para performance, garantindo que recuperação não degrade velocidade."
                                  ],
                                  "verification": "Execute scanner em código fonte real com erros introduzidos e confirme tokens válidos extraídos + erros reportados.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Framework de testes (JUnit, pytest)",
                                    "Código fonte de exemplo com erros simulados",
                                    "Profiler de performance opcional"
                                  ],
                                  "tips": "Use asserts em testes para validar saída esperada; cubra edge cases como EOF com erro.",
                                  "learningObjective": "Garantir integração seamless e robustez total do scanner.",
                                  "commonMistakes": [
                                    "Recuperação falhar em EOF",
                                    "Ignorar erros após muitos reportes",
                                    "Degradar performance em inputs longos"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um scanner para linguagem simples, input 'int x = a1b@;' deve reportar erro em '@' (linha 1, col 8), pular para ';', retornar tokens INT, ID('x'), '=', ID('a1b'), ERROR_TOKEN('@'), ';'. O scanner continua sem crash.",
                              "finalVerifications": [
                                "Scanner processa input com 50% de caracteres inválidos sem crashar.",
                                "Todos erros reportam linha/coluna precisas.",
                                "Tokens válidos são extraídos corretamente apesar de erros.",
                                "Estratégias de recuperação podem ser alternadas via config.",
                                "Testes unitários passam com cobertura >90%.",
                                "Performance similar ao scanner sem erros (±10%)."
                              ],
                              "assessmentCriteria": [
                                "Precisão no relatório de erros (posição e tipo correto).",
                                "Eficácia da recuperação (continuidade da análise).",
                                "Robustez contra edge cases (EOF, múltiplos erros).",
                                "Clareza e modularidade do código.",
                                "Cobertura de testes abrangente.",
                                "Documentação de estratégias implementadas."
                              ],
                              "crossCurricularConnections": [
                                "Engenharia de Software: Programação defensiva e tratamento de exceções.",
                                "Matemática: Autômatos finitos e estados de erro em teoria da computação.",
                                "Design de UX: Mensagens de erro amigáveis em ferramentas de desenvolvimento.",
                                "Segurança da Informação: Prevenção de crashes por inputs maliciosos."
                              ],
                              "realWorldApplication": "Em compiladores profissionais como GCC/Clang, editores IDE (VS Code parsers), ferramentas de linting (ESLint), onde inputs reais contêm erros de digitação, mantendo análise parcial para feedback rápido ao desenvolvedor."
                            },
                            "estimatedTime": "3 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.5.3.3",
                            "name": "Otimizar performance do scanner",
                            "description": "Aplicar técnicas como buffering eficiente, minimização de DFA e caching de tokens para melhorar a velocidade em códigos-fonte grandes.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Implementar Buffering Eficiente",
                                  "subSteps": [
                                    "Analise o fluxo atual de leitura de caracteres do arquivo de entrada.",
                                    "Substitua leituras byte-a-byte por blocos maiores usando buffers fixos ou circulares (ex: 4KB ou 8KB).",
                                    "Implemente recarga automática do buffer quando próximo do fim.",
                                    "Adicione suporte a lookahead limitado sem overflow.",
                                    "Teste com arquivos pequenos para validar correção sem perda de dados."
                                  ],
                                  "verification": "Execute o scanner em um arquivo de teste e verifique se todos os tokens são identificados corretamente sem erros de EOF prematuro.",
                                  "estimatedTime": "2-3 horas",
                                  "materials": "Código-fonte do scanner atual, editor de código, compilador (C/C++ ou Java), arquivos de teste de 1MB+.",
                                  "tips": "Use std::vector<char> ou char[] para buffers em C++; prefira fread() em vez de fgetc().",
                                  "learningObjective": "Entender e aplicar técnicas de I/O em blocos para reduzir chamadas de sistema.",
                                  "commonMistakes": "Ignorar alinhamento de buffer causando lentidão em cache CPU; não tratar casos de buffer exausto no meio de um token."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Minimizar o DFA do Scanner",
                                  "subSteps": [
                                    "Construa o DFA original a partir das regras léxicas usando ferramentas como Flex ou manualmente.",
                                    "Aplique algoritmo de minimização de DFA (Hopcroft ou Moore) para fundir estados equivalentes.",
                                    "Gere uma tabela de transição otimizada com estados reduzidos (visualmente verifique redução >20%).",
                                    "Integre a tabela minimizada no código do scanner.",
                                    "Valide equivalência com o DFA original em suíte de testes."
                                  ],
                                  "verification": "Compare número de estados e transições antes/depois; execute scanner e confirme tokens idênticos.",
                                  "estimatedTime": "3-4 horas",
                                  "materials": "Ferramenta de geração DFA (Flex/RE2C), grafo visualizador (Graphviz), suíte de testes léxicos.",
                                  "tips": "Foquem em estados 'sink' e mortais primeiro; use bitsets para tabelas de transição densas.",
                                  "learningObjective": "Dominar minimização de autômatos para reduzir overhead computacional em reconhecimento de padrões.",
                                  "commonMistakes": "Não remover estados inalcançáveis levando a minimização incompleta; confundir DFA com NFA."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar Caching de Tokens",
                                  "subSteps": [
                                    "Identifique padrões repetitivos em códigos-fonte grandes (ex: keywords, identificadores).",
                                    "Crie uma cache hash-based (unordered_map ou hash table custom) para tokens recentes.",
                                    "Armazene posição no arquivo como chave e token como valor; limite tamanho (ex: 10k entradas).",
                                    "No scan, cheque cache antes de processar DFA; invalide em rewinds ou erros.",
                                    "Implemente LRU eviction para manter cache relevante."
                                  ],
                                  "verification": "Monitore taxa de hit da cache (>30% em arquivos grandes) e correção de tokens.",
                                  "estimatedTime": "2-3 horas",
                                  "materials": "Biblioteca hash (std::unordered_map em C++), profiler de memória, arquivos de código reais (ex: Linux kernel snippets).",
                                  "tips": "Use chave composta (posição + lookahead chars); evite cache para tokens raros.",
                                  "learningObjective": "Aplicar caching para explorar localidade temporal/espacial em streams de input.",
                                  "commonMistakes": "Cache ilimitado causando OOM; não invalidar em backtracks levando a tokens errados."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Integrar Otimizações e Benchmarkar",
                                  "subSteps": [
                                    "Combine buffering, DFA minimizado e cache no scanner unificado.",
                                    "Crie benchmarks com arquivos progressivamente maiores (1MB, 10MB, 100MB).",
                                    "Meça tempo total de scan, throughput (tokens/seg), uso de CPU/memória com ferramentas como perf ou Valgrind.",
                                    "Compare métricas pré/pós-otimização (almeje >2x speedup).",
                                    "Ajuste hiperparâmetros baseado em perfis (ex: tamanho buffer)."
                                  ],
                                  "verification": "Relatório de benchmark mostra speedup significativo sem perda de precisão em testes.",
                                  "estimatedTime": "2 horas",
                                  "materials": "Ferramentas de profiling (perf, gprof, time), arquivos de código-fonte grandes (GitHub repos).",
                                  "tips": "Execute benchmarks em hardware consistente; aqueça caches antes de medir.",
                                  "learningObjective": "Avaliar impacto holístico de otimizações via medições empíricas.",
                                  "commonMistakes": "Benchmarkar apenas arquivos pequenos mascarando ganhos; ignorar overhead de cache misses."
                                }
                              ],
                              "practicalExample": "Otimize um scanner para a linguagem C simples processando o código-fonte do kernel Linux (10MB+). Antes: 45s; Após: 18s, com 35% hit rate no cache e DFA reduzido de 150 para 92 estados.",
                              "finalVerifications": [
                                "Scanner processa arquivos >10MB sem crashes ou perda de tokens.",
                                "Throughput >2x maior que versão baseline em benchmarks.",
                                "Taxa de hit de cache >25% em códigos reais.",
                                "DFA minimizado tem ≤80% dos estados originais.",
                                "Nenhum erro de buffering ou EOF em edge cases.",
                                "Memória estável (<2x baseline)."
                              ],
                              "assessmentCriteria": [
                                "Correção: 100% tokens corretos em suíte de testes.",
                                "Eficiência: Speedup mensurável (>50%) em arquivos grandes.",
                                "Escalabilidade: Performance linear com tamanho de input.",
                                "Robustez: Trata erros sem degradação.",
                                "Otimização balanceada: Trade-offs CPU/memória explicados.",
                                "Documentação: Código comentado com métricas."
                              ],
                              "crossCurricularConnections": [
                                "Algoritmos e Estruturas de Dados (DFAs, hashing, buffers).",
                                "Otimização de Software (profiling, caching strategies).",
                                "Sistemas Operacionais (I/O eficiente, system calls).",
                                "Teoria da Computação (autômatos finitos).",
                                "Engenharia de Software (benchmarking, testes)."
                              ],
                              "realWorldApplication": "Em compiladores industriais como GCC/Clang, onde scanners processam bilhões de linhas de código diariamente, reduzindo tempo de build de horas para minutos em projetos como Chrome ou Linux."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.1.6",
                    "name": "Tratamento de Erros Léxicos",
                    "description": "Detecção, relatório e recuperação de erros durante a tokenização.",
                    "individualConcepts": [
                      {
                        "id": "10.1.1.6.1",
                        "name": "Detecção de Erros Léxicos",
                        "description": "Processo de identificação de entradas no código-fonte que não correspondem a nenhum padrão de token válido definido pelas expressões regulares ou autômatos finitos do analisador léxico.",
                        "specificSkills": [
                          {
                            "id": "10.1.1.6.1.1",
                            "name": "Identificar caracteres inválidos",
                            "description": "Reconhecer e sinalizar caracteres que não pertencem ao alfabeto da linguagem de programação durante a leitura sequencial do código-fonte.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Definir o alfabeto válido da linguagem de programação",
                                  "subSteps": [
                                    "Estude a especificação da linguagem para listar caracteres permitidos (letras, dígitos, símbolos especiais).",
                                    "Crie um conjunto ou tabela de caracteres válidos, incluindo ASCII ou Unicode ranges relevantes.",
                                    "Documente exceções, como caracteres válidos apenas em contextos específicos (ex: strings).",
                                    "Implemente uma função auxiliar para verificar se um caractere pertence ao alfabeto.",
                                    "Teste a função com exemplos de caracteres válidos e inválidos."
                                  ],
                                  "verification": "A função de verificação retorna true para todos os caracteres válidos conhecidos e false para inválidos.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Especificação da linguagem (ex: manual do Python ou C), editor de código, terminal para testes.",
                                  "tips": "Use sets em Python para verificação rápida: valid_chars = set('abcdefghijklmnopqrstuvwxyz0123456789_+-*/=()[]{};,').",
                                  "learningObjective": "Compreender e codificar o conjunto exato de caracteres permitidos na linguagem alvo.",
                                  "commonMistakes": "Incluir acidentalmente caracteres inválidos como válidos ou ignorar case sensitivity."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar leitura sequencial do código-fonte",
                                  "subSteps": [
                                    "Abra o arquivo de código-fonte em modo de leitura binária ou texto.",
                                    "Inicialize um ponteiro ou índice de posição atual (linha e coluna).",
                                    "Leia caractere por caractere usando loop while até EOF.",
                                    "Registre posição atual (linha, coluna) para cada caractere lido.",
                                    "Armazene caracteres lidos em buffer temporário para análise."
                                  ],
                                  "verification": "O loop lê corretamente todos os caracteres de um arquivo de teste sem pular ou repetir.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Editor de código, arquivos de teste .txt ou .py com código-fonte simulado.",
                                  "tips": "Use file.read(1) em Python para leitura caractere por caractere e rastreie posição manualmente.",
                                  "learningObjective": "Dominar a leitura sequencial precisa de código-fonte com rastreamento de posição.",
                                  "commonMistakes": "Não atualizar corretamente linha/coluna em quebras de linha (\n) ou tabs."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Integrar detecção e sinalização de caracteres inválidos",
                                  "subSteps": [
                                    "No loop de leitura, chame a função de verificação para cada caractere.",
                                    "Se inválido, registre erro com mensagem incluindo caractere, posição (linha:coluna).",
                                    "Decida ação: sinalizar e continuar (modo recovery) ou abortar.",
                                    "Colete todos os erros em uma lista para relatório final.",
                                    "Implemente formato de erro padrão: 'Erro léxico: caractere inválido '@' na linha 5, coluna 10'."
                                  ],
                                  "verification": "Ao processar código com inválidos, gera relatório correto sem crash.",
                                  "estimatedTime": "50 minutos",
                                  "materials": "Código do Step 1 e 2, arquivos de teste com caracteres inválidos como @, $, %.",
                                  "tips": "Use logging ou print com formatação para erros claros e posicionais.",
                                  "learningObjective": "Detectar e reportar erros léxicos de forma precisa e informativa.",
                                  "commonMistakes": "Falhar em reportar posição exata ou continuar após erro sem recovery."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Testar e refinar o detector de caracteres inválidos",
                                  "subSteps": [
                                    "Crie suíte de testes: arquivos válidos (sem erros), com 1 inválido, múltiplos inválidos.",
                                    "Execute o scanner e valide saídas contra resultados esperados.",
                                    "Meça cobertura: todos chars válidos ignorados, inválidos sinalizados.",
                                    "Otimize performance para arquivos grandes.",
                                    "Adicione suporte a encoding (ex: UTF-8) se aplicável."
                                  ],
                                  "verification": "100% de taxa de acerto em suíte de testes com pelo menos 10 casos.",
                                  "estimatedTime": "40 minutos",
                                  "materials": "Arquivos de teste variados, framework de teste (ex: unittest em Python).",
                                  "tips": "Automatize testes com asserts para mensagens de erro exatas.",
                                  "learningObjective": "Validar robustez do analisador léxico através de testes abrangentes.",
                                  "commonMistakes": "Testes insuficientes levando a falsos positivos/negativos."
                                }
                              ],
                              "practicalExample": "Em um lexer para Python, ao ler 'print(hello@world)', detecte '@' como inválido na linha 1, coluna 11, e reporte: 'Erro léxico: caractere inválido '@' na linha 1, coluna 11'. Continue para formar tokens 'print', '(', 'hello', etc., ignorando ou substituindo o inválido.",
                              "finalVerifications": [
                                "Lista corretamente o alfabeto válido da linguagem.",
                                "Lê sequencialmente código-fonte com rastreamento preciso de posição.",
                                "Detecta e sinaliza todos os caracteres inválidos com posição exata.",
                                "Gera relatório de erros formatado e continua processamento (recovery).",
                                "Passa em suíte de testes com 100% de acerto.",
                                "Funciona com arquivos grandes sem perda de performance."
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição do alfabeto (sem omissões ou extras).",
                                "Correção no rastreamento de posição (linha/coluna).",
                                "Qualidade das mensagens de erro (claras, posicionais).",
                                "Robustez em recovery de erros múltiplos.",
                                "Cobertura de testes (variedade de casos edge).",
                                "Eficiência no loop de leitura (O(n) tempo)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Autômatos finitos para reconhecimento de linguagens regulares.",
                                "Linguística: Conceitos de alfabeto e morfemas em análise de texto.",
                                "Engenharia de Software: Tratamento de exceções e logging em sistemas.",
                                "Segurança da Informação: Detecção de injeções via caracteres maliciosos."
                              ],
                              "realWorldApplication": "Em compiladores como GCC ou interpretadores Python, detecta erros de digitação cedo; editores como VS Code usam para realce sintático; ferramentas de linting como ESLint sinalizam inválidos para devs."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.6.1.2",
                            "name": "Detectar tokens malformados",
                            "description": "Identificar sequências de caracteres que iniciam um token válido mas falham em completar o padrão, como identificadores com caracteres especiais inválidos ou números sem dígitos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Padrões de Tokens Válidos em Análise Léxica",
                                  "subSteps": [
                                    "Estude as regras gramaticais para tokens comuns: identificadores (letras seguidas de alfanuméricos), números (dígitos opcionais com ponto), operadores (+, -, etc.)",
                                    "Analise expressões regulares (regex) equivalentes para cada tipo de token, como [a-zA-Z_][a-zA-Z0-9_]* para identificadores",
                                    "Identifique os caracteres delimitadores e terminadores de tokens, como espaços, quebras de linha e símbolos especiais",
                                    "Crie uma tabela resumindo padrões válidos vs. inválidos iniciais",
                                    "Pratique reconhecendo tokens válidos em strings de exemplo"
                                  ],
                                  "verification": "Crie uma tabela com 10 exemplos de strings e classifique cada token como válido ou potencialmente malformado",
                                  "estimatedTime": "45 minutes",
                                  "materials": [
                                    "Documentação de gramáticas léxicas (ex: manual de flex/bison)",
                                    "Editor de texto ou IDE com suporte a regex",
                                    "Exemplos de código fonte simples"
                                  ],
                                  "tips": "Use ferramentas online como regex101.com para testar padrões visualmente",
                                  "learningObjective": "Compreender precisamente os critérios de validade para tokens léxicos comuns",
                                  "commonMistakes": [
                                    "Confundir identificadores com palavras-chave",
                                    "Ignorar regras de comprimento máximo",
                                    "Não considerar caracteres Unicode"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Catalogar Tipos Comuns de Tokens Malformados",
                                  "subSteps": [
                                    "Liste categorias: identificadores com caracteres especiais (ex: var@123), números incompletos (ex: 12.), strings sem aspas de fechamento",
                                    "Para cada categoria, gere 5 exemplos de sequências que 'iniciam válido mas falham'",
                                    "Desenhe diagramas de estado finito (FSM) mostrando transições para estados de erro",
                                    "Classifique malformados por gravidade: recuperável vs. fatal",
                                    "Documente mensagens de erro descritivas para cada tipo"
                                  ],
                                  "verification": "Gere uma lista de 15 exemplos malformados com classificações e mensagens de erro corretas",
                                  "estimatedTime": "60 minutes",
                                  "materials": [
                                    "Papel e caneta para diagramas FSM",
                                    "Ferramenta de desenho como draw.io",
                                    "Exemplos de erros léxicos de compiladores reais (ex: GCC warnings)"
                                  ],
                                  "tips": "Comece com os mais comuns como IDs com símbolos para construir confiança",
                                  "learningObjective": "Identificar e categorizar padrões de falha em tokens que começam válidos",
                                  "commonMistakes": [
                                    "Focar só em erros totais, ignorando parciais",
                                    "Não diferenciar entre tipos de token",
                                    "Erros em diagramas FSM levando a detecções erradas"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Desenvolver Algoritmo de Detecção de Tokens Malformados",
                                  "subSteps": [
                                    "Projete um pseudocódigo para um lexer que avance caractere por caractere, validando contra padrões",
                                    "Implemente lógica de 'tentativa de match': avance até mismatch, então retroaja e reporte malformado",
                                    "Incorpore estados de erro com recuperação (ex: pular até próximo delimitador)",
                                    "Teste o pseudocódigo manualmente com 5 strings de input",
                                    "Otimize para eficiência, evitando backtracking excessivo"
                                  ],
                                  "verification": "Simule o algoritmo em papel com 3 inputs complexos e confirme detecções corretas",
                                  "estimatedTime": "75 minutes",
                                  "materials": [
                                    "Pseudocódigo template em editor",
                                    "Exemplos de inputs de teste variados",
                                    "Referências sobre analisadores léxicos (ex: 'Compilers: Principles, Techniques, and Tools')"
                                  ],
                                  "tips": "Use uma máquina de estados finitos (FSM) para modelar o lexer em vez de regex puro",
                                  "learningObjective": "Criar um algoritmo acionável para detectar tokens parciais inválidos",
                                  "commonMistakes": [
                                    "Não implementar recuperação de erro, travando o lexer",
                                    "Confundir backtracking com lookahead excessivo",
                                    "Ignorar contexto de linha/coluna para relatórios"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Implementar, Testar e Refinar a Detecção",
                                  "subSteps": [
                                    "Codifique o algoritmo em Python ou JavaScript como função lexer simples",
                                    "Crie suíte de testes: 10 casos válidos, 15 malformados, edge cases (ex: EOF no meio)",
                                    "Execute testes, registre falsos positivos/negativos e ajuste",
                                    "Adicione relatórios detalhados: posição, tipo de erro, sugestão de correção",
                                    "Profile performance com inputs grandes e otimize se necessário"
                                  ],
                                  "verification": "A função detecta corretamente 100% dos 25 casos de teste, com relatórios precisos",
                                  "estimatedTime": "90 minutes",
                                  "materials": [
                                    "Ambiente de programação (Python/IDLE ou VSCode)",
                                    "Framework de testes (unittest ou pytest)",
                                    "Inputs de teste em arquivo JSON"
                                  ],
                                  "tips": "Comece com lexer minimalista suportando só IDs e números para iterar rápido",
                                  "learningObjective": "Implementar e validar uma detecção robusta de tokens malformados em código real",
                                  "commonMistakes": [
                                    "Testes insuficientes levando a bugs ocultos",
                                    "Relatórios vagos sem posição exata",
                                    "Performance ruim em strings longas"
                                  ]
                                }
                              ],
                              "practicalExample": "Input: 'int x = 3. ; var@name = 10'\nSaída esperada: Token 'var@name' detectado como identificador malformado (caractere '@' inválido na posição 12:15), número '3.' como malformado (falta dígitos após ponto). Lexer recupera pulando para próximo token válido.",
                              "finalVerifications": [
                                "Classificar corretamente 20 tokens malformados misturados em código fonte",
                                "Implementar lexer que processa input inteiro sem crashar em erros",
                                "Gerar relatórios com linha/coluna precisa para todos erros",
                                "Diferenciar tokens malformados de erros sintáticos",
                                "Recuperar e continuar análise após detecção de erro",
                                "Otimizar para inputs de 1000+ caracteres sem lentidão"
                              ],
                              "assessmentCriteria": [
                                "Precisão na detecção: >95% em suíte de testes padrão",
                                "Cobertura de tipos: Pelo menos 80% dos padrões comuns de malformação",
                                "Eficiência: Processa 1KB em <100ms",
                                "Qualidade de relatórios: Inclui contexto, sugestões e posição exata",
                                "Robustez: Lida com edge cases como EOF, Unicode e inputs vazios",
                                "Modularidade: Código reutilizável para extensão a mais tokens"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria de Autômatos Finitos e Expressões Regulares",
                                "Programação: Desenvolvimento de Parsers e Tratamento de Exceções",
                                "Engenharia de Software: Design de Sistemas Tolerantes a Falhas",
                                "Linguística Computacional: Análise Morfológica e Reconhecimento de Padrões",
                                "Segurança da Informação: Detecção de Injections via Parsing Seguro"
                              ],
                              "realWorldApplication": "Em compiladores como GCC/Clang ou IDEs (VSCode, IntelliJ) para realce imediato de erros de digitação, autocompletar sugestões e depuração precoce, prevenindo bugs em escala em projetos de software industriais."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.6.1.3",
                            "name": "Utilizar estados de rejeição em autômatos",
                            "description": "Implementar transições para estados de erro ou usar timeouts em autômatos finitos para detectar falhas na tokenização em tempo real.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender Conceitos Fundamentais de Estados de Rejeição em Autômatos Finitos",
                                  "subSteps": [
                                    "Revise a estrutura básica de um Autômato Finito Determinístico (AFD): estados, alfabeto, função de transição, estado inicial e estados finais.",
                                    "Identifique estados de aceitação (finais) versus estados de rejeição (de erro ou sink states).",
                                    "Estude exemplos de transições para estados de rejeição em cenários de tokenização inválida.",
                                    "Analise o papel de timeouts em autômatos para detecção de falhas em tempo real.",
                                    "Desenhe um diagrama simples de AFD sem e com estados de rejeição."
                                  ],
                                  "verification": "Crie um diagrama de AFD que inclua pelo menos um estado de rejeição e explique sua função em um relatório curto.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Livro de Teoria da Computação (ex: Sipser)",
                                    "Ferramenta de desenho de diagramas como Draw.io ou papel e caneta",
                                    "Artigos sobre análise léxica"
                                  ],
                                  "tips": "Comece com autômatos simples para números ou identificadores para visualizar rejeições.",
                                  "learningObjective": "Compreender a diferença entre estados de aceitação e rejeição e seu uso em detecção de erros léxicos.",
                                  "commonMistakes": [
                                    "Confundir estados de rejeição com estados finais",
                                    "Ignorar loops em estados de rejeição para entradas contínuas inválidas"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Projetar um Autômato com Estados de Rejeição para Tokenização",
                                  "subSteps": [
                                    "Defina o alfabeto relevante para tokenização (ex: letras, dígitos, símbolos especiais).",
                                    "Identifique padrões válidos (ex: identificadores: letra seguida de alfanuméricos).",
                                    "Crie estados de rejeição para padrões inválidos (ex: início com dígito, caracteres especiais não permitidos).",
                                    "Inclua transições para estados de erro a partir de estados parciais.",
                                    "Adicione lógica de timeout para sequências longas sem token válido."
                                  ],
                                  "verification": "Desenhe e valide o diagrama do autômato testando manualmente 5 strings: 3 válidas e 2 inválidas.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Draw.io ou JFLAP para simulação de autômatos",
                                    "Exemplos de linguagens de programação simples (ex: mini-Pascal)"
                                  ],
                                  "tips": "Use estados sink (absorventes) nos estados de rejeição para capturar entradas persistentes inválidas.",
                                  "learningObjective": "Projetar autômatos que incorporem estados de rejeição específicos para erros léxicos comuns.",
                                  "commonMistakes": [
                                    "Falta de transições completas para todos os símbolos do alfabeto",
                                    "Estados de rejeição inacessíveis"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar Transições e Timeouts em Código",
                                  "subSteps": [
                                    "Escreva uma classe ou função para representar o autômato em Python ou Java.",
                                    "Implemente a tabela de transições incluindo redirecionamentos para estados de rejeição.",
                                    "Adicione lógica de timeout (ex: contador de transições máximas por token).",
                                    "Integre detecção de falhas: sinalize erro léxico ao atingir estado de rejeição ou timeout.",
                                    "Teste unitariamente com entradas de borda (válidas, inválidas, longas)."
                                  ],
                                  "verification": "Execute o código com um conjunto de testes e confirme que rejeita entradas inválidas com mensagens de erro apropriadas.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Editor de código (VS Code)",
                                    "Biblioteca JFLAP ou código Python para autômatos",
                                    "Exemplos de lexers como Flex"
                                  ],
                                  "tips": "Use dicionários para tabelas de transição para eficiência em tempo real.",
                                  "learningObjective": "Implementar funcionalmente autômatos com estados de rejeição e timeouts para processamento em tempo real.",
                                  "commonMistakes": [
                                    "Não resetar o autômato após rejeição",
                                    "Timeouts muito curtos ou longos para cenários reais"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Testar e Integrar em um Lexer Simples para Detecção em Tempo Real",
                                  "subSteps": [
                                    "Crie um lexer básico que use o autômato para tokenizar uma string de entrada.",
                                    "Simule entrada em tempo real (ex: stream de caracteres) e meça performance.",
                                    "Registre falhas: tipo de erro, posição e sugestões de correção.",
                                    "Otimize para eficiência: minimize estados e transições.",
                                    "Valide com um conjunto maior de testes incluindo código-fonte real."
                                  ],
                                  "verification": "Tokenize um arquivo de exemplo e gere relatório de erros léxicos detectados corretamente.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Código do Step 3",
                                    "Arquivos de teste com erros léxicos intencionais",
                                    "Profiler de performance (ex: timeit em Python)"
                                  ],
                                  "tips": "Implemente buffering para streams em tempo real, como entrada de usuário.",
                                  "learningObjective": "Aplicar o autômato em um contexto de lexer real, garantindo detecção robusta de falhas.",
                                  "commonMistakes": [
                                    "Ignorar contexto de tokenização (ex: comentários vs código)",
                                    "Baixa performance em entradas longas"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um lexer para uma linguagem simples, ao processar '12abc' (inválido como identificador), o autômato transita para estado de rejeição após '1' (dígito inicial), sinalizando erro léxico na posição 1 com mensagem 'Identificador não pode iniciar com dígito'. Para timeout, em uma sequência infinita de caracteres inválidos, após 100 transições, rejeita como 'Tokenização falhou por timeout'.",
                              "finalVerifications": [
                                "O autômato corretamente aceita todos os tokens válidos definidos.",
                                "Rejeita 100% das strings inválidas testadas, alcançando estados de rejeição.",
                                "Timeouts ativam em sequências excessivamente longas sem token válido.",
                                "Mensagens de erro incluem posição e tipo de falha léxica.",
                                "Performance em tempo real: processa 1KB de input em <100ms.",
                                "Reset correto do autômato após cada token ou rejeição."
                              ],
                              "assessmentCriteria": [
                                "Precisão: Taxa de detecção de erros >95%.",
                                "Completude: Todas transições do alfabeto definidas.",
                                "Eficiência: Tempo de processamento linear no tamanho da entrada.",
                                "Robustez: Lida com edge cases como strings vazias ou EOF.",
                                "Clareza: Código comentado e diagramas legíveis.",
                                "Integração: Funciona em lexer standalone."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria dos Autômatos e Linguagens Formais.",
                                "Engenharia de Software: Desenvolvimento de Parsers e Tratamento de Exceções.",
                                "Segurança da Informação: Detecção de Inputs Maliciosos em Scanners.",
                                "Lógica e Algoritmos: Máquinas de Estados Finitos em IA."
                              ],
                              "realWorldApplication": "Em compiladores como GCC ou Clang, estados de rejeição em lexers detectam erros de sintaxe em código-fonte, permitindo diagnósticos precisos para desenvolvedores; também em analisadores de logs de segurança para identificar padrões anômalos em tempo real."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.1.6.2",
                        "name": "Relatório de Erros Léxicos",
                        "description": "Geração de mensagens de erro claras, concisas e informativas que ajudem o programador a localizar e corrigir problemas na tokenização.",
                        "specificSkills": [
                          {
                            "id": "10.1.1.6.2.1",
                            "name": "Construir mensagens de erro descritivas",
                            "description": "Criar mensagens que especifiquem o tipo de erro léxico, como 'caractere inválido' ou 'token não reconhecido', incluindo contexto relevante do código-fonte.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Identificar e classificar tipos comuns de erros léxicos",
                                  "subSteps": [
                                    "Estude os erros léxicos básicos: caractere inválido, token não reconhecido, fim de arquivo inesperado e string literal não fechada.",
                                    "Revise a gramática da linguagem alvo para mapear tokens válidos vs. inválidos.",
                                    "Crie uma tabela de classificação com exemplos para cada tipo de erro.",
                                    "Analise amostras de código-fonte com erros intencionais para praticar identificação.",
                                    "Documente padrões de detecção no lexer atual."
                                  ],
                                  "verification": "Crie uma tabela completa com pelo menos 5 tipos de erros e exemplos; revise com um colega ou autoavaliação.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Documentação da gramática da linguagem",
                                    "Exemplos de código com erros léxicos",
                                    "Editor de texto ou IDE"
                                  ],
                                  "tips": "Use regex ou fluxogramas para visualizar detecções de erros.",
                                  "learningObjective": "Classificar precisamente erros léxicos e associá-los a mensagens descritivas.",
                                  "commonMistakes": [
                                    "Confundir erros léxicos com sintáticos",
                                    "Ignorar variações culturais em caracteres (ex: UTF-8)",
                                    "Sobrecarregar classificações desnecessariamente"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Capturar contexto relevante do código-fonte",
                                  "subSteps": [
                                    "Registre a posição do erro: linha, coluna e índice no arquivo.",
                                    "Extraia um snippet de código ao redor do erro (ex: 10 caracteres antes e depois).",
                                    "Implemente funções para obter o conteúdo da linha completa.",
                                    "Inclua o caractere ou token problemático destacado.",
                                    "Teste captura em diferentes tamanhos de buffer."
                                  ],
                                  "verification": "Gere logs de contexto para 3 arquivos de teste com erros variados e confirme que o snippet é preciso.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Código do lexer atual",
                                    "Arquivos de teste com erros",
                                    "Ferramenta de depuração como gdb ou print statements"
                                  ],
                                  "tips": "Mantenha snippets curtos para legibilidade; use setas (^) para apontar o erro.",
                                  "learningObjective": "Coletar dados contextuais precisos para tornar mensagens acionáveis.",
                                  "commonMistakes": [
                                    "Capturar contexto muito amplo levando a confusão",
                                    "Falhar em arquivos multiline",
                                    "Ignorar encoding do arquivo"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Estruturar e formatar mensagens de erro descritivas",
                                  "subSteps": [
                                    "Defina um template padrão: 'Erro léxico [tipo] na linha X, coluna Y: [snippet] - [descrição].'",
                                    "Personalize descrições para cada tipo (ex: 'Caractere inválido '@' encontrado').",
                                    "Inclua sugestões de correção quando possível (ex: 'Esperava letra ou dígito').",
                                    "Garanta mensagens concisas, em linguagem natural e sem jargão excessivo.",
                                    "Localize mensagens se aplicável (ex: inglês/português)."
                                  ],
                                  "verification": "Escreva 5 mensagens de exemplo formatadas e valide legibilidade com leitura em voz alta.",
                                  "estimatedTime": "50 minutos",
                                  "materials": [
                                    "Templates de mensagens de compiladores famosos (GCC, Clang)",
                                    "Exemplos de erros capturados do step 2"
                                  ],
                                  "tips": "Priorize clareza sobre tecnicidade; teste com não-especialistas.",
                                  "learningObjective": "Construir mensagens padronizadas que guiem o usuário à correção rápida.",
                                  "commonMistakes": [
                                    "Mensagens vagas como 'Erro desconhecido'",
                                    "Expor detalhes internos do lexer",
                                    "Mensagens longas demais"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Implementar, testar e refinar no lexer",
                                  "subSteps": [
                                    "Integre geração de mensagens nas funções de detecção de erro do lexer.",
                                    "Crie suíte de testes com 10+ casos cobrindo todos os tipos.",
                                    "Execute testes e colete feedback sobre utilidade das mensagens.",
                                    "Refine com base em edge cases (ex: erros no final do arquivo).",
                                    "Adicione logging opcional para depuração avançada."
                                  ],
                                  "verification": "Lexer gera mensagens corretas em 100% dos testes; revise output manualmente.",
                                  "estimatedTime": "90 minutos",
                                  "materials": [
                                    "Código-fonte do lexer",
                                    "Framework de testes (ex: unittest em Python)",
                                    "Validador de mensagens"
                                  ],
                                  "tips": "Automatize testes com asserts em strings de mensagens esperadas.",
                                  "learningObjective": "Integrar mensagens funcionais que melhorem a experiência do desenvolvedor.",
                                  "commonMistakes": [
                                    "Não testar com input realista",
                                    "Mensagens inconsistentes em formatação",
                                    "Ignorar performance no reporting"
                                  ]
                                }
                              ],
                              "practicalExample": "Entrada: código com erro 'int x = @abc;'\nSaída do lexer: 'Erro léxico: caractere inválido '@' na linha 1, coluna 7:\nint x = ^abc;\nEsperava identificador ou número após '='.'",
                              "finalVerifications": [
                                "Gere mensagens para 5 tipos de erros diferentes com contexto preciso.",
                                "Confirme que mensagens incluem linha, coluna, snippet e sugestão.",
                                "Teste em lexer real e valide output contra casos esperados.",
                                "Avalie legibilidade: mensagens compreensíveis por iniciantes.",
                                "Verifique ausência de vazamentos de info interna ou crashes.",
                                "Compare com mensagens de compiladores profissionais (ex: GCC)."
                              ],
                              "assessmentCriteria": [
                                "Precisão na classificação do tipo de erro (100% nos testes).",
                                "Contexto relevante e destacado corretamente em todos os casos.",
                                "Mensagens concisas (máx 100 chars) e acionáveis.",
                                "Cobertura de pelo menos 80% dos erros léxicos comuns.",
                                "Integração sem quebrar fluxo normal do lexer.",
                                "Melhoria mensurável na taxa de correção rápida de erros."
                              ],
                              "crossCurricularConnections": [
                                "UX/UI Design: Princípios de feedback claro e erro humano-centrado.",
                                "Programação Geral: Tratamento de exceções e logging.",
                                "Linguística Computacional: Análise de padrões em texto.",
                                "Testes de Software: Criação de suítes de teste automatizadas.",
                                "Comunicação Técnica: Redação de documentação e relatórios."
                              ],
                              "realWorldApplication": "Em compiladores como GCC ou Clang, mensagens descritivas aceleram depuração de código-fonte; IDEs como VS Code usam para real-time feedback, reduzindo tempo de desenvolvimento em 30-50% para erros triviais."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.6.2.2",
                            "name": "Indicar posição exata do erro",
                            "description": "Manter contadores de linha e coluna para reportar a localização precisa do erro léxico no arquivo de entrada.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Configurar rastreamento de posição atual no lexer",
                                  "subSteps": [
                                    "Identifique o estado atual do lexer que processa o arquivo de entrada.",
                                    "Adicione variáveis para rastrear linha (line) e coluna (column), inicializando em 1.",
                                    "Atualize linha e coluna a cada caractere lido: incremente coluna por caractere, reset coluna e incremente linha em quebras de linha.",
                                    "Implemente uma função para avançar o caractere que atualiza essas posições automaticamente.",
                                    "Teste o rastreamento com um arquivo simples sem erros."
                                  ],
                                  "verification": "Imprima posições atuais após processar linhas e colunas conhecidas; confirme que coincidem com o esperado.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Código fonte do lexer",
                                    "Editor de código (VS Code ou similar)",
                                    "Arquivo de teste com quebras de linha"
                                  ],
                                  "tips": "Use uma estrutura Position {int line, col;} para encapsular as coordenadas.",
                                  "learningObjective": "Compreender e implementar rastreamento dinâmico de posição em streams de caracteres.",
                                  "commonMistakes": [
                                    "Esquecer de resetar coluna para 1 após '\\n'",
                                    "Iniciar linha/coluna em 0 ao invés de 1",
                                    "Não atualizar após EOF"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Detectar e capturar erros léxicos com posição",
                                  "subSteps": [
                                    "Defina condições de erro léxico, como caractere inválido ou token malformado.",
                                    "Ao detectar erro, capture instantaneamente as posições de linha e coluna atuais.",
                                    "Crie uma estrutura Error {string message, Position pos;} para armazenar detalhes.",
                                    "Colete múltiplos erros sem interromper o scan, salvando lista de erros.",
                                    "Ignore ou pule o caractere inválido para continuar o scan."
                                  ],
                                  "verification": "Insira um caractere inválido em um arquivo de teste e verifique se a posição é capturada corretamente.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Código do lexer atualizado",
                                    "Arquivos de teste com erros intencionais",
                                    "Debugger ou prints de debug"
                                  ],
                                  "tips": "Salve posição antes de avançar o stream para precisão.",
                                  "learningObjective": "Integrar detecção de erros com captura contextual de posição no lexer.",
                                  "commonMistakes": [
                                    "Capturar posição após avançar o stream",
                                    "Não lidar com múltiplos erros no mesmo arquivo",
                                    "Mensagens de erro vagas sem posição"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar relatório de erros com posição exata",
                                  "subSteps": [
                                    "Após o scan completo, itere pela lista de erros coletados.",
                                    "Formate cada relatório como: 'Erro na linha X, coluna Y: [mensagem]'",
                                    "Adicione contexto opcional, como trecho do código ao redor da posição.",
                                    "Saia com código de erro não-zero se houver falhas, exibindo relatório no stderr.",
                                    "Teste com vários erros em posições diferentes."
                                  ],
                                  "verification": "Execute lexer em arquivo com erros conhecidos; confirme relatório exibe linha/coluna corretas.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Lista de erros implementada",
                                    "Arquivos de teste múltiplos",
                                    "Ferramenta de diff para comparar saídas"
                                  ],
                                  "tips": "Use 1-based indexing para linha/coluna, padrão em editores.",
                                  "learningObjective": "Gerar relatórios de erro legíveis e posicionais para depuração eficaz.",
                                  "commonMistakes": [
                                    "Usar 0-based indexing",
                                    "Relatórios sem formatação clara",
                                    "Não diferenciar warnings de erros"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Validar e refinar o sistema de reporte de posições",
                                  "subSteps": [
                                    "Crie suíte de testes unitários para casos edge: início/fim de arquivo, tabs, múltiplas linhas.",
                                    "Meça precisão comparando posição reportada com localização manual no editor.",
                                    "Otimize para performance: evite overhead desnecessário no rastreamento.",
                                    "Adicione suporte a codificação UTF-8 se aplicável, ajustando colunas para caracteres multi-byte.",
                                    "Documente o formato do relatório para uso em ferramentas externas."
                                  ],
                                  "verification": "Todos os testes passam com 100% de precisão em posições; cobertura de código >90%.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Framework de testes (JUnit ou similar)",
                                    "Editor com numeração de linhas/colunas",
                                    "Arquivos edge-case"
                                  ],
                                  "tips": "Use asserts em testes para linha e coluna exatas.",
                                  "learningObjective": "Garantir robustez e precisão no tratamento de erros léxicos.",
                                  "commonMistakes": [
                                    "Ignorar tabs/carriage returns em contagem de colunas",
                                    "Falta de testes para EOF",
                                    "Sobre-otimização prematura"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um lexer para uma linguagem simples, arquivo input.txt: 'int x = ;' (erro ';' faltando após '='). Relatório: 'Erro léxico na linha 1, coluna 8: Token esperado após \"=\" mas encontrado \";\"'. Posição aponta exatamente para o ';' inválido.",
                              "finalVerifications": [
                                "Rastreamento de linha/coluna correto em arquivos com 100+ linhas e colunas variadas.",
                                "Relatórios incluem posição exata para todos erros detectados.",
                                "Sistema coleta múltiplos erros sem crash.",
                                "Posições 1-based e compatíveis com editores padrão.",
                                "Testes unitários cobrem 95% dos casos, incluindo edge-cases.",
                                "Performance não degradada em arquivos grandes."
                              ],
                              "assessmentCriteria": [
                                "Precisão das posições reportadas (100% match com manual).",
                                "Clareza e legibilidade do formato de relatório.",
                                "Capacidade de lidar com múltiplos erros sequenciais.",
                                "Robustez contra caracteres especiais (tabs, UTF-8).",
                                "Integração seamless no fluxo do lexer sem interrupções.",
                                "Documentação de uso e exemplos no código."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Cálculo de índices e contadores lineares.",
                                "Programação Geral: Manipulação de streams e estados finitos.",
                                "Desenvolvimento de Software: Boas práticas de logging e error-handling.",
                                "Análise de Dados: Parsing e extração de posições em textos."
                              ],
                              "realWorldApplication": "Compiladores profissionais como GCC/Clang usam isso para diagnostics precisos em IDEs (VS Code, IntelliJ), permitindo desenvolvedores jump-to-error instantaneamente, acelerando depuração em projetos grandes."
                            },
                            "estimatedTime": "0.5 hora",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.6.2.3",
                            "name": "Evitar inundação de mensagens de erro",
                            "description": "Implementar mecanismos como limite de erros por linha ou supressão temporária para prevenir excesso de relatórios em códigos com múltiplos erros consecutivos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o Problema de Inundação de Erros em Análise Léxica",
                                  "subSteps": [
                                    "Analise exemplos de código fonte com múltiplos erros léxicos consecutivos em uma mesma linha.",
                                    "Execute um lexer básico sem limitações e observe o volume excessivo de mensagens de erro no console.",
                                    "Registre o impacto: tempo de processamento aumentado, dificuldade de debugging para o usuário.",
                                    "Pesquise práticas padrão em compiladores reais (ex: GCC --max-errors).",
                                    "Documente métricas como número de erros reportados vs. totais encontrados."
                                  ],
                                  "verification": "Criar um relatório curto listando pelo menos 3 exemplos de inundação observados e seus impactos.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Lexer básico em Python ou C",
                                    "Exemplos de código com 10+ erros consecutivos",
                                    "Editor de texto"
                                  ],
                                  "tips": "Use inputs artificiais com erros repetidos para simular cenários reais rapidamente.",
                                  "learningObjective": "Identificar e quantificar os efeitos negativos da inundação de erros no fluxo de desenvolvimento.",
                                  "commonMistakes": [
                                    "Ignorar o impacto no usuário final",
                                    "Focar apenas em performance sem considerar UX",
                                    "Não registrar métricas quantitativas"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Projetar Mecanismos de Limitação e Supressão",
                                  "subSteps": [
                                    "Defina estratégias: limite de erros por linha (ex: max 5 por linha) ou supressão temporária após threshold.",
                                    "Crie variáveis de controle: contador por linha, flag de supressão global ou por linha.",
                                    "Esboce fluxograma: detectar mudança de linha, resetar contador, reportar ou suprimir.",
                                    "Decida mensagem de supressão: 'Suprimidos X erros adicionais nesta linha'.",
                                    "Avalie trade-offs: precisão vs. usabilidade."
                                  ],
                                  "verification": "Desenhar um fluxograma ou pseudocódigo que cubra detecção de linha e limitação.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Papel e caneta ou ferramenta de diagrama (Draw.io)",
                                    "Documentação de linguagens de lexer (Flex, ANTLR)"
                                  ],
                                  "tips": "Comece com limite simples por linha antes de adicionar supressão global para facilitar testes.",
                                  "learningObjective": "Projetar soluções escaláveis para controle de saída de erros em analisadores.",
                                  "commonMistakes": [
                                    "Definir limites muito altos (ineficaz)",
                                    "Não resetar contadores ao mudar de linha",
                                    "Esquecer mensagem informativa de supressão"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar o Mecanismo no Lexer",
                                  "subSteps": [
                                    "Adicione variáveis: errorCountPerLine, maxErrorsPerLine = 5, suppressionActive.",
                                    "Modifique a função de relatório de erro: incrementar contador, checar limite, suprimir se excedido.",
                                    "Integre detecção de nova linha no lexer para resetar contador.",
                                    "Implemente mensagem de supressão única por linha.",
                                    "Refatore código para manter legibilidade (ex: função helper handleError)."
                                  ],
                                  "verification": "Executar lexer modificado em input com 10 erros consecutivos e confirmar <=5 mensagens + supressão.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Código fonte do lexer",
                                    "IDE com debugger",
                                    "Testes unitários para lexer"
                                  ],
                                  "tips": "Use logging condicional para debugar contadores sem poluir output.",
                                  "learningObjective": "Integrar lógica de controle de erros diretamente no ciclo de tokenização.",
                                  "commonMistakes": [
                                    "Não tratar erros em linhas vazias ou fim de arquivo",
                                    "Contador não reseta corretamente",
                                    "Supressão aplicada globalmente em vez de por linha"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Testar, Validar e Refinar a Implementação",
                                  "subSteps": [
                                    "Crie suíte de testes: 1 erro (reporta), 5 erros (reporta todos), 10 erros (5 + supressão), múltiplas linhas.",
                                    "Meça performance: tempo de execução e legibilidade do output.",
                                    "Colete feedback simulado: 'Output agora é gerenciável'.",
                                    "Ajuste parâmetros (ex: tornar maxErrors configurável via flag).",
                                    "Documente a feature no README do lexer."
                                  ],
                                  "verification": "Todos testes passam com output controlado; nenhum crash ou relatório excessivo.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Framework de testes (pytest, unittest)",
                                    "Inputs de teste variados",
                                    "Timer para performance"
                                  ],
                                  "tips": "Automatize contagem de mensagens de erro nos testes para validação objetiva.",
                                  "learningObjective": "Garantir robustez da solução através de testes abrangentes e iterações.",
                                  "commonMistakes": [
                                    "Testes insuficientes para bordas (ex: exatamente max erros)",
                                    "Ignorar performance em arquivos grandes",
                                    "Não documentar configuração"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um lexer para uma linguagem simples como MiniPython, modifique para que ao escanear 'int x = abc def ghi jkl;' (5 tokens inválidos), reporte apenas os primeiros 3 erros ('Token inválido: abc', 'def', 'ghi') seguido de 'Suprimidos 2 erros adicionais nesta linha.', melhorando drasticamente a usabilidade.",
                              "finalVerifications": [
                                "Lexer reporta no máximo 5 erros por linha em inputs com excesso.",
                                "Mensagem de supressão aparece exatamente uma vez por linha excedida.",
                                "Contadores resetam corretamente ao detectar nova linha ou EOF.",
                                "Performance não degrada >10% em arquivos com 1000+ erros.",
                                "Configuração de limite é ajustável via parâmetro de linha de comando.",
                                "Testes unitários cobrem 100% dos casos de limite e supressão."
                              ],
                              "assessmentCriteria": [
                                "Precisão: Supressão ativa apenas após threshold, sem falsos positivos.",
                                "Usabilidade: Output legível, com mensagens claras de supressão.",
                                "Robustez: Lida com bordas como linhas vazias, múltiplas supressões.",
                                "Eficiência: O(1) overhead por token no ciclo de lexema.",
                                "Manutenibilidade: Código modular, bem comentado e testado.",
                                "Flexibilidade: Limites configuráveis sem recompilação."
                              ],
                              "crossCurricularConnections": [
                                "Engenharia de Software: Práticas de logging e error handling (SWE principles).",
                                "Design de UX/UI: Princípios de sobrecarga cognitiva e feedback conciso.",
                                "Matemática Discreta: Contadores e estados finitos em autômatos.",
                                "Análise de Algoritmos: Otimização de saída em processadores de texto."
                              ],
                              "realWorldApplication": "Em IDEs como Visual Studio Code ou compiladores como Clang/GCC (opção -Werror-max ou max-errors), previne overwhelm do desenvolvedor em código legacy com centenas de warnings, acelerando ciclos de correção e melhorando produtividade em equipes."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.1.6.3",
                        "name": "Recuperação de Erros Léxicos",
                        "description": "Estratégias para permitir que o analisador léxico continue processando o código-fonte após detectar um erro, maximizando a detecção de outros erros subsequentes.",
                        "specificSkills": [
                          {
                            "id": "10.1.1.6.3.1",
                            "name": "Aplicar deleção de caracteres inválidos",
                            "description": "Ignorar ou remover caracteres isolados inválidos e prosseguir com a leitura do próximo caractere para sincronizar o processo de tokenização.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o conceito de deleção de caracteres inválidos em análise léxica",
                                  "subSteps": [
                                    "Estude a definição de caractere inválido no contexto do seu lexer (ex: símbolos não definidos na gramática).",
                                    "Analise exemplos de entrada com erros isolados, como 'abc#def' onde '#' é inválido.",
                                    "Revise o fluxo normal de tokenização e identifique o ponto de inserção da recuperação de erro.",
                                    "Desenhe um diagrama de fluxo mostrando detecção, deleção e continuação.",
                                    "Compare com outras estratégias de recuperação, como pânico mode."
                                  ],
                                  "verification": "Crie um diagrama de fluxo anotado e explique verbalmente ou por escrito como a deleção sincroniza o processo.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Documentação do lexer, papel ou ferramenta de diagramação (ex: Draw.io), exemplos de código léxico.",
                                  "tips": "Foque em erros isolados; não confunda com sequências longas de inválidos.",
                                  "learningObjective": "Entender o papel da deleção na recuperação de sincronização léxica.",
                                  "commonMistakes": "Ignorar o impacto na sincronização futura; assumir que todos os erros são deletáveis."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar detecção de caracteres inválidos no código do lexer",
                                  "subSteps": [
                                    "Adicione uma condição no loop principal do lexer para checar se o caractere atual é inválido (usando tabela de símbolos válidos).",
                                    "Registre o caractere inválido em um log de erros para depuração.",
                                    "Mantenha o estado atual do token em construção inalterado.",
                                    "Prepare o código para pular para a deleção sem avançar o token.",
                                    "Teste unitário simples com input contendo um único inválido."
                                  ],
                                  "verification": "Execute o lexer com input inválido e confirme que detecta sem crashar, via logs ou breakpoints.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Editor de código (ex: VS Code), lexer base em Python/Java, testes unitários (ex: unittest/JUnit).",
                                  "tips": "Use switch-case ou mapa de chars válidos para detecção eficiente.",
                                  "learningObjective": "Detectar precisamente caracteres inválidos isolados no fluxo léxico.",
                                  "commonMistakes": "Detectar válidos como inválidos; não logar para depuração."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Aplicar deleção e sincronizar com o próximo caractere válido",
                                  "subSteps": [
                                    "Ao detectar inválido, avance o ponteiro de leitura sem adicionar ao token.",
                                    "Ignore o caractere deletado e continue lendo o próximo imediatamente.",
                                    "Atualize o contador de posição para refletir a deleção.",
                                    "Emita um warning de erro sem interromper o processo.",
                                    "Integre ao loop principal para transparência na tokenização subsequente."
                                  ],
                                  "verification": "Input 'abc#def' deve produzir tokens 'abc' e 'def' sem '#', com log de deleção.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Lexer com detecção implementada, exemplos de input/output esperados, debugger.",
                                  "tips": "Garanta que a deleção seja atômica: delete e leia próximo na mesma iteração.",
                                  "learningObjective": "Implementar deleção que mantém a sincronização do lexer.",
                                  "commonMistakes": "Avançar múltiplos chars acidentalmente; falhar em sincronizar estados."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Testar e validar a implementação completa de deleção",
                                  "subSteps": [
                                    "Crie suíte de testes com múltiplos inválidos isolados (ex: 'a#b@c d').",
                                    "Verifique saída de tokens e logs de erros contra esperados.",
                                    "Teste casos edge: inválido no início, fim, ou adjacente a delimitadores.",
                                    "Meça performance para garantir que não degrade o lexer normal.",
                                    "Refatore código para legibilidade e adicione comentários."
                                  ],
                                  "verification": "Todos testes passam com 100% cobertura de cenários de deleção.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Framework de testes, inputs variados, comparador de tokens esperados.",
                                  "tips": "Use asserts para tokens exatos e contagem de deleções.",
                                  "learningObjective": "Validar robustez da recuperação por deleção em cenários reais.",
                                  "commonMistakes": "Não testar edges; ignorar performance em loops."
                                }
                              ],
                              "practicalExample": "Em um lexer para uma linguagem simples, input 'let x = 42@;' (onde '@' é inválido). O lexer deleta '@', loga erro, e tokeniza corretamente 'let', 'x', '=', '42', ';'. Saída: tokens válidos sem interrupção.",
                              "finalVerifications": [
                                "Lexer processa input com inválidos isolados produzindo tokens corretos subsequentes.",
                                "Logs registram exatamente os caracteres deletados e posições.",
                                "Não há crashes ou loops infinitos em inputs malformados.",
                                "Sincronização mantém alinhamento com gramática (ex: delimitadores reconhecidos).",
                                "Performance similar a lexer sem erros (teste com benchmark).",
                                "Cobertura de testes >90% para rotas de deleção."
                              ],
                              "assessmentCriteria": [
                                "Precisão na detecção: 100% taxa de acerto em inválidos isolados.",
                                "Corretude da sincronização: tokens pós-deleção idênticos ao input limpo.",
                                "Eficiência: O(1) por caractere deletado, sem overhead significativo.",
                                "Robustez: Lida com 0-10 inválidos consecutivos sem falha.",
                                "Documentação: Código comentado e testes autoexplicativos.",
                                "Limpeza: Sem side-effects em estados do lexer."
                              ],
                              "crossCurricularConnections": [
                                "Algoritmos: Conceitos de parsing e recuperação de erros em autômatos finitos.",
                                "Programação: Tratamento de exceções e robustez em fluxos de I/O.",
                                "Engenharia de Software: Estratégias de error handling e logging.",
                                "Lógica Matemática: Estados de máquina e transições de erro."
                              ],
                              "realWorldApplication": "Em compiladores como GCC/Clang, editores de código (VS Code syntax highlighting), ou parsers de JSON/XML, onde deleção de chars inválidos permite edição contínua sem crash, melhorando UX em cenários de digitação rápida ou dados corruptos."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.6.3.2",
                            "name": "Implementar inserção de tokens faltantes",
                            "description": "Inserir automaticamente delimitadores ou tokens esperados, como ponto-e-vírgula ausente, baseado em heurísticas simples para recuperar o fluxo.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Identificar cenários comuns de tokens faltantes em análise léxica",
                                  "subSteps": [
                                    "Analise o gramática da linguagem alvo para listar tokens esperados, como ponto-e-vírgula após declarações ou chaves em blocos.",
                                    "Estude exemplos de código inválido onde tokens como ';' ou '{' estão ausentes, impactando o fluxo de tokens.",
                                    "Classifique erros por contexto: fim de declaração, início de bloco, separadores de argumentos.",
                                    "Documente padrões heurísticos iniciais, como 'inserir ; se próximo token for identifier ou keyword de declaração'.",
                                    "Crie um diagrama de fluxo para detecção de contexto atual no lexer."
                                  ],
                                  "verification": "Lista de 5+ cenários documentados com exemplos de código inválido e tokens esperados.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Documentação da gramática da linguagem (ex: EBNF), editor de texto, exemplos de código fonte.",
                                  "tips": "Comece com linguagens simples como mini-C para focar em ; e {}",
                                  "learningObjective": "Compreender contextos onde tokens faltantes quebram o lexer e definir heurísticas básicas.",
                                  "commonMistakes": "Ignorar contextos aninhados como em loops ou condicionais."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Definir heurísticas simples para detecção e inserção automática",
                                  "subSteps": [
                                    "Defina regras baseadas em lookahead: verifique próximo token após EOF de declaração.",
                                    "Implemente heurística para ; : inserir se token atual é keyword (if, while) ou identifier seguido de = ou (",
                                    "Crie regras para { : inserir antes de statements após control flow keywords.",
                                    "Adicione limite de inserções por erro para evitar loops infinitos (ex: max 3 por linha).",
                                    "Teste regras manualmente em snippets de código com erros simulados."
                                  ],
                                  "verification": "Conjunto de 10 regras heurísticas testadas manualmente com snippets, 80% acurácia.",
                                  "estimatedTime": "1 hora",
                                  "materials": "Papel e caneta para pseudocódigo, snippets de código inválido, calculadora para contar lookaheads.",
                                  "tips": "Use estados finitos (FSM) para rastrear contexto atual no lexer.",
                                  "learningObjective": "Criar regras acionáveis que detectem e proponham inserções sem alterar semântica.",
                                  "commonMistakes": "Regras muito genéricas que inserem tokens em locais errados, como dentro de strings."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar lógica de inserção no código do analisador léxico",
                                  "subSteps": [
                                    "Modifique o lexer para incluir um buffer de lookahead (1-2 tokens).",
                                    "Adicione função checkMissingToken() que aplica heurísticas e retorna token a inserir se necessário.",
                                    "Integre no loop principal: após retornar token, verifique e insira se match heurística.",
                                    "Registre inserções em log de erros para depuração (ex: 'Inserido ; na linha 42').",
                                    "Ajuste estado do lexer para pular whitespace após inserção simulada."
                                  ],
                                  "verification": "Código do lexer modificado compila e insere token corretamente em teste unitário simples.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": "Código base do lexer (ex: em Python ou Flex), IDE com debugger, testes unitários framework (pytest).",
                                  "tips": "Implemente como função separada para facilitar testes e refatoração.",
                                  "learningObjective": "Integrar recuperação de erros no fluxo do lexer sem quebrar análise normal.",
                                  "commonMistakes": "Não resetar lookahead após inserção, causando cascata de erros."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Testar e refinar a implementação com casos de erro reais",
                                  "subSteps": [
                                    "Crie suíte de testes: 20+ arquivos com erros faltantes variados (simples, aninhados, múltiplos).",
                                    "Execute lexer e verifique se fluxo continua após inserção (parsing subsequente OK).",
                                    "Meça taxa de recuperação: % de códigos inválidos que viram válidos pós-inserção.",
                                    "Analise falsos positivos/negativos e ajuste heurísticas (threshold >85%).",
                                    "Documente limitações e sugestões para heurísticas avançadas (ML-based)."
                                  ],
                                  "verification": "Relatório de testes com >85% recuperação em 20 casos, código atualizado.",
                                  "estimatedTime": "1 hora",
                                  "materials": "Arquivos de teste, script de automação de testes, ferramentas de diff para comparar tokens.",
                                  "tips": "Priorize testes edge-case como código vazio ou só erros.",
                                  "learningObjective": "Validar robustez da recuperação iterativamente.",
                                  "commonMistakes": "Testes insuficientes em contextos aninhados, subestimando complexidade."
                                }
                              ],
                              "practicalExample": "Em um lexer para mini-C, código inválido: 'int x = 5 if (x>0) {'. Heurística detecta fim de declaração após '=' e próximo 'if', insere ';' após '5', resultando em tokens: int, identifier(x), =, 5, ;, if, (, x, >, 0, ), { . Fluxo recupera sem parar.",
                              "finalVerifications": [
                                "Lexer insere token corretamente em 85%+ dos casos testados sem alterar tokens válidos.",
                                "Log de erros registra todas inserções com linha e token inserido.",
                                "Análise subsequente (parsing) prossegue após recuperação.",
                                "Não há loops infinitos ou inserções excessivas (>3 por erro).",
                                "Testes unitários passam para cenários comuns e edge-cases.",
                                "Desempenho do lexer degradado <10% com recuperação ativada."
                              ],
                              "assessmentCriteria": [
                                "Precisão das heurísticas: >80% acerto em inserções corretas.",
                                "Robustez: Recupera fluxo em 90% dos casos sem crash.",
                                "Eficiência: Tempo de execução similar ao lexer sem erros.",
                                "Manutenibilidade: Código modular com funções isoladas.",
                                "Documentação: Comentários e log claro para depuração.",
                                "Escalabilidade: Fácil adicionar novas heurísticas."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Autômatos finitos e expressões regulares para modelar heurísticas.",
                                "Inteligência Artificial: Heurísticas como precursor de regras em sistemas especialistas.",
                                "Engenharia de Software: Tratamento de exceções e robustez em parsers.",
                                "Linguística Computacional: Recuperação de erros similar a correção ortográfica."
                              ],
                              "realWorldApplication": "Em compiladores como GCC/Clang para sugestões automáticas de ; em C/C++, IDEs como VSCode IntelliSense para auto-correção em tempo real, e linters como ESLint para JavaScript que propõem inserções de tokens faltantes melhorando produtividade de desenvolvedores."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.6.3.3",
                            "name": "Usar modo pânico com sincronização",
                            "description": "Pular caracteres até encontrar um delimitador válido como ';', '}' ou nova linha, permitindo recuperação rápida em erros extensos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o Conceito de Modo Pânico com Sincronização",
                                  "subSteps": [
                                    "Estude a definição: modo pânico pula tokens inválidos até um delimitador de sincronização como ';', '}' ou '\\n'.",
                                    "Analise cenários de erro extenso em análise léxica, como código com texto aleatório.",
                                    "Compare com outros métodos de recuperação, como skip de um token apenas.",
                                    "Identifique vantagens: recuperação rápida sem parar o parsing inteiro.",
                                    "Desenhe um fluxograma simples do processo de pânico."
                                  ],
                                  "verification": "Crie um diagrama ou resumo explicando quando e por quê usar modo pânico.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Documentação de compiladores (ex: Dragon Book capítulo sobre análise léxica), papel e caneta ou ferramenta de diagrama como Draw.io.",
                                  "tips": "Foque em exemplos reais de código quebrado para visualizar o impacto.",
                                  "learningObjective": "Explicar o propósito e mecanismo do modo pânico em recuperação de erros léxicos.",
                                  "commonMistakes": "Confundir com detecção de erros (modo pânico é recuperação, não detecção)."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Definir Delimitadores de Sincronização Adequados",
                                  "subSteps": [
                                    "Liste delimitadores comuns para linguagens: ';', '}', ')', '\\n', EOF.",
                                    "Considere a gramática da linguagem-alvo (ex: para C-like: '{', '}', ';').",
                                    "Priorize delimitadores que restauram sincronia sem ambiguidades.",
                                    "Crie uma tabela mapeando tipos de erro para delimitadores preferidos.",
                                    "Teste conceitualmente com snippets de código inválido."
                                  ],
                                  "verification": "Produza uma lista priorizada de 5-10 delimitadores com justificativas.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Referência da gramática da linguagem (ex: manual do C), editor de texto.",
                                  "tips": "Escolha delimitadores que aparecem frequentemente em pontos de sincronização.",
                                  "learningObjective": "Selecionar delimitadores que maximizem recuperação efetiva.",
                                  "commonMistakes": "Incluir delimitadores raros, levando a skips excessivos."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar a Função de Modo Pânico",
                                  "subSteps": [
                                    "Escreva uma função skipPanic() que leia caracteres até encontrar delimitador.",
                                    "Implemente loop: while (!isDelimiter(currentChar)) advance().",
                                    "Reporte o erro encontrado (posição, caracteres pulados).",
                                    "Retorne o próximo token válido após sincronização.",
                                    "Adicione handling para EOF para evitar loops infinitos."
                                  ],
                                  "verification": "Teste a função isoladamente com input inválido e verifique se para no delimitador correto.",
                                  "estimatedTime": "1 hora",
                                  "materials": "Editor de código (VS Code), lexer base em Python/Flex, exemplos de input com erros.",
                                  "tips": "Use logging para rastrear caracteres pulados durante desenvolvimento.",
                                  "learningObjective": "Codificar lógica robusta para pular erros até sincronização.",
                                  "commonMistakes": "Não tratar multi-line errors, causando skips parciais."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Integrar Modo Pânico ao Analisador Léxico Principal",
                                  "subSteps": [
                                    "Modifique nextToken() para chamar skipPanic() em falhas de matching.",
                                    "Defina condições de trigger: falha após N tentativas ou token inválido.",
                                    "Garanta que estado do lexer (posição, linha) seja atualizado corretamente.",
                                    "Adicione flags para modo pânico ativo e limite de erros por arquivo.",
                                    "Compile e rode testes iniciais com código válido para não quebrar funcionalidade normal."
                                  ],
                                  "verification": "Lexer processa código com erros extensos sem crash e continua parsing.",
                                  "estimatedTime": "1 hora",
                                  "materials": "Código fonte do lexer, suíte de testes com casos de erro.",
                                  "tips": "Use asserts ou unit tests para validar integração.",
                                  "learningObjective": "Incorporar recuperação de erros seamless no fluxo léxico.",
                                  "commonMistakes": "Trigger pânico prematuro em erros menores."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Testar e Otimizar a Recuperação",
                                  "subSteps": [
                                    "Crie casos de teste: erro em meio de função, falta de chaves, texto garbage.",
                                    "Meça taxa de recuperação: % de arquivos com erros que parseiam parcialmente.",
                                    "Otimize delimitadores baseados em resultados de testes.",
                                    "Analise logs para refinar reporting de erros.",
                                    "Simule workloads reais com 100+ arquivos buggy."
                                  ],
                                  "verification": "Relatório de testes mostrando >80% recuperação em cenários variados.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Framework de testes (pytest/JUnit), gerador de código buggy.",
                                  "tips": "Automatize testes para regressões.",
                                  "learningObjective": "Validar e iterar implementação para robustez.",
                                  "commonMistakes": "Testes insuficientes, ignorando edge cases como nested errors."
                                }
                              ],
                              "practicalExample": "Em um lexer para uma linguagem C-like, input: 'int main() { printf(\"hello\" texto_invalido_aqui ; return 0; }'. Ao encontrar 'texto_invalido_aqui', modo pânico pula até ';', reporta erro em linha X, coluna Y, e continua tokenizando 'return 0;' corretamente.",
                              "finalVerifications": [
                                "Lexer recupera de 90% dos erros extensos sem crash.",
                                "Posição de erro reportada é precisa (linha/coluna).",
                                "Parsing continua após sincronização com tokens corretos.",
                                "Nenhum loop infinito ou skip excessivo em inputs malformados.",
                                "Logs de erro incluem snippet do conteúdo pulado.",
                                "Desempenho não degradado em código válido (>95% velocidade original)."
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição e uso de delimitadores (30%).",
                                "Corretude da implementação de skipPanic (25%).",
                                "Integração seamless sem quebrar parsing normal (20%).",
                                "Cobertura de testes e taxa de recuperação (15%).",
                                "Qualidade de reporting de erros (10%)."
                              ],
                              "crossCurricularConnections": [
                                "Programação Defensiva: Técnicas de error handling robusto.",
                                "Engenharia de Software: Design de sistemas fault-tolerant.",
                                "Análise de Algoritmos: Otimização de loops de skipping eficientes.",
                                "UX em Ferramentas: Feedback amigável em IDEs/editors."
                              ],
                              "realWorldApplication": "Compiladores como GCC/Clang usam variantes para diagnósticos úteis em código buggy; editores como VS Code aplicam em syntax highlighting para não congelar em arquivos corrompidos."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.6.3.4",
                            "name": "Realizar substituição de tokens inválidos",
                            "description": "Substituir sequências malformadas por tokens válidos mais próximos, como converter um identificador inválido em um comentário ou palavra reservada aproximada.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Detectar e Isolar Tokens Inválidos Durante a Análise Léxica",
                                  "subSteps": [
                                    "Inicie o scanner léxico lendo caracteres da entrada fonte.",
                                    "Compare a sequência atual com todas as regras de padrões de tokens válidos (identificadores, palavras-chave, operadores, etc.).",
                                    "Identifique sequências que não correspondem a nenhum padrão válido, marcando-as como inválidas.",
                                    "Registre a posição (linha e coluna) do token inválido para relatórios de erro."
                                  ],
                                  "verification": "O scanner para em uma sequência não reconhecida e isola o token inválido sem avançar o ponteiro.",
                                  "estimatedTime": "20-25 minutos",
                                  "materials": [
                                    "Ferramenta de lexer como Flex ou JFlex",
                                    "Exemplos de código fonte com erros léxicos intencionais",
                                    "Documentação de gramáticas léxicas"
                                  ],
                                  "tips": [
                                    "Teste com entradas variadas incluindo caracteres especiais e sequências longas.",
                                    "Use logs detalhados para visualizar o matching falhado."
                                  ],
                                  "learningObjective": "Compreender e implementar detecção precisa de tokens inválidos no fluxo de análise léxica.",
                                  "commonMistakes": [
                                    "Avançar o ponteiro além do erro, perdendo contexto.",
                                    "Confundir erros léxicos com erros de parsing sintático."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar o Token Inválido e Identificar Tokens Válidos Semelhantes",
                                  "subSteps": [
                                    "Colete o conjunto de tokens válidos possíveis (palavras-chave, identificadores válidos, símbolos).",
                                    "Calcule métricas de similaridade, como distância de Levenshtein ou Jaro-Winkler, para cada token válido.",
                                    "Classifique candidatos por pontuação de similaridade, priorizando edições mínimas (inserção, deleção, substituição).",
                                    "Considere contexto local (tokens adjacentes) para refinar sugestões."
                                  ],
                                  "verification": "Gere uma lista ordenada de 3-5 tokens válidos mais próximos com pontuações de similaridade.",
                                  "estimatedTime": "30-40 minutos",
                                  "materials": [
                                    "Implementação de algoritmo de distância de edição em Python ou Java",
                                    "Lista de palavras-chave da linguagem alvo",
                                    "Ferramentas como difflib em Python"
                                  ],
                                  "tips": [
                                    "Limite candidatos a tokens comuns para eficiência.",
                                    "Pondere contexto: operadores perto de inválidos sugerem símbolos."
                                  ],
                                  "learningObjective": "Aplicar algoritmos de similaridade de strings para sugerir correções léxicas.",
                                  "commonMistakes": [
                                    "Ignorar contexto, sugerindo identificadores para operadores.",
                                    "Usar similaridade exata em vez de fuzzy matching."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Selecionar e Realizar a Substituição do Token Inválido",
                                  "subSteps": [
                                    "Escolha o token válido com maior pontuação de similaridade e compatibilidade contextual.",
                                    "Substitua a sequência inválida pela sugerida no buffer de entrada ou stream de tokens.",
                                    "Gere um relatório de erro detalhado: posição original, inválido, substituição aplicada.",
                                    "Insira o novo token na fila de saída do lexer como se fosse válido."
                                  ],
                                  "verification": "O token substituído é aceito como válido nas regras léxicas subsequentes.",
                                  "estimatedTime": "25-30 minutos",
                                  "materials": [
                                    "Editor de código com suporte a regex",
                                    "Exemplos de código antes/depois da substituição",
                                    "Templates de relatórios de erro"
                                  ],
                                  "tips": [
                                    "Sempre reporte a mudança para depuração.",
                                    "Teste substituições em loops para entradas múltiplas."
                                  ],
                                  "learningObjective": "Executar substituições seguras mantendo o fluxo de análise intacto.",
                                  "commonMistakes": [
                                    "Substituir sem relatório, ocultando erros do usuário.",
                                    "Escolher substituição sem validar sintaxe básica."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificar a Recuperação e Continuar a Análise Léxica",
                                  "subSteps": [
                                    "Prossiga o scanning a partir da posição pós-substituição.",
                                    "Compile ou parse o código modificado para detectar erros em cascata.",
                                    "Avalie se a recuperação permitiu progresso sem perda total de análise.",
                                    "Registre métricas de sucesso: taxa de recuperação e falsos positivos."
                                  ],
                                  "verification": "O lexer completa a análise do arquivo inteiro, produzindo tokens válidos majoritários.",
                                  "estimatedTime": "20-25 minutos",
                                  "materials": [
                                    "Compilador de teste ou parser simples",
                                    "Scripts de teste automatizados com casos edge"
                                  ],
                                  "tips": [
                                    "Use arquivos de teste com 10+ erros para validar robustez.",
                                    "Compare saída com lexer sem recuperação."
                                  ],
                                  "learningObjective": "Garantir que a recuperação de erros léxicos melhore a usabilidade do compilador.",
                                  "commonMistakes": [
                                    "Parar análise após primeiro erro.",
                                    "Ignorar impactos em fases posteriores como parsing."
                                  ]
                                }
                              ],
                              "practicalExample": "Em código C com 'int x@=5;', o lexer detecta 'x@' como inválido (devido a '@'), calcula similaridade (distância 1 para 'x='), substitui por 'x =', reporta 'Erro léxico na linha 1: '@' substituído por ' =' ', e continua emitindo tokens: ID('int'), ID('x'), OP('='), NUM('5').",
                              "finalVerifications": [
                                "Detecta corretamente tokens inválidos em entradas variadas.",
                                "Sugere substituições semânticas próximas com base em similaridade.",
                                "Aplica substituição sem corromper o stream de tokens subsequentes.",
                                "Gera relatórios de erro claros e posicionais.",
                                "Mantém >80% de taxa de recuperação em testes com múltiplos erros."
                              ],
                              "assessmentCriteria": [
                                "Precisão na detecção: 100% de tokens inválidos isolados.",
                                "Qualidade de sugestões: top-1 similaridade < distância 2.",
                                "Eficiência: tempo de análise < 2x sem recuperação.",
                                "Robustez: lida com edge cases como EOF ou multiline.",
                                "Usabilidade: relatórios legíveis para desenvolvedores iniciantes."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Algoritmos de distância de strings (Levenshtein, Hamming).",
                                "Processamento de Linguagem Natural: Correção ortográfica e sugestões de autocompletar.",
                                "Engenharia de Software: Tratamento de exceções e resiliência em parsers.",
                                "Inteligência Artificial: Modelos de embedding para similaridade semântica."
                              ],
                              "realWorldApplication": "Compiladores como GCC e Clang usam recuperação léxica para diagnósticos amigáveis, permitindo sugestões em IDEs como VS Code (IntelliSense) e editores online, melhorando produtividade em código com erros de digitação comuns."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      }
                    ]
                  }
                ]
              },
              {
                "id": "10.1.2",
                "name": "Análise Sintática",
                "description": "Metodologias top-down e bottom-up para verificação da estrutura gramatical do código, utilizando parsers.",
                "totalSkills": 60,
                "atomicTopics": [
                  {
                    "id": "10.1.2.1",
                    "name": "Análise Sintática Top-Down",
                    "description": "Metodologias que constroem a árvore sintática partindo do símbolo inicial para os terminais, como parsers recursivos descendentes.",
                    "individualConcepts": [
                      {
                        "id": "10.1.2.1.1",
                        "name": "Princípios da Análise Sintática Top-Down",
                        "description": "Fundamentos das metodologias top-down que constroem a árvore sintática partindo do símbolo inicial (não-terminal raiz) em direção aos terminais, utilizando previsibilidade para evitar backtracking.",
                        "specificSkills": [
                          {
                            "id": "10.1.2.1.1.1",
                            "name": "Identificar características da análise top-down",
                            "description": "Diferenciar análise sintática top-down de bottom-up, explicando como ela gera a árvore de derivação esquerda-direita a partir do símbolo inicial, com exemplos de gramáticas adequadas.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os conceitos básicos de análise sintática top-down e bottom-up",
                                  "subSteps": [
                                    "Defina análise sintática top-down como um processo que começa do símbolo inicial e expande para os terminais.",
                                    "Defina análise sintática bottom-up como um processo que começa dos terminais e reduz para o símbolo inicial.",
                                    "Identifique que top-down usa derivação esquerda-direita.",
                                    "Liste as principais diferenças em uma tabela comparativa simples.",
                                    "Revise definições de gramática livre de contexto (GLC) e árvore de derivação."
                                  ],
                                  "verification": "Crie uma tabela comparativa com pelo menos 4 diferenças chave entre top-down e bottom-up.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Livro de compiladores (ex: 'Compilers: Principles, Techniques, and Tools' - Dragon Book), papel e caneta ou editor de texto.",
                                  "tips": "Use diagramas visuais para representar o fluxo top-down (árvore crescendo para baixo) vs. bottom-up (redução ascendente).",
                                  "learningObjective": "Diferenciar conceitualmente análise top-down de bottom-up.",
                                  "commonMistakes": "Confundir derivação esquerda-direita com direita-esquerda; assumir que top-down sempre é recursivo descendente sem contexto."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Explorar o mecanismo de geração da árvore de derivação esquerda-direita em top-down",
                                  "subSteps": [
                                    "Desenhe uma árvore de derivação para uma gramática simples: S → aSb | ε, começando de S.",
                                    "Explique como cada expansão aplica a produção mais à esquerda.",
                                    "Simule o processo passo a passo para a string 'aabb'.",
                                    "Identifique o símbolo inicial e como ele guia as expansões.",
                                    "Compare com uma derivação não esquerda-direita para destacar a diferença."
                                  ],
                                  "verification": "Desenhe e rotule corretamente a árvore de derivação esquerda-direita para uma string dada.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Papel quadriculado, lápis, exemplos de gramáticas de um tutorial online de compiladores.",
                                  "tips": "Sempre comece expandindo o nó mais à esquerda para manter a ordem esquerda-direita.",
                                  "learningObjective": "Entender como top-down constrói árvores de derivação a partir do símbolo inicial.",
                                  "commonMistakes": "Expandir nós não-esquerdos primeiro; ignorar o backtracking em parsers top-down."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Diferenciar características únicas da análise top-down",
                                  "subSteps": [
                                    "Liste características top-down: preditiva, recursiva descendente, sensível ao prefixo esquerdo.",
                                    "Compare com bottom-up: shift-reduce, LR parsers, redução bottom-up.",
                                    "Discuta gramáticas adequadas: LL(k) para top-down vs. LR(k) para bottom-up.",
                                    "Simule falhas em gramáticas ambíguas ou com recursão esquerda.",
                                    "Crie um fluxograma comparativo dos processos."
                                  ],
                                  "verification": "Explique verbalmente ou por escrito 5 características exclusivas da top-down vs. bottom-up.",
                                  "estimatedTime": "50 minutos",
                                  "materials": "Ferramenta de desenho como Draw.io ou PowerPoint, exemplos de gramáticas LL(1).",
                                  "tips": "Foquem em 'predictive parsing' como força da top-down para gramáticas sem ambiguidades.",
                                  "learningObjective": "Identificar e contrastar características específicas da análise top-down.",
                                  "commonMistakes": "Achar que top-down lida bem com recursão esquerda direta; confundir com parsing preditivo simples."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar conceitos com exemplos de gramáticas adequadas",
                                  "subSteps": [
                                    "Escolha uma gramática LL(1) simples: E → T + E | T; T → id.",
                                    "Parse a string 'id + id' usando análise top-down manualmente.",
                                    "Construa a árvore de derivação e verifique se é esquerda-direita.",
                                    "Teste com uma gramática inadequada (com recursão esquerda) e observe falhas.",
                                    "Registre lições aprendidas sobre gramáticas compatíveis."
                                  ],
                                  "verification": "Parse bem-sucedido de uma string em uma gramática LL(1) com árvore correta.",
                                  "estimatedTime": "75 minutos",
                                  "materials": "Simulador de parser online (ex: JFLAP ou parser generator tools), gramáticas de exemplo.",
                                  "tips": "Construa a tabela de parsing FIRST/FOLLOW para validar a gramática LL(1).",
                                  "learningObjective": "Aplicar identificação de características em exemplos reais.",
                                  "commonMistakes": "Não calcular FIRST sets corretamente; ignorar conflitos na tabela de parsing."
                                }
                              ],
                              "practicalExample": "Para a gramática S → A | B, A → aA | a, B → b: Parse 'aab' top-down. Comece com S → A → aA → aA → aa (falha, backtrack para S → B? Não, mas ilustra predição). Use gramática LL(1) melhor: Expr → Term | Expr + Term, parse 'id + id' construindo árvore esquerda-direita de Expr.",
                              "finalVerifications": [
                                "Pode desenhar árvore de derivação esquerda-direita correta para uma gramática dada.",
                                "Lista pelo menos 4 diferenças chave entre top-down e bottom-up.",
                                "Identifica gramáticas adequadas para top-down (ex: LL(1)) vs. inadequadas.",
                                "Simula parsing top-down sem erros para string simples.",
                                "Explica o papel do símbolo inicial na geração da árvore.",
                                "Diferencia derivação esquerda-direita de outras ordens."
                              ],
                              "assessmentCriteria": [
                                "Precisão na diferenciação top-down vs. bottom-up (80% correto).",
                                "Correção na construção de árvores de derivação esquerda-direita.",
                                "Identificação correta de gramáticas LL(k) adequadas.",
                                "Explicação clara do mecanismo preditivo e backtracking.",
                                "Uso de exemplos concretos sem ambiguidades.",
                                "Profundidade na comparação de características únicas."
                              ],
                              "crossCurricularConnections": [
                                "Algoritmos e Estruturas de Dados: Árvores de parsing semelhantes a árvores de expressão.",
                                "Programação: Recursão descendente em funções parser.",
                                "Matemática Discreta: Gramáticas formais e autômatos.",
                                "Linguística Computacional: Parsing de linguagem natural top-down."
                              ],
                              "realWorldApplication": "Em compiladores como GCC ou JavaCC, parsers recursivos descendentes (top-down) são usados para linguagens como Java ou C++, identificando estrutura sintática rapidamente a partir de declarações iniciais, otimizando desenvolvimento de linguagens de programação e ferramentas de análise de código."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.1.1.2",
                            "name": "Reconhecer vantagens e limitações",
                            "description": "Listar vantagens como simplicidade de implementação e depuração fácil, e limitações como necessidade de gramáticas sem ambiguidade e sem recursão à esquerda, com exemplos de referências bibliográficas (Aho et al.).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Identificar as principais vantagens da análise sintática top-down",
                                  "subSteps": [
                                    "Leia a definição de análise top-down em fontes como Aho et al. (páginas 180-190).",
                                    "Liste as vantagens chave: simplicidade de implementação, depuração fácil devido à natureza recursiva descendente.",
                                    "Compare com análise bottom-up para destacar por que top-down é mais intuitiva.",
                                    "Anote exemplos onde simplicidade acelera o desenvolvimento de protótipos.",
                                    "Crie um diagrama mental ligando vantagens a cenários práticos."
                                  ],
                                  "verification": "Conseguir listar pelo menos 3 vantagens com explicações concisas sem consultar notas.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Livro 'Compilers: Principles, Techniques, and Tools' (Aho et al.), notas de aula sobre compiladores.",
                                  "tips": "Use bullet points para listar vantagens e associe cada uma a uma frase de exemplo.",
                                  "learningObjective": "Compreender e articular as vantagens fundamentais da análise top-down.",
                                  "commonMistakes": "Confundir simplicidade com eficiência em larga escala; sempre contextualize com bottom-up."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Reconhecer as limitações inerentes da análise top-down",
                                  "subSteps": [
                                    "Estude as restrições de gramáticas LL(k): sem ambiguidade e sem recursão à esquerda.",
                                    "Liste limitações: necessidade de reescrever gramáticas, backtracking em parsers não-preditivos.",
                                    "Analise exemplos de gramáticas com recursão à esquerda e por que falham em top-down.",
                                    "Discuta impacto na eficiência para gramáticas complexas.",
                                    "Registre referências específicas de Aho et al. sobre eliminação de recursão à esquerda."
                                  ],
                                  "verification": "Explicar verbalmente ou por escrito 3 limitações com exemplos de gramáticas problemáticas.",
                                  "estimatedTime": "50 minutos",
                                  "materials": "Capítulo 4 de Aho et al., exemplos de gramáticas online (ex: Dragon Book excerpts).",
                                  "tips": "Desenhe árvores de derivação para visualizar recursão à esquerda.",
                                  "learningObjective": "Identificar e explicar limitações técnicas da análise top-down.",
                                  "commonMistakes": "Ignorar a necessidade de gramáticas LL; teste com gramáticas reais."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Aplicar conceitos com exemplos práticos e comparações",
                                  "subSteps": [
                                    "Implemente um parser top-down simples para uma gramática LL(1), como expressões aritméticas.",
                                    "Teste com gramática ambígua e observe falhas, aplicando eliminação de recursão.",
                                    "Compare tempo de depuração top-down vs. bottom-up em um mini-projeto.",
                                    "Documente vantagens em ação (ex: código legível) e limitações (ex: reescrita necessária).",
                                    "Crie uma tabela comparativa de prós e contras."
                                  ],
                                  "verification": "Gerar um parser funcional e tabela comparativa com pelo menos 4 entradas cada.",
                                  "estimatedTime": "1 hora e 15 minutos",
                                  "materials": "Editor de código (Python ou Java), gramáticas de exemplo de Aho et al.",
                                  "tips": "Comece com gramática simples como E -> T + E | T para praticar.",
                                  "learningObjective": "Demonstrar vantagens e limitações através de implementação prática.",
                                  "commonMistakes": "Não testar com casos edge; sempre inclua gramáticas inválidas."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Sintetizar conhecimento com referências bibliográficas",
                                  "subSteps": [
                                    "Revise seções relevantes de Aho et al. e cite passagens específicas sobre top-down.",
                                    "Compile uma lista de 5 referências adicionais (artigos, capítulos).",
                                    "Escreva um resumo de 200 palavras integrando vantagens, limitações e citações.",
                                    "Discuta trade-offs em contextos reais de compiladores.",
                                    "Autoavalie o resumo contra critérios de completude."
                                  ],
                                  "verification": "Produzir resumo citando pelo menos 3 fontes com página, sem erros factuais.",
                                  "estimatedTime": "40 minutos",
                                  "materials": "Aho et al. (2ª edição), ferramentas de citação como Zotero, artigos acadêmicos sobre parsers.",
                                  "tips": "Use formato APA para citações para prática profissional.",
                                  "learningObjective": "Integrar teoria com referências acadêmicas para reconhecimento completo.",
                                  "commonMistakes": "Citar genericamente; sempre inclua página e edição."
                                }
                              ],
                              "practicalExample": "Ao desenvolver um parser para uma linguagem de configuração simples (ex: JSON-like), a análise top-down permite implementação rápida em recursão (vantagem), mas requer reescrita da gramática para eliminar recursão à esquerda em listas aninhadas (limitação), como mostrado em Aho et al., cap. 4.",
                              "finalVerifications": [
                                "Listar 4 vantagens e 4 limitações sem hesitação.",
                                "Explicar impacto de recursão à esquerda com diagrama.",
                                "Citar Aho et al. com exemplos específicos.",
                                "Comparar top-down vs. bottom-up em eficiência de depuração.",
                                "Identificar gramática LL(1) vs. não-LL(1).",
                                "Discutir quando usar top-down em projetos reais."
                              ],
                              "assessmentCriteria": [
                                "Precisão na listagem de vantagens (simplicidade, depuração).",
                                "Correta identificação de limitações (LL(k), ambiguidade).",
                                "Uso apropriado de exemplos e diagramas.",
                                "Integração de referências bibliográficas.",
                                "Profundidade em trade-offs e contextos.",
                                "Clareza na comunicação escrita/oral."
                              ],
                              "crossCurricularConnections": [
                                "Linguística: Paralelos com parsing de linguagem natural.",
                                "Matemática: Teoria de gramáticas formais e autômatos.",
                                "Engenharia de Software: Design de ferramentas de parsing em IDEs.",
                                "Algoritmos: Recursão e backtracking em estruturas de dados."
                              ],
                              "realWorldApplication": "Em compiladores de linguagens como JavaScript (parsers recursivos descendentes em V8) ou ferramentas como ANTLR, onde simplicidade acelera desenvolvimento de DSLs, mas limitações exigem pré-processamento de gramáticas para evitar ambiguidades em configurações industriais."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.1.1.3",
                            "name": "Explicar processo de construção da árvore sintática",
                            "description": "Descrever o fluxo de construção da árvore sintática em top-down, desde a expansão do símbolo inicial até a correspondência com tokens do analisador léxico.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar a gramática e o input léxico",
                                  "subSteps": [
                                    "Identifique o símbolo inicial (start symbol) da gramática, como 'S' ou 'Expr'.",
                                    "Liste todas as produções relevantes da gramática em forma de árvore de derivação.",
                                    "Obtenha a sequência de tokens do analisador léxico para a sentença de entrada.",
                                    "Inicialize um ponteiro de lookahead para o primeiro token.",
                                    "Crie um nó raiz vazio para a árvore sintática."
                                  ],
                                  "verification": "Confirme que a gramática está listada corretamente e tokens estão sequenciados sem erros.",
                                  "estimatedTime": "15-20 minutos",
                                  "materials": [
                                    "Gramática formal anotada",
                                    "Sequência de tokens de exemplo",
                                    "Papel ou editor de diagramas como Draw.io"
                                  ],
                                  "tips": [
                                    "Use uma gramática LL(1) para evitar backtracking inicial.",
                                    "Anote FIRST e FOLLOW sets se disponível para prever expansões."
                                  ],
                                  "learningObjective": "Compreender os pré-requisitos para iniciar o parsing top-down.",
                                  "commonMistakes": [
                                    "Ignorar ambiguidades na gramática.",
                                    "Confundir tokens com não-terminais.",
                                    "Não alinhar lookahead corretamente."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Expandir o símbolo inicial",
                                  "subSteps": [
                                    "Coloque o símbolo inicial como nó raiz da árvore.",
                                    "Selecione a produção apropriada baseada no lookahead (primeiro token).",
                                    "Substitua o não-terminal pelos símbolos da mão direita da produção.",
                                    "Crie nós filhos para cada símbolo na expansão.",
                                    "Atualize o ponteiro de lookahead se necessário."
                                  ],
                                  "verification": "A expansão inicial matches o lookahead e a árvore tem nós filhos corretos.",
                                  "estimatedTime": "20-25 minutos",
                                  "materials": [
                                    "Tabela de parsing preditiva (opcional)",
                                    "Diagrama de árvore em branco",
                                    "Exemplo de sentença"
                                  ],
                                  "tips": [
                                    "Priorize produções onde FIRST(α) contém o lookahead.",
                                    "Desenhe a expansão como uma derivação esquerda mais à esquerda."
                                  ],
                                  "learningObjective": "Dominar a primeira expansão recursiva do start symbol.",
                                  "commonMistakes": [
                                    "Escolher produção errada sem verificar lookahead.",
                                    "Criar nós desnecessários para terminais.",
                                    "Não expandir recursivamente quando requerido."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Processar recursivamente: Match e expansão de não-terminais",
                                  "subSteps": [
                                    "Para cada filho terminal: Match com o próximo token e avance o lookahead.",
                                    "Para cada filho não-terminal: Repita o processo de expansão recursivamente.",
                                    "Construa sub-árvores para expansões aninhadas.",
                                    "Registre erros se mismatch ocorrer (ex: token inesperado).",
                                    "Continue até todos os não-terminais serem expandidos."
                                  ],
                                  "verification": "Todos os terminais foram consumidos corretamente e árvore está parcialmente construída.",
                                  "estimatedTime": "25-30 minutos",
                                  "materials": [
                                    "Simulador de parser online (ex: JFLAP)",
                                    "Papel para rastrear lookahead",
                                    "Lista de tokens"
                                  ],
                                  "tips": [
                                    "Use pilha recursiva mental para rastrear chamadas.",
                                    "Anote o caminho de derivação para depuração."
                                  ],
                                  "learningObjective": "Executar o núcleo recursivo do parsing top-down.",
                                  "commonMistakes": [
                                    "Backtracking desnecessário em parsers preditivos.",
                                    "Match prematuro sem expansão completa.",
                                    "Perder sincronia no lookahead."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Finalizar a árvore e verificar completude",
                                  "subSteps": [
                                    "Confirme que o lookahead está no fim da entrada (EOF).",
                                    "Remova nós temporários e polir a árvore final.",
                                    "Valide que a árvore representa a sentença sem resíduos.",
                                    "Teste com variações da sentença para robustez.",
                                    "Documente a derivação completa."
                                  ],
                                  "verification": "Árvore cobre toda a sentença e lookahead é EOF.",
                                  "estimatedTime": "15-20 minutos",
                                  "materials": [
                                    "Ferramenta de visualização de árvores (ex: Graphviz)",
                                    "Exemplos de árvores corretas"
                                  ],
                                  "tips": [
                                    "Sempre valide com a sentença original derivada da árvore.",
                                    "Compare com parser bottom-up para insights."
                                  ],
                                  "learningObjective": "Garantir sucesso e correção da construção da árvore.",
                                  "commonMistakes": [
                                    "Deixar lookahead pendente.",
                                    "Árvore incompleta com não-terminais restantes.",
                                    "Ignorar erros de sincronização."
                                  ]
                                }
                              ],
                              "practicalExample": "Gramática: Expr → Term | Expr + Term; Term → id | ( Expr ). Sentença: 'id + id'. Passo 1: Raiz 'Expr'. Expansão: Expr → Expr + Term (lookahead 'id'). Match 'id' como Term. Expansão recursiva para segundo 'id'. Árvore final: Expr(no '+') com filhos Expr(id) e Term(id).",
                              "finalVerifications": [
                                "Desenhar a árvore sintática completa para uma sentença dada.",
                                "Rastrear lookahead corretamente até EOF.",
                                "Explicar cada expansão com justificativa de lookahead.",
                                "Identificar e corrigir mismatches simulados.",
                                "Derivar a sentença original da árvore construída.",
                                "Comparar com derivação manual passo a passo."
                              ],
                              "assessmentCriteria": [
                                "Precisão na seleção de produções baseada em lookahead (90%+ correto).",
                                "Completude da árvore cobrindo todos os tokens.",
                                "Correção recursiva sem loops infinitos ou backtracking inválido.",
                                "Clareza na documentação de passos e verificações.",
                                "Capacidade de lidar com gramáticas aninhadas.",
                                "Identificação de erros comuns em parsing top-down."
                              ],
                              "crossCurricularConnections": [
                                "Linguística: Análise sintática de frases naturais (árvores de parse).",
                                "Matemática: Estruturas de árvores e recursão em grafos.",
                                "Engenharia de Software: Desenvolvimento de parsers em linguagens como ANTLR.",
                                "Inteligência Artificial: Parsing em PLN para compreensão de linguagem."
                              ],
                              "realWorldApplication": "Em compiladores como GCC ou Javac, o parser top-down constrói árvores sintáticas para validar e otimizar código fonte; usado em ferramentas de IDEs para autocompletar e detecção de erros sintáticos em tempo real."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.2.1.2",
                        "name": "Parser Recursivo Descendente",
                        "description": "Implementação de um parser top-down que utiliza funções recursivas para cada não-terminal, simulando a derivação da gramática.",
                        "specificSkills": [
                          {
                            "id": "10.1.2.1.2.1",
                            "name": "Implementar função recursiva para não-terminais",
                            "description": "Escrever código para uma função recursiva que expande um não-terminal em suas produções, consumindo tokens apropriados do analisador léxico.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Definir a gramática e mapear não-terminais para funções",
                                  "subSteps": [
                                    "Identifique os não-terminais da gramática (ex: Expr, Term).",
                                    "Defina as produções para cada não-terminal em um objeto ou mapa.",
                                    "Crie funções nomeadas para cada não-terminal (ex: parseExpr, parseTerm).",
                                    "Implemente um lookahead para o próximo token do lexer.",
                                    "Estruture o gerenciador de tokens com posição atual."
                                  ],
                                  "verification": "Verifique se o mapa de produções está correto e funções vazias são criadas sem erros.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Editor de código (VS Code)",
                                    "Especificação da gramática da linguagem",
                                    "Lexer funcional"
                                  ],
                                  "tips": "Use um objeto JavaScript como { 'Expr': [productions] } para fácil acesso.",
                                  "learningObjective": "Representar gramáticas de forma programática para facilitar o parsing recursivo.",
                                  "commonMistakes": [
                                    "Definir produções com loops infinitos",
                                    "Ignorar terminais na gramática",
                                    "Não preparar lookahead"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar matching e consumo de terminais",
                                  "subSteps": [
                                    "Crie uma função auxiliar match(tokenType) que verifica e consome o token.",
                                    "Integre com o lexer para avançar a posição do stream de tokens.",
                                    "Adicione tratamento para mismatch de terminais (lançar erro).",
                                    "Teste com tokens isolados para validar consumo.",
                                    "Registre o token consumido para depuração."
                                  ],
                                  "verification": "Chame match em um stream de tokens e confirme que a posição avança corretamente.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Lexer implementado",
                                    "Stream de tokens de teste",
                                    "Console para logs"
                                  ],
                                  "tips": "Sempre verifique token atual antes de consumir para evitar erros de índice.",
                                  "learningObjective": "Gerenciar o fluxo de tokens de forma segura durante o parsing.",
                                  "commonMistakes": [
                                    "Consumir token sem verificar tipo",
                                    "Não avançar posição do lexer",
                                    "Ignorar fim do input"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar escolha de produção com lookahead",
                                  "subSteps": [
                                    "Para cada não-terminal, examine o próximo token para selecionar produção.",
                                    "Defina regras de FIRST sets para cada produção.",
                                    "Implemente lógica if/else ou switch para escolher e executar a produção.",
                                    "Execute a sequência de símbolos da produção escolhida.",
                                    "Adicione suporte para produções vazias (epsilon)."
                                  ],
                                  "verification": "Simule parsing de uma sentença válida e confirme produção correta selecionada.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Lista de FIRST sets calculados",
                                    "Exemplos de sentenças da gramática"
                                  ],
                                  "tips": "Calcule FIRST sets manualmente para gramáticas pequenas para guiar a escolha.",
                                  "learningObjective": "Tomar decisões de parsing baseadas em lookahead para LL(1).",
                                  "commonMistakes": [
                                    "Escolha errada de produção por lookahead insuficiente",
                                    "Não tratar ambiguidades",
                                    "Produções sobrepostas não resolvidas"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Adicionar recursão e tratamento de erros",
                                  "subSteps": [
                                    "Inclua chamadas recursivas para outros não-terminais nas produções.",
                                    "Implemente sincronização de erros (ex: pular tokens até sincronização).",
                                    "Adicione backtracking simples se necessário para não-LL(1).",
                                    "Crie função de parsing principal que chama o não-terminal inicial.",
                                    "Teste com entrada inválida para validar recuperação de erros."
                                  ],
                                  "verification": "Parse uma sentença recursiva (ex: expr + expr) e confirme árvore sintática correta.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Testes unitários com sentenças válidas/inválidas",
                                    "Ferramenta de visualização de árvore sintática"
                                  ],
                                  "tips": "Use try-catch para erros e logs detalhados para depuração recursiva.",
                                  "learningObjective": "Construir parsers recursivos completos com robustez a erros.",
                                  "commonMistakes": [
                                    "Stack overflow por recursão esquerda",
                                    "Não sincronizar após erro",
                                    "Recursão infinita sem base case"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Testar e otimizar a função recursiva",
                                  "subSteps": [
                                    "Escreva testes para múltiplas produções e recursão.",
                                    "Meça performance em inputs grandes e otimize se necessário.",
                                    "Valide árvore sintática gerada contra esperada.",
                                    "Refatore código para modularidade (ex: funções auxiliares).",
                                    "Documente a função com comentários."
                                  ],
                                  "verification": "Todos os testes passam e cobertura >80%.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Framework de testes (Jest)",
                                    "Casos de teste abrangentes"
                                  ],
                                  "tips": "Comece com gramáticas simples como expressões aritméticas.",
                                  "learningObjective": "Garantir correção e eficiência do parser recursivo.",
                                  "commonMistakes": [
                                    "Testes insuficientes para bordas",
                                    "Otimização prematura",
                                    "Falta de documentação"
                                  ]
                                }
                              ],
                              "practicalExample": "Para gramática Expr → Term | Expr + Term | Expr - Term:\n\nfunction parseExpr() {\n  let node = parseTerm();\n  while (lookahead() === '+' || lookahead() === '-') {\n    let op = consume();\n    let right = parseTerm();\n    node = { type: 'BinaryOp', op, left: node, right };\n  }\n  return node;\n}",
                              "finalVerifications": [
                                "Função consome todos os tokens corretamente para sentenças válidas.",
                                "Seleciona produção certa baseada em lookahead.",
                                "Chamadas recursivas constroem árvore sintática correta.",
                                "Trata erros sem crashar o programa.",
                                "Performance aceitável para inputs médios.",
                                "Código está comentado e modular."
                              ],
                              "assessmentCriteria": [
                                "Código limpo, legível e bem indentado.",
                                "Uso correto de recursão sem loops infinitos.",
                                "Tratamento robusto de erros e sincronização.",
                                "Testes unitários com alta cobertura.",
                                "Eficiência O(n) no parsing.",
                                "Documentação clara das funções."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Conceitos de recursão e indução.",
                                "Algoritmos: Árvores e travessia recursiva.",
                                "Engenharia de Software: Design modular e testes.",
                                "Lógica: Conjuntos FIRST/FOLLOW para decisão.",
                                "Inteligência Artificial: Parsing em PLN."
                              ],
                              "realWorldApplication": "Implementado em compiladores como o de JavaScript (V8), Python (CPython) e ferramentas como ANTLR para análise sintática de linguagens de programação, scripts e DSLs."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.1.2.2",
                            "name": "Gerenciar lookahead e backtracking básico",
                            "description": "Implementar lookahead de 1 token para escolher a produção correta e tratar backtracking simples em gramáticas com recursão à esquerda limitada.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender Conceitos de Lookahead e Backtracking em Parsers Recursivos Descendentes",
                                  "subSteps": [
                                    "Estude a definição de lookahead: inspeção de 1 ou mais tokens à frente para escolher a produção correta sem backtrack.",
                                    "Analise exemplos de ambiguidades em gramáticas LL(1), como o problema 'dangling else' em if-then-else.",
                                    "Aprenda backtracking: tentar uma produção, desfazer se falhar, e tentar alternativa, útil para recursão à esquerda limitada.",
                                    "Identifique limitações: backtracking exponencial em gramáticas ruins, então limitar a casos simples.",
                                    "Compare parsers preditivos (lookahead sem backtrack) vs. backtracking parsers."
                                  ],
                                  "verification": "Escreva um resumo de 200 palavras explicando quando usar cada técnica, com um diagrama de árvore de parsing.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Capítulo sobre Análise Sintática Top-Down do Dragon Book (Compilers: Principles, Techniques, and Tools)",
                                    "Slides da aula sobre Parser Recursivo Descendente",
                                    "Exemplos de gramáticas LL(1) online"
                                  ],
                                  "tips": "Desenhe diagramas de FIRST e FOLLOW sets para visualizar escolhas de produção.",
                                  "learningObjective": "Dominar os fundamentos teóricos de lookahead e backtracking para aplicação prática em parsers.",
                                  "commonMistakes": [
                                    "Confundir lookahead com consumo de tokens (lookahead não consome)",
                                    "Subestimar custo computacional do backtracking irrestrito",
                                    "Ignorar recursão à esquerda direta, que torna RD impossível sem modificações"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar e Preparar Gramática com Recursão à Esquerda Limitada",
                                  "subSteps": [
                                    "Escolha uma gramática exemplo: stmt → if expr then stmt | if expr then stmt else stmt | assign.",
                                    "Calcule conjuntos FIRST para cada produção para identificar necessidade de lookahead.",
                                    "Identifique pontos de ambiguidade onde lookahead de 1 token resolve (ex: próximo token 'else' ou não).",
                                    "Modifique a gramática minimamente para permitir backtracking simples em casos de overlap.",
                                    "Crie tokens de teste: 'if a then b', 'if a then b else c'."
                                  ],
                                  "verification": "Liste os conjuntos FIRST/FOLLOW e marque onde lookahead é necessário; valide com 3 frases de teste.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Ferramenta online de cálculo FIRST/FOLLOW (ex: firstfollowsets.com)",
                                    "Editor de texto para gramáticas",
                                    "Lexer simples gerado previamente"
                                  ],
                                  "tips": "Use tabelas para organizar FIRST sets; foque em gramáticas com ambiguidade controlada.",
                                  "learningObjective": "Preparar uma gramática adequada para demonstrar lookahead e backtracking práticos.",
                                  "commonMistakes": [
                                    "Escolher gramáticas não LL(k) para k=1 sem simplificações",
                                    "Esquecer de tratar EOF ou outros terminais",
                                    "Não testar com input inválido cedo"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar Lookahead de 1 Token em Função Não-Terminal",
                                  "subSteps": [
                                    "Estruture a função parseStmt(): peek próximo token sem consumir.",
                                    "Se próximo token == 'else', escolha produção com else; senão, produção sem else.",
                                    "Integre com parser recursivo: chame parseExpr(), consuma 'then', recursão em parseStmt().",
                                    "Adicione salvamento de posição de token para possível backtrack futuro.",
                                    "Teste unitário com input 'if expr then stmt'."
                                  ],
                                  "verification": "Execute parser em 2 casos: com e sem 'else'; confirme árvore de parsing correta sem erros.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Linguagem de programação com suporte a classes (Python/Java)",
                                    "Lexer funcional do módulo anterior",
                                    "IDE com debugger"
                                  ],
                                  "tips": "Implemente peek() como token_stream.current sem advance(); use posição de índice para reset.",
                                  "learningObjective": "Codificar lookahead para resolução preditiva de ambiguidades em tempo linear.",
                                  "commonMistakes": [
                                    "Consumir token durante peek (use cópia ou índice)",
                                    "Não sincronizar posição após escolha errada",
                                    "Ignorar precedência em expr embutida"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Implementar e Testar Backtracking Simples para Casos Limitados",
                                  "subSteps": [
                                    "Adicione lógica de backtrack: salve estado (posição token, pilha recursão) antes de tentar produção 1.",
                                    "Se parse falhar após produção sem else, restaure estado e tente com else.",
                                    "Limite backtrack a 1 nível para evitar explosão (apenas em stmt).",
                                    "Crie casos de teste com recursão à esquerda limitada: stmt embutido falhando inicialmente.",
                                    "Depure com logs de tentativas e restaurações."
                                  ],
                                  "verification": "Parser corretamente parseia 'if a then if b then c' (dangling else resolvido) e inputs inválidos sem crash.",
                                  "estimatedTime": "75 minutos",
                                  "materials": [
                                    "Mesmos do step 3",
                                    "Casos de teste em arquivo .txt",
                                    "Ferramenta de profiling para medir backtracks"
                                  ],
                                  "tips": "Use uma classe State com posição e clone para salvamento; limite profundidade recursiva.",
                                  "learningObjective": "Integrar backtracking controlado para gramáticas não estritamente LL(1).",
                                  "commonMistakes": [
                                    "Backtrack ilimitado causando loop infinito",
                                    "Não restaurar pilha corretamente",
                                    "Excesso de salvamentos degradando performance"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Validar e Otimizar o Parser Completo",
                                  "subSteps": [
                                    "Execute suíte de testes: 10 inputs válidos/inválidos cobrindo lookahead e backtrack.",
                                    "Meça performance: conte backtracks e tempo de parsing.",
                                    "Otimize: prefira lookahead sempre que possível antes de backtrack.",
                                    "Gere árvore de sintaxe abstrata (AST) como output final.",
                                    "Documente código com comentários sobre escolhas."
                                  ],
                                  "verification": "100% pass em testes; <5 backtracks médios por parse; AST correta visualizada.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Framework de testes (unittest/pytest)",
                                    "Visualizador de AST (ex: graphviz)",
                                    "Profiler de código"
                                  ],
                                  "tips": "Priorize lookahead para eficiência; use asserts em verificações.",
                                  "learningObjective": "Garantir robustez e eficiência do parser em cenários reais.",
                                  "commonMistakes": [
                                    "Testes insuficientes para bordas",
                                    "Otimização prematura sem medição",
                                    "AST incorreta devido a backtrack mal gerenciado"
                                  ]
                                }
                              ],
                              "practicalExample": "Implemente um parser recursivo descendente para a gramática de statements: stmt → if ( expr ) then stmt | if ( expr ) then stmt else stmt | id = expr ;. Use lookahead para detectar 'else' após o primeiro stmt e backtrack se o primeiro stmt falhar em contextos com recursão à esquerda limitada, como 'if (a) then if (b) then c ;'. Teste com input: 'if (x=1) then if (y=2) then z=3 ; else w=4 ;' – lookahead escolhe produção correta sem backtrack excessivo.",
                              "finalVerifications": [
                                "Parser gera AST correta para if-then sem else.",
                                "Parser resolve dangling else usando lookahead de 1 token.",
                                "Backtrack ocorre no máximo 1 vez por stmt e restaura estado corretamente.",
                                "Inputs inválidos (ex: if sem then) falham graciosamente com mensagem de erro.",
                                "Performance: parsing de 100 statements < 1s sem explosão.",
                                "Integração com lexer: consome todos tokens até EOF."
                              ],
                              "assessmentCriteria": [
                                "Precisão: 100% de parses corretos em suíte de 20 testes.",
                                "Eficiência: Lookahead usado preferencialmente; backtracks < 2 por parse médio.",
                                "Robustez: Não crasha em inputs malformados; erros reportados com posição.",
                                "Clareza de código: Funções modulares com comentários; estado salvo explicitamente.",
                                "Documentação: Explicação de FIRST sets e pontos de backtrack.",
                                "Extensibilidade: Fácil adicionar nova produção sem quebrar lookahead."
                              ],
                              "crossCurricularConnections": [
                                "Algoritmos: Backtracking similar a busca DFS com poda em problemas de satisfação.",
                                "Lógica e Automatos: Lookahead relacionado a automatos finitos determinísticos (DFA).",
                                "Engenharia de Software: Gerenciamento de estado e undo como em editores/versão control.",
                                "Matemática Discreta: Conjuntos FIRST/FOLLOW como teoria de conjuntos e relações."
                              ],
                              "realWorldApplication": "Em compiladores como Clang ou editores como VS Code (para syntax highlighting), lookahead/backtracking permite parsing rápido de linguagens ambíguas como C++ com templates; em ferramentas de validação JSON/XML, gerencia estruturas opcionais sem parsers full bottom-up caros."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.2.1.1.1"
                            ]
                          },
                          {
                            "id": "10.1.2.1.2.3",
                            "name": "Construir árvore sintática durante parsing",
                            "description": "Modificar o parser recursivo para construir nós da árvore sintática, associando terminais e não-terminais aos respectivos filhos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Definir a estrutura de nós da árvore sintática",
                                  "subSteps": [
                                    "Crie uma classe base Node com propriedades como type (terminal ou não-terminal), value e children (lista vazia inicialmente).",
                                    "Defina subclasses para terminais (ex: TokenNode com lexema) e não-terminais (ex: NonTerminalNode com regra de produção).",
                                    "Implemente um método toString() ou printTree() para visualização hierárquica da árvore.",
                                    "Adicione um construtor que inicialize children como lista vazia.",
                                    "Teste a criação de um nó isolado manualmente."
                                  ],
                                  "verification": "Execute printTree() em um nó criado manualmente e verifique se a estrutura imprime corretamente sem erros.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Editor de código (VS Code ou similar), linguagem de programação usada no parser (ex: Python, Java), documentação de classes OOP.",
                                  "tips": "Use herança para manter código DRY; comece simples sem sobrecarregar com visitors ainda.",
                                  "learningObjective": "Compreender e implementar representações nodais para árvores sintáticas usando OOP.",
                                  "commonMistakes": "Esquecer de inicializar children como lista mutável; confundir terminais com não-terminais na type."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Modificar parsing de terminais para retornar nós",
                                  "subSteps": [
                                    "Identifique funções de parsing para tokens terminais no parser recursivo descendente.",
                                    "Altere essas funções para, em vez de só consumir o token, criar um TokenNode com o lexema atual e retorná-lo.",
                                    "Avance o lookahead ou posição no input após criar o nó.",
                                    "Teste isoladamente: parse um terminal simples e imprima o nó retornado.",
                                    "Integre com erro handling: lance exceção se token inesperado."
                                  ],
                                  "verification": "Input de um terminal isolado gera TokenNode correto com value e printTree() mostra folha.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Código fonte do parser recursivo, exemplos de input com terminais, debugger.",
                                  "tips": "Mantenha o retorno void original como fallback; use funções puras para facilitar testes unitários.",
                                  "learningObjective": "Adaptar parsing bottom-up para terminais produzindo nós folha na árvore.",
                                  "commonMistakes": "Não avançar o scanner após match; retornar None em vez de nó em casos válidos."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Modificar parsing de não-terminais para agregar filhos",
                                  "subSteps": [
                                    "Para cada regra de produção não-terminal, crie um NonTerminalNode com o nome da regra.",
                                    "Colete nós filhos das chamadas recursivas subsequentes e adicione à lista children.",
                                    "Após matching completo da regra, retorne o nó raiz da produção com filhos ordenados.",
                                    "Mantenha sincronia com lookahead para backtracking se necessário.",
                                    "Adicione logging para depurar ordem de criação de nós."
                                  ],
                                  "verification": "Parse uma produção simples (ex: Expr -> Term) retorna NonTerminalNode com filhos corretos.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Gramática de teste (ex: expressões aritméticas), unit tests framework (pytest/JUnit).",
                                  "tips": "Ordene children pela ordem de parsing; use append() em loop para agregação.",
                                  "learningObjective": "Construir subárvores compostas durante parsing recursivo descendente.",
                                  "commonMistakes": "Perder nós filhos em chamadas recursivas; inverter ordem de children."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Integrar e testar a construção completa da árvore",
                                  "subSteps": [
                                    "Modifique a função start/top-level para retornar a raiz da árvore sintática.",
                                    "Execute parser em inputs válidos e inválidos, capturando exceções.",
                                    "Visualize árvores com printTree() para múltiplos casos (simples, aninhado, ambiguidades resolvidas).",
                                    "Adicione testes unitários para árvores esperadas vs. geradas.",
                                    "Otimize memória se necessário (ex: evitar cópias desnecessárias de nós)."
                                  ],
                                  "verification": "Parser completo constrói árvore correta para input válido; printTree() matches diagrama manual.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Suite de testes, exemplos de gramáticas (aritmética, JSON-like), graphviz para visualização opcional.",
                                  "tips": "Comece com gramática mínima; use asserts em testes para shapes de árvore.",
                                  "learningObjective": "Validar end-to-end a construção de AST durante parsing recursivo.",
                                  "commonMistakes": "Árvore vazia em input válido; leaks de memória em recursão profunda."
                                }
                              ],
                              "practicalExample": "Para gramática Expr -> Expr + Term | Term; Term -> num | (Expr): Modifique parser para input '2+(3+4)' produzir árvore com raiz Expr, filho esquerdo '2', operador '+', filho direito com subárvore '(3+4)'. PrintTree(): Expr\n├── Term:2\n└── + → Expr\n    └── ( → Term → Expr\n        ├── 3\n        └── + → 4",
                              "finalVerifications": [
                                "A árvore sintática reflete fielmente a estrutura da gramática para inputs válidos.",
                                "Todos terminais têm value do lexema exato; não-terminais têm nome da regra.",
                                "Children estão na ordem de derivação esquerda-direita.",
                                "Parser rejeita inválidos sem crash, sem árvore parcial.",
                                "PrintTree() ou serialização produz output legível e hierárquico.",
                                "Profundidade da árvore matches recursão do parsing."
                              ],
                              "assessmentCriteria": [
                                "Correção: Nós e children match parse tree manual (90% casos teste).",
                                "Eficiência: Tempo de parsing O(n) sem overhead excessivo de árvore.",
                                "Robustez: Trata erros sem vazamentos ou recursão infinita.",
                                "Modularidade: Mudanças isoladas por step, código legível.",
                                "Testabilidade: 80% cobertura unitária em funções modificadas.",
                                "Extensibilidade: Fácil adicionar visitors ou walkers na árvore."
                              ],
                              "crossCurricularConnections": [
                                "Estruturas de Dados: Árvores binárias/polimórficas e traversals (pré/in/pós-ordem).",
                                "Programação Orientada a Objetos: Herança, polimorfismo em nós.",
                                "Teoria da Computação: Autômatos, gramáticas livres de contexto.",
                                "Engenharia de Software: Refatoração de parsers legados para AST.",
                                "Algoritmos: Recursão descendente vs. ascendente."
                              ],
                              "realWorldApplication": "Em compiladores como GCC/Clang/Python's ast module, ASTs são construídas durante parsing para otimização, geração de código e análise estática; ferramentas como ANTLR geram parsers com árvores sintáticas para DSLs em jogos, configs e apps web."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.2.1.1.3"
                            ]
                          },
                          {
                            "id": "10.1.2.1.2.4",
                            "name": "Tratar erros em parsers recursivos",
                            "description": "Implementar detecção e recuperação de erros sintáticos, como sincronização em tokens de sincronização, conforme técnicas de Santos e Langlois.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender detecção de erros em parsers recursivos descendentes",
                                  "subSteps": [
                                    "Estude o funcionamento padrão de um parser recursivo descendente (recursive descent parser).",
                                    "Identifique pontos onde erros sintáticos ocorrem, como falha no lookahead ou mismatch de tokens.",
                                    "Revise técnicas de Santos e Langlois para detecção: uso de FOLLOW sets e FIRST sets.",
                                    "Analise exemplos de gramáticas LL(1) com erros intencionais.",
                                    "Documente os tipos comuns de erros: unexpected token, missing token, unexpected EOF."
                                  ],
                                  "verification": "Crie um diagrama de fluxo mostrando como um erro é detectado durante a parsing de uma regra não-terminal.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Livro 'Compilers: Principles, Techniques, and Tools' (Dragon Book), capítulos sobre sintaxe",
                                    "Artigos de Santos e Langlois sobre error recovery",
                                    "Editor de texto e calculadora de FIRST/FOLLOW sets online"
                                  ],
                                  "tips": [
                                    "Comece com gramáticas simples para visualizar erros.",
                                    "Use ferramentas como ANTLR para simular parsers sem erros primeiro."
                                  ],
                                  "learningObjective": "Explicar mecanismos de detecção de erros sintáticos em parsers recursivos usando FIRST e FOLLOW sets.",
                                  "commonMistakes": [
                                    "Confundir FIRST com FOLLOW sets.",
                                    "Ignorar lookahead além de 1 token.",
                                    "Não considerar recursão esquerda."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar detecção básica de erros no código do parser",
                                  "subSteps": [
                                    "Modifique um parser recursivo existente para lançar exceções ou retornar códigos de erro em mismatches.",
                                    "Adicione funções de error reporting que registrem o token atual, esperado e posição.",
                                    "Integre uso de FOLLOW sets para prever tokens de sincronização.",
                                    "Teste com inputs inválidos e verifique se erros são reportados corretamente.",
                                    "Refatore para um handler centralizado de erros."
                                  ],
                                  "verification": "Execute o parser com 5 inputs sintaticamente incorretos e confirme que todos os erros são detectados e reportados com detalhes.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Código-fonte de um parser recursivo simples em Python ou C (ex: para expressões aritméticas)",
                                    "Lexer/tokenizer funcional",
                                    "Ambiente de desenvolvimento com debugger"
                                  ],
                                  "tips": [
                                    "Use print statements ou logging para depurar detecções.",
                                    "Mantenha o parser 'panic-mode' simples inicialmente."
                                  ],
                                  "learningObjective": "Codificar detecção de erros que identifique e reporte falhas sintáticas precisamente.",
                                  "commonMistakes": [
                                    "Parar o parsing no primeiro erro (não permitir múltiplos).",
                                    "Reportar erros vagos sem contexto.",
                                    "Modificar o lexer inadvertidamente."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Estudar e implementar sincronização em tokens de sincronização",
                                  "subSteps": [
                                    "Aprenda técnicas de recuperação: skip até token em FOLLOW set (Santos), ou Langlois' method para resync.",
                                    "Calcule FOLLOW sets para todas as não-terminais da gramática.",
                                    "Implemente lógica de skip: consuma tokens até encontrar um em FOLLOW ou sincronização global (ex: ;, }).",
                                    "Adicione suporte a tokens de sincronização como ponto-e-vírgula, chaves.",
                                    "Teste recuperação em gramáticas com erros múltiplos."
                                  ],
                                  "verification": "Parser deve recuperar de um erro e continuar parsing o resto do input corretamente, produzindo AST parcial válido.",
                                  "estimatedTime": "2.5 horas",
                                  "materials": [
                                    "Documentação de técnicas de Santos e Langlois (PDFs acadêmicos)",
                                    "Ferramenta para calcular FOLLOW sets (ex: JFLAP ou script Python)",
                                    "Exemplos de gramáticas com erros em repositórios GitHub"
                                  ],
                                  "tips": [
                                    "Defina um conjunto global de sincronização para robustez.",
                                    "Limite skips para evitar loops infinitos."
                                  ],
                                  "learningObjective": "Aplicar técnicas de sincronização para recuperação local de erros sem crash do parser.",
                                  "commonMistakes": [
                                    "Skip excessivo levando a perda de código válido.",
                                    "Não usar FOLLOW corretamente, causando skips desnecessários.",
                                    "Ignorar precedência de sincronização."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Integrar, testar e otimizar o tratamento de erros",
                                  "subSteps": [
                                    "Integre detecção e recuperação em um parser completo.",
                                    "Crie suíte de testes com 10+ casos: erros isolados, múltiplos, edge cases (EOF, empty input).",
                                    "Meça eficácia: taxa de recuperação, precisão de reports.",
                                    "Otimize para performance e usabilidade (ex: sugestões de correção).",
                                    "Documente o módulo de erros no código."
                                  ],
                                  "verification": "Parser processa input com 3 erros consecutivos, recupera todos e gera AST para partes válidas com reports precisos.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Framework de testes (ex: pytest para Python)",
                                    "Inputs de teste variados",
                                    "Profiler de código"
                                  ],
                                  "tips": [
                                    "Use mutation testing para validar robustez.",
                                    "Compare com parsers profissionais como yacc/bison."
                                  ],
                                  "learningObjective": "Construir um parser recursivo robusto que lida com erros reais de forma eficiente.",
                                  "commonMistakes": [
                                    "Recuperação que introduz novos erros.",
                                    "Testes insuficientes para edge cases.",
                                    "Performance degradada por skips ineficientes."
                                  ]
                                }
                              ],
                              "practicalExample": "Em um parser para uma linguagem de expressões como '2 + a * (b + 1', implemente recuperação: ao detectar 'a' inesperado após '+', skip até ')' ou ';', reportando 'unexpected identifier, expected number', e continue parse após recuperação, produzindo AST parcial para '2 + (b + 1'.",
                              "finalVerifications": [
                                "Parser detecta e reporta erros sintáticos com token atual, esperado e linha/coluna.",
                                "Recupera de erros isolados sem crash, continuando parse.",
                                "Lida com múltiplos erros consecutivos via sincronização.",
                                "Gera AST parcial válido para código correto após erros.",
                                "FOLLOW sets calculados corretamente para a gramática usada.",
                                "Tempo de parse com erros < 2x sem erros."
                              ],
                              "assessmentCriteria": [
                                "Precisão na detecção: 100% dos erros intencionais identificados.",
                                "Eficácia da recuperação: >80% de código válido parseado pós-erro.",
                                "Qualidade dos reports: inclui contexto útil (token, posição, sugestão).",
                                "Robustez: sem crashes ou loops infinitos em inputs malformados.",
                                "Conformidade com técnicas de Santos/Langlois: uso explícito de FOLLOW e sync tokens.",
                                "Eficiência: implementação limpa, modular e comentada."
                              ],
                              "crossCurricularConnections": [
                                "Engenharia de Software: Práticas de robustez e error handling em sistemas críticos.",
                                "Linguística Computacional: Análise de estruturas sintáticas em PLN.",
                                "Matemática Discreta: Teoria de conjuntos (FIRST/FOLLOW) e autômatos.",
                                "Desenvolvimento Web: Parsers em frontend (ex: JSX, CSS selectors).",
                                "Segurança da Informação: Prevenção de ataques via inputs malformados."
                              ],
                              "realWorldApplication": "Compiladores como GCC/Clang usam recovery similar para diagnósticos úteis em IDEs (VSCode, IntelliJ), permitindo edição incremental de código com erros sem recompilação total, melhorando produtividade de desenvolvedores."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.2.1.3",
                        "name": "Parsing Predictivo LL(1)",
                        "description": "Método top-down determinístico que usa tabelas de parsing baseadas em conjuntos FIRST e FOLLOW para eliminar backtracking.",
                        "specificSkills": [
                          {
                            "id": "10.1.2.1.3.1",
                            "name": "Calcular conjuntos FIRST",
                            "description": "Computar o conjunto FIRST para símbolos e produções de uma gramática LL(1), identificando prefixos iniciais possíveis para cada não-terminal.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Identificar Componentes da Gramática",
                                  "subSteps": [
                                    "Liste todos os não-terminais (variáveis) da gramática.",
                                    "Liste todos os terminais da gramática.",
                                    "Escreva todas as produções no formato A → α, onde A é não-terminal e α é string de símbolos.",
                                    "Identifique se há produções ε (vazias) para algum não-terminal.",
                                    "Crie uma tabela inicial com colunas para cada não-terminal e suas linhas vazias para FIRST."
                                  ],
                                  "verification": "Confirme que todos os símbolos e produções estão listados corretamente sem duplicatas ou omissões.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Papel, caneta ou editor de texto; gramática de exemplo impressa ou digital.",
                                  "tips": "Use notação padrão: não-terminais em maiúsculas, terminais em minúsculas.",
                                  "learningObjective": "Compreender a estrutura da gramática LL(1) para preparar cálculo de FIRST.",
                                  "commonMistakes": "Confundir terminais com não-terminais; ignorar produções ε."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Calcular FIRST para Terminais e Símbolos Simples",
                                  "subSteps": [
                                    "Para cada terminal t, defina FIRST(t) = {t}.",
                                    "Para cada não-terminal A com produção A → tβ (onde t é terminal), adicione t a FIRST(A).",
                                    "Atualize a tabela de FIRST adicionando esses valores.",
                                    "Verifique se há propagação imediata para outros não-terminais.",
                                    "Repita até que todos os casos iniciais com terminais sejam cobertos."
                                  ],
                                  "verification": "Tabela mostra FIRST preenchida para todos terminais e produções diretas com terminais.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Tabela de FIRST em planilha ou papel; gramática anotada.",
                                  "tips": "Comece sempre pelos terminais para evitar confusão.",
                                  "learningObjective": "Aplicar regra básica de FIRST para símbolos terminais.",
                                  "commonMistakes": "Esquecer de adicionar o terminal como singleton set; não usar chaves para conjuntos."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular FIRST para Não-Terminais Compostos e Recursivos",
                                  "subSteps": [
                                    "Para produção A → Bγ, adicione FIRST(B) - {ε} a FIRST(A), se B não gera ε.",
                                    "Se B gera ε, adicione FIRST(γ) a FIRST(A), recursivamente.",
                                    "Para produções múltiplas A → α1 | α2 | ..., una os FIRST de cada αi, excluindo ε se aplicável.",
                                    "Resolva dependências circulares iterativamente até estabilização.",
                                    "Inclua ε em FIRST(A) apenas se todas as produções de A derivarem ε."
                                  ],
                                  "verification": "Todos FIRST(A) são conjuntos fechados e não mudam com iterações adicionais.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Tabela de FIRST expandida; algoritmo iterativo anotado.",
                                  "tips": "Use seta → para indicar derivação ε e marque nullable símbolos.",
                                  "learningObjective": "Dominar regras recursivas e nullable para FIRST completo.",
                                  "commonMistakes": "Incluir ε prematuramente; não unir corretamente múltiplas produções."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Validar e Finalizar Conjuntos FIRST",
                                  "subSteps": [
                                    "Verifique se FIRST são disjuntos para diferentes produções de cada não-terminal (para LL(1)).",
                                    "Confirme ausência de recursão à esquerda usando FIRST.",
                                    "Escreva os conjuntos FIRST finais para todos não-terminais.",
                                    "Teste com uma derivada de exemplo para validar prefixos.",
                                    "Documente o processo em um relatório resumido."
                                  ],
                                  "verification": "Conjuntos FIRST predizem corretamente os primeiros símbolos de strings derivadas.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Tabela final; exemplos de strings na gramática.",
                                  "tips": "Para LL(1), FIRST das alternativas devem ser disjuntas.",
                                  "learningObjective": "Garantir correção e aplicabilidade em parsing LL(1).",
                                  "commonMistakes": "Ignorar interseções que violam LL(1); erros de transcrição nos conjuntos."
                                }
                              ],
                              "practicalExample": "Gramática: S → A | a; A → ε | b. FIRST(S) = {a, b}; FIRST(A) = {ε, b}. Passos: Terminais {a}→FIRST(S), {b}→FIRST(A); nullable A adiciona ε e propaga.",
                              "finalVerifications": [
                                "Todos não-terminais têm FIRST não-vazio (exceto se só ε).",
                                "ε incluído apenas em não-terminais nullable.",
                                "Disjunto para produções alternativas de LL(1).",
                                "Teste com string derivada: primeiro símbolo em FIRST do início.",
                                "Sem ciclos infinitos no cálculo iterativo.",
                                "Conjuntos escritos como {t1, t2, ...} corretamente."
                              ],
                              "assessmentCriteria": [
                                "Precisão nos conjuntos FIRST calculados (100% match com solução).",
                                "Explicação clara das regras usadas em cada passo.",
                                "Tratamento correto de nullable e recursão.",
                                "Identificação de propriedades LL(1) via FIRST.",
                                "Eficiência no número de iterações.",
                                "Apresentação organizada da tabela final."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria de Conjuntos (união, inclusão).",
                                "Lógica: Indução e recursão em definições.",
                                "Algoritmos: Iteração até fixpoint (como Warshall).",
                                "Engenharia de Software: Análise formal de linguagens."
                              ],
                              "realWorldApplication": "Em compiladores (ex: GCC, JavaCC), calcular FIRST otimiza parsing preditivo LL(1), prevendo branches sem backtracking, essencial para análise sintática eficiente em linguagens de programação."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.2.1.1.1"
                            ]
                          },
                          {
                            "id": "10.1.2.1.3.2",
                            "name": "Calcular conjuntos FOLLOW",
                            "description": "Determinar o conjunto FOLLOW para cada não-terminal, considerando terminais que podem seguir sua ocorrência em derivações.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Inicializar os conjuntos FOLLOW",
                                  "subSteps": [
                                    "Identifique o símbolo inicial (start symbol) da gramática.",
                                    "Inicialize FOLLOW(start) com o terminal especial '$' (fim de entrada).",
                                    "Inicialize todos os outros FOLLOW(A) como conjuntos vazios para não-terminais A.",
                                    "Liste todos os não-terminais e terminais da gramática para referência.",
                                    "Crie uma tabela ou estrutura para rastrear os conjuntos FOLLOW."
                                  ],
                                  "verification": "Confirme que FOLLOW(start) contém apenas '$' e outros estão vazios.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Gramática formal anotada, papel ou editor de texto para tabelas.",
                                  "tips": "Use conjuntos como { } para representar visualmente.",
                                  "learningObjective": "Entender a inicialização padrão dos FOLLOW sets.",
                                  "commonMistakes": "Esquecer de adicionar '$' ao start symbol ou inicializar com terminais errados."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Aplicar a Regra 1: Propagação de terminais imediatos",
                                  "subSteps": [
                                    "Para cada produção A → α B β, onde B é não-terminal e o primeiro símbolo de β é terminal t, adicione t a FOLLOW(B).",
                                    "Examine todas as produções sequencialmente.",
                                    "Se β estiver vazio, ignore esta regra para esse caso.",
                                    "Registre adições em uma tabela de FOLLOW.",
                                    "Marque mudanças para rastrear iterações futuras."
                                  ],
                                  "verification": "Verifique se todos terminais imediatos após não-terminais foram adicionados.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Lista de produções da gramática, tabela FOLLOW inicial.",
                                  "tips": "Comece pelas produções mais simples para ganhar confiança.",
                                  "learningObjective": "Aplicar a regra básica de terminais seguintes diretos.",
                                  "commonMistakes": "Confundir não-terminais com terminais em β ou duplicar adições sem verificar."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Aplicar a Regra 2: Propagação de FOLLOW através de produções",
                                  "subSteps": [
                                    "Para cada produção A → α B, adicione todo FOLLOW(A) a FOLLOW(B).",
                                    "Para cada produção A → α B β (β não vazio), adicione FOLLOW(A) a FOLLOW(último não-terminal em β).",
                                    "Atualize a tabela FOLLOW com as uniões de conjuntos.",
                                    "Repita para todas as produções, priorizando dependências.",
                                    "Registre todas as mudanças detectadas."
                                  ],
                                  "verification": "Confirme que FOLLOW de símbolos à direita foram atualizados com FOLLOW do lado esquerdo.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Tabela FOLLOW atualizada, todas as produções.",
                                  "tips": "Use union de conjuntos (∪) explicitamente para evitar perda de elementos.",
                                  "learningObjective": "Dominar a propagação recursiva de FOLLOW sets.",
                                  "commonMistakes": "Aplicar a regra apenas para produções vazias ou ignorar o último não-terminal."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Iterar até o ponto fixo e finalizar",
                                  "subSteps": [
                                    "Repita as Regras 1 e 2 em loop até nenhuma mudança ocorrer nos conjuntos.",
                                    "Em cada iteração, verifique se houve adições novas.",
                                    "Conte o número de iterações para eficiência.",
                                    "Remova duplicatas e ordene os terminais em cada FOLLOW.",
                                    "Documente os conjuntos finais para cada não-terminal."
                                  ],
                                  "verification": "Nenhuma adição nova em uma iteração completa confirma o fixpoint.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Tabela FOLLOW iterativa, algoritmo de loop anotado.",
                                  "tips": "Limite iterações a 10 para gramáticas pequenas; use planilha para automação simples.",
                                  "learningObjective": "Garantir completude através de iteração até convergência.",
                                  "commonMistakes": "Parar prematuramente antes do fixpoint ou loops infinitos por erro de regra."
                                }
                              ],
                              "practicalExample": "Gramática: S → A | B A; A → a A | ε; B → b. Inicial: FOLLOW(S)={$}. Regra1: FOLLOW(A)←{b} de S→B A. Regra2: FOLLOW(A)←FOLLOW(S)={$}, FOLLOW(A)←{$} de S→A. Iterar: FOLLOW(B)←FOLLOW(S)={$}. Finais: FOLLOW(S)={$}, FOLLOW(A)={b,$}, FOLLOW(B)={$}.",
                              "finalVerifications": [
                                "FOLLOW(start) contém '$'.",
                                "Todos terminais imediatos estão em FOLLOW apropriados.",
                                "Propagação recursiva cobre todas as dependências.",
                                "Nenhum conjunto vazio para não-terminais usados.",
                                "Conjuntos são minimalmente fechados (fixpoint).",
                                "Sem terminais inválidos ou não-terminais em FOLLOW."
                              ],
                              "assessmentCriteria": [
                                "Precisão: Todos elementos corretos sem extras.",
                                "Completude: Inclui todos terminais possíveis.",
                                "Eficiência: Mínimas iterações necessárias.",
                                "Documentação: Tabela clara com passos.",
                                "Correção de regras: Aplicação fiel das definições.",
                                "Tratamento de ε-produções: Adequado."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria de conjuntos e fechamento transitivo.",
                                "Lógica: Inferência e propagação de relações.",
                                "Algoritmos: Iteração até fixpoint (como Warshall).",
                                "Engenharia de Software: Análise de dependências em parsers."
                              ],
                              "realWorldApplication": "Em compiladores como GCC ou Clang, conjuntos FOLLOW são cruciais para gerar tabelas de parsing LL(1) eficientes, permitindo análise sintática rápida e sem ambiguidades em linguagens de programação reais."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.2.1.3.1"
                            ]
                          },
                          {
                            "id": "10.1.2.1.3.3",
                            "name": "Construir tabela de parsing LL(1)",
                            "description": "Gerar a tabela de parsing M[A, a] preenchendo entradas baseadas em FIRST e FOLLOW, detectando conflitos não-LL(1).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar e analisar a gramática",
                                  "subSteps": [
                                    "Identifique todos os terminais (símbolos em minúsculas ou específicos) e não-terminais (maiúsculas).",
                                    "Liste todas as produções no formato A → α.",
                                    "Determine o símbolo inicial da gramática.",
                                    "Verifique se a gramática é sem left-recursion e left-factoring inicial.",
                                    "Anote possíveis produções com ε (vazio)."
                                  ],
                                  "verification": "Lista completa e correta de terminais, não-terminais, produções e símbolo inicial documentada.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Gramática fornecida",
                                    "Papel/caneta ou editor de texto",
                                    "Folha de cálculo para tabelas"
                                  ],
                                  "tips": "Use convenções padrão: não-terminais em maiúsculas, terminais em minúsculas. Desenhe a árvore de derivações se ajudar.",
                                  "learningObjective": "Compreender a estrutura formal da gramática para cálculos subsequentes.",
                                  "commonMistakes": [
                                    "Confundir terminais com não-terminais.",
                                    "Omitir produções ε ou esquecê-las."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Calcular os conjuntos FIRST",
                                  "subSteps": [
                                    "Para cada terminal t, FIRST(t) = {t}.",
                                    "Para cada não-terminal A → X1 X2 ... Xk, adicione FIRST(X1) a FIRST(A), exceto ε; se todos prefixos têm ε, inclua FIRST do próximo.",
                                    "Itere até fixpoint para produções recursivas.",
                                    "Registre FIRST(ε) = {} e FIRST(vazio) = {ε}.",
                                    "Verifique se todos os não-terminais têm FIRST calculado."
                                  ],
                                  "verification": "Conjuntos FIRST para cada não-terminal coincidem com cálculos manuais ou ferramentas padrão.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Tabela de FIRST vazia",
                                    "Lista de produções",
                                    "Calculadora para iterações"
                                  ],
                                  "tips": "Comece pelos não-terminais foliares (sem recursão). Use sets para evitar duplicatas.",
                                  "learningObjective": "Dominar o algoritmo de cálculo de FIRST para prever símbolos iniciais de sequências.",
                                  "commonMistakes": [
                                    "Não propagar ε corretamente.",
                                    "Esquecer recursão em FIRST de não-terminais."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular os conjuntos FOLLOW",
                                  "subSteps": [
                                    "FOLLOW(símbolo inicial) inclui $ (fim de entrada).",
                                    "Para A → α B β, adicione FIRST(β) a FOLLOW(B); se β deriva ε, adicione FOLLOW(A).",
                                    "Para A → α B, adicione FOLLOW(A) a FOLLOW(B).",
                                    "Itere até fixpoint para todas as produções.",
                                    "Liste FOLLOW para cada não-terminal."
                                  ],
                                  "verification": "Conjuntos FOLLOW estáveis após iterações e incluem $ corretamente.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Tabela de FOLLOW vazia",
                                    "Produções e FIRST calculados",
                                    "Marcadores para rastrear propagação"
                                  ],
                                  "tips": "Processe em ordem topológica se possível. Sempre verifique propagação de FOLLOW(A).",
                                  "learningObjective": "Aplicar o algoritmo FOLLOW para determinar contextos de não-terminais.",
                                  "commonMistakes": [
                                    "Não incluir $ no FOLLOW inicial.",
                                    "Falhar em propagar FOLLOW quando β é nullable."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Construir a tabela M[A, a] e detectar conflitos",
                                  "subSteps": [
                                    "Crie matriz com linhas = não-terminais, colunas = terminais + $.",
                                    "Para cada produção A → α: adicione A a M[A, t] para t em FIRST(α).",
                                    "Se α deriva ε, adicione A a M[A, t] para t em FOLLOW(A).",
                                    "Verifique cada célula: se >1 entrada, conflito (não-LL(1)); se vazio, ok.",
                                    "Documente conflitos e sugira resoluções."
                                  ],
                                  "verification": "Tabela completa sem erros de preenchimento e conflitos identificados corretamente.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Planilha ou tabela impressa",
                                    "FIRST e FOLLOW prontos",
                                    "Marcador para conflitos"
                                  ],
                                  "tips": "Use cores: verde para preenchido, vermelho para conflito. Valide com parser manual.",
                                  "learningObjective": "Gerar tabela de parsing LL(1) e diagnosticar gramáticas não-LL(1).",
                                  "commonMistakes": [
                                    "Preencher com FOLLOW sem checar nullable.",
                                    "Ignorar conflitos múltiplos na mesma célula."
                                  ]
                                }
                              ],
                              "practicalExample": "Gramática: E → T E' | T E' + T (simplificada). Mas exemplo LL(1): E → T E'; E' → + T E' | ε; T → id | ( E ). FIRST(E)={id,(}, FIRST(T)={id,(}, FIRST(E')={+,ε}, FOLLOW(E')={)}, FOLLOW(E)={$)}, etc. Tabela: M[E,id]=(T E'), M[E,(]=(T E'), M[E',+]=(+ T E'), M[E',)]=ε, etc. Sem conflitos.",
                              "finalVerifications": [
                                "Conjuntos FIRST e FOLLOW calculados corretamente para todos não-terminais.",
                                "Tabela M[A,a] preenchida sem omissões baseadas em FIRST e FOLLOW.",
                                "Conflitos detectados e listados com posições exatas (A,a).",
                                "Gramática classificada como LL(1) ou não-LL(1) com justificativa.",
                                "Tabela permite simulação de parsing sem ambiguidades.",
                                "Validação manual com string de teste deriva corretamente."
                              ],
                              "assessmentCriteria": [
                                "Precisão nos cálculos de FIRST e FOLLOW (100% correto).",
                                "Preenchimento completo e sem erros na tabela (sem células erradas).",
                                "Detecção precisa de conflitos (falsos positivos/negativos = 0).",
                                "Clareza na documentação (tabelas legíveis, anotações).",
                                "Eficiência no processo (tempo dentro do estimado).",
                                "Capacidade de explicar cada passo verbalmente."
                              ],
                              "crossCurricularConnections": [
                                "Teoria da Computação: Autômatos, linguagens regulares e context-free.",
                                "Programação: Implementação de parsers em linguagens como Python ou Java.",
                                "Matemática: Teoria de conjuntos, relações e algoritmos iterativos.",
                                "Engenharia de Software: Design de ferramentas de compilação e análise estática."
                              ],
                              "realWorldApplication": "Em compiladores reais como GCC, Clang ou Javac, tabelas LL(1) ou LL(k) são usadas em parsers preditivos para análise sintática rápida e eficiente de código-fonte, detectando erros de sintaxe em tempo real durante a edição em IDEs como VS Code."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.2.1.3.2"
                            ]
                          },
                          {
                            "id": "10.1.2.1.3.4",
                            "name": "Implementar parser LL(1) tabular",
                            "description": "Codificar um parser não-recursivo que consulta a tabela LL(1) para selecionar produções e construir a árvore sintática.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Definir estruturas de dados para o parser LL(1) tabular",
                                  "subSteps": [
                                    "Implemente uma tabela de parsing como um dicionário 2D (não-terminal x terminal -> produção).",
                                    "Crie classes ou estruturas para Token (tipo, valor), Pilha (stack de símbolos), Buffer de entrada (fila de tokens), e Árvore Sintática (nó com filhos).",
                                    "Defina símbolos terminais e não-terminais da gramática exemplo.",
                                    "Implemente funções auxiliares para lookup na tabela e comparação de símbolos.",
                                    "Adicione representação para epsilon (produções vazias)."
                                  ],
                                  "verification": "Execute testes unitários para verificar lookup na tabela e criação de nós da árvore.",
                                  "estimatedTime": "1-2 horas",
                                  "materials": [
                                    "Linguagem de programação (ex: Python ou Java)",
                                    "Gramática LL(1) simples (ex: expressões aritméticas)",
                                    "Editor de código e debugger"
                                  ],
                                  "tips": "Use dicionários aninhados para a tabela para acesso O(1); represente símbolos como strings ou enums.",
                                  "learningObjective": "Entender e codificar as estruturas fundamentais de um parser tabular LL(1).",
                                  "commonMistakes": [
                                    "Confundir terminais com não-terminais na tabela.",
                                    "Esquecer tratamento de epsilon.",
                                    "Não lidar com fim de entrada ($) corretamente."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Inicializar o parser e preparar a entrada",
                                  "subSteps": [
                                    "Escreva uma função para tokenizar a entrada (lexer simples para a gramática).",
                                    "Inicialize a pilha com o símbolo inicial (S) no topo.",
                                    "Carregue a tabela LL(1) pré-computada ou gere-a dinamicamente.",
                                    "Crie o buffer de tokens a partir da string de entrada, adicionando $ no final.",
                                    "Inicialize a raiz da árvore sintática."
                                  ],
                                  "verification": "Verifique se a pilha inicial está correta e tokens são gerados sem erros.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Gramática de teste: E -> T + E | T; T -> id | (E)",
                                    "Exemplos de input: 'id + id'"
                                  ],
                                  "tips": "Teste o lexer separadamente com casos edge como strings vazias ou malformadas.",
                                  "learningObjective": "Configurar o estado inicial do parser para parsing predictivo.",
                                  "commonMistakes": [
                                    "Pilha com ordem invertida (empilhar do final).",
                                    "Esquecer de adicionar $ ao buffer.",
                                    "Tokenização incorreta de operadores."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar o loop principal de parsing não-recursivo",
                                  "subSteps": [
                                    "Escreva o loop while: enquanto topo da pilha != $ e buffer não vazio.",
                                    "Se topo é terminal: match com próximo token, avance buffer se igual.",
                                    "Se topo é não-terminal: consulte tabela com (topo, próximo token), empilhe produção ou erro.",
                                    "Trate erro de parsing (panic mode simples: sincronize pulando tokens).",
                                    "Registre ações para depuração (log de pilha e buffer)."
                                  ],
                                  "verification": "Simule parsing manual de uma string simples e verifique pilha vazia no final.",
                                  "estimatedTime": "2-3 horas",
                                  "materials": [
                                    "Debugger stepwise",
                                    "Papel para simular tabela e pilha manualmente"
                                  ],
                                  "tips": "Use print statements ou logger para rastrear estado em cada iteração.",
                                  "learningObjective": "Codificar o algoritmo tabular LL(1) com seleção predictiva de produções.",
                                  "commonMistakes": [
                                    "Consultar tabela com símbolos errados.",
                                    "Não popar símbolos corretamente.",
                                    "Loop infinito em erros."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Integrar construção da árvore sintática e finalizar parser",
                                  "subSteps": [
                                    "Modifique o loop para criar nós da árvore: novo nó para não-terminal, adicione filhos da produção.",
                                    "Para terminais, crie folha na árvore.",
                                    "Após parsing bem-sucedido, retorne a árvore completa.",
                                    "Adicione função para imprimir/traversar árvore (pretty print).",
                                    "Implemente tratamento de sucesso (pilha vazia e buffer consumido)."
                                  ],
                                  "verification": "Parse input válido e visualize árvore gerada.",
                                  "estimatedTime": "1-2 horas",
                                  "materials": [
                                    "Função de visualização de árvore (ex: recursiva print)"
                                  ],
                                  "tips": "Construa árvore bottom-up durante expand, ligando filhos ao pai atual.",
                                  "learningObjective": "Construir AST durante parsing tabular LL(1).",
                                  "commonMistakes": [
                                    "Árvore com referências circulares.",
                                    "Filhos na ordem errada.",
                                    "Não criar nós para terminais."
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Testar e depurar o parser completo",
                                  "subSteps": [
                                    "Crie suíte de testes: inputs válidos, inválidos, ambiguidades resolvidas.",
                                    "Meça cobertura: árvores corretas para todos casos LL(1).",
                                    "Otimize para performance (se necessário).",
                                    "Documente o código com comentários.",
                                    "Compare saída com parser recursivo descendente."
                                  ],
                                  "verification": "100% de testes passam; árvores idênticas a manuais.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Framework de testes (ex: unittest em Python)",
                                    "Casos de teste pré-definidos"
                                  ],
                                  "tips": "Comece com gramáticas mínimas e escale complexidade.",
                                  "learningObjective": "Validar implementação através de testes abrangentes.",
                                  "commonMistakes": [
                                    "Ignorar casos de erro.",
                                    "Testes insuficientes para cobertura."
                                  ]
                                }
                              ],
                              "practicalExample": "Implemente um parser para gramática de expressões: Expr -> Term + Expr | Term; Term -> Factor * Term | Factor; Factor -> id | (Expr). Para input '(id + id) * id', a tabela LL(1) seleciona produções corretas, construindo árvore: * ( ( ) ( + id id ) id ).",
                              "finalVerifications": [
                                "Pilha fica vazia e buffer consumido após input válido.",
                                "Árvore sintática reflete estrutura hierárquica correta.",
                                "Erros de sintaxe detectados e reportados com posição.",
                                "Parsing de múltiplos inputs produz árvores consistentes.",
                                "Tempo de parsing é linear no tamanho da entrada.",
                                "Tratamento de epsilon não causa loops infinitos."
                              ],
                              "assessmentCriteria": [
                                "Corretude: parseia todos strings válidas da gramática LL(1).",
                                "Eficiência: O(n) tempo, usando tabela para lookup constante.",
                                "Robustez: lida graciosamente com erros sem crash.",
                                "Clareza: código modular com comentários e nomes descritivos.",
                                "Completo: inclui construção de AST e testes unitários.",
                                "Extensibilidade: fácil adicionar novas gramáticas."
                              ],
                              "crossCurricularConnections": [
                                "Algoritmos e Estruturas de Dados: pilhas, tabelas hash, árvores.",
                                "Matemática Discreta: autômatos, linguagens formais, FIRST/FOLLOW.",
                                "Engenharia de Software: testes unitários, depuração, modularidade.",
                                "Inteligência Artificial: parsing em PLN, árvores de decisão."
                              ],
                              "realWorldApplication": "Parsers LL(1) tabulares são usados em compiladores reais (ex: subsets de JavaScript em V8), ferramentas de análise estática (ESLint), e processadores de linguagens de configuração (JSON/YAML parsers otimizados)."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.2.1.2.1",
                              "10.1.2.1.3.3"
                            ]
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.2.2",
                    "name": "Análise Sintática Bottom-Up",
                    "description": "Metodologias que constroem a árvore sintática partindo dos terminais para o símbolo inicial, como parsers shift-reduce.",
                    "individualConcepts": [
                      {
                        "id": "10.1.2.2.1",
                        "name": "Princípios da Análise Sintática Bottom-Up",
                        "description": "Fundamentos da análise bottom-up, que constrói a árvore sintática ascendendo dos tokens terminais até o símbolo inicial da gramática, utilizando pilha para gerenciar estados de parsing.",
                        "specificSkills": [
                          {
                            "id": "10.1.2.2.1.1",
                            "name": "Diferenciar análise bottom-up de top-down",
                            "description": "Comparar as abordagens bottom-up (partindo de terminais) e top-down (partindo do símbolo inicial), identificando vantagens como eficiência em gramáticas LR e desvantagens como maior complexidade em tratamento de erros.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os Fundamentos da Análise Top-Down",
                                  "subSteps": [
                                    "Revise a definição: análise top-down inicia do símbolo inicial da gramática e aplica produções para derivar a string de entrada.",
                                    "Estude exemplos de parsers top-down como LL(1), focando em predição e recursão descendente.",
                                    "Analise como o parser top-down constrói a árvore de derivação de cima para baixo.",
                                    "Identifique limitações iniciais, como left-recursion e ambiguidade em certas gramáticas.",
                                    "Pratique com uma gramática simples, como expressões aritméticas."
                                  ],
                                  "verification": "Descreva verbalmente ou por escrito o processo de parsing top-down para uma string de entrada dada.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Livro de Compiladores (ex: Dragon Book)",
                                    "Gramáticas de exemplo em PDF ou online",
                                    "Editor de texto para simular derivações"
                                  ],
                                  "tips": [
                                    "Use diagramas de árvore para visualizar a derivação.",
                                    "Comece com gramáticas determinísticas para evitar backtracking."
                                  ],
                                  "learningObjective": "Explicar o mecanismo e fluxo da análise top-down com precisão.",
                                  "commonMistakes": [
                                    "Confundir com bottom-up invertendo o fluxo.",
                                    "Ignorar problemas de left-recursion.",
                                    "Não representar a árvore de parsing corretamente."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Compreender os Fundamentos da Análise Bottom-Up",
                                  "subSteps": [
                                    "Defina análise bottom-up: inicia dos terminais da string de entrada e reduz usando inverso de produções até o símbolo inicial.",
                                    "Explore tipos como LR(0), SLR(1), LALR(1), focando em shift-reduce e tabelas de parsing.",
                                    "Desenhe o processo de construção da alça de manipulação (handle) e reduções.",
                                    "Compare com shift-reduce conflicts e como resolvê-los.",
                                    "Simule parsing em uma gramática LR para uma entrada curta."
                                  ],
                                  "verification": "Construa uma tabela LR simples e demonstre o parsing de uma string passo a passo.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Ferramenta online como JFLAP para simular LR parsers",
                                    "Exemplos de gramáticas LR",
                                    "Papel e caneta para desenhar estados"
                                  ],
                                  "tips": [
                                    "Memorize a sequência: shift → reduce → goto.",
                                    "Use ferramentas visuais para estados do autômato."
                                  ],
                                  "learningObjective": "Dominar o mecanismo shift-reduce e identificação de handles na bottom-up.",
                                  "commonMistakes": [
                                    "Confundir reduce com shift.",
                                    "Não validar conflitos na tabela.",
                                    "Esquecer o stack na simulação."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Comparar as Duas Abordagens Diretamente",
                                  "subSteps": [
                                    "Crie uma tabela comparativa: fluxo (top-down vs bottom-up), gramáticas suportadas (LL vs LR), complexidade computacional.",
                                    "Analise uma mesma gramática e string de entrada em ambas abordagens, notando diferenças na árvore de parsing.",
                                    "Discuta quando uma falha e a outra succeeds (ex: left-recursion em top-down).",
                                    "Registre similaridades, como ambos geram árvores de sintaxe.",
                                    "Debata trade-offs iniciais em eficiência e simplicidade de implementação."
                                  ],
                                  "verification": "Preencha e explique uma tabela de comparação com pelo menos 5 critérios para uma gramática exemplo.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Planilha ou tabela em Markdown",
                                    "Mesma gramática de passos anteriores",
                                    "Vídeos curtos de parsers (YouTube)"
                                  ],
                                  "tips": [
                                    "Use a mesma entrada para fair comparison.",
                                    "Foque em métricas quantificáveis como lookahead."
                                  ],
                                  "learningObjective": "Identificar diferenças chave e quando usar cada uma.",
                                  "commonMistakes": [
                                    "Generalizar inadequadamente sem exemplos.",
                                    "Ignorar subclasses como LL(k) vs LR(k).",
                                    "Confundir árvores de parsing com derivações."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar Vantagens, Desvantagens e Aplicações",
                                  "subSteps": [
                                    "Liste vantagens top-down: simplicidade, bom para erros (backtrack fácil).",
                                    "Liste vantagens bottom-up: eficiência em LR gramáticas, trata mais linguagens naturais.",
                                    "Discuta desvantagens: top-down complexo em erros sem backtrack; bottom-up difícil debug de erros.",
                                    "Examine casos reais: top-down em mini-linguagens, bottom-up em GCC/Yacc.",
                                    "Sintetize critérios de escolha baseados em gramática e requisitos."
                                  ],
                                  "verification": "Escreva um parágrafo resumindo prós/contras e escolha para uma gramática hipotética.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Artigos sobre Yacc/Bison vs ANTLR",
                                    "Casos de estudo de compiladores reais"
                                  ],
                                  "tips": [
                                    "Quantifique eficiência (ex: O(n^3) vs O(n)).",
                                    "Considere extensibilidade."
                                  ],
                                  "learningObjective": "Avaliar trade-offs para seleção informada em projetos.",
                                  "commonMistakes": [
                                    "Superestimar simplicidade bottom-up.",
                                    "Não mencionar recuperação de erros.",
                                    "Ignorar power expressivo (LR > LL)."
                                  ]
                                }
                              ],
                              "practicalExample": "Considere a gramática S → a S b | ε. Para entrada 'aabb': Top-down (LL) prediz expansões recursivas descendente; Bottom-up (LR) faz shifts em 'a','a' então reduces para S, shifts 'b','b', reduces. Top-down falha em left-recursion se mal escrita; bottom-up lida eficientemente.",
                              "finalVerifications": [
                                "Explicar fluxo de parsing sem erros para ambas abordagens.",
                                "Identificar corretamente uma gramática como LL ou LR.",
                                "Simular parsing completo de string curta em ambas.",
                                "Listar 3 vantagens e 2 desvantagens de cada.",
                                "Escolher abordagem certa para gramática dada com justificativa.",
                                "Desenhar árvores de sintaxe equivalentes."
                              ],
                              "assessmentCriteria": [
                                "Precisão conceitual (fluxo, mecanismos): 30%",
                                "Uso correto de terminologia (handle, lookahead, shift-reduce): 20%",
                                "Qualidade de comparações e exemplos: 20%",
                                "Análise de trade-offs profundidade: 15%",
                                "Clareza em diagramas/tabelas: 10%",
                                "Aplicação a cenários reais: 5%"
                              ],
                              "crossCurricularConnections": [
                                "Engenharia de Software: Design de parsers para DSLs.",
                                "Inteligência Artificial: Parsing em PLN (NLP).",
                                "Matemática: Autômatos e linguagens formais.",
                                "Algoritmos: Complexidade em parsing ambiguo."
                              ],
                              "realWorldApplication": "Em compiladores como GCC (bottom-up LR via Bison) para eficiência em C++; ANTLR usa top-down para linguagens customizadas com recuperação de erros intuitiva em IDEs."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.2.1.2",
                            "name": "Explicar o uso da pilha em parsers bottom-up",
                            "description": "Descrever o papel da pilha para armazenar símbolos e estados, simulando o processo de shift (empilhar token) e reduce (desempilhar e aplicar produção).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o Conceito Básico da Pilha em Parsers Bottom-Up",
                                  "subSteps": [
                                    "Leia a definição de análise sintática bottom-up e identifique os componentes principais: pilha, buffer de entrada e ações de parsing.",
                                    "Estude o que a pilha armazena: símbolos gramaticais (terminais e não-terminais) e estados do autômato de parsing.",
                                    "Compare com parsers top-down para destacar a diferença: bottom-up constrói a árvore sintática de baixo para cima usando a pilha como memória.",
                                    "Desenhe um diagrama vazio da pilha e rotule os elementos que ela pode conter (estados e símbolos).",
                                    "Revise o papel da pilha em simular reduções de produções gramaticais."
                                  ],
                                  "verification": "Liste verbalmente ou por escrito os 3 principais itens armazenados na pilha e explique por quê.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Livro 'Compilers: Principles, Techniques, and Tools' (Dragon Book), capítulo sobre sintaxe",
                                    "Vídeo tutorial sobre LR parsing no YouTube",
                                    "Papel e caneta para diagramas"
                                  ],
                                  "tips": "Visualize a pilha como uma pilha de pratos: o topo é acessível para shift e reduce.",
                                  "learningObjective": "Entender o papel da pilha como repositório de símbolos parciais e estados para reconstruir a árvore sintática.",
                                  "commonMistakes": [
                                    "Confundir pilha de bottom-up com recursão em top-down",
                                    "Ignorar que estados são empilhados junto com símbolos",
                                    "Pensar que a pilha armazena apenas tokens de input"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Explorar a Operação Shift: Empilhando Tokens e Estados",
                                  "subSteps": [
                                    "Analise a ação shift: mover o próximo token do buffer para o topo da pilha, junto com o estado correspondente da tabela de parsing.",
                                    "Simule um shift manual: dado um token 'id' e estado atual 0, consulte a tabela LR para o novo estado (ex: shift para estado 5).",
                                    "Desenhe a pilha antes e depois de um shift, mostrando [estado0 símbolo estado1 token].",
                                    "Repita com 2-3 shifts consecutivos para observar o crescimento da pilha.",
                                    "Explique como o shift simula a leitura sequencial da entrada."
                                  ],
                                  "verification": "Simule um shift em um exemplo simples e desenhe a pilha resultante corretamente.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Tabela de parsing SLR(1) exemplo impressa",
                                    "Simulador online de LR parser (ex: JFLAP ou ferramentas web)",
                                    "Folha de exercícios com gramática simples"
                                  ],
                                  "tips": "Sempre consulte a tabela de ação/goto antes de shift para pegar o estado correto.",
                                  "learningObjective": "Dominar como shift constrói a 'fronteira direita' na pilha para futuras reduções.",
                                  "commonMistakes": [
                                    "Empilhar apenas o token sem o estado",
                                    "Shift incorreto sem tabela de parsing",
                                    "Confundir shift com lookahead excessivo"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Dominar a Operação Reduce: Desempilhando e Aplicando Produções",
                                  "subSteps": [
                                    "Estude a ação reduce: quando o topo da pilha matches o lado direito de uma produção, desempilhe os símbolos e empilhe o não-terminal com novo estado.",
                                    "Simule um reduce: para produção A → id + id, desempilhe 3 símbolos e 1 operador, empilhe 'A' e estado via tabela goto.",
                                    "Calcule o novo estado após reduce usando a tabela goto do estado exposto após desempilhar.",
                                    "Diferencie reduce de shift: reduce 'reconstrói' estruturas maiores.",
                                    "Pratique com produções aninhadas para ver reduces múltiplos."
                                  ],
                                  "verification": "Execute um reduce em uma pilha simulada e confirme se o não-terminal é corretamente empilhado.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Exemplos de gramáticas LR(0)/SLR(1)",
                                    "Ferramenta online como LR Parser Generator",
                                    "Papel para simular pilha passo a passo"
                                  ],
                                  "tips": "Conte os símbolos a desempilhar exatamente como na produção para evitar erros de contagem.",
                                  "learningObjective": "Compreender como reduce aplica regras gramaticais para construir a árvore sintática bottom-up.",
                                  "commonMistakes": [
                                    "Desempilhar número errado de símbolos",
                                    "Esquecer de atualizar o estado via goto após reduce",
                                    "Aplicar reduce sem match exato no topo"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Simular um Parsing Completo e Gerenciar a Pilha",
                                  "subSteps": [
                                    "Escolha uma gramática simples (ex: expressões aritméticas) e sua tabela LR.",
                                    "Execute parsing completo de uma string: alternando shift/reduce até accept ou error.",
                                    "Registre mudanças na pilha a cada ação, destacando como ela cresce e encolhe.",
                                    "Identifique conflitos potenciais (shift/reduce) e como a pilha os resolve via lookahead.",
                                    "Reflita: como a pilha simula o processo bottom-up inteiro?"
                                  ],
                                  "verification": "Simule parsing de uma sentença completa sem erros e explique 2-3 mudanças chave na pilha.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Gramática de exemplo: E → E + T | T; T → id | (E)",
                                    "Tabela de parsing pré-construída",
                                    "Simulador de parser interativo"
                                  ],
                                  "tips": "Use setas para mostrar ações: S5=shift5, R3=reduce3.",
                                  "learningObjective": "Integrar shift e reduce em uma simulação real para ver o ciclo completo da pilha.",
                                  "commonMistakes": [
                                    "Perder o controle do estado após múltiplos reduces",
                                    "Ignorar accept quando pilha tem axioma no topo",
                                    "Confundir pilha com árvore sintática final"
                                  ]
                                }
                              ],
                              "practicalExample": "Considere a gramática E → E + T | T; T → id | (E) e a entrada 'id + id'. Inicial pilha: [0]. Shift 'id' → [0 id 5]. Shift '+' → [0 id 5 + 6]. Shift 'id' → [0 id 5 + 6 id 5]. Reduce T → id → [0 id 5 + 6 T 7]. Reduce E → E + T (desempilha + T id, mas ajustado) → [0 E 0] até accept. A pilha gerencia símbolos parciais como 'id + id' virando E.",
                              "finalVerifications": [
                                "Explicar corretamente o que shift e reduce fazem com a pilha.",
                                "Desenhar pilha em 3 estados intermediários de uma simulação.",
                                "Identificar itens armazenados: estado + símbolo.",
                                "Simular reduce para uma produção de 2 símbolos.",
                                "Diferenciar pilha bottom-up de recursão top-down.",
                                "Reconhecer accept quando axioma está no topo."
                              ],
                              "assessmentCriteria": [
                                "Precisão na descrição de shift/reduce (90% correto).",
                                "Capacidade de simular parsing manual sem erros de pilha.",
                                "Uso correto de tabela de parsing para estados.",
                                "Explicação clara do papel da pilha em bottom-up vs. top-down.",
                                "Identificação de erros comuns em simulações.",
                                "Criatividade em diagramas visuais da pilha."
                              ],
                              "crossCurricularConnections": [
                                "Estruturas de Dados: Uso avançado de Stack (LIFO) em algoritmos reais.",
                                "Teoria da Computação: Autômatos de pilha e gramáticas LR.",
                                "Matemática Discreta: Linguagens formais e árvores de derivação.",
                                "Engenharia de Software: Parsing em ferramentas como ANTLR ou Yacc/Bison."
                              ],
                              "realWorldApplication": "Em compiladores reais como GCC (C/C++) ou Javac (Java), parsers bottom-up LR usam pilhas para analisar código fonte eficientemente, lidando com linguagens ambíguas e gerando árvores sintáticas para otimização de código, essencial em desenvolvimento de software e IDEs."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.2.1.3",
                            "name": "Identificar conflitos shift-reduce e reduce-reduce",
                            "description": "Reconhecer e explicar conflitos em parsers bottom-up, como shift-reduce (dupla ação possível) e reduce-reduce (múltiplas produções aplicáveis), e sua relação com gramáticas não determinísticas.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Princípios Básicos do Shift-Reduce Parsing",
                                  "subSteps": [
                                    "Estude o stack e o buffer de input em um parser shift-reduce.",
                                    "Aprenda as ações: shift (empilhar símbolo), reduce (reduzir por produção), accept, error.",
                                    "Entenda o papel da tabela de parsing SLR(1) ou LALR(1) com ações shift e reduce.",
                                    "Simule um parse simples sem conflitos usando uma gramática determinística.",
                                    "Identifique estados onde apenas uma ação é possível."
                                  ],
                                  "verification": "Simule manualmente o parse de uma string simples e confirme que não há ambiguidades nas ações.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Diagrama de shift-reduce parsing",
                                    "Exemplo de gramática S → aS | ε",
                                    "Ferramenta online como JFLAP ou papel e caneta"
                                  ],
                                  "tips": "Desenhe o stack e buffer em cada passo para visualizar melhor.",
                                  "learningObjective": "Compreender o funcionamento básico do parser bottom-up para contextualizar conflitos.",
                                  "commonMistakes": [
                                    "Confundir shift com reduce prematuramente",
                                    "Ignorar o lookahead symbol"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Compreender Conflitos Shift-Reduce",
                                  "subSteps": [
                                    "Defina shift-reduce conflict: estado onde shift e reduce são ambos possíveis para o mesmo lookahead.",
                                    "Analise como gramáticas ambíguas ou não-LR(1) causam isso.",
                                    "Construa itens LR(0) para um estado com conflito.",
                                    "Exemplo: Gramática com S → A | a, A → a, identifique conflito em estado com A• e •a.",
                                    "Discuta precedência e associatividade como resoluções."
                                  ],
                                  "verification": "Identifique um shift-reduce conflict em uma gramática fornecida e explique por quê.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Gramáticas de exemplo com conflitos",
                                    "Calculadora de itens de closure",
                                    "Documentação de Yacc/Bison sobre conflitos"
                                  ],
                                  "tips": "Sempre liste ações possíveis para cada lookahead em um estado.",
                                  "learningObjective": "Reconhecer quando um parser enfrenta dilema entre shift e reduce.",
                                  "commonMistakes": [
                                    "Confundir com ambiguidades na árvore de derivação",
                                    "Não considerar o lookahead específico"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Compreender Conflitos Reduce-Reduce",
                                  "subSteps": [
                                    "Defina reduce-reduce conflict: estado onde duas ou mais reduções são possíveis para o mesmo lookahead.",
                                    "Explore gramáticas não determinísticas com múltiplas produções aplicáveis.",
                                    "Exemplo: S → A | B, A → ε, B → ε, conflito em estado vazio.",
                                    "Calcule conjuntos FOLLOW para diferenciar em SLR(1).",
                                    "Compare com shift-reduce: aqui não há shift envolvido."
                                  ],
                                  "verification": "Dada uma gramática, construa a tabela LR e aponte um reduce-reduce conflict.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Exemplos de gramáticas não-LR",
                                    "Tabela de parsing vazia para preencher",
                                    "Livro 'Compilers: Principles, Techniques, and Tools' capítulo 4"
                                  ],
                                  "tips": "Verifique múltiplas produções com ponto final no mesmo estado.",
                                  "learningObjective": "Diferenciar reduce-reduce de outros conflitos e identificá-los em itens LR.",
                                  "commonMistakes": [
                                    "Misturar com shift-reduce",
                                    "Ignorar que FOLLOW sets podem resolver em parsers mais poderosos"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Praticar Identificação e Análise de Conflitos",
                                  "subSteps": [
                                    "Selecione 3-5 gramáticas com conflitos conhecidos.",
                                    "Construa autômatos LR(0) ou SLR(1) para cada uma.",
                                    "Classifique conflitos como shift-reduce ou reduce-reduce.",
                                    "Proponha refatorações para eliminar conflitos (ex: precedência).",
                                    "Teste com ferramentas geradoras de parsers."
                                  ],
                                  "verification": "Analise uma nova gramática desconhecida e liste todos os conflitos com justificativa.",
                                  "estimatedTime": "90 minutos",
                                  "materials": [
                                    "Ferramentas como Bison/Yacc ou online LR parser generators",
                                    "Lista de gramáticas de teste",
                                    "Planilha para tabelas de parsing"
                                  ],
                                  "tips": "Comece com gramáticas pequenas para ganhar confiança.",
                                  "learningObjective": "Aplicar conceitos para diagnosticar gramáticas não determinísticas.",
                                  "commonMistakes": [
                                    "Não propagar closure corretamente",
                                    "Erros em FOLLOW sets"
                                  ]
                                }
                              ],
                              "practicalExample": "Considere a gramática: E → E + T | T, T → T * F | F, F → (E) | id. Em LALR(1), há shift-reduce em precedência de + e *. O parser em estado com E• + T e •+ deve decidir shift ou reduce E → E + T.",
                              "finalVerifications": [
                                "Construa tabela LR para gramática sem conflitos e simule parse.",
                                "Identifique shift-reduce em gramática ambígua de expressões.",
                                "Distinga reduce-reduce em gramática com produções ε vazias.",
                                "Explique relação com gramáticas não-LR(1).",
                                "Resolva conflito via %left/%right em Yacc.",
                                "Compare conflitos em SLR vs LALR."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação do tipo de conflito (shift-reduce vs reduce-reduce).",
                                "Correta construção de itens LR e tabelas de parsing.",
                                "Explicação clara da causa (lookahead, FOLLOW sets).",
                                "Proposta válida de resolução ou refatoração.",
                                "Uso correto de terminologia (bottom-up, determinístico).",
                                "Análise de exemplos reais sem erros comuns."
                              ],
                              "crossCurricularConnections": [
                                "Teoria da Computação: Autômatos pushdown e linguagens LR(k).",
                                "Algoritmos: Construção de tabelas de parsing como algoritmo de grafos.",
                                "Lógica e Prova: Demonstração de não-determinismo via conflitos.",
                                "Engenharia de Software: Design de DSLs e gramáticas LL/LR."
                              ],
                              "realWorldApplication": "Em compiladores como GCC ou ferramentas como ANTLR/Bison, identificar esses conflitos permite criar parsers eficientes para linguagens de programação, evitando erros em análise sintática de código real e otimizando performance em grandes projetos."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.2.2.2",
                        "name": "Parsers Shift-Reduce",
                        "description": "Mecanismo central dos parsers bottom-up, baseado nas ações shift (avançar entrada) e reduce (reduzir por produção da gramática).",
                        "specificSkills": [
                          {
                            "id": "10.1.2.2.2.1",
                            "name": "Simular um parser shift-reduce manualmente",
                            "description": "Executar passo a passo o parsing de uma string em uma gramática simples, registrando ações shift, reduce e accept/reject, usando pilha e entrada.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar a Gramática e a String de Entrada",
                                  "subSteps": [
                                    "Escolha uma gramática simples sem conflitos shift-reduce ou reduce-reduce, como uma gramática para expressões aritméticas.",
                                    "Identifique terminais (ex: id, +, *, $) e não-terminais (ex: E, T, F).",
                                    "Liste todas as produções da gramática explicitamente.",
                                    "Defina a string de entrada válida ou inválida, adicionando o marcador de fim $ no final.",
                                    "Desenhe uma tabela de itens LR(0) básica se necessário para guiar reduces."
                                  ],
                                  "verification": "Gramática e entrada documentadas corretamente, sem ambiguidades identificadas.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e caneta ou editor de texto",
                                    "Referência de gramáticas LR(0) simples"
                                  ],
                                  "tips": "Comece com gramáticas determinísticas para evitar conflitos iniciais.",
                                  "learningObjective": "Configurar os componentes fundamentais de um parser shift-reduce.",
                                  "commonMistakes": [
                                    "Escolher gramática ambígua",
                                    "Esquecer o marcador de fim $ na entrada"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Inicializar a Pilha e o Buffer de Entrada",
                                  "subSteps": [
                                    "Crie uma pilha vazia (ou inicie com o estado 0).",
                                    "Coloque a string de entrada no buffer, terminando com $.",
                                    "Registre o estado inicial: Pilha: [0], Entrada: [tokens da string + $].",
                                    "Verifique o símbolo de lookahead (primeiro token da entrada).",
                                    "Anote o cabeçalho da tabela de simulação com colunas para pilha, entrada, ação."
                                  ],
                                  "verification": "Pilha e buffer inicializados e registrados em uma tabela de rastreamento.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Planilha ou quadro para tabela de simulação"
                                  ],
                                  "tips": "Use símbolos numéricos para estados da pilha para facilitar rastreamento.",
                                  "learningObjective": "Entender o estado inicial do parser bottom-up.",
                                  "commonMistakes": [
                                    "Não incluir $ no buffer",
                                    "Confundir pilha com buffer"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Executar Ações Shift e Reduce Iterativamente",
                                  "subSteps": [
                                    "Examine o topo da pilha e o lookahead para decidir shift ou reduce.",
                                    "Para shift: Mova o lookahead para a pilha e avance o buffer; registre 'Shift'.",
                                    "Para reduce: Identifique a produção aplicável pelo topo da pilha, pop os símbolos, push o não-terminal e estado goto; registre 'Reduce por produção X'.",
                                    "Repita até detectar accept ou erro, atualizando a tabela a cada iteração.",
                                    "Lide com conflitos simulando tabela SLR(1) simples se necessário."
                                  ],
                                  "verification": "Tabela completa com pelo menos 5-10 iterações, todas ações corretas.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Tabela de parsing pré-construída para a gramática (opcional)"
                                  ],
                                  "tips": "Mantenha uma pilha de símbolos e estados separadamente para clareza.",
                                  "learningObjective": "Aplicar o algoritmo shift-reduce em loop com decisões precisas.",
                                  "commonMistakes": [
                                    "Shift prematuro ignorando reduce possível",
                                    "Pop incorreto no reduce"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Concluir o Parsing e Validar o Resultado",
                                  "subSteps": [
                                    "Verifique se pilha contém apenas o axioma inicial e buffer está vazio para 'Accept'.",
                                    "Se pilha tem erro ou buffer não vazio, registre 'Reject' e explique o erro.",
                                    "Revise toda a tabela para consistência em shifts/reduces.",
                                    "Teste com uma segunda string (válida e inválida) para confirmação.",
                                    "Documente o parse tree reconstruído a partir dos reduces."
                                  ],
                                  "verification": "Resultado final (accept/reject) correto com parse tree ou diagnóstico de erro.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Exemplos adicionais de strings para teste"
                                  ],
                                  "tips": "Reconstrua a árvore de parsing retrocedendo os reduces.",
                                  "learningObjective": "Interpretar o término do parsing e derivar estruturas sintáticas.",
                                  "commonMistakes": [
                                    "Aceitar parsing incompleto",
                                    "Ignorar erros de lookahead"
                                  ]
                                }
                              ],
                              "practicalExample": "Gramática: E → E + T | T; T → T * F | F; F → (E) | id. Entrada: id + id * id $. Inicie pilha [0], buffer [id, +, id, *, id, $]. Shift id → pilha [0, id, 5]; Reduce F→id → T→F → E→T; continue até pilha [0, E, $] e buffer vazio → Accept. Parse tree: E → E + T → T + T → id + (T * F) → id + (id * id).",
                              "finalVerifications": [
                                "Simulação completa gera accept para string válida e reject para inválida.",
                                "Todos reduces correspondem a produções corretas da gramática.",
                                "Pilha final contém apenas o start symbol com buffer vazio.",
                                "Tabela de rastreamento registra ações sequenciais sem lacunas.",
                                "Parse tree reconstruída matches a string de entrada.",
                                "Identificação correta de potenciais conflitos shift-reduce."
                              ],
                              "assessmentCriteria": [
                                "Precisão das ações shift/reduce em todas as iterações (100% correto).",
                                "Qualidade da tabela de simulação: clara, completa e legível.",
                                "Explicação correta de cada decisão baseada em lookahead e topo da pilha.",
                                "Reconstrução precisa do parse tree ou diagnóstico de erro.",
                                "Eficiência: simulação concluída em tempo razoável sem erros graves.",
                                "Criatividade em testar variações da entrada."
                              ],
                              "crossCurricularConnections": [
                                "Teoria da Computação: Autômatos de pilha e linguagens livres de contexto.",
                                "Programação: Implementação de parsers em linguagens como Python ou Java.",
                                "Matemática: Modelos de estados finitos e grafos de transição.",
                                "Lógica: Raciocínio dedutivo em sequências de regras de produção."
                              ],
                              "realWorldApplication": "Desenvolvimento de compiladores e interpretadores (ex: GCC, JavaCC), validação de sintaxe em IDEs como VS Code, parsing de configurações em ferramentas DevOps (JSON/YAML parsers), e processamento de linguagens de consulta em bancos de dados SQL."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.2.2.2",
                            "name": "Construir itens LR(0)",
                            "description": "Definir e calcular conjuntos de itens LR(0) para uma gramática, incluindo kernel e closure, para formar autômatos de parsing.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar a gramática aumentada e definir o kernel inicial",
                                  "subSteps": [
                                    "Escreva a gramática original com produções numeradas.",
                                    "Adicione a produção aumentada S' → .S como produção 0.",
                                    "Defina o kernel inicial I0 como {S' → .S}."
                                  ],
                                  "verification": "Confirme que a gramática está numerada corretamente e o kernel I0 contém apenas o item inicial com o ponto antes de S.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Folha com gramática original"
                                  ],
                                  "tips": "Numere as produções sequencialmente para facilitar referências durante cálculos.",
                                  "learningObjective": "Entender o papel da gramática aumentada e identificar o kernel inicial de um autômato LR(0).",
                                  "commonMistakes": [
                                    "Esquecer de adicionar a produção S' → S.",
                                    "Colocar o ponto após S no item inicial."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Calcular o closure do kernel inicial (I0)",
                                  "subSteps": [
                                    "Inclua no closure todos os itens onde o não-terminal após o ponto no kernel tem corpo ε ou inicia com não-terminais.",
                                    "Repita: para cada item [A → α.Bβ], adicione [B → .γ] para cada produção B → γ.",
                                    "Continue até que nenhum novo item seja adicionado (ponto fixo).",
                                    "Ordene os itens alfabeticamente ou por número de produção para clareza.",
                                    "Liste apenas itens com ponto antes de terminais ou fim de produção."
                                  ],
                                  "verification": "Verifique se o closure está completo comparando com todas as produções dos não-terminais expandidos; nenhum item faltante.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel quadriculado",
                                    "Lista de produções numeradas"
                                  ],
                                  "tips": "Use indentação para mostrar expansões recursivas no closure.",
                                  "learningObjective": "Dominar o algoritmo de fechamento (closure) para itens LR(0).",
                                  "commonMistakes": [
                                    "Parar cedo sem atingir ponto fixo.",
                                    "Incluir itens com ponto após terminais no closure.",
                                    "Duplicar itens idênticos."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular transições GOTO e novos kernels",
                                  "subSteps": [
                                    "Para cada símbolo X (terminal ou não-terminal) no closure de I0, compute GOTO(I0, X) = kernel de { [A → αX.β] | [A → α.Xβ] em I0 }.",
                                    "Calcule o closure desse novo kernel para formar o próximo conjunto Ii.",
                                    "Registre a transição I0 --X--> Ii.",
                                    "Evite confundir terminais e não-terminais nas transições.",
                                    "Nomeie os conjuntos sequencialmente (I1, I2, etc.)."
                                  ],
                                  "verification": "Confirme que todos os itens de transição têm o ponto avançado corretamente após X.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Papel para diagramas de transição",
                                    "Marcadores para símbolos"
                                  ],
                                  "tips": "Desenhe setas para visualizar o autômato enquanto calcula.",
                                  "learningObjective": "Aplicar a função GOTO para expandir estados do autômato LR(0).",
                                  "commonMistakes": [
                                    "Avançar o ponto em itens errados.",
                                    "Esquecer de calcular closure nos novos kernels.",
                                    "Confundir shift (terminais) com goto (não-terminais)."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Iterar o processo até completar todos os conjuntos e verificar",
                                  "subSteps": [
                                    "Repita o Step 3 para cada novo conjunto até que nenhum GOTO gere um conjunto não visto.",
                                    "Mantenha uma lista de conjuntos visitados para detectar duplicatas.",
                                    "Ordene todos os conjuntos e liste todas as transições.",
                                    "Identifique itens com ponto no fim (ready for reduce).",
                                    "Desenhe o autômato completo com estados e transições."
                                  ],
                                  "verification": "Todos os conjuntos estão fechados, sem loops pendentes e transições cobrem todos os símbolos relevantes.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Folha grande para o autômato",
                                    "Ferramentas de desenho"
                                  ],
                                  "tips": "Use um índice para rastrear conjuntos (I0, I1, ... ) e marque 'feito' em visitados.",
                                  "learningObjective": "Construir o autômato LR(0) completo através de iteração sistemática.",
                                  "commonMistakes": [
                                    "Gerar conjuntos duplicados sem mesclar.",
                                    "Perder transições para ε-produções.",
                                    "Ignorar símbolos vazios ou fim de string."
                                  ]
                                }
                              ],
                              "practicalExample": "Para a gramática S → CC | c, C → c | d (produções: 1:S→CC, 2:S→c, 3:C→c, 4:C→d; aumentada 0:S'→S). I0: closure({S'→.S}) = {S'→.S, S→.CC, S→.c, C→.c, C→.d}. GOTO(I0,c) = I1: closure({S→c., C→c.}); GOTO(I0,C)=I2: etc. Continue até I5, formando o autômato com 6 estados.",
                              "finalVerifications": [
                                "Todos os closures estão completos e sem itens redundantes.",
                                "Transições GOTO cobrem todos os símbolos no alfabeto da gramática.",
                                "Nenhum conjunto é duplicado ou inacessível.",
                                "Itens reduce (ponto no fim) estão corretamente identificados.",
                                "O autômato aceita a linguagem da gramática.",
                                "Número total de estados é mínimo (sem merges desnecessários)."
                              ],
                              "assessmentCriteria": [
                                "Precisão dos closures: 100% dos itens corretos (30%)",
                                "Correção das funções GOTO e transições (30%)",
                                "Completude da iteração: todos estados gerados (20%)",
                                "Clareza na apresentação: ordenação e diagrama (10%)",
                                "Identificação de conflitos potenciais LR(0) (5%)",
                                "Eficiência no tempo e avoidance de erros comuns (5%)"
                              ],
                              "crossCurricularConnections": [
                                "Teoria de Autômatos: Conjuntos de itens como estados de AFND.",
                                "Teoria dos Grafos: Autômato LR(0) como grafo direcionado.",
                                "Algoritmos e Estruturas de Dados: Algoritmo de subset construction.",
                                "Lógica Formal: Inferência em regras de produção.",
                                "Engenharia de Software: Automação de parsing em ferramentas de compilação."
                              ],
                              "realWorldApplication": "Construção de parsers em compiladores reais (ex: GCC para C/C++, Javac para Java), analisadores sintáticos em IDEs como VS Code, e ferramentas de processamento de linguagens como SQL parsers em bancos de dados."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.2.2.3",
                            "name": "Gerar tabelas de ação e goto",
                            "description": "Preencher tabelas de parsing ACTION e GOTO a partir de um autômato LR(0), interpretando transições shift, reduce e conflitos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar a gramática e os estados canônicos do autômato LR(0)",
                                  "subSteps": [
                                    "Identificar os símbolos terminais e não-terminais da gramática.",
                                    "Listar todos os estados do autômato LR(0), incluindo seus núcleos e kernels (itens fechados).",
                                    "Numerar os estados sequencialmente (I0, I1, ..., In).",
                                    "Verificar transições entre estados para símbolos terminais e não-terminais."
                                  ],
                                  "verification": "Lista completa de estados com itens LR(0) corretos e transições anotadas.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Gramática formalizada",
                                    "Papel ou editor de texto para diagramas de estados",
                                    "Livro 'Compilers: Principles, Techniques, and Tools' (Dragon Book), capítulo 4"
                                  ],
                                  "tips": "Desenhe o autômato como um grafo para visualizar transições facilmente.",
                                  "learningObjective": "Compreender a estrutura do autômato LR(0) fornecido para preenchimento das tabelas.",
                                  "commonMistakes": [
                                    "Confundir terminais com não-terminais.",
                                    "Esquecer de fechar itens com produções epsilon ou nullable."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Construir a tabela GOTO",
                                  "subSteps": [
                                    "Criar linhas para cada estado (0 a n).",
                                    "Para cada transição por não-terminal A de estado i para j, preencher GOTO[i][A] = j.",
                                    "Verificar que todas as transições por não-terminais estão cobertas.",
                                    "Garantir ausência de múltiplas entradas para o mesmo [i][A]."
                                  ],
                                  "verification": "Tabela GOTO preenchida sem lacunas ou duplicatas para não-terminais.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Tabela em branco (planilha ou papel quadriculado)",
                                    "Lista de estados e transições"
                                  ],
                                  "tips": "Use cores diferentes para terminais e não-terminais para evitar confusões.",
                                  "learningObjective": "Dominar o preenchimento da função GOTO baseada em transições do autômato.",
                                  "commonMistakes": [
                                    "Preencher GOTO com terminais (isso vai para ACTION).",
                                    "Ignorar transições implícitas por fechamento."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Preencher a coluna ACTION para transições shift",
                                  "subSteps": [
                                    "Para cada transição shift por terminal a de estado i para j, preencher ACTION[i][a] = 's j'.",
                                    "Cobrir todos os terminais possíveis em cada estado.",
                                    "Identificar o estado inicial I0 e shifts a partir dele.",
                                    "Verificar lookahead implícito em LR(0) (todos os terminais no item)."
                                  ],
                                  "verification": "Todas as entradas shift corretamente numeradas e posicionadas na ACTION.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Tabela ACTION/GOTO parcial",
                                    "Diagrama do autômato"
                                  ],
                                  "tips": "Liste todos os terminais da gramática primeiro para checar cobertura.",
                                  "learningObjective": "Aplicar corretamente a regra shift nas tabelas de parsing LR(0).",
                                  "commonMistakes": [
                                    "Usar 'r' em vez de 's' para shifts.",
                                    "Número do estado de destino incorreto."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Preencher ACTION para reduce e accept",
                                  "subSteps": [
                                    "Para itens completos A → α• em estado i (sem lookahead em LR(0)), preencher ACTION[i][a] = 'r k' para todo terminal a, onde k é o número da produção.",
                                    "Para o item S' → S• no estado final, preencher ACTION[j][$] = 'acc' (fim de entrada).",
                                    "Aplicar reduce apenas onde o ponto está no fim do corpo da produção."
                                  ],
                                  "verification": "Reduces e accept colocados corretamente sem sobreposição inicial com shifts.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Lista de produções numeradas",
                                    "Tabela ACTION parcial"
                                  ],
                                  "tips": "Numere as produções claramente (ex: 0: S' → S).",
                                  "learningObjective": "Distinguir e aplicar regras de reduce e accept em LR(0).",
                                  "commonMistakes": [
                                    "Aplicar reduce seletivamente (em LR(0) é para todos terminais).",
                                    "Confundir accept com reduce na produção aumentada."
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Detectar e analisar conflitos na tabela",
                                  "subSteps": [
                                    "Verificar shift-reduce conflicts: célula com 's j' e 'r k'.",
                                    "Verificar reduce-reduce conflicts: múltiplos 'r' na mesma célula.",
                                    "Marcar conflitos e propor resolução (ex: tornar SLR(1) ou LALR).",
                                    "Validar a tabela completa com uma string de teste simples."
                                  ],
                                  "verification": "Todos conflitos identificados e tabela final consistente ou com alertas.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Tabela completa ACTION/GOTO",
                                    "Exemplo de sentença para simulação manual"
                                  ],
                                  "tips": "Simule o parsing com $ como fim para testar accept.",
                                  "learningObjective": "Identificar e interpretar conflitos em parsers LR(0).",
                                  "commonMistakes": [
                                    "Ignorar conflitos shift-reduce como normais.",
                                    "Não testar com entrada válida."
                                  ]
                                }
                              ],
                              "practicalExample": "Considere a gramática: S' → S (0), S → A (1), S → a (2), A → a (3). Estados: I0: S'→•S, S→•A, S→•a, A→•a; etc. Tabela exemplo: ACTION[0][a]='s3', GOTO[0][S]=1, etc. Simule parsing de 'a': shift a → estado 3 → reduce A→a → etc.",
                              "finalVerifications": [
                                "Tabela GOTO mapeia corretamente todas transições por não-terminais.",
                                "ACTION shift usa 's j' com j correto.",
                                "Reduces 'r k' aplicados a todos terminais em itens completos.",
                                "Accept apenas em S' → S• com $.",
                                "Conflitos shift-reduce e reduce-reduce detectados.",
                                "Cobertura total de terminais sem células vazias críticas.",
                                "Simulação de parsing de uma sentença válida termina em accept."
                              ],
                              "assessmentCriteria": [
                                "Precisão no preenchimento de GOTO (100% das transições).",
                                "Correta distinção entre shift e reduce na ACTION.",
                                "Detecção precisa de conflitos (shift-reduce, reduce-reduce).",
                                "Uso correto de lookahead implícito em LR(0).",
                                "Capacidade de simular parsing na tabela gerada.",
                                "Clareza na apresentação da tabela (formato legível)."
                              ],
                              "crossCurricularConnections": [
                                "Teoria da Computação (autômatos de pilha determinísticos).",
                                "Matemática Discreta (grafos de transição e funções de transição).",
                                "Engenharia de Software (implementação de parsers em ferramentas como Yacc/Bison).",
                                "Processamento de Linguagem Natural (parsing sintático em NLP)."
                              ],
                              "realWorldApplication": "Em compiladores reais como GCC e Clang, tabelas ACTION/GOTO são geradas automaticamente por ferramentas como Bison para parse eficiente de código-fonte em linguagens como C++, detectando erros sintáticos em tempo de compilação."
                            },
                            "estimatedTime": "2.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.2.2.3",
                        "name": "Tipos de Parsers LR e Aplicações",
                        "description": "Variantes de parsers bottom-up como LR(0), SLR(1), LALR(1) e LR(1), com foco em poder expressivo e eficiência prática.",
                        "specificSkills": [
                          {
                            "id": "10.1.2.2.3.1",
                            "name": "Comparar LR(0), SLR(1), LALR(1) e LR(1)",
                            "description": "Analisar diferenças em lookahead e resolução de conflitos: LR(0) sem lookahead, SLR com FOLLOW, LALR combinando tabelas, LR(1) com lookahead completo.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Fundamentos do Parser LR(0)",
                                  "subSteps": [
                                    "Estude a construção de itens LR(0) e estados do automato.",
                                    "Construa a tabela de parsing LR(0) para uma gramática simples sem lookahead.",
                                    "Identifique conflitos shift-reduce e reduce-reduce inerentes ao LR(0).",
                                    "Analise como o LR(0) resolve ações baseando-se apenas no estado atual.",
                                    "Pratique com exemplos de gramáticas LR(0) puras."
                                  ],
                                  "verification": "Construa com sucesso a tabela LR(0) para uma gramática dada sem erros e identifique conflitos.",
                                  "estimatedTime": "1.5 hours",
                                  "materials": [
                                    "Livro de Compiladores (Dragon Book, Cap. 4)",
                                    "Ferramenta online como JFLAP ou LR Parser Generator"
                                  ],
                                  "tips": "Comece com gramáticas determinísticas simples para evitar frustração inicial.",
                                  "learningObjective": "Compreender o parsing LR(0) básico sem lookahead e seus conflitos.",
                                  "commonMistakes": [
                                    "Confundir itens de kernel com closure.",
                                    "Ignorar propagação de lookahead em itens iniciais."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Explorar SLR(1) e Introdução de FOLLOW Sets",
                                  "subSteps": [
                                    "Revise conjuntos FOLLOW para não-terminais.",
                                    "Modifique a tabela LR(0) adicionando lookahead via FOLLOW para ações reduce.",
                                    "Compare tabelas LR(0) e SLR(1) na resolução de shift-reduce conflicts.",
                                    "Teste SLR(1) em gramáticas com ambiguidades resolvidas por FOLLOW.",
                                    "Identifique gramáticas SLR(1) mas não LR(0)."
                                  ],
                                  "verification": "Gere tabela SLR(1) para a mesma gramática do Step 1 e demonstre resolução de conflitos.",
                                  "estimatedTime": "2 hours",
                                  "materials": [
                                    "Notas de aula sobre FOLLOW sets",
                                    "Implementação Python simples de tabela SLR"
                                  ],
                                  "tips": "Use FOLLOW para filtrar reduces apenas quando o próximo símbolo está no conjunto.",
                                  "learningObjective": "Dominar como SLR(1) usa lookahead limitado via FOLLOW para expandir poder de LR(0).",
                                  "commonMistakes": [
                                    "Calcular FOLLOW incorretamente, incluindo terminais errados.",
                                    "Aplicar FOLLOW em shift actions incorretamente."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar LALR(1) e Combinação de Tabelas",
                                  "subSteps": [
                                    "Construa o automato LR(1) completo e observe estados com lookaheads propagados.",
                                    "Mescle estados LR(1) com o mesmo core LR(0) para formar LALR(1).",
                                    "Compare tabelas LALR(1) vs SLR(1), destacando lookaheads mais precisos.",
                                    "Identifique conflitos introduzidos pela mesclagem (spurious conflicts).",
                                    "Aplique LALR(1) em gramáticas reais como expressões aritméticas."
                                  ],
                                  "verification": "Construa e compare tabelas LALR(1) e SLR(1) para uma gramática, notando diferenças em lookaheads.",
                                  "estimatedTime": "2.5 hours",
                                  "materials": [
                                    "Yacc/Bison manual",
                                    "Ferramenta online LALR generator"
                                  ],
                                  "tips": "Visualize estados mesclados graficamente para entender união de lookaheads.",
                                  "learningObjective": "Entender como LALR(1) otimiza LR(1) combinando cores com lookaheads unionados.",
                                  "commonMistakes": [
                                    "Não propagar lookaheads corretamente durante mesclagem.",
                                    "Confundir cores idênticos com estados idênticos."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Dominar LR(1) e Comparação Final dos Quatro Parsers",
                                  "subSteps": [
                                    "Construa o parser LR(1) completo com propagação de lookaheads em itens.",
                                    "Compare eficiência: tamanho das tabelas (LR(0) < SLR < LALR < LR(1)).",
                                    "Analise resolução de conflitos: LR(0) mais restritivo, LR(1) mais poderoso.",
                                    "Crie uma tabela comparativa resumindo diferenças em lookahead e conflicts.",
                                    "Teste todos em uma gramática SLR mas não LR(0)."
                                  ],
                                  "verification": "Crie uma tabela comparativa precisa e parse strings com cada parser.",
                                  "estimatedTime": "2 hours",
                                  "materials": [
                                    "Exemplos de gramáticas de compiladores",
                                    "Simulador LR online"
                                  ],
                                  "tips": "Use diagramas para visualizar hierarquia de poder: LR(0) ⊂ SLR(1) ⊂ LALR(1) ⊂ LR(1).",
                                  "learningObjective": "Sintetizar diferenças chave e hierarquia de poder entre os parsers LR.",
                                  "commonMistakes": [
                                    "Subestimar tamanho explosivo de LR(1).",
                                    "Ignorar que LALR pode introduzir conflitos não presentes em LR(1)."
                                  ]
                                }
                              ],
                              "practicalExample": "Para a gramática S → A | B, A → aA | ε, B → bB | ε: Construa tabelas LR(0), SLR(1), LALR(1) e LR(1). Observe que LR(0) tem shift-reduce conflict em ε-produções, SLR resolve com FOLLOW={a,b,$}, LALR mescla lookaheads {a,$} e {b,$}, LR(1) mantém separados evitando spurious conflicts.",
                              "finalVerifications": [
                                "Explicar verbalmente diferenças em lookahead sem consultar notas.",
                                "Construir tabela SLR(1) de uma gramática LR(0) conflictiva em <10 min.",
                                "Identificar se uma gramática dada é LALR(1) mas não SLR(1).",
                                "Comparar tamanhos de tabelas para uma gramática real.",
                                "Detectar spurious conflict em LALR(1) vs LR(1).",
                                "Listar prós/contras de cada parser em termos de poder e eficiência."
                              ],
                              "assessmentCriteria": [
                                "Precisão na descrição de lookaheads: FOLLOW em SLR, union em LALR, propagado em LR(1).",
                                "Correta identificação e resolução de conflitos shift-reduce/reduce-reduce.",
                                "Hierarquia de poder demonstrada com exemplos concretos.",
                                "Eficiência computacional comparada (espaço/tempo de construção).",
                                "Uso correto de terminologia (core, kernel, closure).",
                                "Aplicação prática em gramáticas não-triviais."
                              ],
                              "crossCurricularConnections": [
                                "Teoria da Computação: Hierarquia de linguagens LR(k).",
                                "Automatos e Linguagens Formais: Estados com lookaheads como AFND.",
                                "Engenharia de Software: Otimização em ferramentas como Yacc/Bison.",
                                "Algoritmos: Construção de tabelas como problema de grafos.",
                                "Matemática Discreta: Conjuntos FOLLOW via fechamento transitivo."
                              ],
                              "realWorldApplication": "Em compiladores como GCC (usa LALR(1) via Bison para balancear poder e tamanho de tabela), permitindo parsing eficiente de linguagens complexas como C++ sem o overhead massivo de LR(1) full."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.2.3.2",
                            "name": "Aplicar parser SLR(1) em gramática real",
                            "description": "Construir autômato e tabelas SLR(1) para uma gramática de expressões aritméticas, testando parsing de entradas válidas e inválidas.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Definir e Augmentar a Gramática",
                                  "subSteps": [
                                    "Escreva a gramática para expressões aritméticas: E → E + T | T, T → T * F | F, F → (E) | id",
                                    "Adicione o axioma aumentado: S' → E",
                                    "Calcule os conjuntos FIRST para cada não-terminal",
                                    "Calcule os conjuntos FOLLOW para cada não-terminal usando algoritmos padrão",
                                    "Verifique se a gramática é SLR(1) sem conflitos iniciais"
                                  ],
                                  "verification": "Conjuntos FIRST e FOLLOW listados corretamente e sem erros de cálculo",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Papel, lápis, tabela de gramática impressa ou editor de texto",
                                  "tips": "Comece pelos terminais e avance para não-terminais recursivos",
                                  "learningObjective": "Entender a preparação da gramática para análise SLR(1)",
                                  "commonMistakes": "Esquecer recursão à esquerda ou incluir epsilon incorretamente em FIRST"
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Construir a Coleção Canônica de Itens LR(0)",
                                  "subSteps": [
                                    "Inicie com o item inicial: [S' → .E]",
                                    "Compute fechamento (closure) para o estado I0 adicionando itens não-terminais",
                                    "Aplique GOTO para cada símbolo (terminais e não-terminais) para gerar novos estados",
                                    "Continue até não haver novos estados, numerando-os sequencialmente (I0 a In)",
                                    "Desenhe o autômato de estados com transições"
                                  ],
                                  "verification": "Todos estados têm closure correto e transições completas sem estados duplicados",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Folha grande para diagrama, calculadora para FOLLOW se necessário",
                                  "tips": "Use notação [A → α.β] consistentemente e marque kernel vs. closure",
                                  "learningObjective": "Dominar a construção do autômato LR(0) base para SLR(1)",
                                  "commonMistakes": "Erro no closure ao propagar pontos em produções recursivas"
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Construir Tabelas de Ação e GOTO SLR(1)",
                                  "subSteps": [
                                    "Para cada estado, preencha colunas de terminais: SHIFT se GOTO em terminal, REDUCE usando FOLLOW, ACCEPT em S' → E., erro caso conflito",
                                    "Preencha colunas de não-terminais com GOTO(state, símbolo)",
                                    "Verifique conflitos SHIFT/REDUCE ou REDUCE/REDUCE resolvendo com FOLLOW sets",
                                    "Crie tabela completa com linhas=estados, colunas=símbolos terminais/não-terminais",
                                    "Valide ausência de conflitos para confirmar SLR(1)"
                                  ],
                                  "verification": "Tabela sem conflitos e todas entradas preenchidas corretamente",
                                  "estimatedTime": "40 minutos",
                                  "materials": "Planilha Excel ou papel quadriculado para tabela",
                                  "tips": "Liste FOLLOW cedo para resolver potenciais conflitos em reduces",
                                  "learningObjective": "Aprender a tabular ações baseadas em FOLLOW para SLR(1)",
                                  "commonMistakes": "Confundir SHIFT com GOTO ou ignorar FOLLOW em reduces"
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Testar o Parser com Entradas Válidas e Inválidas",
                                  "subSteps": [
                                    "Implemente o parser em pseudocódigo ou Python simples usando pilha e tabela",
                                    "Teste string válida: 'id + id * id' – espere ACCEPT",
                                    "Teste string válida: '(id + id)' – confirme pilha e shifts/reduces",
                                    "Teste inválida: 'id + +' – detecte erro em lookahead",
                                    "Analise pilha final e ações para cada teste, registrando trace"
                                  ],
                                  "verification": "Parsing correto para válidas (ACCEPT), rejeição para inválidas sem crash",
                                  "estimatedTime": "35 minutos",
                                  "materials": "Editor de código (VS Code), debugger opcional",
                                  "tips": "Simule manualmente primeiro antes de codificar para validar tabela",
                                  "learningObjective": "Aplicar e depurar parser SLR(1) em cenários reais",
                                  "commonMistakes": "Erro na pilha (pop incorreto) ou lookahead não consultado"
                                }
                              ],
                              "practicalExample": "Para gramática E → E + T | T; T → T * F | F; F → (E) | id, construa autômato com ~8 estados, tabelas sem conflitos, e parse 'id*(id+id)' resultando em ACCEPT após shifts e reduces corretos.",
                              "finalVerifications": [
                                "Autômato LR(0) completo com 6-10 estados e transições precisas",
                                "Tabelas SLR(1) sem SHIFT/REDUCE ou REDUCE/REDUCE conflitos",
                                "Conjuntos FIRST/FOLLOW calculados e listados corretamente",
                                "Parser simulado manualmente para 3 strings: 2 válidas, 1 inválida",
                                "Implementação em código roda sem erros e produz traces corretos",
                                "Diagrama do autômato desenhado e legível"
                              ],
                              "assessmentCriteria": [
                                "Precisão na construção de itens e estados (30%)",
                                "Correção das tabelas de ação/GOTO usando FOLLOW (25%)",
                                "Ausência de conflitos e validação SLR(1) (20%)",
                                "Testes abrangentes com traces detalhados (15%)",
                                "Clareza de diagramas e documentação (10%)"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria de Autômatos Finitos e Grafos",
                                "Lógica: Conjuntos FIRST/FOLLOW como álgebra de conjuntos",
                                "Engenharia de Software: Construção de ferramentas de compilação",
                                "Algoritmos: Algoritmos de fechamento e transição determinística"
                              ],
                              "realWorldApplication": "Parsers SLR(1) e variantes LR são usados em compiladores reais como GCC e Clang para análise sintática eficiente de linguagens de programação, permitindo parsing rápido de código fonte em projetos de software em escala."
                            },
                            "estimatedTime": "3 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.2.3.3",
                            "name": "Discutir ferramentas como Yacc/Bison",
                            "description": "Explicar como meta-compiladores geram parsers bottom-up a partir de especificações de gramática, relacionando com livros como Aho et al.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Fundamentos de Parsers Bottom-Up e LR",
                                  "subSteps": [
                                    "Estude os conceitos de shift-reduce parsing e como parsers bottom-up constroem a árvore sintática de baixo para cima.",
                                    "Revise itens LR(0), LR(1) e conflitos shift-reduce/reduce.",
                                    "Leia seções relevantes do 'Compilers: Principles, Techniques, and Tools' (Aho et al., Dragon Book), capítulos 4 e 5.",
                                    "Anote diferenças entre parsers top-down e bottom-up.",
                                    "Identifique quando usar parsers LR em vez de LL."
                                  ],
                                  "verification": "Crie um diagrama manual de um autômato LR para uma gramática simples e explique seu funcionamento.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Dragon Book (capítulos 4-5)",
                                    "Notas de aula sobre compiladores",
                                    "Ferramenta de desenho como Draw.io"
                                  ],
                                  "tips": "Comece com gramáticas simples sem ambiguidades para evitar confusão inicial.",
                                  "learningObjective": "Compreender os princípios teóricos que Yacc/Bison automatizam.",
                                  "commonMistakes": "Confundir lookahead com lookbehind; ignorar conflitos de reduce."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Aprender Sintaxe e Estrutura de Especificações Yacc/Bison",
                                  "subSteps": [
                                    "Instale Bison (ou Yacc) e compile um exemplo 'hello world' de parser.",
                                    "Estude seções: declarações (%token, %start), regras de gramática, ações C em { }.",
                                    "Aprenda diretivas como %left, %right para precedência e associatividade.",
                                    "Analise a estrutura de saída: y.tab.c, y.tab.h e parser gerado.",
                                    "Pratique escrevendo uma gramática vazia válida."
                                  ],
                                  "verification": "Escreva e compile uma especificação Yacc/Bison mínima que reconheça uma string simples.",
                                  "estimatedTime": "3 horas",
                                  "materials": [
                                    "Bison manual (info bison)",
                                    "Editor de texto/IDE como VS Code",
                                    "Compilador GCC"
                                  ],
                                  "tips": "Use %define api.pure full para parsers reentrantes desde o início.",
                                  "learningObjective": "Dominar a sintaxe para especificar gramáticas LR.",
                                  "commonMistakes": "Esquecer de declarar tokens; não lidar com precedência em expressões."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Construir e Testar um Parser Simples com Yacc/Bison",
                                  "subSteps": [
                                    "Defina uma gramática para expressões aritméticas básicas (+, -, *, /).",
                                    "Implemente ações para construir uma árvore sintática abstrata (AST).",
                                    "Gere o parser e integre com um lexer simples (flex).",
                                    "Teste com entradas válidas e inválidas, observando saídas.",
                                    "Debugue conflitos usando bison -v para ver estados LR."
                                  ],
                                  "verification": "Parser compila e parseia corretamente '2+3*4' produzindo AST equivalente a 14.",
                                  "estimatedTime": "4 horas",
                                  "materials": [
                                    "Flex/Bison",
                                    "Exemplos de gramáticas aritméticas online",
                                    "Terminal para testes"
                                  ],
                                  "tips": "Use yydebug=1 para tracing durante execução.",
                                  "learningObjective": "Aplicar Yacc/Bison para gerar um parser funcional bottom-up.",
                                  "commonMistakes": "Ambiguidades em gramáticas sem %left/%right; vazamentos de memória em ações."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Explicar Processo de Geração e Relacionar com Literatura",
                                  "subSteps": [
                                    "Descreva como Bison constrói tabelas de ação e goto a partir da gramática.",
                                    "Compare com algoritmos manuais do Dragon Book (algoritmo SLR/LR).",
                                    "Discuta limitações: LALR(1) vs LR(1) full, handling de erros.",
                                    "Relacione com capítulos 4.7-4.9 do Aho et al.",
                                    "Prepare uma apresentação ou relatório resumindo o fluxo."
                                  ],
                                  "verification": "Escreva um parágrafo explicando 'Yacc gera parsers LALR(1) bottom-up via autômatos finitos'.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Dragon Book",
                                    "Bison verbose output (-v)",
                                    "Slides ou documento para resumo"
                                  ],
                                  "tips": "Visualize estados com ferramentas como bison's graph output.",
                                  "learningObjective": "Articular como meta-compiladores automatizam teoria de parsing.",
                                  "commonMistakes": "Subestimar overhead de debugging em gramáticas complexas."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Explorar Aplicações Avançadas e Limitações",
                                  "subSteps": [
                                    "Estenda o parser para suportar variáveis e funções simples.",
                                    "Discuta uso em compiladores reais (GCC backend).",
                                    "Compare Yacc/Bison com ANTLR ou ferramentas modernas.",
                                    "Aborde error recovery (%error-token).",
                                    "Pesquise case studies de uso em projetos open-source."
                                  ],
                                  "verification": "Modifique o parser para lidar com erros e teste cenários de falha.",
                                  "estimatedTime": "3 horas",
                                  "materials": [
                                    "Exemplos GCC source",
                                    "Stack Overflow threads on Bison errors"
                                  ],
                                  "tips": "Priorize gramáticas determinísticas para evitar non-LR subsets.",
                                  "learningObjective": "Avaliar Yacc/Bison no contexto prático e teórico.",
                                  "commonMistakes": "Ignorar portabilidade (Yacc vs Bison differences)."
                                }
                              ],
                              "practicalExample": "Use Bison para criar um parser para uma linguagem mini-SQL simples que parseia 'SELECT nome FROM tabela WHERE idade > 18;', gerando uma AST que pode ser usada para query planning, demonstrando shift-reduce em ação com precedência de operadores.",
                              "finalVerifications": [
                                "Explicar corretamente o fluxo: gramática -> itens LR -> tabelas -> parser C.",
                                "Identificar e resolver um conflito shift-reduce em uma gramática dada.",
                                "Relacionar Yacc com Capítulo 4 do Dragon Book verbalmente.",
                                "Executar um parser Bison com input inválido e descrever recovery.",
                                "Comparar Yacc parsers com hand-written parsers em eficiência.",
                                "Listar 3 ferramentas que usam Bison internamente."
                              ],
                              "assessmentCriteria": [
                                "Precisão técnica na descrição do algoritmo LR (90%+ acurácia).",
                                "Clareza na explicação de sintaxe Yacc com exemplos compiláveis.",
                                "Profundidade na relação com literatura (citações específicas do Dragon Book).",
                                "Capacidade de debugging: resolver conflitos autonomamente.",
                                "Criatividade em extensões práticas do exemplo base.",
                                "Comunicação: diagrama ou demo funcional em 5 minutos."
                              ],
                              "crossCurricularConnections": [
                                "Linguística Computacional: gramáticas formais e parsing natural language.",
                                "Engenharia de Software: geração automática de código (code generators).",
                                "Matemática Discreta: autômatos finitos e teoria de linguagens formais.",
                                "Desenvolvimento de Software: integração com lexers em pipelines de compiladores."
                              ],
                              "realWorldApplication": "Yacc/Bison são usados em compiladores como GCC, PostgreSQL parser e Bash para processar linguagens de script/domínio-específicas, acelerando desenvolvimento de ferramentas que lidam com sintaxe complexa em produção."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.2.3.4",
                            "name": "Tratar erros em parsers bottom-up",
                            "description": "Implementar estratégias de recuperação de erros como panic mode ou error productions em shift-reduce parsers.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os fundamentos de detecção e tipos de erros em parsers bottom-up",
                                  "subSteps": [
                                    "Estude o ciclo de shift-reduce em parsers LR/SLR: shift, reduce, conflitos (shift-reduce, reduce-reduce).",
                                    "Identifique cenários comuns de erro: tokens inesperados, faltantes ou duplicados em entradas inválidas.",
                                    "Analise o impacto de erros não tratados: stack overflow, loops infinitos ou rejeição total da entrada.",
                                    "Revise gramáticas LL/LR e exemplos de entradas sintaticamente incorretas.",
                                    "Compare detecção de erros em parsers top-down vs bottom-up."
                                  ],
                                  "verification": "Explique em um diagrama ou pseudocódigo como um shift-reduce parser detecta um token inesperado.",
                                  "estimatedTime": "1-2 horas",
                                  "materials": [
                                    "Livro 'Compilers: Principles, Techniques, and Tools' (Dragon Book), capítulos sobre sintaxe",
                                    "Ferramenta online como JFLAP para simular parsers LR",
                                    "Exemplos de gramáticas em sites como epsilon.com"
                                  ],
                                  "tips": [
                                    "Use diagramas de pilha e entrada para visualizar estados",
                                    "Teste com gramáticas simples como expressões aritméticas",
                                    "Anote diferenças entre erros locais e globais"
                                  ],
                                  "learningObjective": "Identificar e classificar erros em shift-reduce parsers bottom-up.",
                                  "commonMistakes": [
                                    "Confundir shift-reduce com reduce-reduce",
                                    "Ignorar o papel do lookahead token",
                                    "Subestimar propagação de erros"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar a estratégia de Panic Mode para recuperação de erros",
                                  "subSteps": [
                                    "Defina regras do Panic Mode: pular tokens até sincronização (ex: follow sets ou marcadores como ';').",
                                    "Modifique o parser shift-reduce: ao detectar erro, esvazie pilha até estado de sincronização e ignore tokens errados.",
                                    "Implemente em código (Python ou C): adicione flags de erro e loop de recuperação.",
                                    "Teste com entrada inválida: ex: 'id + + id;' deve recuperar após o segundo '+' e parse o resto.",
                                    "Meça eficácia: tempo de recuperação e qualidade do relatório de erro."
                                  ],
                                  "verification": "Execute o parser em input com erro múltiplo e confirme que continua parsing sem crash.",
                                  "estimatedTime": "2-3 horas",
                                  "materials": [
                                    "Código base de um parser SLR simples (GitHub repos como 'tiny-lr-parser')",
                                    "Editor de código com debugger (VS Code, PyCharm)",
                                    "Gramática de teste: E -> E + T | T; T -> id | (E)"
                                  ],
                                  "tips": [
                                    "Escolha sincronização sets conservadores para evitar perda excessiva de código",
                                    "Logue todos os skips para debug",
                                    "Comece com erros isolados antes de múltiplos"
                                  ],
                                  "learningObjective": "Codificar Panic Mode funcional em um shift-reduce parser.",
                                  "commonMistakes": [
                                    "Esvaziar pilha excessivamente, perdendo contexto válido",
                                    "Não restaurar lookahead após skip",
                                    "Ignorar nested structures"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar Error Productions para recuperação precisa",
                                  "subSteps": [
                                    "Adicione produções de erro na gramática: ex: error -> ; ou stmt -> error para absorver erros.",
                                    "Integre no parser generator ou manualmente: trate 'error' como non-terminal especial.",
                                    "Modifique ações de reduce/shift para incluir error handling sem propagar pânico.",
                                    "Teste cenários: entrada como 'if (x + + ) stmt;' deve reportar erro em '+' e continuar.",
                                    "Compare com Panic Mode: avalie precisão vs velocidade."
                                  ],
                                  "verification": "Gere árvore de parsing com 'error' nodes inseridos corretamente em input inválido.",
                                  "estimatedTime": "2-3 horas",
                                  "materials": [
                                    "Yacc/Bison tutoriais para error productions",
                                    "Parser generator como ANTLR ou Menhir",
                                    "Test cases com 5+ gramáticas variadas"
                                  ],
                                  "tips": [
                                    "Limite error productions a 10-20% da gramática para evitar ambiguidades",
                                    "Use precedência para priorizar produções normais",
                                    "Valide com inputs reais de linguagens como C subsets"
                                  ],
                                  "learningObjective": "Incorporar error productions em gramáticas LR para recuperação localizada.",
                                  "commonMistakes": [
                                    "Produções de erro muito gerais causando reduce loops",
                                    "Conflitos LR com error symbols",
                                    "Não limpar error flag após recuperação"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Testar, otimizar e integrar estratégias híbridas de recuperação",
                                  "subSteps": [
                                    "Crie suite de testes: 20+ inputs com erros variados (missing token, extra, wrong order).",
                                    "Meça métricas: taxa de recuperação, falsos positivos, overhead de performance.",
                                    "Híbrido: Panic Mode para erros graves + Error Productions para leves.",
                                    "Otimize: adicione sugestões de correção (ex: 'expected ;').",
                                    "Documente limitações e escreva relatório comparativo."
                                  ],
                                  "verification": "Parser recupera >80% dos testes sem rejeitar entrada inteira e gera relatórios úteis.",
                                  "estimatedTime": "2-4 horas",
                                  "materials": [
                                    "Framework de testes como pytest ou unittest",
                                    "Benchmark tools como timeit",
                                    "Exemplos de compiladores open-source (GCC error handling)"
                                  ],
                                  "tips": [
                                    "Priorize recovery em código 'bem formado exceto um erro'",
                                    "Automatize testes com fuzzing simples",
                                    "Registre posições de erro para UX melhor"
                                  ],
                                  "learningObjective": "Avaliar e refinar estratégias de error recovery em parsers bottom-up.",
                                  "commonMistakes": [
                                    "Overfitting testes a casos simples",
                                    "Ignorar performance em inputs longos",
                                    "Não testar nested erros"
                                  ]
                                }
                              ],
                              "practicalExample": "Desenvolva um parser bottom-up para expressões aritméticas (gramática: E -> E + T | E - T | T; T -> T * F | T / F | F; F -> (E) | id). Input inválido: 'id + + id * (id'. Com Panic Mode: skip '+' extra até '(', recupera parseando 'id * (id'. Com Error Production: stmt -> error + T, insere node error e continua, reportando 'unexpected + near line 1'.",
                              "finalVerifications": [
                                "Implemente parser que lida com 10+ erros sem crashar.",
                                "Gere relatórios de erro com posição e sugestão de fix.",
                                "Recupere parsing em >70% de casos com código restante válido.",
                                "Compare outputs de Panic vs Error Productions em relatório.",
                                "Teste em gramática não-trivial (mini-C subset).",
                                "Explique limitações em diagrama."
                              ],
                              "assessmentCriteria": [
                                "Precisão da recuperação: código válido preservado intacto.",
                                "Eficiência: overhead <20% em parsing normal.",
                                "Qualidade de relatórios: claro, localizado, acionável.",
                                "Robustez: lida com erros múltiplos/nested.",
                                "Modularidade: estratégias fáceis de toggle/extender.",
                                "Conformidade com gramática LR(0/1)."
                              ],
                              "crossCurricularConnections": [
                                "Teoria da Computação: Autômatos pushdown e reconhecimento de linguagens.",
                                "Engenharia de Software: Error handling e fault tolerance em sistemas.",
                                "Inteligência Artificial: Parsing em PLN (NLP) com recuperação semântica.",
                                "Design de UX: Feedback de erros intuitivo em IDEs/editors."
                              ],
                              "realWorldApplication": "Em compiladores como GCC/Clang, essas técnicas permitem diagnósticos úteis em código buggy (ex: 'missing ; after expression'), acelerando desenvolvimento sem rejeitar arquivos inteiros; usado em ferramentas como ESLint para JS ou Rustc."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.2.3",
                    "name": "Parsers Recursivos Descendentes",
                    "description": "Implementação top-down que usa recursão para escolher produções não-terminais com base no lookahead.",
                    "individualConcepts": [
                      {
                        "id": "10.1.2.3.1",
                        "name": "Princípios Básicos dos Parsers Recursivos Descendentes",
                        "description": "Conceitos fundamentais da abordagem top-down que utiliza recursão para reconhecer a estrutura sintática de uma linguagem de programação, com base em uma gramática livre de contexto.",
                        "specificSkills": [
                          {
                            "id": "10.1.2.3.1.1",
                            "name": "Diferenciar parsers top-down de bottom-up",
                            "description": "Explicar as diferenças entre métodos de análise sintática top-down (como recursivos descendentes) e bottom-up, destacando como o top-down constrói a árvore de derivação a partir do símbolo inicial.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os Fundamentos do Parser Top-Down",
                                  "subSteps": [
                                    "Defina parser top-down como um método que começa do símbolo inicial (start symbol) e expande para folhas da árvore de derivação.",
                                    "Estude o parser recursivo descendente como exemplo principal, onde funções recursivas correspondem a não-terminais.",
                                    "Aprenda sobre backtracking: quando uma escolha leva a falha, retroceda e tente outra produção.",
                                    "Desenhe uma árvore de derivação top-down para uma gramática simples como E → E + T | T.",
                                    "Identifique vantagens iniciais: simplicidade de implementação e legibilidade."
                                  ],
                                  "verification": "Desenhe manualmente a árvore de derivação top-down para a string 'id + id' e explique cada expansão.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Dragon Book (capítulo sobre análise sintática)",
                                    "Papel e caneta para diagramas",
                                    "Vídeo tutorial sobre recursivo descendente no YouTube"
                                  ],
                                  "tips": "Sempre comece do topo: visualize o start symbol como raiz da árvore.",
                                  "learningObjective": "Explicar como o top-down constrói a árvore de cima para baixo.",
                                  "commonMistakes": [
                                    "Confundir com geração de código em vez de parsing",
                                    "Ignorar o papel do backtracking em ambiguidades"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Compreender os Fundamentos do Parser Bottom-Up",
                                  "subSteps": [
                                    "Defina parser bottom-up como um método que começa das folhas (tokens) e reduz para o símbolo inicial usando shift-reduce.",
                                    "Estude shift-reduce parsing: shift empilha tokens, reduce aplica produções ao contrário.",
                                    "Aprenda sobre conflitos shift-reduce e reduce-reduce em parsers LR(0), SLR, LALR.",
                                    "Desenhe reduções bottom-up para a mesma gramática E → E + T | T com entrada 'id + id'.",
                                    "Identifique vantagens: eficiência e capacidade de lidar com gramáticas mais complexas sem left-recursion."
                                  ],
                                  "verification": "Simule o stack em um shift-reduce parse para 'id + id' e liste as reduções sequenciais.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Ferramenta online como JFLAP para simular parsers",
                                    "Dragon Book seção bottom-up",
                                    "Editor de texto para pseudocódigo"
                                  ],
                                  "tips": "Pense em 'reduzir' como inverter a produção: de sentença para não-terminal.",
                                  "learningObjective": "Descrever como o bottom-up constrói a árvore de baixo para cima.",
                                  "commonMistakes": [
                                    "Confundir shift com lookahead insuficiente",
                                    "Esquecer que bottom-up lida melhor com left-recursion"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Identificar e Comparar Diferenças Chave",
                                  "subSteps": [
                                    "Compare direção: top-down (start → tokens) vs bottom-up (tokens → start).",
                                    "Analise tratamento de left-recursion: top-down falha, bottom-up gerencia bem.",
                                    "Discuta backtracking vs tabelas determinísticas: top-down pode ser não-determinístico, bottom-up eficiente com LR tables.",
                                    "Compare poder expressivo: top-down para LL(k), bottom-up para LR(k) mais poderoso.",
                                    "Liste prós/contras: top-down mais intuitivo, bottom-up mais rápido em produção.",
                                    "Crie uma tabela comparativa com colunas: direção, recursão, eficiência, exemplos."
                                  ],
                                  "verification": "Preencha uma tabela de comparação com pelo menos 5 diferenças e justifique cada uma.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Planilha Google Sheets ou papel para tabela",
                                    "Resumo de gramáticas LL vs LR online"
                                  ],
                                  "tips": "Use setas para visualizar: ↓ para top-down, ↑ para bottom-up.",
                                  "learningObjective": "Listar e explicar 5+ diferenças fundamentais entre top-down e bottom-up.",
                                  "commonMistakes": [
                                    "Generalizar que um é sempre melhor",
                                    "Ignorar contexto de gramáticas LL vs LR"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar a Diferenciação em um Exemplo Prático",
                                  "subSteps": [
                                    "Escolha uma gramática ambígua simples: Expr → Expr + Term | Term | id.",
                                    "Implemente/simule parse top-down com backtracking para 'id + id'.",
                                    "Implemente/simule parse bottom-up (LR) para a mesma entrada.",
                                    "Observe diferenças no processo: número de passos, stack usage, erros potenciais.",
                                    "Discuta quando escolher cada: top-down para protótipos, bottom-up para compiladores reais."
                                  ],
                                  "verification": "Registre logs de ambos os parses e destaque 3 diferenças observadas.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Python ou Java para código simples de parser",
                                    "Parser generator como ANTLR demo online"
                                  ],
                                  "tips": "Comece com gramática sem ambiguidade para isolar diferenças.",
                                  "learningObjective": "Demonstrar diferenciação prática através de simulação.",
                                  "commonMistakes": [
                                    "Usar gramática incompatível com um método",
                                    "Não anotar estados intermediários"
                                  ]
                                }
                              ],
                              "practicalExample": "Considere a gramática Expr → Expr + Term | Term | id e entrada 'id + id'. No top-down (recursivo descendente), começa com Expr, tenta Expr + Term (chama recursão), backtrack se necessário. No bottom-up (shift-reduce), shift 'id', reduce to Term, shift '+', shift 'id', reduce stepwise to Expr.",
                              "finalVerifications": [
                                "Explicar verbalmente a direção de construção da árvore em cada método.",
                                "Identificar por que left-recursion quebra top-down mas não bottom-up.",
                                "Desenhar árvores de derivação para ambos em uma gramática dada.",
                                "Listar 3 vantagens de cada abordagem.",
                                "Simular parse simples sem erros em ambos os métodos.",
                                "Diferenciar LL vs LR parsers como subclasses."
                              ],
                              "assessmentCriteria": [
                                "Precisão na descrição da direção de parsing (top-down vs bottom-up).",
                                "Correta identificação de limitações como left-recursion e backtracking.",
                                "Capacidade de diagramar árvores e stacks corretamente.",
                                "Uso de terminologia técnica precisa (shift-reduce, recursivo descendente).",
                                "Análise comparativa equilibrada com prós/contras.",
                                "Aplicação correta em exemplos práticos sem confusões."
                              ],
                              "crossCurricularConnections": [
                                "Teoria da Computação: Linguagens regulares e livres de contexto (Chomsky hierarchy).",
                                "Algoritmos: Recursão, pilhas (stacks) e autômatos pushdown.",
                                "Engenharia de Software: Ferramentas como Yacc/Bison para bottom-up.",
                                "Lógica e Matemática: Árvores de derivação e grafos direcionados.",
                                "Programação Funcional: Parsers em Haskell (top-down comum)."
                              ],
                              "realWorldApplication": "Em compiladores como GCC/Clang (bottom-up LR para eficiência em C++), vs parsers em linguagens dinâmicas como JavaScript (muitos top-down para simplicidade), ou ferramentas como JSON parsers em navegadores."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.3.1.2",
                            "name": "Compreender o uso de recursão em parsers",
                            "description": "Identificar como a recursão simula a derivação esquerda de uma gramática, com cada não-terminal correspondendo a uma função recursiva.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Gramáticas Livres de Contexto e Derivações Esquerdas",
                                  "subSteps": [
                                    "Estude a definição de gramáticas livres de contexto (GLC), identificando terminais, não-terminais, produções e símbolo inicial.",
                                    "Aprenda o conceito de derivação esquerda: substitua o não-terminal mais à esquerda em cada passo.",
                                    "Pratique derivando strings de exemplo usando derivação esquerda em uma gramática simples.",
                                    "Compare derivação esquerda com derivação direita para destacar diferenças.",
                                    "Identifique árvores de derivação associadas à derivação esquerda."
                                  ],
                                  "verification": "Desenhe a árvore de derivação esquerda para uma string dada e explique cada passo verbalmente.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Livro de compiladores (ex: Dragon Book, capítulo 4), papel e caneta ou ferramenta de diagramação como Draw.io.",
                                  "tips": "Sempre comece pela esquerda para simular o processo top-down dos parsers.",
                                  "learningObjective": "Compreender como derivações esquerdas modelam a análise sintática de cima para baixo.",
                                  "commonMistakes": "Confundir terminais com não-terminais ou pular passos na derivação."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Mapear Não-Terminais para Funções Recursivas",
                                  "subSteps": [
                                    "Analise uma gramática LL(1) simples e liste todos os não-terminais.",
                                    "Atribua uma função recursiva a cada não-terminal, com nome correspondente.",
                                    "Defina a lógica da função: consumir tokens e chamar recursivamente funções de não-terminais filhos.",
                                    "Estude como a recursão simula expansões de produções na derivação esquerda.",
                                    "Desenhe um fluxograma mostrando chamadas recursivas alinhadas à derivação."
                                  ],
                                  "verification": "Crie um mapeamento escrito de uma gramática para funções e justifique a recursão.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Gramática de exemplo impressa, editor de texto para pseudocódigo.",
                                  "tips": "Use nomes de funções idênticos aos não-terminais para clareza.",
                                  "learningObjective": "Estabelecer a correspondência direta entre não-terminais e funções recursivas em parsers RD.",
                                  "commonMistakes": "Ignorar precedência de chamadas recursivas, levando a loops infinitos."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar um Parser Recursivo Descendente Simples",
                                  "subSteps": [
                                    "Escolha uma gramática para expressões aritméticas: E → T | E + T, T → F | T * F, F → id | (E).",
                                    "Implemente funções E(), T(), F() em uma linguagem como Python ou Java.",
                                    "Adicione lookahead para LL(1), consumindo tokens sequencialmente.",
                                    "Teste com input válido e trace a pilha de chamadas.",
                                    "Corrija erros de sincronização ou backtracking desnecessário."
                                  ],
                                  "verification": "Execute o parser em uma string de input e produza a árvore de parsing correta.",
                                  "estimatedTime": "90 minutos",
                                  "materials": "Editor de código (VS Code), lexer simples ou scanner manual.",
                                  "tips": "Use uma classe global para o token atual para simular lookahead.",
                                  "learningObjective": "Construir um parser funcional que demonstre recursão em ação.",
                                  "commonMistakes": "Não avançar o token corretamente, causando consumo incorreto."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar Simulação da Derivação Esquerda pela Recursão",
                                  "subSteps": [
                                    "Trace a execução do parser passo a passo para uma string específica.",
                                    "Compare o trace com a derivação esquerda manual da mesma string.",
                                    "Identifique como cada chamada recursiva corresponde a uma expansão de produção.",
                                    "Discuta tratamento de recursão esquerda e como LL(1) evita ambiguidades.",
                                    "Experimente com input inválido para ver detecção de erros."
                                  ],
                                  "verification": "Produza um diagrama lado a lado: trace do parser vs. derivação esquerda.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Papel para tracing, debugger do IDE.",
                                  "tips": "Use print statements ou debugger para visualizar pilha recursiva.",
                                  "learningObjective": "Visualizar e validar como recursão espelha derivação esquerda.",
                                  "commonMistakes": "Não alinhar corretamente os passos de recursão com expansões."
                                }
                              ],
                              "practicalExample": "Implemente um parser RD para a gramática de expressões: E → E + T | T, T → T * F | F, F → (E) | id. Para input 'id + id * id', trace como E() chama recursivamente E() e T(), simulando a derivação esquerda: E => E + T => T + T => F + T => id + T => id + T * F => id + F * F => id + id * F => id + id * id.",
                              "finalVerifications": [
                                "Explicar verbalmente como uma chamada recursiva corresponde a uma expansão de não-terminal.",
                                "Implementar e testar parser para 3 strings diferentes com saída correta.",
                                "Desenhar árvore de parsing alinhada à derivação esquerda.",
                                "Identificar e corrigir um erro de recursão infinita em código dado.",
                                "Comparar execução de parser com derivação manual sem discrepâncias.",
                                "Discutir limitações de parsers RD com recursão esquerda."
                              ],
                              "assessmentCriteria": [
                                "Precisão no mapeamento de gramática para funções recursivas (30%).",
                                "Corretude da implementação do parser com testes variados (25%).",
                                "Profundidade na análise de simulação da derivação esquerda (20%).",
                                "Clareza de diagramas e traces (15%).",
                                "Identificação de erros comuns e soluções (10%)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Recursão e indução em funções definidas recursivamente.",
                                "Linguística: Estruturas hierárquicas em gramáticas formais.",
                                "Algoritmos: Análise de complexidade em chamadas recursivas.",
                                "Engenharia de Software: Modularidade via funções recursivas em compiladores."
                              ],
                              "realWorldApplication": "Em compiladores de linguagens como Python (usando pgen) ou JavaScript (esprima.js), parsers RD recursivos analisam código fonte simulando derivações esquerdas para construir ASTs usadas em IDEs, otimizadores e transpilers."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.3.1.3",
                            "name": "Reconhecer a dependência de lookahead",
                            "description": "Explicar o papel do lookahead (um ou mais tokens à frente) para decidir qual produção escolher para um não-terminal.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender o Conceito Básico de Lookahead",
                                  "subSteps": [
                                    "Defina lookahead como a leitura de um ou mais tokens à frente sem consumi-los.",
                                    "Explique que lookahead é usado em parsers recursivos descendentes para resolver ambiguidades.",
                                    "Diferencie lookahead de 0 (LL(0)) de LL(1) ou LL(k), focando em k=1.",
                                    "Identifique que lookahead evita backtracking ao prever a produção correta.",
                                    "Revise a estrutura de uma função parse para um não-terminal."
                                  ],
                                  "verification": "Escreva uma definição curta de lookahead e dê um exemplo simples de uso em pseudocódigo.",
                                  "estimatedTime": "20-30 minutos",
                                  "materials": [
                                    "Documentação de parsers LL(1)",
                                    "Pseudocódigo de parser recursivo descendente"
                                  ],
                                  "tips": [
                                    "Visualize o stream de tokens como uma fila onde você 'espia' o próximo sem remover.",
                                    "Comece com gramáticas simples sem lookahead para contrastar."
                                  ],
                                  "learningObjective": "Compreender o que é lookahead e seu propósito fundamental em parsers.",
                                  "commonMistakes": [
                                    "Confundir lookahead com consumo de tokens.",
                                    "Achar que lookahead é só para LL(k>1)."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar o Papel do Lookahead na Escolha de Produção",
                                  "subSteps": [
                                    "Para um não-terminal A com produções A → α | β, examine o FIRST conjunto de cada produção.",
                                    "Construa a tabela de parsing LL(1) para ver onde lookahead decide entre produções.",
                                    "Simule a decisão: match(next_token) com FIRST(α) vs FIRST(β).",
                                    "Discuta casos onde FIRSTs se sobrepõem, exigindo lookahead.",
                                    "Implemente uma função parse(A) que usa lookahead para branch."
                                  ],
                                  "verification": "Construa uma tabela LL(1) simples para uma gramática com duas produções e identifique a célula dependente de lookahead.",
                                  "estimatedTime": "30-45 minutos",
                                  "materials": [
                                    "Ferramenta online de gerador de tabelas LL(1)",
                                    "Papel e lápis para diagramas"
                                  ],
                                  "tips": [
                                    "Use cores diferentes para FIRST sets de cada produção.",
                                    "Teste com gramáticas left-factored para ver necessidade de lookahead."
                                  ],
                                  "learningObjective": "Reconhecer como lookahead resolve conflitos na seleção de produções alternativas.",
                                  "commonMistakes": [
                                    "Ignorar FOLLOW sets em LL(1).",
                                    "Confundir FIRST com FOLLOW."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Identificar Dependência de Lookahead em Gramáticas Reais",
                                  "subSteps": [
                                    "Escolha uma gramática ambígua como expressões aritméticas (E → T | T + E).",
                                    "Left-factor ou use lookahead para disambiguar + vs outros operadores.",
                                    "Trace o parsing de uma string como 'id + id * id' mostrando decisão no lookahead.",
                                    "Compare parsing com e sem lookahead, destacando falhas.",
                                    "Classifique gramáticas como LL(1) baseadas na ausência de conflitos com lookahead."
                                  ],
                                  "verification": "Trace manualmente o parse de uma sentença e anote onde lookahead foi usado decisivamente.",
                                  "estimatedTime": "25-40 minutos",
                                  "materials": [
                                    "Exemplos de gramáticas de compiladores (ex: Dragon Book)",
                                    "Simulador de parser online"
                                  ],
                                  "tips": [
                                    "Desenhe a árvore de parsing com setas para lookahead.",
                                    "Pratique com gramáticas não-LL(1) para ver erros."
                                  ],
                                  "learningObjective": "Detectar situações específicas onde lookahead é indispensável para correção do parse.",
                                  "commonMistakes": [
                                    "Assumir que toda gramática precisa lookahead.",
                                    "Não considerar precedência de operadores."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Praticar Reconhecimento e Implementação com Lookahead",
                                  "subSteps": [
                                    "Implemente um parser simples em Python ou Java para uma mini-gramática.",
                                    "Adicione prints para mostrar uso de lookahead em decisões.",
                                    "Teste com inputs que forçam diferentes produções via lookahead.",
                                    "Refatore uma gramática não-LL(1) para usar lookahead efetivamente.",
                                    "Avalie o parser com casos de borda onde lookahead resolve ambiguidades."
                                  ],
                                  "verification": "Execute o parser em 3 strings diferentes e documente as decisões de lookahead.",
                                  "estimatedTime": "40-60 minutos",
                                  "materials": [
                                    "Editor de código (VS Code)",
                                    "Biblioteca ANTLR ou parser generator básico"
                                  ],
                                  "tips": [
                                    "Use funções peek() para simular lookahead sem consumir.",
                                    "Debugue com token streams visuais."
                                  ],
                                  "learningObjective": "Aplicar reconhecimento de dependência de lookahead em código prático.",
                                  "commonMistakes": [
                                    "Consumir token acidentalmente durante peek.",
                                    "Não tratar EOF como lookahead."
                                  ]
                                }
                              ],
                              "practicalExample": "Em uma gramática para expressões: Expr → Term (('+'|'-') Expr)? | Term '*' Factor. Ao parsear 'a + b * c', no não-terminal Expr após Term 'a', lookahead vê '+' e escolhe a produção com (+|-), evitando erro se escolhesse '*' por engano.",
                              "finalVerifications": [
                                "Explicar corretamente o que acontece sem lookahead em uma gramática ambígua.",
                                "Construir FIRST sets e identificar conflitos resolvidos por lookahead.",
                                "Trace um parse completo destacando decisões de lookahead.",
                                "Implementar uma função parse que usa lookahead explicitamente.",
                                "Diferenciar gramáticas LL(1) de não-LL(1) baseadas em dependência de lookahead.",
                                "Dar exemplo real de compilador usando lookahead (ex: yacc/bison)."
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição e uso de lookahead (90-100%).",
                                "Capacidade de construir tabelas LL(1) sem erros (80-90%).",
                                "Análise correta de traces de parsing com lookahead (70-80%).",
                                "Implementação funcional de parser com lookahead (60-70%).",
                                "Identificação de dependências em gramáticas complexas (exemplos originais).",
                                "Explicação clara de erros comuns sem lookahead."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Conjuntos FIRST/FOLLOW como teoria de conjuntos e autômatos.",
                                "Linguística: Análise sintática em linguagens naturais (parsing probabilístico).",
                                "Engenharia de Software: Design de parsers em ferramentas como ANTLR ou PEG.js.",
                                "Inteligência Artificial: Parsing em PLN e chatbots com gramáticas.",
                                "Algoritmos: Similaridade com buscas lookahead em jogos (ex: xadrez minimax)."
                              ],
                              "realWorldApplication": "Em compiladores como GCC ou Clang, lookahead em parsers recursivos descendentes permite parsing eficiente de linguagens como C++ sem backtracking, otimizando performance em grandes códigos-fonte; também usado em editores de texto (ex: VS Code syntax highlighting) e validadores JSON/XML."
                            },
                            "estimatedTime": "0.5 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.2.3.2",
                        "name": "Gramáticas Adequadas para Parsing Recursivo Descendente",
                        "description": "Condições das gramáticas LL(1) que permitem a implementação eficiente sem backtracking, incluindo conjuntos FIRST e FOLLOW.",
                        "specificSkills": [
                          {
                            "id": "10.1.2.3.2.1",
                            "name": "Calcular conjuntos FIRST",
                            "description": "Computar o conjunto FIRST de símbolos e produções para prever o primeiro terminal de uma cadeia derivada.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Identificar Componentes da Gramática",
                                  "subSteps": [
                                    "Analise a gramática fornecida e liste todos os símbolos presentes.",
                                    "Classifique cada símbolo como terminal (folhas da árvore de derivação) ou não-terminal (variáveis que aparecem à esquerda de produções).",
                                    "Liste todas as produções no formato A → α, destacando se há produções ε (vazias).",
                                    "Verifique se a gramática é livre de contexto e adequada para parsing recursivo descendente (sem recursão esquerda)."
                                  ],
                                  "verification": "Criar uma tabela com colunas: Símbolo, Tipo (terminal/não-terminal), Produções associadas.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Gramática exemplo impressa ou digital",
                                    "Papel/caneta ou editor de texto"
                                  ],
                                  "tips": "Use maiúsculas para não-terminais e minúsculas/itálicos para terminais por convenção.",
                                  "learningObjective": "Dominar a identificação precisa dos elementos fundamentais de uma gramática.",
                                  "commonMistakes": [
                                    "Confundir identificadores como 'id' com não-terminais",
                                    "Ignorar produções ε que afetam FIRST"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Calcular FIRST para Terminais e Produções Simples",
                                  "subSteps": [
                                    "Para cada terminal t, defina FIRST(t) = {t}.",
                                    "Para não-terminais com produção A → t β (onde t é terminal), adicione t a FIRST(A).",
                                    "Para produções A → ε, adicione ε a FIRST(A).",
                                    "Registre todos os FIRST iniciais em uma tabela."
                                  ],
                                  "verification": "Tabela atualizada com FIRST para todos terminais e casos simples sem conflitos.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Tabela de símbolos do Step 1",
                                    "Marcadores coloridos para terminais vs não-terminais"
                                  ],
                                  "tips": "Comece sempre pelos terminais; eles são a base de todos os FIRST.",
                                  "learningObjective": "Aplicar regras básicas de FIRST para símbolos leaf.",
                                  "commonMistakes": [
                                    "Esquecer ε em produções vazias",
                                    "Adicionar não-terminais a FIRST (FIRST contém apenas terminais ou ε)"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Propagar FIRST Através de Não-Terminais Compostos",
                                  "subSteps": [
                                    "Para produção A → B γ, onde B é não-terminal, adicione FIRST(B) - {ε} a FIRST(A).",
                                    "Se ε ∈ FIRST(B), adicione FIRST(γ) a FIRST(A), recursivamente.",
                                    "Repita para todas as alternativas de A até não haver mudanças (fixpoint).",
                                    "Resolva dependências ordenando não-terminais topologicamente se possível."
                                  ],
                                  "verification": "Todos FIRST atualizados sem alterações em iterações subsequentes.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Tabela do Step 2",
                                    "Algoritmo de fixpoint anotado"
                                  ],
                                  "tips": "Use iteração: liste todos FIRST, atualize em loop até estabilizar.",
                                  "learningObjective": "Mestre a propagação recursiva e detecção de ε.",
                                  "commonMistakes": [
                                    "Parar cedo sem fixpoint",
                                    "Incluir ε incorretamente em FIRST se não nullable"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificar e Finalizar Conjuntos FIRST Completos",
                                  "subSteps": [
                                    "Compile FIRST para todos não-terminais em uma tabela final.",
                                    "Verifique propriedades: FIRST(A) ⊆ terminais ∪ {ε}, disjoint se LL(1).",
                                    "Teste com derivações curtas: primeiro terminal previsto está em FIRST?",
                                    "Documente o processo em pseudocódigo para automação."
                                  ],
                                  "verification": "Tabela final com FIRST corretos validados por pelo menos 3 derivações exemplo.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Tabela dos steps anteriores",
                                    "Exemplos de derivações"
                                  ],
                                  "tips": "Para parsers RD, FIRST deve prever exatamente o lookahead.",
                                  "learningObjective": "Garantir completude e correção dos conjuntos FIRST.",
                                  "commonMistakes": [
                                    "Ciclos infinitos por recursão esquerda (evite gramáticas assim)",
                                    "Omite alternativas de produções"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Praticar com Gramática Complexa",
                                  "subSteps": [
                                    "Aplique o processo completo a uma nova gramática exemplo.",
                                    "Calcule FIRST iterativamente, registrando cada iteração.",
                                    "Compare com solução conhecida ou valide com parser simulado.",
                                    "Refatore a gramática se necessário para LL(1)."
                                  ],
                                  "verification": "Cálculo correto na gramática de prática, com log de iterações.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Gramática de expressões aritméticas",
                                    "Simulador online de FIRST (opcional)"
                                  ],
                                  "tips": "Pratique com gramáticas reais de linguagens como expressões ou JSON.",
                                  "learningObjective": "Consolidar o algoritmo através de prática hands-on.",
                                  "commonMistakes": [
                                    "Não iterar o suficiente em gramáticas com cadeias longas",
                                    "Ignorar FOLLOW para validação LL(1) inicial"
                                  ]
                                }
                              ],
                              "practicalExample": "Gramática de expressões: E → T E' | ( E ); E' → + T E' | ε; T → F T' | id; T' → * F T' | ε; F → ( E ) | id. FIRST(E) = {id, (}; FIRST(T) = {id, (}; FIRST(F) = {id, (}; FIRST(E') = {+, ε}; FIRST(T') = {*, ε}. Processo: Inicie com terminais {id, +, *, (, )}, propague de F para T, etc.",
                              "finalVerifications": [
                                "Lista correta de terminais e não-terminais.",
                                "Tabela de FIRST com fixpoint alcançado (sem mudanças).",
                                "Validação com 3+ derivações: primeiro terminal em FIRST.",
                                "Pseudocódigo do algoritmo escrito.",
                                "Teste em gramática independente com acerto 100%."
                              ],
                              "assessmentCriteria": [
                                "Precisão: Todos FIRST corretos sem ε indevido (90%).",
                                "Completude: Cobertura de todas produções e iterações (80%).",
                                "Eficiência: Algoritmo em O(n) iterações sem loops infinitos (70%).",
                                "Clareza: Tabelas e logs legíveis (60%).",
                                "Aplicação: Correto em exemplo prático não visto (100%)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria de Conjuntos e Fecho Transitivo.",
                                "Lógica: Inferência Dedutiva e Fixpoints.",
                                "Programação: Implementação de Algoritmos em Grafos de Dependência.",
                                "Engenharia de Software: Análise de Dependências em Sistemas."
                              ],
                              "realWorldApplication": "Em compiladores (ex: GCC, Clang), calcula FIRST para gerar parsers recursivos descendentes eficientes, prevendo tokens lookahead sem backtracking, essencial para análise sintática de linguagens como C++, Java ou Python."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.3.2.2",
                            "name": "Calcular conjuntos FOLLOW",
                            "description": "Determinar o conjunto FOLLOW de um não-terminal para identificar terminais que podem segui-lo em uma derivação.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar a gramática e identificar símbolos",
                                  "subSteps": [
                                    "Liste todas as produções da gramática em formato A → α.",
                                    "Identifique e liste todos os terminais (símbolos em aspas ou itálico) e não-terminais (maiúsculos).",
                                    "Determine o símbolo inicial (start symbol) da gramática.",
                                    "Crie uma tabela inicial com colunas para cada não-terminal e seus FOLLOW vazios.",
                                    "Verifique se a gramática é livre de contexto e adequada para parsing recursivo descendente (sem recursão esquerda)."
                                  ],
                                  "verification": "Tabela com não-terminais listados, produções anotadas e distinção clara entre terminais/não-terminais.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Gramática fornecida",
                                    "Papel/caneta ou editor de texto como Notepad++",
                                    "Folha de cálculo para tabelas"
                                  ],
                                  "tips": "Use maiúsculas para não-terminais e aspas para terminais para evitar confusão visual.",
                                  "learningObjective": "Dominar a representação padrão de gramáticas e identificar componentes essenciais.",
                                  "commonMistakes": [
                                    "Confundir terminais com não-terminais",
                                    "Esquecer de anotar o start symbol",
                                    "Não verificar recursão esquerda"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Inicializar os conjuntos FOLLOW",
                                  "subSteps": [
                                    "Adicione o símbolo de fim de entrada '$' ao conjunto FOLLOW do símbolo inicial.",
                                    "Inicialize os conjuntos FOLLOW de todos os outros não-terminais como conjuntos vazios {}.",
                                    "Crie uma cópia da tabela inicial para rastrear mudanças durante iterações.",
                                    "Registre a versão inicial dos conjuntos em uma tabela ou lista."
                                  ],
                                  "verification": "FOLLOW(start) contém apenas '$', e todos os outros FOLLOW estão vazios.",
                                  "estimatedTime": "10 minutos",
                                  "materials": [
                                    "Tabela do Step 1",
                                    "Editor de texto ou planilha"
                                  ],
                                  "tips": "Sempre use chaves {} para representar conjuntos vazios para clareza.",
                                  "learningObjective": "Entender a inicialização baseada na regra fundamental para o start symbol.",
                                  "commonMistakes": [
                                    "Adicionar '$' a múltiplos símbolos",
                                    "Esquecer de inicializar como vazios",
                                    "Não criar cópia para iterações"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Aplicar as regras de FOLLOW iterativamente",
                                  "subSteps": [
                                    "Para cada produção A → α B β: adicione FIRST(β) (excluindo ε) a FOLLOW(B); se β ⇒* ε, adicione FOLLOW(A) a FOLLOW(B).",
                                    "Para cada produção A → α B: adicione FOLLOW(A) diretamente a FOLLOW(B).",
                                    "Para cada produção A → α B β onde β é vazio ou ε, adicione FOLLOW(A) a FOLLOW(B).",
                                    "Percorra todas as produções em ordem e atualize os conjuntos FOLLOW.",
                                    "Repita o processo para todas as produções até que nenhuma mudança ocorra (fixpoint)."
                                  ],
                                  "verification": "Nenhuma adição nova aos conjuntos FOLLOW em uma iteração completa.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Produções listadas",
                                    "Conjuntos FIRST pré-calculados se necessário",
                                    "Tabela de FOLLOW atualizável"
                                  ],
                                  "tips": "Calcule FIRST(β) manualmente se não fornecido; priorize regras de propagação de FOLLOW(A).",
                                  "learningObjective": "Aplicar corretamente as três regras principais de FOLLOW em todas as produções.",
                                  "commonMistakes": [
                                    "Esquecer de excluir ε de FIRST(β)",
                                    "Não propagar FOLLOW(A) quando β ⇒* ε",
                                    "Parar iterações prematuramente"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificar convergência e documentar resultados",
                                  "subSteps": [
                                    "Compare a tabela final com a anterior para confirmar ausência de mudanças.",
                                    "Liste explicitamente cada terminal em cada FOLLOW e justifique sua inclusão com referências às regras/produções.",
                                    "Teste com uma derivação sentencial exemplo para validar um FOLLOW.",
                                    "Registre o número de iterações necessárias para convergência.",
                                    "Resuma os conjuntos FOLLOW finais em formato legível."
                                  ],
                                  "verification": "Justificativas para cada elemento em todos os FOLLOW e confirmação de fixpoint.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Tabelas de iterações",
                                    "Exemplo de derivação sentencial"
                                  ],
                                  "tips": "Use set union (+) para atualizações e evite duplicatas nos conjuntos.",
                                  "learningObjective": "Validar o algoritmo de fixpoint e documentar raciocínio.",
                                  "commonMistakes": [
                                    "Duplicar terminais nos conjuntos",
                                    "Não justificar inclusões",
                                    "Ignorar verificação de convergência"
                                  ]
                                }
                              ],
                              "practicalExample": "Gramática: S → A$, A → aA | bB, B → c. Inicial: FOLLOW(S)={$}. Iteração 1: Para A → aA, FOLLOW(A) += FIRST(ε) ∪ FOLLOW(A) [propagação]; Para A → bB, FOLLOW(B) += FOLLOW(A); Para B → c, nada. Como A é seguido por $, FOLLOW(A)={$}. Então FOLLOW(B)={$}. Sem mudanças: FOLLOW(S)={$}, FOLLOW(A)={$}, FOLLOW(B)={$}.",
                              "finalVerifications": [
                                "Todos os FOLLOW incluem apenas terminais ou $.",
                                "Pode explicar uma derivação que justifica cada terminal em um FOLLOW.",
                                "Algoritmo converge em <10 iterações para gramáticas pequenas.",
                                "FOLLOW(start) sempre contém $.",
                                "Nenhum FOLLOW vazio se gramática completa.",
                                "Teste: Substitua em parser recursivo descendente sem lookahead erros."
                              ],
                              "assessmentCriteria": [
                                "Precisão: 100% dos terminais corretos em cada FOLLOW.",
                                "Completude: Aplicação de todas as regras em todas produções.",
                                "Eficiência: Convergência demonstrada com ≤5 iterações.",
                                "Documentação: Justificativas claras para cada adição.",
                                "Validação: Exemplo de derivação confirma pelo menos um FOLLOW.",
                                "Clareza: Tabelas legíveis e sem erros de sintaxe em conjuntos."
                              ],
                              "crossCurricularConnections": [
                                "Teoria dos Conjuntos (Matemática): Operações de união e inclusão.",
                                "Lógica e Automatos: Estados finitos e transições em parsers.",
                                "Algoritmos: Algoritmo de fixpoint iterativo semelhante a closure.",
                                "Engenharia de Software: Construção de ferramentas de análise léxica/sintática."
                              ],
                              "realWorldApplication": "Em compiladores como GCC ou Clang, conjuntos FOLLOW guiam parsers recursivos descendentes para prever tokens seguintes, otimizando análise sintática em linguagens como C++ ou Java, evitando erros de lookahead e habilitando parsing eficiente em tempo real."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.3.2.3",
                            "name": "Verificar se uma gramática é LL(1)",
                            "description": "Analisar uma gramática para confirmar se ela é LL(1), verificando não-interseção dos FIRST de alternativas e uso de FOLLOW em casos de ε-produções.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar a gramática e identificar símbolos",
                                  "subSteps": [
                                    "Liste todos os não-terminais (variáveis) e terminais da gramática.",
                                    "Identifique o símbolo inicial e todas as produções.",
                                    "Verifique se a gramática está livre de recursão à esquerda e fatoração à esquerda; se não, anote como não LL(1) preliminarmente.",
                                    "Coloque a gramática em uma tabela clara com colunas para não-terminal, produções alternativas.",
                                    "Defina o conjunto de terminais, incluindo o símbolo fim-de-entrada ($)."
                                  ],
                                  "verification": "Confirme que todos os símbolos estão listados corretamente e não há recursão à esquerda detectada.",
                                  "estimatedTime": "15-20 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Editor de texto ou planilha para tabelas",
                                    "Referência: Livro de Compiladores como 'Compilers: Principles, Techniques, and Tools' (Dragon Book)"
                                  ],
                                  "tips": "Comece sempre pela gramática mais simples; desenhe uma árvore de derivação para visualizar.",
                                  "learningObjective": "Entender a estrutura da gramática e pré-requisitos para LL(1).",
                                  "commonMistakes": [
                                    "Ignorar recursão à esquerda",
                                    "Confundir terminais com não-terminais",
                                    "Esquecer o símbolo $"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Calcular os conjuntos FIRST para todos os não-terminais",
                                  "subSteps": [
                                    "Para cada terminal a, FIRST(a) = {a}.",
                                    "Para cada não-terminal X, inicialize FIRST(X) vazio.",
                                    "Iterativamente: para cada produção X → Y1 Y2 ... Yk, adicione FIRST(Y1) a FIRST(X), exceto ε; se ε em todos Yi até algum, propague.",
                                    "Repita até não haver mudanças (fixpoint).",
                                    "Liste FIRST para cada não-terminal em uma tabela."
                                  ],
                                  "verification": "Verifique se FIRST(ε-produção) inclui ε e se os conjuntos são fechados (sem mudanças adicionais).",
                                  "estimatedTime": "20-30 minutos",
                                  "materials": [
                                    "Tabelas em papel ou Excel",
                                    "Algoritmo FIRST da Dragon Book (página 220)"
                                  ],
                                  "tips": "Use um grafo de dependências para ordenar o cálculo; comece por folhas.",
                                  "learningObjective": "Dominar o algoritmo de cálculo de FIRST sets.",
                                  "commonMistakes": [
                                    "Não propagar ε corretamente",
                                    "Incluir ε em FIRST se não nullable",
                                    "Ciclos infinitos sem fixpoint"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular os conjuntos FOLLOW para todos os não-terminais",
                                  "subSteps": [
                                    "Inicialize FOLLOW(S) = {$} onde S é o start symbol; outros vazios.",
                                    "Para cada produção A → α B β, adicione FIRST(β) a FOLLOW(B), exceto ε.",
                                    "Se ε em FIRST(β), adicione FOLLOW(A) a FOLLOW(B).",
                                    "Para A → α B, adicione FOLLOW(A) a FOLLOW(B).",
                                    "Itere até fixpoint e liste em tabela."
                                  ],
                                  "verification": "Confirme que FOLLOW sets são consistentes e incluem $ apenas onde apropriado.",
                                  "estimatedTime": "20-30 minutos",
                                  "materials": [
                                    "Mesmas tabelas do step anterior",
                                    "Pseudocódigo FOLLOW da Dragon Book"
                                  ],
                                  "tips": "Processe produções em ordem reversa para eficiência.",
                                  "learningObjective": "Aplicar algoritmo FOLLOW corretamente.",
                                  "commonMistakes": [
                                    "Esquecer de propagar FOLLOW(A) no final de produção",
                                    "Não incluir $ no start",
                                    "Duplicatas em sets"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificar condições LL(1) para cada não-terminal",
                                  "subSteps": [
                                    "Para cada não-terminal A com produções A → α1 | α2 | ... | αn:",
                                    "Verifique se FIRST(αi) ∩ FIRST(αj) = ∅ para i ≠ j.",
                                    "Para cada αi com ε ∈ FIRST(αi), verifique FIRST(αj) ∩ FOLLOW(A) = ∅ para j com ε ∉ FIRST(αj).",
                                    "Marque violações em uma tabela por não-terminal.",
                                    "Se nenhuma violação em todos A, a gramática é LL(1)."
                                  ],
                                  "verification": "Tabela de verificação completa sem interseções não vazias.",
                                  "estimatedTime": "15-25 minutos",
                                  "materials": [
                                    "Tabelas FIRST e FOLLOW",
                                    "Matriz de interseções"
                                  ],
                                  "tips": "Use conjuntos para checar interseções rapidamente; ferramentas como Python sets ajudam.",
                                  "learningObjective": "Aplicar precisamente as condições de predictibilidade LL(1).",
                                  "commonMistakes": [
                                    "Esquecer checagem com FOLLOW para ε-produções",
                                    "Confundir FIRST de alternativas",
                                    "Ignorar múltiplas produções"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Analisar resultados e concluir",
                                  "subSteps": [
                                    "Revise todas as checagens de steps anteriores.",
                                    "Liste quaisquer violações encontradas.",
                                    "Conclua: 'É LL(1)' ou 'Não é LL(1)' com razões específicas.",
                                    "Sugira correções se não for (ex: left-factoring).",
                                    "Documente o processo completo."
                                  ],
                                  "verification": "Conclusão clara suportada por evidências das tabelas.",
                                  "estimatedTime": "10-15 minutos",
                                  "materials": [
                                    "Todas as tabelas compiladas"
                                  ],
                                  "tips": "Sempre valide com um exemplo de parsing manual.",
                                  "learningObjective": "Sintetizar análise para decisão final.",
                                  "commonMistakes": [
                                    "Concluir prematuramente sem todas checagens",
                                    "Não listar violações específicas"
                                  ]
                                }
                              ],
                              "practicalExample": "Considere a gramática: S → A | B, A → a A | ε, B → b. Calcule FIRST: FIRST(S)={a,b}, FIRST(A)={a,ε}, FIRST(B)={b}. FOLLOW(S)={$}, FOLLOW(A)={$}, FOLLOW(B)={$}. Verificação: Para S, FIRST(A)∩FIRST(B)={a,ε}∩{b}=∅, mas ε em FIRST(A) então FIRST(B)∩FOLLOW(S)={b}∩{$}=∅. Para A: FIRST(aA)={a}, FIRST(ε)={ε}, disjuntos e {a}∩FOLLOW(A)=∅. Para B ok. Conclusão: LL(1).",
                              "finalVerifications": [
                                "Tabelas FIRST e FOLLOW completas e corretas.",
                                "Nenhuma interseção não vazia nas condições LL(1).",
                                "Tratamento correto de ε-produções com FOLLOW.",
                                "Conclusão explícita com justificativa.",
                                "Sem recursão à esquerda detectada.",
                                "Exemplo prático resolvido corretamente."
                              ],
                              "assessmentCriteria": [
                                "Precisão nos cálculos de FIRST e FOLLOW (90% correto).",
                                "Aplicação completa das condições LL(1) sem omissões.",
                                "Clareza nas tabelas e documentação.",
                                "Identificação correta de violações ou confirmação.",
                                "Eficiência no número de iterações (fixpoint mínimo).",
                                "Sugestões de correção se aplicável."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria de Conjuntos e operações de interseção/union.",
                                "Lógica: Algoritmos iterativos e fixpoints (como em programação funcional).",
                                "Engenharia de Software: Análise de dependências em gramáticas formais.",
                                "Algoritmos: Grafos de dependência para ordenação topológica em FIRST/FOLLOW."
                              ],
                              "realWorldApplication": "Em compiladores reais (ex: GCC, Clang), verificar LL(1) garante parsing recursivo descendente eficiente sem backtracking, usado em linguagens como JSON parsers, mini-linguagens de configuração, reduzindo tempo de compilação em desenvolvimento de software."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.2.3.3",
                        "name": "Implementação Prática de Parsers Recursivos Descendentes",
                        "description": "Desenvolvimento de código para funções de parsing, matching de tokens e tratamento básico de erros.",
                        "specificSkills": [
                          {
                            "id": "10.1.2.3.3.1",
                            "name": "Implementar função de matching de tokens",
                            "description": "Escrever uma função que consome um token específico do lookahead e avança o ponteiro de entrada, reportando erro se não corresponder.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Definir a assinatura da função e inicializar variáveis de estado",
                                  "subSteps": [
                                    "Analise a estrutura do parser: identifique o ponteiro de entrada (inputPosition) e o lookahead (próximo token).",
                                    "Defina a assinatura da função match(expectedTokenType), onde expectedTokenType é o tipo de token esperado (ex: 'INT', 'ID').",
                                    "Declare variáveis locais: currentToken = getLookahead() ou tokens[inputPosition].",
                                    "Garanta acesso global ou passado por referência ao array de tokens e ao inputPosition."
                                  ],
                                  "verification": "Verifique se a função compila sem erros e as variáveis estão acessíveis via debugger ou print.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Editor de código (VS Code ou similar)",
                                    "Lexer gerado previamente com lista de tokens",
                                    "Documentação do parser recursivo descendente"
                                  ],
                                  "tips": "Use ponteiro por referência para permitir avanço mutável; evite cópias desnecessárias.",
                                  "learningObjective": "Compreender o estado compartilhado no parser e parametrizar a função para reutilização.",
                                  "commonMistakes": [
                                    "Passar ponteiro por valor em vez de referência",
                                    "Esquecer de importar tipos de tokens",
                                    "Assumir lookahead sem verificar limites"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar a verificação de correspondência do token",
                                  "subSteps": [
                                    "Obtenha o token atual: currentToken = tokens[inputPosition].",
                                    "Compare currentToken.type com expectedTokenType usando == ou equals().",
                                    "Se corresponder, prossiga para o próximo passo; senão, salte para tratamento de erro.",
                                    "Registre o token consumido opcionalmente para depuração (ex: log 'Matched: ' + currentToken.value)."
                                  ],
                                  "verification": "Teste unitário simples: chame match('INT') com input ['INT', ...] e verifique se identifica match.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Framework de testes (Jest ou unittest)",
                                    "Exemplos de stream de tokens de um lexer simples"
                                  ],
                                  "tips": "Use enums para tipos de tokens para evitar erros de string; normalize case se necessário.",
                                  "learningObjective": "Dominar comparação exata de tokens e lookahead sem consumo prematuro.",
                                  "commonMistakes": [
                                    "Comparar valores em vez de tipos",
                                    "Avançar ponteiro antes da verificação",
                                    "Ignorar whitespace ou novos tokens"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Avançar o ponteiro de entrada em caso de sucesso",
                                  "subSteps": [
                                    "Se match confirmado, incremente inputPosition: inputPosition++.",
                                    "Atualize o lookahead chamando nextToken() ou avance o buffer se aplicável.",
                                    "Retorne sucesso (ex: true ou void com exceção só em erro).",
                                    "Opcional: armazene o token consumido em uma pilha de parse para árvore sintática."
                                  ],
                                  "verification": "Após match, verifique inputPosition == posição anterior +1 e lookahead é o próximo token.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Debugger com breakpoints",
                                    "Stream de tokens de teste com múltiplos itens"
                                  ],
                                  "tips": "Mantenha inputPosition dentro dos limites do array para evitar index out of bounds.",
                                  "learningObjective": "Implementar consumo seguro e avançar estado do parser corretamente.",
                                  "commonMistakes": [
                                    "Incrementar múltiplas vezes",
                                    "Não atualizar lookahead",
                                    "Avançar em caso de não-match"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Implementar relatório de erro em caso de falha",
                                  "subSteps": [
                                    "Se não match, construa mensagem de erro: 'Expected ' + expectedTokenType + ' but found ' + currentToken.type + ' at position ' + inputPosition.",
                                    "Lance exceção ParseError com mensagem, posição e token atual.",
                                    "Opcional: adicione recuperação de erro básica (ex: pular token).",
                                    "Garanta que inputPosition não avance em erro."
                                  ],
                                  "verification": "Teste com input mismatch: chame match('INT') com ['ID', ...] e capture exceção com mensagem correta.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Exceções customizadas definidas",
                                    "Testes de erro com try-catch"
                                  ],
                                  "tips": "Inclua linha/coluna do token para erros mais úteis; use console.error para dev.",
                                  "learningObjective": "Gerenciar falhas de parsing com diagnósticos precisos e não avançar estado inválido.",
                                  "commonMistakes": [
                                    "Avançar ponteiro em erro",
                                    "Mensagem genérica sem contexto",
                                    "Não lançar exceção, só retornar false"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Testar e refatorar a função completa",
                                  "subSteps": [
                                    "Escreva testes unitários: match sucesso, match falha, fim de input, múltiplos matches.",
                                    "Integre em um parser simples (ex: match('INT') seguido de match('ID')).",
                                    "Meça cobertura de código e performance em streams grandes.",
                                    "Refatore para legibilidade: adicione comentários e tipos."
                                  ],
                                  "verification": "Todos testes passam (100% cobertura); parser consome stream corretamente sem vazamentos.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Suite de testes completa",
                                    "Exemplos de código fonte como ANTLR ou Tiny Parser"
                                  ],
                                  "tips": "Use mocks para tokens; teste edge cases como empty input.",
                                  "learningObjective": "Validar robustez da função e prepará-la para uso em parsers maiores.",
                                  "commonMistakes": [
                                    "Testes só para sucesso",
                                    "Ignorar EOF",
                                    "Código sem comentários"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um parser para mini-linguagem: def match('INT'); input = ['INT', 'x', '=', '5', ';']; após match('INT'), inputPosition=1, lookahead='x', consumiu 'int' keyword.",
                              "finalVerifications": [
                                "Função avança inputPosition apenas em match sucesso.",
                                "Lança ParseError com posição e tokens corretos em falha.",
                                "Lookahead é atualizado corretamente após consumo.",
                                "Funciona com stream vazio (EOF handling).",
                                "Integra sem erros em parser recursivo descendente maior.",
                                "Cobertura de testes >95%."
                              ],
                              "assessmentCriteria": [
                                "Código limpo, legível com comentários.",
                                "Tratamento de erro preciso e informativo.",
                                "Eficiência O(1) por chamada.",
                                "Reutilizável em diferentes tipos de tokens.",
                                "Sem side-effects indesejados (ex: vazamentos).",
                                "Conformidade com convenções de nomenclatura."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Lógica booleana e estados finitos.",
                                "Inglês: Redação clara de mensagens de erro.",
                                "Design de Software: Princípios SOLID (Single Responsibility).",
                                "Depuração: Técnicas de debugging e logging.",
                                "Algoritmos: Gerenciamento de ponteiros e índices."
                              ],
                              "realWorldApplication": "Essencial em compiladores (GCC, Clang), parsers JSON/XML (browsers), validadores de configurações (Kubernetes YAML), e ferramentas como ESLint para JavaScript."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.3.3.2",
                            "name": "Criar funções recursivas para não-terminais",
                            "description": "Desenvolver procedimentos para cada não-terminal da gramática, invocando recursivamente subproduções com base no lookahead.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Analisar a gramática e identificar não-terminais",
                                  "subSteps": [
                                    "Liste todos os não-terminais presentes na gramática.",
                                    "Para cada não-terminal, anote suas produções possíveis (alternativas).",
                                    "Identifique os terminais e o lookahead necessário para cada produção.",
                                    "Desenhe um diagrama de chamadas recursivas esperado entre funções.",
                                    "Defina o escopo global para o tokenizer e lookahead."
                                  ],
                                  "verification": "Verifique se a lista de não-terminais cobre todas as produções e se o diagrama reflete a recursão corretamente.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Gramática formal, papel ou ferramenta de diagramação como Draw.io, editor de código.",
                                  "tips": "Comece pelos não-terminais folha (sem recursão) para construir de baixo para cima.",
                                  "learningObjective": "Compreender a estrutura da gramática para mapear funções corretamente.",
                                  "commonMistakes": "Ignorar produções ambíguas ou não anotar lookahead explícito."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Definir assinaturas e estruturas iniciais das funções",
                                  "subSteps": [
                                    "Crie uma função para cada não-terminal com assinatura padrão (ex: void parseNome()).",
                                    "Inicialize funções para consumir tokens (match(token)) e lookahead (la() ou peek()).",
                                    "Adicione estruturas de controle como switch ou if baseado em lookahead.",
                                    "Implemente funções auxiliares para terminais simples.",
                                    "Configure variáveis globais para posição atual no stream de tokens."
                                  ],
                                  "verification": "Compile o código sem erros e chame funções vazias sem crash.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Editor de código (VS Code), linguagem como C/Python/Java, gramática anotada.",
                                  "tips": "Use funções match(token) para validar e avançar tokens obrigatórios.",
                                  "learningObjective": "Estabelecer a base modular para o parser recursivo.",
                                  "commonMistakes": "Assinaturas inconsistentes ou esquecer de passar estado do tokenizer."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar lógica recursiva com lookahead nas funções",
                                  "subSteps": [
                                    "Para cada produção de um não-terminal, verifique lookahead e chame sub-funções recursivamente.",
                                    "Implemente backtracking simples se necessário (salve/restore posição).",
                                    "Adicione tratamento de erros para produções inválidas (ex: syntaxError()).",
                                    "Construa árvore sintática abstrata (AST) durante parsing, se aplicável.",
                                    "Teste individualmente cada função com inputs parciais."
                                  ],
                                  "verification": "Execute com input válido e confirme que funções retornam sem erros e consomem tokens esperados.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Editor de código, tokenizer funcional, casos de teste unitários simples.",
                                  "tips": "Sempre avance o lookahead após match para evitar loops infinitos.",
                                  "learningObjective": "Dominar recursão descendente guiada por lookahead.",
                                  "commonMistakes": "Loop recursivo infinito por falta de consumo de tokens ou lookahead incorreto."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Integrar funções e realizar testes completos",
                                  "subSteps": [
                                    "Chame a função raiz do parser (ex: parseProgram()) com stream completo.",
                                    "Crie suíte de testes com entradas válidas, inválidas e edge cases.",
                                    "Depure usando debug prints ou debugger para rastrear chamadas recursivas.",
                                    "Otimize para left-recursion se detectada (reformule gramática).",
                                    "Valide árvore sintática gerada contra input original."
                                  ],
                                  "verification": "Parser aceita inputs válidos e rejeita inválidos com mensagens claras.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Editor com debugger, suíte de testes (JUnit/Pytest), gramática de exemplo.",
                                  "tips": "Use asserts para verificar posição final do token stream == fim.",
                                  "learningObjective": "Garantir robustez e correção do parser completo.",
                                  "commonMistakes": "Não testar recursão profunda ou ambiguidades na gramática."
                                }
                              ],
                              "practicalExample": "Para gramática expr → term | expr + term; term → factor | term * factor; factor → id | (expr): Crie parseExpr() que verifica lookahead '+', chama recursivamente parseExpr(), match('+'), parseTerm(); similar para outras.",
                              "finalVerifications": [
                                "Todas as funções consomem tokens corretamente sem sobras ou faltas.",
                                "Recursão lida com profundidade variável sem stack overflow.",
                                "Tratamento de erro reporta posição exata do syntax error.",
                                "Parser constrói AST fiel à gramática para inputs válidos.",
                                "Testes unitários cobrem 100% das produções.",
                                "Lookahead guia escolhas sem backtracking excessivo."
                              ],
                              "assessmentCriteria": [
                                "Precisão no uso de lookahead para seleção de produções (90% acerto).",
                                "Ausência de loops recursivos infinitos em testes.",
                                "Modularidade: cada função foca em um não-terminal.",
                                "Tratamento robusto de erros com mensagens informativas.",
                                "Eficiência: parsing em tempo linear no tamanho do input.",
                                "Conformidade com gramática: aceita apenas linguagens válidas."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Conceitos de recursão e indução matemática.",
                                "Algoritmos: Análise de complexidade em estruturas recursivas.",
                                "Linguística Computacional: Gramáticas formais e autômatos.",
                                "Engenharia de Software: Design modular e testes unitários."
                              ],
                              "realWorldApplication": "Implementação de parsers em compiladores (GCC, Clang), validadores de JSON/XML em navegadores, interpretadores de linguagens de script (Python, JavaScript) e ferramentas de linting em IDEs."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.3.3.3",
                            "name": "Integrar parser com analisador léxico",
                            "description": "Conectar o parser recursivo descendente ao analisador léxico para obter tokens sequencialmente durante a análise.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Definir a interface entre o analisador léxico e o parser",
                                  "subSteps": [
                                    "Analise a estrutura atual do lexer para identificar funções de geração de tokens (ex: nextToken(), peekToken()).",
                                    "Defina uma classe ou estrutura TokenStream que encapsule o lexer e forneça métodos padronizados como getNextToken(), lookahead(1) e hasNextToken().",
                                    "Atualize o lexer para retornar tokens com tipo, valor e posição (linha/coluna) para melhor depuração.",
                                    "Crie um contrato claro: o parser consumirá tokens via stream, sem acesso direto ao input fonte.",
                                    "Teste o TokenStream isoladamente com um input simples para verificar fluxo sequencial."
                                  ],
                                  "verification": "Execute testes unitários no TokenStream; confirme que tokens são consumidos em ordem sem skips ou duplicatas.",
                                  "estimatedTime": "1-2 hours",
                                  "materials": [
                                    "Código fonte do lexer existente",
                                    "Editor de código (VS Code ou similar)",
                                    "Framework de testes (JUnit ou pytest)"
                                  ],
                                  "tips": [
                                    "Use um buffer circular para lookahead eficiente.",
                                    "Sempre inclua posição do token para erros informativos."
                                  ],
                                  "learningObjective": "Compreender e implementar uma interface desacoplada entre lexer e parser.",
                                  "commonMistakes": [
                                    "Acessar input fonte diretamente no parser.",
                                    "Ignorar handling de EOF no stream.",
                                    "Não validar tipos de token no contrato."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Modificar o parser recursivo descendente para usar o TokenStream",
                                  "subSteps": [
                                    "Injete o TokenStream no construtor do parser como dependência.",
                                    "Substitua parsing de caracteres hardcoded por chamadas a match(expectedTokenType).",
                                    "Implemente um método consume() que avance o stream após match bem-sucedido.",
                                    "Adicione suporte a lookahead para decisões não-greedy em regras de parsing.",
                                    "Refatore funções de parsing existentes (ex: parseExpression()) para usar o novo fluxo de tokens."
                                  ],
                                  "verification": "Compile o parser e verifique se ele inicializa com TokenStream sem erros de compilação.",
                                  "estimatedTime": "2-3 hours",
                                  "materials": [
                                    "Código fonte do parser RD",
                                    "Diagrama de gramática da linguagem alvo",
                                    "Exemplos de input léxico"
                                  ],
                                  "tips": [
                                    "Mantenha estado global mínimo no parser; use o stream para tudo.",
                                    "Log tokens consumidos durante desenvolvimento para depuração."
                                  ],
                                  "learningObjective": "Adaptar um parser standalone para integração modular com lexer.",
                                  "commonMistakes": [
                                    "Esquecer de avançar o stream após match.",
                                    "Usar lookahead excessivo, causando ineficiência.",
                                    "Não tratar exceções de token mismatch graciosamente."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar funções de matching e tratamento de erros",
                                  "subSteps": [
                                    "Crie a função match(tokenType) que verifica lookahead, consome se match, senão lança SyntaxError com contexto.",
                                    "Implemente nextToken() e peekToken() no parser delegando ao stream.",
                                    "Adicione suporte a sincronização de erros: skip tokens até sincronização point (ex: ';' ou EOF).",
                                    "Integre construção de AST durante matches bem-sucedidos.",
                                    "Teste cenários de erro: input inválido, EOF prematuro."
                                  ],
                                  "verification": "Parse inputs inválidos e confirme que erros são reportados com posição correta do token.",
                                  "estimatedTime": "2-3 hours",
                                  "materials": [
                                    "Casos de teste para gramática (válidos e inválidos)",
                                    "Biblioteca de AST básica",
                                    "Debugger de código"
                                  ],
                                  "tips": [
                                    "Use enums para token types para type-safety.",
                                    "Implemente panic mode recovery para parsing robusto."
                                  ],
                                  "learningObjective": "Dominar consumo sequencial de tokens e recovery de erros em parsers.",
                                  "commonMistakes": [
                                    "Match sem lookahead, causando consumo prematuro.",
                                    "Erro recovery que loopa infinitamente.",
                                    "AST incompleto em branches de erro."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Testar e validar a integração completa",
                                  "subSteps": [
                                    "Crie um pipeline end-to-end: input string -> lexer -> tokenstream -> parser -> AST.",
                                    "Escreva testes para gramáticas simples (ex: expressões aritméticas).",
                                    "Meça performance: tempo de parsing e memória para inputs grandes.",
                                    "Depure discrepâncias comparando com parser hardcoded anterior.",
                                    "Documente a integração com exemplos de uso."
                                  ],
                                  "verification": "Todos os testes unitários e de integração passam; AST gerado matches expected output.",
                                  "estimatedTime": "1-2 hours",
                                  "materials": [
                                    "Suite de testes abrangente",
                                    "Ferramentas de profiling (ex: timeit)",
                                    "Exemplos de input reais"
                                  ],
                                  "tips": [
                                    "Comece com gramática mínima viável (MVGP).",
                                    "Use golden files para testes de regressão."
                                  ],
                                  "learningObjective": "Validar integração lexer-parser em cenários reais e escaláveis.",
                                  "commonMistakes": [
                                    "Testes só para casos felizes.",
                                    "Ignorar edge cases como whitespace excessivo ou comentários.",
                                    "Não benchmark performance pós-integração."
                                  ]
                                }
                              ],
                              "practicalExample": "Desenvolva um lexer para tokenizar expressões como '2 + 3 * (4 - 1)' em tokens NUM, PLUS, MULT, LPAREN, etc. Integre com um parser RD que construa uma AST representando a árvore de expressões, consumindo tokens sequencialmente e reportando erros como 'Unexpected token ) at line 1 col 10'.",
                              "finalVerifications": [
                                "Parser consome todos os tokens sequencialmente sem sobras ou skips.",
                                "Tratamento correto de EOF após input válido.",
                                "Detecção e relatório preciso de erros sintáticos com posição.",
                                "Construção completa e correta de AST para inputs válidos.",
                                "Performance aceitável: parsing de 1k tokens em <1s.",
                                "Integração modular: lexer pode ser trocado sem alterar parser."
                              ],
                              "assessmentCriteria": [
                                "Código limpo, modular e bem documentado (90% cobertura de testes).",
                                "Correção semântica: AST reflete gramática precisamente.",
                                "Robustez: recovery de erros permite parsing parcial útil.",
                                "Eficiência: O(1) lookahead, linear no tamanho do input.",
                                "Manutenibilidade: Separação clara de lexer/parser concerns.",
                                "Conformidade com gramática: zero falsos positivos/negativos em testes."
                              ],
                              "crossCurricularConnections": [
                                "Teoria da Computação: Reconhecimento de linguagens regulares (lexer) e context-free (parser).",
                                "Engenharia de Software: Princípios de design modular e injeção de dependências.",
                                "Matemática Discreta: Autômatos finitos e árvores de parsing.",
                                "Desenvolvimento de Software: Test-driven development para componentes críticos.",
                                "Inteligência Artificial: Parsing em PLN e compiladores de IA."
                              ],
                              "realWorldApplication": "Essa integração é o núcleo de compiladores profissionais como GCC/Clang (C++), CPython (Python) e V8 (JavaScript), permitindo análise sintática eficiente em IDEs, linters e transpilers como Babel ou ANTLR-generated parsers em ferramentas empresariais."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.3.3.4",
                            "name": "Implementar tratamento básico de erros",
                            "description": "Adicionar recuperação de erros simples, como pular tokens inválidos ou sincronizar com FOLLOW sets.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender Conceitos Fundamentais de Recuperação de Erros em Parsers RDD",
                                  "subSteps": [
                                    "Estude o conceito de FOLLOW sets na análise sintática: conjunto de terminais que podem seguir um não-terminal na gramática.",
                                    "Revise como erros sintáticos ocorrem em parsers recursivos descendentes (excesso ou falta de tokens esperados).",
                                    "Analise estratégias básicas: panic mode (pular até sincronização) e skipping inválidos.",
                                    "Implemente um FOLLOW set manual para uma gramática simples (ex: expressões aritméticas).",
                                    "Desenhe um fluxograma de detecção de erro em uma função parse não-terminal."
                                  ],
                                  "verification": "Crie um diagrama ou tabela de FOLLOW sets para sua gramática e explique em voz alta como usá-los para sincronização.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Documentação da gramática do parser",
                                    "Papel e caneta para diagramas",
                                    "Referência sobre análise LL(1)"
                                  ],
                                  "tips": "Comece com uma gramática pequena para evitar sobrecarga; use ferramentas como ANTLR para visualizar FOLLOW sets.",
                                  "learningObjective": "Compreender FOLLOW sets e estratégias de recuperação para preparar implementação robusta.",
                                  "commonMistakes": [
                                    "Confundir FOLLOW com FIRST sets",
                                    "Ignorar recursão esquerda na gramática",
                                    "Subestimar impacto de erros em parsing bottom-up"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar Detecção de Erros nas Funções Parse",
                                  "subSteps": [
                                    "Adicione verificação de lookahead em cada função parse não-terminal (ex: if current_token not in expected).",
                                    "Crie uma função auxiliar reportError(token, expected) para logar erros sem interromper.",
                                    "Modifique o consumo de tokens para retornar false em mismatch, propagando erro para cima.",
                                    "Teste detecção com input inválido simples (ex: faltando operador).",
                                    "Garanta que o parser não crash: use try-catch ou flags de erro."
                                  ],
                                  "verification": "Execute parser com input inválido e confirme que erro é reportado sem exceção.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Código base do parser RDD",
                                    "Editor de código",
                                    "Lexer/tokenizer funcional"
                                  ],
                                  "tips": "Use print statements iniciais para debug; evite exceções globais que parem o parse inteiro.",
                                  "learningObjective": "Detectar mismatches de tokens de forma controlada para habilitar recuperação.",
                                  "commonMistakes": [
                                    "Consumir token antes de verificar",
                                    "Não propagar flag de erro para chamadas recursivas",
                                    "Reportar erros duplicados"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar Recuperação por Skipping de Tokens Inválidos",
                                  "subSteps": [
                                    "Crie função skipInvalid(): avance tokenizer até encontrar token em FIRST ou FOLLOW do não-terminal atual.",
                                    "Integre skipInvalid() após detecção de erro em parse functions.",
                                    "Limite skips para evitar loops infinitos (ex: max 5 skips por erro).",
                                    "Teste com input como 'a + b c;' onde 'c' é inválido após operador.",
                                    "Ajuste para pular múltiplos inválidos até sincronizar."
                                  ],
                                  "verification": "Parser deve pular 'c' inválido e parse 'a + b;' corretamente, reportando erro.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Código do Step 2",
                                    "Casos de teste com tokens extras/inválidos",
                                    "Debugger"
                                  ],
                                  "tips": "Sempre cheque FOLLOW após skip para evitar skips excessivos; logue tokens pulados.",
                                  "learningObjective": "Recuperar de tokens extras ou inválidos sem perder o resto do input.",
                                  "commonMistakes": [
                                    "Loop infinito em skips",
                                    "Pular tokens válidos acidentalmente",
                                    "Não resetar lookahead após skip"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Implementar Sincronização com FOLLOW Sets e Testes Finais",
                                  "subSteps": [
                                    "Adicione syncWithFollow(non_terminal): pule até token em FOLLOW(non_terminal).",
                                    "Integre em funções parse: após erro, chame syncWithFollow e continue.",
                                    "Crie tabela de FOLLOW pré-computada ou função dinâmica.",
                                    "Teste cenários: erro em declaração, expressão nested, EOF prematuro.",
                                    "Meça robustez: parser deve processar 80% de inputs inválidos sem crash."
                                  ],
                                  "verification": "Todos testes passam: recupera erros, parse parcial correto, logs claros.",
                                  "estimatedTime": "50 minutos",
                                  "materials": [
                                    "Tabela FOLLOW calculada",
                                    "Suite de testes (válidos/inválidos)",
                                    "Input files variados"
                                  ],
                                  "tips": "Pré-calcule FOLLOW sets em init(); teste com gramáticas ambíguas primeiro em simulação.",
                                  "learningObjective": "Sincronizar parser após erros usando FOLLOW para continuação precisa.",
                                  "commonMistakes": [
                                    "FOLLOW incorreto devido a gramática não LL(1)",
                                    "Não tratar EOF em sync",
                                    "Sync agressivo que pula código válido"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um parser RDD para expressões aritméticas (gramática: Expr -> Term (('+'|'-') Term)*), ao encontrar 'x' após '+' (inválido), reportError, skip até próximo operador ou ';', sync com FOLLOW(Expr) = {')', ';', EOF}, permitindo parse de '2 + x * 3;' como 2 + 3 com warning em 'x'. Código Python: def parseExpr(): if error_flag: syncWithFollow('Expr'); while lookahead in ['+', '-']: consume(); parseTerm();",
                              "finalVerifications": [
                                "Parser não crasha em nenhum input inválido dos testes.",
                                "Logs de erro mostram token inválido e esperado corretamente.",
                                "Parse parcial é correto para código após erro.",
                                "FOLLOW sets usados levam a sincronização em <5 tokens.",
                                "Taxa de recuperação >80% em suite de testes.",
                                "Nenhum loop infinito ou stack overflow em recursão."
                              ],
                              "assessmentCriteria": [
                                "Precisão da detecção: 100% de mismatches detectados.",
                                "Eficácia da recuperação: parser continua após erro sem perda total.",
                                "Eficiência: tempo de parse inválido <2x válido.",
                                "Clareza dos logs: erro legível com contexto (linha, token).",
                                "Robustez: lida com 10+ tipos de erro sintático.",
                                "Conformidade com gramática: FOLLOW/FIRST corretos."
                              ],
                              "crossCurricularConnections": [
                                "Debugging em programação geral: técnicas de graceful degradation.",
                                "Design de software: princípios de fault-tolerance e resiliência.",
                                "Matemática discreta: teoria de conjuntos (FIRST/FOLLOW).",
                                "Engenharia de software: error handling em sistemas distribuídos.",
                                "Inteligência Artificial: parsing em PLN e chatbots."
                              ],
                              "realWorldApplication": "Em compiladores como GCC/Clang, tratamento de erros permite diagnósticos úteis em código bugado sem crash do compiler, ajudando desenvolvedores a fixar erros rapidamente em projetos grandes como kernels ou apps web."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.2.4",
                    "name": "Parsers LL(k)",
                    "description": "Parsers top-down determinísticos que utilizam tabelas de parsing baseadas em k símbolos de lookahead.",
                    "individualConcepts": [
                      {
                        "id": "10.1.2.4.1",
                        "name": "Definição e Características dos Parsers LL(k)",
                        "description": "Parsers top-down determinísticos que utilizam k símbolos de lookahead para decidir a produção a ser aplicada, baseados em gramáticas livres de contexto LL(k).",
                        "specificSkills": [
                          {
                            "id": "10.1.2.4.1.1",
                            "name": "Compreender a notação LL(k)",
                            "description": "Explicar o significado de LL(k), onde LL indica left-to-right scan e leftmost derivation, e k é o número de símbolos de lookahead necessários para parsing determinístico.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender o Contexto de Parsing em Compiladores",
                                  "subSteps": [
                                    "Revise o processo de análise sintática em compiladores: tokenização leva a parsing.",
                                    "Identifique os tipos principais de parsers: top-down (como LL) vs bottom-up (como LR).",
                                    "Leia definições básicas de gramáticas livres de contexto (CFG) e derivações.",
                                    "Anote a importância do parsing determinístico para eficiência.",
                                    "Compare scanning left-to-right com right-to-left em exemplos simples."
                                  ],
                                  "verification": "Escreva um parágrafo resumindo o papel do parsing e mencione LL como top-down.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Livro de Compiladores (ex: Dragon Book, capítulo 4)",
                                    "Notas de aula sobre análise sintática",
                                    "Vídeo introdutório sobre parsers (YouTube: 5-10 min)"
                                  ],
                                  "tips": "Use diagramas para visualizar o fluxo de tokenização -> parsing.",
                                  "learningObjective": "Compreender o papel fundamental do parsing no pipeline de compiladores.",
                                  "commonMistakes": [
                                    "Confundir parsing com lexing (tokenização)",
                                    "Ignorar a distinção top-down vs bottom-up"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Decifrar o Significado de 'LL'",
                                  "subSteps": [
                                    "Analise 'L' primeiro: Left-to-right scan (leitura da entrada da esquerda para direita).",
                                    "Analise o segundo 'L': Leftmost derivation (derivação do não-terminal mais à esquerda primeiro).",
                                    "Compare com LR: Rightmost derivation in reverse.",
                                    "Desenhe um exemplo de derivação leftmost para uma gramática simples como E -> T + E | T.",
                                    "Explique verbalmente: LL = Left-to-right, Leftmost."
                                  ],
                                  "verification": "Crie um diagrama mostrando left-to-right scan e leftmost derivation em uma string de exemplo.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Papel e caneta para diagramas",
                                    "Ferramenta online de gramáticas CFG (ex: JFLAP)",
                                    "Referência: Wikipedia 'LL parser' seção notação"
                                  ],
                                  "tips": "Lembre-se: LL é top-down, predizendo a árvore de parsing da raiz para folhas.",
                                  "learningObjective": "Explicar precisamente o que cada 'L' representa na notação LL(k).",
                                  "commonMistakes": [
                                    "Confundir leftmost com rightmost derivation",
                                    "Pensar que scan é bidirectional"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Compreender o Parâmetro 'k' (Lookahead)",
                                  "subSteps": [
                                    "Defina lookahead: Número de tokens futuros inspecionados para decidir a produção.",
                                    "Diferencie LL(1) (1 token lookahead) de LL(k) para k>1.",
                                    "Estude por que k=1 é comum, mas gramáticas precisam de FIRST/FOLLOW sets.",
                                    "Calcule lookahead para uma gramática ambígua simples, mostrando necessidade de k>1.",
                                    "Discuta limitações: LL(k) requer gramáticas LL(k)-compatíveis."
                                  ],
                                  "verification": "Para uma gramática dada, identifique se é LL(1) e quantos tokens de lookahead são necessários.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Exemplos de gramáticas LL(1) de tutoriais online",
                                    "Calculadora de FIRST/FOLLOW (ferramentas como ANTLR docs)",
                                    "Notas sobre conjuntos FIRST e FOLLOW"
                                  ],
                                  "tips": "Pratique com gramáticas pequenas; evite expressões aritméticas complexas inicialmente.",
                                  "learningObjective": "Identificar o papel do 'k' como lookahead para parsing determinístico.",
                                  "commonMistakes": [
                                    "Confundir lookahead com backtracking",
                                    "Achar que k maior sempre resolve ambiguidades"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Integrar Conceitos em Parsing Determinístico LL(k)",
                                  "subSteps": [
                                    "Revise todos: LL(k) = left-to-right scan, leftmost derivation, k-lookahead.",
                                    "Explique determinístico: Decisão única sem backtrack em cada passo.",
                                    "Construa uma tabela de parsing simples para LL(1).",
                                    "Discuta quando LL(k) falha (gramáticas não LL(k)).",
                                    "Resuma vantagens: Simples implementação, previsível."
                                  ],
                                  "verification": "Explique LL(k) em suas próprias palavras e dê um exemplo completo.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Implementação de LL(1) parser em pseudocódigo",
                                    "Ferramenta de teste: Online LL parser demo",
                                    "Resumo escrito dos 4 passos"
                                  ],
                                  "tips": "Conecte de volta ao contexto de compiladores reais como GCC ou Javac.",
                                  "learningObjective": "Sintetizar a notação LL(k) como parsing determinístico top-down.",
                                  "commonMistakes": [
                                    "Omitir 'determinístico'",
                                    "Confundir com parsers recursivos descent sem lookahead"
                                  ]
                                }
                              ],
                              "practicalExample": "Considere a gramática S -> a S b | ε. Para LL(1), lookahead=1 distingue ε (se próximo token !=a) vs aSb (se a). Parse 'aabb': scan left-to-right, derive leftmost: S=>aSb=>aεb=>aabb.",
                              "finalVerifications": [
                                "Pode definir LL(k) verbalmente sem hesitação?",
                                "Desenha corretamente derivação leftmost com lookahead?",
                                "Diferencia LL(k) de LR(k)?",
                                "Identifica gramática como LL(1) ou requer k>1?",
                                "Explica por que determinístico é crucial?",
                                "Cita exemplo real de uso em compiladores?"
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição de cada componente (LL e k): 30%",
                                "Uso correto de termos técnicos (derivação leftmost, lookahead): 25%",
                                "Capacidade de aplicar em exemplo prático: 20%",
                                "Identificação de limitações e erros comuns: 15%",
                                "Clareza e estrutura na explicação: 10%"
                              ],
                              "crossCurricularConnections": [
                                "Teoria da Computação: Autômatos pushdown e linguagens livres de contexto.",
                                "Matemática: Teoria de grafos para árvores de parsing.",
                                "Programação: Implementação de parsers em linguagens como Python (PLY) ou Java (ANTLR).",
                                "Linguística Computacional: Parsing de linguagem natural similar.",
                                "Engenharia de Software: Ferramentas de desenvolvimento como IDEs com auto-complete."
                              ],
                              "realWorldApplication": "Parsers LL(k), especialmente LL(1), são usados em compiladores de linguagens como Java (ANTLR gera LL(*)), JavaScript (Esprima), e ferramentas como yacc/bison variantes, permitindo análise sintática eficiente em editores de código e transpilers."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.4.1.2",
                            "name": "Identificar características top-down determinísticas",
                            "description": "Diferenciar parsers LL(k) de outros parsers top-down, destacando o uso de tabelas de parsing pré-computadas e a ausência de backtracking.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Conceitos Básicos de Parsers Top-Down",
                                  "subSteps": [
                                    "Defina parser top-down como um algoritmo que constrói a árvore de derivação de cima para baixo, começando do símbolo inicial.",
                                    "Explique como parsers top-down expandem não-terminais seguindo a gramática.",
                                    "Classifique parsers top-down em determinísticos (sem backtracking) e não-determinísticos (com backtracking).",
                                    "Identifique exemplos: recursive descent (pode ter backtracking) vs. predictive parsing.",
                                    "Anote diferenças iniciais entre abordagens com e sem backtracking."
                                  ],
                                  "verification": "Crie um diagrama simples comparando derivação top-down com bottom-up e liste 3 características top-down.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Notas de aula sobre análise sintática",
                                    "Capítulo de livro sobre compiladores (ex: Dragon Book, Cap. 4)"
                                  ],
                                  "tips": "Use diagramas de árvore de análise para visualizar o processo top-down.",
                                  "learningObjective": "Compreender os fundamentos dos parsers top-down para contextualizar LL(k).",
                                  "commonMistakes": "Confundir top-down com bottom-up; assumir que todo top-down usa backtracking."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Estudar Definição e Funcionamento de Parsers LL(k)",
                                  "subSteps": [
                                    "Defina LL(k) como parser top-down determinístico que usa lookahead de k tokens para decidir expansões.",
                                    "Descreva o processo: consulta tabela de parsing M[A, a] onde A é não-terminal e a é string de k tokens.",
                                    "Explique como a gramática deve ser LL(k) para evitar ambiguidades.",
                                    "Revise cálculo de FIRST e FOLLOW sets para k=1 como base.",
                                    "Simule um parsing manual com lookahead k=1 em uma gramática simples."
                                  ],
                                  "verification": "Construa uma tabela de parsing parcial para uma gramática LL(1) dada e simule parsing de uma string.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Ferramenta online de parsing LL(1)",
                                    "Exemplos de gramáticas LL(k) em PDF"
                                  ],
                                  "tips": "Comece com k=1 para simplicidade antes de generalizar para k>1.",
                                  "learningObjective": "Dominar a mecânica interna dos parsers LL(k) e seu uso de lookahead.",
                                  "commonMistakes": "Ignorar FOLLOW sets na construção da tabela; confundir lookahead com backtracking."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Identificar Características Determinísticas Chave",
                                  "subSteps": [
                                    "Destaque a pré-computação da tabela de parsing: elimina decisões em runtime.",
                                    "Explique ausência de backtracking: cada decisão é única baseada em lookahead fixo.",
                                    "Compare com parsers top-down não-determinísticos: backtracking tenta múltiplas expansões.",
                                    "Liste propriedades: eficiência O(n), requer gramática LL(k), top-down puro.",
                                    "Crie uma tabela comparativa: LL(k) vs. Recursive Descent com backtracking."
                                  ],
                                  "verification": "Explique em 3 frases por que LL(k) é determinístico e forneça um contraexemplo de backtracking.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Tabela comparativa de parsers (imagem ou ferramenta)",
                                    "Artigo sobre LL parsers"
                                  ],
                                  "tips": "Memorize: 'Determinístico = Tabela + No Backtrack'.",
                                  "learningObjective": "Reconhecer e articular as características top-down determinísticas de LL(k).",
                                  "commonMistakes": "Achar que todos top-down são LL(k); subestimar importância da pré-computação."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Diferenciar LL(k) de Outros Parsers Top-Down",
                                  "subSteps": [
                                    "Compare LL(k) com predictive parsers (LL(1) é caso especial).",
                                    "Destaque diferenças com recursive descent: LL(k) usa tabelas, recursive pode backtrack.",
                                    "Analise quando uma gramática não é LL(k) e requer backtracking.",
                                    "Estude exemplos reais: gramáticas que falham LL(1) mas succeedem com LL(2).",
                                    "Pratique identificando se um parser descrito é LL(k) ou não."
                                  ],
                                  "verification": "Classifique 5 descrições de parsers como LL(k) ou outro top-down, justificando.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Exercícios de classificação de parsers",
                                    "Compilador open-source com LL(k)"
                                  ],
                                  "tips": "Pergunte: 'Tem tabela pré-computada e lookahead fixo sem retry?' para identificar LL(k).",
                                  "learningObjective": "Diferenciar precisamente LL(k) de variantes top-down não-determinísticas.",
                                  "commonMistakes": "Confundir LL(k) com LR(k); ignorar que recursive descent pode ser LL(1) sem backtrack."
                                }
                              ],
                              "practicalExample": "Dada a gramática S → a A | b B; A → c; B → d. Construa tabela LL(1): M[S,a]=S→aA, M[S,b]=S→bB. Parse 'a c': lookahead 'a' → S→aA, próximo 'c' → A→c. Sem backtrack, tabela decide tudo.",
                              "finalVerifications": [
                                "Explique em suas palavras a ausência de backtracking em LL(k).",
                                "Descreva como tabelas pré-computadas tornam LL(k) determinístico.",
                                "Diferencie LL(k) de um parser recursive descent com backtracking em um exemplo.",
                                "Identifique se uma gramática dada é LL(1) e por quê.",
                                "Simule parsing de uma string usando tabela LL(1) sem erros."
                              ],
                              "assessmentCriteria": [
                                "Precisão na descrição de tabelas pré-computadas (exata e completa).",
                                "Correta explicação da ausência de backtracking vs. outros top-down.",
                                "Uso correto de terminologia: lookahead k, FIRST/FOLLOW.",
                                "Capacidade de diferenciar LL(k) em comparações.",
                                "Exemplos práticos fornecidos sem ambiguidades.",
                                "Eficiência na identificação de características determinísticas."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria de autômatos finitos e conjuntos (FIRST/FOLLOW).",
                                "Algoritmos: Estruturas de dados (tabelas de decisão multidimensionais).",
                                "Engenharia de Software: Design de linguagens e ferramentas de compilação.",
                                "Lógica: Raciocínio determinístico vs. não-determinístico."
                              ],
                              "realWorldApplication": "Em compiladores como o de JavaScript (V8 usa variantes LL), ferramentas como ANTLR geram parsers LL(*), garantindo parsing rápido e previsível em IDEs e transpilers sem ambiguidades em tempo real."
                            },
                            "estimatedTime": "0.5 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.4.1.3",
                            "name": "Explicar o papel do lookahead",
                            "description": "Descrever como os k símbolos de lookahead resolvem ambiguidades na escolha da produção não-terminal inicial.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender os Fundamentos de Parsers LL(k) e o Conceito Básico de Lookahead",
                                  "subSteps": [
                                    "Revise a definição de parsers LL(k): left-to-right scan, leftmost derivation, lookahead de k símbolos.",
                                    "Explique que em LL(1), k=1; em LL(k), usa k símbolos para decidir a produção.",
                                    "Identifique que lookahead permite 'olhar adiante' sem consumir tokens permanentemente.",
                                    "Compare LL(0) (sem lookahead) com LL(1) usando uma tabela de parsing simples.",
                                    "Anote diferenças entre parsing top-down e bottom-up em relação ao lookahead."
                                  ],
                                  "verification": "Crie um diagrama simples mostrando o processo de lookahead em uma gramática LL(1) básica e confirme se identifica o papel inicial.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Notas de aula sobre parsers LL(k)",
                                    "Editor de texto ou papel para diagramas",
                                    "Referência: Livro 'Compilers: Principles, Techniques, and Tools' (Dragon Book), capítulo 4"
                                  ],
                                  "tips": "Use setas para ilustrar o 'olhar adiante' no stream de tokens; evite confundir com backtracking.",
                                  "learningObjective": "Compreender o que é lookahead e sua posição no framework LL(k).",
                                  "commonMistakes": [
                                    "Confundir lookahead com consumo de tokens (lookahead não consome)",
                                    "Achar que LL(k) usa backtracking (é determinístico)"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar Ambiguidade na Escolha da Produção Não-Terminal Inicial",
                                  "subSteps": [
                                    "Analise uma gramática LL(1) que falha: ex. S → a A | a B; A → ε | c; B → d (ambiguidade no 'a').",
                                    "Construa a tabela de parsing FIRST e FOLLOW para mostrar conflito.",
                                    "Simule o parsing manualmente com input 'a c' e 'a d', destacando indecisão após primeiro 'a'.",
                                    "Discuta como sem lookahead extra, múltiplas produções são candidatas.",
                                    "Registre cenários comuns de ambiguidade em gramáticas reais (ex.: expressões if-then-else)."
                                  ],
                                  "verification": "Construa uma tabela de parsing com conflito e explique verbalmente por que há ambiguidade.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Gramática de exemplo impressa",
                                    "Planilha ou ferramenta online como JFLAP para simulação de parsing",
                                    "Calculadora de FIRST/FOLLOW sets"
                                  ],
                                  "tips": "Sempre compute FIRST sets primeiro; foque em prefixos comuns entre produções.",
                                  "learningObjective": "Reconhecer quando e por quê o lookahead é necessário para resolver conflitos.",
                                  "commonMistakes": [
                                    "Ignorar FOLLOW sets na análise",
                                    "Confundir ambiguidade léxica com sintática"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explicar o Mecanismo de Resolução de Ambiguidade com k Símbolos de Lookahead",
                                  "subSteps": [
                                    "Descreva o processo: ao encontrar não-terminal, examine os próximos k tokens sem consumi-los.",
                                    "Estenda FIRST(k) sets para k>1: sequências de k símbolos para distinguir produções.",
                                    "Simule com k=2 na gramática anterior: 'a c' escolhe S→a A; 'a d' escolhe S→a B.",
                                    "Explique generalização: tabela de parsing usa tuplas de k tokens como índice.",
                                    "Compare eficiência: LL(k) com k maior resolve mais gramáticas, mas tabelas crescem exponencialmente."
                                  ],
                                  "verification": "Aplique lookahead=2 em um input de teste e mostre a escolha correta da produção.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Simulador de parser LL(k) online (ex.: https://cyberzhg.github.io/toolbox/llk)",
                                    "Papel para desenhar token stream com janelas de lookahead"
                                  ],
                                  "tips": "Pense no lookahead como uma 'janela deslizante' de k tokens; pratique com k=2 antes de k>2.",
                                  "learningObjective": "Dominar como os k símbolos distinguem produções ambíguas.",
                                  "commonMistakes": [
                                    "Achar que lookahead consome tokens (use peek, não next)",
                                    "Não considerar epsilon-produções em FIRST(k)"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar e Verificar o Papel do Lookahead em Exemplos Práticos",
                                  "subSteps": [
                                    "Teste uma gramática mais complexa: ex. expressões com operadores prefixos vs. postfixos.",
                                    "Construa e preencha uma tabela LL(2) para ela.",
                                    "Parse inputs ambíguos manualmente, destacando papel do lookahead.",
                                    "Discuta limitações: nem toda gramática é LL(k) para k finito.",
                                    "Resuma: lookahead garante unicidade na escolha da produção inicial."
                                  ],
                                  "verification": "Parse dois inputs ambíguos corretamente usando lookahead e explique decisões.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Exemplos de gramáticas de compiladores",
                                    "Ferramenta ANTLR ou similar para validação"
                                  ],
                                  "tips": "Use cores diferentes para tokens no lookahead vs. consumidos.",
                                  "learningObjective": "Aplicar o conceito para validar seu entendimento completo.",
                                  "commonMistakes": [
                                    "Sobrestimar LL(k) para gramáticas left-recursive",
                                    "Esquecer de normalizar gramática (left-factored)"
                                  ]
                                }
                              ],
                              "practicalExample": "Considere a gramática: S → a A | a B; A → c; B → d. Input: 'a c'. Com LL(1), ambíguo após 'a' (ambas produções possíveis). Com lookahead=2, vê 'a c' → escolhe S → a A; para 'a d' → S → a B. Isso resolve a ambiguidade na produção inicial.",
                              "finalVerifications": [
                                "Explique em 1 parágrafo o que é lookahead e seu papel em LL(k).",
                                "Identifique ambiguidade em uma gramática dada e proponha k necessário.",
                                "Simule parsing com lookahead=2 em input fornecido.",
                                "Diferencie FIRST(1) de FIRST(2) em exemplo.",
                                "Discuta por que LL(k) é preferível a backtracking em compiladores.",
                                "Crie diagrama de token stream com lookahead destacado."
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição de lookahead e LL(k) (exata vs. vaga).",
                                "Capacidade de identificar e resolver ambiguidades com exemplos corretos.",
                                "Profundidade na explicação do mecanismo (inclui FIRST(k)?).",
                                "Uso correto de terminologia (ex.: não confunde com consumo de tokens).",
                                "Criatividade e clareza em diagramas/simulações.",
                                "Compreensão de limitações e trade-offs de k maior."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria de Linguagens Formais e Autômatos (Chomsky Hierarchy).",
                                "Lógica: Tabelas de decisão e resolução de conflitos lógicos.",
                                "Programação: Implementação de parsers em linguagens como Python (PLY) ou Java (ANTLR).",
                                "Engenharia de Software: Design de linguagens e ferramentas de desenvolvimento.",
                                "Inteligência Artificial: Parsing em PLN para análise de sentenças naturais."
                              ],
                              "realWorldApplication": "Em compiladores reais como GCC (para C++) ou Javac (Java), lookahead é usado em parsers LL(k)-inspirados para resolver ambiguidades em gramáticas complexas de programação, garantindo parsing eficiente e determinístico sem backtracking, essencial para performance em grandes códigos-fonte."
                            },
                            "estimatedTime": "0.5 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.2.4.2",
                        "name": "Gramáticas LL(k) e Conjuntos FIRST/FOLLOW",
                        "description": "Condições para uma gramática ser LL(k), envolvendo os conjuntos FIRST_k e FOLLOW_k para garantir unicidade nas decisões de parsing.",
                        "specificSkills": [
                          {
                            "id": "10.1.2.4.2.1",
                            "name": "Calcular conjuntos FIRST_k",
                            "description": "Computar o conjunto FIRST_k(A) para não-terminais A, considerando sequências de até k terminais à esquerda das derivações.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar a gramática e identificar componentes",
                                  "subSteps": [
                                    "Analise a gramática LL(k) fornecida e liste todos os não-terminais, terminais e produções.",
                                    "Marque símbolos nullable (que derivam ε) usando um algoritmo auxiliar como computação de NULLABLE.",
                                    "Defina k explicitamente e represente FIRST_k como conjuntos de strings de terminais de comprimento ≤ k.",
                                    "Crie tabelas vazias para FIRST_k de cada não-terminal (use mapas ou sets para strings).",
                                    "Revise a notação: FIRST_k(α) para cadeia α é união de prefixos terminais ≤k de derivações de α."
                                  ],
                                  "verification": "Confirme que todos não-terminais e produções estão listados corretamente sem erros tipográficos.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Gramática de exemplo",
                                    "Papel ou editor de texto",
                                    "Referência de teoria de gramáticas formais"
                                  ],
                                  "tips": "Comece com k pequeno (ex: k=1) para validar compreensão antes de generalizar.",
                                  "learningObjective": "Dominar representação formal da gramática e conceitos iniciais de FIRST_k.",
                                  "commonMistakes": [
                                    "Esquecer símbolos nullable",
                                    "Confundir terminais com não-terminais",
                                    "Ignorar o limite de k símbolos"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Inicializar conjuntos FIRST_k para símbolos básicos",
                                  "subSteps": [
                                    "Para cada terminal t, defina FIRST_k(t) = {t} se |t|=1, ou prefixos ≤k se t for string.",
                                    "Para ε (se aplicável), FIRST_k(ε) = {ε}.",
                                    "Para não-terminais iniciais, defina como vazios.",
                                    "Para cadeias simples (ex: X1 X2 ... Xm), inicialize baseado em primeiros símbolos não-nullable.",
                                    "Registre mudanças em uma tabela de rastreamento para depuração."
                                  ],
                                  "verification": "Verifique que FIRST_k de terminais está correto e não-terminais vazios onde esperado.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Planilha ou código Python para sets",
                                    "Exemplo de gramática simples"
                                  ],
                                  "tips": "Use strings como chaves em dicionários para representar sequências de terminais.",
                                  "learningObjective": "Implementar inicialização correta de FIRST_k para base cases.",
                                  "commonMistakes": [
                                    "Incluir ε incorretamente em terminais",
                                    "Não truncar sequências >k",
                                    "Duplicar entradas idênticas"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Executar iteração fixpoint para propagação",
                                  "subSteps": [
                                    "Para cada não-terminal A com produção A → α, compute FIRST_k(α) recursivamente ou iterativamente.",
                                    "Para cadeia α = X1...Xm: encontre posição do primeiro não-nullable Xi, adicione FIRST_k(Xi) prefixado pelos anteriores.",
                                    "Se nullable até Xi, continue concatenando prefixos até k símbolos ou fim.",
                                    "Atualize FIRST_k(A) com união de todos FIRST_k(α) das produções, truncando >k.",
                                    "Repita para todos não-terminais até nenhum conjunto mudar (fixpoint)."
                                  ],
                                  "verification": "Execute uma iteração manual e confirme que novos elementos foram adicionados corretamente.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Pseudocódigo do algoritmo FIRST_k",
                                    "Ferramenta de desenho para derivações"
                                  ],
                                  "tips": "Implemente em loop while com flag de mudança para detectar convergência.",
                                  "learningObjective": "Aplicar algoritmo iterativo para calcular FIRST_k completo.",
                                  "commonMistakes": [
                                    "Não propagar através de nullables",
                                    "Exceder limite k na concatenação",
                                    "Parar iteração prematuramente"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificar e otimizar o cálculo",
                                  "subSteps": [
                                    "Compare FIRST_k com FIRST_1 esperado para validação cruzada.",
                                    "Teste com derivações específicas: gere strings de ≤k terminais e confirme presença em FIRST_k.",
                                    "Otimize removendo redundâncias ou usando algoritmo mais eficiente (ex: com tabelas de lookahead).",
                                    "Documente o resultado final para cada não-terminal.",
                                    "Discuta limitações para k grande (explosão combinatória)."
                                  ],
                                  "verification": "Gere uma derivação que deva estar em FIRST_k e confirme inclusão; teste uma que não deva e confirme exclusão.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Gramática de teste",
                                    "Calculadora ou simulador de derivações"
                                  ],
                                  "tips": "Use grafos de dependências entre não-terminais para ordem de iteração.",
                                  "learningObjective": "Validar precisão e entender implicações práticas do FIRST_k.",
                                  "commonMistakes": [
                                    "Aceitar fixpoint falso",
                                    "Ignorar recursão esquerda",
                                    "Não testar casos edge como k=0"
                                  ]
                                }
                              ],
                              "practicalExample": "Gramática: E → T E' | ( E ) ; E' → + T E' | ε ; T → id | num . Calcule FIRST_2(E). Resultado esperado inclui {id,...}, {num,...}, {(, ...}, {+, id}, etc., considerando derivações como E → T E' → id + T → id + id.",
                              "finalVerifications": [
                                "Todos FIRST_k(A) são conjuntos de strings ≤k terminais sem duplicatas.",
                                "Cobertura completa: cada produção contribui para pelo menos um FIRST_k.",
                                "Convergência atingida (sem mudanças em iterações finais).",
                                "Compatível com FIRST_1 (subconjunto).",
                                "Casos nullable propagados corretamente.",
                                "Testes de derivações confirmam inclusão/exclusão."
                              ],
                              "assessmentCriteria": [
                                "Precisão: 100% dos FIRST_k corretos para gramática de teste.",
                                "Eficiência: Convergência em ≤10 iterações para gramáticas médias.",
                                "Completude: Tratamento de nullables e concatenações ≤k.",
                                "Clareza: Documentação passo-a-passo legível.",
                                "Generalização: Correto para k=1,2,3 em exemplos variados.",
                                "Robustez: Manejo de recursão esquerda indireta."
                              ],
                              "crossCurricularConnections": [
                                "Teoria de Conjuntos: Operações de união, concatenação e truncamento.",
                                "Algoritmos e Estruturas de Dados: Iteração fixpoint e tabelas hash para strings.",
                                "Matemática Discreta: Linguagens formais e autômatos.",
                                "Lógica Computacional: Predição em parsing descendente.",
                                "Engenharia de Software: Otimização em compiladores."
                              ],
                              "realWorldApplication": "Usado em compiladores (ex: parsers LL(k) no Clang/LLVM) para prever k tokens lookahead, permitindo parsing determinístico eficiente em linguagens como C++ ou Java, reduzindo ambiguidades sintáticas em tempo de compilação."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.2.4.1.1"
                            ]
                          },
                          {
                            "id": "10.1.2.4.2.2",
                            "name": "Calcular conjuntos FOLLOW_k",
                            "description": "Determinar FOLLOW_k(A), os terminais que podem seguir A em derivações, limitados a k símbolos, para preencher entradas da tabela.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Inicializar os conjuntos FOLLOW_k para todos os não-terminais",
                                  "subSteps": [
                                    "Identifique todos os não-terminais (NT) na gramática.",
                                    "Crie um conjunto vazio FOLLOW_k(N) para cada NT N.",
                                    "Para o símbolo inicial S, adicione a string vazia ou '$' (fim de entrada) ao FOLLOW_k(S), dependendo da convenção para k.",
                                    "Liste todas as produções da gramática para referência.",
                                    "Verifique se a gramática é LL(k)-compatível (sem left-recursion, etc.)"
                                  ],
                                  "verification": "Confirme que cada NT tem um conjunto FOLLOW_k vazio ou inicializado corretamente, e S inclui o marcador de fim.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Gramática formal anotada",
                                    "Papel ou editor de texto para tabelas",
                                    "Referência: Capítulo sobre LL(k) parsers (ex: Dragon Book)"
                                  ],
                                  "tips": "Use representações de conjuntos como {ε, a, ab, bc} para strings de até k símbolos; ordene alfabeticamente para facilitar comparações.",
                                  "learningObjective": "Entender a inicialização baseada na estrutura da gramática e no símbolo inicial.",
                                  "commonMistakes": [
                                    "Esquecer de inicializar FOLLOW_k(S) com o marcador de fim",
                                    "Incluir terminais incorretamente nos conjuntos iniciais"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Aplicar a regra para produções do tipo A → α B β, onde β é não-vazio",
                                  "subSteps": [
                                    "Para cada produção A → α B β (B é NT, β ≠ ε):",
                                    "Calcule FIRST_k(β), o conjunto de strings de terminais de até k símbolos iniciando derivações de β.",
                                    "Adicione todos os elementos de FIRST_k(β) ao FOLLOW_k(B).",
                                    "Se FIRST_k(β) inclui ε, pare aqui para esta regra (não propague FOLLOW_k(A)).",
                                    "Registre mudanças em uma tabela de rastreamento."
                                  ],
                                  "verification": "Para cada produção aplicável, verifique se FIRST_k(β) foi corretamente computado e unido a FOLLOW_k(B).",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Tabelas de FIRST_k pré-calculadas",
                                    "Lista de produções",
                                    "Ferramenta de conjuntos como Python sets para prototipagem"
                                  ],
                                  "tips": "Reutilize FIRST_k(β) se já calculado anteriormente; foque em prefixos de exatamente 1 a k terminais.",
                                  "learningObjective": "Dominar a propagação de FIRST_k através de contextos à direita de não-terminais.",
                                  "commonMistakes": [
                                    "Confundir FIRST_k com FOLLOW_k",
                                    "Incluir strings mais longas que k símbolos"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Aplicar a regra para produções do tipo A → α B (no final da produção)",
                                  "subSteps": [
                                    "Para cada produção A → α B (B no final da mão direita):",
                                    "Adicione todos os elementos de FOLLOW_k(A) ao FOLLOW_k(B).",
                                    "Isso propaga o contexto de A para B quando B é o último símbolo.",
                                    "Repita para todas as produções onde um NT aparece no final.",
                                    "Atualize os conjuntos e anote uniões."
                                  ],
                                  "verification": "Confirme que FOLLOW_k(B) inclui FOLLOW_k(A) para todos os casos de B no final de produções de A.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Conjuntos FOLLOW_k atualizados do Step 1-2",
                                    "Lista de produções invertida por posição final"
                                  ],
                                  "tips": "Essa regra é crucial para propagar contextos de cima para baixo na árvore de derivação.",
                                  "learningObjective": "Compreender a propagação vertical de contextos FOLLOW entre não-terminais.",
                                  "commonMistakes": [
                                    "Aplicar esta regra quando há β não-vazio",
                                    "Não iterar após uniões"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Iterar as regras até o ponto fixo (sem mudanças)",
                                  "subSteps": [
                                    "Repita Steps 2 e 3 em loop até que nenhuma adição ocorra em qualquer FOLLOW_k(N).",
                                    "Monitore mudanças por iteração (use cópias dos conjuntos anteriores).",
                                    "Para k>1, expanda strings concatenando prefixos quando necessário (ex: ab + c → abc se |abc|<=k).",
                                    "Teste com uma derivação sentencial para validar.",
                                    "Documente o número de iterações necessárias."
                                  ],
                                  "verification": "Execute uma iteração final sem mudanças; compare com derivações manuais.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Planilha ou script para automação de iterações",
                                    "Exemplos de derivações da gramática"
                                  ],
                                  "tips": "Limite iterações a |NT| * k para eficiência; use grafos de dependência se complexo.",
                                  "learningObjective": "Implementar o algoritmo iterativo completo para convergência.",
                                  "commonMistakes": [
                                    "Parar prematuramente antes do fixpoint",
                                    "Erros em concatenação de k-strings"
                                  ]
                                }
                              ],
                              "practicalExample": "Gramática: S → E; E → T | E + T; T → id | ( E ). Para k=1, FOLLOW_1(E) = {$, )}; FOLLOW_1(T) = {+, $, )}. Para k=2, expanda para strings como '+', '$', ')', '+id', etc., via iterações: Inicial: FOLLOW_1(S)={$}. Propague de S→E para FOLLOW_1(E)={$}, de E→E+T para FIRST_1(T)={id,(} em FOLLOW_1(T), etc., iterando até fixpoint.",
                              "finalVerifications": [
                                "Todos FOLLOW_k(N) são fechados sob as regras (nenhuma adição em iteração final).",
                                "Validação por derivação: Para cada w em FOLLOW_k(A), existe derivação A α ⇒* γ A w δ.",
                                "|FOLLOW_k(N)| é razoável (não explode além de terminais^k).",
                                "Conjuntos são prefixo-fechados (se ab em conjunto, a também).",
                                "Comparação com FOLLOW_1 como subconjunto.",
                                "Sem ε em FOLLOW_k exceto possivelmente para S."
                              ],
                              "assessmentCriteria": [
                                "Precisão: Conjuntos finais idênticos ao esperado (90%+ match).",
                                "Completude: Todas produções processadas em todas iterações.",
                                "Eficiência: Convergência em <= |NT| iterações.",
                                "Documentação: Tabelas claras de mudanças por step.",
                                "Validação: Pelo menos 2 derivações confirmam cada FOLLOW_k.",
                                "Tratamento de k>1: Strings concatenadas corretamente sem overflow."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria de conjuntos, fechamento transitivo, autômatos finitos.",
                                "Algoritmos: Algoritmos iterativos fixpoint (como Warshall para transitividade).",
                                "Lógica: Inferência em regras de produção como sistema dedutivo.",
                                "Engenharia de Software: Análise de dependências em parsing de linguagens."
                              ],
                              "realWorldApplication": "Em compiladores (GCC, Clang), calcular FOLLOW_k otimiza tabelas de parsing LL(k) para linguagens como C++, permitindo análise sintática eficiente e detecção precoce de erros em código fonte."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.2.4.2.1"
                            ]
                          },
                          {
                            "id": "10.1.2.4.2.3",
                            "name": "Verificar se uma gramática é LL(k)",
                            "description": "Aplicar critérios de LL(k): para cada produção A → α, FIRST_k(α) e FOLLOW_k(A) não se sobrepõem com outras produções de A.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Calcular os conjuntos FIRST_k para todos os símbolos e strings da gramática",
                                  "subSteps": [
                                    "Liste todos os terminais, não-terminais e produções da gramática.",
                                    "Inicialize FIRST_k(X) como vazio para cada símbolo X.",
                                    "Para terminais t, defina FIRST_k(t) = {t} se k>=1.",
                                    "Para não-terminais A, itere recursivamente: para cada produção A → X1...Xn, adicione FIRST_k(X1...Xi) até não-nullable.",
                                    "Repita iterações até fixpoint (sem mudanças nos conjuntos)."
                                  ],
                                  "verification": "Verifique se todos FIRST_k estabilizaram e não há mudanças em iterações subsequentes.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Papel e caneta ou editor de texto",
                                    "Tabela da gramática impressa",
                                    "Calculadora para k>1 (sequências de k símbolos)"
                                  ],
                                  "tips": "Comece com FIRST_1 e generalize para k; use tabelas para rastrear dependências.",
                                  "learningObjective": "Dominar o algoritmo de cálculo de FIRST_k, incluindo handling de nullable símbolos.",
                                  "commonMistakes": [
                                    "Esquecer de propagar através de nullable símbolos",
                                    "Não iterar até fixpoint",
                                    "Confundir FIRST_k de strings com símbolos únicos"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Calcular os conjuntos FOLLOW_k para todos os não-terminais",
                                  "subSteps": [
                                    "Inicialize FOLLOW_k($) = {$} (fim de entrada).",
                                    "Para cada produção B → α A β, adicione FIRST_k(β) a FOLLOW_k(A); se β nullable, adicione FOLLOW_k(B).",
                                    "Para o símbolo inicial S, FOLLOW_k(S) inclui {$}.",
                                    "Itere sobre todas as produções até que FOLLOW_k estabilizem.",
                                    "Para k>1, considere sequências de k símbolos após o não-terminal."
                                  ],
                                  "verification": "Confirme que FOLLOW_k não mudam em iterações adicionais e incluem todos os contextos possíveis.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Tabelas de FIRST_k do passo anterior",
                                    "Lista de produções",
                                    "Folha de cálculo para tracking de conjuntos"
                                  ],
                                  "tips": "Mantenha FOLLOW_k separados por não-terminal; priorize produções que terminam com não-terminais.",
                                  "learningObjective": "Entender como FOLLOW_k captura contextos à direita, essencial para LL(k).",
                                  "commonMistakes": [
                                    "Não adicionar FOLLOW_k(B) quando β é nullable",
                                    "Esquecer FOLLOW_k do start symbol",
                                    "Ignorar k-lookahead em sequências múltiplas"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Computar os conjuntos de lookahead LL_k para cada produção de cada não-terminal",
                                  "subSteps": [
                                    "Para cada não-terminal A com produções A → α1 | α2 | ... | αm, selecione A.",
                                    "Para cada αi, determine se αi é nullable (deriva ε).",
                                    "Se não nullable, LL_k(αi) = FIRST_k(αi).",
                                    "Se nullable, LL_k(αi) = FIRST_k(αi) ∪ FOLLOW_k(A).",
                                    "Registre todos os LL_k(αi) para A em uma tabela."
                                  ],
                                  "verification": "Liste explicitamente os LL_k para cada alternativa de A e confirme inclusão de FOLLOW se nullable.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Conjuntos FIRST_k e FOLLOW_k calculados",
                                    "Tabela por não-terminal A"
                                  ],
                                  "tips": "Nullable check: veja se há caminho para ε nas derivadas.",
                                  "learningObjective": "Construir lookahead sets que capturam quando escolher cada produção.",
                                  "commonMistakes": [
                                    "Não unir FOLLOW_k para nullables",
                                    "Calcular FIRST_k incorreto para αi longa",
                                    "Esquecer múltiplas produções por A"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificar disjointness dos conjuntos de lookahead para cada não-terminal",
                                  "subSteps": [
                                    "Para cada A com m>1 produções, pegue os LL_k(α1), ..., LL_k(αm).",
                                    "Para cada par i≠j, compute interseção LL_k(αi) ∩ LL_k(αj).",
                                    "Se qualquer interseção não-vazia, gramática NÃO é LL(k).",
                                    "Se todas disjuntas para todo A, gramática É LL(k).",
                                    "Documente violações específicas com exemplos de tokens conflitantes."
                                  ],
                                  "verification": "Afirme 'LL(k): Sim/Não' com justificativa por A violador.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Tabelas de LL_k do passo 3",
                                    "Ferramenta de conjuntos como Python sets para interseções"
                                  ],
                                  "tips": "Use diagramas de Venn para visualizar overlaps; teste com k-lookaheads específicos.",
                                  "learningObjective": "Aplicar critério de determinismo para parsers LL(k).",
                                  "commonMistakes": [
                                    "Verificar apenas FIRST sem FOLLOW",
                                    "Ignorar pares i=j (auto-interseção)",
                                    "Confundir com LR(k) critérios"
                                  ]
                                }
                              ],
                              "practicalExample": "Gramática: S → A a | b; A → c | ε. Para k=1: FIRST_1(A a)={c}, FIRST_1(b)={b}, FOLLOW_1(S)={$}, FOLLOW_1(A)={a,$}. LL_1(A→c)={c}, LL_1(A→ε)={a,$}. Disjuntos. Para S: LL_1(S→A a)={c,a? wait, FIRST_1(A a)=FIRST_1(A)U if null {a}={c,a}, LL_1(S→b)={b}. Disjuntos se a≠b. Verifique passo a passo.",
                              "finalVerifications": [
                                "Calcule corretamente FIRST_k e FOLLOW_k para uma gramática dada.",
                                "Identifique nullables e aplique união com FOLLOW_k.",
                                "Detecte overlaps em LL_k sets com exemplo concreto.",
                                "Conclua corretamente se é LL(k) ou não, justificando.",
                                "Explique uma violação em termos de ambiguidade de parsing.",
                                "Generalize para k=2 com sequências de lookahead."
                              ],
                              "assessmentCriteria": [
                                "Precisão nos cálculos de FIRST_k e FOLLOW_k (100% correto).",
                                "Correta identificação de nullables e lookahead sets.",
                                "Detecção precisa de overlaps sem falsos positivos/negativos.",
                                "Clareza na documentação de steps e tabelas.",
                                "Eficiência: tempo dentro dos estimados.",
                                "Capacidade de debugar erros comuns em cálculos."
                              ],
                              "crossCurricularConnections": [
                                "Teoria dos Conjuntos: operações de união, interseção e diferença.",
                                "Matemática Discreta: autômatos e linguagens formais.",
                                "Lógica: predicados de disjointness e fixpoints iterativos.",
                                "Programação: implementação em código de algoritmos FIRST/FOLLOW."
                              ],
                              "realWorldApplication": "Em compiladores de linguagens como JavaScript ou Python, verificar se a gramática da linguagem é LL(k) permite construir parsers descendentes recursivos eficientes e previsíveis, evitando backtracking e acelerando análise sintática em ferramentas como ESLint ou Babel."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.2.4.2.2"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "10.1.2.4.3",
                        "name": "Construção e Uso da Tabela de Parsing LL(k)",
                        "description": "Geração da tabela M[A, a] onde A é não-terminal e a é sequência de k terminais, indicando a produção a expandir.",
                        "specificSkills": [
                          {
                            "id": "10.1.2.4.3.1",
                            "name": "Construir a tabela de parsing",
                            "description": "Preencher a tabela LL(k) usando regras: para cada produção A → α, inserir em M[A, w] onde w ∈ FIRST_k(α) se α não deriva ε, ou também FOLLOW_k(A) se deriva.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Identificar e listar todas as produções da gramática",
                                  "subSteps": [
                                    "Analise a gramática LL(k) fornecida e identifique o símbolo inicial.",
                                    "Liste todas as produções no formato A → α, separando não-terminais (maiúsculos) e terminais (minúsculos ou símbolos).",
                                    "Determine o valor de k (lookahead) da gramática.",
                                    "Identifique símbolos anuláveis (que derivam ε).",
                                    "Crie uma tabela ou lista organizada das produções."
                                  ],
                                  "verification": "Verifique se todas as produções estão listadas sem duplicatas e com símbolos corretamente classificados.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Editor de texto ou planilha (Google Sheets/Excel)",
                                    "Definição da gramática LL(k)"
                                  ],
                                  "tips": "Use convenções padrão: não-terminais em maiúsculo, terminais em minúsculo. Anote anulabilidades imediatamente.",
                                  "learningObjective": "Compreender a estrutura da gramática e preparar dados para cálculos de FIRST e FOLLOW.",
                                  "commonMistakes": [
                                    "Confundir terminais com não-terminais",
                                    "Omitir produções recursivas",
                                    "Ignorar o valor de k"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Calcular os conjuntos FIRST_k para não-terminais e sequências α",
                                  "subSteps": [
                                    "Para cada não-terminal A, inicialize FIRST_k(A) como vazio.",
                                    "Para terminais a, FIRST_k(a) = {a} (se |a| <= k).",
                                    "Para produções A → X1 X2 ... Xm, adicione FIRST_k(X1...Xi) até cobrir k símbolos ou nullable.",
                                    "Propague recursivamente para dependências, iterando até fixpoint.",
                                    "Calcule FIRST_k(α) para cada lado direito α de produções."
                                  ],
                                  "verification": "Compare FIRST_k calculados com exemplos conhecidos ou valide com lookahead de k símbolos.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Planilha para conjuntos",
                                    "Ferramenta online de FIRST/FOLLOW (opcional)",
                                    "Lista de produções do step 1"
                                  ],
                                  "tips": "Use tabelas para rastrear iterações em gramáticas recursivas. Comece por folhas (produções para terminais).",
                                  "learningObjective": "Dominar o algoritmo de FIRST_k e lidar com anulabilidades e recursão.",
                                  "commonMistakes": [
                                    "Não propagar através de anuláveis",
                                    "Exceder lookahead k",
                                    "Esquecer recursão esquerda"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular os conjuntos FOLLOW_k para não-terminais",
                                  "subSteps": [
                                    "Inicialize FOLLOW_k(S) com {$} para símbolo inicial S.",
                                    "Para cada produção A → α B β onde B é não-terminal, adicione FIRST_k(β) a FOLLOW_k(B).",
                                    "Se β é anulável, adicione FOLLOW_k(A) a FOLLOW_k(B).",
                                    "Para A → α B, adicione FOLLOW_k(A) a FOLLOW_k(B).",
                                    "Itere até fixpoint para todas produções."
                                  ],
                                  "verification": "Verifique se FOLLOW_k(A) contém apenas terminais válidos e é fechado sob as regras.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Planilha atualizada",
                                    "Lista de FIRST_k do step 2",
                                    "Produções anotadas"
                                  ],
                                  "tips": "Priorize FOLLOW do símbolo inicial. Use sets para evitar duplicatas.",
                                  "learningObjective": "Entender como FOLLOW_k captura contextos de chamada em parsing top-down.",
                                  "commonMistakes": [
                                    "Não adicionar FOLLOW(A) quando β anulável",
                                    "Confundir com FIRST",
                                    "Omitir $ no inicial"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Preencher a tabela de parsing LL(k) M[A, w]",
                                  "subSteps": [
                                    "Crie uma tabela com linhas para não-terminais A e colunas para terminais w (lookahead de k símbolos).",
                                    "Para cada produção A → α: se α não anulável, adicione 'A → α' em M[A, w] para w em FIRST_k(α).",
                                    "Se α anulável (deriva ε), adicione também para w em FOLLOW_k(A).",
                                    "Preencha todas as entradas; detecte conflitos (múltiplas produções em [A,w]).",
                                    "Valide a tabela: cada [A,w] deve ter no máximo uma entrada."
                                  ],
                                  "verification": "Simule parsing com lookahead em entradas de amostra; sem conflitos na tabela.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Planilha ou tabela em LaTeX/Markdown",
                                    "Conjuntos FIRST_k e FOLLOW_k",
                                    "Lista de terminais possíveis"
                                  ],
                                  "tips": "Use cores para destacar entradas populadas. Liste terminais exaustivamente.",
                                  "learningObjective": "Aplicar regras para construir tabela determinística LL(k).",
                                  "commonMistakes": [
                                    "Adicionar FOLLOW só quando não anulável",
                                    "Ignorar k em w multi-símbolo",
                                    "Conflitos não detectados"
                                  ]
                                }
                              ],
                              "practicalExample": "Gramática LL(1): S → E; E → T E'; E' → + T E' | ε; T → F T'; T' → * F T' | ε; F → ( E ) | id. Calcule FIRST_1: FIRST(E)={id,(}, etc. FOLLOW(E)={$ , ) , +}. Tabela exemplo: M[E, id] = E → T E'; M[E, (] = E → T E'; sem conflitos.",
                              "finalVerifications": [
                                "Tabela preenchida sem conflitos para gramática de teste.",
                                "Simulação de parsing com 3 strings aceita/rejeita corretamente.",
                                "FIRST_k e FOLLOW_k validados com algoritmo manual.",
                                "Todas entradas de M[A,w] justificadas por regras.",
                                "Detecção correta de anulabilidades.",
                                "Lookahead respeita k=1 ou especificado."
                              ],
                              "assessmentCriteria": [
                                "Precisão nos cálculos de FIRST_k e FOLLOW_k (100% correto).",
                                "Completude da tabela (todas produções inseridas adequadamente).",
                                "Ausência de conflitos e explicação de regras usadas.",
                                "Clareza na documentação de passos e justificativas.",
                                "Eficiência no tempo e detecção de erros comuns.",
                                "Validação prática via simulação de parsing."
                              ],
                              "crossCurricularConnections": [
                                "Teoria dos Conjuntos (operações de união, fixpoint em Matemática).",
                                "Lógica Formal e Autômatos (reconhecimento de linguagens).",
                                "Algoritmos e Estruturas de Dados (tabelas hash-like).",
                                "Engenharia de Software (ferramentas de compilação como ANTLR).",
                                "Matemática Discreta (relações e funções em gramáticas)."
                              ],
                              "realWorldApplication": "Em compiladores reais (ex: GCC, Clang, Javac), tabelas LL(k) aceleram análise sintática top-down em linguagens como C++, Java; ferramentas como yacc/bison geram parsers otimizados para apps web/mobile."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.2.4.2.3"
                            ]
                          },
                          {
                            "id": "10.1.2.4.3.2",
                            "name": "Executar o algoritmo de parsing LL(k)",
                            "description": "Simular o parsing com pilha: consultar tabela com não-terminal no topo e lookahead atual, expandir ou combinar conforme entrada.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Inicializar a estrutura de parsing",
                                  "subSteps": [
                                    "Carregue a gramática e a tabela de parsing LL(k) para a linguagem alvo.",
                                    "Inicialize a pilha com o símbolo inicial (ex: S') no topo.",
                                    "Configure o ponteiro de entrada na posição inicial da string de entrada.",
                                    "Gere o lookahead de k tokens a partir da entrada atual.",
                                    "Registre o estado inicial para depuração."
                                  ],
                                  "verification": "Verifique se a pilha contém apenas o símbolo inicial, o ponteiro está em 0 e o lookahead é correto.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Tabela de parsing LL(k), gramática formal, string de teste, papel e caneta ou simulador online.",
                                  "tips": "Use um símbolo augmentado como S' → S para simplificar o fim do parsing.",
                                  "learningObjective": "Entender a configuração inicial que permite a simulação determinística do parser.",
                                  "commonMistakes": "Esquecer de inicializar o lookahead com exatamente k tokens ou usar símbolo errado na pilha."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Consultar tabela e executar ação no loop principal",
                                  "subSteps": [
                                    "Examine o topo da pilha (deve ser não-terminal) e o lookahead atual.",
                                    "Consulte a entrada correspondente na tabela de parsing LL(k).",
                                    "Se MATCH: pop topo da pilha e avance ponteiro de entrada.",
                                    "Se EXPANDIR: substitua topo por produção escolhida e empilhe reverso.",
                                    "Se ERRO: registre falha de parsing."
                                  ],
                                  "verification": "Simule uma iteração completa e confirme que pilha e entrada foram atualizadas corretamente.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Tabela de parsing impressa ou digital, string de entrada anotada.",
                                  "tips": "Sempre leia a tabela como [não-terminal][lookahead] para ação exata.",
                                  "learningObjective": "Dominar a decisão determinística baseada na tabela LL(k).",
                                  "commonMistakes": "Confundir MATCH com EXPANDIR ou não empilhar símbolos na ordem reversa."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Gerenciar lookahead e avançar entrada",
                                  "subSteps": [
                                    "Após MATCH ou EXPANDIR, avance o ponteiro de entrada em 1.",
                                    "Atualize o lookahead consumindo o token atual e lendo os próximos k-1.",
                                    "Verifique se fim da entrada foi atingido (EOF).",
                                    "Se pilha tem terminal, force MATCH ou detecte erro.",
                                    "Continue loop até pilha vazia ou erro."
                                  ],
                                  "verification": "Confirme que lookahead é sempre de tamanho k e entrada avança corretamente.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Simulador de pilha (ex: Python stack), tokens da entrada listados.",
                                  "tips": "Trate EOF como token especial no lookahead.",
                                  "learningObjective": "Controlar o consumo sequencial da entrada sem backtracking.",
                                  "commonMistakes": "Avançar lookahead incorretamente ou ignorar EOF no fim."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Concluir parsing e verificar resultado",
                                  "subSteps": [
                                    "Pare quando pilha estiver vazia e entrada totalmente consumida.",
                                    "Se pilha vazia e ponteiro no EOF: aceite como válido.",
                                    "Caso contrário (pilha não vazia ou erro detectado): rejeite.",
                                    "Registre a árvore de parsing derivada da simulação.",
                                    "Compare com parsing esperado."
                                  ],
                                  "verification": "Pilha vazia E ponteiro no fim da entrada = sucesso.",
                                  "estimatedTime": "10 minutos",
                                  "materials": "Registro de passos anteriores, diagrama de árvore sintática.",
                                  "tips": "Desenhe a árvore de derivação durante o processo para visualização.",
                                  "learningObjective": "Reconhecer condições de aceitação/rejeição no algoritmo LL(k).",
                                  "commonMistakes": "Aceitar parsing com entrada sobrando ou pilha não vazia."
                                }
                              ],
                              "practicalExample": "Gramática: S → a S b | ε. String: 'a a b b'. Tabela LL(1): Para S e lookahead 'a' → S → a S b. Inicialize pilha: [$ S], entrada: a a b b $. Simule: Topo S + 'a' → expandir para b S a (reverso). Continue até pilha [$] e entrada vazia.",
                              "finalVerifications": [
                                "Pilha está vazia após simulação.",
                                "Ponteiro de entrada aponta para EOF.",
                                "Nenhum erro de tabela foi acionado.",
                                "Árvore de parsing corresponde à string.",
                                "Lookahead foi gerenciado corretamente em todas iterações.",
                                "Tempo de execução é linear na entrada."
                              ],
                              "assessmentCriteria": [
                                "Precisão na consulta da tabela LL(k) (100% correto).",
                                "Correta manipulação de pilha (push/pop/substituição).",
                                "Atualização precisa do lookahead de k tokens.",
                                "Detecção correta de MATCH/EXPANDIR/ERRO.",
                                "Conclusão válida (aceitar/rejeitar com justificativa).",
                                "Documentação clara dos passos simulados."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Autômatos de empilhamento e linguagens livres de contexto.",
                                "Lógica: Tabelas de decisão e fluxos condicionais determinísticos.",
                                "Engenharia de Software: Construção de compiladores e interpretadores.",
                                "Algoritmos: Simulação de processos iterativos com estados."
                              ],
                              "realWorldApplication": "Em compiladores como GCC ou Clang, o algoritmo LL(k) é usado para análise sintática rápida de código-fonte, permitindo detecção precoce de erros de sintaxe em linguagens como C++ ou Java, otimizando o ciclo de desenvolvimento de software."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.2.4.3.1"
                            ]
                          },
                          {
                            "id": "10.1.2.4.3.3",
                            "name": "Tratar conflitos e erros na tabela",
                            "description": "Identificar múltiplas entradas (conflitos) na tabela e estratégias como reescrita de gramática ou aumento de k para resolução.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Identificar conflitos e erros na tabela de parsing LL(k)",
                                  "subSteps": [
                                    "Revise a gramática e a tabela de parsing gerada, focando em células que contêm múltiplas entradas (produções ou ações).",
                                    "Liste todas as células com conflitos, anotando o não-terminal, o lookahead de k tokens e as produções conflitantes.",
                                    "Classifique os erros iniciais, como células vazias (não cobertas) ou entradas inválidas (ex.: shift em estado final).",
                                    "Use uma ferramenta de visualização ou imprima a tabela para inspeção manual.",
                                    "Documente o número total de conflitos encontrados."
                                  ],
                                  "verification": "Confirme que uma lista completa de conflitos foi criada e que nenhuma célula conflitante foi omitida, comparando com a tabela original.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Tabela de parsing LL(k) gerada",
                                    "Gramática fonte em notação BNF",
                                    "Editor de texto ou planilha para anotar conflitos"
                                  ],
                                  "tips": "Comece pelas primeiras linhas da tabela; conflitos em lookaheads curtos são mais comuns em k=1.",
                                  "learningObjective": "Compreender e detectar sistematicamente conflitos em tabelas LL(k).",
                                  "commonMistakes": [
                                    "Ignorar conflitos em lookaheads longos",
                                    "Confundir shift com reduce sem verificar lookahead",
                                    "Não anotar o contexto exato do lookahead"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar causas dos conflitos",
                                  "subSteps": [
                                    "Para cada conflito, trace de volta à gramática: identifique produções com prefixos comuns (falta de left-factoring).",
                                    "Verifique ambiguidades, como FIRST/FOLLOW sets sobrepostos para k>1.",
                                    "Avalie se o conflito é shift-reduce, reduce-reduce ou devido a recursão esquerda.",
                                    "Calcule manualmente FIRST_k e FOLLOW_k para os não-terminais envolvidos.",
                                    "Crie um diagrama de derivação mostrando o prefixo ambíguo."
                                  ],
                                  "verification": "Produza um relatório por conflito explicando a causa raiz, validado por derivação manual de uma string de teste.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Cálculos de FIRST/FOLLOW prévios",
                                    "Ferramenta de parsing como ANTLR ou Yacc para comparação",
                                    "Papel e caneta para diagramas"
                                  ],
                                  "tips": "Use lookaheads de exemplo reais da linguagem para simular parsing.",
                                  "learningObjective": "Diagnosticar precisamente as origens gramaticais dos conflitos LL(k).",
                                  "commonMistakes": [
                                    "Assumir left-recursion sem verificar",
                                    "Não considerar k múltiplos tokens no lookahead",
                                    "Ignorar FOLLOW sets em reduces"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Aplicar estratégias de resolução",
                                  "subSteps": [
                                    "Priorize reescrita de gramática: aplique left-factoring ou elimine recursão esquerda nas produções conflitantes.",
                                    "Teste aumento de k: regenere a tabela com k+1 e verifique se conflitos persistem.",
                                    "Implemente precedência explícita ou nullable handling se aplicável.",
                                    "Escolha a estratégia ótima baseada em complexidade (ex.: prefira reescrita sobre k alto).",
                                    "Atualize a gramática e regenere a tabela."
                                  ],
                                  "verification": "A nova tabela não apresenta conflitos nas células previamente identificadas; valide com parsing de strings de teste.",
                                  "estimatedTime": "90 minutos",
                                  "materials": [
                                    "Gerador de tabelas LL(k) (script Python ou ferramenta)",
                                    "Gramática editável",
                                    "Suite de testes com strings ambíguas"
                                  ],
                                  "tips": "Mantenha k mínimo possível para eficiência; documente mudanças na gramática.",
                                  "learningObjective": "Selecionar e aplicar correções eficazes para tornar a gramática LL(k).",
                                  "commonMistakes": [
                                    "Aumentar k sem tentar reescrita primeiro",
                                    "Introduzir novos conflitos durante edição",
                                    "Não testar com casos de borda como epsilon-produções"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificar e otimizar a tabela corrigida",
                                  "subSteps": [
                                    "Parse strings de teste cobrindo todos os caminhos da gramática na tabela corrigida.",
                                    "Procure células vazias ou ineficiências (ex.: muitas reduces).",
                                    "Otimize lookahead sets se k alto causar overhead.",
                                    "Compare performance com métricas como tamanho da tabela e tempo de parsing.",
                                    "Documente lições aprendidas para gramáticas futuras."
                                  ],
                                  "verification": "Parsing bem-sucedido de 10+ strings sem erros ou backtracking; tabela 100% livre de conflitos.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Parser LL(k) implementado",
                                    "Casos de teste abrangentes",
                                    "Ferramentas de profiling"
                                  ],
                                  "tips": "Use automação para testes; foque em cobertura de gramática.",
                                  "learningObjective": "Garantir robustez e eficiência da tabela LL(k) final.",
                                  "commonMistakes": [
                                    "Testar só strings simples",
                                    "Omitir otimizações de lookahead",
                                    "Não medir impacto de mudanças"
                                  ]
                                }
                              ],
                              "practicalExample": "Considere a gramática: E → T | E + T; T → F | T * F; F → ( E ) | id. Para LL(1), conflito shift-reduce em '+' após T (FIRST de E+ e T*). Solução: reescreva com precedência (E → E + T | T; T → T * F | F), eliminando conflito sem aumentar k.",
                              "finalVerifications": [
                                "Identificar todos os conflitos em uma tabela LL(k) fornecida em <5 minutos.",
                                "Explicar causa e solução para um conflito dado.",
                                "Gerar tabela LL(k) livre de conflitos a partir de gramática ambígua.",
                                "Parse manualmente uma string usando a tabela corrigida.",
                                "Comparar tabelas antes/depois e justificar mudanças.",
                                "Detectar se uma gramática é LL(k) para dado k."
                              ],
                              "assessmentCriteria": [
                                "Precisão na detecção de conflitos (100% identificados).",
                                "Profundidade da análise causal (trace até gramática).",
                                "Eficácia das resoluções (tabela final LL(k) válida).",
                                "Cobertura de testes (parsing sem falhas).",
                                "Eficiência (k mínimo e tabela otimizada).",
                                "Documentação clara de passos e lições."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Conjuntos FIRST/FOLLOW como teoria de linguagens formais.",
                                "Lógica: Resolução de ambiguidades similar a resolução de teoremas.",
                                "Programação: Aplicação em automação de parsing (ex.: Python parsers).",
                                "Engenharia de Software: Refatoração de gramáticas como código.",
                                "Algoritmos: Tabelas como estruturas de decisão finitas."
                              ],
                              "realWorldApplication": "Em compiladores como GCC ou Clang, tabelas LL(k) corrigidas aceleram análise sintática em linguagens como C++; ferramentas como ANTLR usam isso para gerar parsers customizados em apps web/mobile, evitando erros em tempo de compilação."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.2.4.3.1"
                            ]
                          },
                          {
                            "id": "10.1.2.4.3.4",
                            "name": "Aplicar exemplo prático de parsing LL(1)",
                            "description": "Resolver um exemplo completo de gramática LL(1), construindo tabela e parseando uma string de entrada, conforme Aho et al.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Definir a Gramática LL(1) e a String de Entrada",
                                  "subSteps": [
                                    "Liste todas as produções da gramática de exemplo: E → T E' | T E'; E' → + T E' | ε; T → F T'; T' → * F T' | ε; F → ( E ) | id.",
                                    "Identifique os terminais (id, +, *, (, ), ε) e não-terminais (E, E', T, T', F).",
                                    "Marque símbolos nullable (E' e T').",
                                    "Escolha uma string de entrada válida, como 'id + id * id'.",
                                    "Desenhe a árvore de derivação esperada manualmente para validar."
                                  ],
                                  "verification": "Gramática listada corretamente com todos os não-terminais, terminais e string de entrada anotada.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Referência Aho et al. (Compilers: Principles, Techniques, and Tools)"
                                  ],
                                  "tips": [
                                    "Use uma gramática padrão sem recursão à esquerda para garantir LL(1)."
                                  ],
                                  "learningObjective": "Representar precisamente uma gramática LL(1) e selecionar entrada apropriada.",
                                  "commonMistakes": [
                                    "Incluir recursão à esquerda",
                                    "Esquecer ε-produções",
                                    "Não identificar símbolos nullable"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Calcular Conjuntos FIRST e FOLLOW",
                                  "subSteps": [
                                    "Calcule FIRST para cada não-terminal: FIRST(E) = {id, (}; FIRST(E') = {+, ε}; etc.",
                                    "Use regras: para ε-produções, inclua ε; para terminais, adicione diretamente; propague de direitas.",
                                    "Calcule FOLLOW: FOLLOW(E) = {$}; FOLLOW(E') = FOLLOW(E); etc., usando regras de propagação.",
                                    "Verifique se FIRST(A) ∩ FOLLOW(A) = ∅ para cada não-terminal A (condição LL(1)).",
                                    "Tabule os resultados em uma tabela organizada."
                                  ],
                                  "verification": "Tabelas de FIRST e FOLLOW completas e corretas, sem interseções inválidas.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Planilha ou papel quadriculado",
                                    "Calculadora para anotações"
                                  ],
                                  "tips": [
                                    "Comece pelos não-terminais mais baixos na hierarquia (F primeiro)."
                                  ],
                                  "learningObjective": "Dominar o cálculo de FIRST e FOLLOW para validar LL(1).",
                                  "commonMistakes": [
                                    "Não propagar FIRST corretamente em concatenações",
                                    "Esquecer FOLLOW do início ($)",
                                    "Ignorar ε em FOLLOW"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Construir a Tabela de Parsing LL(1)",
                                  "subSteps": [
                                    "Crie uma tabela M[A, a] com linhas para não-terminais e colunas para terminais + $.",
                                    "Para cada produção A → α, para cada terminal a em FIRST(α), insira [A → α] em M[A, a].",
                                    "Se ε em FIRST(α), preencha com FOLLOW(A).",
                                    "Marque células vazias como erro.",
                                    "Preencha a tabela para o exemplo: ex. M[E', +] = E' → + T E'; M[E', $] = E' → ε."
                                  ],
                                  "verification": "Tabela completa sem conflitos (múltiplas entradas na mesma célula).",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Tabela impressa ou software como Excel",
                                    "Lista de FIRST/FOLLOW"
                                  ],
                                  "tips": [
                                    "Use cores para diferenciar produções e erros."
                                  ],
                                  "learningObjective": "Construir tabela de parsing determinística LL(1).",
                                  "commonMistakes": [
                                    "Conflitos de entrada múltipla",
                                    "Esquecer preenchimento com FOLLOW para ε",
                                    "Células vazias não marcadas"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Executar o Parsing da String de Entrada",
                                  "subSteps": [
                                    "Inicialize pilha com $ e S' (ou E), entrada com 'id + id * id $'.",
                                    "Repita: Match terminal (pop e avance); ou use M[topo, próximo] para expandir não-terminal.",
                                    "Registre cada ação em uma tabela de rastreamento (entrada, pilha, ação).",
                                    "Continue até pilha = $ e entrada consumida.",
                                    "Desenhe a árvore de parsing derivada."
                                  ],
                                  "verification": "String parseada completamente com pilha vazia e sem erros.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel para pilha e entrada",
                                    "Tabela de parsing pronta"
                                  ],
                                  "tips": [
                                    "Simule passo a passo devagar para evitar erros de pilha."
                                  ],
                                  "learningObjective": "Aplicar tabela para parsear e construir árvore sintática.",
                                  "commonMistakes": [
                                    "Match incorreto de terminais",
                                    "Expansão errada da tabela",
                                    "Não avançar entrada após match"
                                  ]
                                }
                              ],
                              "practicalExample": "Gramática: E → T E' | T E'; E' → + T E' | ε; T → F T' | F T'; T' → * F T' | ε; F → ( E ) | id. String: 'id + id * id'. FIRST/FOLLOW calculados corretamente levam a tabela sem conflitos. Parsing gera árvore: E → T E' → F T' E' → id T' E' → ε (+ T E') → ... resultando em parse aceito.",
                              "finalVerifications": [
                                "Gramática e string definidas corretamente.",
                                "FIRST e FOLLOW sem erros ou interseções.",
                                "Tabela LL(1) sem conflitos e completa.",
                                "Parsing simula sem rejeição, consumindo toda a entrada.",
                                "Árvore de parsing desenhada e matches com derivação.",
                                "Rastreamento de pilha/entrada registrado."
                              ],
                              "assessmentCriteria": [
                                "Precisão nos cálculos de FIRST/FOLLOW (100% correto).",
                                "Tabela de parsing livre de conflitos LL(1).",
                                "Simulação de parsing passo a passo sem erros.",
                                "Árvore sintática alinhada com a string.",
                                "Explicação clara de cada decisão na tabela.",
                                "Tempo e eficiência na construção."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria de Conjuntos (FIRST/FOLLOW como operações de união).",
                                "Lógica: Tabelas de decisão e autômatos finitos.",
                                "Algoritmos: Estruturas de dados (pilha, tabelas).",
                                "Engenharia de Software: Validação de especificações formais."
                              ],
                              "realWorldApplication": "Em compiladores como o de linguagens de programação (ex: JavaCC, ANTLR gera parsers LL(*)), análise sintática de queries SQL em bancos de dados, ou validadores de XML/JSON em navegadores."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.2.4.3.2"
                            ]
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.2.5",
                    "name": "Parsers LR(k)",
                    "description": "Parsers bottom-up poderosos que reconhecem linguagens determinísticas de contexto livre usando pilha e tabelas de ação/ir para.",
                    "individualConcepts": [
                      {
                        "id": "10.1.2.5.1",
                        "name": "Definição e Características dos Parsers LR(k)",
                        "description": "Conceitos fundamentais sobre parsers LR(k), incluindo sua natureza bottom-up, capacidade de reconhecer linguagens determinísticas de contexto livre (DCFL) e uso de lookahead de k símbolos.",
                        "specificSkills": [
                          {
                            "id": "10.1.2.5.1.1",
                            "name": "Explicar o funcionamento bottom-up dos parsers LR(k)",
                            "description": "Descrever como os parsers LR(k) constroem a árvore de derivação de baixo para cima utilizando uma pilha para armazenar estados e símbolos, processando a entrada da esquerda para a direita.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a estrutura da pilha e os itens LR em parsers LR(k)",
                                  "subSteps": [
                                    "Estude a pilha como estrutura que armazena símbolos de gramática e estados do autômato LR(k).",
                                    "Aprenda sobre itens LR: produções com um ponto indicando posição de derivação, como [A → α • β, a].",
                                    "Entenda o kernel de um item (parte após o ponto) e o lookahead de k símbolos para decisões.",
                                    "Revise a construção da tabela de parsing LR(k), com colunas para ações (shift/reduce) e estados.",
                                    "Pratique identificando transições de estado baseadas na entrada."
                                  ],
                                  "verification": "Desenhe uma pilha inicial com estado 0 e entrada vazia, e liste 3 itens LR de exemplo.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Diagrama de autômato LR(k)",
                                    "Papel e caneta para desenhos",
                                    "Referência de gramática LR(1)"
                                  ],
                                  "tips": "Visualize a pilha crescendo à direita como em uma fita de Turing para facilitar a compreensão.",
                                  "learningObjective": "Identificar componentes básicos da pilha e itens LR para setup do parser.",
                                  "commonMistakes": [
                                    "Confundir lookahead com símbolos na pilha",
                                    "Ignorar o papel do kernel nos estados"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Explicar as ações principais: Shift e Goto",
                                  "subSteps": [
                                    "Descreva shift: empilhar símbolo de entrada e mover para novo estado baseado na tabela.",
                                    "Explique goto: transição de estado após shift, sem consumir entrada adicional.",
                                    "Diferencie shift de reduce: shift avança na entrada, reduce substitui pela não-terminal.",
                                    "Simule shift em uma entrada de exemplo, atualizando pilha e índice de entrada.",
                                    "Identifique quando shift ocorre usando a ação Sij na tabela LR(k)."
                                  ],
                                  "verification": "Simule 2 shifts consecutivos em uma entrada simples e mostre a pilha resultante.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Tabela de parsing LR(k) exemplo",
                                    "Simulador online de parser LR (opcional)"
                                  ],
                                  "tips": "Lembre-se: shift é como 'ler e empilhar', mantendo o fluxo esquerda-direita.",
                                  "learningObjective": "Dominar como shift processa entrada e atualiza estados na pilha.",
                                  "commonMistakes": [
                                    "Confundir shift com reduce",
                                    "Esquecer de avançar o índice de entrada"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Descrever as reduções e construção bottom-up da árvore",
                                  "subSteps": [
                                    "Explique reduce: quando o topo da pilha matches o lado direito de uma produção, pop e push não-terminal.",
                                    "Detalhe como reduce constrói árvore bottom-up: folhas primeiro, ascendendo para raiz.",
                                    "Incorpore lookahead k para resolver conflitos shift/reduce ou reduce/reduce.",
                                    "Simule uma reduce completa, atualizando pilha e registrando pai na árvore de derivação.",
                                    "Repita reduces até aceitar (pilha com axioma e entrada esvaziada)."
                                  ],
                                  "verification": "Execute uma reduce em uma pilha simulada e desenhe o nó pai na árvore.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Exemplo de gramática SLR/LR(1)",
                                    "Ferramenta de visualização de árvores de parsing"
                                  ],
                                  "tips": "Pense em reduce como 'reconstruir' subárvores a partir de folhas reconhecidas.",
                                  "learningObjective": "Entender como reduces constroem a árvore de derivação de baixo para cima.",
                                  "commonMistakes": [
                                    "Pop incorreto número de símbolos",
                                    "Ignorar lookahead em ambiguidades"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Integrar o processo completo e lidar com erros",
                                  "subSteps": [
                                    "Revise o loop: while não aceito, shift/reduce baseado na tabela e lookahead.",
                                    "Explique detecção de erros: ação 'error' na tabela leva a recuperação.",
                                    "Construa a árvore final: cada reduce adiciona arestas pai-filho.",
                                    "Compare com top-down (LL): bottom-up lida melhor com left-recursion.",
                                    "Pratique o ciclo completo em uma gramática não-trivial."
                                  ],
                                  "verification": "Descreva o estado final da pilha e árvore para uma entrada válida/inválida.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Gramática de teste completa",
                                    "Compilador de exemplo como yacc/bison"
                                  ],
                                  "tips": "Use debuggers de parser para pausar e inspecionar pilha em tempo real.",
                                  "learningObjective": "Sintetizar o algoritmo LR(k) bottom-up em um fluxo acionável.",
                                  "commonMistakes": [
                                    "Parar prematuramente sem esvaziar entrada",
                                    "Confundir bottom-up com top-down"
                                  ]
                                }
                              ],
                              "practicalExample": "Considere a gramática E → E + T | T, T → T * F | F, F → id. Para entrada 'id + id * id', o parser LR(1): inicia pilha [0], shift 'id' → [0 id 5], reduce F→id → [0 F 7], reduce T→F → [0 T 9], shift '+' → [...], e assim constrói árvore com * tendo precedência sobre + via reduces bottom-up.",
                              "finalVerifications": [
                                "Desenhe a pilha e ações para os primeiros 5 shifts/reduces de um exemplo.",
                                "Explique por que LR(k) é bottom-up usando uma árvore de derivação.",
                                "Identifique lookahead em uma decisão shift/reduce.",
                                "Simule parsing completo de 'id * id + id' e verifique aceitação.",
                                "Diferencie pilha LR de pilha recursiva descendente.",
                                "Liste 3 vantagens do bottom-up sobre top-down."
                              ],
                              "assessmentCriteria": [
                                "Precisão na descrição de shift/reduce (90% correto).",
                                "Correta visualização da pilha e árvore em exemplos (com diagramas).",
                                "Uso adequado de lookahead k em simulações.",
                                "Identificação de erros comuns e resoluções.",
                                "Explicação clara do fluxo bottom-up vs. top-down.",
                                "Aplicação em gramática real com no máximo 1 erro."
                              ],
                              "crossCurricularConnections": [
                                "Teoria da Computação: Autômatos pushdown e reconhecimento de linguagens LR.",
                                "Estruturas de Dados: Uso avançado de pilhas e tabelas de transição.",
                                "Algoritmos: Parsing como algoritmo determinístico O(n).",
                                "Engenharia de Software: Ferramentas como Yacc/Bison em compiladores.",
                                "Matemática Discreta: Conjuntos de itens LR como fechos."
                              ],
                              "realWorldApplication": "Em compiladores de linguagens como C++ (GCC usa LR(1)), Java (javac), ou ferramentas como ANTLR/Yacc para análise sintática eficiente de código fonte, lidando com precedências e left-recursion sem backtracking."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.5.1.2",
                            "name": "Identificar linguagens reconhecidas por LR(k)",
                            "description": "Reconhecer que parsers LR(k) são poderosos para linguagens DCFL, comparando com LL(k) top-down e explicando por que LR(k) lida melhor com ambiguidades e precedências.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Fundamentos de Linguagens Context-Free e Tipos de Parsers",
                                  "subSteps": [
                                    "Estude a definição de linguagens context-free (CFLs) e gramáticas context-free (CFGs).",
                                    "Diferencie parsers top-down (LL(k)) de bottom-up (LR(k)).",
                                    "Entenda o conceito de lookahead (k) em parsers limitados.",
                                    "Revise a hierarquia de Chomsky e classes de linguagens determinísticas."
                                  ],
                                  "verification": "Liste 3 diferenças chave entre LL(k) e LR(k) parsers em um papel.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Livro 'Compilers: Principles, Techniques, and Tools' (Dragon Book), capítulo 4",
                                    "Notas de aula sobre teoria da computação"
                                  ],
                                  "tips": "Use diagramas para visualizar top-down vs bottom-up parsing.",
                                  "learningObjective": "Compreender as bases teóricas para comparação posterior.",
                                  "commonMistakes": [
                                    "Confundir lookahead com poderes expressivos das linguagens",
                                    "Ignorar a direção de parsing (top-down vs bottom-up)"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Entender Linguagens DCFL e Poder dos Parsers LR(k)",
                                  "subSteps": [
                                    "Defina Deterministic Context-Free Languages (DCFLs).",
                                    "Aprenda que todo DCFL tem uma gramática LR(k) determinística.",
                                    "Estude teoremas que provam que LR(k) reconhece exatamente as DCFLs.",
                                    "Compare com CFLs não-determinísticas que requerem parsers mais poderosos."
                                  ],
                                  "verification": "Escreva uma definição precisa de DCFL e cite um teorema relacionado a LR(k).",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Artigos acadêmicos sobre teoria dos parsers LR",
                                    "Ferramenta online como JFLAP para simular autômatos DPDA"
                                  ],
                                  "tips": "Lembre-se: DCFLs correspondem a Pushdown Automata Determinísticos (DPDA).",
                                  "learningObjective": "Identificar que LR(k) é poderoso o suficiente para todas as DCFLs.",
                                  "commonMistakes": [
                                    "Achar que LR(k) pode parsear todas as CFLs (não pode, só DCFLs)",
                                    "Confundir LR(k) com LALR ou SLR"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Comparar LR(k) com LL(k) em Termos de Poder e Limitações",
                                  "subSteps": [
                                    "Analise por que LL(k) é restrito a linguagens LL(k) (subconjunto próprio de DCFLs).",
                                    "Estude exemplos onde LL(k) falha devido a left-recursion.",
                                    "Compare eficiência em reconhecimento de prefixos vs sufixos.",
                                    "Discuta k finito vs poder assintótico à medida que k cresce."
                                  ],
                                  "verification": "Crie uma tabela comparativa com 4 colunas: Característica, LL(k), LR(k), Vencedor.",
                                  "estimatedTime": "50 minutos",
                                  "materials": [
                                    "Exemplos de gramáticas do Dragon Book, seções 4.4-4.6",
                                    "Editor de texto para escrever gramáticas simples"
                                  ],
                                  "tips": "Foque em left-recursion: LL odeia, LR ama.",
                                  "learningObjective": "Explicar limitações de LL(k) que LR(k) supera.",
                                  "commonMistakes": [
                                    "Pensar que LL(k) e LR(k) têm o mesmo poder para todo k (LR é mais poderoso)",
                                    "Ignorar que ambos requerem k finito"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar Superioridade de LR(k) em Ambiguidades e Precedências",
                                  "subSteps": [
                                    "Estude gramáticas ambíguas e como LR resolve com shift-reduce.",
                                    "Exemplo: Expressões aritméticas com precedência (if-then-else dangling).",
                                    "Simule parsing de uma gramática com precedência em LL vs LR.",
                                    "Conclua por que LR lida melhor com ambiguidades locais.",
                                    "Pratique identificando linguagens que são LR mas não LL."
                                  ],
                                  "verification": "Parse manualmente uma gramática ambígua em LR e explique por que LL falha.",
                                  "estimatedTime": "75 minutos",
                                  "materials": [
                                    "Simulador de parser LR online (ex: LR Parser Generator)",
                                    "Papel e lápis para tabelas de parsing"
                                  ],
                                  "tips": "Use tabelas de ação/goto para visualizar decisões shift/reduce.",
                                  "learningObjective": "Reconhecer cenários onde LR(k) é essencial devido a ambiguidades/precedências.",
                                  "commonMistakes": [
                                    "Confundir ambiguidade da gramática com conflito no parser",
                                    "Subestimar o papel do lookahead em resolver conflitos"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Sintetizar e Verificar Conhecimento",
                                  "subSteps": [
                                    "Resuma as linguagens reconhecidas por LR(k): exatamente DCFLs.",
                                    "Liste 3 exemplos de linguagens DCFL que desafiam LL(k).",
                                    "Crie um fluxograma de decisão para classificar uma linguagem como LR(k).",
                                    "Teste-se com questões de autoavaliação."
                                  ],
                                  "verification": "Responda corretamente a 5 perguntas de múltipla escolha sobre o tópico.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Quiz online sobre parsers (ex: de universidades MIT/Stanford)",
                                    "Flashcards Anki personalizadas"
                                  ],
                                  "tips": "Ensine o conceito a outra pessoa para reforçar.",
                                  "learningObjective": "Consolidar identificação de linguagens LR(k) vs outras.",
                                  "commonMistakes": [
                                    "Generalizar demais: nem toda DCFL é facilmente LL",
                                    "Esquecer que LR(1) é subset de LR(k) para k>1"
                                  ]
                                }
                              ],
                              "practicalExample": "Considere a gramática de expressões aritméticas: E → E + T | T; T → T * F | F; F → (E) | id. LL(1) requer left-factoring e left-recursion elimination, mas LR(1) parseia diretamente usando shift-reduce para respeitar precedência (* > +). Simule input 'id + id * id' e veja LR resolver sem ambiguidade.",
                              "finalVerifications": [
                                "Defina precisamente DCFL e sua relação com LR(k).",
                                "Cite pelo menos 2 exemplos de linguagens LR mas não LL.",
                                "Explique com um diagrama por que LR lida melhor com precedências.",
                                "Identifique conflitos shift-reduce em uma gramática ambígua.",
                                "Compare poderes: LL(k) ⊆ DCFL = LR(k)."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de DCFLs (100% correto).",
                                "Profundidade na explicação de ambiguidades/precedências (exemplos concretos).",
                                "Uso correto de terminologia (lookahead, shift-reduce, etc.).",
                                "Capacidade de simular parsing manual simples.",
                                "Criatividade em conexões com exemplos reais de compiladores."
                              ],
                              "crossCurricularConnections": [
                                "Teoria da Computação: Autômatos DPDA e hierarquia Chomsky.",
                                "Matemática Formal: Teoria de linguagens e grafos de dependência.",
                                "Engenharia de Software: Design de compiladores e ferramentas como Yacc/Bison.",
                                "Linguística Computacional: Análise sintática em PLN."
                              ],
                              "realWorldApplication": "Compiladores modernos como GCC (para C/C++) e Clang usam parsers LR(k)/LALR(1) para lidar com precedências complexas e ambiguidades em linguagens como C++, permitindo parsing eficiente de código real sem reescrever gramáticas para LL."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.5.1.3",
                            "name": "Diferenciar variantes LR(0), SLR(1), LALR(1) e LR(1)",
                            "description": "Comparar as variantes de parsers LR(k), destacando o tamanho das tabelas e o poder de reconhecimento, com exemplos de quando usar cada uma.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os Fundamentos dos Parsers LR(0)",
                                  "subSteps": [
                                    "Estude a construção de itens LR(0) e estados canônicos.",
                                    "Aprenda a gerar a tabela de parsing LR(0) para uma gramática simples.",
                                    "Identifique conflitos shift-reduce e reduce-reduce em LR(0).",
                                    "Pratique com uma gramática de expressões aritméticas.",
                                    "Compare o poder de reconhecimento de LR(0) com LL parsers."
                                  ],
                                  "verification": "Construa corretamente a tabela LR(0) para uma gramática dada sem conflitos.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Livro 'Compilers: Principles, Techniques, and Tools' (Dragon Book), Capítulo 4",
                                    "Ferramenta online de geração de tabelas LR",
                                    "Papel e lápis para desenhar AFNDs"
                                  ],
                                  "tips": "Comece com gramáticas determinísticas para evitar frustrações iniciais.",
                                  "learningObjective": "Dominar a construção e limitações básicas dos parsers LR(0).",
                                  "commonMistakes": [
                                    "Ignorar kernels de itens ao mesclar estados",
                                    "Confundir goto com shift"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Explorar Parsers SLR(1) e sua Melhoria sobre LR(0)",
                                  "subSteps": [
                                    "Revise conjuntos FOLLOW para gramáticas.",
                                    "Aprenda a resolver conflitos de reduce usando FOLLOW em tabelas LR(0).",
                                    "Construa uma tabela SLR(1) para a mesma gramática do Step 1.",
                                    "Identifique gramáticas SLR(1) que não são LR(0).",
                                    "Teste parsing de strings ambíguas."
                                  ],
                                  "verification": "Resolva um conflito shift-reduce em uma tabela SLR(1) usando FOLLOW corretamente.",
                                  "estimatedTime": "2.5 horas",
                                  "materials": [
                                    "Dragon Book, Seção 4.5",
                                    "Implementação Jison ou Bison para testes",
                                    "Lista de gramáticas exemplo"
                                  ],
                                  "tips": "Calcule FOLLOW sets manualmente antes de automatizar.",
                                  "learningObjective": "Entender como o lookahead de 1 token melhora o poder de SLR(1).",
                                  "commonMistakes": [
                                    "Usar FIRST em vez de FOLLOW para reduces",
                                    "Não propagar FOLLOW adequadamente"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar Parsers LALR(1) e Otimização de Estados",
                                  "subSteps": [
                                    "Construa itens LR(1) completos e estados para uma gramática.",
                                    "Aprenda a mesclar estados com o mesmo core LR(0), propagando lookaheads.",
                                    "Gere tabela LALR(1) e compare com SLR(1).",
                                    "Identifique gramáticas LALR(1) que falham em SLR(1).",
                                    "Verifique conflitos introduzidos pela mesclagem."
                                  ],
                                  "verification": "Construa uma tabela LALR(1) sem conflitos espontâneos para uma gramática não-SLR.",
                                  "estimatedTime": "3 horas",
                                  "materials": [
                                    "Dragon Book, Seção 4.7",
                                    "Ferramenta Yacc/Bison com opções LALR",
                                    "Exemplos de gramáticas if-then-else"
                                  ],
                                  "tips": "Use diagramas para visualizar mesclagem de estados.",
                                  "learningObjective": "Compreender o trade-off entre tamanho de tabela e poder em LALR(1).",
                                  "commonMistakes": [
                                    "Não unir lookaheads corretamente na mesclagem",
                                    "Confundir LALR com SLR"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Dominar LR(1) e Comparar Todas as Variantes",
                                  "subSteps": [
                                    "Construa a tabela LR(1) completa sem mesclagens.",
                                    "Compare tamanhos de tabelas: LR(0) < SLR(1)=LALR(1) << LR(1).",
                                    "Discuta hierarquia de poder: LR(0) ⊆ SLR(1) ⊆ LALR(1) ⊂ LR(1).",
                                    "Exemplos de uso: LR(0) para simples, LALR(1) em ferramentas como Yacc.",
                                    "Avalie quando usar cada uma baseado em tamanho vs. poder."
                                  ],
                                  "verification": "Explique com uma gramática por que LR(1) é necessário e compare tamanhos numéricos.",
                                  "estimatedTime": "2.5 horas",
                                  "materials": [
                                    "Dragon Book, Seções 4.6-4.8",
                                    "Tabelas comparativas pré-computadas",
                                    "Compilador open-source como GCC para inspiração"
                                  ],
                                  "tips": "Crie uma tabela de comparação em spreadsheet para visualização.",
                                  "learningObjective": "Diferenciar precisamente todas as variantes em termos de tabela e poder.",
                                  "commonMistakes": [
                                    "Achar que LALR(1) é tão poderoso quanto LR(1)",
                                    "Ignorar overhead computacional de LR(1)"
                                  ]
                                }
                              ],
                              "practicalExample": "Para a gramática if-then-else: S → if E then S | if E then S else S | outras. Construa tabelas LR(0) (conflito), SLR(1) (pode falhar), LALR(1) (resolve dangling else), LR(1) (sempre correto, mas tabela 10x maior). Parse 'if e1 then if e2 then s1 else s2'.",
                              "finalVerifications": [
                                "Construir tabela LR(0) sem erros para gramática dada.",
                                "Resolver conflitos SLR(1) usando FOLLOW.",
                                "Mesclar estados LALR(1) corretamente.",
                                "Explicar por que uma gramática requer LR(1).",
                                "Comparar tamanhos de tabelas numericamente.",
                                "Identificar uso prático de cada variante."
                              ],
                              "assessmentCriteria": [
                                "Precisão na construção de itens e tabelas (80% sem erros).",
                                "Correta identificação de conflitos e resoluções.",
                                "Explicação clara da hierarquia de poder.",
                                "Uso apropriado de FOLLOW e lookaheads.",
                                "Comparação quantitativa de tamanhos de tabelas.",
                                "Exemplos relevantes e sem ambiguidades."
                              ],
                              "crossCurricularConnections": [
                                "Teoria da Computação: Autômatos com lookahead.",
                                "Algoritmos: Otimização de tabelas de parsing.",
                                "Engenharia de Software: Ferramentas como Yacc/Bison.",
                                "Matemática Discreta: Conjuntos FIRST/FOLLOW."
                              ],
                              "realWorldApplication": "Em compiladores como GCC ou ferramentas como ANTLR/Yacc, LALR(1) equilibra eficiência (tabelas menores) e poder para linguagens reais como C/Java, evitando overhead de LR(1) full enquanto parseia 99% das gramáticas práticas."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.2.5.2",
                        "name": "Estrutura de Parsing: Pilha e Tabelas",
                        "description": "Componentes operacionais dos parsers LR(k), incluindo a pilha de estados e símbolos, e as tabelas de ação (shift, reduce) e goto para transições.",
                        "specificSkills": [
                          {
                            "id": "10.1.2.5.2.1",
                            "name": "Descrever o uso da pilha no parsing LR(k)",
                            "description": "Explicar como a pilha armazena pares (estado, símbolo) e gerencia shift (empilhar) e reduce (desempilhar e empilhar não-terminal) com base no estado atual e lookahead.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a estrutura da pilha em parsers LR(k)",
                                  "subSteps": [
                                    "Estude a representação da pilha como uma sequência de pares (estado, símbolo).",
                                    "Identifique que o topo da pilha contém o estado atual e o símbolo mais recente.",
                                    "Revise como os estados representam conjuntos de itens LR e símbolos são terminais ou não-terminais.",
                                    "Desenhe um exemplo inicial de pilha vazia: [0] (estado inicial).",
                                    "Analise como a pilha cresce da esquerda para a direita, com o topo à direita."
                                  ],
                                  "verification": "Desenhe uma pilha com 3 pares (estado, símbolo) e explique o que cada um representa.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e caneta para diagramas",
                                    "Tabela de parsing LR(k) de exemplo",
                                    "Documentação sobre itens LR"
                                  ],
                                  "tips": "Sempre anote o estado no topo como o 'estado atual' para decisões futuras.",
                                  "learningObjective": "Entender que a pilha armazena o histórico de parsing como pares (estado, símbolo) para determinismo.",
                                  "commonMistakes": [
                                    "Confundir ordem da pilha (topo à esquerda vs. direita)",
                                    "Ignorar que estados derivam de itens LR"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Executar a operação SHIFT (empilhar)",
                                  "subSteps": [
                                    "Consulte a tabela de ação no estado atual e lookahead (próximo símbolo de entrada).",
                                    "Se a ação for 'shift s', empilhe o par (s, símbolo de lookahead) no topo da pilha.",
                                    "Avance o ponteiro de entrada para o próximo símbolo.",
                                    "Simule com um exemplo: pilha [0], entrada 'id +', shift para [0 $ id 1] (estado 1).",
                                    "Verifique transições determinísticas baseadas em lookahead k símbolos."
                                  ],
                                  "verification": "Simule um shift em uma pilha exemplo e confirme que o novo estado está no topo.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Tabela de ações LR(k) exemplo",
                                    "Sequência de entrada sintática simples",
                                    "Simulador de pilha online ou papel"
                                  ],
                                  "tips": "Lembre-se: shift só ocorre se não houver reduce prioritário na mesma célula.",
                                  "learningObjective": "Dominar como shift expande a pilha com lookahead para continuar parsing.",
                                  "commonMistakes": [
                                    "Empilhar sem consultar lookahead",
                                    "Não avançar o ponteiro de entrada"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Executar a operação REDUCE (desempilhar e empilhar não-terminal)",
                                  "subSteps": [
                                    "No estado atual, se a ação for 'reduce A → β' (com |β| símbolos), desempilhe 2|β| elementos (estados + símbolos).",
                                    "Consulte o estado exposto após desempilhar (goto) com não-terminal A para novo estado s.",
                                    "Empilhe o par (s, A) no topo.",
                                    "Coloque os símbolos de β de volta na entrada para matching semântico futuro.",
                                    "Exemplo: pilha [... E 5 + 6 id 7], reduce T → id → desempilha 2, goto E → pilha [... E 8]."
                                  ],
                                  "verification": "Aplique reduce em uma pilha com 4 elementos e mostre a pilha resultante.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Gramática LR(k) simples com produções",
                                    "Tabela de goto",
                                    "Exemplos de reduces múltiplos"
                                  ],
                                  "tips": "Conte precisamente: desempilhe 2 elementos por símbolo em β.",
                                  "learningObjective": "Aprender como reduce colapsa a pilha em não-terminais usando goto.",
                                  "commonMistakes": [
                                    "Desempilhar quantidade errada de elementos",
                                    "Esquecer de consultar goto no estado exposto"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Gerenciar o ciclo completo de parsing com lookahead e fim",
                                  "subSteps": [
                                    "Inicie com pilha [0] e entrada completa + $ (fim de entrada).",
                                    "Loop: consulte ação(estado_atual, lookahead); shift ou reduce até accept/error.",
                                    "Em accept: pilha tem [0 S 0] onde S é axioma; em error: rejeite.",
                                    "Simule parsing completo de 'id + id' em gramática aritmética.",
                                    "Discuta lookahead k>1 para resolver ambiguidades em gramáticas não-LR(1)."
                                  ],
                                  "verification": "Parse uma string completa e liste todas as mudanças na pilha passo a passo.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Ferramenta Yacc/Bison exemplo",
                                    "Gramática de expressões aritméticas LR(1)",
                                    "Vídeo tutorial de parsing LR"
                                  ],
                                  "tips": "Use $ como lookahead final para triggers de reduce.",
                                  "learningObjective": "Integrar shift/reduce em um algoritmo determinístico LR(k).",
                                  "commonMistakes": [
                                    "Parar shift cedo sem esvaziar entrada",
                                    "Ignorar conflitos shift/reduce sem lookahead k"
                                  ]
                                }
                              ],
                              "practicalExample": "Gramática: S → E; E → E + T | T; T → id. Entrada: id + id $. Início: pilha [0]. Lookahead 'id' → shift 5: [0 id 5]. Lookahead '+' → shift 6: [0 id 5 + 6]. Lookahead 'id' → shift 5: [0 id 5 + 6 id 5]. Reduce T→id (2 elems): [0 id 5 + 6 T 7]. Reduce E→T (2 elems): [0 id 5 + 6 E 8? goto]. Continue até accept.",
                              "finalVerifications": [
                                "Descreva verbalmente o conteúdo de uma pilha durante shift e reduce.",
                                "Simule manualmente o parsing de uma string curta e liste pilhas intermediárias.",
                                "Explique por que pares (estado, símbolo) são necessários em vez de só símbolos.",
                                "Identifique quando lookahead é consultado e seu papel em k>1.",
                                "Diferencie pilha LR de pilha recursiva descendente."
                              ],
                              "assessmentCriteria": [
                                "Precisão na contagem de desempilhamento em reduce (|β| * 2 elementos).",
                                "Correta consulta de tabelas ação/goto com estado atual e lookahead.",
                                "Descrição clara de shift vs. reduce com exemplos visuais.",
                                "Compreensão de determinismo via lookahead k.",
                                "Identificação de accept/error condições na pilha final.",
                                "Uso correto de pares (estado, símbolo) em simulações."
                              ],
                              "crossCurricularConnections": [
                                "Estruturas de Dados: Pilhas como LIFO para histórico reversível.",
                                "Teoria da Computação: Autômatos de pilha e linguagens determinísticas.",
                                "Algoritmos: Tabelas de transição finitas em parsing bottom-up.",
                                "Engenharia de Software: Implementação em ferramentas como Yacc/Bison."
                              ],
                              "realWorldApplication": "Em compiladores reais como GCC (C/C++) ou javac (Java), a pilha LR(k) parseia código-fonte complexo eficientemente, lidando com gramáticas ambíguas via lookahead, permitindo compilação rápida de milhões de linhas de código."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.5.2.2",
                            "name": "Construir tabela de ação e tabela goto",
                            "description": "Gerar tabelas de parsing a partir de um autômato LR(k), definindo ações como shift, reduce, accept e error para terminais, e transições goto para não-terminais.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar a gramática e os estados do autômato LR(k)",
                                  "subSteps": [
                                    "Analisar a gramática e adicionar o axioma aumentado S' → .S.",
                                    "Construir os conjuntos de itens LR(k) canônicos, fechando sob ε-transições e lookaheads.",
                                    "Numerar sequencialmente os estados obtidos (I0, I1, ..., In).",
                                    "Listar todos os terminais e não-terminais da gramática."
                                  ],
                                  "verification": "Verificar se todos os estados estão listados corretamente e o estado inicial I0 contém S' → .S.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Gramática formal anotada",
                                    "Ferramenta de simulação como JFLAP ou papel quadriculado"
                                  ],
                                  "tips": "Sempre comece pelo item aumentado e aplique CLOSURE até fixpoint.",
                                  "learningObjective": "Dominar a construção de itens canônicos e estados para basear as tabelas.",
                                  "commonMistakes": [
                                    "Esquecer de fechar itens com produções ε",
                                    "Ignorar lookaheads em LR(1)"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Calcular transições SHIFT e GOTO",
                                  "subSteps": [
                                    "Para cada estado I e terminal a, calcular o próximo estado J = goto(I, a) e anotar como SHIFT j.",
                                    "Para cada estado I e não-terminal A, calcular J = goto(I, A) e registrar na tabela GOTO.",
                                    "Preencher todas as transições possíveis sem duplicatas.",
                                    "Verificar kernels dos itens para confirmar transições."
                                  ],
                                  "verification": "Tabela parcial com SHIFTS e GOTOs preenchidos; testar uma transição manualmente.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Lista de estados do Step 1",
                                    "Tabela vazia ACTION/GOTO (linhas=estados, colunas=símbolos)"
                                  ],
                                  "tips": "Use a função goto recursivamente: kernel de J é { B → α .β | existe item A → α .A β em I }.",
                                  "learningObjective": "Entender como transições de símbolos definem shift e goto em autômatos LR.",
                                  "commonMistakes": [
                                    "Confundir terminais com não-terminais",
                                    "Erro no cálculo de goto levando a estados inexistentes"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Determinar ações REDUCE e ACCEPT",
                                  "subSteps": [
                                    "Identificar itens completos A → α . em cada estado I com lookaheads apropriados.",
                                    "Para cada tal item, preencher ACTION[I][la] = reduce A → α para lookahead la.",
                                    "No estado com S' → S ., preencher ACTION[i][$] = accept.",
                                    "Verificar múltiplos reduces por lookahead para conflitos."
                                  ],
                                  "verification": "Todas entradas reduce e accept adicionadas sem sobrescrita inicial de shifts.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Estados com itens completos destacados",
                                    "Tabela ACTION parcial do Step 2"
                                  ],
                                  "tips": "Reduce só para lookaheads específicos em LR(1); use FOLLOW em SLR(0).",
                                  "learningObjective": "Diferenciar shift/reduce/accept e gerenciar lookaheads.",
                                  "commonMistakes": [
                                    "Aplicar reduce em todos os terminais, ignorando lookaheads",
                                    "Confundir accept com reduce do axioma"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Finalizar tabelas com ERRO e validar consistência",
                                  "subSteps": [
                                    "Preencher células vazias na ACTION com 'error'.",
                                    "Verificar ausência de conflitos SHIFT/REDUCE ou REDUCE/REDUCE em qualquer [I,a].",
                                    "Simular parsing com uma string de entrada simples nas tabelas.",
                                    "Documentar o tamanho das tabelas e resumo de ações."
                                  ],
                                  "verification": "Tabelas completas sem conflitos; parsing de exemplo termina corretamente.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Tabelas parciais",
                                    "String de teste válida e inválida"
                                  ],
                                  "tips": "Conflitos indicam gramática não LR(k); resolva com mais lookahead.",
                                  "learningObjective": "Garantir tabelas acionáveis e livres de ambiguidades.",
                                  "commonMistakes": [
                                    "Deixar células vazias sem 'error'",
                                    "Ignorar conflitos durante preenchimento"
                                  ]
                                }
                              ],
                              "practicalExample": "Para a gramática S → a S b | ε (com S' → S), estados LR(0): I0={S'→.S, S→.aSb, S→.ε}, I1={S'→S.}, I2={S→a.Sb}, I3={S→aSb.}, I4={S→aSb .b} (simplificado). ACTION[0]['a']=s2, ACTION[0]['$']=r(S→ε), GOTO[0]['S']=1, etc. Parsing de 'ab' usa shifts e reduces corretos.",
                              "finalVerifications": [
                                "Tabela ACTION cobre todos terminais por estado com shift/reduce/accept/error.",
                                "Tabela GOTO tem transições exatas para não-terminais.",
                                "Ausência de conflitos SHIFT/REDUCE ou REDUCE/REDUCE.",
                                "Simulação de parsing aceita string válida e rejeita inválida.",
                                "Estados numerados corretamente sem duplicatas."
                              ],
                              "assessmentCriteria": [
                                "Precisão de 100% nas transições shift e goto (verificação por kernel).",
                                "Correta identificação de reduces por lookahead (sem falsos positivos).",
                                "Completude: zero células vazias na ACTION.",
                                "Validação via simulação: parsing correto em ≥3 strings.",
                                "Clareza na documentação de estados e itens."
                              ],
                              "crossCurricularConnections": [
                                "Teoria da Computação (autômatos de pilha determinísticos).",
                                "Matemática Discreta (grafos de transição e matrizes de adjacência).",
                                "Lógica Formal (inferência por redução de regras de produção).",
                                "Engenharia de Software (geração automática de parsers via ferramentas)."
                              ],
                              "realWorldApplication": "Essas tabelas impulsionam parsers bottom-up em compiladores profissionais como GCC (usando Bison/Yacc), permitindo análise sintática eficiente de linguagens como C++, Java e até scripts em Python, otimizando tempo de compilação em projetos de grande escala."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.5.2.3",
                            "name": "Simular parsing com pilha e tabelas",
                            "description": "Executar um exemplo passo a passo de parsing LR(1) em uma gramática simples, rastreando mudanças na pilha e consultas às tabelas.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar a gramática, tabelas LR(1), entrada e componentes iniciais",
                                  "subSteps": [
                                    "Defina a gramática simples em notação de Chomsky normalizada, por exemplo: S' → S, S → a S b | ε.",
                                    "Construa ou liste as tabelas de ação (shift/reduce) e goto para os estados LR(1), usando ferramentas como um gerador de tabelas ou manualmente para gramáticas pequenas.",
                                    "Especifique a string de entrada, terminada com $, ex: 'a a b b $'.",
                                    "Identifique os símbolos terminais e não-terminais envolvidos.",
                                    "Crie uma representação visual das tabelas (colunas para símbolos, linhas para estados)."
                                  ],
                                  "verification": "Verifique se gramática, tabelas, entrada e símbolos estão corretamente listados e sem erros tipográficos.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Papel quadriculado, lápis, calculadora para estados (opcional), tabela LR(1) pré-computada ou gerador online como JFLAP.",
                                  "tips": "Use uma gramática determinística LR(1) para evitar conflitos; comece com exemplos canônicos de livros como 'Compilers: Principles, Techniques, and Tools'.",
                                  "learningObjective": "Compreender os pré-requisitos para simulação manual de parsing LR(1).",
                                  "commonMistakes": "Confundir terminais com não-terminais; esquecer o marcador $ no final da entrada."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Inicializar a pilha, buffer de entrada e estado inicial",
                                  "subSteps": [
                                    "Inicialize a pilha com o estado inicial 0: pilha = [0].",
                                    "Coloque a string de entrada no buffer: input = 'aabb$' com ponteiro i=0 apontando para o primeiro token 'a'.",
                                    "Registre o estado atual da pilha (topo) e o próximo símbolo de entrada.",
                                    "Confirme que não há ações iniciais pendentes.",
                                    "Desenhe o layout inicial: Pilha | Input | Ação."
                                  ],
                                  "verification": "Pilha contém apenas [0], input intacto e pronto para primeira consulta à tabela.",
                                  "estimatedTime": "10 minutos",
                                  "materials": "Folha de papel para diagramas de pilha/input, marcadores coloridos para estados.",
                                  "tips": "Sempre anote o estado no topo da pilha, não apenas símbolos, pois tabelas são indexadas por estados.",
                                  "learningObjective": "Dominar a configuração inicial do parser LR(1).",
                                  "commonMistakes": "Iniciar pilha vazia ou esquecer o estado 0; ignorar o lookahead $."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Executar iterações de shift e reduce rastreando pilha e tabelas",
                                  "subSteps": [
                                    "Consulte a tabela de ação: linha = estado topo da pilha, coluna = próximo token de entrada.",
                                    "Se shift(s): avance o token (i++), empilhe símbolo e estado s na pilha.",
                                    "Se reduce(r): pop 2*|rhs| elementos da pilha, empilhe não-terminal e goto novo estado.",
                                    "Repita até ação 'accept' ou 'error'; registre cada mudança em uma tabela de rastreamento.",
                                    "Atualize input removendo tokens processados e avance lookahead."
                                  ],
                                  "verification": "Cada iteração resulta em pilha/input atualizados corretamente, sem erros prematuros.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Tabela LR(1) impressa ou digital, planilha para log de passos (colunas: Passo, Pilha, Input, Ação).",
                                  "tips": "Use setas para mostrar shifts e reversões para reduces; pause após cada ação para validar.",
                                  "learningObjective": "Simular dinamicamente as transições de pilha e consultas tabulares em LR(1).",
                                  "commonMistakes": "Pop incorreto no reduce (errado número de estados); consultar tabela errada (ação vs goto)."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Concluir o parsing, diagnosticar erros e validar aceitação",
                                  "subSteps": [
                                    "Continue até pilha conter apenas [0, S', estado aceita] e input vazio exceto $.",
                                    "Se error: identifique conflito (shift/reduce ou estado inválido) e proponha correções.",
                                    "Registre árvore de parsing derivada da sequência de reduces.",
                                    "Compare com parsing esperado para a gramática.",
                                    "Documente lições aprendidas sobre ambiguidades resolvidas pelo LR(1)."
                                  ],
                                  "verification": "Parsing termina em 'accept' para entrada válida, com pilha final correta e árvore de sintaxe.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Log de passos anterior, software de visualização como LR Parser Simulator online.",
                                  "tips": "Para entradas inválidas, note o estado de erro exato para depuração.",
                                  "learningObjective": "Interpretar resultados finais e depurar falhas em simulações LR(1).",
                                  "commonMistakes": "Aceitar prematuramente; confundir reduce com shift em conflitos."
                                }
                              ],
                              "practicalExample": "Gramática: S' → S $ | S → a S b | S → ε. Entrada: 'aabb$'. Tabelas simplificadas: Estado 0, 'a'→shift 1; Estado 1, 'a'→shift 2, etc. Simulação: [0] | aabb$ → shift a [0 S1] | abb$ → shift a [0 S1 S2] | bb$ → reduce S→aSb pop2 push S goto3 → ... até [0 S4] | $ → accept.",
                              "finalVerifications": [
                                "Pilha final contém apenas estado inicial e axioma reduzido.",
                                "Todos tokens de entrada foram consumidos.",
                                "Sequência de ações corresponde à tabela LR(1) sem conflitos.",
                                "Árvore de parsing derivada é válida para a gramática.",
                                "Nenhum erro de shift/reduce ou estado inválido ocorreu.",
                                "Lookahead $ foi corretamente processado no final."
                              ],
                              "assessmentCriteria": [
                                "Precisão na consulta e aplicação de tabelas de ação/goto (90% correto).",
                                "Rastreamento correto de mudanças na pilha por iteração.",
                                "Identificação correta de shift vs reduce vs accept.",
                                "Geração de árvore de sintaxe a partir de reduces.",
                                "Diagnóstico preciso de erros em entradas inválidas.",
                                "Documentação clara com diagramas e logs."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Autômatos de pilha e linguagens livres de contexto.",
                                "Lógica: Estados finitos e tabelas de transição como máquinas de estados.",
                                "Engenharia de Software: Depuração e rastreamento de estado em sistemas reativos.",
                                "Algoritmos: Simulação de processos iterativos com estruturas de dados (pilha)."
                              ],
                              "realWorldApplication": "Em compiladores reais como GCC ou Clang, simulações manuais ajudam desenvolvedores a depurar analisadores sintáticos, otimizar gramáticas para evitar conflitos LR(k), e ensinar parsing em ferramentas como ANTLR ou Bison para processamento de linguagens de programação, DSLs e formatos de dados."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.2.5.3",
                        "name": "Construção Automática de Parsers LR(k)",
                        "description": "Algoritmos para gerar autômatos e tabelas LR(k) a partir de gramáticas, incluindo itens LR, fechamento e kernels.",
                        "specificSkills": [
                          {
                            "id": "10.1.2.5.3.1",
                            "name": "Construir itens e conjuntos LR(k)",
                            "description": "Definir itens LR como produções com ponto de inserção e lookahead, calcular fechamento (CLOSURE) e ir (GOTO) para formar o autômato canônico.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender e Definir Itens LR(k)",
                                  "subSteps": [
                                    "Revise a gramática de entrada e liste todas as produções.",
                                    "Defina um item LR(k) como [A → α•β, a], onde • indica o ponto de inserção e a é o lookahead de k símbolos.",
                                    "Escreva exemplos de itens iniciais para o axioma da gramática.",
                                    "Identifique itens kernel (com • não no início) e itens não-kernel.",
                                    "Pratique representando itens em notação padrão."
                                  ],
                                  "verification": "Liste corretamente 5 itens LR(1) para uma gramática simples sem erros de notação.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Folha de papel ou editor de texto, gramática de exemplo (ex: E → E + T | T).",
                                  "tips": "Sempre inclua o lookahead explícito para evitar ambiguidades em k>0.",
                                  "learningObjective": "Dominar a representação formal de itens LR(k) e sua estrutura.",
                                  "commonMistakes": "Esquecer o lookahead ou posicionar incorretamente o ponto •."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Calcular o Fechamento (CLOSURE) de um Conjunto de Itens",
                                  "subSteps": [
                                    "Comece com o conjunto de itens kernel fornecidos.",
                                    "Para cada item [A → α•Bβ, a], adicione itens para não-terminais B: [B → •γ, b] onde b é FIRST(β a).",
                                    "Repita iterativamente até que nenhum novo item seja adicionado.",
                                    "Ordene os itens alfabeticamente ou numericamente para padronização.",
                                    "Verifique se todos os lookaheads foram propagados corretamente."
                                  ],
                                  "verification": "O conjunto fechado deve conter todos os itens derivados sem duplicatas ou itens extras.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Gramática anotada, calculadora de FIRST se necessário.",
                                  "tips": "Use um conjunto auxiliar para rastrear itens adicionados e evitar loops infinitos.",
                                  "learningObjective": "Aplicar o algoritmo CLOSURE para completar conjuntos de itens.",
                                  "commonMistakes": "Não propagar lookaheads corretamente ou adicionar itens para terminais."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular Funções GOTO para Símbolos",
                                  "subSteps": [
                                    "Para um conjunto I e símbolo X (terminal ou não-terminal), colete itens [A → α•Xβ, a] de I.",
                                    "Avance o ponto • sobre X para formar [A → αX•β, a].",
                                    "Calcule CLOSURE desse novo conjunto para obter GOTO(I, X).",
                                    "Repita para todos os símbolos relevantes no conjunto I.",
                                    "Registre transições como um mapa: símbolo → novo conjunto."
                                  ],
                                  "verification": "Cada GOTO deve levar a um conjunto fechado válido e distinto.",
                                  "estimatedTime": "50 minutos",
                                  "materials": "Tabela de conjuntos parciais, software como Python para prototipagem opcional.",
                                  "tips": "Numere os conjuntos sequencialmente à medida que os descobre para facilitar referências.",
                                  "learningObjective": "Implementar transições GOTO para expandir o autômato.",
                                  "commonMistakes": "Avançar o ponto incorretamente ou esquecer de fechar o conjunto resultante."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Construir o Autômato Canônico Completo",
                                  "subSteps": [
                                    "Inicie com o conjunto I0 = CLOSURE([S' → •S, $]), onde S' é o axioma aumentado.",
                                    "Use uma fila ou pilha para processar conjuntos não visitados.",
                                    "Para cada conjunto processado, calcule GOTO para todos os símbolos e adicione novos conjuntos.",
                                    "Continue até que todos os conjuntos tenham sido processados (fixpoint).",
                                    "Valide a ausência de ciclos ou conjuntos vazios inválidos."
                                  ],
                                  "verification": "O autômato deve ter todos os conjuntos LR(k) interconectados via GOTO sem itens pendentes.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Gráfico de estados (papel ou ferramenta como Graphviz), lista completa de símbolos.",
                                  "tips": "Mantenha um índice de conjuntos visitados para evitar recomputação.",
                                  "learningObjective": "Construir iterativamente o autômato LR(k) completo a partir da gramática.",
                                  "commonMistakes": "Iniciar com conjunto incorreto ou perder transições para símbolos não iniciais."
                                }
                              ],
                              "practicalExample": "Para a gramática S → A | B, A → a, B → b: Construa I0 = CLOSURE([S' → •S, $]) → itens para A e B. GOTO(I0, A) = CLOSURE([A → a•, FIRST(S A))] levando a reduce, etc., formando 4-5 conjuntos com accepts e shifts.",
                              "finalVerifications": [
                                "Todos os conjuntos estão fechados corretamente sem itens duplicados.",
                                "Transições GOTO cobrem todos os símbolos possíveis em cada conjunto.",
                                "Item inicial [S' → .S, $] leva a accept em algum caminho.",
                                "Nenhum conjunto vazio ou inacessível existe.",
                                "Lookaheads são precisos para k=1 ou especificado.",
                                "Autômato é determinístico (um GOTO por símbolo por conjunto)."
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição e representação de itens LR(k) (30%).",
                                "Correção dos cálculos de CLOSURE e GOTO (40%).",
                                "Completude da construção iterativa do autômato (20%).",
                                "Clareza na documentação de transições e conjuntos (10%)."
                              ],
                              "crossCurricularConnections": [
                                "Teoria de Autômatos e Linguagens Formais (Ciência da Computação).",
                                "Teoria dos Grafos (representação do autômato como grafo direcionado).",
                                "Matemática Discreta (fechos e funções de transição).",
                                "Engenharia de Software (ferramentas como Yacc/Bison)."
                              ],
                              "realWorldApplication": "Essencial para gerar tabelas de parsing em compiladores como GCC ou ferramentas como Bison, permitindo análise sintática eficiente de linguagens de programação complexas como C++ ou Java."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.5.3.2",
                            "name": "Detectar e resolver conflitos em parsers LR",
                            "description": "Identificar conflitos shift-reduce e reduce-reduce nas tabelas, explicando como SLR usa FOLLOW, LALR propaga lookaheads e LR(1) os mantém precisos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar itens canônicos LR e construção do autômato",
                                  "subSteps": [
                                    "Estude a definição de itens LR(0) e LR(1), incluindo kernel e closure.",
                                    "Construa o conjunto de itens canônicos para uma gramática simples usando o algoritmo de closure e goto.",
                                    "Desenhe o autômato LR a partir dos estados iniciais e transições.",
                                    "Identifique estados finais e reduções potenciais.",
                                    "Pratique com uma gramática ambígua como E → E + E | id."
                                  ],
                                  "verification": "Confirme que o autômato tem estados corretos sem erros de closure ou goto.",
                                  "estimatedTime": "1-2 horas",
                                  "materials": [
                                    "Livro de Compiladores (Dragon Book)",
                                    "Ferramenta online como JFLAP ou LR Parser Generator"
                                  ],
                                  "tips": "Sempre comece pelo item inicial [S' → .S] para o estado 0.",
                                  "learningObjective": "Compreender a base para detecção de conflitos via estados LR.",
                                  "commonMistakes": [
                                    "Ignorar epsilon-produções no closure",
                                    "Erro em transições goto para símbolos não-terminais"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Construir tabela de parsing LR e detectar conflitos",
                                  "subSteps": [
                                    "Preencha as colunas ACTION e GOTO da tabela usando shift, reduce e error.",
                                    "Para cada célula, verifique múltiplas ações possíveis (shift e reduce).",
                                    "Classifique conflitos: shift-reduce (shift vs reduce) ou reduce-reduce (duas reduces).",
                                    "Marque células conflitantes e liste os itens envolvidos.",
                                    "Teste a tabela com sequências de entrada para reproduzir conflitos."
                                  ],
                                  "verification": "Tabela completa com pelo menos um conflito identificado e anotado.",
                                  "estimatedTime": "2-3 horas",
                                  "materials": [
                                    "Planilha ou software como Bison/Yacc",
                                    "Gramática de exemplo com if-then-else"
                                  ],
                                  "tips": "Use FOLLOW sets preliminarmente para inspecionar reduces.",
                                  "learningObjective": "Detectar conflitos diretamente na tabela de parsing.",
                                  "commonMistakes": [
                                    "Confundir shift com goto",
                                    "Não considerar lookahead em LR(1)"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar conflitos usando SLR(1) com FOLLOW sets",
                                  "subSteps": [
                                    "Calcule FOLLOW sets para todos os não-terminais na gramática.",
                                    "Para shift-reduce: verifique se lookahead está em FOLLOW da produção reduce.",
                                    "Resolva resolvendo se shift é preferido ou reescrevendo gramática.",
                                    "Para reduce-reduce: identifique ambiguidades e priorize uma produção.",
                                    "Atualize a tabela SLR e valide com parsing de strings."
                                  ],
                                  "verification": "Tabela SLR sem conflitos ou com resoluções justificadas.",
                                  "estimatedTime": "1-2 horas",
                                  "materials": [
                                    "Calculadora de FOLLOW online",
                                    "Exemplos de Dragon Book cap. 4"
                                  ],
                                  "tips": "FOLLOW(A) inclui $ se A é start symbol.",
                                  "learningObjective": "Aplicar FOLLOW para resolver conflitos em SLR.",
                                  "commonMistakes": [
                                    "FOLLOW incorreto incluindo FIRST",
                                    "Ignorar precedência em gramáticas ambíguas"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Comparar resoluções em LALR(1) e LR(1)",
                                  "subSteps": [
                                    "Construa itens LR(1) propagando lookaheads espontâneos e propagados.",
                                    "Para LALR: mescle estados com mesmos núcleos, propagando lookaheads.",
                                    "Compare tabelas: LR(1) evita conflitos por precisão, LALR pode introduzir.",
                                    "Resolva conflitos LALR propagando lookaheads adequadamente.",
                                    "Avalie trade-offs: tamanho da tabela vs precisão."
                                  ],
                                  "verification": "Tabelas LALR e LR(1) construídas e diferenças de conflitos destacadas.",
                                  "estimatedTime": "2-3 horas",
                                  "materials": [
                                    "Ferramentas como Menhir ou Bison em modo debug",
                                    "Tutoriais LR(1) vs LALR"
                                  ],
                                  "tips": "Use FIRST e FOLLOW para propagação inicial de lookaheads.",
                                  "learningObjective": "Entender escalabilidade e precisão em parsers reais.",
                                  "commonMistakes": [
                                    "Mesclar estados sem propagar lookaheads",
                                    "Confundir LR(0) com LR(1)"
                                  ]
                                }
                              ],
                              "practicalExample": "Gramática if-then-else: S → if E then S | if E then S else S | other. Construa autômato LR(0), detecte shift-reduce em 'else', resolva com SLR (FOLLOW(S) inclui else), refine com LALR lookahead {else} para then-state.",
                              "finalVerifications": [
                                "Construir tabela LR para gramática dada sem erros de conflito não resolvido.",
                                "Explicar por que SLR falha em dangling else mas LALR resolve.",
                                "Identificar shift-reduce vs reduce-reduce em tabela fornecida.",
                                "Calcular FOLLOW e lookaheads corretos para uma gramática.",
                                "Gerar parser sem conflitos usando Yacc para gramática ambígua.",
                                "Debugar tabela com lookahead propagado em LALR."
                              ],
                              "assessmentCriteria": [
                                "Precisão na detecção e classificação de conflitos (90%+ correto).",
                                "Correção de FOLLOW e lookahead calculations.",
                                "Capacidade de resolver conflitos via reescrita ou técnicas LR(k).",
                                "Análise comparativa SLR/LALR/LR(1) com exemplos.",
                                "Parsing manual de strings com tabela construída.",
                                "Uso eficiente de ferramentas para validação."
                              ],
                              "crossCurricularConnections": [
                                "Teoria da Computação: Autômatos pushdown e linguagens LR(k).",
                                "Algoritmos: Construção de grafos e closure transitivo.",
                                "Programação: Implementação de parsers em linguagens como C/Python.",
                                "Matemática Discreta: Conjuntos, relações e FIRST/FOLLOW.",
                                "Engenharia de Software: Ferramentas de geração de parsers (ANTLR, Bison)."
                              ],
                              "realWorldApplication": "Em compiladores como GCC/Clang, detectores de conflitos em Yacc/Bison garantem parsers eficientes para linguagens reais como C++, evitando ambiguidades em expressões e estruturas de controle."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.5.3.3",
                            "name": "Aplicar ferramentas automáticas para LR(k)",
                            "description": "Descrever uso de geradores como Yacc/Bison para construir parsers LR(1)/LALR(1) a partir de gramáticas, com exemplos de especificação.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Instalar e configurar ferramentas Yacc/Bison",
                                  "subSteps": [
                                    "Instalar o pacote bison no sistema operacional (ex: apt install bison no Linux ou brew install bison no macOS).",
                                    "Verificar a instalação executando 'bison --version' no terminal.",
                                    "Configurar ambiente de desenvolvimento com um editor de texto e compilador C (gcc).",
                                    "Criar um diretório de projeto e preparar arquivos auxiliares como scanner (lexer) simples.",
                                    "Testar bison com um exemplo mínimo para confirmar funcionamento."
                                  ],
                                  "verification": "Executar 'bison --version' e gerar um parser simples sem erros.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Terminal/comando linha",
                                    "gcc instalado",
                                    "Editor de texto (VS Code ou Vim)"
                                  ],
                                  "tips": "Use flex junto com bison para o lexer; comece com Linux para simplicidade.",
                                  "learningObjective": "Configurar ambiente pronto para desenvolvimento de parsers automáticos.",
                                  "commonMistakes": [
                                    "Não instalar dependências como flex",
                                    "Ignorar caminhos de instalação personalizados"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Escrever especificação de gramática em formato Yacc/Bison",
                                  "subSteps": [
                                    "Definir seções: declarações (%token), regras de produção e código C auxiliar.",
                                    "Especificar tokens e gramática para uma linguagem simples (ex: expressões aritméticas).",
                                    "Adicionar ações semânticas para construir árvore de sintaxe.",
                                    "Incluir precedência e associatividade com %left, %right.",
                                    "Validar sintaxe manualmente antes de gerar."
                                  ],
                                  "verification": "Arquivo .y sem erros sintáticos detectados pelo bison -v.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Documentação Bison (manual bison.info)",
                                    "Exemplos de gramáticas LR(1)"
                                  ],
                                  "tips": "Comece com gramática ambígua e resolva com precedências para entender conflitos.",
                                  "learningObjective": "Criar gramáticas LALR(1) válidas com ações semânticas.",
                                  "commonMistakes": [
                                    "Esquecer ponto e vírgula em ações C",
                                    "Gramáticas não LR(1) causando shift-reduce conflicts"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Gerar e compilar o parser automático",
                                  "subSteps": [
                                    "Executar 'bison -d -o parser.c gramatica.y' para gerar parser.tab.c e parser.tab.h.",
                                    "Integrar com lexer (flex) gerando scanner.c.",
                                    "Compilar tudo: gcc -o parser parser.tab.c scanner.c.",
                                    "Analisar relatório de conflitos com 'bison -v gramatica.y'.",
                                    "Resolver conflitos shift-reduce ou reduce-reduce ajustando gramática."
                                  ],
                                  "verification": "Compilação bem-sucedida sem warnings de conflitos e executável gerado.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Flex instalado",
                                    "Compilador gcc",
                                    "Relatório bison.output"
                                  ],
                                  "tips": "Use -d para headers e -t para debug; priorize gramáticas determinísticas.",
                                  "learningObjective": "Automatizar construção de parsers LR(1)/LALR(1) via ferramentas.",
                                  "commonMistakes": [
                                    "Não usar -d causando erros de include",
                                    "Ignorar conflitos no output"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Testar, depurar e otimizar o parser",
                                  "subSteps": [
                                    "Criar casos de teste: entradas válidas, inválidas e ambíguas.",
                                    "Executar parser com inputs e verificar saídas semânticas.",
                                    "Usar yydebug=1 para trace de parsing.",
                                    "Depurar erros com gdb ou prints em ações.",
                                    "Otimizar para performance medindo tempo de parse."
                                  ],
                                  "verification": "Parser aceita 100% entradas válidas e rejeita inválidas corretamente.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Scripts de teste",
                                    "GDB debugger",
                                    "Entradas de exemplo variadas"
                                  ],
                                  "tips": "Teste gramáticas maiores gradualmente; use valgrind para leaks.",
                                  "learningObjective": "Validar e refinar parsers automáticos em cenários reais.",
                                  "commonMistakes": [
                                    "Testes insuficientes para bordas",
                                    "Não ativar debug para shifts"
                                  ]
                                }
                              ],
                              "practicalExample": "Construa um parser para expressões aritméticas (ex: 2+3*4) usando Bison: defina tokens NUM, +, *, (, ); regras como expr: expr '+' term | term; ações imprimem árvore de parse. Gere, compile e teste com 'echo \"2+3*4\" | ./parser'.",
                              "finalVerifications": [
                                "Gerar parser sem conflitos de um arquivo .y personalizado.",
                                "Parser processa entrada válida produzindo saída semântica correta.",
                                "Parser rejeita sintaxe inválida com mensagem de erro apropriada.",
                                "Resolver manualmente um shift-reduce conflict em gramática ambígua.",
                                "Integrar com lexer flex para parsing completo.",
                                "Executar trace de debug mostrando estados LR."
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição de gramáticas LALR(1) sem conflitos.",
                                "Correta implementação de ações semânticas e precedências.",
                                "Eficiência na resolução de erros de parsing.",
                                "Qualidade dos testes cobrindo casos edge.",
                                "Documentação clara do processo e relatórios bison.",
                                "Tempo de execução otimizado do parser gerado."
                              ],
                              "crossCurricularConnections": [
                                "Teoria da Computação: Autômatos e linguagens formais LR(k).",
                                "Engenharia de Software: Ferramentas de automação em desenvolvimento.",
                                "Matemática: Grafos e algoritmos de reconhecimento.",
                                "Linguagens de Programação: Design de sintaxe e semântica."
                              ],
                              "realWorldApplication": "Desenvolvimento de compiladores (GCC, Clang usam variantes), parsers para DSLs em ferramentas como SQL parsers em bancos de dados, ou analisadores sintáticos em IDEs para autocompletar código."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.2.6",
                    "name": "Tratamento de Erros na Análise Sintática",
                    "description": "Técnicas para detecção, relatório e recuperação de erros sintáticos durante o parsing.",
                    "individualConcepts": [
                      {
                        "id": "10.1.2.6.1",
                        "name": "Detecção de Erros Sintáticos",
                        "description": "Técnicas para identificar erros sintáticos durante o processo de parsing, comparando a entrada léxica com as regras da gramática da linguagem.",
                        "specificSkills": [
                          {
                            "id": "10.1.2.6.1.1",
                            "name": "Reconhecer falhas em parsers descendentes (top-down)",
                            "description": "Identificar e explicar como parsers LL(1) e recursivos descendentes detectam erros por falha na previsão de terminais ou não-terminais esperados, usando conjuntos FIRST e FOLLOW.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Conceitos Fundamentais de FIRST e FOLLOW",
                                  "subSteps": [
                                    "Defina os conjuntos FIRST e FOLLOW para uma gramática dada.",
                                    "Calcule manualmente FIRST para todos os não-terminais usando regras de produção.",
                                    "Calcule FOLLOW incorporando regras de sincronização e terminais de fim.",
                                    "Verifique cálculos com exemplos simples de gramáticas LL(1).",
                                    "Compare FIRST e FOLLOW em uma tabela para visualização."
                                  ],
                                  "verification": "Construa tabelas FIRST e FOLLOW corretas para uma gramática de teste sem erros.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Papel e caneta ou editor de texto",
                                    "Exemplos de gramáticas LL(1) impressas ou digitais"
                                  ],
                                  "tips": "Comece com produções simples sem recursão esquerda para evitar confusão inicial.",
                                  "learningObjective": "Dominar o cálculo preciso de FIRST e FOLLOW como base para detecção de falhas.",
                                  "commonMistakes": [
                                    "Incluir ε incorretamente no FIRST",
                                    "Esquecer $ no FOLLOW do axioma",
                                    "Ignorar recursão indireta"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Entender Detecção de Erros em Parsers LL(1)",
                                  "subSteps": [
                                    "Construa a tabela de parsing LL(1) usando FIRST e FOLLOW.",
                                    "Simule o parsing token por token, consultando a tabela para ações.",
                                    "Identifique falha quando entrada não corresponde a célula da tabela (vazio ou conflito).",
                                    "Explique o papel de FOLLOW na recuperação de sincronização pós-erro.",
                                    "Trace um exemplo onde previsão de terminal falha."
                                  ],
                                  "verification": "Simule parsing de input inválido e aponte exatamente onde a tabela indica falha.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Planilha ou ferramenta online para tabelas LL(1)",
                                    "Gramática de exemplo com input inválido"
                                  ],
                                  "tips": "Use cores para marcar células vazias na tabela para visualizar pontos de falha.",
                                  "learningObjective": "Reconhecer falhas LL(1) por ausência de previsão na tabela de parsing.",
                                  "commonMistakes": [
                                    "Confundir conflito com falha de entrada",
                                    "Não usar FOLLOW para ações de pop",
                                    "Ignorar lookahead k=1"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar Falhas em Parsers Recursivos Descendentes",
                                  "subSteps": [
                                    "Implemente pseudocódigo de um parser recursivo descendente para uma gramática.",
                                    "Execute passo a passo, verificando match de terminais esperados via FIRST.",
                                    "Detecte erro quando próximo token não está em FIRST da produção atual.",
                                    "Use FOLLOW para decidir backtrack ou sincronização em caso de falha.",
                                    "Compare com LL(1) destacando diferenças em detecção recursiva."
                                  ],
                                  "verification": "Rastreie execução em papel para input inválido e identifique chamada recursiva falha.",
                                  "estimatedTime": "50 minutos",
                                  "materials": [
                                    "Pseudocódigo impresso",
                                    "Simulador de parser online ou debugger simples"
                                  ],
                                  "tips": "Anote pilha de chamadas recursivas para visualizar profundidade de falha.",
                                  "learningObjective": "Identificar falhas por mismatch em FIRST durante chamadas recursivas.",
                                  "commonMistakes": [
                                    "Backtrack excessivo sem FOLLOW",
                                    "Não tratar ε-produções corretamente",
                                    "Confundir fim de input com erro"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Praticar Identificação e Explicação de Falhas",
                                  "subSteps": [
                                    "Selecione 3 gramáticas com inputs inválidos variados.",
                                    "Para cada, calcule FIRST/FOLLOW, simule parsing e documente ponto de falha.",
                                    "Explique verbalmente ou por escrito o motivo da detecção (terminal/não-terminal inesperado).",
                                    "Teste recuperação de erro usando FOLLOW.",
                                    "Crie seu próprio exemplo de falha e valide."
                                  ],
                                  "verification": "Produza relatório de 3 exemplos com diagramas de falha corretos.",
                                  "estimatedTime": "75 minutos",
                                  "materials": [
                                    "Ferramentas de diagramação como Draw.io",
                                    "Lista de gramáticas de teste"
                                  ],
                                  "tips": "Grave áudio explicando falhas para autoavaliação.",
                                  "learningObjective": "Aplicar conceitos para diagnosticar falhas reais em parsers top-down.",
                                  "commonMistakes": [
                                    "Atribuir falha errada a lookahead",
                                    "Não diferenciar LL(1) de recursivo",
                                    "Omitir uso de FOLLOW"
                                  ]
                                }
                              ],
                              "practicalExample": "Gramática: E → T E' | ( E ) ; E' → + T E' | ε ; T → id | num. Input inválido: id + +. Simulação LL(1): Após parsing 'id +', lookahead '+' não em FIRST(E') nem FOLLOW(E'), falha detectada por célula vazia na tabela.",
                              "finalVerifications": [
                                "Calcule FIRST/FOLLOW corretamente para gramática não-trivial.",
                                "Simule parsing LL(1) e identifique falha exata em input inválido.",
                                "Trace recursivo descendente e aponte mismatch em FIRST.",
                                "Explique uso de FOLLOW na detecção/recuperação.",
                                "Crie exemplo próprio de falha e valide com pares.",
                                "Diferencie falhas terminais vs. não-terminais."
                              ],
                              "assessmentCriteria": [
                                "Precisão nos cálculos de FIRST/FOLLOW (100% correto).",
                                "Correta identificação do token causador de falha.",
                                "Explicação clara do mecanismo de detecção (LL(1) vs. recursivo).",
                                "Uso adequado de FOLLOW em cenários de erro.",
                                "Criatividade e validade no exemplo prático criado.",
                                "Profundidade na análise de sub-passos de simulação."
                              ],
                              "crossCurricularConnections": [
                                "Matemática Discreta: Teoria de conjuntos e relações em FIRST/FOLLOW.",
                                "Lógica e Algoritmos: Predição determinística e backtracking.",
                                "Programação: Implementação de recursão e tabelas de decisão.",
                                "Engenharia de Software: Tratamento de exceções em compiladores."
                              ],
                              "realWorldApplication": "Em compiladores como GCC ou IDEs (VS Code, IntelliJ), parsers top-down detectam erros de sintaxe em código-fonte (ex: ponto-e-vírgula faltante), fornecendo mensagens de erro precisas para desenvolvedores corrigirem código rapidamente."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.6.1.2",
                            "name": "Identificar erros em parsers ascendentes (bottom-up)",
                            "description": "Descrever como parsers LR detectam erros por conflitos na pilha ou falha na redução de produções, analisando estados inválidos na tabela de parsing.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Fundamentos de Parsers Ascendentes LR",
                                  "subSteps": [
                                    "Estude a construção de itens LR(0) ou LR(1) para uma gramática simples.",
                                    "Entenda o processo de shift e reduce usando a pilha e a tabela de parsing.",
                                    "Identifique os componentes da tabela: ação (shift/reduce) e goto.",
                                    "Simule um parsing bem-sucedido em uma entrada válida.",
                                    "Anote como a pilha representa estados e símbolos."
                                  ],
                                  "verification": "Construa manualmente itens LR para uma gramática S → A | B; A → a; B → b e simule parsing de 'a'.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Papel e lápis",
                                    "Documentação de parsers LR (ex: Dragon Book capítulo 4)",
                                    "Ferramenta online como LR Parser Generator"
                                  ],
                                  "tips": "Desenhe a pilha visualmente para melhor compreensão.",
                                  "learningObjective": "Compreender o fluxo normal de parsing bottom-up sem erros.",
                                  "commonMistakes": "Confundir shift com reduce; ignorar lookahead em LR(1)."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar Conflitos na Tabela de Parsing",
                                  "subSteps": [
                                    "Construa a tabela de parsing para uma gramática ambígua, como E → E + T | T; T → id.",
                                    "Localize células com múltiplas ações (shift-reduce ou reduce-reduce).",
                                    "Classifique o tipo de conflito e explique sua causa na gramática.",
                                    "Discuta como precedência/assocatividade resolve conflitos em ferramentas como Yacc.",
                                    "Teste com entradas que acionam o conflito."
                                  ],
                                  "verification": "Gere tabela LR para gramática ambígua e destaque pelo menos um conflito shift-reduce.",
                                  "estimatedTime": "50 minutos",
                                  "materials": [
                                    "Calculadora LR online ou JFLAP",
                                    "Exemplos de gramáticas do livro 'Compilers: Principles, Techniques, and Tools'"
                                  ],
                                  "tips": "Use cores diferentes para ações conflitantes na tabela.",
                                  "learningObjective": "Detectar e classificar conflitos como causa primária de erros em parsers LR.",
                                  "commonMistakes": "Não diferenciar shift-reduce de reduce-reduce; assumir gramática livre de conflitos."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar Estados Inválidos na Pilha Durante Parsing",
                                  "subSteps": [
                                    "Simule parsing passo a passo para uma entrada sintaticamente inválida.",
                                    "Monitore a pilha: procure estados sem ação definida para o símbolo atual.",
                                    "Identifique quando a pilha entra em estado 'aceitar' prematuramente ou trava.",
                                    "Registre o snapshot da pilha no momento do erro.",
                                    "Compare com parsing válido para destacar diferenças."
                                  ],
                                  "verification": "Para entrada inválida 'id +', pause no erro e descreva o estado da pilha.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Simulador de parser LR (ex: Python script ou online tool)",
                                    "Gramática de expressões aritméticas"
                                  ],
                                  "tips": "Use debug mode em ferramentas para pausar e inspecionar pilha.",
                                  "learningObjective": "Reconhecer estados inválidos na pilha como indicadores de erro sintático.",
                                  "commonMistakes": "Ignorar lookahead; confundir erro de pilha com conflito de tabela."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Detectar Falhas na Redução de Produções",
                                  "subSteps": [
                                    "Examine cenários onde uma produção não pode ser reduzida devido a símbolos extras ou faltantes.",
                                    "Simule pop da pilha para reduce e verifique falha por comprimento incorreto.",
                                    "Analise erros de 'dangling else' ou expressões malformadas.",
                                    "Discuta estratégias de recuperação como pop até separador ou skip.",
                                    "Valide com múltiplas entradas errôneas."
                                  ],
                                  "verification": "Identifique falha de redução em 'if (x) if (y) z;' para dangling else.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Exemplos de código C-like com erros",
                                    "Yacc/Bison manual para simulação"
                                  ],
                                  "tips": "Liste produções lado a lado com pilha para visualização.",
                                  "learningObjective": "Diagnosticar erros específicos de redução em parsers bottom-up.",
                                  "commonMistakes": "Não considerar contexto da pilha inteira; focar só no topo."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Integrar Análise e Praticar Diagnóstico Completo",
                                  "subSteps": [
                                    "Escolha uma gramática complexa e gere tabela LR.",
                                    "Parse entradas com erros variados e diagnostique usando todos os métodos.",
                                    "Documente relatório: tipo de erro, localização na pilha/tabela, causa.",
                                    "Teste recuperação de erro e verifique parsing continua.",
                                    "Compare diagnósticos com ferramentas reais como bison -v."
                                  ],
                                  "verification": "Produza relatório de 3 entradas errôneas com diagnósticos precisos.",
                                  "estimatedTime": "50 minutos",
                                  "materials": [
                                    "Bison/Yacc instalado",
                                    "Gramáticas de teste avançadas"
                                  ],
                                  "tips": "Automatize com scripts para múltiplos testes.",
                                  "learningObjective": "Aplicar integralmente detecção de erros em cenários reais de parsing.",
                                  "commonMistakes": "Sobrecarregar diagnóstico sem priorizar conflitos."
                                }
                              ],
                              "practicalExample": "Considere a gramática E → E + T | T; T → id | (E). Para entrada inválida 'id + + id', simule LR(1): na pilha [0, id, +, 5], shift em '+' causa shift-reduce conflict (estado 5 tem shift e reduce); pilha entra em estado inválido sem ação para segundo '+', falhando redução de E → E + T.",
                              "finalVerifications": [
                                "Construa tabela LR sem erros para gramática simples.",
                                "Identifique e classifique 2 conflitos em gramática ambígua.",
                                "Simule parsing de entrada inválida e descreva snapshot da pilha no erro.",
                                "Explique falha de redução em exemplo de dangling else.",
                                "Gere relatório diagnóstico para 3 entradas errôneas.",
                                "Compare simulação manual com output de Bison -v."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de conflitos (shift-reduce vs reduce-reduce): 25%.",
                                "Correta análise de estados inválidos na pilha: 20%.",
                                "Detalhamento de falhas de redução com exemplos: 20%.",
                                "Uso correto de ferramentas/simuladores: 15%.",
                                "Relatório claro e completo de diagnósticos: 10%.",
                                "Compreensão de recuperação de erros: 10%."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Autômatos finitos e linguagens formais (Teoria da Computação).",
                                "Engenharia de Software: Debugging e análise de falhas em ferramentas de build.",
                                "Linguística Computacional: Parsing em PLN para detecção de erros gramaticais.",
                                "Inteligência Artificial: Similaridades com beam search em modelos sequenciais."
                              ],
                              "realWorldApplication": "Em compiladores como GCC/Clang, parsers LR detectam erros sintáticos em código C++ (ex: ponto e vírgula faltante causa falha de redução), permitindo diagnósticos precisos como 'expected ';' before '+'', facilitando desenvolvimento de software robusto."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.6.1.3",
                            "name": "Diferenciar detecção local e global de erros",
                            "description": "Comparar detecção imediata durante o parsing com análise posterior via árvores de sintaxe, destacando vantagens e limitações de cada abordagem.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a Detecção Local de Erros durante o Parsing",
                                  "subSteps": [
                                    "Estude o conceito de detecção local: erros identificados imediatamente durante a leitura token a token no parser.",
                                    "Analise como parsers bottom-up (ex: LR) ou top-down (ex: LL) detectam mismatches sintáticos em tempo real.",
                                    "Identifique exemplos de erros locais: token inesperado, falta de ponto e vírgula.",
                                    "Registre as vantagens: feedback rápido, baixo overhead computacional.",
                                    "Note limitações: pode perder contexto global, gerar cascades de erros."
                                  ],
                                  "verification": "Crie um diagrama de fluxo mostrando um erro local sendo detectado em uma linha de código simples.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Documentação de parsers LL/LR",
                                    "Editor de código como VS Code",
                                    "Exemplos de gramáticas simples em BNF"
                                  ],
                                  "tips": "Use ferramentas como ANTLR para simular parsing e ver erros em tempo real.",
                                  "learningObjective": "Explicar como e por que a detecção local ocorre durante o parsing imediato.",
                                  "commonMistakes": [
                                    "Confundir detecção local com semântica",
                                    "Ignorar impacto em parsers recursivos descendentes"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Compreender a Detecção Global de Erros via Árvores de Sintaxe",
                                  "subSteps": [
                                    "Revise árvores de sintaxe abstrata (AST): estrutura pós-parsing que representa o código validado.",
                                    "Aprenda análise global: percorrer a AST para detectar erros contextuais como escopo incorreto ou tipos incompatíveis.",
                                    "Examine ferramentas como walkers de AST para validação pós-parse.",
                                    "Liste vantagens: visão holística, detecção precisa de erros multi-token.",
                                    "Liste limitações: requer parsing completo bem-sucedido, mais lento."
                                  ],
                                  "verification": "Construa uma AST manual para um snippet de código e anote um erro global nela.",
                                  "estimatedTime": "50 minutos",
                                  "materials": [
                                    "Ferramenta AST explorer como AST Explorer online",
                                    "Livro 'Compilers: Principles, Techniques, and Tools' (Dragon Book)",
                                    "Papel e caneta para diagramas"
                                  ],
                                  "tips": "Comece com linguagens simples como uma mini-linguagem aritmética para construir ASTs.",
                                  "learningObjective": "Descrever o papel da AST na detecção de erros que transcendem tokens locais.",
                                  "commonMistakes": [
                                    "Achar que AST é só para otimização",
                                    "Não diferenciar sintaxe de semântica na análise global"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Comparar Vantagens e Limitações das Duas Abordagens",
                                  "subSteps": [
                                    "Crie uma tabela comparativa: velocidade (local rápido vs global lento), precisão (global melhor contexto), robustez a erros múltiplos.",
                                    "Discuta cenários: local ideal para IDEs interativas, global para compiladores batch.",
                                    "Avalie trade-offs: local gera mais falsos positivos, global pode falhar se parse inicial colapsa.",
                                    "Simule um caso com erro híbrido: local detecta sintaxe básica, global refina.",
                                    "Conclua com melhores práticas: híbrido em compiladores modernos."
                                  ],
                                  "verification": "Preencha uma tabela de comparação com pelo menos 5 critérios e 2 exemplos.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Planilha Google Sheets ou Excel para tabela",
                                    "Artigos sobre error recovery em parsers"
                                  ],
                                  "tips": "Pense em UX: usuários querem feedback imediato (local) mas preciso (global).",
                                  "learningObjective": "Comparar criticamente as duas abordagens em termos de performance e usabilidade.",
                                  "commonMistakes": [
                                    "Superestimar velocidade global",
                                    "Ignorar recuperação de erros (panic mode vs error production)"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar o Conhecimento em um Exemplo Prático de Parser Simples",
                                  "subSteps": [
                                    "Implemente um parser toy em Python para expressões aritméticas.",
                                    "Adicione detecção local: raise error em token mismatch.",
                                    "Gere AST e adicione detecção global: cheque balanceamento de parênteses via traverse.",
                                    "Teste com código inválido e compare diagnósticos.",
                                    "Refatore para abordagem híbrida e avalie melhorias."
                                  ],
                                  "verification": "Execute o parser com 3 casos de teste e documente diferenças nos erros reportados.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Python IDLE ou Jupyter Notebook",
                                    "Biblioteca PLY ou manual parsing code"
                                  ],
                                  "tips": "Use print statements para visualizar o processo passo a passo.",
                                  "learningObjective": "Implementar e contrastar detecção local e global em código real.",
                                  "commonMistakes": [
                                    "Não tratar edge cases como EOF prematuro",
                                    "Confundir parsing com lexing"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um parser para uma linguagem como 'if (x > 0) print(x);', detecção local flagra 'printt(x)' como token inválido imediatamente. Detecção global, após AST parcial, nota que 'if' sem corpo ou escopo incorreto só é visto na árvore completa.",
                              "finalVerifications": [
                                "Explique verbalmente a diferença entre local e global com um exemplo.",
                                "Identifique corretamente 5 erros em um código fornecido usando ambas abordagens.",
                                "Crie uma tabela comparativa precisa sem consultar notas.",
                                "Implemente um parser toy que demonstre ambas detecções.",
                                "Discuta limitações em um compilador real como GCC.",
                                "Proponha melhorias híbridas para um cenário dado."
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição de detecção local vs global (90%+ acerto).",
                                "Compreensão de vantagens/limitações com exemplos concretos.",
                                "Capacidade de implementar parser simples com ambas abordagens.",
                                "Análise crítica de trade-offs em contextos reais.",
                                "Clareza na comunicação via diagramas/tabelas.",
                                "Identificação correta de erros comuns em cenários práticos."
                              ],
                              "crossCurricularConnections": [
                                "Debugging em programação geral (local como linting, global como type checking).",
                                "Inteligência Artificial: parsing em NLP (local token errors vs global semantics).",
                                "Engenharia de Software: error handling em pipelines CI/CD.",
                                "Matemática: teoria de grafos em árvores de sintaxe.",
                                "Design de UX: feedback de erros em editores como VS Code."
                              ],
                              "realWorldApplication": "Em compiladores como Clang ou editores como IntelliJ, detecção local fornece squiggles vermelhos instantâneos durante digitação, enquanto global via AST permite diagnósticos precisos como 'variável não declarada no escopo', melhorando produtividade de desenvolvedores em projetos grandes."
                            },
                            "estimatedTime": "0.25 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.2.6.2",
                        "name": "Relatório de Erros Sintáticos",
                        "description": "Métodos para gerar mensagens de erro claras, informativas e não ambíguas, incluindo posição no código fonte e sugestões de correção.",
                        "specificSkills": [
                          {
                            "id": "10.1.2.6.2.1",
                            "name": "Gerar mensagens de erro posicionadas",
                            "description": "Implementar relatório que inclua linha, coluna e token atual, utilizando pilha de parsing e buffer de entrada para precisão.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Implementar rastreamento de posição no buffer de entrada e lexer",
                                  "subSteps": [
                                    "Inicialize variáveis de linha (line = 1) e coluna (col = 1) no buffer de entrada.",
                                    "Ao consumir caracteres, incremente coluna para cada char não-quebra de linha.",
                                    "Ao encontrar quebra de linha, incremente linha e resete coluna para 1.",
                                    "Associe linha e coluna ao token gerado no lexer.",
                                    "Teste com strings multiline para validar contadores."
                                  ],
                                  "verification": "Inspecione tokens gerados: cada token deve ter atributos line e col corretos via debug print.",
                                  "estimatedTime": "45 minutes",
                                  "materials": "Código fonte do lexer, exemplos de input com quebras de linha, debugger ou print statements.",
                                  "tips": "Use uma estrutura Token com campos line e col; atualize posições antes de retornar o token.",
                                  "learningObjective": "Dominar o cálculo preciso de posições (linha/coluna) durante lexical analysis.",
                                  "commonMistakes": "Off-by-one errors em colunas (esquecer +1 após incremento); não resetar coluna em nova linha."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Integrar posições na pilha de parsing do parser",
                                  "subSteps": [
                                    "Modifique a pilha do parser para armazenar tokens completos (incluindo line/col) em vez de apenas símbolos.",
                                    "Ao fazer shift/reduce, preserve as posições do token top da pilha.",
                                    "Crie uma função para acessar o token atual e sua posição da pilha.",
                                    "Atualize regras de parsing para propagar posições em nós da árvore sintática.",
                                    "Valide pilha via dump durante parsing bem-sucedido."
                                  ],
                                  "verification": "Dump da pilha durante parse: confirme que posições são mantidas em shifts e reduces.",
                                  "estimatedTime": "1 hour",
                                  "materials": "Código do parser (stack-based, e.g., LR), exemplos de gramáticas simples.",
                                  "tips": "Use uma stack de structs TokenNode { symbol, line, col, ... }; evite copiar desnecessariamente.",
                                  "learningObjective": "Entender como manter contexto posicional na stack durante análise bottom-up.",
                                  "commonMistakes": "Perder posições em reduces (não copiar do top); stack overflow por tokens grandes."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Detectar erros sintáticos e capturar contexto posicional",
                                  "subSteps": [
                                    "Identifique pontos de erro no parser (e.g., mismatch em shift/reduce).",
                                    "Ao erro, capture: token atual (top da stack), linha/col do token, símbolo esperado.",
                                    "Salve buffer position atual para fallback preciso se stack falhar.",
                                    "Crie struct ErrorContext { line, col, actualToken, expected }.",
                                    "Integre em handler de erro do parser."
                                  ],
                                  "verification": "Simule erro: verifique se ErrorContext é populado corretamente via logs.",
                                  "estimatedTime": "45 minutes",
                                  "materials": "Parser com gramática intencionalmente ambígua para testes de erro.",
                                  "tips": "Priorize stack top para posição; use buffer pos como backup para precisão.",
                                  "learningObjective": "Capturar estado exato (token, posição) no momento do erro sintático.",
                                  "commonMistakes": "Capturar posição errada (e.g., do lookahead em vez de current); ignorar lookahead token."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Formatar e gerar mensagem de erro posicionada",
                                  "subSteps": [
                                    "Defina template: 'Erro sintático na linha {line}, coluna {col}: esperado {expected}, encontrado {actual}'.",
                                    "Use ErrorContext para preencher template.",
                                    "Adicione snippet de código ao redor (e.g., 2 linhas antes/depois) do buffer.",
                                    "Emita para stderr ou log com cor (opcional).",
                                    "Teste formatação com múltiplos cenários."
                                  ],
                                  "verification": "Execute input inválido: mensagem deve mostrar linha/col/token exatos e snippet relevante.",
                                  "estimatedTime": "30 minutes",
                                  "materials": "Função de formatação string, exemplos de inputs inválidos.",
                                  "tips": "Use str.format ou template literals; inclua snippet para usabilidade.",
                                  "learningObjective": "Criar mensagens legíveis e precisas para debugging.",
                                  "commonMistakes": "Mensagens vagas sem posição; snippet desalinhado por índices errados."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Testar e refinar o relatório de erros em cenários reais",
                                  "subSteps": [
                                    "Crie suíte de testes: erros em diferentes linhas/colunas, multiline, edge cases (EOF).",
                                    "Integre recuperação de erro (panic mode) sem perder precisão.",
                                    "Meça precisão: compare posição reportada vs. manual.",
                                    "Otimize performance (evite overhead em parses normais).",
                                    "Documente API de erro para extensibilidade."
                                  ],
                                  "verification": "Todos testes passam: 100% precisão em linha/col/token; cobertura >90%.",
                                  "estimatedTime": "1 hour",
                                  "materials": "Framework de testes (unit tests), inputs de teste variados.",
                                  "tips": "Use asserts para posição exata; teste com grandes inputs para perf.",
                                  "learningObjective": "Validar robustez do sistema de erros em produção-like scenarios.",
                                  "commonMistakes": "Recuperação quebra posições; testes insuficientes para edge cases como tab/newline."
                                }
                              ],
                              "practicalExample": "Input: 'int x = ;'\nSaída esperada: 'Erro sintático na linha 1, coluna 8: esperado <expressão>, encontrado \";\"'\nSnippet:\nint x = \n      ^",
                              "finalVerifications": [
                                "Mensagem inclui linha, coluna e token atual com precisão 100%.",
                                "Pilha de parsing é consultada corretamente para contexto.",
                                "Buffer fallback garante precisão em erros precoces.",
                                "Snippet de código contextual é exibido corretamente.",
                                "Sistema não crasha em erros múltiplos ou EOF.",
                                "Performance overhead <5% em parses válidos."
                              ],
                              "assessmentCriteria": [
                                "Precisão posicional: linha/col exata em todos testes (obrigatório).",
                                "Uso correto de stack e buffer para contexto (ver código).",
                                "Mensagem formatada clara e informativa (legível por iniciantes).",
                                "Integração seamless no parser sem quebrar parses válidos.",
                                "Cobertura de testes: >=10 casos, incluindo edge cases.",
                                "Documentação inline no código para manutenção."
                              ],
                              "crossCurricularConnections": [
                                "Matemática Discreta: Cálculo de índices 2D (linha/coluna) em strings.",
                                "Design de UX: Mensagens de erro user-friendly como em editores.",
                                "Algoritmos: Estruturas de dados (stack, buffer) para tracking.",
                                "Testes de Software: Unit testing para robustez de erros."
                              ],
                              "realWorldApplication": "Em compiladores como GCC/Clang ou linters (ESLint, Pylint), mensagens posicionadas aceleram debugging em IDEs como VSCode, reduzindo tempo de desenvolvimento em 30-50% para código inválido."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.6.2.2",
                            "name": "Criar descrições descritivas de erros",
                            "description": "Elaborar mensagens como 'token inesperado X, esperado Y ou Z' baseadas em FIRST/FOLLOW ou estados LR, evitando jargões técnicos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender Conjuntos FIRST e FOLLOW na Gramática",
                                  "subSteps": [
                                    "Analise a gramática dada e liste todos os não-terminais.",
                                    "Calcule o conjunto FIRST para cada não-terminal, incluindo tokens iniciais possíveis.",
                                    "Calcule o conjunto FOLLOW para cada não-terminal, identificando tokens que podem segui-los.",
                                    "Crie uma tabela resumida de FIRST e FOLLOW para referência rápida.",
                                    "Compare com exemplos de gramáticas simples para validar cálculos."
                                  ],
                                  "verification": "Tabela de FIRST/FOLLOW completa e correta para uma gramática de teste.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Papel e caneta ou editor de texto, gramática de exemplo (ex: expressões aritméticas).",
                                  "tips": "Comece com gramáticas pequenas para evitar confusão; use diagramas de árvore sintática.",
                                  "learningObjective": "Dominar cálculo de FIRST e FOLLOW para prever tokens esperados.",
                                  "commonMistakes": "Incluir ε (vazio) incorretamente em FIRST; esquecer recursão em FOLLOW."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Simular Parsing LR Até o Ponto de Erro",
                                  "subSteps": [
                                    "Construa ou use uma tabela de parsing LR(0) ou SLR(1) para a gramática.",
                                    "Inicie o parsing com o token de input inválido, rastreando pilha e estado atual.",
                                    "Registre a sequência de shifts e reduces até detectar mismatch (token não esperado).",
                                    "Anote o estado da pilha e o token atual no momento do erro.",
                                    "Repita com 2-3 inputs diferentes para praticar rastreamento."
                                  ],
                                  "verification": "Diagrama de pilha e estados mostrando exatamente onde o parsing falha.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Ferramenta de parsing online ou simulador LR (ex: JFLAP), gramática anotada.",
                                  "tips": "Desenhe a pilha visualmente; pause em cada shift para confirmar.",
                                  "learningObjective": "Simular análise sintática para localizar precisamente o erro.",
                                  "commonMistakes": "Confundir shift com reduce; ignorar lookahead token."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Identificar Tokens Esperados no Estado de Erro",
                                  "subSteps": [
                                    "No estado atual da pilha, liste ações possíveis da tabela LR (shift, reduce, accept).",
                                    "Colete tokens do conjunto FIRST dos símbolos esperados ou FOLLOW se aplicável.",
                                    "Priorize tokens mais prováveis baseados no contexto (ex: tipos numéricos após operador).",
                                    "Liste 2-4 tokens esperados mais comuns, evitando listas exaustivas.",
                                    "Valide cruzando com simulações manuais de inputs corretos."
                                  ],
                                  "verification": "Lista concisa de 2-4 tokens esperados confirmados por tabela LR.",
                                  "estimatedTime": "40 minutos",
                                  "materials": "Tabela LR impressa ou digital, exemplos de inputs válidos/inválidos.",
                                  "tips": "Foquem em tokens semanticamente próximos; use FOLLOW para contexto pós-erro.",
                                  "learningObjective": "Extrair tokens esperados de estados LR sem jargão interno.",
                                  "commonMistakes": "Listar todos os tokens possíveis em vez de relevantes; incluir não-terminais."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Elaborar Mensagem Descritiva Clara e sem Jargão",
                                  "subSteps": [
                                    "Estruture: 'Token inesperado [token_encontrado], esperado [lista_tokens_esperados]'",
                                    "Use nomes legíveis dos tokens (ex: 'número inteiro' em vez de 'INT').",
                                    "Adicione posição do erro: 'na linha X, coluna Y'.",
                                    "Teste legibilidade lendo em voz alta para um não-especialista.",
                                    "Itere: refine para brevidade e precisão."
                                  ],
                                  "verification": "Mensagem gerada compreensível por aluno iniciante em programação.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Editor de texto, exemplos de mensagens de compiladores reais (GCC, Python).",
                                  "tips": "Mantenha abaixo de 100 caracteres; use 'ou' para listas.",
                                  "learningObjective": "Criar mensagens de erro amigáveis e acionáveis.",
                                  "commonMistakes": "Incluir termos como 'FIRST/FOLLOW'; ser vago como 'erro de sintaxe'."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Testar e Refinar com Múltiplos Casos",
                                  "subSteps": [
                                    "Aplique o processo a 3 inputs com erros diferentes na mesma gramática.",
                                    "Compare mensagens geradas com diagnósticos de compiladores reais.",
                                    "Colete feedback simulado: 'Isso ajuda a corrigir?'",
                                    "Ajuste baseados em padrões comuns de confusão do usuário.",
                                    "Documente um template reutilizável para erros recorrentes."
                                  ],
                                  "verification": "Portfólio de 3 mensagens testadas e aprovadas por critérios de clareza.",
                                  "estimatedTime": "50 minutos",
                                  "materials": "Compilador de teste (ex: tiny compiler online), lista de casos de erro.",
                                  "tips": "Varie erros: missing token, extra token, wrong type.",
                                  "learningObjective": "Refinar mensagens para máxima usabilidade em cenários reais.",
                                  "commonMistakes": "Ignorar contexto semântico; mensagens muito técnicas."
                                }
                              ],
                              "practicalExample": "Gramática: Expr -> Term | Expr '+' Term; Term -> 'int' | 'float' | '(' Expr ')'. Input: '1 + foo'. Simulação LR para em estado após '+', pilha=[Expr, '+'], token 'foo'. Esperados: 'int', 'float', '('. Mensagem: 'Token inesperado \"foo\", esperado \"int\", \"float\" ou \"(\" na linha 1, coluna 5.'",
                              "finalVerifications": [
                                "Gera mensagem correta para gramática de expressões com erro de token inválido.",
                                "Lista exatamente 2-4 tokens esperados relevantes sem jargão.",
                                "Inclui posição do erro (linha/coluna).",
                                "Mensagem é legível por não-especialistas.",
                                "Processo funciona para parsers LR e preditivos.",
                                "Template é reutilizável para novas gramáticas."
                              ],
                              "assessmentCriteria": [
                                "Clareza: Mensagem usa linguagem natural, sem termos técnicos.",
                                "Precisão: Tokens esperados baseados corretamente em FIRST/FOLLOW ou LR.",
                                "Concisão: Lista limitada e priorizada de esperados.",
                                "Usabilidade: Inclui localização exata do erro.",
                                "Consistência: Formato padronizado em múltiplos exemplos.",
                                "Validação: Corresponde a diagnósticos de compiladores profissionais."
                              ],
                              "crossCurricularConnections": [
                                "Comunicação: Técnicas de redação clara e persuasiva em mensagens de usuário.",
                                "UI/UX Design: Princípios de feedback de erro intuitivo em interfaces.",
                                "Linguística: Análise de estruturas sintáticas em linguagem natural.",
                                "Psicologia Cognitiva: Redução de carga mental em debugging."
                              ],
                              "realWorldApplication": "Implementar em compiladores como GCC/Clang para diagnósticos amigáveis, IDEs como VS Code para sugestões de correção automática, ou linters em JavaScript/Python para ajudar desenvolvedores iniciantes a debugar código rapidamente."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.6.2.3",
                            "name": "Evitar cascata de erros",
                            "description": "Aplicar técnicas para limitar o número de mensagens por erro primário, usando contadores ou detecção de contexto.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o Conceito de Cascata de Erros",
                                  "subSteps": [
                                    "Estude exemplos de código fonte com um erro sintático inicial que causa múltiplos erros reportados.",
                                    "Analise o fluxo do parser: como um erro primário desalinha o estado, gerando falsos positivos.",
                                    "Compare parsers sem e com controle de cascata usando ferramentas de depuração.",
                                    "Identifique padrões comuns de cascata, como erros em expressões ou blocos.",
                                    "Documente 3 casos reais de cascata em linguagens como C ou Java."
                                  ],
                                  "verification": "Crie um diagrama mostrando o fluxo de cascata antes e depois do controle.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Documentação de compiladores (ex: Dragon Book)",
                                    "Exemplos de código fonte inválido",
                                    "Ferramenta de parser como ANTLR ou Bison"
                                  ],
                                  "tips": "Use inputs minimais para isolar o erro primário.",
                                  "learningObjective": "Explicar verbalmente o mecanismo de cascata de erros e seus impactos.",
                                  "commonMistakes": [
                                    "Confundir erros semânticos com sintáticos",
                                    "Ignorar o papel do lookahead no parser"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar Contador de Erros Simples",
                                  "subSteps": [
                                    "Adicione um contador global de erros no código do parser.",
                                    "Modifique a função de relatório de erro para incrementar o contador e verificar limite (ex: max 5 erros).",
                                    "Pare o parsing ou suprima relatórios adicionais após atingir o limite.",
                                    "Teste com input contendo um erro inicial seguido de sintaxe correta.",
                                    "Registre logs para rastrear ativações do contador."
                                  ],
                                  "verification": "Execute parser em input com 10 erros potenciais e confirme ≤5 reportados.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Código base de um parser LL(1) ou LR",
                                    "Editor de código (VS Code)",
                                    "Compilador de teste"
                                  ],
                                  "tips": "Defina limite baseado no tamanho do input para escalabilidade.",
                                  "learningObjective": "Implementar lógica de contagem que limita relatórios de erro.",
                                  "commonMistakes": [
                                    "Incrementar contador em todos os erros, incluindo warnings",
                                    "Não resetar contador entre arquivos"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Aplicar Detecção de Contexto e Pontos de Sincronização",
                                  "subSteps": [
                                    "Identifique tokens de sincronização (ex: ';', '}', 'else') comuns em gramáticas.",
                                    "Modifique o parser para pular até o próximo token de sincronização após erro.",
                                    "Combine com detecção de contexto: rastreie estado atual (ex: dentro de função).",
                                    "Implemente heurísticas para suprimir erros em contextos desbalanceados.",
                                    "Refatore código para uma função unificada de recuperação de erro."
                                  ],
                                  "verification": "Parser recupera sincronização e reporta apenas erro primário em input malformado.",
                                  "estimatedTime": "75 minutos",
                                  "materials": [
                                    "Gramática de referência (ex: para uma mini-linguagem)",
                                    "Ferramentas de geração de parser",
                                    "Exemplos de inputs com desbalanceamento"
                                  ],
                                  "tips": "Priorize tokens de sincronização de alta frequência na linguagem.",
                                  "learningObjective": "Desenvolver mecanismos de recuperação que previnem propagação de erros.",
                                  "commonMistakes": [
                                    "Pontos de sincronização muito agressivos que pulam código válido",
                                    "Falta de contexto levando a falsos negativos"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Testar e Otimizar a Solução",
                                  "subSteps": [
                                    "Crie suíte de testes com casos de cascata: single error, multi-line errors, nested structures.",
                                    "Meça métricas: número de erros reportados, taxa de recuperação, tempo de parsing.",
                                    "Ajuste parâmetros (limites, sincronizações) baseado em resultados.",
                                    "Compare performance com parser vanilla usando benchmarks.",
                                    "Documente a implementação em comentários e README."
                                  ],
                                  "verification": "Todos testes passam com ≤1 erro reportado por erro primário real.",
                                  "estimatedTime": "90 minutos",
                                  "materials": [
                                    "Framework de testes (ex: pytest para Python parser)",
                                    "Inputs de teste variados",
                                    "Profiler de performance"
                                  ],
                                  "tips": "Use fuzzing para gerar inputs aleatórios com erros.",
                                  "learningObjective": "Validar e refinar técnicas de controle de cascata empiricamente.",
                                  "commonMistakes": [
                                    "Testes insuficientes para edge cases",
                                    "Otimização prematura sem medição"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um parser para uma linguagem similar a C, input 'int x = ; y = 1;' causa cascata (erro em '=', então em ';', etc.). Após implementação: reporta apenas 'expected expression after =' e sincroniza no próximo ';', ignorando y=1 como consequência.",
                              "finalVerifications": [
                                "Parser reporta no máximo 3-5 erros por erro primário em inputs complexos.",
                                "Recuperação de sincronização permite parsing parcial de código restante.",
                                "Contador reseta corretamente entre múltiplos arquivos ou módulos.",
                                "Logs mostram ativação de mecanismos de controle.",
                                "Performance degradada <10% comparado a parser sem controle.",
                                "Testes cobrem 90% dos casos de cascata identificados."
                              ],
                              "assessmentCriteria": [
                                "Precisão: Erros reportados focam no primário (peso 30%).",
                                "Efetividade: Redução >70% em mensagens de cascata (peso 25%).",
                                "Robustez: Funciona em gramáticas variadas (peso 20%).",
                                "Eficiência: Tempo de parsing similar ou melhor (peso 15%).",
                                "Documentação: Código comentado e explicações claras (peso 10%)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Modelagem de estados finitos e contadores probabilísticos.",
                                "Design de Software: Princípios de UX em mensagens de erro.",
                                "Engenharia de Software: Técnicas de fault-tolerance e recovery.",
                                "Linguística Computacional: Análise de estruturas hierárquicas em parsers."
                              ],
                              "realWorldApplication": "Compiladores como GCC/Clang usam isso para fornecer diagnósticos úteis em código com typos, evitando overwhelm do desenvolvedor; IDEs como VS Code integram para feedback em tempo real sem flood de erros."
                            },
                            "estimatedTime": "0.25 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.2.6.3",
                        "name": "Recuperação de Erros Sintáticos",
                        "description": "Estratégias para continuar o parsing após um erro, permitindo análise de múltiplos erros sem parada abrupta.",
                        "specificSkills": [
                          {
                            "id": "10.1.2.6.3.1",
                            "name": "Implementar modo pânico (panic-mode recovery)",
                            "description": "Pular tokens até sincronizar com um conjunto FOLLOW ou marcadores específicos, restaurando a pilha para prosseguir.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Calcular conjuntos FOLLOW e definir marcadores de sincronização",
                                  "subSteps": [
                                    "Analise a gramática da linguagem de programação alvo e identifique todos os não-terminais.",
                                    "Calcule os conjuntos FIRST para cada não-terminal usando o algoritmo padrão (incluindo ε-produções).",
                                    "Compute os conjuntos FOLLOW iterativamente: inicie com $ no FOLLOW do axioma e propague regras de produção.",
                                    "Defina marcadores de sincronização fixos, como ';', '}', ')', EOF, baseados em pontos comuns de delimitação.",
                                    "Implemente funções auxiliares em código para consultar se um token pertence ao FOLLOW de um não-terminal ou é um marcador."
                                  ],
                                  "verification": "Execute uma função de teste que imprima os FOLLOW sets para 3-5 não-terminais e compare manualmente com cálculos teóricos.",
                                  "estimatedTime": "2-3 horas",
                                  "materials": [
                                    "Gramática formal da linguagem (ex: mini-linguagem aritmética)",
                                    "Livro 'Compilers: Principles, Techniques, and Tools' (Dragon Book), capítulo 4",
                                    "Editor de código com suporte a debugging (VS Code ou IntelliJ)"
                                  ],
                                  "tips": [
                                    "Comece cálculos FOLLOW do não-terminal raiz e itere até convergência.",
                                    "Use conjuntos (sets) em linguagens como Python ou Java para evitar duplicatas."
                                  ],
                                  "learningObjective": "Dominar o cálculo preciso de FOLLOW sets e seleção de marcadores para guiar a recuperação.",
                                  "commonMistakes": [
                                    "Confundir FIRST com FOLLOW",
                                    "Esquecer de propagar FOLLOW através de produções com múltiplos não-terminais",
                                    "Não incluir EOF como marcador padrão"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Detectar erros sintáticos no parser principal",
                                  "subSteps": [
                                    "Identifique os pontos de lookahead no parser recursivo descendente ou bottom-up onde erros ocorrem (ex: token atual não matches esperado).",
                                    "Adicione uma função de detecção de erro que verifique se o token atual está no FIRST do esperado ou em FOLLOW.",
                                    "Implemente lançamento de exceção ou flag de erro sem interromper o parsing imediatamente.",
                                    "Registre o erro com posição do token, não-terminal esperado e token encontrado para diagnósticos.",
                                    "Teste detecção com input inválido simples (ex: faltando operador)."
                                  ],
                                  "verification": "Insira um erro sintático proposital e confirme que o parser detecta sem crash, imprimindo mensagem de erro.",
                                  "estimatedTime": "1-2 horas",
                                  "materials": [
                                    "Código fonte base do parser recursivo descendente",
                                    "Suite de testes unitários com casos inválidos",
                                    "Ferramenta de lexer/tokenizer existente"
                                  ],
                                  "tips": [
                                    "Use logging em vez de exceções para manter o fluxo controlado.",
                                    "Sempre inclua posição linha/coluna no relatório de erro."
                                  ],
                                  "learningObjective": "Implementar detecção robusta de mismatches sintáticos sem paralisar o parser.",
                                  "commonMistakes": [
                                    "Parar o parsing no primeiro erro (violando robustez)",
                                    "Não diferenciar erros de lookahead de 1 token vs. mais",
                                    "Ignorar contexto da pilha na detecção"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar pulo de tokens até sincronização",
                                  "subSteps": [
                                    "No modo pânico, consuma (pule) o token atual se não sincronizado.",
                                    "Verifique loop: enquanto token atual não estiver em FOLLOW(não-terminal esperado) nem for marcador, avance o token.",
                                    "Pare o pulo ao encontrar sincronização e reporte tokens pulados como 'recuperados'.",
                                    "Evite loops infinitos limitando pulos a N tokens ou até EOF.",
                                    "Integre com pilha: pop não-terminais até o topo ter FOLLOW contendo o token sincronizador."
                                  ],
                                  "verification": "Teste com input contendo erro no meio: confirme que pula corretamente e sincroniza (ex: pula até ';').",
                                  "estimatedTime": "3-4 horas",
                                  "materials": [
                                    "Código do parser com detecção de erro do step 2",
                                    "Lexer que suporte peek/consume tokens",
                                    "Exemplos de gramáticas com erros comuns"
                                  ],
                                  "tips": [
                                    "Use peek() antes de consume() para decisões sem avançar.",
                                    "Priorize FOLLOW sobre marcadores para precisão."
                                  ],
                                  "learningObjective": "Criar lógica de skip eficiente que minimize perda de contexto.",
                                  "commonMistakes": [
                                    "Pular demais, perdendo declarações inteiras",
                                    "Não popular a pilha corretamente durante skip",
                                    "Loop infinito sem limite de iterações"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Restaurar pilha, continuar parsing e testar recuperação",
                                  "subSteps": [
                                    "Após sincronização, pop pilha até não-terminal cujo FOLLOW inclua o token atual.",
                                    "Descarte tokens pulados da análise semântica, mas continue parsing do resto.",
                                    "Implemente contagem de erros e limite (ex: max 10 erros por arquivo).",
                                    "Crie testes: arquivos com 1-5 erros múltiplos, verifique relatório final e AST parcial.",
                                    "Meça eficácia: % de input parseado apesar de erros."
                                  ],
                                  "verification": "Parse input com múltiplos erros; confirme AST parcial correto e múltiplos diagnósticos.",
                                  "estimatedTime": "2-3 horas",
                                  "materials": [
                                    "Suite de testes abrangente (válidos + inválidos)",
                                    "Ferramenta de visualização de pilha (debugger)",
                                    "Benchmark de performance simples"
                                  ],
                                  "tips": [
                                    "Sempre gere AST mesmo com erros para análise semântica parcial.",
                                    "Teste com gramáticas reais como JSON mini-parser."
                                  ],
                                  "learningObjective": "Garantir continuidade do parsing pós-recuperação com pilha restaurada corretamente.",
                                  "commonMistakes": [
                                    "Não restaurar pilha, causando cascades de erros",
                                    "Continuar sem limite de erros, degradando performance",
                                    "Perder diagnósticos úteis nos relatórios"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um parser recursivo descendente para expressões aritméticas (gramática: Expr -> Term {('+'|'-') Term}), se após '2 + ' vem ';' em vez de número, detecta erro, pula ';' (não em FOLLOW(Expr) = {$,')',';'}? Assume ';' é marcador), popa Expr da pilha se necessário, sincroniza e continua se houver mais código.",
                              "finalVerifications": [
                                "Parser processa arquivos com erros sem crash ou loop infinito.",
                                "Tokens são pulados minimamente até sincronização comprovada.",
                                "Pilha é restaurada corretamente, permitindo parsing posterior.",
                                "Relatórios de erro incluem posição, esperado vs. encontrado.",
                                "Múltiplos erros são detectados e reportados em um único pass.",
                                "Performance não degrada >20% com 10 erros."
                              ],
                              "assessmentCriteria": [
                                "Precisão dos FOLLOW sets (100% correto para gramática testada).",
                                "Eficiência do skip: média <5 tokens pulados por erro.",
                                "Robustez: 90% de cobertura em suite de testes com erros.",
                                "Qualidade dos diagnósticos: claros e acionáveis.",
                                "Integração seamless com parser original sem side-effects.",
                                "Modularidade: funções de recuperação isoladas e reutilizáveis."
                              ],
                              "crossCurricularConnections": [
                                "Algoritmos e Estruturas de Dados (conjuntos e iterações em grafos de gramática).",
                                "Engenharia de Software (gerenciamento de exceções e robustez).",
                                "Teoria da Computação (reconhecimento de linguagens com erros).",
                                "Programação Sistemas (parsers em compiladores e interpretadores).",
                                "Debugging e Testes (estratégias de recuperação em ferramentas dev)."
                              ],
                              "realWorldApplication": "Compiladores como GCC e Clang usam variantes de panic-mode para reportar dezenas de erros por arquivo sem parar, permitindo desenvolvedores corrigirem múltiplos issues rapidamente; similar em linters como ESLint ou editores como VS Code para autocompletar com erros."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.6.3.2",
                            "name": "Aplicar recuperação em nível de frase (phrase-level)",
                            "description": "Inserir ou deletar tokens para completar construções sintáticas locais, como vírgulas ou ponto e vírgula faltantes.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o Conceito de Recuperação em Nível de Frase",
                                  "subSteps": [
                                    "Estude a definição: recuperação phrase-level envolve inserção ou deleção de tokens para corrigir construções sintáticas locais, como vírgulas ou ponto e vírgula faltantes.",
                                    "Analise diferenças com recuperação token-level (erros isolados) e sentence-level (erros maiores).",
                                    "Revise gramáticas context-free e como parsers lidam com ambiguidades locais.",
                                    "Examine diagramas de parsing trees para identificar frases afetadas.",
                                    "Discuta impacto na análise sintática geral."
                                  ],
                                  "verification": "Explique em suas palavras, com um exemplo, o que diferencia recuperação phrase-level de outras.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Documentação de compiladores (ex: Dragon Book capítulo sobre parsing)",
                                    "Exemplos de gramáticas LL/LR"
                                  ],
                                  "tips": "Foque em erros 'locais' que não quebram o parse inteiro.",
                                  "learningObjective": "Definir recuperação phrase-level e identificar seus casos de uso em parsers.",
                                  "commonMistakes": "Confundir com correções semânticas em vez de sintáticas."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar Erros Sintáticos Locais em Código de Entrada",
                                  "subSteps": [
                                    "Parse o código de entrada usando um parser simples e detecte mismatches em non-terminals de frase.",
                                    "Liste tokens comuns que causam erros: vírgulas em listas, ; em declarações, parênteses em expressões.",
                                    "Simule parsing manual em 3-5 exemplos com erros phrase-level.",
                                    "Registre posições exatas de tokens faltantes ou extras.",
                                    "Classifique erros como inseríveis/deletáveis."
                                  ],
                                  "verification": "Anote 5 exemplos de código com erros identificados e suas posições.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Editor de código com syntax highlighting",
                                    "Parser toy em Python (ex: usando PLY ou Lark)"
                                  ],
                                  "tips": "Use lookahead de 1-2 tokens para detectar padrões locais.",
                                  "learningObjective": "Detectar precisamente erros phrase-level em streams de tokens.",
                                  "commonMistakes": "Ignorar contexto anterior, levando a falsos positivos."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar Lógica de Inserção e Deleção de Tokens",
                                  "subSteps": [
                                    "Defina regras heurísticas: insira vírgula após identificadores em listas; delete duplicatas.",
                                    "Codifique função de recovery que tenta inserção/deleção e reparse a frase.",
                                    "Teste em parser skeleton: modifique estado do parser temporariamente.",
                                    "Implemente backtracking para reverter se recovery falhar.",
                                    "Otimize para erros comuns como ',' ou ';'."
                                  ],
                                  "verification": "Execute código corrigido e confirme que parse succeeds sem erros globais.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Linguagem de programação (Python/Java)",
                                    "Biblioteca de parsing (ANTLR, yacc)"
                                  ],
                                  "tips": "Limite recovery a janelas de 5-10 tokens para eficiência.",
                                  "learningObjective": "Codificar mecanismos de inserção/deleção para recovery phrase-level.",
                                  "commonMistakes": "Inserir tokens que criam ambiguidades semânticas."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Testar e Integrar Recuperação no Parser Completo",
                                  "subSteps": [
                                    "Integre recovery no loop principal do parser.",
                                    "Crie suíte de testes com 10 casos: 50% recovery bem-sucedido, 50% falha graciosa.",
                                    "Meça métricas: taxa de recovery, overhead de performance.",
                                    "Debug falhas e refine heurísticas.",
                                    "Documente limitações e casos edge."
                                  ],
                                  "verification": "Parser processa 90% dos testes com recovery sem crash.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Ferramentas de teste unitário (pytest/JUnit)",
                                    "Benchmarks de código com erros sintáticos"
                                  ],
                                  "tips": "Registre todos recoveries em log para análise posterior.",
                                  "learningObjective": "Validar e integrar recovery phrase-level em um parser funcional.",
                                  "commonMistakes": "Recovery propagando erros para fases semânticas."
                                }
                              ],
                              "practicalExample": "Código com erro: 'int x y = 5;' (falta vírgula). Recuperação: insere ',' após 'x' → 'int x, y = 5;'. Parser continua sem perder tokens subsequentes.",
                              "finalVerifications": [
                                "Parser recupera 8/10 casos phrase-level sem perda de sincronia.",
                                "Tempo de parsing aumenta <20% com recovery ativado.",
                                "Nenhum falso recovery altera significado semântico.",
                                "Logs mostram detecção correta de vírgulas/; faltantes.",
                                "Explicação escrita de 3 recoveries manuais."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de erros locais (90%+).",
                                "Eficiência da recovery (overhead <30%).",
                                "Robustez contra edge cases (ex: aninhamento).",
                                "Clareza no código da implementação.",
                                "Capacidade de debugar falhas de recovery."
                              ],
                              "crossCurricularConnections": [
                                "Linguística Computacional: Parsing de linguagem natural similar.",
                                "Desenvolvimento de Software: Error handling em IDEs como VS Code.",
                                "Inteligência Artificial: Heurísticas em modelos de correção de código (ex: GitHub Copilot).",
                                "Matemática Discreta: Autômatos e grafos de parsing.",
                                "Engenharia de Software: Resiliência em sistemas críticos."
                              ],
                              "realWorldApplication": "Em compiladores como GCC/Clang, recovery phrase-level permite diagnósticos úteis em código buggy, melhorando UX para desenvolvedores iniciantes e reduzindo tempo de debug em projetos grandes."
                            },
                            "estimatedTime": "0.75 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.6.3.3",
                            "name": "Usar produções de erro (error productions)",
                            "description": "Incorporar regras gramaticais com 'error' como símbolo para capturar padrões comuns de erro e gerar diagnósticos específicos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os Fundamentos de Error Productions",
                                  "subSteps": [
                                    "Estude a teoria de parsing bottom-up e como erros sintáticos interrompem o processo normal.",
                                    "Analise exemplos de gramáticas ambíguas e como o símbolo 'error' é introduzido como um token não-terminal.",
                                    "Revise regras de precedência e associatividade em gramáticas LR para contextualizar recuperação de erros.",
                                    "Identifique cenários comuns de erros sintáticos, como tokens inesperados ou faltantes.",
                                    "Compare error productions com outras técnicas de recuperação, como panic mode ou phrase-level recovery."
                                  ],
                                  "verification": "Explique em suas palavras o papel do 'error' em uma gramática e forneça um exemplo simples de produção.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Documentação de Yacc/Bison sobre error handling",
                                    "Livro 'Compilers: Principles, Techniques, and Tools' (Dragon Book), capítulo sobre sintaxe",
                                    "Artigos online sobre LR parsing errors"
                                  ],
                                  "tips": "Comece com gramáticas simples para evitar sobrecarga cognitiva; desenhe árvores de parsing manualmente.",
                                  "learningObjective": "Entender conceitualmente como error productions capturam e isolam erros sem parar o parser.",
                                  "commonMistakes": [
                                    "Confundir 'error' com um token terminal real",
                                    "Ignorar impactos na precedência da gramática",
                                    "Subestimar ambiguidades introduzidas pelo 'error'"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Definir Error Productions em uma Gramática",
                                  "subSteps": [
                                    "Crie uma gramática base para expressões aritméticas (ex: expr -> expr + term | term).",
                                    "Identifique pontos de inserção para error productions, como após operadores inválidos.",
                                    "Escreva produções como: expr -> error ';' | expr + error.",
                                    "Ajuste precedências para que 'error' tenha baixa prioridade e permita sincronização.",
                                    "Valide a gramática gerando conflitos LR e resolvendo-os com error handling."
                                  ],
                                  "verification": "Escreva uma gramática com pelo menos 3 error productions e simule parsing manual de uma entrada errada.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Editor de texto ou IDE com suporte a Yacc",
                                    "Ferramenta online de visualização de gramáticas LR",
                                    "Exemplos de gramáticas do Yacc manual"
                                  ],
                                  "tips": "Use %left, %right e %nonassoc para controlar precedências envolvendo 'error'.",
                                  "learningObjective": "Capacitar a construção de gramáticas robustas que incorporam símbolos de erro explicitamente.",
                                  "commonMistakes": [
                                    "Produções de error muito amplas que mascaram erros reais",
                                    "Falta de tokens de sincronização como ';'",
                                    "Não testar precedências com shift/reduce conflicts"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar Error Productions em um Parser Generator",
                                  "subSteps": [
                                    "Configure um ambiente Yacc/Bison com scanner flex.",
                                    "Inclua o token ERROR na definição do lexer (ex: qualquer caractere inválido).",
                                    "Gere o parser com as error productions definidas.",
                                    "Adicione ações semânticas para reportar erros específicos (ex: 'Erro de operador inválido').",
                                    "Compile e execute o parser com inputs de teste."
                                  ],
                                  "verification": "Gere um executável do parser que compile sem warnings e processe inputs errôneos produzindo diagnósticos.",
                                  "estimatedTime": "2.5 horas",
                                  "materials": [
                                    "Yacc/Bison instalado",
                                    "Flex para lexer",
                                    "Makefile simples para build",
                                    "Testes unitários com inputs errôneos"
                                  ],
                                  "tips": "Use yyerror() para mensagens customizadas; teste com valgrind para leaks.",
                                  "learningObjective": "Implementar parsers que usam error productions para recuperação automática.",
                                  "commonMistakes": [
                                    "Não declarar %token ERROR",
                                    "Conflitos não resolvidos levando a stack overflow",
                                    "Lexer passando tokens inválidos sem mapear para ERROR"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Testar e Otimizar Recuperação de Erros",
                                  "subSteps": [
                                    "Crie um conjunto de testes com erros comuns: missing operators, extra tokens, mismatched parentheses.",
                                    "Execute o parser e analise diagnósticos gerados.",
                                    "Meça taxa de recuperação (percentual de código parseado após erro).",
                                    "Refine produções para melhorar diagnósticos específicos (ex: 'erro em declaração de variável').",
                                    "Compare performance com e sem error productions."
                                  ],
                                  "verification": "Documente 5 testes onde o parser recupera corretamente e fornece diagnóstico preciso.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Script de testes automatizados (Bash/Python)",
                                    "Logs de parsing para análise",
                                    "Ferramentas como bison -v para .output files"
                                  ],
                                  "tips": "Priorize sincronização em pontos como ';', '}' para melhor recuperação.",
                                  "learningObjective": "Avaliar e iterar em estratégias de error recovery para robustez.",
                                  "commonMistakes": [
                                    "Testes insuficientes para casos edge",
                                    "Ignorar cascateamento de erros",
                                    "Overfitting de produções para testes específicos"
                                  ]
                                }
                              ],
                              "practicalExample": "Em uma gramática para expressões: expr : expr '+' term | term | error ';' { yyerror('Operador inválido detectado'); } ; Input: '2 + a * 3;' produz diagnóstico 'Operador inválido' e recupera após ';', continuando parsing se houver mais código.",
                              "finalVerifications": [
                                "Explica corretamente o mecanismo de error productions em parsing LR.",
                                "Implementa uma gramática com error productions sem conflitos shift/reduce.",
                                "Parser recupera de pelo menos 80% dos erros de teste fornecidos.",
                                "Gera diagnósticos específicos e não genéricos para diferentes erros.",
                                "Documenta otimizações feitas baseadas em análise de .output do Bison.",
                                "Compara com parsers sem error handling em termos de robustez."
                              ],
                              "assessmentCriteria": [
                                "Precisão das produções de error (cobertura de padrões comuns sem ambiguidades excessivas).",
                                "Qualidade dos diagnósticos (específicos, localizados e úteis).",
                                "Taxa de recuperação em testes variados (>75%).",
                                "Eficiência do parser (tempo de parsing similar ao sem erros).",
                                "Documentação clara de gramática, testes e lições aprendidas.",
                                "Integração correta com lexer e ações semânticas."
                              ],
                              "crossCurricularConnections": [
                                "Linguística Computacional: Gramáticas formais e parsing em PLN.",
                                "Engenharia de Software: Tratamento de exceções e robustez em ferramentas de desenvolvimento.",
                                "Inteligência Artificial: Recovery mechanisms em sistemas de diálogo e chatbots.",
                                "Matemática Discreta: Autômatos e linguagens formais (LR(k))."
                              ],
                              "realWorldApplication": "Compiladores como GCC e Clang usam error productions em seus parsers Yacc/Bison para fornecer diagnósticos úteis em código com erros, permitindo que desenvolvedores corrijam múltiplos problemas em uma única compilação sem crash."
                            },
                            "estimatedTime": "0.75 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.6.3.4",
                            "name": "Comparar estratégias de recuperação",
                            "description": "Avaliar trade-offs entre precisão, velocidade e completude em top-down vs. bottom-up, com exemplos de ferramentas como Yacc/Bison.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender Fundamentos das Estratégias Top-Down e Bottom-Up",
                                  "subSteps": [
                                    "Estude a recuperação top-down (ex.: em parsers LL), onde erros são detectados durante a predição e sincronizados via tokens de follow.",
                                    "Analise recuperação bottom-up (ex.: em parsers LR), usando redução de estados inválidos e pop de stack.",
                                    "Compare fluxos de erro em diagramas de parsing.",
                                    "Identifique diferenças em detecção de ambiguidade.",
                                    "Revise gramáticas LL(1) vs LR(1) para contextualizar."
                                  ],
                                  "verification": "Desenhe diagramas de fluxo para um erro sintático simples em ambos os parsers e explique diferenças.",
                                  "estimatedTime": "2 horas",
                                  "materials": "Documentação de compiladores Dragon Book (Cap. 4), tutoriais LL/LR parsers online.",
                                  "tips": "Use ferramentas visuais como draw.io para diagramas de parsing.",
                                  "learningObjective": "Diferenciar mecanismos básicos de recuperação top-down vs bottom-up.",
                                  "commonMistakes": "Confundir stack handling em bottom-up com lookahead excessivo em top-down."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Definir e Medir Trade-offs: Precisão, Velocidade e Completude",
                                  "subSteps": [
                                    "Defina precisão como taxa de correção sem falsos positivos.",
                                    "Meça velocidade por tokens processados por segundo em erro.",
                                    "Avalie completude como % de código recuperado sem perda.",
                                    "Crie tabela comparativa com métricas qualitativas/quantitativas.",
                                    "Simule benchmarks com gramáticas sintéticas."
                                  ],
                                  "verification": "Crie uma tabela com 3 exemplos de trade-offs medidos para cada métrica.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": "Planilhas Excel/Google Sheets, exemplos de gramáticas do ANTLR ou Yacc.",
                                  "tips": "Priorize métricas em cenários de erro realistas, não ideais.",
                                  "learningObjective": "Quantificar trade-offs chave em recuperação de erros.",
                                  "commonMistakes": "Ignorar overhead computacional em completude alta."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar Implementações em Ferramentas como Yacc/Bison",
                                  "subSteps": [
                                    "Instale Yacc/Bison e compile uma gramática simples com erros.",
                                    "Configure ações de erro em Yacc (yyerrok, yyclearin).",
                                    "Teste recuperação bottom-up em Bison com shift/reduce conflicts.",
                                    "Compare com top-down via ferramentas como ANTLR.",
                                    "Registre logs de erro e tempo de recuperação."
                                  ],
                                  "verification": "Execute parser com input inválido e capture saída de recuperação em ambos.",
                                  "estimatedTime": "3 horas",
                                  "materials": "Yacc/Bison instalados, gramática exemplo (ex.: calculadora), terminal/IDE.",
                                  "tips": "Use -v flag no Bison para estados verbose.",
                                  "learningObjective": "Explorar configurações práticas de recuperação em geradores de parsers.",
                                  "commonMistakes": "Não limpar stack adequadamente, causando loops infinitos."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Comparar Estratégias com Exemplos Práticos e Síntese",
                                  "subSteps": [
                                    "Selecione 2-3 cenários de erro (ex.: missing semicolon, unmatched brace).",
                                    "Aplique ambas estratégias e compare resultados.",
                                    "Sintetize prós/contras em relatório curto.",
                                    "Discuta quando usar cada uma (ex.: top-down para linguagens simples).",
                                    "Proponha híbridos se aplicável."
                                  ],
                                  "verification": "Escreva relatório de 1 página comparando 3 cenários com métricas.",
                                  "estimatedTime": "2 horas",
                                  "materials": "Parser custom em Python/C, exemplos de código com erros injetados.",
                                  "tips": "Automatize testes com scripts para múltiplos inputs.",
                                  "learningObjective": "Sintetizar comparação holística de estratégias.",
                                  "commonMistakes": "Focar só em teoria sem testes empíricos."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Avaliar Impacto em Contextos Reais de Compiladores",
                                  "subSteps": [
                                    "Pesquise implementações em GCC/Clang (LR-based) vs Roslyn (top-down elements).",
                                    "Analise trade-offs em escala (milhares de LOC).",
                                    "Considere extensibilidade para novas linguagens.",
                                    "Debata escolhas em design de compiladores modernos.",
                                    "Documente lições aprendidas."
                                  ],
                                  "verification": "Apresente 3 insights de compiladores reais alinhados à comparação.",
                                  "estimatedTime": "1 hora",
                                  "materials": "Documentação GCC/Clang, papers sobre error recovery (ex.: ACM SIGPLAN).",
                                  "tips": "Busque issues no GitHub de compiladores para casos reais.",
                                  "learningObjective": "Conectar teoria a práticas industriais.",
                                  "commonMistakes": "Generalizar de toy examples para produção sem evidência."
                                }
                              ],
                              "practicalExample": "Em uma gramática de calculadora, input inválido '2 + ; 3 *' : Top-down (LL) pula ';' via follow-set e continua com '3 *'; Bottom-up (Yacc) reduz stack inválido, recupera precisão mas pode ser mais lento em deep nests.",
                              "finalVerifications": [
                                "Lista corretamente 4+ trade-offs com exemplos.",
                                "Explica configurações Yacc/Bison para recuperação.",
                                "Compara precisamente top-down vs bottom-up em 2 cenários.",
                                "Identifica quando uma estratégia supera a outra.",
                                "Propõe métrica personalizada para avaliação.",
                                "Demonstra com código funcional."
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição de métricas (80%+ acurácia).",
                                "Profundidade de análise em ferramentas reais (Yacc/Bison demos).",
                                "Qualidade de comparação quantitativa/qualitativa.",
                                "Relevância de exemplos práticos.",
                                "Clareza na síntese de trade-offs.",
                                "Conexão com aplicações reais."
                              ],
                              "crossCurricularConnections": [
                                "Algoritmos: Otimização de backtracking em parsing.",
                                "Design de Software: Trade-offs em UX de ferramentas dev (IDEs).",
                                "Matemática: Teoria de grafos em estados de parser.",
                                "Engenharia de Sistemas: Performance em compiladores escaláveis."
                              ],
                              "realWorldApplication": "Em compiladores como GCC (bottom-up otimizado para velocidade em C++ large-scale) vs editores como VSCode (top-down para feedback rápido em JS), balanceando completude para devs produtivos sem travamentos."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      }
                    ]
                  }
                ]
              },
              {
                "id": "10.1.3",
                "name": "Organização de Tabelas de Símbolos",
                "description": "Estruturas de dados para armazenar e gerenciar informações sobre identificadores e símbolos durante a compilação.",
                "totalSkills": 51,
                "atomicTopics": [
                  {
                    "id": "10.1.3.1",
                    "name": "Definição e Propósito da Tabela de Símbolos",
                    "description": "Conceito básico de tabela de símbolos como estrutura para armazenar informações sobre identificadores durante a compilação.",
                    "individualConcepts": [
                      {
                        "id": "41.1.1.1",
                        "name": "Definição de Tabela de Símbolos",
                        "description": "Compreensão do conceito fundamental da tabela de símbolos como uma estrutura de dados usada pelo compilador para registrar e acessar informações sobre identificadores declarados no código fonte.",
                        "specificSkills": [
                          {
                            "id": "41.1.1.1.1",
                            "name": "Definir tabela de símbolos",
                            "description": "Fornecer uma definição precisa da tabela de símbolos, descrevendo-a como uma estrutura associativa que mapeia nomes de identificadores para atributos associados, utilizada desde a análise léxica até a geração de código.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender estruturas associativas básicas",
                                  "subSteps": [
                                    "Estudar o conceito de estrutura associativa como um mapeamento chave-valor.",
                                    "Explorar exemplos como dicionários em Python ou Maps em Java.",
                                    "Identificar vantagens sobre arrays lineares, como acesso O(1) médio.",
                                    "Diferenciar chaves únicas de valores compostos.",
                                    "Praticar criando um dicionário simples com identificadores fictícios."
                                  ],
                                  "verification": "Criar um exemplo de estrutura associativa com 3 entradas e explicar seu funcionamento.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Documentação Python dict",
                                    "Artigos sobre hash tables",
                                    "Editor de código online"
                                  ],
                                  "tips": "Use chaves como strings para simular nomes de variáveis.",
                                  "learningObjective": "Dominar o conceito fundamental de mapeamento associativo.",
                                  "commonMistakes": [
                                    "Confundir com listas indexadas numericamente",
                                    "Ignorar colisões em hash tables",
                                    "Usar chaves duplicadas sem tratamento"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar identificadores e atributos em linguagens de programação",
                                  "subSteps": [
                                    "Definir identificadores como nomes de variáveis, funções ou labels.",
                                    "Listar atributos comuns: tipo de dado, escopo, endereço de memória, visibilidade.",
                                    "Analisar um trecho de código fonte simples e destacar identificadores.",
                                    "Classificar atributos por fase de uso no compilador.",
                                    "Mapear manualmente 5 identificadores de um programa exemplo."
                                  ],
                                  "verification": "Listar 4 atributos típicos de um identificador e justificá-los.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Exemplos de código em C ou Pascal",
                                    "Livro 'Compilers: Principles, Techniques, and Tools'",
                                    "Bloco de notas"
                                  ],
                                  "tips": "Comece com linguagens simples como Pascal para clareza.",
                                  "learningObjective": "Reconhecer componentes chave mapeados na tabela.",
                                  "commonMistakes": [
                                    "Omitir escopo como atributo essencial",
                                    "Confundir identificadores com literais",
                                    "Ignorar atributos de tipo durante análise"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explorar o uso da tabela de símbolos nas fases do compilador",
                                  "subSteps": [
                                    "Descrever papel na análise léxica: armazenamento inicial de tokens.",
                                    "Explicar na análise sintática: verificação de declarações e usos.",
                                    "Detalhar na análise semântica: checagem de tipos e escopos.",
                                    "Abordar na geração de código: recuperação de endereços e atributos.",
                                    "Diagrama fluxo de inserção e consulta em cada fase."
                                  ],
                                  "verification": "Desenhar um fluxograma simples mostrando inserções e consultas por fase.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Diagrama de fases do compilador",
                                    "Ferramenta de desenho como Draw.io",
                                    "Vídeos sobre frontend de compiladores"
                                  ],
                                  "tips": "Visualize como uma agenda: insere na declaração, consulta no uso.",
                                  "learningObjective": "Entender a tabela como estrutura persistente ao longo do pipeline.",
                                  "commonMistakes": [
                                    "Limitar uso só à análise semântica",
                                    "Esquecer limpeza pós-escopo",
                                    "Não considerar tabelas aninhadas para blocos"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Formalizar a definição completa da tabela de símbolos",
                                  "subSteps": [
                                    "Sintetizar: 'Estrutura associativa que mapeia identificadores a atributos'.",
                                    "Incluir propósitos: resolução de nomes, verificações semânticas, otimização.",
                                    "Escrever definição em pseudocódigo: Tabela[Nome] = {Tipo, Escopo, ...}.",
                                    "Comparar com implementações reais (ex: LLVM SymbolTable).",
                                    "Redigir uma definição precisa em 100 palavras."
                                  ],
                                  "verification": "Escrever e recitar a definição completa sem consulta.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Pseudocódigo de tabela de símbolos",
                                    "Referências de compiladores como GCC"
                                  ],
                                  "tips": "Use analogia de 'catálogo telefônico' para nomes e detalhes.",
                                  "learningObjective": "Articular definição precisa e abrangente.",
                                  "commonMistakes": [
                                    "Definição vaga sem menção a fases",
                                    "Omitir associatividade chave-valor",
                                    "Confundir com pilha de ativação"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um compilador para linguagem mini: identificador 'var x: integer;' insere na tabela T['x'] = {tipo: 'integer', escopo: 'global', endereco: 0x1000}. Na uso 'x := 5;', consulta T['x'] para validar tipo e gerar código de store em 0x1000.",
                              "finalVerifications": [
                                "Explicar tabela de símbolos como mapeamento chave-valor sem hesitação.",
                                "Listar pelo menos 4 atributos comuns corretamente.",
                                "Descrever uso em 3 fases do compilador com exemplos.",
                                "Criar um exemplo prático de inserção/consulta.",
                                "Diferenciar de estruturas como pilha ou heap.",
                                "Identificar necessidade de tabelas hierárquicas para escopos aninhados."
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição (mapeamento associativo explícito).",
                                "Completude de atributos e fases mencionadas.",
                                "Clareza na descrição de inserção e consulta.",
                                "Uso de exemplos concretos e relevantes.",
                                "Capacidade de analogias para compreensão.",
                                "Ausência de confusões com outras estruturas de dados."
                              ],
                              "crossCurricularConnections": [
                                "Banco de Dados: Similar a índices hash para consultas rápidas.",
                                "Estruturas de Dados: Aplicação direta de hash tables e árvores.",
                                "Linguagens de Programação: Dicionários em Python/Rust para protótipos.",
                                "Engenharia de Software: Gerenciamento de namespaces em IDEs."
                              ],
                              "realWorldApplication": "Em compiladores como GCC ou Clang, tabelas de símbolos resolvem nomes em milhões de linhas de código C++, habilitando detecção de erros, otimizações e geração de executáveis eficientes; também em IDEs como VS Code para autocompletar e refatoração."
                            },
                            "estimatedTime": "0.25 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "41.1.1.1.2",
                            "name": "Identificar características básicas",
                            "description": "Reconhecer as propriedades essenciais da tabela de símbolos, como suporte a inserção, busca, atualização e remoção de entradas para identificadores, garantindo eficiência em tempo de compilação.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a definição e propósito da Tabela de Símbolos",
                                  "subSteps": [
                                    "Leia a definição: uma estrutura de dados que armazena informações sobre identificadores (variáveis, funções, etc.) durante a compilação.",
                                    "Identifique o propósito principal: mapear nomes de símbolos para atributos como tipo, escopo e localização.",
                                    "Diferencie de outras estruturas: não é apenas uma lista, mas um mapa eficiente para consultas rápidas.",
                                    "Anote exemplos de identificadores: variáveis locais, globais, parâmetros de funções.",
                                    "Desenhe um diagrama simples de uma tabela vazia."
                                  ],
                                  "verification": "Escreva uma definição em suas palavras e desenhe um diagrama básico; verifique se inclui mapeamento nome-atributos.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e caneta ou editor de diagramas (ex: Draw.io)",
                                    "Documentação de compiladores básicos (PDF ou wiki)"
                                  ],
                                  "tips": "Use analogia com uma agenda telefônica: nome -> informações.",
                                  "learningObjective": "Definir precisamente o que é uma tabela de símbolos e seu papel na compilação.",
                                  "commonMistakes": "Confundir com tabela de literais ou assumir que armazena código objeto."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar as operações básicas suportadas",
                                  "subSteps": [
                                    "Liste as operações CRUD: Inserção (adicionar novo identificador), Busca (localizar por nome), Atualização (modificar atributos), Remoção (excluir ao sair de escopo).",
                                    "Para cada operação, descreva o que acontece: ex. inserção verifica duplicatas antes de adicionar.",
                                    "Simule inserção: para 'int x;', adicione entrada {nome: 'x', tipo: 'int', escopo: global}.",
                                    "Simule busca: durante uso de 'x', encontre a entrada rapidamente.",
                                    "Simule remoção: ao fim de bloco, remova variáveis locais."
                                  ],
                                  "verification": "Crie uma tabela manual com 3 identificadores e execute as 4 operações, registrando resultados.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Planilha ou tabela em editor de texto (ex: Google Sheets)",
                                    "Pseudocódigo de exemplo"
                                  ],
                                  "tips": "Pense em hash tables para entender por que busca deve ser O(1) em média.",
                                  "learningObjective": "Reconhecer e descrever as quatro operações essenciais: inserção, busca, atualização e remoção.",
                                  "commonMistakes": "Esquecer verificação de duplicatas na inserção ou ignorar escopos na remoção."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar requisitos de eficiência em tempo de compilação",
                                  "subSteps": [
                                    "Entenda por que eficiência importa: compiladores processam milhões de linhas; atrasos propagam.",
                                    "Compare complexidades: busca deve ser O(1) ou O(log n), não O(n).",
                                    "Discuta estruturas subjacentes: hash tables para acesso rápido, árvores para escopos aninhados.",
                                    "Calcule exemplo: para 10.000 símbolos, O(n) busca = desastre; O(1) = instantâneo.",
                                    "Identifique trade-offs: hash tables vs. árvores balanceadas."
                                  ],
                                  "verification": "Explique verbalmente ou por escrito por que eficiência é crucial e sugira uma estrutura adequada.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Calculadora ou simulador online de complexidade (ex: Big-O cheat sheet)",
                                    "Artigo sobre tabelas de símbolos em compiladores"
                                  ],
                                  "tips": "Meça tempo de execução em um script simples de busca linear vs. hash.",
                                  "learningObjective": "Explicar como as operações garantem eficiência durante a fase de compilação.",
                                  "commonMistakes": "Subestimar impacto de buscas lentas ou ignorar colisões em hashes."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Reconhecer propriedades essenciais em um contexto prático",
                                  "subSteps": [
                                    "Revise propriedades: suporte a múltiplos escopos, armazenamento de atributos (tipo, endereço), thread-safety em compiladores paralelos.",
                                    "Analise um snippet de código: identifique onde cada operação ocorre.",
                                    "Liste propriedades não funcionais: persistência durante fases de compilação, limpeza automática.",
                                    "Compare com linguagens reais: como Java ou C gerenciam símbolos.",
                                    "Crie checklist de características básicas."
                                  ],
                                  "verification": "Aplique checklist a um exemplo de código e confirme todas propriedades essenciais.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Código-fonte simples em C ou pseudocódigo",
                                    "Editor de código (ex: VS Code)"
                                  ],
                                  "tips": "Use depuradores de compiladores open-source para observar tabelas reais.",
                                  "learningObjective": "Identificar todas as características básicas em cenários reais de compilação.",
                                  "commonMistakes": "Confundir propriedades com implementações específicas (ex: sempre hash table)."
                                }
                              ],
                              "practicalExample": "Considere o código: int x = 1; { int y = 2; x++; } Tabela inicia vazia -> Inserir 'x' (global, tipo int) -> Inserir 'y' (local) -> Busca 'x' para incremento -> Atualizar 'x' -> Remover 'y' ao sair de escopo. Verifique eficiência: todas ops em O(1).",
                              "finalVerifications": [
                                "Pode listar e descrever as 4 operações principais (inserção, busca, atualização, remoção)?",
                                "Explica por que eficiência O(1) é essencial para compilação?",
                                "Identifica propriedades como suporte a escopos em um exemplo de código?",
                                "Cria uma tabela de símbolos manual para um programa simples?",
                                "Diferencia tabela de símbolos de outras estruturas de dados?",
                                "Reconhece atributos armazenados (tipo, escopo, localização)?"
                              ],
                              "assessmentCriteria": [
                                "Precisão na descrição das operações CRUD (100% cobertura).",
                                "Compreensão demonstrada de eficiência temporal com exemplos quantitativos.",
                                "Aplicação correta de propriedades em cenários práticos.",
                                "Ausência de confusões comuns (ex: escopo vs. globalidade).",
                                "Criatividade em analogias e verificações pessoais.",
                                "Completude da checklist de características essenciais."
                              ],
                              "crossCurricularConnections": [
                                "Estruturas de Dados: Hash Tables e Árvores para implementação.",
                                "Algoritmos: Análise de Complexidade Big-O.",
                                "Linguagens de Programação: Gerenciamento de escopos em C/Java.",
                                "Engenharia de Software: Design de sistemas eficientes em compiladores."
                              ],
                              "realWorldApplication": "Em compiladores como GCC ou Clang, tabelas de símbolos aceleram análise semântica, detectam erros (redeclarações) e habilitam otimizações; em IDEs como VS Code, suportam autocompletar e refatoração em tempo real."
                            },
                            "estimatedTime": "0.25 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "41.1.1.1.3",
                            "name": "Diferenciar de outras estruturas",
                            "description": "Comparar a tabela de símbolos com estruturas simples como listas ou arrays, destacando sua capacidade de associação rápida por chave (nome do identificador) em contextos de compiladores.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender as Características da Tabela de Símbolos",
                                  "subSteps": [
                                    "Defina o que é uma tabela de símbolos: uma estrutura que mapeia identificadores (chaves) para atributos como tipo, escopo e endereço.",
                                    "Identifique seu propósito principal em compiladores: armazenar e recuperar informações sobre símbolos de forma eficiente durante análise léxica, sintática e semântica.",
                                    "Note que tipicamente usa hash tables ou árvores para associação chave-valor rápida.",
                                    "Destaque propriedades chave: inserção, busca e remoção por nome de identificador em tempo médio O(1).",
                                    "Compare superficialmente com estruturas sequenciais para notar a diferença inicial."
                                  ],
                                  "verification": "Escreva uma definição de 3 frases da tabela de símbolos e liste 3 atributos armazenados.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Documentação sobre compiladores (ex: Dragon Book capítulo 2)",
                                    "Notebook para anotações"
                                  ],
                                  "tips": "Visualize como um dicionário onde chaves são nomes de variáveis.",
                                  "learningObjective": "Dominar o conceito e propósito da tabela de símbolos em compiladores.",
                                  "commonMistakes": [
                                    "Confundir com pilha de escopos; foque em mapeamento chave-valor."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Revisar Estruturas Alternativas: Listas e Arrays",
                                  "subSteps": [
                                    "Descreva arrays: estruturas indexadas numericamente, acesso O(1) por índice, mas busca por valor/chave requer varredura O(n).",
                                    "Explique listas ligadas: sequenciais, inserção/fusão fácil, mas busca sempre O(n) sem índice.",
                                    "Discuta limitações para símbolos: nomes de identificadores são strings arbitrárias, não índices numéricos fixos.",
                                    "Exemplo: Em um array de variáveis, encontrar 'x' requer loop linear.",
                                    "Liste prós/cons: arrays bons para acesso direto por posição, ruins para busca por chave."
                                  ],
                                  "verification": "Crie diagramas simples de array e lista com 5 elementos e marque tempo de busca para chave aleatória.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Papel e caneta para diagramas",
                                    "Exemplos de código em C ou Python para listas/arrays"
                                  ],
                                  "tips": "Pense em um telefone: discar número (índice) é rápido, mas achar nome requer folhear toda agenda (O(n)).",
                                  "learningObjective": "Entender limitações de listas e arrays para mapeamento por chave string.",
                                  "commonMistakes": [
                                    "Achar que arrays suportam busca rápida por string; teste com código."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Comparar Diferenças Chave: Performance e Associação",
                                  "subSteps": [
                                    "Compare tempo de busca: Tabela de símbolos (hash): O(1) médio; Lista/Array: O(n) para chave.",
                                    "Analise associação: Tabela usa hash de string para índice; listas usam comparação sequencial.",
                                    "Discuta colisões em hash tables e como resolvidas (encadeamento/chaining).",
                                    "Avalie inserção: Hash O(1); lista O(n) se no meio.",
                                    "Considere cenários de compilador: milhares de símbolos, busca frequente justifica hash."
                                  ],
                                  "verification": "Monte uma tabela comparativa com colunas: Estrutura, Busca por Chave, Inserção, Adequado para Compiladores?",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Planilha ou tabela Markdown",
                                    "Gráficos de complexidade Big O"
                                  ],
                                  "tips": "Use notação Big O para quantificar: O(1) vs O(n) é exponencial em escala.",
                                  "learningObjective": "Identificar por que tabelas de símbolos superam listas/arrays em compiladores.",
                                  "commonMistakes": [
                                    "Ignorar custo médio vs pior caso em hash tables."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar Comparação no Contexto de Compiladores",
                                  "subSteps": [
                                    "Simule fase de análise semântica: declarar 'int x=5;' requer inserir/buscar 'x' rapidamente.",
                                    "Discuta gerenciamento de escopo: tabelas aninhadas para blocos/funções vs listas planas.",
                                    "Exemplo: Em loop de parsing, lookup 'x' 100x; hash vence.",
                                    "Avalie trade-offs: memória extra em hash vs simplicidade de listas.",
                                    "Conclua: Tabelas otimizadas para compiladores por velocidade em lookups por nome."
                                  ],
                                  "verification": "Escreva pseudocódigo de lookup em tabela vs lista e calcule tempos para 1000 símbolos.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Pseudocódigo editor (ex: VS Code)",
                                    "Simulador online de Big O"
                                  ],
                                  "tips": "Teste com código real: implemente ambos e meça tempo com timer.",
                                  "learningObjective": "Aplicar diferenciação prática em fluxo de compilador.",
                                  "commonMistakes": [
                                    "Subestimar frequência de lookups em compiladores reais."
                                  ]
                                }
                              ],
                              "practicalExample": "Em um compilador simples para uma linguagem mini, ao processar 'int foo = 42;', uma lista de símbolos busca 'foo' linearmente (lento para 10k vars). Uma hash table (dict em Python) acha em O(1): symbols['foo'] = {'type':'int', 'addr':0x100}. Teste: crie dict vs list, insira 1000 vars e busque aleatória 100x.",
                              "finalVerifications": [
                                "Explicar em 1 min por que hash table é preferida para símbolos.",
                                "Montar tabela comparativa precisa com tempos Big O.",
                                "Simular lookup em compilador com 3 exemplos de código.",
                                "Identificar 2 cenários onde lista seria melhor (raro).",
                                "Diferenciar colisão hash de busca linear falha.",
                                "Listar 3 atributos de símbolo recuperados via chave.",
                                "Defender escolha de tabela vs array em debate simulado."
                              ],
                              "assessmentCriteria": [
                                "Precisão conceitual: 100% acerto em definições/diferenças.",
                                "Profundidade análise: inclui Big O e cenários reais.",
                                "Criatividade exemplos: práticos e relevantes a compiladores.",
                                "Clareza explicação: usa analogias e diagramas.",
                                "Completude verificações: cobre todos aspectos performance/uso."
                              ],
                              "crossCurricularConnections": [
                                "Estruturas de Dados: Hash tables vs árvores em CS geral.",
                                "Bancos de Dados: Índices hash para queries rápidas.",
                                "Algoritmos: Análise de complexidade e otimização.",
                                "Linguagens de Programação: Dicionários em Python/JS para simulação.",
                                "Engenharia de Software: Trade-offs performance vs simplicidade."
                              ],
                              "realWorldApplication": "Em compiladores como GCC ou Clang, tabelas de símbolos com hash maps permitem resolução rápida de identificadores em código fonte grande (milhões linhas), acelerando build times; similar em IDEs para autocompletar variáveis instantaneamente."
                            },
                            "estimatedTime": "0.25 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "41.1.1.2",
                        "name": "Propósito da Tabela de Símbolos",
                        "description": "Entender os objetivos principais da tabela de símbolos no processo de compilação, focando no gerenciamento de informações para análises semânticas e resolução de referências.",
                        "specificSkills": [
                          {
                            "id": "41.1.1.2.1",
                            "name": "Explicar armazenamento de identificadores",
                            "description": "Descrever como a tabela de símbolos armazena identificadores encontrados durante a análise léxica e sintática, permitindo rastreamento contínuo ao longo das fases de compilação.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender Análise Léxica e Identificadores",
                                  "subSteps": [
                                    "Estude o que é análise léxica (scanner) e como ela tokeniza o código fonte em identificadores, palavras-chave e símbolos.",
                                    "Identifique exemplos de identificadores: nomes de variáveis, funções e classes (ex: 'int x;', 'main()').",
                                    "Diferencie identificadores de outros tokens como operadores e literais.",
                                    "Revise como tokens de identificadores são passados para a análise sintática (parser).",
                                    "Anote diferenças entre fase léxica e sintática no contexto de armazenamento."
                                  ],
                                  "verification": "Crie um fluxograma simples mostrando o fluxo de um identificador da fonte para o tokenizador.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Livro texto de compiladores (ex: 'Compilers: Principles, Techniques, and Tools'), editor de texto para exemplos de código.",
                                  "tips": "Use cores diferentes no fluxograma para léxica vs. sintática para visualizar melhor.",
                                  "learningObjective": "Explicar o papel da análise léxica na identificação inicial de identificadores.",
                                  "commonMistakes": "Confundir identificadores com palavras-chave; lembre-se que palavras-chave são tokens fixos."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Explorar Estrutura da Tabela de Símbolos",
                                  "subSteps": [
                                    "Descreva componentes básicos de uma entrada na tabela: nome do identificador, tipo, escopo, endereço de memória.",
                                    "Aprenda sobre hashing para armazenamento eficiente (ex: hash table para busca rápida).",
                                    "Estude inserção: durante léxica/sintática, novo identificador é adicionado se não existir.",
                                    "Discuta colisões e resolução em tabelas de hash.",
                                    "Visualize com diagrama: tabela como array de buckets com listas encadeadas."
                                  ],
                                  "verification": "Desenhe uma tabela de símbolos vazia e adicione 3 entradas manualmente.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Papel e caneta para diagramas, ferramenta online como draw.io, pseudocódigo de hash table.",
                                  "tips": "Comece com tabela simples linear antes de hash para construir intuição.",
                                  "learningObjective": "Descrever a estrutura de dados usada para armazenar identificadores.",
                                  "commonMistakes": "Ignorar escopo; sempre associe identificadores a blocos/escopos."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Simular Armazenamento Durante Análises Léxica e Sintática",
                                  "subSteps": [
                                    "Pegue um código fonte simples (ex: função com variáveis locais).",
                                    "Simule scanner: liste tokens identificadores encontrados.",
                                    "No parser: ao declarar variável, insira na tabela; ao usar, busque e verifique.",
                                    "Registre atualizações: adicione tipo durante declaração, atualize escopo.",
                                    "Teste redeclaração: detecte erros se identificador já existe no escopo."
                                  ],
                                  "verification": "Execute simulação passo-a-passo e liste mudanças na tabela após cada token.",
                                  "estimatedTime": "75 minutos",
                                  "materials": "Exemplo de código C simples, planilha ou tabela em editor para simular a tabela de símbolos.",
                                  "tips": "Use trace de debug imaginário: imprima 'Inserindo ID: x, tipo: int' a cada passo.",
                                  "learningObjective": "Demonstrar como identificadores são inseridos e consultados nas fases iniciais.",
                                  "commonMistakes": "Não diferenciar inserção (declaração) de lookup (uso); pratique ambos."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Entender Rastreamento nas Fases Posteriores de Compilação",
                                  "subSteps": [
                                    "Revise fases: semântica (tipos), otimização, geração de código.",
                                    "Explique como tabela é usada: verificação de tipos, alocação de memória.",
                                    "Discuta escopos aninhados: tabelas hierárquicas ou pilha de escopos.",
                                    "Simule passagem de tabela para próxima fase: exportar símbolos globais.",
                                    "Aborde remoção: limpar escopos locais ao final de blocos."
                                  ],
                                  "verification": "Crie narrativa descrevendo jornada de um identificador da léxica ao código objeto.",
                                  "estimatedTime": "50 minutos",
                                  "materials": "Diagrama de pipeline de compilador, notas das fases anteriores.",
                                  "tips": "Pense na tabela como 'diário de vida' do identificador ao longo da compilação.",
                                  "learningObjective": "Explicar continuidade do rastreamento de identificadores além da análise.",
                                  "commonMistakes": "Achar que tabela é só para front-end; ela persiste no back-end."
                                }
                              ],
                              "practicalExample": "Considere o código C: int main() { int x = 5; x++; return x; }. Durante léxica: tokens 'int', 'main', 'x'. Sintática: insere 'main' (função), 'x' (int, escopo local). Semântica: verifica tipo de x em x++. Geração: aloca memória para x na stack frame de main.",
                              "finalVerifications": [
                                "Descreva verbalmente o processo de armazenamento de um identificador específico.",
                                "Desenhe tabela de símbolos populada para um snippet de código dado.",
                                "Identifique erros em uma tabela de símbolos simulada (ex: tipo errado).",
                                "Explique impacto de não armazenar identificadores corretamente.",
                                "Simule rastreamento de identificador através de 3 fases de compilação.",
                                "Compare tabelas de símbolos em linguagens diferentes (C vs. Python)."
                              ],
                              "assessmentCriteria": [
                                "Precisão na descrição de inserção durante léxica/sintática (90% correta).",
                                "Completude da estrutura da tabela (inclui nome, tipo, escopo).",
                                "Correta explicação de hashing e resolução de colisões.",
                                "Demonstração clara de rastreamento contínuo nas fases.",
                                "Uso de exemplos concretos sem erros conceituais.",
                                "Capacidade de identificar e corrigir erros comuns em simulações."
                              ],
                              "crossCurricularConnections": [
                                "Estruturas de Dados: Tabelas de hash e árvores para gerenciamento de símbolos.",
                                "Banco de Dados: Índices e chaves primárias semelhantes a identificadores únicos.",
                                "Programação: Escopos e namespaces em linguagens modernas.",
                                "Engenharia de Software: Debuggers e IDEs usam tabelas de símbolos para intellisense."
                              ],
                              "realWorldApplication": "Em compiladores como GCC ou Clang, tabelas de símbolos permitem detecção de erros (ex: uso antes de declaração), otimização (inline de funções) e ferramentas de depuração (listar variáveis locais no GDB)."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": [
                              "41.1.1.1.1"
                            ]
                          },
                          {
                            "id": "41.1.1.2.2",
                            "name": "Relacionar com verificações semânticas",
                            "description": "Explicar o papel da tabela na detecção de erros semânticos, como redeclarações ou usos indefinidos de identificadores, consultando atributos armazenados para validação.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender Verificações Semânticas e o Papel da Tabela de Símbolos",
                                  "subSteps": [
                                    "Definir análise semântica como a fase que verifica o significado do código além da sintaxe.",
                                    "Explicar que erros semânticos incluem redeclarações, usos indefinidos e incompatibilidades de tipo.",
                                    "Descrever a tabela de símbolos como um repositório dinâmico de atributos de identificadores (nome, tipo, escopo).",
                                    "Relacionar a tabela à detecção: ela armazena declarações para consultas durante a análise.",
                                    "Identificar o fluxo: preencher tabela na declaração e consultar na utilização."
                                  ],
                                  "verification": "Listar três erros semânticos comuns detectados pela tabela e explicar como ela os identifica.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Diagrama de fases de compilador",
                                    "Exemplos de código com erros semânticos"
                                  ],
                                  "tips": "Visualize a tabela como um 'dicionário de contexto' que cresce com o código.",
                                  "learningObjective": "Compreender como a tabela de símbolos suporta a análise semântica.",
                                  "commonMistakes": "Confundir análise semântica com sintática (estrutura vs. significado)."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Detectar Redeclarações de Identificadores",
                                  "subSteps": [
                                    "Ao processar uma declaração, buscar o identificador no escopo atual da tabela.",
                                    "Se o identificador já existir no mesmo escopo, reportar erro de redeclaração.",
                                    "Analisar exemplo: 'int x; int x;' – segunda declaração falha na busca.",
                                    "Considerar escopos aninhados: permitir redeclaração em escopo filho se shadowed.",
                                    "Implementar lógica: inserir apenas se não encontrado, senão erro."
                                  ],
                                  "verification": "Simular tabela para código com redeclaração e identificar o erro corretamente.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Editor de código",
                                    "Pseudocódigo de inserção na tabela"
                                  ],
                                  "tips": "Sempre busque primeiro, insira depois – ordem crítica para evitar duplicatas.",
                                  "learningObjective": "Dominar a detecção de redeclarações via busca na tabela.",
                                  "commonMistakes": "Ignorar escopos hierárquicos, permitindo redeclarações indevidas em escopos irmãos."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Detectar Usos Indefinidos de Identificadores",
                                  "subSteps": [
                                    "Ao encontrar um uso (leitura/atribuição), buscar o identificador da tabela, começando pelo escopo atual.",
                                    "Percorrer escopos pais se não encontrado, respeitando regras de visibilidade.",
                                    "Se ausente em todos os escopos, reportar erro de 'identificador não declarado'.",
                                    "Exemplo: 'x = 5;' sem 'int x;' prévio – busca falha.",
                                    "Diferenciar de shadowing: uso em escopo filho resolve local primeiro."
                                  ],
                                  "verification": "Para um snippet de código, traçar buscas na tabela e confirmar erros de uso indefinido.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Exemplos de código com escopos aninhados",
                                    "Diagrama de pilha de escopos"
                                  ],
                                  "tips": "Busca é de dentro para fora: priorize escopo local para shadowing correto.",
                                  "learningObjective": "Aplicar buscas hierárquicas para validar usos de identificadores.",
                                  "commonMistakes": "Buscar apenas no escopo global, ignorando declarações locais."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Consultar Atributos Armazenados para Validações Avançadas",
                                  "subSteps": [
                                    "Após encontrar identificador, consultar atributos como tipo, número de parâmetros.",
                                    "Validar atribuições: compatibilidade de tipos (ex: int = string → erro).",
                                    "Para funções: checar assinatura armazenada vs. chamada.",
                                    "Exemplo: 'int a = \"texto\";' – tipo incompatível detectado via atributo.",
                                    "Atualizar tabela com mais atributos (ex: endereço) pós-validação."
                                  ],
                                  "verification": "Analisar código com erro de tipo e explicar consulta de atributos na tabela.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Tabela de símbolos simulada em planilha",
                                    "Códigos com erros de tipo"
                                  ],
                                  "tips": "Atributos são a 'chave' para validações: armazene o máximo possível na declaração.",
                                  "learningObjective": "Usar atributos da tabela para validações semânticas complexas.",
                                  "commonMistakes": "Parar na busca de existência, ignorando validação de atributos."
                                }
                              ],
                              "practicalExample": "Código C: int main() { int x = 10; x = 'a'; // erro tipo int x; // erro redeclaração printf(x); // erro argumentos }. Passo a passo: 1) Declara int x (insere tipo int). 2) x='a' (busca x: tipo int != char → erro). 3) int x (busca x no escopo: existe → redeclaração). 4) printf(x) (busca x: existe mas args errados via atributo).",
                              "finalVerifications": [
                                "Explicar o fluxo de inserção e busca na tabela para declarações e usos.",
                                "Identificar e corrigir redeclaração em um snippet fornecido.",
                                "Detectar uso indefinido considerando escopos aninhados.",
                                "Validar tipos via atributos em uma atribuição simples.",
                                "Listar três atributos essenciais na tabela para semântica.",
                                "Simular tabela para um programa curto sem erros."
                              ],
                              "assessmentCriteria": [
                                "Precisão na descrição do papel da tabela em detecções semânticas.",
                                "Correta simulação de buscas e inserções com exemplos.",
                                "Compreensão de escopos e shadowing.",
                                "Identificação precisa de erros como redeclaração e indefinido.",
                                "Uso de terminologia técnica (ex: atributos, escopo léxico).",
                                "Capacidade de estender para validações de tipo e funções."
                              ],
                              "crossCurricularConnections": [
                                "Linguística Computacional: Semântica em parsers de linguagem natural.",
                                "Banco de Dados: Dicionários de dados para validação de schemas.",
                                "Engenharia de Software: Linters estáticos como ESLint.",
                                "Lógica Matemática: Verificação de consistência em sistemas formais."
                              ],
                              "realWorldApplication": "Em compiladores como GCC/Clang ou IDEs (VS Code com IntelliSense), a tabela de símbolos detecta erros semânticos em tempo real, acelerando depuração e prevenindo runtime errors em software como navegadores ou sistemas operacionais."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": [
                              "41.1.1.1.1"
                            ]
                          },
                          {
                            "id": "41.1.1.2.3",
                            "name": "Associar à geração de código",
                            "description": "Identificar como a tabela de símbolos fornece informações necessárias para a geração de código intermediário e objeto, como tipos e endereços de identificadores.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Conceitos Fundamentais de Tabela de Símbolos e Geração de Código",
                                  "subSteps": [
                                    "Estude a definição e propósito da tabela de símbolos em compiladores.",
                                    "Identifique as fases de compilação: análise léxica, sintática, semântica, otimização e geração de código.",
                                    "Diferencie código intermediário (ex: three-address code) de código objeto (ex: assembly ou binário).",
                                    "Liste exemplos de informações armazenadas na tabela de símbolos: nome, tipo, escopo, endereço de memória.",
                                    "Desenhe um fluxograma simples mostrando onde a tabela de símbolos é consultada durante a geração de código."
                                  ],
                                  "verification": "Crie um diagrama resumindo as fases de compilação e destaque o papel da tabela de símbolos na geração de código.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Livro-texto de compiladores (ex: Dragon Book), slides de aula sobre compiladores, papel e caneta para diagrama.",
                                  "tips": "Use analogias como 'agenda telefônica' para a tabela de símbolos para fixar o conceito.",
                                  "learningObjective": "Compreender o contexto geral onde a tabela de símbolos interage com a geração de código.",
                                  "commonMistakes": "Confundir tabela de símbolos com tabela de literais ou ignorar diferenças entre código intermediário e objeto."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar Informações Essenciais na Tabela de Símbolos para Geração de Código",
                                  "subSteps": [
                                    "Liste atributos chave: tipo de dado (int, float), endereço/base register, tamanho, escopo/offset.",
                                    "Explique como tipos determinam instruções (ex: ADD para int vs FADD para float).",
                                    "Descreva como endereços são usados para alocação de variáveis locais/globais.",
                                    "Discuta resolução de identificadores em expressões e atribuições.",
                                    "Crie uma tabela comparativa de atributos da symtab vs. necessidades em code gen."
                                  ],
                                  "verification": "Preencha uma tabela com pelo menos 5 atributos da symtab e seu uso específico em code gen.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Editor de texto ou planilha (Google Sheets), exemplos de entradas de symtab de aulas anteriores.",
                                  "tips": "Agrupe atributos por categoria (semântica vs. alocação) para melhor organização.",
                                  "learningObjective": "Mapear precisamente os dados da tabela de símbolos às demandas da geração de código.",
                                  "commonMistakes": "Esquecer atributos como escopo ou alinhamento de memória, que afetam endereçamento."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Simular o Uso da Tabela de Símbolos na Geração de Código Intermediário e Objeto",
                                  "subSteps": [
                                    "Para uma expressão simples (ex: a = b + c), simule lookup de tipos e endereços na symtab.",
                                    "Gere código intermediário usando os dados (ex: t1 = b + c; a = t1).",
                                    "Converta para código objeto/assembly, inserindo endereços reais (ex: MOV [EBP-4], EAX).",
                                    "Analise como symtab resolve ambiguidades (ex: overload de funções).",
                                    "Registre o processo em pseudocódigo passo a passo."
                                  ],
                                  "verification": "Escreva o código intermediário e objeto para uma expressão, citando lookups da symtab.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Simulador de compilador online (ex: onlinegdb), pseudocódigo de exemplo.",
                                  "tips": "Comece com código simples sem escopos aninhados para evitar complexidade inicial.",
                                  "learningObjective": "Aplicar dados da symtab para gerar código funcional em múltiplas fases.",
                                  "commonMistakes": "Gerar código sem verificar tipos, levando a instruções inválidas."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Validar e Refinar o Entendimento com Análise de Erros Comuns",
                                  "subSteps": [
                                    "Identifique cenários onde symtab falha (ex: identificador não declarado).",
                                    "Simule erros: tipo mismatch e como symtab previne via verificação.",
                                    "Compare geração de código com/ sem symtab completa.",
                                    "Otimize um exemplo usando infos de symtab (ex: alocação estática vs. dinâmica).",
                                    "Resuma lições aprendidas em bullet points."
                                  ],
                                  "verification": "Crie um relatório de 1 página com 3 cenários de erro e como symtab os resolve.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Document editor (Google Docs), exemplos de código com erros intencionais.",
                                  "tips": "Use debuggers mentais: 'O que acontece se o endereço estiver errado?'",
                                  "learningObjective": "Reconhecer dependências críticas da symtab para code gen robusta.",
                                  "commonMistakes": "Subestimar impacto de escopo em endereços relativos."
                                }
                              ],
                              "practicalExample": "Considere o código C: int main() { int a=1, b=2; int c = a + b; return c; }. Na symtab: a(tipo:int, end: EBP-4), b(int, EBP-8). Geração intermediária: t1 = a + b; c = t1. Objeto: MOV EAX, [EBP-4]; ADD EAX, [EBP-8]; MOV [EBP-12], EAX. Symtab fornece tipos para ADD e endereços para acessos.",
                              "finalVerifications": [
                                "Liste 5 atributos da symtab usados em code gen com exemplos.",
                                "Gere código intermediário correto para uma expressão usando symtab simulada.",
                                "Explique diferença no assembly com/sem endereços da symtab.",
                                "Identifique 3 erros potenciais sem symtab e como evitá-los.",
                                "Desenhe fluxograma de lookup symtab → code gen.",
                                "Compare code gen para variáveis locais vs. globais."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de atributos symtab (90% cobertura).",
                                "Corretude do código gerado (sem erros de tipo/endereço).",
                                "Profundidade dos substeps (mínimo 4 por step com detalhes acionáveis).",
                                "Clareza nas verificações e exemplos práticos.",
                                "Integração de conexões com fases de compilação.",
                                "Originalidade no practicalExample e realWorldApplication."
                              ],
                              "crossCurricularConnections": [
                                "Arquitetura de Computadores: Endereçamento de memória e registradores.",
                                "Programação: Gerenciamento de escopo e resolução de símbolos em linguagens.",
                                "Engenharia de Software: Otimizadores de compiladores e linkers.",
                                "Bancos de Dados: Estruturas de tabelas e consultas (análogas a lookups)."
                              ],
                              "realWorldApplication": "Em compiladores como GCC ou LLVM, a symtab (ou IR metadata) fornece tipos/endereços para gerar assembly otimizado, essencial em desenvolvimento de software, firmware embarcado e ferramentas de análise estática como linters."
                            },
                            "estimatedTime": "0.25 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": [
                              "41.1.1.1.2"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "41.1.1.3",
                        "name": "Informações Armazenadas na Tabela",
                        "description": "Conhecer os tipos de dados tipicamente armazenados na tabela de símbolos para cada identificador, suportando as diversas fases da compilação.",
                        "specificSkills": [
                          {
                            "id": "41.1.1.3.1",
                            "name": "Listar atributos comuns",
                            "description": "Enumerar e descrever atributos básicos armazenados, como nome do identificador, tipo de dado, escopo, posição na memória e número de linha de declaração.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender o Conceito Básico de Tabela de Símbolos",
                                  "subSteps": [
                                    "Revise a definição de tabela de símbolos como uma estrutura de dados que armazena informações sobre identificadores no código fonte.",
                                    "Identifique o propósito principal: auxiliar o compilador na análise semântica, resolução de escopos e geração de código.",
                                    "Liste os tipos de identificadores comuns: variáveis, funções, classes e constantes.",
                                    "Discuta por que atributos são necessários: para verificação de tipos, alocação de memória e depuração.",
                                    "Anote exemplos iniciais de atributos que você já conhece, como nome e tipo."
                                  ],
                                  "verification": "Escreva um parágrafo resumindo o papel da tabela de símbolos e liste pelo menos 3 identificadores de um código simples.",
                                  "estimatedTime": "15-20 minutos",
                                  "materials": [
                                    "Documentação sobre compiladores (ex: Dragon Book capítulo sobre análise semântica)",
                                    "Exemplo de código fonte em C ou Java"
                                  ],
                                  "tips": [
                                    "Use diagramas para visualizar a tabela como um mapa de identificadores.",
                                    "Foquem em linguagens imperativas como C para simplicidade inicial."
                                  ],
                                  "learningObjective": "Compreender o contexto e propósito da tabela de símbolos antes de listar atributos.",
                                  "commonMistakes": [
                                    "Confundir tabela de símbolos com tabela de literais.",
                                    "Ignorar o papel na fase semântica do compilador."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar e Enumerar Atributos Comuns",
                                  "subSteps": [
                                    "Liste os atributos básicos: nome do identificador, tipo de dado, escopo (local/global), posição na memória (offset ou endereço), número de linha de declaração.",
                                    "Descreva cada um: nome (string única), tipo (int, float, etc.), escopo (bloco/função/módulo), posição (endereço alocado), linha (para erros).",
                                    "Pesquise atributos adicionais opcionais: visibilidade, tamanho, valor inicial.",
                                    "Crie uma tabela em papel ou planilha com colunas para cada atributo.",
                                    "Classifique atributos por obrigatoriedade: essenciais vs. opcionais."
                                  ],
                                  "verification": "Crie uma lista numerada com 5 atributos comuns, incluindo uma breve descrição para cada.",
                                  "estimatedTime": "20-25 minutos",
                                  "materials": [
                                    "Planilha Google Sheets ou papel e caneta",
                                    "Referências: especificações de linguagens como C99 ou Java SE"
                                  ],
                                  "tips": [
                                    "Agrupe atributos por categoria: identificação, tipo, localização e metadados.",
                                    "Use abreviações padronizadas como 'scope: global'."
                                  ],
                                  "learningObjective": "Enumerar e descrever precisamente os atributos básicos armazenados na tabela.",
                                  "commonMistakes": [
                                    "Omitir escopo, levando a erros de shadowing.",
                                    "Confundir posição na memória com valor da variável."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar Atributos em um Exemplo de Código",
                                  "subSteps": [
                                    "Selecione um código fonte simples com múltiplas variáveis em escopos diferentes.",
                                    "Passe pelo código linha por linha, identificando declarações de identificadores.",
                                    "Preencha a tabela de símbolos para cada identificador com todos os atributos.",
                                    "Verifique conflitos potenciais, como redeclarações no mesmo escopo.",
                                    "Compare sua tabela com uma solução modelo."
                                  ],
                                  "verification": "Construa uma tabela de símbolos completa para o código exemplo e destaque pelo menos 2 atributos por identificador.",
                                  "estimatedTime": "25-30 minutos",
                                  "materials": [
                                    "Código exemplo fornecido abaixo",
                                    "Ferramenta de desenho como Draw.io para tabelas"
                                  ],
                                  "tips": [
                                    "Comece pelas declarações globais e avance para locais.",
                                    "Anote o número da linha exato da primeira declaração."
                                  ],
                                  "learningObjective": "Aplicar o conhecimento de atributos a um código real, preenchendo uma tabela de símbolos.",
                                  "commonMistakes": [
                                    "Esquecer escopo em blocos aninhados.",
                                    "Atribuir posição na memória antes da alocação semântica."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Praticar e Verificar a Lista de Atributos",
                                  "subSteps": [
                                    "Crie seu próprio código curto com 5-7 identificadores variados.",
                                    "Gere a tabela de símbolos listando todos os atributos comuns.",
                                    "Autoavalie usando critérios: completude, precisão e consistência.",
                                    "Discuta variações por linguagem (ex: C vs. Python).",
                                    "Refatore a lista para incluir pelo menos um atributo extra relevante."
                                  ],
                                  "verification": "Compartilhe ou revise sua tabela personalizada, confirmando que todos os 5 atributos principais estão presentes e corretos.",
                                  "estimatedTime": "20-25 minutos",
                                  "materials": [
                                    "Editor de texto (VS Code)",
                                    "Compilador online como Replit para validação"
                                  ],
                                  "tips": [
                                    "Teste o código para validar alocações de memória reais.",
                                    "Use comentários no código para mapear à tabela."
                                  ],
                                  "learningObjective": "Consolidar a habilidade de listar atributos de forma independente e precisa.",
                                  "commonMistakes": [
                                    "Listar atributos irrelevantes como valores runtime.",
                                    "Ignorar diferenças entre declaração e definição."
                                  ]
                                }
                              ],
                              "practicalExample": "Considere o código C: int globalVar = 10; void func() { int localVar; float pi = 3.14; } Tabela de símbolos: globalVar (nome: 'globalVar', tipo: int, escopo: global, posição: 0x1000, linha:1); localVar (nome: 'localVar', tipo: int, escopo: func, posição: 0x2000, linha:3); pi (nome: 'pi', tipo: float, escopo: func, posição: 0x2004, linha:4).",
                              "finalVerifications": [
                                "Pode listar pelo menos 5 atributos comuns sem consultar notas.",
                                "Descreve corretamente o papel de escopo e posição na memória.",
                                "Preenche uma tabela de símbolos para um código de 10 linhas com precisão.",
                                "Identifica erros comuns em tabelas incompletas.",
                                "Explica diferenças entre atributos em linguagens estáticas vs. dinâmicas.",
                                "Cria uma tabela para código com escopos aninhados."
                              ],
                              "assessmentCriteria": [
                                "Completude: Todos os atributos essenciais incluídos (nome, tipo, escopo, posição, linha).",
                                "Precisão: Descrições factuais e sem erros conceituais.",
                                "Detalhamento: Cada atributo descrito com exemplos ou justificativas.",
                                "Consistência: Formato uniforme na lista ou tabela.",
                                "Aplicação: Capacidade de extrair atributos de código real.",
                                "Criatividade: Inclusão de atributos opcionais relevantes."
                              ],
                              "crossCurricularConnections": [
                                "Estruturas de Dados: Tabelas de hash ou árvores para implementação da tabela de símbolos.",
                                "Banco de Dados: Atributos como schema de tabelas relacionais.",
                                "Lógica e Matemática: Escopo como conjuntos e subconjuntos.",
                                "Engenharia de Software: Uso em IDEs para autocompletar e refatoração."
                              ],
                              "realWorldApplication": "Em compiladores como GCC ou Clang, a tabela de símbolos permite detecção de erros como 'variável não declarada' e otimização de código; em IDEs como Visual Studio, suporta IntelliSense e depuração, listando atributos para navegação rápida no código."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": [
                              "41.1.1.2.1"
                            ]
                          },
                          {
                            "id": "41.1.1.3.2",
                            "name": "Exemplificar entrada de tabela",
                            "description": "Criar um exemplo simples de entrada na tabela de símbolos para um identificador como 'int x;', listando os campos preenchidos e seu propósito na compilação.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Campos Comuns em uma Tabela de Símbolos para Identificadores",
                                  "subSteps": [
                                    "Liste os campos típicos: nome, tipo, escopo, endereço memória, visibilidade.",
                                    "Explique brevemente cada campo: nome é o identificador; tipo é 'int'; escopo é o bloco atual.",
                                    "Pesquise ou recorde exemplos de tabelas de símbolos em compiladores como GCC ou LLVM.",
                                    "Anote em um papel ou editor os 5-7 campos essenciais para variáveis simples.",
                                    "Compare com documentação de compiladores para confirmar relevância."
                                  ],
                                  "verification": "Verifique se você pode recitar e definir pelo menos 5 campos sem consultar notas.",
                                  "estimatedTime": "10 minutos",
                                  "materials": "Papel e caneta ou editor de texto simples; acesso a documentação de compiladores online.",
                                  "tips": "Comece com campos básicos (nome, tipo) antes de avançar para escopo e offsets.",
                                  "learningObjective": "Identificar e definir os campos padrão armazenados para um identificador de variável.",
                                  "commonMistakes": "Confundir campos de tabela de símbolos com estruturas de dados de linguagens de alto nível como structs."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar a Declaração 'int x;'",
                                  "subSteps": [
                                    "Identifique o tipo: 'int' indica tipo inteiro.",
                                    "Note o nome do identificador: 'x'.",
                                    "Determine o escopo: assuma escopo global ou função atual para simplicidade.",
                                    "Considere atributos implícitos: visibilidade pública, sem inicializador.",
                                    "Registre possíveis valores iniciais como endereço simbólico ou offset de pilha."
                                  ],
                                  "verification": "Escreva um resumo da declaração destacando tipo, nome e contexto assumido.",
                                  "estimatedTime": "8 minutos",
                                  "materials": "Editor de código ou bloco de notas para anotar a análise.",
                                  "tips": "Use sintaxe da linguagem C para contextualizar, pois 'int x;' é declaração C.",
                                  "learningObjective": "Extrair informações chave da declaração fonte para mapear à tabela de símbolos.",
                                  "commonMistakes": "Ignorar escopo, assumindo sempre global sem contexto."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Preencher a Entrada da Tabela de Símbolos",
                                  "subSteps": [
                                    "Crie uma tabela com colunas: Nome, Tipo, Escopo, Endereço/Offset, Visibilidade, Linha Declarada.",
                                    "Preencha: Nome='x', Tipo='int', Escopo='global', Offset='0', Visibilidade='public', Linha='1'.",
                                    "Adicione campos extras se relevante: Tamanho=4 bytes (para int 32-bit).",
                                    "Formate como tabela markdown ou ASCII para clareza.",
                                    "Valide preenchimento cruzando com análise do Step 2."
                                  ],
                                  "verification": "Desenhe ou imprima a tabela preenchida e confirme todos os campos.",
                                  "estimatedTime": "12 minutos",
                                  "materials": "Editor de texto ou ferramenta de tabela como Excel/Google Sheets.",
                                  "tips": "Mantenha simples; foque em 6 campos para evitar sobrecarga.",
                                  "learningObjective": "Construir uma entrada de tabela de símbolos completa e formatada para o exemplo dado.",
                                  "commonMistakes": "Esquecer linha de declaração ou confundir offset com valor inicial."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Explicar o Propósito de Cada Campo na Compilação",
                                  "subSteps": [
                                    "Para Nome: Usado em resolução de identificadores durante análise semântica.",
                                    "Para Tipo: Verificação de tipos e geração de código (ex: tamanho para alocação).",
                                    "Para Escopo: Detecção de shadowing e resolução de nomes.",
                                    "Para Endereço/Offset: Geração de código assembly para acessos.",
                                    "Para Visibilidade: Otimizações e linking.",
                                    "Escreva uma frase curta para cada campo ligando à fase de compilação."
                                  ],
                                  "verification": "Crie um mapa mental ou lista numerada explicando propósitos e teste recitação.",
                                  "estimatedTime": "10 minutos",
                                  "materials": "Papel para diagrama ou ferramenta de mindmap online.",
                                  "tips": "Ligue cada campo a uma fase: léxica (nome), semântica (tipo/escopo), código (endereço).",
                                  "learningObjective": "Articular como cada campo suporta fases específicas da compilação.",
                                  "commonMistakes": "Generalizar propósitos sem ligar a fases concretas como semântica ou otimização."
                                }
                              ],
                              "practicalExample": "Para 'int x;' na linha 5 de um arquivo main.c (escopo global):\n| Nome | Tipo | Escopo | Offset | Visibilidade | Linha |\n|------|------|--------|--------|--------------|-------|\n| x    | int  | global | 0      | public       | 5     |\nPropósitos: Nome para lookup; Tipo para checagem; Offset para acesso memória em assembly.",
                              "finalVerifications": [
                                "Pode recriar a tabela de 'int x;' com 6+ campos corretos?",
                                "Explica propósito de pelo menos 4 campos na compilação?",
                                "Identifica erros em uma tabela de exemplo incompleta?",
                                "Aplica o conceito a uma declaração similar como 'float y;'?",
                                "Desenha fluxograma de inserção na tabela durante parsing?",
                                "Lista limitações para tipos compostos (ex: structs)?"
                              ],
                              "assessmentCriteria": [
                                "Precisão: Todos os campos preenchidos corretamente (30%)",
                                "Completude: Pelo menos 5 campos + propósitos explicados (25%)",
                                "Clareza: Tabela formatada e explicações concisas (20%)",
                                "Relevância: Ligações diretas a fases de compilação (15%)",
                                "Originalidade: Exemplo personalizado sem cópia (10%)"
                              ],
                              "crossCurricularConnections": [
                                "Banco de Dados: Similar a registros em tabelas relacionais com chaves primárias (nome).",
                                "Estruturas de Dados: Hash tables para lookup eficiente de símbolos.",
                                "Linguagens de Programação: Ambientes de execução como Python's globals() locals().",
                                "Engenharia de Software: Gerenciamento de dependências em build systems."
                              ],
                              "realWorldApplication": "Em compiladores como GCC ou Clang, tabelas de símbolos detectam erros de redeclaração (ex: 'int x;' duplicado), otimizam código alocando offsets precisos na stack/heap, e suportam debugging via símbolos em executáveis (gdb usa para print x)."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": [
                              "41.1.1.1.1",
                              "41.1.1.2.1"
                            ]
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.3.2",
                    "name": "Estruturas de Dados para Tabelas de Símbolos",
                    "description": "Uso de listas lineares, árvores e tabelas hash para implementação eficiente.",
                    "individualConcepts": [
                      {
                        "id": "10.1.3.2.1",
                        "name": "Listas Lineares para Tabelas de Símbolos",
                        "description": "Estrutura de dados sequencial utilizando listas encadeadas ou arrays para armazenar entradas de símbolos, com operações de inserção, busca e remoção baseadas em varredura linear, adequada para escopos pequenos em compiladores.",
                        "specificSkills": [
                          {
                            "id": "10.1.3.2.1.1",
                            "name": "Identificar vantagens e desvantagens de listas lineares",
                            "description": "Analisar o tempo de busca O(n), simplicidade de implementação e overhead de memória baixo em comparação com outras estruturas, no contexto de tabelas de símbolos para análise léxica e sintática.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar conceitos básicos de listas lineares em tabelas de símbolos",
                                  "subSteps": [
                                    "Defina o que é uma lista linear (lista ligada) e seus componentes: nós com dado e ponteiro para próximo.",
                                    "Explique o uso em tabelas de símbolos para análise léxica e sintática, armazenando identificadores.",
                                    "Desenhe um diagrama simples de uma lista ligada com 3-4 nós representando símbolos.",
                                    "Discuta operações básicas: inserção no início/fim e remoção."
                                  ],
                                  "verification": "Desenhe e rotule corretamente um diagrama de lista ligada com símbolos de exemplo.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Papel e caneta ou ferramenta de desenho como Draw.io; pseudocódigo ou editor de texto.",
                                  "tips": "Comece pelo nó cabeça para simplificar inserções.",
                                  "learningObjective": "Compreender a estrutura fundamental de listas lineares aplicada a tabelas de símbolos.",
                                  "commonMistakes": "Confundir lista ligada com array; esquecer ponteiro nulo no final."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar e analisar vantagens das listas lineares",
                                  "subSteps": [
                                    "Liste vantagens: simplicidade de implementação (poucas linhas de código).",
                                    "Analise overhead de memória baixo: apenas ponteiro extra por nó (~8 bytes).",
                                    "Discuta inserção dinâmica eficiente O(1) no início, ideal para fluxos de análise sequencial.",
                                    "Relacione com compiladores: bom para tabelas pequenas ou scopes locais em análise léxica.",
                                    "Calcule exemplo: memória para N símbolos vs. array redimensionável."
                                  ],
                                  "verification": "Escreva uma tabela com 3 vantagens, justificadas com complexidade temporal/espacial.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Planilha ou tabela em Markdown; calculadora para comparações de memória.",
                                  "tips": "Use notação Big O para quantificar: O(1) inserção vs. O(n) em arrays fixos.",
                                  "learningObjective": "Reconhecer cenários onde listas lineares superam outras estruturas em simplicidade e custo.",
                                  "commonMistakes": "Ignorar overhead em 64-bit systems; superestimar simplicidade sem código exemplo."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Identificar e analisar desvantagens das listas lineares",
                                  "subSteps": [
                                    "Destaque desvantagem principal: busca sequencial O(n), ruim para consultas frequentes.",
                                    "Discuta falta de acesso aleatório: impossível indexar diretamente.",
                                    "Analise cache unfriendly: saltos de ponteiros causam misses em cache.",
                                    "Compare com sintática: em parsing, buscas repetidas por símbolos podem degradar performance.",
                                    "Exemplo numérico: tempo médio de busca para N=1000."
                                  ],
                                  "verification": "Liste 3 desvantagens com impacto quantitativo (ex: O(n) vs O(1) em hash).",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Gráfico de complexidade (ferramentas como Desmos ou papel); exemplos de código.",
                                  "tips": "Meça com timer em código simples para validar O(n).",
                                  "learningObjective": "Avaliar limitações de listas lineares em operações de busca intensivas.",
                                  "commonMistakes": "Subestimar impacto de cache; confundir com listas duplamente ligadas."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Comparar com outras estruturas e contextualizar em compiladores",
                                  "subSteps": [
                                    "Compare com array: array tem busca O(n) mas acesso O(1), overhead redimensionamento.",
                                    "Vs. hash table: O(1) médio busca, mas colisões e mais memória.",
                                    "Vs. árvore binária: O(log n) busca, balanceamento complexo.",
                                    "No contexto: listas para scopes lineares em léxica; hash/árvores para semântica global.",
                                    "Decida trade-off: use lista quando N pequeno e inserções > buscas."
                                  ],
                                  "verification": "Crie matriz de comparação (linhas: estruturas; colunas: tempo inserção/busca/memória).",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Tabela comparativa em Excel ou LaTeX; artigos sobre compiladores (ex: Dragon Book).",
                                  "tips": "Priorize métricas do contexto: análise léxica é sequencial, favorece listas.",
                                  "learningObjective": "Aplicar análise de trade-offs para escolha de estrutura em compiladores.",
                                  "commonMistakes": "Generalizar sem contexto; ignorar custo de implementação de alternativas."
                                }
                              ],
                              "practicalExample": "Implemente uma tabela de símbolos com lista ligada em Python para análise léxica de um código fonte simples (ex: variáveis 'x', 'y', 'z'). Insira 100 símbolos sequencialmente, busque 'z' 10x e meça tempo total vs. array lista. Observe O(n) na busca degradando performance.",
                              "finalVerifications": [
                                "Pode listar 4 vantagens e 4 desvantagens com justificativas precisas.",
                                "Calcula corretamente complexidades: inserção O(1), busca O(n).",
                                "Compara memória: lista ~ (tamanho_dado + 8 bytes) * N vs. array.",
                                "Identifica uso ideal: scopes locais em parsing.",
                                "Desenha diagrama correto de lista com símbolos.",
                                "Explica trade-off em compilador: lista para léxica simples."
                              ],
                              "assessmentCriteria": [
                                "Precisão na notação Big O e análises quantitativas (40%)",
                                "Profundidade de comparação com alternativas (25%)",
                                "Relevância ao contexto de compiladores (20%)",
                                "Clareza em diagramas e exemplos práticos (10%)",
                                "Identificação de erros comuns e tips (5%)"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Análise assintótica e notação Big O",
                                "Engenharia de Software: Trade-offs em design de dados",
                                "Análise de Algoritmos: Medição empírica de performance",
                                "Lógica e Estruturas Discretas: Grafos e encadeamento"
                              ],
                              "realWorldApplication": "Em compiladores como GCC ou LLVM, listas lineares gerenciam símbolos em scopes aninhados durante análise semântica, priorizando inserções rápidas em parsing descendente recursivo, onde buscas são raras e N é pequeno."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.2.1.2",
                            "name": "Implementar inserção e remoção em lista linear",
                            "description": "Desenvolver código para adicionar um símbolo (nome, tipo, escopo) no final ou em posição específica e remover por nome, gerenciando ponteiros em listas encadeadas para tabelas de símbolos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Definir a estrutura de dados para o nó da lista linear",
                                  "subSteps": [
                                    "Crie uma struct para o nó contendo campos: nome (char*), tipo (char*), escopo (int), e ponteiro next (struct Node*)",
                                    "Defina um typedef para a struct Node para facilitar o uso",
                                    "Crie um ponteiro head para representar o início da lista (inicialmente NULL)",
                                    "Inclua headers necessários como <stdio.h>, <stdlib.h> e <string.h> para manipulação de strings e memória"
                                  ],
                                  "verification": "Compile o código sem erros e imprima a estrutura vazia (head == NULL)",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Editor de código (VS Code ou similar), compilador C (GCC)",
                                  "tips": "Use typedef para legibilidade; sempre inicialize ponteiros como NULL",
                                  "learningObjective": "Compreender e implementar a representação básica de uma lista encadeada simples",
                                  "commonMistakes": "Esquecer de incluir headers para malloc/free; não inicializar next como NULL"
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar inserção no final da lista",
                                  "subSteps": [
                                    "Crie uma função insertEnd(Node** head, char* name, char* type, int scope) que aloque novo nó com malloc",
                                    "Copie nome, tipo e escopo para o novo nó usando strcpy",
                                    "Se lista vazia (head == NULL), defina *head = novo nó",
                                    "Caso contrário, percorra a lista até o último nó e defina seu next para o novo nó",
                                    "Defina next do novo nó como NULL e retorne"
                                  ],
                                  "verification": "Insira 3 símbolos e imprima a lista percorrendo de head; verifique ordem e ponteiros",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Compilador C, debugger (GDB)",
                                  "tips": "Passe head por referência (**head) para modificar o ponteiro raiz",
                                  "learningObjective": "Dominar alocação dinâmica e travessia de lista para inserção terminal",
                                  "commonMistakes": "Não passar head por referência; vazamento de memória sem free em testes; overflow em strcpy sem checagem"
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar inserção em posição específica",
                                  "subSteps": [
                                    "Crie função insertAtPosition(Node** head, char* name, char* type, int scope, int position) (posição 0 = início)",
                                    "Alocar novo nó como antes",
                                    "Se posição 0, defina novo->next = *head e *head = novo",
                                    "Caso contrário, percorra até position-1, insira novo entre current e current->next",
                                    "Atualize ponteiros e retorne; trate posição > tamanho como append"
                                  ],
                                  "verification": "Insira em posições 0, meio e fim; imprima lista e confirme ordem correta",
                                  "estimatedTime": "40 minutos",
                                  "materials": "Compilador C, ferramenta de debug visual (Valgrind para leaks)",
                                  "tips": "Use um contador no loop de travessia; valide posição >=0",
                                  "learningObjective": "Gerenciar inserções arbitrárias preservando integridade da lista",
                                  "commonMistakes": "Não atualizar ponteiro anterior corretamente; loop infinito se position inválida sem checagem"
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Implementar remoção por nome",
                                  "subSteps": [
                                    "Crie função removeByName(Node** head, char* name)",
                                    "Caso lista vazia, retorne",
                                    "Se head->name == name, temp = *head, *head = (*head)->next, free(temp)",
                                    "Caso contrário, percorra buscando nome, free nó encontrado e atualize ponteiro anterior->next",
                                    "Use strcmp para comparar nomes; imprima confirmação de remoção"
                                  ],
                                  "verification": "Insira símbolos, remova um pelo nome, imprima lista e confirme ausência",
                                  "estimatedTime": "35 minutos",
                                  "materials": "Compilador C, Valgrind para detectar memory leaks",
                                  "tips": "Sempre free o nó removido para evitar leaks; preserve ponteiro anterior na travessia",
                                  "learningObjective": "Executar remoção segura com gerenciamento de ponteiros e desalocação",
                                  "commonMistakes": "Não free o nó (leak); perder ponteiros ao remover head; strcmp sem NULL check"
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Testar e depurar operações completas",
                                  "subSteps": [
                                    "Crie função printList(Node* head) para exibir todos símbolos",
                                    "No main, teste sequências: inserir múltiplos, inserir no meio, remover, inserir novamente",
                                    "Use asserts ou ifs para checar tamanhos e conteúdos pós-operações",
                                    "Execute com Valgrind para leaks e execute casos edge: lista vazia, um item, duplicados",
                                    "Adicione função size(Node* head) para verificação de contagem"
                                  ],
                                  "verification": "Todos testes passam sem crashes, leaks ou erros lógicos; lista mantém integridade",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Valgrind, GDB",
                                  "tips": "Teste casos edge primeiro; use printf para debug temporário",
                                  "learningObjective": "Validar implementação completa com testes robustos",
                                  "commonMistakes": "Ignorar casos vazios; não testar duplicatas; forgets frees em testes"
                                }
                              ],
                              "practicalExample": "Em um compilador simples, crie tabela de símbolos: insertEnd(head, \"x\", \"int\", 1); insertAtPosition(head, \"y\", \"float\", 1, 1); removeByName(head, \"x\"); printList(head) deve mostrar apenas 'y float scope 1'.",
                              "finalVerifications": [
                                "Lista permanece ligada corretamente após múltiplas inserções/remoções (sem ponteiros quebrados)",
                                "Nenhum vazamento de memória detectado por Valgrind",
                                "Remoção por nome funciona para head, meio e fim",
                                "Inserção em posição inválida (fim) appenda corretamente",
                                "Impressão mostra nomes, tipos e escopos exatos",
                                "Função size reflete contagem precisa pós-operações"
                              ],
                              "assessmentCriteria": [
                                "Código compila e executa sem erros ou warnings",
                                "Gerenciamento correto de ponteiros (sem dangling ou NULL deref)",
                                "Eficiência O(n) para operações, sem loops desnecessários",
                                "Tratamento completo de casos edge (vazia, única, duplicatas)",
                                "Uso apropriado de malloc/free sem leaks",
                                "Código legível com comentários e nomes descritivos"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Estruturas discretas e teoria de grafos (listas como caminhos)",
                                "Algoritmos: Complexidade temporal de travessia linear O(n)",
                                "Engenharia de Software: Gerenciamento de memória e testes unitários",
                                "Lógica: Condicionais para casos especiais em programação imperativa"
                              ],
                              "realWorldApplication": "Em compiladores como GCC ou LLVM, tabelas de símbolos usam listas encadeadas para scopes aninhados, permitindo inserção/remoção eficiente de variáveis durante parsing e análise semântica, evitando realocações custosas em arrays."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.2.1.3",
                            "name": "Realizar busca sequencial eficiente",
                            "description": "Implementar função de busca que percorre a lista linear comparando nomes de símbolos, retornando atributos como tipo e escopo, otimizando para casos comuns em compiladores.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Definir a Estrutura de Dados para Lista Linear de Símbolos",
                                  "subSteps": [
                                    "Crie uma estrutura SymbolEntry com campos: name (string), type (string), scope (int), next (ponteiro para SymbolEntry).",
                                    "Implemente um construtor para inicializar os campos, definindo next como null.",
                                    "Crie uma variável head como ponteiro para SymbolEntry para representar o início da lista.",
                                    "Desenvolva função insertFront(head, name, type, scope) para inserir novo símbolo no início da lista (O(1) tempo).",
                                    "Teste inserção criando uma lista com 3 símbolos e imprimindo em ordem."
                                  ],
                                  "verification": "Lista é impressa corretamente com símbolos na ordem de inserção reversa, sem erros de segmentação.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Editor de código (VS Code ou similar)",
                                    "Compilador C/Python",
                                    "Documentação de ponteiros/listas ligadas"
                                  ],
                                  "tips": [
                                    "Sempre verifique se head é null antes de inserir.",
                                    "Use printf/debug para visualizar a lista após cada inserção."
                                  ],
                                  "learningObjective": "Modelar tabela de símbolos como lista singly-linked otimizada para inserções recentes.",
                                  "commonMistakes": [
                                    "Não inicializar next como null, causando loops infinitos.",
                                    "Esquecer de atualizar head na inserção no início.",
                                    "Comparações de string sem considerar case ou trim."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar Busca Sequencial Básica",
                                  "subSteps": [
                                    "Defina função SymbolEntry* sequentialSearch(head, targetName) que retorna ponteiro para entry ou null.",
                                    "Inicialize current = head em um loop while (current != null).",
                                    "Dentro do loop, compare current->name == targetName; se sim, retorne current.",
                                    "Avance current = current->next; se loop termina, retorne null.",
                                    "Adicione retorno de atributos (type, scope) via ponteiro ou struct copiada."
                                  ],
                                  "verification": "Execute testes: busque símbolo no início, meio e fim da lista; confirme retorno correto ou null.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Código do Step 1",
                                    "Função de teste unitário (ex: assert ou prints)"
                                  ],
                                  "tips": [
                                    "Use strcmp em C para comparação segura de strings.",
                                    "Imprima caminho da busca para depuração visual."
                                  ],
                                  "learningObjective": "Implementar iteração linear para lookup exato de nomes de símbolos.",
                                  "commonMistakes": [
                                    "Loop infinito por não avançar current corretamente.",
                                    "Retornar null prematuramente em comparações falhas.",
                                    "Não copiar atributos antes de retornar ponteiro."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Otimizar Busca para Casos Comuns em Compiladores",
                                  "subSteps": [
                                    "Explique otimização: inserir símbolos de escopo atual no head para hits rápidos em locals recentes.",
                                    "Implemente cache simples: variável lastFound para armazenar último lookup bem-sucedido e checar primeiro.",
                                    "Adicione medida de performance: conte comparações em 100 buscas aleatórias em lista de 100 itens.",
                                    "Simule escopos: insira símbolos globais primeiro, locals depois, busque locals (deve ser O(1)).",
                                    "Ajuste função para priorizar escopo atual via flag ou lista por escopo."
                                  ],
                                  "verification": "Média de comparações < 5 para acessos recentes em lista de 50 itens; confirme com logs.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Código dos Steps 1-2",
                                    "Timer ou contador de iterações",
                                    "Gerador de listas grandes"
                                  ],
                                  "tips": [
                                    "Cache MRU (Most Recently Used) simula bem uso real em compiladores.",
                                    "Evite cache se lista muito dinâmica para não degradar worst-case."
                                  ],
                                  "learningObjective": "Aplicar heurísticas práticas para reduzir complexidade média de O(n) para casos comuns.",
                                  "commonMistakes": [
                                    "Cache inválido após inserções, causando misses falsos.",
                                    "Não resetar contador de performance entre testes.",
                                    "Otimizações que pioram worst-case sem justificativa."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Testar, Integrar e Verificar a Função Completa",
                                  "subSteps": [
                                    "Crie suite de testes: 10 casos (hits head/meio/fim, miss, escopos múltiplos, lista vazia).",
                                    "Simule compilador: parse 'int x=1; { int y=2; use x; use y; }' inserindo/busca sucessiva.",
                                    "Verifique atributos: confirme type='int', scope correto no retorno.",
                                    "Profile memória: use valgrind para vazamentos; performance em 1000 buscas.",
                                    "Documente função com comentários sobre O(n) worst, O(1) avg com otimizações."
                                  ],
                                  "verification": "100% pass em testes; performance aceitável (<1ms para listas <100); sem leaks.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Framework de testes (Unity para C ou pytest)",
                                    "Valgrind/Memory profiler"
                                  ],
                                  "tips": [
                                    "Teste edge cases primeiro: lista vazia, todos misses.",
                                    "Integre em parser toy para contexto real."
                                  ],
                                  "learningObjective": "Garantir robustez e eficiência da busca em cenários de compilador.",
                                  "commonMistakes": [
                                    "Ignorar vazamentos em loops de teste.",
                                    "Testes só para hits, esquecendo misses.",
                                    "Não validar escopo em buscas aninhadas."
                                  ]
                                }
                              ],
                              "practicalExample": "Em um mini-compilador para linguagem simples: declare 'global int x;' (escopo 0), entre escopo 1 com 'local string x;', busque 'x' deve retornar tipo='string', escopo=1 (local shadows global), otimizado pois local no head.",
                              "finalVerifications": [
                                "Busca retorna entry correto com name, type e scope exatos.",
                                "Lida graciosamente com não-encontrado (null/false).",
                                "Otimizações reduzem comparações médias em >50% para acessos recentes.",
                                "Sem vazamentos ou crashes em listas de até 1000 itens.",
                                "Atributos preservados no retorno (não corrompidos).",
                                "Funciona em múltiplos escopos com shadowing correto."
                              ],
                              "assessmentCriteria": [
                                "Código modular, legível com comentários explicando otimizações.",
                                "Correção total em suite de testes abrangente.",
                                "Eficiência demonstrada empiricamente (logs de performance).",
                                "Estrutura de dados apropriada para compiladores (inserção front).",
                                "Explicação clara de trade-offs O(n) vs. hash tables.",
                                "Integração em exemplo prático de parsing."
                              ],
                              "crossCurricularConnections": [
                                "Algoritmos: Análise de complexidade temporal O(n) e otimizações heurísticas.",
                                "Matemática: Probabilidade de hits em posições iniciais, Big-O notation.",
                                "Engenharia de Software: Design de estruturas de dados escaláveis.",
                                "Lógica e Programação: Controle de fluxo em recursão/iteração."
                              ],
                              "realWorldApplication": "Em compiladores como GCC/Clang, tabelas de símbolos usam listas ou árvores para lookup sequencial durante análise semântica, otimizadas para escopos locais frequentes, evitando overhead de hashes para tabelas pequenas."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.3.2.2",
                        "name": "Árvores para Tabelas de Símbolos",
                        "description": "Uso de árvores binárias de busca (BST) ou balanceadas (AVL) para armazenar símbolos ordenados por nome, permitindo buscas, inserções e remoções em tempo O(log n), ideal para tabelas com muitos símbolos em compiladores.",
                        "specificSkills": [
                          {
                            "id": "10.1.3.2.2.1",
                            "name": "Construir árvore binária de busca para símbolos",
                            "description": "Implementar nó com campos para nome do símbolo, atributos (tipo, escopo) e ponteiros esquerdo/direito, inserindo símbolos mantendo a propriedade de ordenação lexicográfica.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Definir a estrutura do nó da árvore binária de busca",
                                  "subSteps": [
                                    "Analise os campos necessários: nome do símbolo (string), atributos como tipo (string) e escopo (int), ponteiros esquerdo e direito (ponteiros para o próprio tipo de nó).",
                                    "Crie uma struct em C/C++ ou classe equivalente com esses campos.",
                                    "Inicialize os ponteiros esquerdo e direito como NULL na declaração.",
                                    "Inclua bibliotecas necessárias como <stdio.h>, <stdlib.h> e <string.h> para strcmp.",
                                    "Compile e teste a definição isoladamente para verificar erros de sintaxe."
                                  ],
                                  "verification": "O código compila sem erros e a struct é reconhecida pelo compilador.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Editor de código (VS Code ou similar)",
                                    "Compilador GCC/Clang",
                                    "Documentação de C para structs"
                                  ],
                                  "tips": "Use typedef para simplificar o nome do tipo de nó, ex: typedef struct Node Node;.",
                                  "learningObjective": "Compreender os componentes essenciais de um nó em uma árvore binária de busca para tabelas de símbolos.",
                                  "commonMistakes": [
                                    "Esquecer de declarar ponteiros como ponteiros para o tipo da struct",
                                    "Não incluir bibliotecas para strings e alocação",
                                    "Definir campos com tipos incompatíveis para ordenação lexicográfica"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar a função de criação de um novo nó",
                                  "subSteps": [
                                    "Crie uma função createNode que recebe nome, tipo e escopo como parâmetros.",
                                    "Alocar memória dinamicamente com malloc para um novo nó.",
                                    "Copie os valores dos parâmetros para os campos do nó usando strcpy para strings.",
                                    "Inicialize left e right como NULL.",
                                    "Retorne o ponteiro para o novo nó e teste com printf para verificar valores."
                                  ],
                                  "verification": "Chame createNode e imprima os campos; valores devem estar corretos sem vazamentos de memória (use valgrind se possível).",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Compilador com suporte a debug",
                                    "Ferramenta de análise de memória como Valgrind"
                                  ],
                                  "tips": "Sempre verifique se malloc retornou NULL para evitar crashes.",
                                  "learningObjective": "Dominar a alocação dinâmica e inicialização de nós para construção segura da árvore.",
                                  "commonMistakes": [
                                    "Não copiar strings com strcpy, causando ponteiros pendentes",
                                    "Esquecer de inicializar ponteiros left/right",
                                    "Não checar falha de alocação"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar a função de inserção recursiva mantendo ordenação lexicográfica",
                                  "subSteps": [
                                    "Defina a função insert(Node** root, char* name, char* type, int scope) com ponteiro para ponteiro raiz.",
                                    "Se *root == NULL, crie novo nó com createNode e atribua a *root.",
                                    "Senão, compare name com (*root)->name usando strcmp.",
                                    "Se name < (*root)->name, insira recursivamente no subárvore esquerdo.",
                                    "Se name > (*root)->name, insira recursivamente no subárvore direito.",
                                    "Compile e teste inserções simples para verificar recursão."
                                  ],
                                  "verification": "Insira 3-5 símbolos e verifique que não há loops infinitos ou duplicatas incorretas.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Editor com suporte a recursão",
                                    "Compilador",
                                    "Exemplos de símbolos como 'int', 'main', 'x'"
                                  ],
                                  "tips": "Use strcmp(name, (*root)->name) < 0 para comparação lexicográfica case-sensitive.",
                                  "learningObjective": "Implementar inserção que preserva a propriedade de BST: left < node < right em ordem lexicográfica.",
                                  "commonMistakes": [
                                    "Comparação errada com strcmp (inverter ordem)",
                                    "Não usar ponteiro para ponteiro na raiz",
                                    "Inserir duplicatas sem tratamento"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Implementar verificação de ordenação via travessia in-order",
                                  "subSteps": [
                                    "Crie função inOrder(Node* root) que imprime nomes em ordem recursiva: left, node, right.",
                                    "Insira uma sequência de símbolos como 'var', 'int', 'main', 'printf', 'x'.",
                                    "Execute inOrder e verifique se saem em ordem alfabética: int, main, printf, var, x.",
                                    "Adicione função para checar balanceamento ou altura opcionalmente.",
                                    "Teste casos edge: árvore vazia, um nó, duplicatas."
                                  ],
                                  "verification": "Saída da inOrder mostra nomes ordenados lexicograficamente sem erros.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Lista de símbolos de teste",
                                    "Compilador"
                                  ],
                                  "tips": "InOrder traversal naturalmente produz ordem sorted em BST.",
                                  "learningObjective": "Validar a propriedade de ordenação da árvore binária de busca.",
                                  "commonMistakes": [
                                    "Erro na recursão da travessia",
                                    "Imprimir valores errados",
                                    "Não tratar nó NULL"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Integrar e testar a árvore como tabela de símbolos",
                                  "subSteps": [
                                    "Crie função main com inserções múltiplas simulando declaração de variáveis em um compilador.",
                                    "Execute inOrder para listar todos símbolos ordenados.",
                                    "Adicione busca simples para verificar existência de um símbolo.",
                                    "Libere memória recursivamente para evitar leaks.",
                                    "Rode testes com 10+ símbolos variados."
                                  ],
                                  "verification": "Programa executa corretamente, lista ordenada e sem vazamentos de memória.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Valgrind ou similar para leaks",
                                    "Conjunto de testes"
                                  ],
                                  "tips": "Simule escopos diferentes incrementando um contador.",
                                  "learningObjective": "Aplicar a BST em contexto real de tabela de símbolos de compilador.",
                                  "commonMistakes": [
                                    "Não liberar memória",
                                    "Ignorar escopos em comparações",
                                    "Falhar em casos de nomes iguais"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um compilador simples, insira símbolos: nome='int' tipo='keyword' escopo=0; nome='main' tipo='function' escopo=1; nome='x' tipo='var' escopo=1; nome='printf' tipo='function' escopo=0. A árvore resultante terá 'int' na raiz, 'main' e 'printf' à direita, 'x' sob 'main'. Travessia in-order: int, main, printf, x (ordenado lexicograficamente).",
                              "finalVerifications": [
                                "Travessia in-order lista símbolos em ordem lexicográfica crescente.",
                                "Todos nós têm ponteiros left/right corretos (NULL ou apontando para subárvores ordenadas).",
                                "Inserção de duplicatas é tratada (ex: não inserir ou marcar).",
                                "Busca por símbolo existente retorna o nó correto.",
                                "Não há vazamentos de memória após liberação.",
                                "Propriedade BST mantida: para todo nó, left < node < right."
                              ],
                              "assessmentCriteria": [
                                "Corretude da inserção: mantém ordenação em 100% dos testes.",
                                "Eficiência: O(log n) para inserções em árvores balanceadas.",
                                "Tratamento de erros: checa alocações e casos vazios.",
                                "Código limpo: comentários, indentação e modularidade.",
                                "Testes abrangentes: edges cases como vazio, um nó, desbalanceada.",
                                "Integração: funciona como tabela de símbolos com atributos."
                              ],
                              "crossCurricularConnections": [
                                "Algoritmos e Estruturas de Dados: Conceitos de BST e travessias.",
                                "Matemática: Ordenação lexicográfica e propriedades de árvores binárias.",
                                "Banco de Dados: Índices em B-trees semelhantes a BST.",
                                "Engenharia de Software: Gerenciamento de memória em sistemas.",
                                "Linguagens de Programação: Aplicação em compiladores e interpretadores."
                              ],
                              "realWorldApplication": "Em compiladores como GCC ou LLVM, tabelas de símbolos usam BST para armazenar variáveis, funções e tipos com busca rápida O(log n) durante análise semântica, evitando conflitos de nomes por escopo e mantendo eficiência em programas grandes."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.2.2.2",
                            "name": "Executar busca e remoção em árvores",
                            "description": "Desenvolver algoritmos recursivos ou iterativos para localizar símbolo por nome em O(log n) e remover nó preservando balanceamento, aplicável a escopos aninhados em análise semântica.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender estruturas de árvores binárias de busca balanceadas (BST e AVL)",
                                  "subSteps": [
                                    "Estude as propriedades de uma BST: nó esquerdo < nó atual < nó direito.",
                                    "Aprenda sobre árvores AVL: fator de balanceamento |altura_esq - altura_dir| <= 1.",
                                    "Revise operações básicas: inserção com rotações simples (LL, RR, LR, RL).",
                                    "Analise complexidade: busca, inserção e remoção em O(log n).",
                                    "Implemente uma classe Nó com campos: valor, nomeSimbolo, esquerda, direita, altura."
                                  ],
                                  "verification": "Implemente inserção básica e verifique fator de balanceamento em todos os nós via traversia in-order.",
                                  "estimatedTime": "2-3 horas",
                                  "materials": [
                                    "Documentação AVL Tree (Wikipedia/GeeksforGeeks)",
                                    "Editor de código (VS Code)",
                                    "Linguagem: Python ou C++"
                                  ],
                                  "tips": "Sempre atualize a altura após rotações; use funções auxiliares para calcular altura e fator de balanceamento.",
                                  "learningObjective": "Entender as propriedades e operações fundamentais de árvores AVL para manter O(log n).",
                                  "commonMistakes": [
                                    "Esquecer de atualizar alturas após rotações.",
                                    "Confundir rotações LR/RL.",
                                    "Não tratar casos de árvore vazia."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar algoritmo de busca recursivo e iterativo em O(log n)",
                                  "subSteps": [
                                    "Implemente busca recursiva: compare nomeSimbolo, recurse esquerda/direita ou retorne nó.",
                                    "Converta para iterativa usando loop while, evitando recursão profunda.",
                                    "Adicione contadores para medir profundidade e confirmar O(log n).",
                                    "Teste com dados desbalanceados iniciais para verificar eficiência pós-balanceamento.",
                                    "Integre com contexto de escopos: passe ponteiro para raiz do escopo atual."
                                  ],
                                  "verification": "Testes unitários: busque 100 símbolos aleatórios e confirme tempo médio log n e acurácia 100%.",
                                  "estimatedTime": "1-2 horas",
                                  "materials": [
                                    "Código base da Step 1",
                                    "Ferramenta de profiling (timeit em Python)",
                                    "Conjunto de testes com símbolos de compilador"
                                  ],
                                  "tips": "Para iterativo, use um loop while com ponteiro atual; retorne None se não encontrado.",
                                  "learningObjective": "Desenvolver e comparar implementações de busca eficiente em árvores balanceadas.",
                                  "commonMistakes": [
                                    "Recursão infinita em casos de loop (improvável em BST)",
                                    "Comparação errada de strings (case-sensitive)",
                                    "Ignorar escopos aninhados na busca."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar remoção básica em BST sem balanceamento",
                                  "subSteps": [
                                    "Identifique casos: nó folha, um filho, dois filhos (sucessor in-order).",
                                    "Caso folha: remova ponteiro pai.",
                                    "Caso um filho: substitua por filho.",
                                    "Caso dois filhos: encontre min da subárvore direita, copie valor, remova min.",
                                    "Atualize ponteiros pai durante remoção."
                                  ],
                                  "verification": "Traversia in-order antes/depois confirma ordem e ausência do símbolo removido.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Código das steps anteriores",
                                    "Exemplos visuais de remoção BST (animações online)"
                                  ],
                                  "tips": "Sempre encontre o sucessor in-order para dois filhos; evite predecessor para simplicidade.",
                                  "learningObjective": "Dominar os três casos de remoção em BST preservando ordem.",
                                  "commonMistakes": [
                                    "Não atualizar ponteiro do pai corretamente.",
                                    "Perder subárvore ao copiar valor.",
                                    "Remover raiz sem handler especial."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Estender remoção para AVL com preservação de balanceamento",
                                  "subSteps": [
                                    "Após remoção BST, propague desbalanceamento para cima verificando fatores.",
                                    "Aplique rotações duplas/single onde fator >1 ou <-1.",
                                    "Implemente getMin para encontrar sucessor e recursão para balanceamento bottom-up.",
                                    "Teste sequências de remoções que causam desbalanceamento (ex: remover raiz).",
                                    "Integre busca + remoção em função unificada para tabelas de símbolos."
                                  ],
                                  "verification": "Após 50 remoções aleatórias, confirme |fator balanceamento| <=1 em todos nós e altura O(log n).",
                                  "estimatedTime": "3-4 horas",
                                  "materials": [
                                    "Código completo anterior",
                                    "Biblioteca de testes (pytest/unittest)",
                                    "Visualizador de árvores (online tools)"
                                  ],
                                  "tips": "Balanceie no caminho de volta da recursão; priorize rotações baseadas no fator do filho.",
                                  "learningObjective": "Implementar remoção completa em AVL, garantindo balanceamento em O(log n).",
                                  "commonMistakes": [
                                    "Não propagar balanceamento após remoção.",
                                    "Rotações erradas em casos LR/RL.",
                                    "Recursão excessiva levando a stack overflow."
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Aplicar em tabelas de símbolos com escopos aninhados",
                                  "subSteps": [
                                    "Crie estrutura de escopos: árvore de escopos onde cada nó tem sua AVL de símbolos.",
                                    "Busca: percorra escopos pais até encontrar ou global.",
                                    "Remoção: localize em escopo correto e remova preservando balanceamento local.",
                                    "Simule análise semântica: insira variáveis em funções aninhadas, busque e remova temporárias.",
                                    "Meça performance em compilador toy com 1000 símbolos."
                                  ],
                                  "verification": "Simulação completa: compile código com escopos, verifique símbolos corretos sem vazamentos.",
                                  "estimatedTime": "2-3 horas",
                                  "materials": [
                                    "Código full AVL",
                                    "Exemplo de compilador simples (TinyC ou similar)",
                                    "Dados de teste com escopos JSON"
                                  ],
                                  "tips": "Use ponteiro para escopo atual na busca recursiva por escopos.",
                                  "learningObjective": "Contextualizar busca/remoção em compiladores reais.",
                                  "commonMistakes": [
                                    "Buscar em escopo errado (não subir hierarquia)",
                                    "Remover de escopo global por engano.",
                                    "Não restaurar balanceamento em escopo pai."
                                  ]
                                }
                              ],
                              "practicalExample": "Em um compilador para linguagem com blocos aninhados, implemente uma tabela de símbolos usando AVL por escopo. Insira 'int x=1;' em função main(), busque 'x' em sub-bloco (encontra no pai), remova variável temporária 'tmp' preservando balanceamento, confirmando O(log n) em 1000 declarações.",
                              "finalVerifications": [
                                "Busca retorna símbolo correto ou null em todos escopos aninhados.",
                                "Remoção preserva ordem in-order e balanceamento (|FB| <=1).",
                                "Profundidade máxima da árvore <= 2*log2(n) para n=1000.",
                                "Sem vazamentos de memória ou ponteiros dangling.",
                                "Performance: <1ms por operação em dataset realista.",
                                "Traversia in-order lista símbolos ordenados por nome."
                              ],
                              "assessmentCriteria": [
                                "Correção funcional: 100% testes passam (busca/remoção/casos edge).",
                                "Eficiência: O(log n) comprovado por profiling.",
                                "Balanceamento: Fator <=1 em 100% nós pós-operações.",
                                "Robustez: Trata árvores vazias, duplicatas, nomes longos.",
                                "Código limpo: Modular, comentado, sem warnings.",
                                "Integração: Funciona em hierarquia de escopos sem falhas."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Análise assintótica O(log n) e propriedades de árvores.",
                                "Bancos de Dados: Índices B+ árvores semelhantes a AVL para queries.",
                                "Análise de Algoritmos: Recursão vs iteração, amortização de rotações.",
                                "Engenharia de Software: Design de estruturas de dados para compiladores.",
                                "Inteligência Artificial: Árvores de decisão balanceadas em ML."
                              ],
                              "realWorldApplication": "Em compiladores como GCC ou LLVM, tabelas de símbolos usam árvores balanceadas para gerenciar milhões de símbolos em escopos aninhados (funções, classes), permitindo análise semântica rápida sem degradação para O(n)."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.2.2.3",
                            "name": "Avaliar balanceamento em árvores AVL",
                            "description": "Explicar rotações simples e duplas para manter altura balanceada em tabelas de símbolos, comparando com BST puro em cenários de compiladores com inserções desordenadas.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o Fator de Balanceamento em Árvores AVL",
                                  "subSteps": [
                                    "Revise a definição de árvore AVL: uma BST onde a diferença de altura entre subárvores esquerda e direita de qualquer nó é no máximo 1.",
                                    "Aprenda a calcular o fator de balanceamento (BF) para um nó: BF = altura(subesquerda) - altura(subbDireita).",
                                    "Implemente uma função recursiva para calcular alturas de subárvores.",
                                    "Teste o cálculo em uma árvore BST simples com 5-7 nós.",
                                    "Visualize a árvore usando ferramentas como draw.io ou código Python para plotar."
                                  ],
                                  "verification": "Calcule corretamente o BF para todos os nós em uma árvore de exemplo fornecida.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Pseudocódigo ou código em C/Python para calcular altura",
                                    "Ferramenta de visualização de árvores (ex: Graphviz)"
                                  ],
                                  "tips": "Sempre calcule alturas de baixo para cima recursivamente para evitar erros.",
                                  "learningObjective": "Calcular e interpretar o fator de balanceamento em nós AVL.",
                                  "commonMistakes": [
                                    "Confundir ordem de subárvores no cálculo de BF",
                                    "Esquecer nós folha com altura 0"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar e Aplicar Rotações Simples (LL e RR)",
                                  "subSteps": [
                                    "Estude o caso LL: inserção na subárvore esquerda do filho esquerdo (BF = +2).",
                                    "Implemente rotação direita simples em um nó desbalanceado.",
                                    "Estude o caso RR: inserção na subárvore direita do filho direito (BF = -2).",
                                    "Implemente rotação esquerda simples.",
                                    "Simule inserções que causem LL/RR e verifique restauração do balanceamento."
                                  ],
                                  "verification": "Aplique rotações em árvores de exemplo LL/RR e confirme BF <=1 em todos os nós.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Código template para rotações em AVL",
                                    "Animador online de rotações AVL (ex: VisuAlgo)"
                                  ],
                                  "tips": "Desenhe a rotação em papel antes de codificar para visualizar o pivô.",
                                  "learningObjective": "Executar rotações simples para corrigir desbalanceamentos LL e RR.",
                                  "commonMistakes": [
                                    "Trocar lados esquerdo/direito nas rotações",
                                    "Não atualizar pais corretamente"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Identificar e Aplicar Rotações Duplas (LR e RL)",
                                  "subSteps": [
                                    "Estude caso LR: inserção na subárvore direita do filho esquerdo (BF = +2).",
                                    "Implemente rotação esquerda no filho esquerdo + rotação direita no nó.",
                                    "Estude caso RL: inserção na subárvore esquerda do filho direito (BF = -2).",
                                    "Implemente rotação direita no filho direito + rotação esquerda no nó.",
                                    "Teste com sequências de inserção que gerem LR/RL."
                                  ],
                                  "verification": "Corrija árvores LR/RL desbalanceadas e valide alturas finais.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Código estendido com rotações duplas",
                                    "Exemplos visuais de antes/depois"
                                  ],
                                  "tips": "Lembre: rotação dupla é composição de duas simples no filho e no pai.",
                                  "learningObjective": "Executar rotações duplas para casos complexos de desbalanceamento.",
                                  "commonMistakes": [
                                    "Errar a ordem das rotações duplas",
                                    "Não rotacionar o filho primeiro"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Avaliar Balanceamento e Comparar com BST em Cenários de Compiladores",
                                  "subSteps": [
                                    "Simule inserções desordenadas (ex: chaves lexicográficas em tabela de símbolos).",
                                    "Construa AVL e BST paralelos, meça alturas e tempos de busca.",
                                    "Avalie: AVL mantém O(log n) vs BST degenera para O(n).",
                                    "Aplique em contexto de compiladores: inserções de variáveis em ordem alfabética.",
                                    "Gere relatório comparativo com métricas (altura, buscas).",
                                    "Verificações finais: todos BF entre -1 e +1 na AVL."
                                  ],
                                  "verification": "Compare alturas e desempenho em 100 inserções desordenadas.",
                                  "estimatedTime": "75 minutos",
                                  "materials": [
                                    "Implementação completa AVL vs BST",
                                    "Dados de teste: lista desordenada de símbolos"
                                  ],
                                  "tips": "Use contadores de altura e profundidade máxima para automação.",
                                  "learningObjective": "Avaliar superioridade AVL sobre BST em cenários reais de compiladores.",
                                  "commonMistakes": [
                                    "Ignorar custo de rotações na análise",
                                    "Testar apenas inserções ordenadas"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um compilador, insira símbolos {'z', 'y', 'x', 'w'} em ordem reversa. BST vira lista ligada (altura 4). AVL usa rotações RR/RL para manter altura 2, garantindo buscas rápidas em tabela de símbolos durante parsing.",
                              "finalVerifications": [
                                "Calcula BF corretamente em qualquer nó AVL.",
                                "Identifica tipo de desbalanceamento (LL, RR, LR, RL).",
                                "Executa rotações sem quebrar estrutura BST.",
                                "Verifica balanceamento global pós-rotação (todos |BF| <=1).",
                                "Compara desempenho AVL vs BST em inserções desordenadas.",
                                "Aplica em cenário de tabela de símbolos de compilador."
                              ],
                              "assessmentCriteria": [
                                "Precisão no cálculo de BF e alturas (100% correto).",
                                "Correta implementação e aplicação de todas 4 rotações.",
                                "Análise quantitativa: altura AVL <= 1.44 log n vs BST.",
                                "Código funcional sem vazamentos ou erros de ponteiros.",
                                "Relatório claro comparando cenários de compiladores.",
                                "Tempo de execução O(log n) em testes empíricos."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Análise de árvores binárias e propriedades de balanceamento.",
                                "Algoritmos: Complexidade amortizada de inserções/rotações.",
                                "Bancos de Dados: Índices B+ árvores balanceadas semelhantes.",
                                "Engenharia de Software: Estruturas eficientes para dicionários."
                              ],
                              "realWorldApplication": "Em compiladores (GCC, LLVM), árvores AVL otimizam tabelas de símbolos para lookups rápidos de variáveis durante análise semântica, evitando degradação em códigos com declarações desordenadas."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.3.2.3",
                        "name": "Tabelas Hash para Tabelas de Símbolos",
                        "description": "Estrutura baseada em função hash para mapear nomes de símbolos a índices de array, com tratamento de colisões via encadeamento ou sondagem, oferecendo buscas em tempo médio O(1) para eficiência em compiladores.",
                        "specificSkills": [
                          {
                            "id": "10.1.3.2.3.1",
                            "name": "Selecionar e implementar função hash",
                            "description": "Escolher hash polinomial ou folding para nomes de identificadores em linguagens de programação, computando índice em array de tamanho fixo para tabelas de símbolos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender Funções Hash Polinomial e Folding",
                                  "subSteps": [
                                    "Estude a definição de função hash: uma função que mapeia chaves (nomes de identificadores) para índices em um array de tamanho fixo.",
                                    "Aprenda hash folding: some dígitos ou caracteres agrupados e aplique módulo pelo tamanho da tabela (ex: para 'ABC', fold como (A + B + C) % tableSize).",
                                    "Aprenda hash polinomial: trate a string como polinômio em base 127 ou similar (ex: s[0]*127^3 + s[1]*127^2 + ... ) % tableSize).",
                                    "Compare vantagens: folding é simples e rápido para strings curtas; polinomial distribui melhor para identificadores alfanuméricos.",
                                    "Calcule exemplos manuais para strings como 'var', 'main', 'loop' com tableSize=101."
                                  ],
                                  "verification": "Liste fórmulas exatas e calcule hash para 3 identificadores diferentes usando ambas as funções, confirmando resultados idênticos aos esperados.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Documentação de hashing (Wikipedia: Hash function), editor de texto para cálculos manuais, calculadora"
                                  ],
                                  "tips": "Use ASCII values para caracteres (ex: 'A'=65) e teste com tableSize primo como 101 para melhor distribuição.",
                                  "learningObjective": "Diferenciar e calcular manualmente hash polinomial e folding para nomes de identificadores.",
                                  "commonMistakes": [
                                    "Ignorar módulo final, causando índices fora do range.",
                                    "Usar base inadequada no polinomial (prefira 127 para evitar overflow).",
                                    "Não tratar strings vazias ou nulas."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Avaliar e Selecionar Função Hash Adequada",
                                  "subSteps": [
                                    "Defina critérios: simplicidade de implementação, distribuição uniforme, velocidade para identificadores típicos (5-20 chars alfanuméricos).",
                                    "Teste distribuição: gere 20 identificadores comuns (var, i, functionX) e compute hashes para ambas funções com tableSize=101.",
                                    "Meça uniformidade: conte colisões potenciais (índices repetidos) e escolha a com menor variância.",
                                    "Considere contexto de compiladores: prefira polinomial para melhor espalhamento em tabelas de símbolos.",
                                    "Documente decisão: escreva parágrafo justificando escolha (ex: 'Polinomial selecionado por melhor distribuição em testes')."
                                  ],
                                  "verification": "Crie tabela comparativa com 20 hashes e estatísticas (média colisões <5%), confirmando seleção justificada.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Planilha ou script Python simples para contagem de frequências",
                                    "Lista de 20 identificadores de exemplo"
                                  ],
                                  "tips": "Use tableSize primo para reduzir colisões; priorize uniformidade sobre velocidade se >10% colisões.",
                                  "learningObjective": "Selecionar função hash baseada em testes empíricos e critérios de compiladores.",
                                  "commonMistakes": [
                                    "Escolher baseado só em teoria sem testes.",
                                    "Usar tableSize par ou poder de 2, piorando clusters.",
                                    "Ignorar case-sensitivity (use lowercase)."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar a Função Hash Selecionada",
                                  "subSteps": [
                                    "Escolha linguagem (ex: C para compilador): defina protótipo int hashFunction(char* key, int tableSize).",
                                    "Implemente lógica: para folding, some chars agrupados; para polinomial, loop com potência (use pow ou manual para evitar float).",
                                    "Aplique módulo: return abs(hashValue) % tableSize; trate overflow com unsigned long long.",
                                    "Adicione tratamento de edge cases: strings vazias retornam 0; NULL retorna -1.",
                                    "Integre em estrutura de tabela hash básica: struct SymbolTable { char** table; int size; };"
                                  ],
                                  "verification": "Compile código e rode unit tests para 10 strings, verificando índices em [0, tableSize-1].",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Compilador C/GCC ou IDE como VSCode",
                                    "Exemplos de código de hashing online"
                                  ],
                                  "tips": "Use unsigned para evitar negativos; pré-compute potências no polinomial para eficiência.",
                                  "learningObjective": "Codificar função hash funcional e robusta para tabelas de símbolos.",
                                  "commonMistakes": [
                                    "Overflow sem cast para unsigned.",
                                    "Não normalizar string (toLower).",
                                    "Loop infinito em strings longas sem limite."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Testar e Validar Implementação na Tabela de Símbolos",
                                  "subSteps": [
                                    "Crie função insert: use hash para índice, cheque colisão simples (linear probe).",
                                    "Implemente lookup: compute hash e procure no índice.",
                                    "Gere testes: insira 50 identificadores, busque 20, meça taxa de acerto e tempo médio.",
                                    "Analise performance: verifique load factor <0.7 e colisões <15%.",
                                    "Otimize se necessário: ajuste base ou folding groups."
                                  ],
                                  "verification": "Execute suite de testes com 100% acerto em lookups e relatório de métricas.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Framework de testes como Unity para C",
                                    "Gerador de identificadores aleatórios"
                                  ],
                                  "tips": "Registre logs de colisões para debug; mire <1ms por lookup.",
                                  "learningObjective": "Validar função hash em contexto real de tabela de símbolos.",
                                  "commonMistakes": [
                                    "Probing inadequado amplificando colisões ruins.",
                                    "Não testar strings longas ou com caracteres especiais.",
                                    "Ignorar memory leaks em inserts."
                                  ]
                                }
                              ],
                              "practicalExample": "Implemente hash polinomial para tabela de símbolos de tamanho 101 em C: para 'main123', compute (109*'m'+97*'a'+105*'i'+110*'n'+49*'1'+50*'2'+51*'3') com base 127, módulo 101, resultando em índice 42. Insira em tabela e lookup deve retornar sucesso.",
                              "finalVerifications": [
                                "Função produz índices sempre em [0, tableSize-1] para qualquer string válida.",
                                "Distribuição uniforme: <10% colisões em 100 identificadores aleatórios.",
                                "Tempo de execução <1ms por hash em strings de 20 chars.",
                                "Tratamento correto de edge cases (vazia, NULL, uppercase).",
                                "Integração perfeita com insert/lookup sem crashes.",
                                "Módulo final aplicado corretamente, sem overflow visível."
                              ],
                              "assessmentCriteria": [
                                "Correção: 100% testes passam sem erros.",
                                "Eficiência: O(1) médio, com load factor otimizado.",
                                "Robustez: Lida com todos edge cases e colisões.",
                                "Clareza: Código comentado e modular.",
                                "Escolha justificada: Documentação de testes comparativos.",
                                "Performance: Métricas comprovadas empiricamente."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Aritmética modular e polinômios.",
                                "Algoritmos: Análise de complexidade e probing.",
                                "Análise Léxica: Tokenização de identificadores.",
                                "Engenharia de Software: Testes unitários e profiling.",
                                "Bancos de Dados: Indexing e hash tables em SQL."
                              ],
                              "realWorldApplication": "Em compiladores como GCC ou Clang, funções hash polinomiais/folding aceleram tabelas de símbolos durante parsing, permitindo compilação rápida de milhões de linhas de código sem buscas lineares lentas."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.2.3.2",
                            "name": "Tratar colisões com encadeamento",
                            "description": "Implementar listas encadeadas em cada slot do array hash para resolver colisões, inserindo e buscando símbolos em cadeia colidida durante análise léxica.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender colisões em tabelas hash e solução por encadeamento",
                                  "subSteps": [
                                    "Estude o conceito de função hash e colisão (quando dois símbolos geram o mesmo índice).",
                                    "Analise exemplos de colisões em um array simples de hash.",
                                    "Aprenda como encadeamento usa listas ligadas em cada slot para armazenar múltiplos itens.",
                                    "Compare encadeamento com sondagem linear, destacando vantagens em análise léxica.",
                                    "Desenhe um diagrama de uma tabela hash com colisão resolvida por encadeamento."
                                  ],
                                  "verification": "Crie um diagrama manual de uma colisão resolvida e explique verbalmente.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Papel e caneta ou ferramenta de diagramação como Draw.io; documentação de hashing.",
                                  "tips": "Use hashes simples como soma de caracteres para visualizar colisões rapidamente.",
                                  "learningObjective": "Entender o problema de colisões e como encadeamento o resolve eficientemente.",
                                  "commonMistakes": "Confundir encadeamento com rehashing; ignorar custo de percorrer listas longas."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Definir estruturas de dados para tabela hash com encadeamento",
                                  "subSteps": [
                                    "Defina uma struct Node com campos: símbolo (string), próximo ponteiro.",
                                    "Crie struct HashTable com array de ponteiros para Node (tamanho fixo, ex: 101 slots).",
                                    "Implemente função hash simples (ex: soma de códigos ASCII módulo tamanho).",
                                    "Inicialize a tabela alocando array e definindo ponteiros como NULL.",
                                    "Adicione campos auxiliares como contagem de símbolos inseridos."
                                  ],
                                  "verification": "Compile o código das structs sem erros e imprima tabela vazia.",
                                  "estimatedTime": "1 hora",
                                  "materials": "Editor de código (VS Code ou similar); compilador C (GCC).",
                                  "tips": "Use typedef para structs para facilitar legibilidade.",
                                  "learningObjective": "Modelar dados para suportar múltiplos símbolos por slot via listas ligadas.",
                                  "commonMistakes": "Esquecer de inicializar ponteiros para NULL; usar tamanho de array inadequado."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar inserção em cadeia colidida",
                                  "subSteps": [
                                    "Calcule hash do símbolo de entrada.",
                                    "Se slot vazio, crie novo Node e aponte.",
                                    "Se slot ocupado, percorra lista até NULL e insira novo Node.",
                                    "Gerencie alocação dinâmica com malloc e verifique falhas.",
                                    "Atualize contador de inserções."
                                  ],
                                  "verification": "Insira 3 símbolos com colisão no mesmo slot e imprima cadeia.",
                                  "estimatedTime": "1 hora 30 minutos",
                                  "materials": "Código base da Step 2; debugger (GDB).",
                                  "tips": "Sempre cheque se ponteiro é NULL antes de avançar na lista.",
                                  "learningObjective": "Inserir símbolos eficientemente em listas encadeadas de slots hash.",
                                  "commonMistakes": "Loop infinito em lista; vazamento de memória sem free em testes."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Implementar busca em cadeia colidida",
                                  "subSteps": [
                                    "Calcule hash do símbolo procurado.",
                                    "Percorra lista no slot comparando strings.",
                                    "Retorne ponteiro para Node se encontrado, NULL caso contrário.",
                                    "Otimize comparando strings com strcmp.",
                                    "Teste com símbolos presentes e ausentes."
                                  ],
                                  "verification": "Busque símbolos colididos e não colididos, confirmando resultados.",
                                  "estimatedTime": "1 hora",
                                  "materials": "Código das Steps anteriores; conjunto de teste com 10 símbolos.",
                                  "tips": "Use busca linear simples, pois listas curtas em hashing bom.",
                                  "learningObjective": "Localizar símbolos rapidamente em cadeias colididas.",
                                  "commonMistakes": "Comparação errada de strings; não tratar slot vazio."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Integrar e testar na análise léxica",
                                  "subSteps": [
                                    "Simule tokens da análise léxica (ex: IDs, keywords).",
                                    "Insira tokens na tabela durante 'análise'.",
                                    "Busque para verificar duplicatas ou recuperar atributos.",
                                    "Implemente função de dump para imprimir toda tabela.",
                                    "Execute testes unitários com colisões intencionais."
                                  ],
                                  "verification": "Processar stream de 20 tokens com 20% colisões sem erros.",
                                  "estimatedTime": "1 hora 30 minutos",
                                  "materials": "Código completo; framework de testes (Unity para C).",
                                  "tips": "Gere colisões forçando símbolos com hash igual.",
                                  "learningObjective": "Aplicar tabela hash com encadeamento em fluxo de análise léxica.",
                                  "commonMistakes": "Não limpar tabela entre testes; ignorar case-sensitivity em símbolos."
                                }
                              ],
                              "practicalExample": "Em análise léxica de uma linguagem, tokens 'if' (hash=42) e 'fi' (hash=42) colidem no slot 42. Inserir 'if' cria Node inicial; inserir 'fi' adiciona à lista. Busca por 'if' percorre até encontrar, ignorando 'fi'.",
                              "finalVerifications": [
                                "Inserção de símbolos colididos forma cadeia correta.",
                                "Busca retorna símbolo exato em cadeia de 5+ itens.",
                                "Tabela mantém integridade após 100 inserções com 30% colisões.",
                                "Não há vazamentos de memória (valgrind clean).",
                                "Função hash distribui uniformemente (máx 5 por slot).",
                                "Integração com análise léxica detecta duplicatas corretamente."
                              ],
                              "assessmentCriteria": [
                                "Código compila e executa sem crashes (100%).",
                                "Eficiência: busca média O(1+α) com α<1 (90%).",
                                "Estruturas corretas: listas sem ciclos ou NULLs inválidos (100%).",
                                "Testes cobrem casos edge (colisão total, vazio) (80%).",
                                "Comentários e legibilidade do código (70%).",
                                "Aplicação correta em contexto léxico (90%)."
                              ],
                              "crossCurricularConnections": [
                                "Estruturas de Dados: Listas Ligadas e Hashing.",
                                "Algoritmos: Funções Hash e Complexidade Amortizada.",
                                "Compiladores: Análise Léxica e Gerenciamento de Símbolos.",
                                "Banco de Dados: Índices Hash com Overflow Chains.",
                                "Engenharia de Software: Testes Unitários em Estruturas Críticas."
                              ],
                              "realWorldApplication": "Em compiladores como GCC ou LLVM, tabelas de símbolos usam hashing com encadeamento para armazenar identifiers durante parsing, permitindo buscas rápidas em milhões de linhas de código sem perda de performance."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.2.3.3",
                            "name": "Aplicar sondagem linear para colisões",
                            "description": "Desenvolver busca e inserção com probing linear (h(k) + i mod m), gerenciando clusters e redimensionamento para fator de carga baixo em tabelas de símbolos grandes.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Configurar a estrutura básica da tabela hash",
                                  "subSteps": [
                                    "Defina o tamanho inicial da tabela (m) como um primo grande para minimizar colisões.",
                                    "Crie um array de tamanho m para armazenar os slots, inicializando com valores nulos ou sentinela.",
                                    "Implemente a função de hash h(k) simples, como soma de caracteres mod m para chaves de string.",
                                    "Defina o fator de carga alvo (ex: 0.7) para disparar redimensionamento.",
                                    "Teste a inicialização com uma tabela vazia."
                                  ],
                                  "verification": "Verifique se a tabela é criada com todos os slots vazios e h(k) produz índices válidos entre 0 e m-1.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Linguagem de programação (ex: Python ou C++)",
                                    "Editor de código",
                                    "Documentação de funções hash built-in"
                                  ],
                                  "tips": "Escolha m como primo próximo a 2^k para melhor distribuição.",
                                  "learningObjective": "Compreender e implementar a base de uma tabela hash aberta.",
                                  "commonMistakes": "Usar tamanho não primo, levando a mais colisões; ignorar overflow na função hash."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar inserção com sondagem linear",
                                  "subSteps": [
                                    "Para uma chave k, compute i = 0; pos = (h(k) + i) mod m.",
                                    "Enquanto o slot em pos não estiver vazio e não for a chave k, incremente i e recompute pos.",
                                    "Se encontrar slot vazio, insira k ali; se ciclo completo (i >= m), falhe ou redimensione.",
                                    "Registre o probe length para análise de clusters.",
                                    "Teste inserindo 5-10 chaves com colisões intencionais."
                                  ],
                                  "verification": "Insira chaves que colidem e confirme que são colocadas em slots subsequentes sem sobrescrever.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Código da Step 1",
                                    "Exemplos de chaves strings como nomes de variáveis"
                                  ],
                                  "tips": "Use uma sentinela 'DELETED' para remoções futuras, mas foque em inserção agora.",
                                  "learningObjective": "Aplicar a fórmula h(k) + i mod m para resolver colisões durante inserção.",
                                  "commonMistakes": "Parar no primeiro slot ocupado sem verificar se é a mesma chave; esquecer mod m."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar busca com sondagem linear",
                                  "subSteps": [
                                    "Para buscar k, inicie i=0; pos = (h(k) + i) mod m.",
                                    "Continue até encontrar k, slot vazio ou ciclo completo.",
                                    "Pare ao encontrar slot vazio (não pode estar além).",
                                    "Registre probe length médio para 20 buscas.",
                                    "Teste buscas bem-sucedidas, falhas e após inserções."
                                  ],
                                  "verification": "Busque chaves inseridas e confirme retorno correto; busque inexistentes e retorne null sem loop infinito.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Código das Steps 1-2",
                                    "Conjunto de chaves de teste"
                                  ],
                                  "tips": "Busca para mais cedo que inserção devido a slots vazios.",
                                  "learningObjective": "Realizar buscas eficientes parando em vazios para evitar clusters longos.",
                                  "commonMistakes": "Não parar em slot vazio, percorrendo clusters desnecessariamente."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Gerenciar clusters e redimensionamento",
                                  "subSteps": [
                                    "Monitore load factor = n/m; se > 0.7, redimensione para 2m ou próximo primo.",
                                    "Rehash todas as entradas existentes na nova tabela usando probing linear.",
                                    "Meça cluster lengths antes/depois e reduza máximo para <10.",
                                    "Implemente remoção com 'DELETED' para manter chains.",
                                    "Teste com 100 inserções até trigger redimensionamento."
                                  ],
                                  "verification": "Após redimensionamento, todas chaves são encontráveis e load factor <0.7; clusters curtos.",
                                  "estimatedTime": "50 minutos",
                                  "materials": [
                                    "Código anterior",
                                    "Ferramentas de profiling (ex: timeit em Python)"
                                  ],
                                  "tips": "Rehash em thread-safe se multi-threaded, mas foque single-thread.",
                                  "learningObjective": "Otimizar performance gerenciando clusters via redimensionamento dinâmico.",
                                  "commonMistakes": "Não rehashar todas entradas; escolher novo m não primo."
                                }
                              ],
                              "practicalExample": "Em um compilador, insira símbolos 'var1', 'var2' (h('var1')=5, h('var2')=5 mod 11). Probe: pos=5 (ocupado), i=1 pos=6 (vazio)->insira var2. Busca var2: probe até pos=6. Redimensione se load>0.7 para tabela de 1000s símbolos.",
                              "finalVerifications": [
                                "Inserção resolve colisões sem perda de dados.",
                                "Busca retorna corretamente em < m probes.",
                                "Redimensionamento mantém todas chaves acessíveis.",
                                "Load factor permanece <0.7 após operações.",
                                "Probe lengths médios <5 para 100 operações.",
                                "Sem loops infinitos ou overflows."
                              ],
                              "assessmentCriteria": [
                                "Correção: Todas operações passam em testes unitários.",
                                "Eficiência: Tempo de busca O(1) médio, probe <10 max.",
                                "Escalabilidade: Funciona com 10k entradas sem degradação.",
                                "Gerenciamento de clusters: Máx cluster <15 slots.",
                                "Código limpo: Modular, comentado, sem vazamentos.",
                                "Análise: Relatório de métricas pré/pós redimensionamento."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Aritmética modular e propriedades de primos.",
                                "Algoritmos: Análise de complexidade amortizada O(1).",
                                "Engenharia de Software: Design de estruturas de dados escaláveis.",
                                "Probabilidade: Distribuição de hashes e colisões esperadas."
                              ],
                              "realWorldApplication": "Em compiladores como GCC ou LLVM, tabelas hash com probing linear gerenciam milhões de símbolos (variáveis, funções) eficientemente durante parsing e otimização, evitando buscas lineares lentas em tabelas grandes."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.2.3.4",
                            "name": "Comparar eficiência de tabelas hash",
                            "description": "Analisar tempo médio e pior caso versus listas e árvores, justificando uso em compiladores para símbolos globais e locais com alto volume de consultas.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar complexidades assintóticas das estruturas de dados",
                                  "subSteps": [
                                    "Estude as operações principais: inserção, busca e remoção para tabelas hash, listas ligadas e árvores binárias de busca (BST).",
                                    "Anote as complexidades no pior caso: O(n) para listas, O(log n) para BST balanceadas, O(n) para hash com colisões ruins.",
                                    "Registre complexidades no caso médio: O(1) para hash bem implementada, O(n) para listas, O(log n) para BST.",
                                    "Compare com árvores AVL ou Red-Black para cenários balanceados.",
                                    "Crie uma tabela comparativa resumindo Big O para cada operação."
                                  ],
                                  "verification": "Tabela comparativa completa com todas as operações e casos listados corretamente.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Notas de aula sobre estruturas de dados",
                                    "Referências: CLRS ou Introduction to Algorithms"
                                  ],
                                  "tips": "Use notação Big O de forma consistente e inclua fatores como fator de carga em hash tables.",
                                  "learningObjective": "Compreender as diferenças fundamentais em eficiência assintótica entre as estruturas.",
                                  "commonMistakes": [
                                    "Confundir caso médio com pior caso para hash tables",
                                    "Ignorar colisões em hash",
                                    "Esquecer remoção em listas"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar cenários médios e piores casos com exemplos numéricos",
                                  "subSteps": [
                                    "Simule uma lista ligada com 1000 símbolos: calcule tempo de busca sequencial.",
                                    "Simule BST desbalanceada (pior caso linear) vs balanceada.",
                                    "Implemente uma hash table simples com chaining e calcule acessos médios com fator de carga 0.7.",
                                    "Compare tempos para 10k consultas: liste tempo vs. n=1000.",
                                    "Discuta impacto de colisões (hash ruim) levando a O(n) pior caso."
                                  ],
                                  "verification": "Cálculos numéricos corretos e gráficos comparativos gerados.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Python ou pseudocódigo para simulações",
                                    "Ferramentas como Jupyter Notebook"
                                  ],
                                  "tips": "Use funções hash boas como Python's hash() e meça empiricamente para validar teoria.",
                                  "learningObjective": "Quantificar vantagens de hash tables em cenários reais de alto volume.",
                                  "commonMistakes": [
                                    "Assumir sempre O(1) para hash sem considerar fator de carga",
                                    "Não testar com dados reais",
                                    "Ignorar overhead de hash computation"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Aplicar comparações ao contexto de compiladores e tabelas de símbolos",
                                  "subSteps": [
                                    "Descreva tabelas de símbolos em compiladores: globais (estáticas, poucas inserções/muitas buscas) vs. locais (scoped, dinâmicas).",
                                    "Explique por que listas são ruins para alto volume: buscas O(n) em milhões de consultas.",
                                    "Discuta árvores para ordenação, mas O(log n) ainda lento para n grande em buscas frequentes.",
                                    "Justifique hash: O(1) médio ideal para símbolos globais com hashing de nomes.",
                                    "Considere nested scopes com hash tables separadas por escopo."
                                  ],
                                  "verification": "Diagrama ou texto explicando fluxos em compiladores com cada estrutura.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Documentação de compiladores como GCC ou LLVM",
                                    "Exemplos de código fonte de tabelas de símbolos"
                                  ],
                                  "tips": "Pense em fases do compilador: análise léxica/sintática com muitas lookups.",
                                  "learningObjective": "Conectar teoria a uso prático em compiladores.",
                                  "commonMistakes": [
                                    "Subestimar frequência de buscas em compiladores",
                                    "Confundir globais com locais",
                                    "Ignorar gerenciamento de memória em hash"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Sintetizar justificativas e trade-offs para escolha de hash tables",
                                  "subSteps": [
                                    "Liste prós/cons: hash (rápido médio, vulnerável a ataques), listas (simples, lento), árvores (balanceado, overhead).",
                                    "Justifique uso em compiladores: alto volume de consultas justifica O(1) médio.",
                                    "Discuta mitigações: resizing, boas funções hash, open addressing.",
                                    "Crie um fluxograma de decisão para escolher estrutura baseada em workload.",
                                    "Resuma em parágrafo: quando usar hash vs. alternativas."
                                  ],
                                  "verification": "Fluxograma e resumo escrito justificando hash para o contexto dado.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Papel ou ferramenta de diagrama como Draw.io"
                                  ],
                                  "tips": "Considere workloads reais: compilação de grandes projetos com 100k+ símbolos.",
                                  "learningObjective": "Formular argumentos racionais para seleção de estruturas em cenários específicos.",
                                  "commonMistakes": [
                                    "Ignorar trade-offs de memória em hash",
                                    "Generalizar sem contexto",
                                    "Não mencionar segurança em hash"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um compilador para uma linguagem como C++, simule uma tabela de símbolos globais com 50.000 funções/variáveis. Use hash table para buscas em tempo de análise semântica (milhões de lookups); compare com lista ligada que demoraria segundos vs. microssegundos em hash.",
                              "finalVerifications": [
                                "Explicar corretamente O(1) médio vs. O(n) pior para hash tables.",
                                "Identificar cenários onde árvores superam hash (ex: range queries).",
                                "Justificar hash para símbolos globais em compiladores.",
                                "Calcular impacto de fator de carga >1 em performance.",
                                "Discutir uso em scopes locais nested.",
                                "Comparar empiricamente com código simples."
                              ],
                              "assessmentCriteria": [
                                "Precisão nas complexidades assintóticas (100% correto).",
                                "Profundidade na análise de compiladores (conexão clara com símbolos).",
                                "Uso de exemplos numéricos/empíricos convincentes.",
                                "Identificação de trade-offs e mitigações.",
                                "Clareza na justificativa final.",
                                "Criatividade em conexões reais."
                              ],
                              "crossCurricularConnections": [
                                "Análise de Algoritmos: Estudo de amortização em hash resizing.",
                                "Engenharia de Software: Design de sistemas com alto throughput de consultas.",
                                "Banco de Dados: Índices hash vs. B-trees em DBMS.",
                                "Segurança da Informação: Ataques de hash collision (ex: DoS).",
                                "Matemática: Probabilidade em análise média de hash."
                              ],
                              "realWorldApplication": "Em compiladores como GCC ou Clang, hash tables aceleram lookups de símbolos durante parsing e otimização, reduzindo tempo de compilação em projetos grandes como Linux kernel de horas para minutos."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.3.3",
                    "name": "Gerenciamento de Escopos",
                    "description": "Tratamento de escopos aninhados, visibilidade e resolução de símbolos em blocos e funções.",
                    "individualConcepts": [
                      {
                        "id": "10.1.3.3.1",
                        "name": "Escopos Aninhados",
                        "description": "Compreensão da estrutura hierárquica de escopos em linguagens de programação, onde blocos e funções criam novos escopos internos acessíveis a partir de escopos pais.",
                        "specificSkills": [
                          {
                            "id": "10.1.3.3.1.1",
                            "name": "Identificar hierarquia de escopos em código-fonte",
                            "description": "Analisar um trecho de código com funções e blocos aninhados para mapear a árvore de escopos, identificando o escopo pai de cada declaração de variável.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender Conceitos Básicos de Escopos Aninhados",
                                  "subSteps": [
                                    "Defina escopo como a região do código onde uma variável é acessível.",
                                    "Diferencie escopo global, local e aninhado (lexical).",
                                    "Estude regras de shadowing e lookup de variáveis em linguagens como Python ou JavaScript.",
                                    "Identifique delimitadores comuns: funções, blocos { }, if/while/for.",
                                    "Revise exemplos simples de aninhamento."
                                  ],
                                  "verification": "Escreva uma definição própria de escopo aninhado e liste 3 exemplos de delimitadores.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Documentação oficial de Python/JavaScript sobre escopos",
                                    "Vídeo tutorial de 5 minutos sobre escopos léxicos"
                                  ],
                                  "tips": "Sempre comece pelo escopo global como raiz da árvore.",
                                  "learningObjective": "Dominar definições fundamentais para análise hierárquica.",
                                  "commonMistakes": [
                                    "Confundir escopo estático (lexical) com dinâmico",
                                    "Ignorar escopos de blocos não-funcionais"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar Estrutura Geral do Código-Fonte",
                                  "subSteps": [
                                    "Leia o código inteiro de cima para baixo, anotando funções e blocos.",
                                    "Numere cada função/bloco sequencialmente (ex: F1, B1).",
                                    "Marque posições de abertura e fechamento de escopos.",
                                    "Liste todas as declarações de variáveis com suas linhas.",
                                    "Desenhe um esboço linear da estrutura."
                                  ],
                                  "verification": "Crie uma lista numerada de todos os escopos e declarações de variáveis.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Editor de texto com numeração de linhas (VS Code)",
                                    "Papel e caneta para esboços"
                                  ],
                                  "tips": "Use indentação do código como pista visual inicial.",
                                  "learningObjective": "Preparar uma visão panorâmica para mapeamento hierárquico.",
                                  "commonMistakes": [
                                    "Pular blocos condicionais ou loops",
                                    "Não notar funções aninhadas"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Mapear Hierarquia e Árvores de Escopos",
                                  "subSteps": [
                                    "Inicie com escopo global como nó raiz.",
                                    "Para cada escopo filho, identifique o pai imediato pelo aninhamento.",
                                    "Conecte nós pai-filho formando a árvore.",
                                    "Associe cada declaração de variável ao seu escopo de declaração.",
                                    "Valide lookup: confirme acessibilidade de variáveis de pais."
                                  ],
                                  "verification": "Desenhe a árvore de escopos com rótulos e indique pai de cada variável.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Ferramenta de diagramação (Draw.io ou papel)",
                                    "Código-fonte impresso"
                                  ],
                                  "tips": "Use setas para conexões pai-filho e evite ciclos.",
                                  "learningObjective": "Construir visualmente a árvore de escopos.",
                                  "commonMistakes": [
                                    "Atribuir pai errado por indentação visual enganosa",
                                    "Esquecer escopo global"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificar e Refinar o Mapeamento",
                                  "subSteps": [
                                    "Simule execução traçando acessos a variáveis.",
                                    "Teste shadowing: declare variável homônima em filho.",
                                    "Compare com ferramentas como AST explorer.",
                                    "Documente exceções ou peculiaridades da linguagem.",
                                    "Revise árvore para completude."
                                  ],
                                  "verification": "Explique por que uma variável específica tem um pai determinado.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "AST Explorer online (astexplorer.net)",
                                    "Debugger do navegador/editor"
                                  ],
                                  "tips": "Pergunte: 'De qual escopo esta var é visível?'",
                                  "learningObjective": "Garantir precisão e robustez do mapeamento.",
                                  "commonMistakes": [
                                    "Assumir visibilidade sem verificar regras léxicas",
                                    "Ignorar hoisting em JS"
                                  ]
                                }
                              ],
                              "practicalExample": "Considere este código Python:\n\ndef global_scope():\n    x = 10  # Escopo F1 (filho de global)\n    def nested():\n        y = 20  # Escopo F2 (filho de F1)\n        if y > 15:\n            z = 30  # Escopo B1 (filho de F2)\n    nested()\nglobal_scope()\nÁrvore: Global -> F1(x) -> F2(y) -> B1(z). Pai de z é F2.",
                              "finalVerifications": [
                                "Árvore de escopos mapeada corretamente sem ciclos.",
                                "Cada variável associada ao escopo pai exato.",
                                "Simulação de lookup confirma acessibilidade.",
                                "Identificados todos os blocos aninhados.",
                                "Explicação escrita justifica cada conexão pai-filho.",
                                "Teste com var homônima demonstra shadowing."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de 100% dos escopos e pais.",
                                "Árvore visual clara e hierarquicamente correta.",
                                "Tratamento correto de blocos não-funcionais.",
                                "Explicações detalhadas para pelo menos 3 variáveis.",
                                "Detecção e explicação de pelo menos 1 potencial erro comum.",
                                "Tempo de análise eficiente (menos de 1h para código médio)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Representação de árvores e grafos hierárquicos.",
                                "Lógica e Filosofia: Conceitos de encapsulamento e visibilidade.",
                                "Linguagens Naturais: Parsing sintático similar a análise gramatical.",
                                "Engenharia de Software: Modularidade e abstração em design."
                              ],
                              "realWorldApplication": "Em compiladores e interpretadores, para construir tabelas de símbolos durante a fase semântica; em debuggers para resolver escopos durante stepping; em linters para detectar erros de variável indefinida ou shadowing indesejado."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.3.1.2",
                            "name": "Implementar criação de novo escopo em tabela de símbolos",
                            "description": "Desenvolver código que, ao encontrar um bloco ou função, crie uma nova tabela de símbolos filha vinculada à tabela pai, inicializando-a vazia.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Definir a estrutura de dados para Tabela de Símbolos com suporte a escopos aninhados",
                                  "subSteps": [
                                    "Crie uma classe SymbolTable com um mapa (ex: HashMap<String, Symbol>) para armazenar símbolos.",
                                    "Adicione um ponteiro para a tabela pai (parent: SymbolTable?).",
                                    "Inclua um método para verificar se um símbolo existe no escopo atual ou em escopos pais (lookup).",
                                    "Implemente construtor que recebe a tabela pai opcional e inicializa o mapa vazio."
                                  ],
                                  "verification": "Instancie uma SymbolTable e verifique se o mapa está vazio e parent é null ou correto via debug ou teste unitário.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Editor de código (VS Code ou IntelliJ)",
                                    "Linguagem de programação (Java, Python ou C++)"
                                  ],
                                  "tips": "Use interfaces para Symbol para flexibilidade futura.",
                                  "learningObjective": "Compreender hierarquia de escopos usando composição de objetos.",
                                  "commonMistakes": [
                                    "Esquecer de inicializar o mapa vazio.",
                                    "Não tratar parent como nullable."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar detecção de eventos de criação de escopo no analisador sintático",
                                  "subSteps": [
                                    "Identifique nós AST que representam blocos ou funções (ex: FunctionNode, BlockNode).",
                                    "No visitor ou parser recursivo, detecte entrada nesses nós.",
                                    "Prepare contexto atual da tabela de símbolos (currentScope).",
                                    "Registre o evento de 'enterScope' com informações do nó atual."
                                  ],
                                  "verification": "Execute parser em código com função e bloco; logue detecção via console ou breakpoints.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "AST parser gerado (ANTLR ou handmade)",
                                    "Exemplos de código fonte com funções e blocos"
                                  ],
                                  "tips": "Use pattern visitor para separar lógica de escopo da análise sintática.",
                                  "learningObjective": "Integrar gerenciamento de escopo com análise sintática.",
                                  "commonMistakes": [
                                    "Detectar saída em vez de entrada.",
                                    "Ignorar escopos condicionais como if/else."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Desenvolver função para criar e ativar novo escopo filho",
                                  "subSteps": [
                                    "Crie método pushScope() na classe SymbolTable que retorna nova ST com self como parent.",
                                    "Salve a tabela anterior em uma pilha de escopos (scopeStack).",
                                    "Atualize currentScope para a nova tabela.",
                                    "Inicialize a nova tabela vazia e associe ao nó AST se necessário."
                                  ],
                                  "verification": "Chame pushScope() e verifique: nova ST vazia, parent correto, pilha atualizada.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Estrutura de pilha (Stack<SymbolTable>)",
                                    "Testes unitários (JUnit ou pytest)"
                                  ],
                                  "tips": "Mantenha pilha global ou no contexto do compilador para pop futuro.",
                                  "learningObjective": "Implementar criação dinâmica de escopos vinculados hierarquicamente.",
                                  "commonMistakes": [
                                    "Não linkar corretamente ao parent.",
                                    "Inicializar com símbolos herdados (deve ser vazia)."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Integrar criação de escopo no fluxo do compilador e adicionar testes básicos",
                                  "subSteps": [
                                    "No visitor/parser, chame pushScope() ao entrar em bloco/função.",
                                    "Adicione popScope() simétrico para saída (guarde para próxima lição).",
                                    "Teste com código fonte simples: função com variável local.",
                                    "Verifique lookup resolvendo nomes em escopos pai."
                                  ],
                                  "verification": "Compile código com escopos aninhados; sem erros de símbolo não encontrado e ST hierarquia correta.",
                                  "estimatedTime": "50 minutos",
                                  "materials": [
                                    "Compilador parcial com AST",
                                    "Código teste: func() { var x; } var x;"
                                  ],
                                  "tips": "Use debugger para inspecionar pilha de escopos em runtime.",
                                  "learningObjective": "Aplicar criação de escopo em compilador funcional.",
                                  "commonMistakes": [
                                    "Leak de escopos (não pop).",
                                    "Lookup falhando em hierarquia."
                                  ]
                                }
                              ],
                              "practicalExample": "Em Python: class SymbolTable: def __init__(self, parent=None): self.symbols = {}; self.parent = parent. Ao parsear 'def func(): x=1', pushScope() cria st = SymbolTable(current), current=st; st.symbols['x'] = Symbol('x').",
                              "finalVerifications": [
                                "Nova tabela é instanciada vazia ao entrar em função/bloco.",
                                "Ponteiro parent aponta corretamente para tabela anterior.",
                                "Pilha de escopos reflete hierarquia atual.",
                                "Lookup busca em escopo atual primeiro, depois pais recursivamente.",
                                "Não há vazamento de memória ou referências circulares."
                              ],
                              "assessmentCriteria": [
                                "Código compila sem erros e executa pushScope corretamente.",
                                "Testes unitários passam para 3 níveis de aninhamento.",
                                "Tempo de execução não degrada com escopos profundos.",
                                "Código é legível com comentários em pontos chave.",
                                "Tratamento de edge cases: escopo sem pai (global)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Estruturas de árvores e grafos direcionados (pai-filho).",
                                "Programação Orientada a Objetos: Composição e herança simulada.",
                                "Banco de Dados: Escopos como namespaces em SQL.",
                                "Lógica: Resolução de nomes como busca em árvore de decisão."
                              ],
                              "realWorldApplication": "Em compiladores como GCC/Clang para C++, gerencia visibilidade de variáveis em funções/blocos; em interpreters Python/JavaScript para runtime scopes dinâmicos, evitando colisões de nomes em módulos aninhados."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.3.1.3",
                            "name": "Gerenciar profundidade de aninhamento de escopos",
                            "description": "Manter um contador ou pilha de escopos para rastrear a profundidade atual durante a análise sintática, evitando estouro de pilha em aninhamentos profundos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o conceito de profundidade de aninhamento de escopos",
                                  "subSteps": [
                                    "Estude a estrutura de escopos aninhados em linguagens de programação, como blocos { } em C ou funções aninhadas.",
                                    "Analise como a análise sintática (parsing) processa árvores de sintaxe abstrata (AST) com níveis profundos.",
                                    "Identifique riscos de estouro de pilha recursiva em parsers descendentes quando o aninhamento excede limites.",
                                    "Revise exemplos de código com aninhamento profundo (ex: 100 níveis de blocos).",
                                    "Desenhe um diagrama de pilha de escopos representando profundidade atual."
                                  ],
                                  "verification": "Crie um diagrama manual de uma árvore de escopos com 5 níveis e anote a profundidade em cada nó.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Documentação de parsers (ex: ANTLR ou yacc)",
                                    "Editor de diagramas (Draw.io)",
                                    "Exemplos de código fonte com aninhamento profundo"
                                  ],
                                  "tips": "Comece com exemplos simples de 2-3 níveis antes de escalar para profundidades maiores.",
                                  "learningObjective": "Entender por que rastrear profundidade evita recursão infinita e estouro de pilha.",
                                  "commonMistakes": "Confundir profundidade com largura da árvore ou ignorar limites de pilha da linguagem."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar um contador simples de profundidade",
                                  "subSteps": [
                                    "Crie uma classe ou estrutura para o gerenciador de escopos com um inteiro 'depthCounter'.",
                                    "Defina funções: incrementar ao entrar em novo escopo (ex: onEnterScope()), decrementar ao sair (onExitScope()).",
                                    "Adicione verificação de limite (ex: if depth > MAX_DEPTH, lance erro).",
                                    "Integre chamadas em um parser mock simples processando tokens de abertura/fechamento de escopo.",
                                    "Registre logs da profundidade atual em cada mudança."
                                  ],
                                  "verification": "Execute o parser em código com 10 níveis aninhados e confirme que depthCounter retorna corretamente sem exceder limite.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Linguagem de programação (Python ou C++)",
                                    "IDE com debugger",
                                    "Parser simples de exemplo (ex: expressão com parênteses)"
                                  ],
                                  "tips": "Use asserts ou prints para monitorar o contador em tempo real durante testes.",
                                  "learningObjective": "Implementar rastreamento básico de profundidade usando contador linear.",
                                  "commonMistakes": "Esquecer de decrementar no exit, causando contagem inflada permanente."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Evoluir para gerenciamento com pilha de escopos",
                                  "subSteps": [
                                    "Substitua o contador por uma Stack<Scope> onde cada Scope armazena ID, pai e profundidade.",
                                    "Ao entrar: push novo Scope com depth = stack.size().",
                                    "Ao sair: pop e valide que depth corresponde ao esperado.",
                                    "Adicione suporte a metadados por escopo (ex: símbolos locais).",
                                    "Implemente detecção de aninhamento excessivo via stack.size() > MAX_DEPTH."
                                  ],
                                  "verification": "Teste com parser que constrói tabela de símbolos; verifique se pilha esvazia corretamente após parsing completo.",
                                  "estimatedTime": "75 minutos",
                                  "materials": [
                                    "Biblioteca de Stack (ex: std::stack em C++ ou deque em Python)",
                                    "Código do contador do Step 2",
                                    "Testes unitários (JUnit ou pytest)"
                                  ],
                                  "tips": "Sempre pop emparelhado com push para evitar vazamentos de memória na pilha.",
                                  "learningObjective": "Dominar uso de pilha para rastreamento hierárquico e robusto de escopos.",
                                  "commonMistakes": "Push sem pop correspondente ou pop em pilha vazia, causando exceções."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Integrar e testar em análise sintática completa",
                                  "subSteps": [
                                    "Incorpore o gerenciador em um parser recursivo descendente ou LL(1).",
                                    "Gere casos de teste: aninhamento válido profundo, inválido (excesso depth), desalinhado.",
                                    "Meça performance com 1000 níveis e otimize se necessário (iterativo vs recursivo).",
                                    "Adicione recuperação de erros para depth overflow.",
                                    "Valide saída: tabela de símbolos com escopos corretamente aninhados."
                                  ],
                                  "verification": "Parser processa código com 50 níveis sem crash e gera relatório de profundidade máxima.",
                                  "estimatedTime": "90 minutos",
                                  "materials": [
                                    "Parser generator (ex: ANTLR)",
                                    "Casos de teste extremos",
                                    "Profiler de performance"
                                  ],
                                  "tips": "Use recursão tail para otimizar em linguagens que suportam, ou converta para iterativo.",
                                  "learningObjective": "Aplicar gerenciamento de profundidade em pipeline real de compilador.",
                                  "commonMistakes": "Ignorar depth em funções recursivas do parser, levando a stack overflow dupla."
                                }
                              ],
                              "practicalExample": "Em um parser para uma mini-linguagem como 'MiniC', ao encontrar '{', push novo escopo na pilha (depth=stack.size()), adicione variáveis locais; ao encontrar '}', pop e retorne ao escopo pai. Teste com: func1 { func2 { func3 { var x; } } } – pilha rastreia depth=3 sem overflow.",
                              "finalVerifications": [
                                "Contador/pilha nunca excede MAX_DEPTH (ex: 100) em testes extremos.",
                                "Todos os escopos são pop corretamente; pilha vazia ao fim do parsing.",
                                "Tabela de símbolos reflete hierarquia correta de aninhamento.",
                                "Parser lida com erros de depth overflow emitindo mensagem clara.",
                                "Performance: parsing de 500 níveis < 1s sem recursão profunda.",
                                "Logs mostram depth atual variando corretamente em entradas aninhadas."
                              ],
                              "assessmentCriteria": [
                                "Correção: depth rastreada precisamente em 100% dos testes.",
                                "Robustez: gerencia overflow sem crash do programa.",
                                "Eficiência: O(1) por operação de enter/exit scope.",
                                "Modularidade: gerenciador separado e reutilizável.",
                                "Documentação: comentários explicam lógica de depth.",
                                "Testes: cobertura >90% incluindo casos edge."
                              ],
                              "crossCurricularConnections": [
                                "Estruturas de Dados: Pilhas e árvores para modelagem hierárquica.",
                                "Algoritmos: Análise sintática e parsing bottom-up/top-down.",
                                "Engenharia de Software: Gerenciamento de estado em compiladores.",
                                "Matemática: Recursão e teoria de grafos acíclicos direcionados (DAG)."
                              ],
                              "realWorldApplication": "Em compiladores como GCC ou Clang, previne stack overflow durante parsing de código com recursão profunda (ex: shaders em jogos); editores como VS Code usam para symbol outlining em arquivos grandes."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.3.3.2",
                        "name": "Visibilidade de Símbolos",
                        "description": "Regras que determinam quais símbolos declarados em um escopo são visíveis em escopos filhos, incluindo conceitos de shadowing e hiding.",
                        "specificSkills": [
                          {
                            "id": "10.1.3.3.2.1",
                            "name": "Aplicar regras de visibilidade em escopos filhos",
                            "description": "Verificar se um símbolo declarado no escopo pai é acessível no escopo filho sem shadowing, simulando buscas em tabelas hierárquicas.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender Hierarquia de Escopos e Tabelas de Símbolos",
                                  "subSteps": [
                                    "Defina escopo pai como o ambiente declarativo que engloba o escopo filho.",
                                    "Explique tabela de símbolos hierárquica: cada escopo tem sua própria tabela, referenciando a do pai.",
                                    "Desenhe um diagrama simples mostrando escopo global -> função -> bloco local.",
                                    "Identifique símbolos locais vs. herdados do pai.",
                                    "Liste exemplos de linguagens (C++, Java) com escopos aninhados."
                                  ],
                                  "verification": "Crie um diagrama de 3 níveis de escopos e anote 2 símbolos em cada.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Papel e caneta ou ferramenta de diagrama como Draw.io",
                                    "Documentação de tabelas de símbolos em compiladores"
                                  ],
                                  "tips": [
                                    "Use setas para mostrar herança de escopos pai-filho.",
                                    "Comece sempre do escopo mais externo."
                                  ],
                                  "learningObjective": "Dominar a estrutura hierárquica de escopos e como tabelas de símbolos são organizadas.",
                                  "commonMistakes": [
                                    "Confundir escopo lexical com dinâmico.",
                                    "Ignorar que escopos irmãos não se acessam diretamente."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Aprender Regras de Visibilidade e Shadowing",
                                  "subSteps": [
                                    "Defina visibilidade: símbolo do pai é acessível no filho se não shadowed.",
                                    "Explique shadowing: declaração homônima no filho oculta o do pai.",
                                    "Estude regra de busca: procure no escopo local primeiro, depois suba para pais.",
                                    "Diferencie visibilidade de acessibilidade (ex: private em OOP).",
                                    "Anote exceções em linguagens específicas (ex: Python nonlocal)."
                                  ],
                                  "verification": "Escreva definições curtas para visibilidade, shadowing e busca hierárquica.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Referências de manuais de C++ ou Java sobre escopos",
                                    "Notas de aula sobre compiladores"
                                  ],
                                  "tips": [
                                    "Lembre: shadowing não remove o símbolo pai, só o oculta localmente.",
                                    "Use pseudocódigo para regras."
                                  ],
                                  "learningObjective": "Aplicar regras precisas de visibilidade sem ambiguidades.",
                                  "commonMistakes": [
                                    "Achar que shadowing deleta o símbolo pai.",
                                    "Buscar em escopos irmãos antes do pai."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Simular Busca de Símbolos em Escopos Filhos",
                                  "subSteps": [
                                    "Crie uma tabela de símbolos simulada para 3 escopos aninhados.",
                                    "Simule busca: para um símbolo no filho, cheque local, depois pai, até global.",
                                    "Teste caso sem shadowing: confirme acessibilidade.",
                                    "Teste com shadowing: identifique qual símbolo é usado.",
                                    "Registre o caminho da busca em um log passo a passo."
                                  ],
                                  "verification": "Simule 3 buscas (2 sem shadow, 1 com) e anote resultados corretos.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Planilha Excel ou papel para tabelas",
                                    "Pseudocódigo de simulador de tabela de símbolos"
                                  ],
                                  "tips": [
                                    "Implemente busca como uma pilha: pop local, push pai.",
                                    "Sempre anote 'found in scope X'."
                                  ],
                                  "learningObjective": "Executar simulações precisas de resolução de nomes hierárquicos.",
                                  "commonMistakes": [
                                    "Parar busca após primeiro não-encontrado sem subir.",
                                    "Confundir nomes semelhantes como shadowing."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificar e Aplicar Regras em Cenários Práticos",
                                  "subSteps": [
                                    "Analise código-fonte com escopos aninhados e marque visibilidades.",
                                    "Implemente pseudofunção de verificação: input escopo filho e símbolo, output acessível?.",
                                    "Teste edge cases: escopo vazio, múltiplos pais, shadowing parcial.",
                                    "Compare com comportamento real de um compilador (ex: g++ warnings).",
                                    "Documente um relatório de 3 testes com resultados."
                                  ],
                                  "verification": "Produza pseudocódigo funcional para verificador e teste com 3 exemplos.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Editor de texto para pseudocódigo",
                                    "Compilador online como Godbolt para C++"
                                  ],
                                  "tips": [
                                    "Use recursão na simulação: check_local() then check_parent().",
                                    "Valide com código real."
                                  ],
                                  "learningObjective": "Integrar regras em verificações acionáveis para compiladores.",
                                  "commonMistakes": [
                                    "Ignorar visibilidade em loops ou condicionais.",
                                    "Não tratar símbolos não-declarados (undeclared error)."
                                  ]
                                }
                              ],
                              "practicalExample": "Em C++: int x = 10; { int x = 20; cout << x; } // imprime 20 (shadowing); fora do bloco, x=10 é acessível. Simule tabela: escopo1 (global: x=10), escopo2 (filho: x=20 shadowing). Busca em escopo2 encontra local primeiro.",
                              "finalVerifications": [
                                "Explicar corretamente busca hierárquica em diagrama.",
                                "Identificar shadowing em código fornecido.",
                                "Simular tabela para 4 escopos aninhados sem erros.",
                                "Diferenciar visibilidade de encapsulamento.",
                                "Implementar verificador pseudocódigo que passa em 5 testes.",
                                "Prever erros de compilador em cenários de visibilidade."
                              ],
                              "assessmentCriteria": [
                                "Precisão na simulação de buscas (100% corretas).",
                                "Completude de substeps em cada step (>90% cobertura).",
                                "Correta identificação de shadowing vs. herança.",
                                "Clareza em diagramas e pseudocódigo.",
                                "Tratamento de edge cases sem falhas.",
                                "Tempo respeitado com qualidade alta."
                              ],
                              "crossCurricularConnections": [
                                "Análise Léxica e Sintática em Compiladores.",
                                "Programação Orientada a Objetos (visibilidade de membros).",
                                "Estruturas de Dados (árvores para hierarquias de escopos).",
                                "Lógica e Algoritmos de Busca.",
                                "Design de Linguagens de Programação."
                              ],
                              "realWorldApplication": "Em compiladores como GCC ou Clang, essa regra garante resolução correta de nomes em funções aninhadas ou blocos, evitando erros de 'undeclared identifier' e habilitando otimizações baseadas em escopo."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.3.2.2",
                            "name": "Detectar e tratar shadowing de símbolos",
                            "description": "Identificar casos onde uma declaração no escopo filho oculta um símbolo homônimo no escopo pai, atualizando a visibilidade na tabela de símbolos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o Conceito de Shadowing em Escopos",
                                  "subSteps": [
                                    "Defina shadowing como a ocultação de um símbolo do escopo pai por um homônimo no escopo filho.",
                                    "Analise exemplos simples em linguagens como C ou Python onde variáveis locais sombreiam globais.",
                                    "Diferencie shadowing de redeclaração ilegal (ex.: em escopos não aninhados).",
                                    "Estude a regra de visibilidade: símbolos filhos prevalecem localmente, mas pais são acessíveis via qualificação.",
                                    "Crie um diagrama de escopos aninhados ilustrando o shadowing."
                                  ],
                                  "verification": "Explique em suas palavras o shadowing e desenhe um diagrama correto de um exemplo com 2 níveis de escopo.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Documentação de linguagens (C, Python), papel e caneta para diagramas, editor de texto.",
                                  "tips": "Use setas para mostrar resolução de nomes durante a busca em escopos.",
                                  "learningObjective": "Identificar e explicar o impacto do shadowing na resolução de símbolos.",
                                  "commonMistakes": "Confundir shadowing com captura por referência ou assumir que shadowing é sempre um erro."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar Detecção de Shadowing na Entrada de Símbolos",
                                  "subSteps": [
                                    "Ao inserir um símbolo em um novo escopo, busque no escopo pai por homônimos.",
                                    "Registre o shadowing na tabela de símbolos marcando o novo símbolo como 'shadowing' e linkando ao pai.",
                                    "Implemente em pseudocódigo: função insertSymbol(scope, name) que verifica ancestors.",
                                    "Teste com código fonte simples contendo funções ou blocos aninhados.",
                                    "Registre logs ou flags para cada detecção."
                                  ],
                                  "verification": "Execute pseudocódigo em um exemplo e confirme que detecta shadowing corretamente sem falsos positivos.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Pseudocódigo editor (VS Code), exemplos de código fonte com escopos aninhados.",
                                  "tips": "Use uma pilha de escopos para busca eficiente de ancestrais.",
                                  "learningObjective": "Desenvolver lógica para detectar shadowing durante a fase de declaração.",
                                  "commonMistakes": "Buscar apenas no escopo atual, ignorando chain completo de ancestrais."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Atualizar Visibilidade na Tabela de Símbolos",
                                  "subSteps": [
                                    "Atualize o campo 'visibility' do símbolo filho para 'local_shadowing' e do pai para 'shadowed'.",
                                    "Implemente resolução de nomes que priorize escopos filhos durante lookup.",
                                    "Adicione metadados como 'shadowedBy' apontando para o filho.",
                                    "Propague atualizações para escopos aninhados se necessário.",
                                    "Gere relatório de shadowing para depuração do compilador."
                                  ],
                                  "verification": "Inspecione a tabela de símbolos gerada e confirme que visibilidades estão corretas em um exemplo complexo.",
                                  "estimatedTime": "75 minutos",
                                  "materials": "Estrutura de dados para tabela de símbolos (JSON ou código), debugger simples.",
                                  "tips": "Mantenha referências bidirecionais para facilitar navegação.",
                                  "learningObjective": "Gerenciar atualizações de visibilidade causadas por shadowing.",
                                  "commonMistakes": "Não atualizar visibilidade do pai, levando a resoluções incorretas em escopos irmãos."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Validar e Testar Tratamento de Shadowing",
                                  "subSteps": [
                                    "Crie suíte de testes: casos sem shadowing, shadowing simples, múltiplos níveis, shadowing em loops.",
                                    "Simule fase de resolução de nomes e verifique acessos corretos.",
                                    "Implemente warnings opcionais para shadowing em compiladores pedagógicos.",
                                    "Compare saída da tabela com expectativa manual.",
                                    "Refatore código baseado em falhas detectadas."
                                  ],
                                  "verification": "Todos os testes passam e a tabela de símbolos reflete shadowing corretamente em 5+ cenários.",
                                  "estimatedTime": "90 minutos",
                                  "materials": "Framework de testes unitários (JUnit ou similar), exemplos de código variados.",
                                  "tips": "Comece com casos edge como shadowing recursivo em funções.",
                                  "learningObjective": "Garantir robustez do tratamento de shadowing via testes.",
                                  "commonMistakes": "Ignorar shadowing em escopos dinâmicos ou condicionais."
                                }
                              ],
                              "practicalExample": "Em C: int x = 1; { int x = 2; printf(\"%d\", x); } // Imprime 2, x global shadowed. Na tabela: escopo global x.visibility='shadowed', escopo local x.visibility='local_shadowing, shadowedBy=local_x'.",
                              "finalVerifications": [
                                "Tabela de símbolos marca corretamente símbolos shadowed.",
                                "Resolução de nomes ignora shadowed em escopos filhos.",
                                "Logs ou warnings são gerados para shadowings detectados.",
                                "Testes com múltiplos níveis de aninhamento passam.",
                                "Nenhum falso shadowing em escopos não relacionados.",
                                "Metadados de shadowing são precisos e navegáveis."
                              ],
                              "assessmentCriteria": [
                                "Precisão na detecção: 100% dos shadowings identificados.",
                                "Atualização de visibilidade: Campos corretos em todos símbolos afetados.",
                                "Eficiência: Busca O(n) em profundidade de escopos.",
                                "Robustez: Lida com 10+ casos edge sem crashes.",
                                "Documentação: Explicação clara do processo implementado.",
                                "Testes: Cobertura mínima de 80% dos cenários."
                              ],
                              "crossCurricularConnections": [
                                "Linguagens de Programação: Entender escopos em Python/JS.",
                                "Estruturas de Dados: Uso de árvores ou pilhas para escopos.",
                                "Debugging: Análise de erros de resolução de nomes.",
                                "Design de Linguagens: Decisões sobre shadowing vs. erros."
                              ],
                              "realWorldApplication": "Em compiladores como GCC/Clang, shadowing é tratado para gerar warnings (ex: -Wshadow) e resolver nomes corretamente em código C/C++, evitando bugs sutis em bibliotecas grandes."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.3.2.3",
                            "name": "Definir visibilidade estática vs dinâmica",
                            "description": "Explicar e implementar visibilidade estática (lexical scoping) comum em linguagens como C e Pascal, contrastando com escopos dinâmicos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender Conceitos Fundamentais de Escopo e Visibilidade",
                                  "subSteps": [
                                    "Defina 'escopo' como a região do código onde uma variável é visível e acessível.",
                                    "Explique 'visibilidade' como a capacidade de uma entidade (variável, função) ser referenciada em partes do programa.",
                                    "Diferencie 'tempo de compilação' de 'tempo de execução'.",
                                    "Liste exemplos de blocos de escopo: funções, loops, condicionais.",
                                    "Crie um diagrama simples de tabela de símbolos para um programa com escopos aninhados."
                                  ],
                                  "verification": "Crie um diagrama de escopo para um código simples e explique verbalmente ou por escrito.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Papel e caneta ou ferramenta de diagramação como Draw.io",
                                    "Documentação de linguagens C/Pascal"
                                  ],
                                  "tips": "Use anotações coloridas para diferenciar escopos pai e filho.",
                                  "learningObjective": "Entender os pilares de escopo e visibilidade como base para distinções estáticas/dinâmicas.",
                                  "commonMistakes": [
                                    "Confundir visibilidade com tempo de vida da variável",
                                    "Ignorar escopos aninhados"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Explorar Visibilidade Estática (Lexical Scoping)",
                                  "subSteps": [
                                    "Descreva lexical scoping: resolução de símbolos baseada na estrutura textual do código (tempo de compilação).",
                                    "Analise exemplo em C: variáveis locais em funções aninhadas resolvidas pelo compilador.",
                                    "Implemente um programa C simples com funções internas demonstrando shadowing.",
                                    "Use uma tabela de símbolos para rastrear visibilidade estática em código aninhado.",
                                    "Compare com Pascal: declare procedimentos aninhados e observe resolução lexical."
                                  ],
                                  "verification": "Compile e execute código C/Pascal com shadowing e confirme resolução esperada.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Compilador GCC para C",
                                    "Compilador Free Pascal",
                                    "Editor de código como VS Code"
                                  ],
                                  "tips": "Compile com flags de warning para detectar erros de escopo cedo.",
                                  "learningObjective": "Dominar como lexical scoping resolve símbolos estaticamente.",
                                  "commonMistakes": [
                                    "Assumir resolução em runtime para lexical",
                                    "Esquecer de declarar variáveis no escopo correto"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar Visibilidade Dinâmica (Dynamic Scoping)",
                                  "subSteps": [
                                    "Defina dynamic scoping: resolução baseada na pilha de chamadas em runtime.",
                                    "Estude exemplos em linguagens como Perl ou Emacs Lisp onde escopo segue chamadas de função.",
                                    "Implemente um exemplo simples em Perl demonstrando binding dinâmico.",
                                    "Simule pilha de chamadas para rastrear resolução dinâmica em um cenário aninhado.",
                                    "Discuta desvantagens: imprevisibilidade e dependência de ordem de execução."
                                  ],
                                  "verification": "Execute código Perl/Lisp e altere ordem de chamadas para observar mudanças na resolução.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Perl instalado",
                                    "Emacs com Lisp",
                                    "Documentação oficial de dynamic scoping"
                                  ],
                                  "tips": "Use print statements para rastrear pilha de chamadas durante execução.",
                                  "learningObjective": "Compreender como dynamic scoping difere em runtime.",
                                  "commonMistakes": [
                                    "Confundir com lexical em linguagens híbridas",
                                    "Subestimar impacto no debugging"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Comparar e Implementar Exemplos Contrastantes",
                                  "subSteps": [
                                    "Crie um programa idêntico em C (estático) e Perl (dinâmico) com funções aninhadas.",
                                    "Execute ambos e compare saídas para diferentes ordens de chamada.",
                                    "Construa tabela comparativa: prós/contras de cada abordagem.",
                                    "Discuta implicações em compiladores: tabelas de símbolos para estático vs runtime lookup para dinâmico.",
                                    "Refatore código estático para simular comportamento dinâmico (impossível nativamente)."
                                  ],
                                  "verification": "Apresente relatório com códigos, saídas e tabela comparativa.",
                                  "estimatedTime": "75 minutos",
                                  "materials": [
                                    "Compiladores C/Perl",
                                    "Ferramenta de diff como Meld para comparar saídas"
                                  ],
                                  "tips": "Teste com múltiplas configurações de chamada para destacar diferenças.",
                                  "learningObjective": "Aplicar e contrastar ambos os modelos em implementações práticas.",
                                  "commonMistakes": [
                                    "Usar linguagens erradas para scoping",
                                    "Ignorar efeitos colaterais em dynamic"
                                  ]
                                }
                              ],
                              "practicalExample": "Em C (estático): int x=1; void outer() { int x=2; void inner() { printf(\"%d\", x); } } // imprime 2 (lexical). Em Perl (dinâmico): nossa $x=1; sub outer { minha $x=2; inner(); } sub inner { print $x; } outer(); // pode imprimir 1 se chamado de fora.",
                              "finalVerifications": [
                                "Explicar corretamente a diferença entre lexical e dynamic scoping sem erros.",
                                "Implementar e debugar código C com shadowing lexical.",
                                "Simular resolução dynamic em pseudocódigo ou Perl.",
                                "Construir tabela de símbolos para programa com 3 níveis de escopo.",
                                "Identificar scoping em código desconhecido de linguagens variadas.",
                                "Discutir trade-offs em design de linguagens."
                              ],
                              "assessmentCriteria": [
                                "Precisão conceitual (80% correto em definições).",
                                "Qualidade de implementações de código (compila/executa sem erros).",
                                "Profundidade da comparação (tabela com prós/contras).",
                                "Criatividade em exemplos práticos.",
                                "Capacidade de verificação própria via testes.",
                                "Clareza em diagramas e explicações."
                              ],
                              "crossCurricularConnections": [
                                "Compiladores: Construção de tabelas de símbolos.",
                                "Linguagens de Programação: Design de semântica.",
                                "Debugging: Análise de erros de escopo.",
                                "Teoria da Computação: Modelos de avaliação de expressões."
                              ],
                              "realWorldApplication": "Em compiladores como GCC, visibilidade estática otimiza código e previne erros runtime; dynamic scoping usado em shells/scripts para flexibilidade, mas evitado em apps críticas por imprevisibilidade."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.3.3.3",
                        "name": "Resolução de Símbolos",
                        "description": "Processo de busca por símbolos durante a análise semântica, priorizando escopos locais e subindo na hierarquia até encontrar a declaração apropriada.",
                        "specificSkills": [
                          {
                            "id": "10.1.3.3.3.1",
                            "name": "Implementar busca sequencial em pilha de escopos",
                            "description": "Desenvolver uma função de lookup que inicia no escopo atual e sobe para escopos pais até localizar o símbolo ou reportar undeclared identifier.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Modelar a estrutura de Escopo e Pilha de Escopos",
                                  "subSteps": [
                                    "Defina uma classe ou estrutura para representar um Escopo, contendo um mapa de símbolos (chave: nome, valor: informação do símbolo) e um ponteiro para o escopo pai.",
                                    "Crie uma classe PilhaDeEscopos que gerencie uma lista ou pilha de objetos Escopo.",
                                    "Implemente métodos básicos para empilhar (push) e desempilhar (pop) escopos.",
                                    "Inicialize a pilha com um escopo global (raiz, sem pai).",
                                    "Adicione um método para inserir símbolos em um escopo específico."
                                  ],
                                  "verification": "Verifique se é possível criar uma pilha com escopo global e adicionar um filho sem erros de compilação ou runtime.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Editor de código (VS Code ou similar)",
                                    "Linguagem de programação orientada a objetos (ex: Python, C++, Java)"
                                  ],
                                  "tips": "Use dicionários ou mapas hash para armazenar símbolos por eficiência em lookups locais.",
                                  "learningObjective": "Compreender e implementar a representação hierárquica de escopos em compiladores.",
                                  "commonMistakes": [
                                    "Esquecer de inicializar o ponteiro para o pai como null no escopo raiz.",
                                    "Não diferenciar inserção local de busca global."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar Inserção de Símbolos nos Escopos",
                                  "subSteps": [
                                    "Crie um método insert(symbolName, symbolInfo) que adiciona o símbolo apenas no escopo atual (topo da pilha).",
                                    "Garanta que símbolos com o mesmo nome no escopo atual sobrescrevam anteriores no mesmo escopo.",
                                    "Teste inserção em escopo global e em escopo filho.",
                                    "Adicione validação para evitar inserção de símbolos nulos ou vazios.",
                                    "Documente o método com comentários sobre shadowing (sombreamento de símbolos pais)."
                                  ],
                                  "verification": "Insira símbolos em escopos aninhados e confirme via print ou debug que eles estão no escopo correto.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Editor de código",
                                    "Console para depuração"
                                  ],
                                  "tips": "Sempre insira localmente; a resolução de nomes cuidará da busca em pais.",
                                  "learningObjective": "Dominar a inserção localizada de símbolos em escopos hierárquicos.",
                                  "commonMistakes": [
                                    "Inserir recursivamente em pais, o que quebra o princípio de escopo local.",
                                    "Permitir duplicatas sem aviso."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Desenvolver a Função de Lookup Sequencial",
                                  "subSteps": [
                                    "Crie a função lookup(symbolName) que inicia no escopo atual (topo da pilha).",
                                    "Verifique se o símbolo existe no escopo atual; se sim, retorne suas informações.",
                                    "Se não, avance para o escopo pai e repita até o raiz ou esgotar a pilha.",
                                    "Se não encontrado em nenhum escopo, levante uma exceção ou retorne 'undeclared identifier'.",
                                    "Otimize para evitar loops infinitos (verifique null pai)."
                                  ],
                                  "verification": "Execute lookup em símbolos locais, sombreados e ausentes; confirme retornos corretos.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Editor de código",
                                    "Exemplos de código de teste unitário (pytest ou JUnit)"
                                  ],
                                  "tips": "Use um loop while com currentScope e currentScope.parent até null.",
                                  "learningObjective": "Implementar busca sequencial eficiente em estruturas hierárquicas.",
                                  "commonMistakes": [
                                    "Não parar no escopo raiz, causando NullPointerException.",
                                    "Buscar apenas no topo sem subir a cadeia."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Testar e Integrar a Implementação Completa",
                                  "subSteps": [
                                    "Crie cenários de teste: símbolo local, sombreado, global, inexistente.",
                                    "Simule um programa com blocos aninhados (ex: função dentro de função).",
                                    "Meça performance em pilhas profundas (até 10 escopos).",
                                    "Adicione logs para rastrear a cadeia de busca.",
                                    "Refatore para encapsular em uma classe SymbolTable."
                                  ],
                                  "verification": "Todos os testes passam sem erros ou falsos positivos/negativos.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Framework de testes unitários",
                                    "Gerador de casos de teste aleatórios"
                                  ],
                                  "tips": "Comece com testes simples e adicione complexidade gradualmente.",
                                  "learningObjective": "Validar robustez da resolução de símbolos em compiladores.",
                                  "commonMistakes": [
                                    "Ignorar casos de shadowing.",
                                    "Falhar em pilhas vazias."
                                  ]
                                }
                              ],
                              "practicalExample": "Em Python:\nclass Scope:\n    def __init__(self, parent=None):\n        self.symbols = {}\n        self.parent = parent\n\nclass ScopeStack:\n    def __init__(self):\n        self.scopes = [Scope()]\n    \n    def push(self):\n        self.scopes.append(Scope(self.scopes[-1]))\n    \n    def pop(self):\n        self.scopes.pop()\n    \n    def insert(self, name, info):\n        self.scopes[-1].symbols[name] = info\n    \n    def lookup(self, name):\n        current = self.scopes[-1]\n        while current:\n            if name in current.symbols:\n                return current.symbols[name]\n            current = current.parent\n        raise ValueError('Undeclared identifier: ' + name)\n\nExemplo de uso: stack = ScopeStack(); stack.insert('x', 10); stack.push(); stack.insert('x', 20); print(stack.lookup('x'))  # 20",
                              "finalVerifications": [
                                "A função lookup retorna corretamente símbolos locais sem subir a pilha.",
                                "Símbolos sombreados são resolvidos no escopo mais interno.",
                                "Busca falha graciosamente em símbolos inexistentes com mensagem de erro.",
                                "Performance é linear no número de escopos (O(profundidade da pilha)).",
                                "Pilha vazia ou escopo raiz é tratada corretamente.",
                                "Integração com push/pop não quebra lookups pendentes."
                              ],
                              "assessmentCriteria": [
                                "Correção: Todos os casos de teste passam (local, shadow, global, error).",
                                "Eficiência: Busca sequencial sem buscas desnecessárias.",
                                "Robustez: Tratamento de edge cases (pilha vazia, profundidade alta).",
                                "Clareza: Código legível com comentários e nomes descritivos.",
                                "Extensibilidade: Fácil adicionar novas features como tipos de símbolos.",
                                "Documentação: Exemplos e docstrings presentes."
                              ],
                              "crossCurricularConnections": [
                                "Estruturas de Dados: Pilhas e árvores para hierarquia de escopos.",
                                "Algoritmos: Busca linear e recursão implícita.",
                                "Linguagens de Programação: Conceitos de lexical scoping em Python/JS.",
                                "Engenharia de Software: Design de APIs para tabelas de símbolos.",
                                "Teoria da Computação: Autômatos e análise léxica."
                              ],
                              "realWorldApplication": "Em compiladores reais como GCC ou Clang, para resolver nomes de variáveis em blocos aninhados (ex: { int x; { int x; } }), garantindo shadowing correto; também em interpretadores de JavaScript para closures e linguagens funcionais como Rust."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.3.3.2",
                            "name": "Resolver ambiguidades em referências de símbolos",
                            "description": "Tratar casos de múltiplas declarações com o mesmo nome em escopos diferentes, aplicando regras de resolução lexical mais próxima.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a Hierarquia de Escopos e Tabelas de Símbolos",
                                  "subSteps": [
                                    "Defina escopo como região do código onde declarações são visíveis.",
                                    "Diferencie escopos globais, locais e aninhados.",
                                    "Modele tabelas de símbolos como pilha ou árvore hierárquica.",
                                    "Analise um código-fonte simples para mapear escopos manualmente.",
                                    "Registre símbolos em cada nível de escopo com seus metadados (tipo, posição)."
                                  ],
                                  "verification": "Crie um diagrama de pilha de escopos para um snippet de código com 3 níveis aninhados.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Editor de texto (VS Code)",
                                    "Papel e caneta para diagrama",
                                    "Documentação de sintaxe da linguagem exemplo (ex: C-like)"
                                  ],
                                  "tips": "Visualize escopos como uma pilha: novo escopo empilha sobre o anterior.",
                                  "learningObjective": "Representar corretamente a estrutura hierárquica de escopos e símbolos.",
                                  "commonMistakes": [
                                    "Ignorar escopos aninhados profundos",
                                    "Confundir visibilidade global com shadowing local"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar Referências Potencialmente Ambíguas",
                                  "subSteps": [
                                    "Localize todas as referências a símbolos no código-fonte.",
                                    "Para cada referência, busque declarações com o mesmo nome nos escopos ancestrais.",
                                    "Marque referências onde múltiplas declarações (≥2) são encontradas.",
                                    "Classifique ambiguidades como 'shadowing' ou 'colisão de nomes'.",
                                    "Documente o caminho de busca lexical da referência até a raiz."
                                  ],
                                  "verification": "Liste todas as referências ambíguas em um código de teste com pelo menos 2 casos.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Código-fonte de exemplo com ambiguidades",
                                    "Ferramenta de parsing simples ou regex para localizar referências"
                                  ],
                                  "tips": "Comece a busca do escopo mais interno para fora (regra lexical).",
                                  "learningObjective": "Detectar sistematicamente referências ambíguas usando busca em escopos.",
                                  "commonMistakes": [
                                    "Parar na primeira declaração encontrada",
                                    "Não considerar shadowing em funções aninhadas"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Aplicar Regra de Resolução Lexical Mais Próxima",
                                  "subSteps": [
                                    "Implemente algoritmo de resolução: selecione símbolo do escopo mais próximo (innermost).",
                                    "Para cada referência ambígua, priorize declaração no escopo atual ou pai imediato.",
                                    "Substitua referências por ponteiros para o símbolo resolvido na tabela.",
                                    "Trate casos especiais: imports, herança ou namespaces se aplicável.",
                                    "Teste resolução em código com print de escopo selecionado."
                                  ],
                                  "verification": "Simule resolução em 3 exemplos e confirme que usa escopo mais próximo.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Pseudocódigo ou implementação em Python para tabela de símbolos",
                                    "Exemplos de código com ambiguidades resolvidas"
                                  ],
                                  "tips": "Use uma pilha de dicionários para simular tabelas de símbolos eficientemente.",
                                  "learningObjective": "Resolver ambiguidades aplicando corretamente a regra 'mais próxima lexical'.",
                                  "commonMistakes": [
                                    "Selecionar escopo global por engano",
                                    "Ignorar declarações em blocos condicionais"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Validar e Testar a Resolução de Símbolos",
                                  "subSteps": [
                                    "Compile ou interprete o código pós-resolução para erros semânticos.",
                                    "Crie casos de teste unitários para verificação de resolução.",
                                    "Compare resolução manual vs algorítmica.",
                                    "Analise performance: tempo de busca O(1) por hash em escopos.",
                                    "Documente relatório de resolução com mapeamentos finais."
                                  ],
                                  "verification": "Execute testes em 5 cenários variados sem erros de resolução.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Interpretador simples ou compilador toy",
                                    "Suite de testes com casos edge"
                                  ],
                                  "tips": "Automatize testes com asserts para símbolos resolvidos.",
                                  "learningObjective": "Validar robustez da resolução em cenários reais e edge cases.",
                                  "commonMistakes": [
                                    "Não testar casos de escopo vazio",
                                    "Sobrecarregar tabelas com buscas lineares"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Refinar e Otimizar Gerenciamento de Ambiguidades",
                                  "subSteps": [
                                    "Implemente cache de resoluções para referências repetidas.",
                                    "Adicione suporte a regras avançadas: qualified names ou aliases.",
                                    "Analise código legado para refatorações de ambiguidades.",
                                    "Gere warnings para programadores sobre shadowings potenciais.",
                                    "Integre com passes de otimização do compilador."
                                  ],
                                  "verification": "Otimize um exemplo grande e meça redução de tempo de resolução.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Profiler simples para medir buscas",
                                    "Código de exemplo complexo"
                                  ],
                                  "tips": "Use símbolos únicos internamente para evitar colisões.",
                                  "learningObjective": "Otimizar e estender resolução para cenários de produção.",
                                  "commonMistakes": [
                                    "Cache inválido após mudanças de escopo",
                                    "Ignorar regras de linguagem específicas"
                                  ]
                                }
                              ],
                              "practicalExample": "Considere este código C-like: int x = 1; // global void foo() { int x = 2; // local if (true) { int x = 3; // nested print(x); // Resolve para x=3 (escopo mais próximo) } } A resolução deve selecionar x do escopo if, ignorando os outer.",
                              "finalVerifications": [
                                "Explicar por que 'print(x)' resolve para 3, não 1 ou 2.",
                                "Desenhar pilha de escopos com setas para resolução correta.",
                                "Implementar função resolve_symbol(escopo, nome) que retorna o correto.",
                                "Testar com código onde remoção de shadowing muda comportamento.",
                                "Gerar relatório de todas resoluções em um módulo completo."
                              ],
                              "assessmentCriteria": [
                                "Precisão: 100% das ambiguidades resolvidas corretamente.",
                                "Eficiência: Busca em escopos < profundidade média de 5.",
                                "Robustez: Lida com 10+ níveis aninhados sem stack overflow.",
                                "Clareza: Diagrama e código legíveis com comentários.",
                                "Cobertura: Testa shadowing, globals e edge cases."
                              ],
                              "crossCurricularConnections": [
                                "Lógica e Teoria de Grafos: Escopos como árvore de busca.",
                                "Estruturas de Dados: Pilhas e HashMaps para tabelas de símbolos.",
                                "Linguagens Naturais: Resolução de anáforas ambíguas em NLP.",
                                "Design de Software: Namespacing em APIs modernas (ex: Python modules).",
                                "Matemática Discreta: Funções de mapeamento injetiva para nomes únicos."
                              ],
                              "realWorldApplication": "Em compiladores como GCC/Clang para C++, resolve nomes em funções aninhadas ou lambdas, prevenindo erros semânticos; IDEs como VS Code usam para autocompletar e refatoração precisa em projetos grandes."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.3.3.3",
                            "name": "Gerenciar saída de escopo e remoção de símbolos locais",
                            "description": "Ao final de um bloco ou função, remover ou desempilhar a tabela de símbolos local, restaurando visibilidade dos símbolos do escopo pai.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Identificar pontos de saída de escopo no código fonte",
                                  "subSteps": [
                                    "Analise a estrutura sintática do código para detectar fechamentos de blocos ou funções (ex: '}' ou 'end')",
                                    "Mantenha um stack de escopos durante a análise sintática ou semântica",
                                    "Registre o contexto atual do escopo (local vs. pai) ao encontrar o token de saída",
                                    "Atualize o contador de escopos aninhados para confirmar saída",
                                    "Prepare metadados da tabela local para remoção futura"
                                  ],
                                  "verification": "Confirme que o parser detecta corretamente o fim do escopo e empurra/popa o stack apropriadamente via logs ou breakpoints",
                                  "estimatedTime": "20-30 minutos",
                                  "materials": [
                                    "Parser AST implementado",
                                    "Stack de escopos básico",
                                    "Exemplos de código com blocos aninhados"
                                  ],
                                  "tips": "Use recursão no parser para rastrear escopos aninhados; teste com blocos vazios primeiro.",
                                  "learningObjective": "Compreender como o parser sintático sinaliza transições de escopo.",
                                  "commonMistakes": [
                                    "Ignorar escopos vazios",
                                    "Confundir chaves de objetos com blocos",
                                    "Não sincronizar stack com árvore sintática"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Desempilhar a tabela de símbolos local",
                                  "subSteps": [
                                    "Ao detectar saída de escopo, acesse o topo do stack de tabelas de símbolos",
                                    "Salve referências aos símbolos locais para limpeza (se necessário para debugging)",
                                    "Pop a tabela local do stack, liberando memória associada",
                                    "Registre estatísticas de símbolos removidos para otimização",
                                    "Trate exceções como escopos vazios ou stack underflow"
                                  ],
                                  "verification": "Verifique o stack pós-pop: tamanho reduzido em 1 e ausência de símbolos locais via inspeção de memória ou dump",
                                  "estimatedTime": "25-35 minutos",
                                  "materials": [
                                    "Implementação de stack de tabelas (hash maps ou árvores)",
                                    "Ferramentas de profiling de memória",
                                    "Código de teste com funções simples"
                                  ],
                                  "tips": "Implemente tabelas como objetos leves para pop eficiente; use weak references se aplicável.",
                                  "learningObjective": "Dominar operações de stack em estruturas de dados para gerenciamento dinâmico.",
                                  "commonMistakes": [
                                    "Vazamento de memória ao não liberar entradas",
                                    "Pop incorreto em escopos condicionais",
                                    "Não limpar caches de lookup"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Restaurar visibilidade e lookup do escopo pai",
                                  "subSteps": [
                                    "Após pop, defina a tabela do escopo pai como atual (topo do stack)",
                                    "Atualize o resolvedor de símbolos para priorizar o escopo pai em buscas",
                                    "Teste lookup de símbolos do pai para confirmar visibilidade restaurada",
                                    "Propague mudanças de visibilidade para fases subsequentes (ex: codegen)",
                                    "Valide que símbolos locais não sejam mais acessíveis"
                                  ],
                                  "verification": "Execute lookup de símbolo pai: deve resolver corretamente; símbolo local: deve falhar com erro de 'não encontrado'",
                                  "estimatedTime": "20-30 minutos",
                                  "materials": [
                                    "Resolvedor de símbolos funcional",
                                    "Suite de testes unitários para lookup",
                                    "AST com anotações de escopo"
                                  ],
                                  "tips": "Mantenha profundidade de escopo em cada tabela para debugging hierárquico.",
                                  "learningObjective": "Entender restauração de namespaces em ambientes hierárquicos.",
                                  "commonMistakes": [
                                    "Lookup ainda acessando tabela popada",
                                    "Não atualizar ponteiros de contexto global",
                                    "Falha em escopos com herança"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Testar e depurar o gerenciamento completo de escopo",
                                  "subSteps": [
                                    "Compile código com múltiplos escopos aninhados e verifique stack final vazio",
                                    "Inspecione dumps de tabelas em pontos de saída para confirmação",
                                    "Execute casos de borda: escopos vazios, recursão, erros de sintaxe",
                                    "Meça performance: tempo de pop e lookup pós-restauração",
                                    "Integre com próxima fase do compilador e valide end-to-end"
                                  ],
                                  "verification": "Todos testes passam: sem vazamentos, lookups corretos, stack limpo ao fim da compilação",
                                  "estimatedTime": "30-45 minutos",
                                  "materials": [
                                    "Framework de testes (ex: unittest ou pytest)",
                                    "Profiler (ex: Valgrind para C++)",
                                    "Códigos de teste complexos"
                                  ],
                                  "tips": "Automatize dumps de stack em asserts para depuração rápida.",
                                  "learningObjective": "Aplicar testes abrangentes para robustez em compiladores.",
                                  "commonMistakes": [
                                    "Testes insuficientes para recursão profunda",
                                    "Ignorar overhead de memória em pops frequentes",
                                    "Não testar interações com otimização"
                                  ]
                                }
                              ],
                              "practicalExample": "Em uma função como `function foo() { var x = 1; if(true) { var y = 2; } /* aqui, ao sair do if, pop tabela de y; ao fim da foo, pop tabela de x, restaurando escopo global */ }`, o compilador detecta '}' do if, pops y, restaura visibilidade de x; depois pops x ao fim da função.",
                              "finalVerifications": [
                                "Stack de escopos está vazio ou no escopo correto ao fim da compilação",
                                "Símbolos locais não são acessíveis após saída de escopo",
                                "Lookups no escopo pai resolvem corretamente pós-restauração",
                                "Nenhum vazamento de memória detectado em profiling",
                                "Compilação end-to-end sem erros de símbolo indefinido",
                                "Performance de gerenciamento de escopo dentro de limites esperados"
                              ],
                              "assessmentCriteria": [
                                "Precisão na detecção e pop de escopos (100% acerto em testes)",
                                "Eficiência: O(1) tempo médio para pop e restauração",
                                "Robustez: Trata casos de borda sem crashes",
                                "Integração: Funciona seamless com fases anterior/posterior do compilador",
                                "Documentação: Código comentado com fluxos de escopo",
                                "Test coverage >90% para gerenciamento de escopo"
                              ],
                              "crossCurricularConnections": [
                                "Estruturas de Dados: Uso de stacks para hierarquias",
                                "Algoritmos: Resolvedores com fallback recursivo",
                                "Engenharia de Software: Gerenciamento de estado em parsers",
                                "Matemática: Teoria de grafos para dependências de símbolos"
                              ],
                              "realWorldApplication": "Em compiladores como GCC ou Clang, isso garante que variáveis locais em funções ou loops não poluam o escopo global, prevenindo erros em apps grandes como navegadores ou sistemas operacionais, otimizando memória e evitando conflitos de nomes."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.3.3.4",
                            "name": "Tratar erros de resolução de símbolos",
                            "description": "Implementar detecção e relatório de erros como 'undeclared variable' ou 'out of scope', com sugestões baseadas na hierarquia de escopos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os tipos de erros de resolução de símbolos",
                                  "subSteps": [
                                    "Estude a hierarquia de escopos em compiladores (global, função, bloco).",
                                    "Identifique erros comuns: 'undeclared variable', 'out of scope', 'redeclaration'.",
                                    "Analise exemplos de código fonte com esses erros em linguagens como C ou uma mini-linguagem.",
                                    "Mapeie cada erro à fase de resolução de símbolos na tabela de símbolos.",
                                    "Crie um fluxograma da detecção de erros durante a busca por símbolos."
                                  ],
                                  "verification": "Crie um documento listando 5 tipos de erros com exemplos de código e fluxogramas; revise com um colega.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Documentação de compiladores (Dragon Book capítulo 5)",
                                    "Exemplos de código em C ou Java",
                                    "Ferramenta de fluxograma como Draw.io"
                                  ],
                                  "tips": "Comece com erros simples como undeclared antes de hierarquias complexas.",
                                  "learningObjective": "Dominar os conceitos fundamentais de erros de resolução de símbolos e sua relação com escopos.",
                                  "commonMistakes": [
                                    "Confundir 'out of scope' com 'undeclared'",
                                    "Ignorar redeclarações em escopos aninhados"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar detecção de erros no resolvedor de símbolos",
                                  "subSteps": [
                                    "Modifique a função de lookup na tabela de símbolos para retornar um status de erro.",
                                    "Adicione flags para detectar ausência de símbolo (undeclared) ou falha em escopos visíveis (out of scope).",
                                    "Integre com a pilha de escopos para percorrer hierarquias durante a busca.",
                                    "Registre o contexto do erro (linha, coluna, nome do símbolo).",
                                    "Teste unitário com casos de undeclared em escopo global."
                                  ],
                                  "verification": "Execute testes unitários que falhem sem detecção e passem com ela implementada.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Código base de resolvedor de símbolos",
                                    "Framework de testes como JUnit ou pytest",
                                    "Editor de código com debugger"
                                  ],
                                  "tips": "Use enums para tipos de erro para facilitar extensões futuras.",
                                  "learningObjective": "Capacitar o resolvedor a detectar erros proativamente durante a resolução.",
                                  "commonMistakes": [
                                    "Não percorrer todos os escopos pai",
                                    "Retornar erro prematuro sem busca completa"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Desenvolver sistema de relatório de erros com mensagens claras",
                                  "subSteps": [
                                    "Crie uma classe ou estrutura para objetos de erro contendo tipo, posição e símbolo.",
                                    "Implemente um formatter para mensagens como 'Undeclared variable 'x' at line 5'.",
                                    "Colete erros em uma lista durante a compilação sem interromper o processo.",
                                    "Adicione suporte a múltiplos erros por símbolo (ex: múltiplas ocorrências out of scope).",
                                    "Teste relatório com código contendo vários erros."
                                  ],
                                  "verification": "Compile um código com 3 erros e verifique se o relatório lista todos corretamente.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Código do resolvedor do step 2",
                                    "Exemplos de mensagens de erro de GCC/Clang"
                                  ],
                                  "tips": "Mantenha mensagens concisas mas informativas para melhor UX.",
                                  "learningObjective": "Gerar relatórios de erros legíveis e úteis para desenvolvedores.",
                                  "commonMistakes": [
                                    "Interromper compilação no primeiro erro",
                                    "Mensagens vagas sem posição ou nome"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Adicionar sugestões de correção baseadas na hierarquia de escopos",
                                  "subSteps": [
                                    "Durante a busca falha, colete símbolos similares em escopos vizinhos.",
                                    "Para out of scope, sugira 'Declare 'x' no escopo atual ou use escopo pai'.",
                                    "Para undeclared, liste símbolos próximos: 'Did you mean 'y'?'.",
                                    "Integre sugestões ao relatório de erros.",
                                    "Avalie precisão com testes de similaridade de nomes."
                                  ],
                                  "verification": "Gere relatório para código com erro e confirme presença de sugestões relevantes.",
                                  "estimatedTime": "2.5 horas",
                                  "materials": [
                                    "Biblioteca de similaridade de strings (Levenshtein)",
                                    "Código dos steps anteriores"
                                  ],
                                  "tips": "Limite sugestões a 3 para evitar sobrecarga.",
                                  "learningObjective": "Fornecer feedback acionável melhorando a experiência de debugging.",
                                  "commonMistakes": [
                                    "Sugestões irrelevantes por falta de contexto de escopo",
                                    "Sugestões muito genéricas"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Integrar, testar e refinar o tratamento de erros",
                                  "subSteps": [
                                    "Integre todo o sistema em um mini-compilador.",
                                    "Crie suíte de testes com 20 casos: 10 sucesso, 10 erros variados.",
                                    "Meça cobertura de detecção e precisão de sugestões.",
                                    "Refine baseado em falhas nos testes.",
                                    "Documente o API de erros para uso futuro."
                                  ],
                                  "verification": "Taxa de acerto >95% em suíte de testes; relatório sem falsos positivos.",
                                  "estimatedTime": "3 horas",
                                  "materials": [
                                    "Mini-compilador base",
                                    "Ferramentas de coverage como gcov"
                                  ],
                                  "tips": "Priorize testes edge-case como escopos vazios ou nomes duplicados.",
                                  "learningObjective": "Validar e otimizar o sistema completo de tratamento de erros.",
                                  "commonMistakes": [
                                    "Testes insuficientes para escopos profundos",
                                    "Ignorar performance em grandes hierarquias"
                                  ]
                                }
                              ],
                              "practicalExample": "Em uma mini-linguagem 'MiniLang', código 'x = 1; func() { y = 2; } print(y);' gera erros: 'Undeclared 'y' at line 3 (did you mean declare in global?)' e 'Out of scope 'y' in print (declared in func)'. O resolvedor busca escopos, falha, coleta sugestões de 'x' similar.",
                              "finalVerifications": [
                                "Lista e explica 5 tipos de erros de resolução com exemplos.",
                                "Implementa detecção em resolvedor com >90% cobertura de testes.",
                                "Gera relatórios com posição, tipo e sugestões para 10 casos.",
                                "Integra sistema sem quebrar resolução de símbolos válidos.",
                                "Documenta fluxos de erro em fluxograma.",
                                "Compara com erros reais de GCC em códigos C simples."
                              ],
                              "assessmentCriteria": [
                                "Precisão na detecção (sem falsos positivos/negativos).",
                                "Clareza e utilidade das mensagens e sugestões.",
                                "Eficiência na busca de escopos (O(n) onde n=profundidade).",
                                "Cobertura de testes (>85%).",
                                "Extensibilidade para novos tipos de erro.",
                                "Integração seamless com pipeline de compilação."
                              ],
                              "crossCurricularConnections": [
                                "Debugging e linting em linguagens de programação (ex: ESLint).",
                                "Análise semântica em Processamento de Linguagem Natural (NLP).",
                                "Gerenciamento de namespaces em Python/Java.",
                                "Design de sistemas de exceções em software engineering.",
                                "Lógica formal e prova de propriedades em ciência da computação teórica."
                              ],
                              "realWorldApplication": "Em compiladores profissionais como GCC/Clang ou Rustc, onde detecção precisa de erros de símbolos acelera desenvolvimento; em IDEs como VS Code para autocompletar e sugestões em tempo real; linters empresariais reduzem tempo de debug em 30-50%."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.3.4",
                    "name": "Atributos dos Símbolos",
                    "description": "Informações armazenadas como tipo, escopo, endereço de memória e atributos léxicos.",
                    "individualConcepts": [
                      {
                        "id": "10.1.3.4.1",
                        "name": "Atributos de Tipo",
                        "description": "Informações sobre o tipo de dado associado ao símbolo, como inteiro, real, string ou estrutura composta, incluindo tamanho e compatibilidade para verificações semânticas.",
                        "specificSkills": [
                          {
                            "id": "10.1.3.4.1.1",
                            "name": "Identificar atributos de tipo em tabelas de símbolos",
                            "description": "Reconhecer e listar os atributos de tipo armazenados para símbolos, como 'int', 'float', 'char' e tipos derivados, explicando seu impacto na análise semântica.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os Conceitos Básicos de Tabelas de Símbolos e Atributos de Tipo",
                                  "subSteps": [
                                    "Estude a definição de tabela de símbolos em compiladores: uma estrutura de dados que armazena informações sobre identificadores.",
                                    "Identifique os tipos de atributos armazenados: nome, escopo, tipo, entre outros.",
                                    "Revise o papel específico dos atributos de tipo na fase de análise semântica.",
                                    "Anote exemplos de tipos básicos: int, float, char, bool.",
                                    "Diferencie tipos básicos de derivados (arrays, ponteiros, funções)."
                                  ],
                                  "verification": "Crie um mapa mental ou lista resumindo os conceitos chave e atributos de tipo.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Documentação de compiladores (ex: Dragon Book capítulo sobre tabelas de símbolos)",
                                    "Diagrama de tabela de símbolos em PDF ou imagem"
                                  ],
                                  "tips": "Use analogias como 'atributos de tipo são como etiquetas de bagagem que definem o conteúdo'.",
                                  "learningObjective": "Entender o propósito e estrutura dos atributos de tipo em tabelas de símbolos.",
                                  "commonMistakes": [
                                    "Confundir atributos de tipo com atributos de escopo",
                                    "Ignorar tipos derivados como arrays"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Reconhecer e Classificar Tipos de Dados em Tabelas de Símbolos",
                                  "subSteps": [
                                    "Liste tipos básicos comuns: int (inteiro), float (ponto flutuante), char (caractere), bool (booleano).",
                                    "Estude tipos derivados: array[int], pointer to float, function returning char.",
                                    "Pratique identificando notações de tipos em pseudocódigo ou linguagens como C.",
                                    "Crie uma tabela comparativa de tipos básicos vs. derivados com exemplos.",
                                    "Analise como tipos compostos são representados (ex: struct com múltiplos tipos)."
                                  ],
                                  "verification": "Classifique 10 exemplos de tipos em uma lista de exercícios e confira com uma chave de respostas.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Lista de 20 exemplos de tipos de dados impressa ou digital",
                                    "Editor de texto para tabelas"
                                  ],
                                  "tips": "Lembre-se: tipos derivados herdam ou combinam básicos; busque padrões como [] para arrays.",
                                  "learningObjective": "Classificar corretamente tipos básicos e derivados em contextos de tabelas de símbolos.",
                                  "commonMistakes": [
                                    "Classificar ponteiros como tipos básicos",
                                    "Confundir char com string"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Praticar a Identificação e Listagem de Atributos de Tipo em Tabelas Exemplo",
                                  "subSteps": [
                                    "Examine uma tabela de símbolos exemplo com 5-10 entradas.",
                                    "Extraia e liste apenas os atributos de tipo para cada símbolo.",
                                    "Registre tipos como 'int', 'float[10]', 'char*'.",
                                    "Repita com uma segunda tabela mais complexa incluindo funções e structs.",
                                    "Compare sua listagem com a versão anotada da tabela."
                                  ],
                                  "verification": "Gere uma listagem completa de atributos de tipo para duas tabelas exemplo sem erros.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Exemplos de tabelas de símbolos em imagem ou JSON (2-3 amostras)",
                                    "Planilha ou papel para listagem"
                                  ],
                                  "tips": "Procure colunas específicas nomeadas 'type' ou 'data_type' na tabela.",
                                  "learningObjective": "Extrair e listar atributos de tipo de tabelas de símbolos reais.",
                                  "commonMistakes": [
                                    "Omitir qualificadores como const ou volatile",
                                    "Listar nomes de símbolos em vez de tipos"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar o Impacto dos Atributos de Tipo na Análise Semântica",
                                  "subSteps": [
                                    "Explique como atributos de tipo detectam erros semânticos (ex: soma int + char).",
                                    "Simule cenários: incompatibilidade de tipos em atribuições ou chamadas de função.",
                                    "Discuta verificações: promoção de tipos, coerção implícita.",
                                    "Crie um fluxograma de como o compilador usa tipos na análise semântica.",
                                    "Resuma o impacto em otimização de código."
                                  ],
                                  "verification": "Escreva 3 parágrafos explicando impactos com exemplos de erros semânticos.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Pseudocódigo com erros semânticos",
                                    "Ferramenta de desenho de fluxogramas online"
                                  ],
                                  "tips": "Pense em tipos como 'contratos' que o código deve respeitar.",
                                  "learningObjective": "Explicar o papel dos atributos de tipo na detecção de erros semânticos.",
                                  "commonMistakes": [
                                    "Confundir análise semântica com sintática",
                                    "Subestimar tipos derivados em verificações"
                                  ]
                                }
                              ],
                              "practicalExample": "Considere o programa: int x; float y[5]; char* z; Tabela de símbolos: {x: {type: 'int'}, y: {type: 'float[5]'}, z: {type: 'char*'}}. Identifique: x='int', y='float[5]', z='char*'. Isso permite análise semântica para verificar x = y; (erro de tipo).",
                              "finalVerifications": [
                                "Liste corretamente atributos de tipo de uma tabela com 10 símbolos mistos.",
                                "Identifique 5 erros semânticos baseados em incompatibilidades de tipo.",
                                "Explique diferença entre tipo básico e derivado com 3 exemplos.",
                                "Crie uma tabela de símbolos simples com tipos corretos.",
                                "Simule análise semântica em um trecho de código curto."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de tipos básicos e derivados (90%+ acerto).",
                                "Explicação clara do impacto na análise semântica com exemplos.",
                                "Listagens completas e formatadas sem omissões.",
                                "Uso correto de terminologia (ex: 'atributo de tipo', 'análise semântica').",
                                "Profundidade nas substeps e verificações pessoais.",
                                "Conexão lógica entre steps e conceitos globais."
                              ],
                              "crossCurricularConnections": [
                                "Programação: Verificação de tipos em linguagens como C/Python.",
                                "Análise de Dados: Tipos de colunas em DataFrames (Pandas).",
                                "Lógica e Matemática: Inferência de tipos em expressões algébricas.",
                                "Engenharia de Software: Modelagem de dados em UML com tipos."
                              ],
                              "realWorldApplication": "Em IDEs como VS Code ou compiladores GCC, atributos de tipo em tabelas de símbolos habilitam autocompletar, detecção de erros em tempo real e otimização de código, essencial para desenvolvimento de software escalável e livre de bugs semânticos."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.4.1.2",
                            "name": "Armazenar e recuperar atributos de tipo",
                            "description": "Implementar operações de inserção e busca de atributos de tipo em uma tabela de símbolos, considerando herança de tipos e resolução de ambiguidades.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a estrutura da tabela de símbolos para atributos de tipo",
                                  "subSteps": [
                                    "Estude o conceito de tabela de símbolos em compiladores e seu papel na análise semântica.",
                                    "Identifique os campos necessários para atributos de tipo: nome do tipo, escopo, herança e propriedades como tamanho e compatibilidade.",
                                    "Analise exemplos de herança de tipos, como classes derivadas em linguagens orientadas a objetos.",
                                    "Desenhe um diagrama da estrutura de dados para a tabela (ex: árvore ou hash map com ponteiros para pais).",
                                    "Revise ambiguidades comuns, como sobrecarga de tipos ou shadowing em escopos aninhados."
                                  ],
                                  "verification": "Crie um diagrama da estrutura e explique verbalmente ou por escrito como ela lida com herança.",
                                  "estimatedTime": "1 hora",
                                  "materials": "Livro 'Compilers: Principles, Techniques, and Tools' (Dragon Book), editor de diagramas como Draw.io, notebook.",
                                  "tips": "Use representações gráficas para visualizar herança como árvores.",
                                  "learningObjective": "Entender como atributos de tipo são organizados considerando herança e escopos.",
                                  "commonMistakes": "Ignorar escopos aninhados ou não considerar ponteiros para tipos pais na herança."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar operação de inserção de atributos de tipo",
                                  "subSteps": [
                                    "Defina a estrutura de dados em código (ex: classe SymbolTable com mapa de strings para TypeAttributes).",
                                    "Implemente função insert(symbolName, typeAttr) que verifica duplicatas no escopo atual.",
                                    "Adicione suporte a herança: ao inserir, linke ao tipo pai se aplicável.",
                                    "Trate resolução de ambiguidades: priorize escopo local sobre herdado.",
                                    "Teste inserções em escopos múltiplos com herança simulada."
                                  ],
                                  "verification": "Execute inserções de teste e imprima a tabela para confirmar estrutura correta.",
                                  "estimatedTime": "2 horas",
                                  "materials": "Editor de código (VS Code ou PyCharm), linguagem Python ou C++, exemplos de código de compiladores open-source.",
                                  "tips": "Use recursão para propagar herança durante inserção.",
                                  "learningObjective": "Desenvolver código para inserir atributos de tipo com suporte a herança.",
                                  "commonMistakes": "Não verificar colisões de nomes ou falhar em linkar herança corretamente."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar operação de busca e recuperação de atributos de tipo",
                                  "subSteps": [
                                    "Crie função lookup(symbolName, scope) que busca no escopo atual e herda de pais se não encontrado.",
                                    "Implemente resolução de ambiguidades: use regras como 'mais específico vence' ou escopo mais próximo.",
                                    "Adicione cache para buscas frequentes em herança profunda.",
                                    "Teste cenários de ambiguidades, como tipos homônimos em hierarquias.",
                                    "Retorne atributos completos, incluindo herdados."
                                  ],
                                  "verification": "Realize buscas em cenários complexos e valide resultados contra expectativas manuais.",
                                  "estimatedTime": "2 horas",
                                  "materials": "Mesmos do step 2, mais ferramenta de debug como gdb ou print statements.",
                                  "tips": "Implemente busca recursiva partindo do escopo atual até raiz.",
                                  "learningObjective": "Capacitar recuperação eficiente de atributos considerando herança e ambiguidades.",
                                  "commonMistakes": "Busca linear ineficiente ou ignorar herança em ambiguidades."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Testar e validar as operações integradas",
                                  "subSteps": [
                                    "Crie suíte de testes unitários para inserção, busca e casos de herança/ambiguidades.",
                                    "Simule um programa fonte simples com declarações de tipos e verifique análise semântica.",
                                    "Meça performance em tabelas grandes (100+ símbolos).",
                                    "Corrija bugs identificados e reteste.",
                                    "Documente limitações e melhorias potenciais."
                                  ],
                                  "verification": "Todas as testes passam com 100% de cobertura e sem vazamentos de memória.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": "Framework de testes (pytest para Python, unittest para C++), valgrind para C++.",
                                  "tips": "Priorize testes edge-case como herança cíclica (detectar e evitar).",
                                  "learningObjective": "Garantir robustez das operações em cenários reais de compiladores.",
                                  "commonMistakes": "Testes insuficientes para ambiguidades ou herança profunda."
                                }
                              ],
                              "practicalExample": "Em Python, crie uma SymbolTable para um mini-compilador: insira 'class Animal { }' e 'class Dog extends Animal { }'. Busque 'Dog' e recupere atributos como 'herda de Animal, tamanho=16 bytes', resolvendo se há um 'Dog' local que sombreia o herdado.",
                              "finalVerifications": [
                                "Inserção de 50 símbolos com herança sem erros ou duplicatas.",
                                "Busca recupera atributos corretos em 100% dos casos de teste, incluindo ambiguidades.",
                                "Tabela mantém integridade após múltiplas operações de escopo push/pop.",
                                "Performance aceitável: busca em O(log n) ou melhor.",
                                "Nenhum vazamento de memória ou ciclo infinito em herança.",
                                "Documentação clara das funções implementadas."
                              ],
                              "assessmentCriteria": [
                                "Correção: Operações lidam perfeitamente com herança e ambiguidades.",
                                "Eficiência: Tempo de busca proporcional ao tamanho da tabela.",
                                "Robustez: Trata erros como tipos inexistentes ou herança inválida.",
                                "Clareza do código: Bem comentado e modular.",
                                "Cobertura de testes: Pelo menos 90% com casos edge.",
                                "Extensibilidade: Fácil adicionar novos tipos de atributos."
                              ],
                              "crossCurricularConnections": [
                                "Programação Orientada a Objetos: Herança de classes e polimorfismo.",
                                "Banco de Dados: Índices e consultas em esquemas relacionais com herança.",
                                "Estruturas de Dados: Árvores e mapas hash para organização hierárquica.",
                                "Análise Semântica: Verificação de tipos em linguagens de programação."
                              ],
                              "realWorldApplication": "Em compiladores como GCC ou Clang, tabelas de símbolos armazenam atributos de tipo para verificação semântica, permitindo detecção de erros como atribuições incompatíveis em hierarquias de classes, essencial para desenvolvimento de software confiável."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.4.1.3",
                            "name": "Verificar compatibilidade de tipos",
                            "description": "Aplicar regras de compatibilidade de tipos durante a análise semântica, usando atributos de tipo para detectar erros como atribuições inválidas.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender Conceitos de Tipos e Regras de Compatibilidade",
                                  "subSteps": [
                                    "Estude os tipos primitivos comuns (int, float, string, bool) e suas hierarquias.",
                                    "Aprenda regras de compatibilidade: subtipagem, promoção implícita (ex: int para float).",
                                    "Analise exemplos de incompatibilidades: atribuição string a int.",
                                    "Revise atribuições de referência vs valor em linguagens tipadas.",
                                    "Documente uma tabela de compatibilidade para 4-5 tipos principais."
                                  ],
                                  "verification": "Crie uma tabela de compatibilidade e teste com 3 exemplos de pares compatíveis/incompatíveis.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Documentação de análise semântica, exemplos de código em C ou Java.",
                                  "tips": "Use diagramas de Venn para visualizar subtipagem.",
                                  "learningObjective": "Identificar e classificar regras de compatibilidade de tipos.",
                                  "commonMistakes": "Confundir promoção implícita com casting explícito."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar Verificação em Atribuições Simples",
                                  "subSteps": [
                                    "No visitor semântico, acesse atributos de tipo da tabela de símbolos para LHS e RHS.",
                                    "Defina função isCompatible(type1, type2) baseada em regras aprendidas.",
                                    "Emita erro semântico se incompatível, com mensagem detalhada.",
                                    "Teste com código fonte: var x: int; x := 'abc';",
                                    "Atualize tabela de símbolos com tipo inferido se compatível."
                                  ],
                                  "verification": "Compile um programa com atribuição inválida e confirme erro reportado.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Código base de analisador semântico, IDE com depurador.",
                                  "tips": "Implemente isCompatible como recursiva para tipos compostos.",
                                  "learningObjective": "Aplicar verificação de tipos em nós de atribuição AST.",
                                  "commonMistakes": "Ignorar tipos void ou nulos na verificação."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Estender para Expressões e Operações Binárias",
                                  "subSteps": [
                                    "Defina regras para operadores: + para numéricos/strings, == para todos.",
                                    "Para cada nó binário, verifique compatibilidade de operandos.",
                                    "Calcule tipo resultante (ex: int + float -> float).",
                                    "Teste expressões mistas: 1 + 2.5; 'a' + 'b';",
                                    "Integre com verificação de atribuição do resultado."
                                  ],
                                  "verification": "Parse e analise expressão incompatível como true + 1, confirmando erro.",
                                  "estimatedTime": "75 minutos",
                                  "materials": "AST walker/visitor pattern código, exemplos de expressões.",
                                  "tips": "Use enums para operadores para switch cases eficientes.",
                                  "learningObjective": "Verificar e inferir tipos em árvores de expressões.",
                                  "commonMistakes": "Não propagar tipos para nós pais na AST."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Testar, Depurar e Integrar na Análise Semântica Completa",
                                  "subSteps": [
                                    "Crie suíte de testes: 5 casos válidos, 5 inválidos de atribuições/expressões.",
                                    "Execute análise semântica completa em programa multi-linha.",
                                    "Depure falsos positivos/negativos ajustando regras.",
                                    "Adicione suporte a casting explícito (ex: (int)3.14).",
                                    "Gere relatório de erros com linha/coluna."
                                  ],
                                  "verification": "100% de acerto na suíte de testes sem falsos erros.",
                                  "estimatedTime": "90 minutos",
                                  "materials": "Ferramentas de teste unitário (JUnit/Pytest), programa de teste fonte.",
                                  "tips": "Log tipos durante análise para depuração visual.",
                                  "learningObjective": "Integrar verificador de tipos em pipeline semântico robusto.",
                                  "commonMistakes": "Esquecer verificação em declarações implícitas."
                                }
                              ],
                              "practicalExample": "Em uma mini-linguagem: 'var x: int; x := 5.0;' -> Detecta incompatibilidade int/float sem cast, emite erro 'Tipo incompatível: float não é atribuível a int na linha 2'. Para 'x := (int)5.0;' -> Sucesso com promoção.",
                              "finalVerifications": [
                                "Analisador detecta e reporta corretamente 5/5 atribuições inválidas.",
                                "Tipos são inferidos precisamente em expressões mistas.",
                                "Nenhum falso positivo em casos compatíveis com promoção.",
                                "Relatórios de erro incluem contexto (linha, tipo esperado vs encontrado).",
                                "Integração sem quebrar outras fases semânticas.",
                                "Suporte a casting explícito funciona sem erros."
                              ],
                              "assessmentCriteria": [
                                "Precisão na detecção de incompatibilidades (90%+ taxa de acerto).",
                                "Eficiência: tempo de análise O(n) para AST de tamanho n.",
                                "Cobertura completa: atribuições, expressões unárias/binárias.",
                                "Mensagens de erro claras e úteis para desenvolvedores.",
                                "Robustez contra tipos compostos ou user-defined.",
                                "Documentação de regras de compatibilidade no código."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria de conjuntos para subtipagem e união de tipos.",
                                "Lógica: Inferência de tipos como resolução de restrições.",
                                "Engenharia de Software: Design de APIs para extensibilidade de tipos."
                              ],
                              "realWorldApplication": "Em compiladores como GCC/Clang para C++, verifica atribuições inválidas em milhões de linhas de código open-source, prevenindo runtime errors; no javac, assegura type-safety em apps Android enterprise."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.3.4.2",
                        "name": "Atributos de Escopo",
                        "description": "Registros que definem o escopo de visibilidade do símbolo, como escopo local, global ou de bloco, para gerenciar declarações e referências em diferentes contextos.",
                        "specificSkills": [
                          {
                            "id": "10.1.3.4.2.1",
                            "name": "Definir e associar escopos a símbolos",
                            "description": "Explicar como atribuir níveis de escopo (global, local, função) aos símbolos e usar pilhas de escopos para resolução de nomes.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os Conceitos Fundamentais de Escopo",
                                  "subSteps": [
                                    "Defina escopo global como o nível raiz acessível em todo o programa.",
                                    "Explique escopo local como variáveis declaradas dentro de blocos ou funções, visíveis apenas ali.",
                                    "Descreva escopo de função como hierarquia onde funções internas herdam do pai mas podem sombrear.",
                                    "Estude exemplos de sombreamento (shadowing) onde nomes locais ocultam globais.",
                                    "Compare com linguagens como C, Python e JavaScript para contextualizar."
                                  ],
                                  "verification": "Crie um diagrama manual de escopos para um código simples com funções aninhadas.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Documentação de linguagens (MDN para JS, Python docs), papel e caneta para diagramas.",
                                  "tips": "Use cores diferentes para representar níveis de escopo no diagrama.",
                                  "learningObjective": "Identificar e diferenciar tipos de escopo (global, local, função) com exemplos precisos.",
                                  "commonMistakes": "Confundir escopo de bloco com escopo de função; ignorar herança de escopos pai."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Representar Símbolos e Seus Escopos em Tabelas",
                                  "subSteps": [
                                    "Crie uma estrutura de tabela de símbolos com campos: nome, tipo, escopoID, posição.",
                                    "Atribua um ID único a cada escopo (ex: 0 para global, 1 para primeira função).",
                                    "Durante parsing, insira símbolos na tabela atual com escopoID do escopo corrente.",
                                    "Implemente uma classe simples em Python para TabelaDeSimbolos com método insert.",
                                    "Teste inserindo símbolos em diferentes escopos simulados."
                                  ],
                                  "verification": "Implemente e rode um código que insere 5 símbolos em escopos variados e imprime a tabela.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Editor de código (VS Code), Python instalado, pseudocódigo de compiladores.",
                                  "tips": "Sempre associe escopoID no momento da declaração, não da referência.",
                                  "learningObjective": "Construir entradas de tabela de símbolos que incluam atributos de escopo corretos.",
                                  "commonMistakes": "Usar escopoID incorreto ao inserir; não diferenciar símbolos com mesmo nome em escopos distintos."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar Pilha de Escopos para Gerenciamento",
                                  "subSteps": [
                                    "Crie uma pilha onde cada frame representa uma tabela de escopo (global no fundo).",
                                    "Implemente push_scope() para adicionar novo frame na pilha ao entrar em função/bloco.",
                                    "Implemente pop_scope() para remover frame ao sair do escopo.",
                                    "Adicione current_scope() para acessar o topo da pilha.",
                                    "Teste com sequência de enters/exits simulando parsing de código."
                                  ],
                                  "verification": "Simule parsing de um programa com 3 funções aninhadas e verifique estados da pilha.",
                                  "estimatedTime": "75 minutos",
                                  "materials": "Editor de código, debugger Python, diagramas de pilha em papel.",
                                  "tips": "Visualize a pilha como uma torre: base global, topo local atual.",
                                  "learningObjective": "Gerenciar dinamicamente escopos usando pilha durante análise semântica.",
                                  "commonMistakes": "Pop prematuro causando perda de escopos; push sem atualizar escopoID dos símbolos."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Realizar Resolução de Nomes Usando a Pilha",
                                  "subSteps": [
                                    "Para uma referência a um símbolo, busque do topo da pilha para baixo (current to global).",
                                    "Implemente lookup(name) que retorna símbolo se encontrado, ou erro se não.",
                                    "Registre o escopo resolvido na tabela para análise posterior.",
                                    "Teste com casos de sombreamento e referências cross-escopo.",
                                    "Integre com tabela de símbolos para validação semântica completa."
                                  ],
                                  "verification": "Parse um código exemplo com referências ambíguas e confirme resoluções corretas.",
                                  "estimatedTime": "90 minutos",
                                  "materials": "Código de exemplo com escopos (fornecido abaixo), testes unitários em Python.",
                                  "tips": "Busca linear na pilha é OK para aprendizado; otimize depois com hashmaps.",
                                  "learningObjective": "Resolver nomes corretamente considerando hierarquia de escopos via pilha.",
                                  "commonMistakes": "Buscar apenas no escopo atual ignorando herança; resolver para símbolo errado em sombreamento."
                                }
                              ],
                              "practicalExample": "Considere o código fictício:\nglobal x = 10;\nfunction A() { local y = 20; function B() { print(x); print(y); } }\n- Ao declarar x: inserir em escopo 0.\n- Entrar A: push escopo 1, inserir y.\n- Entrar B: push escopo 2.\n- print(x): lookup encontra em escopo 0.\n- print(y): lookup encontra em escopo 1 (herdado).",
                              "finalVerifications": [
                                "Explique verbalmente como uma variável local sombreia global.",
                                "Desenhe pilha de escopos para código com 2 funções aninhadas.",
                                "Implemente lookup que falhe corretamente em nome indefinido.",
                                "Identifique erro em tabela onde escopoID está errado.",
                                "Simule resolução para 3 referências em código exemplo.",
                                "Compare com comportamento em Python (globals() vs locals())."
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição e distinção de tipos de escopo (90% correto).",
                                "Implementação funcional de pilha com push/pop/lookup sem bugs.",
                                "Correta associação de escopoID a símbolos em exemplos testados.",
                                "Explicação clara de resolução de nomes com diagrama.",
                                "Tratamento adequado de casos edge como escopo vazio ou sombreamento.",
                                "Eficiência conceitual: tempo de lookup O(profundidade da pilha)."
                              ],
                              "crossCurricularConnections": [
                                "Programação: Entender closures e namespaces em linguagens modernas.",
                                "Matemática: Estruturas de pilha como em teoria de linguagens formais.",
                                "Engenharia de Software: Design de sistemas modulares com encapsulamento.",
                                "Lógica: Resolução de ambiguidades em provas e teoremas."
                              ],
                              "realWorldApplication": "Em compiladores como GCC/Clang, tabelas de símbolos com pilhas de escopo detectam erros de 'undeclared variable' em C++; em IDEs como VS Code, IntelliSense usa isso para autocompletar considerando escopos locais/globais; em JavaScript engines (V8), suporta closures eficientes."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.4.2.2",
                            "name": "Gerenciar aninhamento de escopos",
                            "description": "Implementar entrada e saída de escopos aninhados, criando e destruindo tabelas locais para suportar blocos e funções.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender o Conceito de Escopos Aninhados e Estrutura de Tabelas",
                                  "subSteps": [
                                    "Estude a hierarquia de escopos: escopo global, funções e blocos internos.",
                                    "Defina uma estrutura de dados para tabela de símbolos (ex: hashmap com ponteiro para escopo pai).",
                                    "Implemente uma pilha de escopos para rastrear aninhamento.",
                                    "Desenhe um diagrama de árvore representando escopos aninhados.",
                                    "Revise como símbolos são resolvidos: lookup local primeiro, depois pais."
                                  ],
                                  "verification": "Crie um diagrama manual de escopos aninhados para um código de exemplo e explique a resolução de um símbolo.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Documentação de compiladores (ex: Dragon Book capítulo 2)",
                                    "Papel e caneta para diagramas",
                                    "Editor de código para protótipos"
                                  ],
                                  "tips": "Use uma representação visual como árvore para visualizar melhor o aninhamento.",
                                  "learningObjective": "Compreender a representação hierárquica de escopos em tabelas de símbolos.",
                                  "commonMistakes": [
                                    "Confundir escopo local com global",
                                    "Ignorar ponteiros para escopos pais"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar Entrada em Novo Escopo (Push de Tabela Local)",
                                  "subSteps": [
                                    "Crie uma função 'enterScope()' que aloca uma nova tabela de símbolos.",
                                    "Vincule a nova tabela ao escopo pai atual (ponteiro pai).",
                                    "Empilhe a nova tabela na pilha global de escopos.",
                                    "Teste com declaração de variável no novo escopo.",
                                    "Verifique lookup: deve encontrar símbolos locais antes de pais."
                                  ],
                                  "verification": "Execute código que declara uma variável em um bloco e confirme que ela é acessível localmente mas não no pai.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Linguagem de implementação (ex: C++, Python)",
                                    "Compilador de teste simples",
                                    "Exemplos de código com blocos"
                                  ],
                                  "tips": "Use um contador de escopo único para debug (ex: scopeId).",
                                  "learningObjective": "Implementar criação e ativação de escopo local aninhado.",
                                  "commonMistakes": [
                                    "Não atualizar ponteiro de escopo atual",
                                    "Vazar memória ao alocar tabelas"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar Saída de Escopo (Pop e Destruição de Tabela Local)",
                                  "subSteps": [
                                    "Crie função 'exitScope()' que remove o escopo atual da pilha.",
                                    "Libere memória da tabela local (destruir entradas).",
                                    "Restaure o escopo pai como atual.",
                                    "Teste destruição: símbolos locais devem ficar inacessíveis.",
                                    "Adicione logging para rastrear push/pop durante parsing."
                                  ],
                                  "verification": "Parse um código com blocos aninhados e confirme que após exitScope, lookup resolve no pai corretamente.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Mesmos do step 2",
                                    "Ferramentas de debug (gdb, printfs)",
                                    "Código de teste com funções e blocos"
                                  ],
                                  "tips": "Sempre pop no fim de blocos/funções para evitar vazamentos.",
                                  "learningObjective": "Gerenciar destruição segura de escopos e restauração de contexto pai.",
                                  "commonMistakes": [
                                    "Pop incorreto da pilha",
                                    "Não liberar recursos da tabela"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Integrar e Testar Gerenciamento Completo em um Parser Simples",
                                  "subSteps": [
                                    "Integre push/pop em um parser recursivo para blocos e funções.",
                                    "Teste com código aninhado: função > if > bloco.",
                                    "Implemente resolução de símbolos com lookup recursivo em pais.",
                                    "Adicione tratamento de erros (ex: escopo não encontrado).",
                                    "Execute testes unitários para cenários de aninhamento profundo."
                                  ],
                                  "verification": "Compilar um programa com múltiplos níveis de aninhamento sem erros de símbolo.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Parser simples (ex: para mini-linguagem)",
                                    "Suite de testes automatizados",
                                    "Ferramentas de profiling"
                                  ],
                                  "tips": "Use recursão no parser para naturally mapear a escopos.",
                                  "learningObjective": "Aplicar gerenciamento de escopos em fluxo completo de compilação.",
                                  "commonMistakes": [
                                    "Mismatch de push/pop",
                                    "Lookup infinito em ciclos (raro mas possível)"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um compilador para uma linguagem como C, ao parsear 'void func() { int x=1; { int x=2; } }', push escopo na func, push no bloco interno (x=2 shadowa x=1), pop interno (x=1 visível novamente), pop func.",
                              "finalVerifications": [
                                "Diagrama de escopos para código complexo é correto.",
                                "Parser lida com 5 níveis de aninhamento sem crash.",
                                "Símbolos shadowados resolvem corretamente.",
                                "Memória de tabelas é liberada (valgrind zero leaks).",
                                "Lookup falha graciosamente para símbolos não declarados.",
                                "Logs mostram push/pop balanceados."
                              ],
                              "assessmentCriteria": [
                                "Precisão na criação/destruição de tabelas locais (100% taxa de acerto).",
                                "Correta resolução de símbolos em hierarquia (sem falsos positivos/negativos).",
                                "Eficiência: O(1) lookup médio por símbolo.",
                                "Robustez: Trata aninhamento até 10 níveis.",
                                "Limpeza de código: Sem vazamentos ou bugs de ponteiros.",
                                "Documentação de funções push/pop clara."
                              ],
                              "crossCurricularConnections": [
                                "Programação: Namespaces e closures em linguagens como Python/JavaScript.",
                                "Estruturas de Dados: Pilhas e árvores para hierarquia.",
                                "Matemática: Grafos direcionados acíclicos (DAG) para dependências de escopo.",
                                "Engenharia de Software: Gerenciamento de contexto em threads.",
                                "Lógica: Resolução de escopo como busca em árvore."
                              ],
                              "realWorldApplication": "Em compiladores como GCC ou Clang, gerencia escopos para otimização de código e detecção de erros; essencial para linguagens com blocos léxicos como Rust ou C++."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.4.2.3",
                            "name": "Resolver conflitos de escopo",
                            "description": "Detectar e resolver sombreamento de nomes (shadowing) usando atributos de escopo para priorizar declarações locais sobre globais.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender Conceitos de Escopo e Sombreamento",
                                  "subSteps": [
                                    "Estude a definição de escopo léxico: região do código onde uma declaração é válida.",
                                    "Analise exemplos de escopo global versus escopo local em linguagens como C ou Python.",
                                    "Identifique sombreamento (shadowing): declaração de nome local que oculta um global.",
                                    "Diferencie shadowing de redeclaração ilegal (ex.: em escopos não permitidos).",
                                    "Crie um diagrama mental de hierarquia de escopos (global > função > bloco)."
                                  ],
                                  "verification": "Explique em suas palavras o que é shadowing e forneça um exemplo simples.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Documentação de linguagens (C, Python)",
                                    "Diagramas de escopo online"
                                  ],
                                  "tips": [
                                    "Visualize escopos como pilhas: o mais recente (local) prevalece sobre os mais antigos."
                                  ],
                                  "learningObjective": "Dominar os fundamentos teóricos de escopo e shadowing para detecção posterior.",
                                  "commonMistakes": [
                                    "Confundir shadowing com captura de variáveis em closures.",
                                    "Ignorar que shadowing é geralmente permitido em PLs block-scoped."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Estruturar Tabelas de Símbolos com Atributos de Escopo",
                                  "subSteps": [
                                    "Crie uma tabela de símbolos com campos: nome, tipo, escopoLevel (int), escopoID (string).",
                                    "Implemente uma pilha de escopos para gerenciar tabelas locais e globais.",
                                    "Ao declarar um símbolo, associe o escopo atual (ex.: escopoLevel = profundidade da pilha).",
                                    "Ao entrar em um novo escopo (função/bloco), empilhe uma nova tabela.",
                                    "Ao sair, desempilhe e restaure referências ao escopo pai."
                                  ],
                                  "verification": "Construa uma tabela de símbolos manual para um código simples com 2 níveis de escopo.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Editor de código",
                                    "Pseudo-código de tabela de símbolos"
                                  ],
                                  "tips": [
                                    "Use uma estrutura de dados como hashmap por escopo para buscas O(1)."
                                  ],
                                  "learningObjective": "Representar hierarquias de escopo em estruturas de dados para análise.",
                                  "commonMistakes": [
                                    "Esquecer de propagar referências ao escopo pai na pilha.",
                                    "Não diferenciar escopoLevel de escopoID único."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Detectar Conflitos de Sombreamento",
                                  "subSteps": [
                                    "Durante a análise semântica, busque o símbolo do escopo atual primeiro.",
                                    "Se não encontrado, busque recursivamente nos escopos pais até o global.",
                                    "Ao declarar um novo símbolo, verifique se já existe no escopo atual (shadowing detectado).",
                                    "Registre o conflito: armazene ponteiro para o símbolo global sombreado.",
                                    "Gere um relatório de conflitos com linha/coluna do código fonte."
                                  ],
                                  "verification": "Aplique em um código de exemplo e liste todos os shadowings detectados.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Código fonte de teste com shadowings",
                                    "Ferramenta de parsing simples"
                                  ],
                                  "tips": [
                                    "Busca deve ser depth-first na pilha de escopos para priorizar locais."
                                  ],
                                  "learningObjective": "Implementar detecção precisa de conflitos usando busca hierárquica.",
                                  "commonMistakes": [
                                    "Buscar apenas no global sem verificar locais primeiro.",
                                    "Marcar shadowing como erro em vez de aviso."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Resolver Conflitos Priorizando Declarações Locais",
                                  "subSteps": [
                                    "Ao resolver uma referência, retorne o símbolo do escopo mais interno (maior escopoLevel).",
                                    "Ignore símbolos globais ou pais se houver match local (shadowing resolvido).",
                                    "Atualize atributos: defina 'resolvedTo' como ponteiro para o símbolo local.",
                                    "Valide a resolução gerando código intermediário ou relatório de binding.",
                                    "Teste com casos edge: shadowing em loops, funções aninhadas."
                                  ],
                                  "verification": "Compile um programa com shadowing e confirme que referências locais são priorizadas.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Compilador toy ou simulador de tabela de símbolos",
                                    "Códigos de teste variados"
                                  ],
                                  "tips": [
                                    "Registre o caminho de resolução para depuração futura."
                                  ],
                                  "learningObjective": "Aplicar regras de priorização para binding correto de nomes.",
                                  "commonMistakes": [
                                    "Priorizar globais por engano.",
                                    "Não lidar com shadowings múltiplos em cadeia."
                                  ]
                                }
                              ],
                              "practicalExample": "Considere o código:\nint globalVar = 10;\nvoid func() {\n  int globalVar = 20; // Shadowing detectado\n  print(globalVar); // Resolve para 20 (local)\n  if (true) {\n    int globalVar = 30; // Shadowing interno\n    print(globalVar); // Resolve para 30\n  }\n  print(globalVar); // Volta para 20\n}\nA tabela deve detectar shadowings e priorizar locais em cada referência.",
                              "finalVerifications": [
                                "Detecta corretamente todos os shadowings em um código com 3 níveis de escopo.",
                                "Resolve referências priorizando sempre o escopo local mais interno.",
                                "Gera relatório preciso com posições de conflitos no código fonte.",
                                "Manipula pilha de escopos sem vazamentos (push/pop corretos).",
                                "Testa casos edge como shadowing em loops ou condicionais sem erros.",
                                "Valida binding produzindo saída correta em interpretador simples."
                              ],
                              "assessmentCriteria": [
                                "Precisão na detecção: 100% dos shadowings identificados sem falsos positivos.",
                                "Correção na resolução: Todas as referências bindam ao símbolo correto.",
                                "Eficiência: Buscas em O(1) médio com hashmaps por escopo.",
                                "Robustez: Lida com códigos complexos (aninhamento profundo) sem crashes.",
                                "Documentação: Relatórios claros com escopoLevel e caminhos de resolução.",
                                "Conformidade: Segue regras léxicas padrão de PLs como C/Python."
                              ],
                              "crossCurricularConnections": [
                                "Análise Semântica: Integra com verificação de tipos pós-detecção.",
                                "Design de Linguagens: Compara regras de escopo em PLs funcionais vs imperativas.",
                                "Estruturas de Dados: Aplicação de pilhas e árvores para hierarquias.",
                                "Lógica de Programação: Resolução de ambiguidades como em parsers.",
                                "Depuração de Software: Similar a ferramentas como linters (ex: ESLint)."
                              ],
                              "realWorldApplication": "Em compiladores profissionais como GCC ou Clang, para análise semântica precisa, evitando erros de binding em grandes projetos; em IDEs como VS Code para highlight de shadowings e sugestões de refatoração; otimiza performance ao resolver nomes localmente sem buscas globais desnecessárias."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.3.4.3",
                        "name": "Atributos de Endereço de Memória",
                        "description": "Informações sobre o deslocamento ou endereço alocado para o símbolo na memória, incluindo offsets em frames de ativação para geração de código.",
                        "specificSkills": [
                          {
                            "id": "10.1.3.4.3.1",
                            "name": "Calcular endereços de memória para símbolos",
                            "description": "Determinar offsets de memória baseados no tamanho do tipo e alinhamento, para variáveis locais e globais em tabelas de símbolos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender Conceitos Fundamentais de Tamanhos de Tipos e Alinhamento",
                                  "subSteps": [
                                    "Liste os tamanhos típicos de tipos primitivos em bytes (ex: int=4, char=1, double=8).",
                                    "Explique o conceito de alinhamento de memória: tipos devem começar em endereços múltiplos do seu tamanho ou poder de 2.",
                                    "Calcule o padding necessário para alinhar um tipo após outro (ex: char seguido de int requer 3 bytes de padding).",
                                    "Diferencie alocação estática (globais) de dinâmica (locais no stack).",
                                    "Crie uma tabela simples com tipos, tamanhos e requisitos de alinhamento."
                                  ],
                                  "verification": "Construa uma tabela de 5 tipos com tamanhos e alinhamentos corretos, sem erros de padding.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Papel e caneta ou editor de texto",
                                    "Tabela de tamanhos de tipos de um compilador como GCC"
                                  ],
                                  "tips": "Use potências de 2 para alinhamento (1,2,4,8); lembre que estruturas seguem o alinhamento do maior membro.",
                                  "learningObjective": "Dominar tamanhos de tipos e regras de alinhamento para calcular offsets precisos.",
                                  "commonMistakes": [
                                    "Ignorar padding entre membros",
                                    "Confundir tamanho com alinhamento",
                                    "Assumir tamanhos portáteis sem contexto"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Calcular Endereços para Variáveis Globais",
                                  "subSteps": [
                                    "Inicie o offset global em 0.",
                                    "Para cada símbolo global em ordem de declaração: some o tamanho do tipo anterior, adicione padding para alinhamento.",
                                    "Atualize o offset cumulativo após cada símbolo.",
                                    "Registre o endereço final como offset + base global (geralmente 0).",
                                    "Teste com uma sequência de 3-4 variáveis globais mistas."
                                  ],
                                  "verification": "Calcule offsets para um conjunto de 4 globais e verifique soma total igual ao tamanho esperado da seção .data.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Exemplo de código C com globais",
                                    "Calculadora ou planilha"
                                  ],
                                  "tips": "Sempre arredonde o offset atual para o próximo múltiplo do alinhamento requerido.",
                                  "learningObjective": "Aplicar alocação sequencial com alinhamento para seção de dados globais.",
                                  "commonMistakes": [
                                    "Esquecer de resetar offset para 0",
                                    "Não adicionar padding entre símbolos",
                                    "Usar ordem errada de declaração"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular Endereços para Variáveis Locais",
                                  "subSteps": [
                                    "Inicie o offset local em 0 (ou base do stack frame).",
                                    "Para parâmetros: aloque do final para o início (offsets positivos crescentes).",
                                    "Para variáveis locais: aloque do início para o final (offsets negativos decrescentes do BP).",
                                    "Inclua padding para alinhamento em ambos.",
                                    "Calcule o tamanho total do frame para reserva no prologue.",
                                    "verification]: "
                                  ]
                                }
                              ],
                              "estimatedTime": "40 minutos",
                              "materials": [
                                "Diagrama de stack frame",
                                "Exemplo de função C com locais e params"
                              ],
                              "tips": "Locais crescem para baixo (BP - offset); params crescem para cima (BP + offset).",
                              "learningObjective": "Calcular offsets em stack frames considerando direção de crescimento e alinhamento.",
                              "commonMistakes": [
                                "Confundir direção de alocação locais vs params",
                                "Ignorar alinhamento no stack",
                                "Não reservar espaço total no SP"
                              ]
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.4.3.2",
                            "name": "Alocar endereços em frames de pilha",
                            "description": "Gerenciar alocação dinâmica de endereços para parâmetros e variáveis locais, atualizando atributos durante a análise semântica.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a estrutura de um frame de pilha",
                                  "subSteps": [
                                    "Estudar os componentes principais: registrador base (BP), registrador de pilha (SP), área de parâmetros, variáveis locais, espaço de retorno e registradores salvos.",
                                    "Aprender sobre offsets relativos ao BP: positivos para parâmetros e negativos para variáveis locais.",
                                    "Analisar convenções de chamada (ex: System V ABI ou Microsoft x64).",
                                    "Visualizar e desenhar diagramas de stack frames para funções simples.",
                                    "Identificar o papel da análise semântica na preparação para alocação."
                                  ],
                                  "verification": "Desenhar e rotular um diagrama completo de stack frame para uma função com 2 parâmetros e 1 variável local.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Diagramas de stack frames online",
                                    "Documentação de ABIs (System V, x64)",
                                    "Editor de imagens para diagramas"
                                  ],
                                  "tips": "Sempre relacione offsets ao BP para facilitar cálculos relativos.",
                                  "learningObjective": "Identificar e descrever todos os componentes de um frame de pilha e seus offsets.",
                                  "commonMistakes": [
                                    "Confundir offsets positivos (parâmetros) com negativos (locais)",
                                    "Ignorar o tamanho do espaço de retorno"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Alocar endereços para parâmetros",
                                  "subSteps": [
                                    "Iniciar alocação a partir do BP + offset inicial (geralmente BP+8 ou BP+16, dependendo da ABI).",
                                    "Calcular offsets sequenciais: cada parâmetro ocupa seu tamanho (int=4 bytes, double=8 bytes), considerando alinhamento.",
                                    "Atualizar o atributo 'endereço' na tabela de símbolos para cada parâmetro durante a análise semântica.",
                                    "Tratar parâmetros por referência (ponteiros) com alocação similar.",
                                    "Verificar total de bytes alocados para parâmetros."
                                  ],
                                  "verification": "Listar offsets exatos para parâmetros em uma função com tipos mistos (int, double).",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Exemplos de código C simples",
                                    "Calculadora para offsets",
                                    "Tabela de tamanhos de tipos por arquitetura"
                                  ],
                                  "tips": "Some 8 bytes iniciais para BP e IP em ABIs comuns antes dos parâmetros.",
                                  "learningObjective": "Calcular e atribuir endereços precisos para parâmetros em frames de pilha.",
                                  "commonMistakes": [
                                    "Esquecer alinhamento (ex: double em endereço par)",
                                    "Não reservar espaço para ponteiros de retorno"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Alocar endereços para variáveis locais",
                                  "subSteps": [
                                    "Iniciar alocação abaixo do BP (BP - offset).",
                                    "Calcular offsets sequenciais de baixo para cima ou cima para baixo, dependendo da convenção.",
                                    "Considerar alinhamento e tamanho de cada variável local na tabela de símbolos.",
                                    "Atualizar atributos de endereço na tabela durante a segunda passada da análise semântica.",
                                    "Ajustar o SP para o tamanho total das locais no prólogo da função."
                                  ],
                                  "verification": "Implementar pseudocódigo para alocação de 3 variáveis locais e verificar offsets.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Pseudocódigo de compiladores",
                                    "Simulador de stack (ex: online stack visualizer)",
                                    "Lista de tamanhos de tipos"
                                  ],
                                  "tips": "Alinhe variáveis maiores primeiro para otimizar espaço.",
                                  "learningObjective": "Gerenciar alocação dinâmica de variáveis locais com offsets corretos.",
                                  "commonMistakes": [
                                    "Invertir direção de alocação (crescente vs decrescente)",
                                    "Não arredondar para alinhamento de 8 bytes"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Integrar alocação na análise semântica e gerenciar atualizações",
                                  "subSteps": [
                                    "Implementar lógica no analisador semântico para percorrer a tabela de símbolos da função.",
                                    "Atualizar atributos de endereço para params e locals em uma única passada.",
                                    "Tratar recursão: cada chamada tem seu próprio frame.",
                                    "Gerar código assembly equivalente para verificação (prólogo/epílogo).",
                                    "Testar com exemplos de funções aninhadas."
                                  ],
                                  "verification": "Simular análise semântica em uma função completa e listar todos os endereços alocados.",
                                  "estimatedTime": "50 minutos",
                                  "materials": [
                                    "Código-fonte de analisadores semânticos open-source (ex: LLVM snippets)",
                                    "Ferramenta de depuração como GDB",
                                    "Compilador online (Godbolt)"
                                  ],
                                  "tips": "Use um contador de offset global por frame para evitar erros manuais.",
                                  "learningObjective": "Integrar alocação de endereços na pipeline de análise semântica de compiladores.",
                                  "commonMistakes": [
                                    "Atualizar tabela antes de calcular tamanhos totais",
                                    "Não lidar com funções recursivas"
                                  ]
                                }
                              ],
                              "practicalExample": "Para a função C: int f(int x, double y) { int z; z = x + (int)y; return z; } Alocação (x86-64 System V): x em [RBP+8] (4 bytes), y em [RBP+16] (8 bytes alinhado), z em [RBP-8] (4 bytes, arredondado para 8). Tabela de símbolos atualizada: x.endereco = 'RBP+8', y.endereco = 'RBP+16', z.endereco = 'RBP-8'.",
                              "finalVerifications": [
                                "Desenhar stack frame completo com offsets corretos para função com 2 params e 2 locals.",
                                "Calcular total de bytes alocados e ajustar SP adequadamente.",
                                "Explicar como a alocação muda em chamadas recursivas.",
                                "Implementar pseudocódigo para alocador e testar com exemplo.",
                                "Comparar com assembly gerado por GCC para uma função similar.",
                                "Identificar erros em um stack frame mal alocado fornecido."
                              ],
                              "assessmentCriteria": [
                                "Precisão nos cálculos de offsets e alinhamentos (100% correto).",
                                "Correta integração com tabela de símbolos (atributos atualizados).",
                                "Tratamento de tipos variados e convenções de ABI.",
                                "Capacidade de visualizar e diagramar frames complexos.",
                                "Explicação clara de atualizações dinâmicas na análise semântica.",
                                "Detecção e correção de erros comuns em alocações."
                              ],
                              "crossCurricularConnections": [
                                "Arquitetura de Computadores: Uso de registradores BP/SP e convenções de pilha.",
                                "Análise Semântica: Atualização de atributos em árvores de sintaxe.",
                                "Programação em Assembly: Geração de prólogo/epílogo de funções.",
                                "Sistemas Operacionais: Gerenciamento de pilha no runtime.",
                                "Engenharia de Software: Otimização de memória em compiladores."
                              ],
                              "realWorldApplication": "Em compiladores como GCC ou Clang, essa alocação garante execução eficiente de funções em linguagens como C/C++, otimizando uso de memória em pilha para programas reais, evitando stack overflows e habilitando depuração precisa com ferramentas como GDB."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.3.4.4",
                        "name": "Atributos Léxicos",
                        "description": "Propriedades derivadas da análise léxica, como identificador, literal ou palavra reservada, incluindo comprimento e valor tokenizado.",
                        "specificSkills": [
                          {
                            "id": "10.1.3.4.4.1",
                            "name": "Classificar símbolos por atributos léxicos",
                            "description": "Identificar e armazenar categorias léxicas (ID, NUM, STRING) nos atributos iniciais da tabela de símbolos durante a análise léxica.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender as categorias léxicas básicas",
                                  "subSteps": [
                                    "Estudar as definições: ID (identificadores alfanuméricos iniciando por letra), NUM (sequências de dígitos opcionais com ponto ou expoente), STRING (sequências entre aspas com escapes permitidos).",
                                    "Analisar regras formais: ID = letra({letra|dígito})*, NUM = dígito+(.dígito*)?(E[+-]?dígito+)?, STRING = \"({caractere não \"}|\\\")*\".",
                                    "Identificar diferenças com outros tokens como operadores e palavras-chave.",
                                    "Revisar exemplos de código fonte para cada categoria.",
                                    "Mapear atributos iniciais na tabela de símbolos: categoria como primeiro campo."
                                  ],
                                  "verification": "Criar uma tabela com 10 exemplos de tokens e classificá-los corretamente em ID, NUM ou STRING.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Documentação de gramáticas formais",
                                    "Exemplos de código fonte simples",
                                    "Ferramenta de edição de texto"
                                  ],
                                  "tips": "Use diagramas de transição finita para visualizar reconhecimento de padrões.",
                                  "learningObjective": "Dominar as regras exatas para distinguir categorias léxicas.",
                                  "commonMistakes": [
                                    "Confundir IDs com palavras-chave reservadas",
                                    "Ignorar sequências de escape em strings",
                                    "Classificar números hexadecimais como inválidos sem suporte explícito"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Definir funções de classificação no código",
                                  "subSteps": [
                                    "Implementar função isIdentifier(): verificar início com letra e continuação alfanumérica.",
                                    "Implementar função isNumber(): usar regex ou loop para validar formato numérico completo.",
                                    "Implementar função isString(): checar aspas duplas delimitadoras e lidar com escapes.",
                                    "Criar função classifyLexicalCategory(token): retornar 'ID', 'NUM' ou 'STRING' baseado nas funções acima.",
                                    "Testar funções isoladamente com casos de borda (ex: '1a' inválido para NUM)."
                                  ],
                                  "verification": "Executar testes unitários para as funções com 15 tokens variados e obter 100% de acerto.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Editor de código (VS Code ou similar)",
                                    "Linguagem de programação (C, Python ou Java)",
                                    "Biblioteca de testes unitários (JUnit, pytest)"
                                  ],
                                  "tips": "Priorize funções puras sem efeitos colaterais para facilitar testes.",
                                  "learningObjective": "Desenvolver lógica programática para classificação automática de tokens.",
                                  "commonMistakes": [
                                    "Não tratar casos vazios ou nulos",
                                    "Falhar em números com expoente como 1E-3",
                                    "Permitir aspas simples em strings"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Integrar classificação na análise léxica e tabela de símbolos",
                                  "subSteps": [
                                    "Modificar o scanner/lexer para chamar classifyLexicalCategory() após reconhecimento de token.",
                                    "Estruturar entrada na tabela de símbolos: {categoria: 'ID', lexeme: 'var', linha: 5, ...}.",
                                    "Implementar inserção condicional: só inserir se for ID, NUM ou STRING (ignorar operadores).",
                                    "Adicionar logging ou debug para rastrear classificações durante scan.",
                                    "Garantir unicidade por lexeme em IDs para evitar duplicatas."
                                  ],
                                  "verification": "Rodar lexer em um programa fonte pequeno e inspecionar tabela de símbolos gerada.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Código base de analisador léxica simples",
                                    "Estrutura de tabela de símbolos (array ou hashmap)",
                                    "Ferramenta de debug (print ou debugger)"
                                  ],
                                  "tips": "Use enum para categorias para evitar erros de string.",
                                  "learningObjective": "Conectar classificação léxica diretamente à estrutura de dados da tabela de símbolos.",
                                  "commonMistakes": [
                                    "Inserir todos tokens na tabela, incluindo operadores",
                                    "Perder tracking de posição (linha/coluna)",
                                    "Não normalizar lexemes (espaços extras)"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Testar e validar a classificação completa",
                                  "subSteps": [
                                    "Criar suíte de testes com programas fonte contendo IDs, NUMs e STRINGs misturados.",
                                    "Verificar tabela final: todos símbolos classificados corretamente sem duplicatas ou omissões.",
                                    "Simular erros léxicos e confirmar que classificação não falha.",
                                    "Medir performance: tempo de scan e tamanho da tabela.",
                                    "Refatorar baseado em falhas encontradas."
                                  ],
                                  "verification": "Passar todos testes automatizados e manualmente inspecionar 3 programas fonte.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Programas de teste fonte",
                                    "Framework de testes de integração",
                                    "Ferramenta de profiling opcional"
                                  ],
                                  "tips": "Comece com casos simples e escale para complexos.",
                                  "learningObjective": "Garantir robustez da classificação em cenários reais de compilação.",
                                  "commonMistakes": [
                                    "Testes insuficientes para bordas como strings vazias",
                                    "Ignorar case-sensitivity em IDs",
                                    "Sobrecarga na tabela com tokens irrelevantes"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um lexer para linguagem mini: fonte 'int x = 3.14; string msg = \"hello\";'. Saída na tabela: [{categoria: 'ID', lexeme: 'x'}, {categoria: 'NUM', lexeme: '3.14'}, {categoria: 'ID', lexeme: 'msg'}, {categoria: 'STRING', lexeme: 'hello'}].",
                              "finalVerifications": [
                                "Classificar corretamente 20 tokens mistos sem erros.",
                                "Tabela de símbolos contém apenas ID/NUM/STRING com atributos corretos.",
                                "Lexer processa programa de 50 linhas sem crash em classificação.",
                                "Identificar e corrigir 3 erros comuns em classificação.",
                                "Explicar verbalmente o fluxo de classificação para um par.",
                                "Comparar tabela gerada com uma referência manual."
                              ],
                              "assessmentCriteria": [
                                "Precisão de classificação > 95% em testes.",
                                "Eficiência: tempo de execução < 1s para 1000 tokens.",
                                "Cobertura de casos: todos formatos válidos de NUM/STRING suportados.",
                                "Integração limpa: sem vazamentos na tabela de símbolos.",
                                "Robustez: lida com inputs inválidos sem falha.",
                                "Documentação: comentários explicando lógica de classificação."
                              ],
                              "crossCurricularConnections": [
                                "Linguística: Reconhecimento de morfemas e padrões linguísticos.",
                                "Matemática: Autômatos finitos e expressões regulares.",
                                "Programação: Estruturas de dados (hash tables) e testes unitários.",
                                "Teoria da Computação: Fases de compiladores e linguagens regulares."
                              ],
                              "realWorldApplication": "Em compiladores profissionais como GCC ou Clang, essa classificação popula tabelas de símbolos para otimização e geração de código; em ferramentas como ESLint ou parsers de JSON, garante análise semântica precisa de tokens."
                            },
                            "estimatedTime": "0.5 hora",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.4.4.2",
                            "name": "Integrar atributos léxicos com semânticos",
                            "description": "Combinar informações léxicas (como valor de literal) com atributos semânticos para declarações e inicializações.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender Atributos Léxicos e Semânticos",
                                  "subSteps": [
                                    "Estude as definições: atributos léxicos incluem valor literal, posição na fonte (linha/coluna), tamanho do token; atributos semânticos incluem tipo inferido, escopo, visibilidade e endereço de memória.",
                                    "Analise exemplos: para literal '42', léxico = {valor: 42, tipoToken: INT_LITERAL, linha: 5}; semântico = {tipo: int, inicializado: true}.",
                                    "Identifique a necessidade de integração: durante declarações (ex: int x;), preencha léxicos primeiro e adicione semânticos na análise.",
                                    "Classifique 10 símbolos de um código-fonte em léxicos vs semânticos.",
                                    "Discuta casos onde integração falha (ex: tipo mismatch)."
                                  ],
                                  "verification": "Classifique corretamente atributos de 10 símbolos em um exercício fornecido, sem erros.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Livro 'Compilers: Principles, Techniques, and Tools' (Dragon Book), capítulos 1-3",
                                    "Notas de aula sobre análise léxica/sintática"
                                  ],
                                  "tips": "Sempre associe léxicos à fase de scanning/parsing e semânticos à fase semântica posterior.",
                                  "learningObjective": "Diferenciar atributos léxicos de semânticos e justificar sua integração em tabelas de símbolos.",
                                  "commonMistakes": [
                                    "Confundir valor literal (léxico) com tipo inferido (semântico)",
                                    "Ignorar metadados de posição fonte como atributos léxicos"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Projetar Estrutura de Símbolo Integrada",
                                  "subSteps": [
                                    "Defina uma estrutura de dados (ex: struct Symbol em C++ ou classe em Python) com campos léxicos: valueLiteral, tokenType, sourcePos.",
                                    "Adicione campos semânticos: dataType, scopeLevel, isInitialized, memoryOffset.",
                                    "Crie métodos para merge: função que popula léxicos durante parsing e atualiza semânticos em declarações.",
                                    "Valide a estrutura com diagrama UML ou pseudocódigo.",
                                    "Teste design com pseudocódigo para declaração 'int x = 42;'."
                                  ],
                                  "verification": "Desenhe e valide uma estrutura de símbolo que integra ambos atributos, aprovada por auto-revisão ou peer review.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Ferramentas de diagramação como Draw.io ou Lucidchart",
                                    "Exemplos de tabelas de símbolos de compiladores open-source (GCC/LLVM)"
                                  ],
                                  "tips": "Use herança ou composição para separar concerns, mas permita referência mútua.",
                                  "learningObjective": "Projetar uma estrutura de dados flexível para armazenar atributos integrados.",
                                  "commonMistakes": [
                                    "Estruturas rígidas que não escalam para múltiplos escopos",
                                    "Falta de campos para rastreamento de erros semânticos"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar Integração em Análise Léxica/Sintática",
                                  "subSteps": [
                                    "Implemente um scanner simples que capture atributos léxicos e insira na tabela de símbolos.",
                                    "No parser, para declarações (ex: type id;), busque símbolo, adicione atributos semânticos como tipo e escopo.",
                                    "Para inicializações (ex: id = literal;), merge valor léxico do literal com semânticos do id (type check).",
                                    "Adicione verificações: se mismatch, reporte erro semântico.",
                                    "Teste com código-fonte simples contendo 5 declarações/inicializações."
                                  ],
                                  "verification": "Código implementado compila sem erros e processa corretamente 5 casos de teste.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Linguagem de prototipagem: Python com PLY ou ANTLR",
                                    "Código-fonte de exemplo em linguagem toy (ex: mini-C)"
                                  ],
                                  "tips": "Use pilha de escopos para tabelas de símbolos aninhadas durante parsing.",
                                  "learningObjective": "Codificar o processo de integração durante fases do compilador.",
                                  "commonMistakes": [
                                    "Inserir semânticos antes de léxicos completos",
                                    "Não lidar com forward references em declarações"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificar e Aplicar em Análise Semântica Completa",
                                  "subSteps": [
                                    "Execute análise semântica usando a tabela integrada: cheque inicializações contra declarações.",
                                    "Gere código intermediário baseado em atributos combinados (ex: alocação de memória).",
                                    "Debugue erros comuns: undeclared variables, type mismatches.",
                                    "Otimize: adicione inferência de tipos onde possível.",
                                    "Avalie com benchmark de 10 snippets de código."
                                  ],
                                  "verification": "Análise semântica passa em todos testes, sem falsos positivos/negativos.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Testes unitários com pytest ou JUnit",
                                    "Ferramentas de debug como gdb para C++ protótipos"
                                  ],
                                  "tips": "Registre todos merges em logs para facilitar debugging.",
                                  "learningObjective": "Aplicar integração em fluxo completo de compilação e validar resultados.",
                                  "commonMistakes": [
                                    "Sobrescrever atributos léxicos durante updates semânticos",
                                    "Ignorar propagação de erros para fases posteriores"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Refinar e Documentar o Processo",
                                  "subSteps": [
                                    "Revise implementações anteriores com base em testes falhos.",
                                    "Documente API da tabela de símbolos com exemplos de integração.",
                                    "Crie guia de troubleshooting para erros de integração.",
                                    "Compartilhe em repositório Git com README.",
                                    "Planeje extensões para atributos avançados (ex: overloads)."
                                  ],
                                  "verification": "Documentação completa e repositório funcional com issues resolvidas.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "GitHub ou GitLab",
                                    "Templates de documentação Markdown"
                                  ],
                                  "tips": "Use diagramas de fluxo para ilustrar o merge léxico-semântico.",
                                  "learningObjective": "Refinar processo e documentar para reutilização.",
                                  "commonMistakes": [
                                    "Documentação incompleta sem exemplos práticos",
                                    "Não versionar mudanças na estrutura de símbolo"
                                  ]
                                }
                              ],
                              "practicalExample": "Em uma linguagem toy: código-fonte 'int x = 42; printf(x);'. Durante scanning: token INT (léxico: tipoToken=INT_KW), 42 (léxico: valor=42, pos=linha1col7), x (léxico: valor='x', pos=linha1col5), =, etc. No parser: para 'int x', crie símbolo {lex: {name:'x'}, sem: {type:int, scope:global}}. Para '=42', merge {sem: {initialized:true, value:42}}. Saída semântica: x é int inicializado com 42, pronto para código-geração.",
                              "finalVerifications": [
                                "Explicar verbalmente o fluxo de integração para um exemplo dado.",
                                "Implementar e rodar parser que processa 10 declarações/inicializações sem erros.",
                                "Identificar e corrigir 5 erros simulados de integração léxica-semântica.",
                                "Gerar tabela de símbolos populada corretamente para código complexo.",
                                "Demonstrar type-checking usando atributos integrados."
                              ],
                              "assessmentCriteria": [
                                "Precisão na distinção e merge de atributos (90% acurácia em testes).",
                                "Eficiência da estrutura: tempo de lookup O(1) médio em benchmarks.",
                                "Cobertura de casos edge: forward refs, shadowed vars (100% pass).",
                                "Qualidade da documentação e exemplos práticos.",
                                "Criatividade em conexões semânticas (ex: inferência automática)."
                              ],
                              "crossCurricularConnections": [
                                "Linguagens de Programação: Uso similar em type systems de TypeScript/Python.",
                                "Banco de Dados: Metadados de colunas (léxicos) + constraints semânticos.",
                                "Matemática Discreta: Teoria de grafos para escopos e dependências.",
                                "Engenharia de Software: Design patterns como Composite para símbolos.",
                                "Inteligência Artificial: Embeddings semânticos em NLP parsers."
                              ],
                              "realWorldApplication": "Em compiladores reais como GCC ou Clang, essa integração permite detecção precoce de erros em C/C++ (ex: int x= 'abc';), otimização de código (dead code elimination baseado em initialized), e suporte a linguagens modernas com inferência (Rust, Swift), reduzindo tempo de desenvolvimento e bugs em software de grande escala como browsers (Chrome V8) ou kernels (Linux)."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.4.4.3",
                            "name": "Tratar erros léxicos em símbolos",
                            "description": "Detectar identificadores inválidos ou duplicados usando atributos léxicos para reportar erros precocemente.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Definir regras léxicas para identificadores válidos",
                                  "subSteps": [
                                    "Estude as convenções padrão de identificadores em linguagens de programação (ex: deve iniciar com letra ou underscore, seguido de alfanuméricos).",
                                    "Liste caracteres permitidos e proibidos (ex: sem espaços, símbolos especiais exceto underscore).",
                                    "Defina comprimento máximo e regras de case-sensitivity.",
                                    "Crie um regex ou função para validar formato léxico.",
                                    "Documente regras em um fluxograma para visualização."
                                  ],
                                  "verification": "Crie uma tabela comparativa de identificadores válidos vs. inválidos e valide manualmente 10 exemplos.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Editor de texto ou IDE (VS Code)",
                                    "Documentação de linguagens como C ou Python",
                                    "Ferramenta de regex tester online"
                                  ],
                                  "tips": "Use regex para automação inicial: /^[a-zA-Z_][a-zA-Z0-9_]*$/ para maioria das linguagens.",
                                  "learningObjective": "Compreender e formalizar atributos léxicos de identificadores para detecção de erros.",
                                  "commonMistakes": [
                                    "Ignorar case-sensitivity em validações.",
                                    "Permitir underscore inicial mas esquecer de letras subsequentes.",
                                    "Não considerar comprimento mínimo/máximo."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar validação durante análise léxica",
                                  "subSteps": [
                                    "Integre a verificação no lexer: ao tokenizar um identificador, aplique as regras definidas.",
                                    "Se inválido, gere um token de erro com posição (linha/coluna).",
                                    "Armazene atributos léxicos temporários (nome, posição) antes da inserção na tabela.",
                                    "Teste com input contendo identificadores inválidos (ex: '1var', '@var', 'var space').",
                                    "Registre logs ou exceções para depuração."
                                  ],
                                  "verification": "Execute lexer em código com 5 identificadores inválidos e confirme que todos são detectados sem crash.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Linguagem de programação (Python ou Flex)",
                                    "Exemplos de código fonte com erros léxicos",
                                    "Debugger integrado no IDE"
                                  ],
                                  "tips": "Capture posição exata do erro usando contadores de linha/coluna no lexer.",
                                  "learningObjective": "Desenvolver código para detectar erros léxicos em tempo real durante tokenização.",
                                  "commonMistakes": [
                                    "Não capturar posição do erro, dificultando depuração.",
                                    "Continuar processamento após erro léxico, propagando falhas.",
                                    "Confundir erros léxicos com sintáticos."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Detectar duplicatas na tabela de símbolos usando atributos léxicos",
                                  "subSteps": [
                                    "Estruture a tabela de símbolos com chave primária no nome (case-sensitive) e escopo.",
                                    "Ao inserir símbolo, busque por duplicatas no escopo atual.",
                                    "Se duplicado, compare atributos léxicos (nome exato, tipo) e reporte erro.",
                                    "Implemente hashmap ou árvore para busca O(1) ou O(log n).",
                                    "Adicione suporte a escopos aninhados para evitar falsos positivos."
                                  ],
                                  "verification": "Insira 10 símbolos, incluindo 3 duplicados em escopos diferentes, e verifique relatórios corretos.",
                                  "estimatedTime": "75 minutos",
                                  "materials": [
                                    "Estrutura de dados em Python (dict ou TreeMap em Java)",
                                    "Código base de tabela de símbolos",
                                    "Ferramentas de profiling para performance"
                                  ],
                                  "tips": "Use tuplas (nome, escopo) como chaves compostas para precisão.",
                                  "learningObjective": "Integrar atributos léxicos à tabela de símbolos para detecção precoce de duplicatas.",
                                  "commonMistakes": [
                                    "Ignorar escopo, reportando falsos duplicados em blocos diferentes.",
                                    "Busca linear ineficiente em tabelas grandes.",
                                    "Não diferenciar redeclarações permitidas (ex: funções vs. variáveis)."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Reportar erros precocemente e integrar ao compilador",
                                  "subSteps": [
                                    "Crie um sistema de mensagens de erro padronizado (ex: 'Erro léxico na linha X: identificador inválido \"1abc\"').",
                                    "Implemente flag para parar compilação no primeiro erro ou coletar todos.",
                                    "Integre lexer + tabela em um parser simples.",
                                    "Gere relatório de erros em arquivo ou console com sugestões de correção.",
                                    "Adicione recuperação de erros para continuar análise."
                                  ],
                                  "verification": "Compile código com múltiplos erros e valide relatório completo sem omissões.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Código integrado de lexer/parser",
                                    "Templates de mensagens de erro",
                                    "Testes unitários (pytest ou JUnit)"
                                  ],
                                  "tips": "Priorize erros léxicos sobre sintáticos para feedback imediato.",
                                  "learningObjective": "Criar mecanismo robusto de reporting para erros léxicos usando tabela de símbolos.",
                                  "commonMistakes": [
                                    "Mensagens vagas sem posição ou exemplo do erro.",
                                    "Não lidar com múltiplos erros, parando no primeiro.",
                                    "Recuperação agressiva que mascara erros subsequentes."
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Testar e refinar o sistema de tratamento de erros",
                                  "subSteps": [
                                    "Crie suíte de testes: 20 casos (válidos, inválidos, duplicados em escopos variados).",
                                    "Meça cobertura de código e taxa de detecção (95%+).",
                                    "Analise falsos positivos/negativos e ajuste regras.",
                                    "Profile performance em inputs grandes.",
                                    "Documente limitações e extensões futuras (ex: Unicode)."
                                  ],
                                  "verification": "Execute testes automatizados; taxa de acerto 100% em casos conhecidos.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Framework de testes",
                                    "Gerador de casos de teste aleatórios",
                                    "Ferramentas de coverage (coverage.py)"
                                  ],
                                  "tips": "Use TDD: escreva testes antes de código para guiar implementação.",
                                  "learningObjective": "Validar e otimizar detecção de erros léxicos em cenários reais.",
                                  "commonMistakes": [
                                    "Testes insuficientes, perdendo edge cases como strings vazias.",
                                    "Ignorar performance em tabelas com milhares de símbolos.",
                                    "Não testar interações com outros atributos (ex: tipo)."
                                  ]
                                }
                              ],
                              "practicalExample": "Em um lexer Python simples: def tokenize(code): for match in re.finditer(r'([a-zA-Z_][a-zA-Z0-9_]*)', code): name = match.group(1); if not re.match(r'^[a-zA-Z_][a-zA-Z0-9_]*$', name): raise LexError(f'Invalid identifier \"{name}\" at {match.start()}'); symbol_table[name] = {'scope': current_scope}; if name in symbol_table and symbol_table[name]['scope'] == current_scope: raise DuplicateError(name);. Teste com 'int 1var = 5;' → detecta '1var' inválido.",
                              "finalVerifications": [
                                "Lexer detecta todos identificadores inválidos com posição exata.",
                                "Tabela de símbolos rejeita duplicatas no mesmo escopo.",
                                "Mensagens de erro são claras e incluem sugestões.",
                                "Sistema continua após erros (modo recovery).",
                                "Testes cobrem 95%+ do código com zero falsos negativos.",
                                "Performance aceitável (<1s para 10k símbolos)."
                              ],
                              "assessmentCriteria": [
                                "Precisão na detecção: 100% em casos padrão.",
                                "Eficiência: Busca O(1) na tabela.",
                                "Qualidade das mensagens: Informativas e localizadas.",
                                "Robustez: Lida com edge cases sem crash.",
                                "Documentação: Regras e testes bem comentados.",
                                "Integração: Funciona em pipeline lexer-parser."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Expressões regulares e autômatos finitos.",
                                "Linguagens Formais: Teoria de linguagens e gramáticas.",
                                "Programação: Estruturas de dados (hash tables, árvores).",
                                "Engenharia de Software: Tratamento de exceções e logging.",
                                "Design de UX: Mensagens de erro user-friendly em IDEs."
                              ],
                              "realWorldApplication": "Em compiladores como GCC/Clang ou IDEs (VS Code, IntelliJ), detecta erros em identificadores cedo, acelerando depuração em projetos grandes, prevenindo bugs em runtime e melhorando produtividade de desenvolvedores."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.3.5",
                    "name": "Operações Básicas em Tabelas de Símbolos",
                    "description": "Inserção, busca, atualização e remoção de entradas durante as fases de análise.",
                    "individualConcepts": [
                      {
                        "id": "10.1.3.5.1",
                        "name": "Inserção de Entradas",
                        "description": "Processo de adicionar novas entradas na tabela de símbolos, tipicamente durante a análise léxica para identificadores iniciais e na análise sintática/semântica para declarações, garantindo unicidade no escopo atual.",
                        "specificSkills": [
                          {
                            "id": "10.1.3.5.1.1",
                            "name": "Identificar momentos de inserção",
                            "description": "Determinar os pontos exatos nas fases de análise (léxica para tokens de ID, sintática para declarações) onde uma nova entrada deve ser inserida, considerando escopos aninhados.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Fases de Análise no Compilador",
                                  "subSteps": [
                                    "Estude o pipeline de compilação: pré-processamento, análise léxica, sintática, semântica.",
                                    "Identifique o papel da análise léxica: tokenização de código fonte em tokens como ID, keywords.",
                                    "Descreva a análise sintática: parsing de tokens em árvore sintática abstrata (AST).",
                                    "Explique quando as tabelas de símbolos são consultadas/inseridas em cada fase.",
                                    "Anote diferenças entre inserções iniciais (léxica) e refinadas (sintática)."
                                  ],
                                  "verification": "Crie um fluxograma simples mostrando fases e pontos potenciais de inserção.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Diagrama de fases de compilador (ex: Dragon Book capítulo 1), papel e caneta.",
                                  "tips": "Use setas no fluxograma para indicar fluxo de dados entre fases.",
                                  "learningObjective": "Compreender o contexto temporal das inserções nas fases iniciais de análise.",
                                  "commonMistakes": "Confundir análise léxica com sintática; achar que inserções ocorrem só na semântica."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar Inserções na Análise Léxica para Tokens de ID",
                                  "subSteps": [
                                    "Simule tokenização de código: ao encontrar um ID novo, marque como candidato para inserção.",
                                    "Defina regra: inserir entrada provisória na tabela global ou escopo atual após validação léxica.",
                                    "Registre atributos iniciais: nome do ID, tipo 'undeclared', posição no código.",
                                    "Teste com exemplo: código 'int x;' – inserir 'x' após tokenizar 'x'.",
                                    "Verifique colisões: se ID já existe no escopo, não inserir duplicata."
                                  ],
                                  "verification": "Liste 3 exemplos de código onde inserção léxica ocorre, com tokens destacados.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Lexer simples em Python ou ferramenta online como JLex, exemplos de código fonte.",
                                  "tips": "Implemente um lexer mock para visualizar tokens em tempo real.",
                                  "learningObjective": "Dominar detecção e inserção inicial de IDs durante tokenização.",
                                  "commonMistakes": "Inserir antes de validar se é realmente um ID válido (não keyword)."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Determinar Inserções na Análise Sintática para Declarações",
                                  "subSteps": [
                                    "Analise gramática: identifique não-terminais para declarações (ex: VarDecl → type ID ;).",
                                    "Defina momento: após parsing bem-sucedido da declaração, inserir/atualizar entrada.",
                                    "Adicione atributos: tipo, escopo, visibilidade baseados no contexto sintático.",
                                    "Exemplo: em 'int x = 5;' inserir/atualizar 'x' com tipo 'int' após reduzir regra de declaração.",
                                    "Integre com pilha de escopos: push/pop escopos em { }."
                                  ],
                                  "verification": "Parse um snippet com declarações e anote pontos exatos de inserção na árvore sintática.",
                                  "estimatedTime": "50 minutos",
                                  "materials": "Parser generator como ANTLR ou Yacc, gramática de linguagem simples (ex: mini-C).",
                                  "tips": "Use debug mode no parser para pausar em reduções de regras.",
                                  "learningObjective": "Precificar inserções definitivas durante construção da AST.",
                                  "commonMistakes": "Inserir antes de confirmar sintaxe válida da declaração."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Gerenciar Inserções Considerando Escopos Aninhados",
                                  "subSteps": [
                                    "Implemente pilha de tabelas: nova tabela por escopo (função, bloco).",
                                    "Regra de inserção: sempre no escopo top da pilha; procure em escopos pais se não achar.",
                                    "Momentos chave: push escopo em '{', pop em '}'; inserir em declarações dentro do escopo.",
                                    "Exemplo: função com bloco local – inserir locals só no escopo interno.",
                                    "Valide shadowing: permitir ID local sombrear global."
                                  ],
                                  "verification": "Simule código com escopos aninhados e trace inserções com pilha de escopos.",
                                  "estimatedTime": "40 minutos",
                                  "materials": "Código exemplo com funções/blocos, simulador de tabela de símbolos (ex: hashmap stack).",
                                  "tips": "Desenhe pilha visualmente para cada linha de código.",
                                  "learningObjective": "Aplicar escopos hierárquicos para inserções precisas.",
                                  "commonMistakes": "Ignorar pop de escopo, causando vazamento de símbolos locais."
                                }
                              ],
                              "practicalExample": "Considere o código C-like: int x = 1; { int x = 2; } Ao tokenizar 'int x = 1;', insira 'x' (global, tipo int) após declaração sintática na linha 1. No bloco '{ int x = 2; }', push novo escopo, insira 'x' local após declaração na linha 2. Pop escopo após '}', restaurando global.",
                              "finalVerifications": [
                                "Liste pontos exatos de inserção para análise léxica e sintática em um código dado.",
                                "Trace inserções em código com 3 níveis de escopo aninhado sem erros.",
                                "Diferencie inserções provisórias (léxica) de definitivas (sintática).",
                                "Simule pilha de escopos corretamente para shadowing de variáveis.",
                                "Identifique 5 momentos onde NÃO inserir (ex: keywords, expressões).",
                                "Valide ausência de duplicatas em escopo atual."
                              ],
                              "assessmentCriteria": [
                                "Precisão nos momentos de inserção (léxica vs sintática): 100% correto.",
                                "Tratamento completo de escopos aninhados e shadowing.",
                                "Detalhes de atributos inseridos (nome, tipo, escopo).",
                                "Uso correto de fluxogramas ou traces para visualização.",
                                "Identificação de erros comuns evitados.",
                                "Completude: cobre todos sub-passos em exemplos práticos."
                              ],
                              "crossCurricularConnections": [
                                "Estruturas de Dados: pilhas para escopos, hash tables para tabelas de símbolos.",
                                "Algoritmos: busca em escopos (profundidade limitada), detecção de colisões.",
                                "Lógica e Automatos: análise léxica como autômato finito.",
                                "Engenharia de Software: design de APIs para symbol tables em compiladores/IDEs."
                              ],
                              "realWorldApplication": "Em compiladores como GCC ou Clang, identificar momentos de inserção otimiza detecção de erros (ex: redeclarações) e acelera resolução de símbolos em IDEs como VS Code, permitindo autocompletar e refatoração em tempo real."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.5.1.2",
                            "name": "Implementar inserção em tabela hash",
                            "description": "Criar pseudocódigo para inserir um símbolo com atributos básicos (nome, tipo inicial, escopo) em uma tabela de símbolos baseada em hash, tratando colisões com encadeamento.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Definir as estruturas de dados para a tabela hash e o símbolo",
                                  "subSteps": [
                                    "Crie uma estrutura Símbolo com campos: nome (string), tipoInicial (string), escopo (string), e próximo (ponteiro para próximo nó).",
                                    "Defina a tabela hash como um array de ponteiros para listas encadeadas (ou cabeças de listas).",
                                    "Especifique o tamanho inicial da tabela, como 101 slots para evitar muitas colisões.",
                                    "Declare tipos pseudocódigo: tipo Simbolo = registro com nome, tipoInicial, escopo, proximo; tipo TabelaHash = array[1..TAMANHO] de ponteiro para Simbolo.",
                                    "Inicialize todos os ponteiros da tabela como NIL."
                                  ],
                                  "verification": "Verifique se as estruturas estão definidas corretamente escrevendo-as em pseudocódigo e compilando mentalmente um exemplo de inicialização.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Editor de texto ou papel para pseudocódigo",
                                    "Referência de estruturas de dados encadeadas"
                                  ],
                                  "tips": "Use nomes claros como 'SymbolNode' para evitar confusão com tipos primitivos.",
                                  "learningObjective": "Compreender e modelar as estruturas básicas necessárias para tabela hash com encadeamento.",
                                  "commonMistakes": [
                                    "Esquecer o ponteiro 'proximo' na estrutura Simbolo",
                                    "Não inicializar a tabela com NIL",
                                    "Usar array fixo sem considerar redimensionamento futuro"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar a função de hash",
                                  "subSteps": [
                                    "Escolha uma função hash simples para strings, como soma dos códigos ASCII módulo o tamanho da tabela.",
                                    "Defina função hash(chave: string, tamanho: inteiro): inteiro = (soma de ord(c) para c em chave) mod tamanho.",
                                    "Teste a função manualmente com exemplos: hash('varX', 101) deve retornar um índice entre 0 e 100.",
                                    "Considere melhorar com multiplicação por primo ou polinômio para distribuição melhor, mas mantenha simples.",
                                    "Escreva o pseudocódigo completo da função."
                                  ],
                                  "verification": "Calcule hash para 3 chaves diferentes e confirme que os índices são válidos (0 a tamanho-1).",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Calculadora para somas ASCII",
                                    "Tabela ASCII impressa"
                                  ],
                                  "tips": "Normalize a chave para minúsculas se o escopo exigir case-insensitivity.",
                                  "learningObjective": "Desenvolver uma função hash eficiente que mapeie chaves de string para índices da tabela.",
                                  "commonMistakes": [
                                    "Não usar módulo para ficar dentro dos limites",
                                    "Hash idêntico para chaves similares sem tratamento",
                                    "Ignorar comprimento da string levando a overflow"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar a lógica de inserção com tratamento de colisão por encadeamento",
                                  "subSteps": [
                                    "Crie função inserir(tabela: TabelaHash, simbolo: Simbolo): escreva pseudocódigo.",
                                    "Calcule indice = hash(simbolo.nome, tamanho(tabela)).",
                                    "Se tabela[indice] = NIL, defina tabela[indice] = novo Simbolo com dados copiados e proximo = NIL.",
                                    "Senão, percorra a lista: comece em atual = tabela[indice]; enquanto atual.proximo != NIL, atual = atual.proximo.",
                                    "Se encontrar nome duplicado, decida política (ex: erro ou atualizar); senão, atual.proximo = novo Simbolo."
                                  ],
                                  "verification": "Simule inserção de 2 símbolos que colidem (mesmo hash) e trace o encadeamento no papel.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Papel e caneta para diagrama da lista encadeada",
                                    "Pseudocódigo dos steps anteriores"
                                  ],
                                  "tips": "Sempre copie os dados do símbolo para um novo nó para evitar referências compartilhadas.",
                                  "learningObjective": "Implementar inserção que lida corretamente com colisões via encadeamento.",
                                  "commonMistakes": [
                                    "Inserir no início sem checar duplicatas",
                                    "Loop infinito no traversal da lista",
                                    "Não tratar caso de tabela vazia no índice"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Testar e depurar a inserção completa",
                                  "subSteps": [
                                    "Crie um exemplo: inserir 'int x' (tipo 'int', escopo 'global'), depois 'float y' que colida.",
                                    "Escreva pseudocódigo de teste: crie tabela, insira símbolos, imprima tabela simulando busca.",
                                    "Verifique colisões: confirme que ambos estão na mesma lista encadeada.",
                                    "Adicione verificação de duplicatas: se nome existe no escopo, não insira ou avise.",
                                    "Refatore código para modularidade e comente cada linha."
                                  ],
                                  "verification": "Execute simulação manual e confirme que a tabela reflete inserções corretas sem vazamentos.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Diagrama de tabela hash em papel",
                                    "Exemplos de símbolos prontos"
                                  ],
                                  "tips": "Use printfs simulados no pseudocódigo para rastrear execução.",
                                  "learningObjective": "Validar a implementação através de testes que cobrem casos normais e de colisão.",
                                  "commonMistakes": [
                                    "Não testar colisões",
                                    "Erros de ponteiros nulos",
                                    "Duplicatas não detectadas"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um compilador simples, insira símbolo 'int main' (nome='main', tipoInicial='int', escopo='global') em tabela de tamanho 101. Hash('main')=42. Lista vazia: novo nó em tabela[42]. Depois insira 'char argc' com hash=42: encadeie após 'main'.",
                              "finalVerifications": [
                                "Pseudocódigo compila sem erros sintáticos e lógicos.",
                                "Simulação manual insere 5 símbolos com 2 colisões corretamente.",
                                "Função hash distribui uniformemente (teste 10 chaves).",
                                "Nenhum loop infinito ou crash em casos edge (tabela cheia em um slot).",
                                "Duplicatas são detectadas e tratadas.",
                                "Estruturas liberam memória implicitamente no pseudocódigo."
                              ],
                              "assessmentCriteria": [
                                "Precisão da função hash (distribuição e corretude).",
                                "Tratamento correto de colisões via encadeamento.",
                                "Detecção e manejo de chaves duplicadas.",
                                "Eficiência: O(1) médio para inserção.",
                                "Clareza e comentários no pseudocódigo.",
                                "Cobertura de casos: vazio, colisão, duplicata."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Funções módulo e propriedades de hashing (distribuição uniforme).",
                                "Algoritmos: Complexidade temporal de tabelas hash vs árvores.",
                                "Engenharia de Software: Modularidade em compiladores (LLVM/GCC usam hashes).",
                                "Banco de Dados: Índices hash em SQL para consultas rápidas.",
                                "Segurança: Ataques de hash collision e mitigações."
                              ],
                              "realWorldApplication": "Em compiladores como GCC ou Clang, tabelas de símbolos com hash aceleram resolução de identificadores durante parsing e análise semântica, permitindo compilar milhões de linhas de código eficientemente."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.5.1.3",
                            "name": "Tratar duplicatas na inserção",
                            "description": "Desenvolver lógica para detectar e gerenciar símbolos duplicados no mesmo escopo, emitindo erros semânticos ou atualizando conforme regras da linguagem.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender conceitos de escopo e duplicatas em tabelas de símbolos",
                                  "subSteps": [
                                    "Defina o que é um escopo em compiladores (bloco de código com visibilidade limitada).",
                                    "Identifique o que constitui uma duplicata: símbolo com mesmo nome no mesmo escopo.",
                                    "Estude regras da linguagem: ex., C permite shadowing em escopos internos, mas não redeclaração no mesmo escopo.",
                                    "Analise impactos semânticos de duplicatas não tratadas (ambiguidade, erros de linkagem).",
                                    "Revise estrutura da tabela de símbolos (hash map com escopo como chave)."
                                  ],
                                  "verification": "Resuma em um diagrama ou parágrafo os conceitos de escopo e duplicatas, confirmando com exemplos da linguagem alvo.",
                                  "estimatedTime": "20-30 minutos",
                                  "materials": [
                                    "Documentação da linguagem (ex. manual C)",
                                    "Código fonte da tabela de símbolos atual",
                                    "Papel e caneta para diagramas"
                                  ],
                                  "tips": "Use exemplos reais de código para ilustrar; foque em escopos globais vs. locais.",
                                  "learningObjective": "Entender fundamentos teóricos para detecção precisa de duplicatas.",
                                  "commonMistakes": [
                                    "Confundir shadowing com duplicata no mesmo escopo",
                                    "Ignorar regras específicas da linguagem",
                                    "Não considerar escopos aninhados"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar detecção de duplicatas via busca pré-inserção",
                                  "subSteps": [
                                    "Crie ou adapte função de lookup na tabela de símbolos por nome e escopo atual.",
                                    "Antes de inserir novo símbolo, execute lookup no escopo corrente.",
                                    "Se encontrado, marque como duplicata; caso contrário, prossiga para inserção.",
                                    "Registre escopo atual usando pilha de escopos para contextos aninhados.",
                                    "Teste lookup com casos simples de não-duplicata."
                                  ],
                                  "verification": "Execute inserções de teste: confirme que lookup retorna null para novos símbolos e o existente para duplicatas.",
                                  "estimatedTime": "30-45 minutos",
                                  "materials": [
                                    "Editor de código (VS Code ou similar)",
                                    "Compilador de teste para a linguagem",
                                    "Exemplos de código com escopos"
                                  ],
                                  "tips": "Use hash maps para lookup O(1); sempre cheque escopo exato, não global.",
                                  "learningObjective": "Desenvolver mecanismo eficiente de detecção antes da inserção.",
                                  "commonMistakes": [
                                    "Buscar apenas no escopo global",
                                    "Não tratar colisões de hash",
                                    "Ignorar case-sensitivity do nome"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Definir e implementar políticas de tratamento de duplicatas",
                                  "subSteps": [
                                    "Decida política: emitir erro semântico (padrão) ou atualizar atributos (ex. redefinição de funções).",
                                    "Implemente emissão de erro: gere mensagem com linha/coluna e símbolo duplicado.",
                                    "Para update permitido: substitua atributos (tipo, valor) mantendo entrada existente.",
                                    "Integre na função insert: if duplicata then treat_duplicate() else insert_new().",
                                    "Adicione logging para depuração de decisões."
                                  ],
                                  "verification": "Compile código com duplicata intencional: verifique se erro é emitido e inserção abortada.",
                                  "estimatedTime": "25-40 minutos",
                                  "materials": [
                                    "Código da função insert atual",
                                    "Ferramentas de linting ou debugger",
                                    "Especificação semântica da linguagem"
                                  ],
                                  "tips": "Priorize erro semântico para segurança; configure flags para modos permissivos.",
                                  "learningObjective": "Gerenciar duplicatas de forma configurável e semântica.",
                                  "commonMistakes": [
                                    "Sempre atualizar sem checar regras",
                                    "Não reportar posição no código fonte",
                                    "Quebrar escopos pais ao tratar"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Testar e validar o tratamento de duplicatas em cenários reais",
                                  "subSteps": [
                                    "Crie testes unitários: duplicata no escopo global, local, shadowing válido.",
                                    "Teste casos de borda: nomes case-insensitive, símbolos com caracteres especiais.",
                                    "Simule compilação de programa com múltiplas duplicatas e verifique todos erros.",
                                    "Meça performance: tempo de inserção com 1000 símbolos duplicados.",
                                    "Refatore código com base em falhas encontradas."
                                  ],
                                  "verification": "Todos testes passam (100% cobertura); nenhum falso positivo/negativo em detecção.",
                                  "estimatedTime": "30-50 minutos",
                                  "materials": [
                                    "Framework de testes (JUnit ou similar)",
                                    "Programa de teste com escopos aninhados",
                                    "Profiler de performance"
                                  ],
                                  "tips": "Use TDD: escreva testes antes de codificar; cubra 80%+ dos cenários.",
                                  "learningObjective": "Garantir robustez da implementação através de validação exaustiva.",
                                  "commonMistakes": [
                                    "Testes só para casos felizes",
                                    "Ignorar performance em tabelas grandes",
                                    "Não testar escopos dinâmicos"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um compilador para C-like: código 'int x = 1; int x = 2;' no mesmo escopo global deve detectar duplicata na segunda declaração, emitir erro 'redeclaration of x' na linha 2, e abortar inserção sem modificar a entrada original.",
                              "finalVerifications": [
                                "Detecção correta de duplicatas no mesmo escopo, sem falsos positivos em shadowing.",
                                "Emissão de erro semântico com posição exata no código fonte.",
                                "Inserção abortada ou atualizada conforme política, preservando tabela consistente.",
                                "Funcionamento em escopos aninhados e pilha de escopos.",
                                "Performance aceitável (lookup < 1ms para tabelas médias).",
                                "Cobertura de testes > 90% para função insert."
                              ],
                              "assessmentCriteria": [
                                "Precisão da detecção: 100% acerto em testes unitários.",
                                "Conformidade com regras semânticas da linguagem (ex. C99).",
                                "Eficiência: O(1) médio para lookup/inserção.",
                                "Qualidade do erro: mensagem clara, informativa e localizável.",
                                "Robustez: trata bordas como nomes vazios ou colisões.",
                                "Manutenibilidade: código modular com comentários."
                              ],
                              "crossCurricularConnections": [
                                "Estruturas de Dados: uso de hash tables e árvores para tabelas de símbolos.",
                                "Lógica e Algoritmos: busca e decisão condicional em fluxos semânticos.",
                                "Análise Formal: teoria de linguagens formais e análise semântica.",
                                "Banco de Dados: conceitos de chaves únicas e constraints de integridade.",
                                "Engenharia de Software: testes unitários e tratamento de erros."
                              ],
                              "realWorldApplication": "Em compiladores profissionais como GCC ou Clang, o tratamento de duplicatas previne erros de linkagem em projetos grandes, garantindo que variáveis como 'main()' não sejam redeclaradas acidentalmente, similar a chaves primárias em bancos de dados relacionais."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.3.5.2",
                        "name": "Busca de Entradas",
                        "description": "Operação de localização de entradas existentes na tabela de símbolos, usada em referências a identificadores durante análise sintática e semântica para verificação de existência e recuperação de atributos.",
                        "specificSkills": [
                          {
                            "id": "10.1.3.5.2.1",
                            "name": "Executar busca em escopos aninhados",
                            "description": "Implementar busca que inicia no escopo atual e sobe hierarquicamente até o escopo global, retornando a entrada mais próxima ou sinalizando undeclared identifier.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Definir a estrutura de dados para escopos aninhados",
                                  "subSteps": [
                                    "Crie uma classe ou estrutura para representar um Escopo, com um mapa/dicionário para entradas (nome -> símbolo), um ponteiro/referência para o escopo pai e um nome para identificação.",
                                    "Implemente um construtor que inicialize o mapa vazio e aponte para o escopo pai (null para global).",
                                    "Crie um escopo global como raiz da hierarquia.",
                                    "Adicione métodos auxiliares como getParent() e isGlobal().",
                                    "Teste a criação de escopos aninhados manualmente."
                                  ],
                                  "verification": "Verifique se pode criar uma cadeia de escopos pai-filho e acessar corretamente o pai sem erros.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Editor de código (VS Code ou similar), linguagem de programação com suporte a classes (Python, Java ou C++)",
                                  "tips": "Use dicionários/hashtables para buscas O(1) no escopo atual.",
                                  "learningObjective": "Compreender e modelar hierarquias de escopos como árvores.",
                                  "commonMistakes": "Esquecer de lidar com escopo global sem pai; usar listas em vez de mapas para entradas."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar busca no escopo atual",
                                  "subSteps": [
                                    "Defina uma função lookupLocal(String identifier) que retorne o símbolo se existir no mapa atual, ou null.",
                                    "Garanta que a busca seja case-sensitive ou conforme a regra da linguagem simulada.",
                                    "Trate identificadores vazios ou nulos retornando erro imediato.",
                                    "Adicione logging para depuração, mostrando o escopo atual e identificador procurado.",
                                    "Teste com entradas existentes e inexistentes no escopo atual."
                                  ],
                                  "verification": "Chame lookupLocal em um escopo com e sem a entrada; confirme retornos corretos.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Código do Step 1, exemplos de símbolos (variáveis, funções)",
                                  "tips": "Sempre verifique null antes de acessar o mapa para evitar exceções.",
                                  "learningObjective": "Dominar busca eficiente em estruturas locais de símbolos.",
                                  "commonMistakes": "Ignorar distinção entre case upper/lower; retornar pai em vez de null."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar busca hierárquica subindo escopos",
                                  "subSteps": [
                                    "Crie a função principal lookup(String identifier) que chama lookupLocal primeiro.",
                                    "Se não encontrado localmente e há pai, chame recursivamente lookup no pai.",
                                    "Pare na recursão se escopo pai for null (global não encontrou).",
                                    "Retorne o símbolo encontrado mais próximo ou lance/signalize 'UndeclaredIdentifierException'.",
                                    "Otimize para evitar recursão profunda adicionando limite ou iterativo com loop."
                                  ],
                                  "verification": "Teste com identificador em escopo local, pai e ausente em toda hierarquia.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Código dos Steps 1-2, casos de teste com hierarquia de 3+ escopos",
                                  "tips": "Prefira abordagem iterativa para evitar stack overflow em hierarquias profundas.",
                                  "learningObjective": "Implementar resolução de escopos com shadowing hierárquico.",
                                  "commonMistakes": "Loop infinito sem check de pai null; retornar entrada errada de escopo distante."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Testar e refinar a busca completa",
                                  "subSteps": [
                                    "Crie uma hierarquia de teste: global com 'x', função com 'y' sombreando 'x', bloco com 'z'.",
                                    "Execute lookups para 'x', 'y', 'z' de diferentes escopos e valide resultados.",
                                    "Adicione tratamento de exceções para undeclared e logs de caminho de busca.",
                                    "Meça performance com 100 lookups em hierarquia profunda.",
                                    "Refatore para clareza e adicione documentação inline."
                                  ],
                                  "verification": "Todos testes passam sem exceções inesperadas e resultados corretos.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Framework de testes (unittest em Python), código completo",
                                  "tips": "Use asserts para verificar não só achou, mas o escopo correto.",
                                  "learningObjective": "Validar robustez da implementação em cenários reais.",
                                  "commonMistakes": "Não testar shadowing (declaração local ocultando pai); ignorar escopo global."
                                }
                              ],
                              "practicalExample": "Em Python: class Scope: def __init__(self, parent=None): self.entries = {}; self.parent = parent; def lookup(self, id): if id in self.entries: return self.entries[id]; if self.parent: return self.parent.lookup(id); raise UndeclaredIdentifier(id). Teste: global = Scope(); global.entries['pi'] = 3.14; func = Scope(global); func.entries['x'] = 10; print(func.lookup('pi'))  # 3.14; print(func.lookup('x'))  # 10; print(func.lookup('missing'))  # Erro",
                              "finalVerifications": [
                                "Busca retorna entrada local corretamente, ignorando pais.",
                                "Busca sobe hierarquia e retorna entrada mais próxima (shadowing funciona).",
                                "Sinaliza undeclared após checar toda cadeia até global.",
                                "Sem recursão infinita ou stack overflow em 10+ níveis.",
                                "Performance O(profundidade) em pior caso.",
                                "Logs mostram caminho exato da busca."
                              ],
                              "assessmentCriteria": [
                                "Correção: 100% dos testes passam incluindo shadowing e undeclared.",
                                "Eficiência: Busca local O(1), hierárquica O(profundidade).",
                                "Robustez: Trata nulls, vazios e hierarquias vazias.",
                                "Clareza: Código legível com comentários e nomes descritivos.",
                                "Extensibilidade: Fácil adicionar features como escopos múltiplos.",
                                "Documentação: Inline docs explicam lógica de subida."
                              ],
                              "crossCurricularConnections": [
                                "Estruturas de Dados: Árvores e travessia DFS para hierarquias.",
                                "Algoritmos: Recursão vs iteração em grafos acíclicos.",
                                "Linguagens de Programação: Namespaces e resolução de símbolos em Python/Java.",
                                "Debugging: Tracing de stack para depuração de compiladores."
                              ],
                              "realWorldApplication": "Em compiladores como GCC/Clang para C++, resolve variáveis em blocos/funções; em interpreters de JS/Python para closures e léxico scoping; ferramentas como linters (ESLint) para detectar undeclared vars."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.5.2.2",
                            "name": "Otimizar busca com hash",
                            "description": "Desenvolver pseudocódigo para busca O(1) médio em tabela hash, comparando chaves e retornando ponteiro para atributos do símbolo encontrado.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender Fundamentos de Tabelas Hash",
                                  "subSteps": [
                                    "Defina o que é uma tabela hash e sua estrutura básica (array de listas ou buckets).",
                                    "Explique propriedades de uma boa função de hash: uniformidade, determinismo e avalanche effect.",
                                    "Discuta colisões e métodos de resolução como chaining (listas encadeadas).",
                                    "Calcule complexidade: O(1) médio para busca com load factor baixo.",
                                    "Esboce uma tabela hash vazia com tamanho 10 e exemplo de inserção."
                                  ],
                                  "verification": "Desenhe uma tabela hash com 3 entradas e identifique o bucket de uma chave dada.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Editor de texto para anotações"
                                  ],
                                  "tips": "Use funções hash simples como djb2 para strings iniciais.",
                                  "learningObjective": "Entender como tabelas hash alcançam O(1) médio para buscas.",
                                  "commonMistakes": [
                                    "Confundir O(1) médio com O(1) pior caso",
                                    "Ignorar tratamento de colisões"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Projetar Função de Hash para Chaves de Símbolos",
                                  "subSteps": [
                                    "Identifique chaves típicas em tabelas de símbolos: strings como nomes de variáveis ('main', 'x').",
                                    "Implemente uma função hash simples para strings: somar valores ASCII modularizados pelo tamanho da tabela.",
                                    "Teste a função com exemplos: hash('main') % 11 = ?",
                                    "Ajuste para evitar clusters: adicione multiplicação por primo.",
                                    "Defina tamanho da tabela como primo (ex: 11, 17)."
                                  ],
                                  "verification": "Compute hash para 5 chaves diferentes e confirme distribuição uniforme.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Calculadora",
                                    "Editor de código para protótipo"
                                  ],
                                  "tips": "Escolha primo próximo ao número esperado de símbolos para minimizar colisões.",
                                  "learningObjective": "Criar uma função de hash eficaz para identificadores de programação.",
                                  "commonMistakes": [
                                    "Não usar módulo pelo tamanho da tabela",
                                    "Hash não sensível a maiúsculas/minúsculas"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Desenvolver Pseudocódigo de Busca Otimizada",
                                  "subSteps": [
                                    "Escreva função search(key): compute hash(key) % size → index.",
                                    "Percorra a cadeia no bucket[index]: compare entry.key == key.",
                                    "Se igual, retorne entry.pointerToAttributes; senão, continue até null.",
                                    "Se fim da cadeia sem match, retorne null.",
                                    "Inclua comentário sobre comparação exata de chaves."
                                  ],
                                  "verification": "Simule busca manual em tabela desenhada com 4 entradas.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Editor de texto",
                                    "Papel para simulação"
                                  ],
                                  "tips": "Use ponteiro como referência para atributos (tipo, escopo, linha).",
                                  "learningObjective": "Escrever pseudocódigo que realize busca O(1) médio retornando ponteiro.",
                                  "commonMistakes": [
                                    "Comparar ponteiros em vez de chaves",
                                    "Não percorrer toda a cadeia"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar Complexidade e Testar Casos Edge",
                                  "subSteps": [
                                    "Analise tempo médio: 1 hash + load_factor comparações.",
                                    "Teste casos: chave existente no primeiro/last da cadeia, não existente, tabela vazia.",
                                    "Meça load factor: símbolos / tamanho < 0.7.",
                                    "Otimize: rehash se load alto (opcional para busca).",
                                    "Documente análise de complexidade em comentários."
                                  ],
                                  "verification": "Execute simulações para 3 casos edge e confirme retornos corretos.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Planilha para tracking de testes",
                                    "Pseudocódigo do step 3"
                                  ],
                                  "tips": "Registre número de comparações por busca para validar O(1).",
                                  "learningObjective": "Validar otimização e robustez da busca em cenários reais.",
                                  "commonMistakes": [
                                    "Ignorar colisões em análise de complexidade",
                                    "Retornar índice em vez de ponteiro"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um compilador simples, tabela hash tamanho 17 com símbolos 'int' (hash=5, attrs: tipo inteiro), 'main' (hash=12, attrs: função). Busca('main'): index=12, cadeia tem 'main'→ retorna ponteiro para {tipo: 'function', escopo: global, linha: 1}.",
                              "finalVerifications": [
                                "Pseudocódigo implementa hash → index → busca em cadeia?",
                                "Compara chaves corretamente e retorna ponteiro ou null?",
                                "Simulações de busca executam em <5 comparações médio?",
                                "Load factor considerado para O(1)?",
                                "Casos edge (não encontrado, vazio) tratados?",
                                "Comentários explicam complexidade."
                              ],
                              "assessmentCriteria": [
                                "Função hash distribui uniformemente (teste com 10 chaves).",
                                "Pseudocódigo usa chaining para colisões.",
                                "Busca compara chaves exatas e retorna ponteiro para atributos.",
                                "Análise prova O(1) médio com justificativa.",
                                "Tratamento completo de casos edge.",
                                "Clareza e estrutura do pseudocódigo."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Aritmética modular e propriedades de funções hash.",
                                "Algoritmos: Análise assintótica de estruturas de dados.",
                                "Engenharia de Software: Otimização de performance em compiladores.",
                                "Banco de Dados: Indexing com hash tables em consultas SQL."
                              ],
                              "realWorldApplication": "Em compiladores como GCC ou LLVM, tabelas de hash otimizam buscas de símbolos durante análise léxica/sintática, permitindo compilação rápida de milhões de linhas de código."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.5.2.3",
                            "name": "Aplicar busca em análise semântica",
                            "description": "Exemplificar uso de busca para resolver referências em expressões, recuperando tipo e localização para verificações de compatibilidade.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o papel da busca em tabelas de símbolos na análise semântica",
                                  "subSteps": [
                                    "Estude a estrutura básica de uma tabela de símbolos, incluindo campos como nome, tipo, escopo e localização.",
                                    "Revise conceitos de escopos aninhados e hierarquia de namespaces em linguagens de programação.",
                                    "Analise exemplos de expressões com referências ambíguas para identificar a necessidade de busca.",
                                    "Desenhe um diagrama de fluxo mostrando quando a busca é acionada durante a análise semântica.",
                                    "Compare busca linear vs. busca em árvore para eficiência em compiladores."
                                  ],
                                  "verification": "Crie um diagrama anotado explicando o fluxo de busca e discuta com um par ou tutor.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Documentação de compiladores (ex: Dragon Book), diagramas de tabelas de símbolos, editor de diagramas como Draw.io.",
                                  "tips": "Comece com escopos globais e locais para visualizar aninhamento.",
                                  "learningObjective": "Explicar o propósito e o momento da busca em análise semântica.",
                                  "commonMistakes": "Confundir busca léxica com semântica; ignorar escopos dinâmicos."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar e parsear referências em expressões",
                                  "subSteps": [
                                    "Parseie uma expressão AST (Abstract Syntax Tree) para localizar nós de identificadores.",
                                    "Marque referências não resolvidas em expressões como 'x + y' ou 'func(a.b)'.",
                                    "Registre o contexto atual (escopo) e posição no código fonte para cada referência.",
                                    "Implemente um visitor pattern para percorrer a AST e coletar referências.",
                                    "Teste com expressões simples e compostas para validar identificação."
                                  ],
                                  "verification": "Gere uma lista de referências identificadas de um snippet de código e verifique manualmente.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Código fonte de exemplo em C ou Java, parser gerado (ex: ANTLR), debugger de AST.",
                                  "tips": "Use impressões de depuração para rastrear nós visitados na AST.",
                                  "learningObjective": "Localizar precisamente referências que requerem resolução via busca.",
                                  "commonMistakes": "Perder referências qualificadas como 'obj.field'; ignorar literais vs. identificadores."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Executar a busca na tabela de símbolos",
                                  "subSteps": [
                                    "Inicie busca no escopo atual e suba hierarquicamente até o escopo global.",
                                    "Implemente função de busca que retorna a entrada correspondente ou null.",
                                    "Lide com sobrecargas (overloading) comparando assinaturas de tipos.",
                                    "Atualize a entrada encontrada com metadados como tipo e offset de memória.",
                                    "Otimize com cache para buscas repetidas no mesmo escopo."
                                  ],
                                  "verification": "Execute busca em um escopo aninhado e confirme que retorna a entrada correta sem ambiguidades.",
                                  "estimatedTime": "90 minutos",
                                  "materials": "Implementação de tabela de símbolos em Python/Java, exemplos de código com escopos.",
                                  "tips": "Simule com prints o caminho de busca: 'Buscando em escopo local -> pai -> global'.",
                                  "learningObjective": "Realizar busca eficiente recuperando tipo e localização corretos.",
                                  "commonMistakes": "Parar na primeira match sem checar escopo; não lidar com shadowing de nomes."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar resultados da busca para verificações de compatibilidade",
                                  "subSteps": [
                                    "Recupere tipo e localização da entrada encontrada para cada operando.",
                                    "Implemente regras de type checking (ex: int + int -> int; int + string -> erro).",
                                    "Gere erros semânticos se tipos incompatíveis ou não encontrados.",
                                    "Atualize a AST com tipos resolvidos para fases posteriores (código geração).",
                                    "Teste casos de borda como undeclared variables ou type mismatches."
                                  ],
                                  "verification": "Compile um programa com erros intencionais e valide que erros são reportados corretamente.",
                                  "estimatedTime": "75 minutos",
                                  "materials": "Compilador toy ou fase semântica customizada, testes unitários para type checker.",
                                  "tips": "Defina um enum para tipos e uma tabela de compatibilidade para simplificar checks.",
                                  "learningObjective": "Usar resultados da busca para validações semânticas precisas.",
                                  "commonMistakes": "Assumir tipos sem verificação; propagar erros incorretos na AST."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Integrar e testar o fluxo completo de busca em análise semântica",
                                  "subSteps": [
                                    "Conecte identificação, busca e verificação em um pipeline semântico.",
                                    "Crie testes abrangentes: casos válidos, inválidos e de performance.",
                                    "Meça tempo de busca em programas maiores e otimize se necessário.",
                                    "Documente o processo com comentários no código.",
                                    "Execute em um compilador real ou toy para validação end-to-end."
                                  ],
                                  "verification": "Passe um conjunto de 10 programas de teste, com 100% de detecção de erros semânticos.",
                                  "estimatedTime": "120 minutos",
                                  "materials": "Suite de testes, profiler de performance, código fonte de compilador exemplo (ex: LLVM tutorial).",
                                  "tips": "Use assertions em testes para automação.",
                                  "learningObjective": "Implementar e validar um sistema completo de resolução semântica via busca.",
                                  "commonMistakes": "Não testar escopos profundos; ignorar performance em buscas frequentes."
                                }
                              ],
                              "practicalExample": "Em um compilador para uma linguagem simples, considere o código: int x = 5; { float y = 3.14; z = x + y; } A busca para 'x' no escopo local falha, sobe para global (tipo int, loc=0x100), 'y' local (float, loc=0x200), então verifica compatibilidade int+float -> promove para float, mas se 'z' for int gera erro de atribuição incompatível.",
                              "finalVerifications": [
                                "Resolve corretamente identificadores em escopos aninhados sem ambiguidades.",
                                "Recupera tipo e localização precisos para todos os referenciados.",
                                "Detecta e reporta 100% dos erros de tipo incompatível em expressões.",
                                "Atualiza AST com metadados semânticos para fases subsequentes.",
                                "Mantém performance aceitável (busca <1ms por identificador em programas médios).",
                                "Lida com sobrecargas e shadowing adequadamente."
                              ],
                              "assessmentCriteria": [
                                "Precisão na resolução de referências (90%+ em testes).",
                                "Correção das verificações de compatibilidade (sem falsos positivos/negativos).",
                                "Eficiência da implementação de busca (O(1) médio com hash ou árvore).",
                                "Qualidade da documentação e tratamento de erros.",
                                "Capacidade de integrar em pipeline semântico completo.",
                                "Criatividade em handling de casos edge (ex: recursão infinita em escopos)."
                              ],
                              "crossCurricularConnections": [
                                "Estruturas de Dados: Uso de árvores/hashing para tabelas de símbolos eficientes.",
                                "Bancos de Dados: Analogia com consultas SQL e resolução de nomes em schemas.",
                                "Linguagens Formais: Teoria de tipos e inferência em λ-cálculo.",
                                "Engenharia de Software: Design patterns como Visitor para análise AST."
                              ],
                              "realWorldApplication": "Em compiladores como GCC/Clang, a busca semântica resolve milhões de referências por segundo em projetos grandes como o kernel Linux, habilitando type checking, otimizações e autocompletar em IDEs como VS Code ou IntelliJ."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.3.5.3",
                        "name": "Atualização de Entradas",
                        "description": "Modificação de atributos existentes em uma entrada da tabela de símbolos, comum na análise semântica para inferência de tipos, endereços ou outros metadados após declarações iniciais.",
                        "specificSkills": [
                          {
                            "id": "10.1.3.5.3.1",
                            "name": "Localizar e modificar atributos",
                            "description": "Combinar busca com atualização seletiva de campos como 'tipo', 'dimensões' ou 'endereço', garantindo atomicidade da operação.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a Estrutura da Tabela de Símbolos e Entradas",
                                  "subSteps": [
                                    "Estude a definição da estrutura de dados da tabela de símbolos (ex: hash table com entradas contendo nome, tipo, dimensões, endereço, escopo).",
                                    "Identifique atributos mutáveis como 'tipo', 'dimensões' e 'endereço'.",
                                    "Revise regras de atomicidade: operações devem ser indivisíveis e thread-safe se aplicável.",
                                    "Analise exemplos de entradas antes e depois de modificações.",
                                    "Documente os campos imutáveis (ex: nome do símbolo) para evitar alterações acidentais."
                                  ],
                                  "verification": "Crie um diagrama UML ou JSON schema da estrutura e liste atributos mutáveis.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Documentação do compilador",
                                    "Exemplos de código fonte da tabela de símbolos"
                                  ],
                                  "tips": [
                                    "Priorize atributos com ponteiros ou unions para modificações seguras.",
                                    "Use typedefs para clareza na estrutura."
                                  ],
                                  "learningObjective": "Dominar a anatomia das entradas para buscas e updates precisos.",
                                  "commonMistakes": [
                                    "Alterar campos imutáveis como 'nome'.",
                                    "Ignorar dependências entre atributos (ex: dimensões com tipo array)."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar a Localização da Entrada Específica",
                                  "subSteps": [
                                    "Defina a chave de busca (geralmente o nome do símbolo + escopo).",
                                    "Implemente a função de busca (ex: hash_lookup(key) retornando ponteiro para entrada).",
                                    "Trate casos de falha: símbolo não encontrado (retorne NULL ou erro).",
                                    "Teste a busca com chaves conhecidas presentes e ausentes.",
                                    "Otimize para eficiência O(1) médio em hash tables, lidando com colisões."
                                  ],
                                  "verification": "Execute testes unitários: busque 5 símbolos e confirme ponteiro retornado.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Código da tabela de símbolos",
                                    "Ferramentas de teste unitário (ex: Unity, Google Test)"
                                  ],
                                  "tips": [
                                    "Use escopo hierárquico para buscas nested.",
                                    "Cache resultados frequentes para performance."
                                  ],
                                  "learningObjective": "Executar buscas precisas e eficientes na tabela.",
                                  "commonMistakes": [
                                    "Não considerar escopo (busca global em local).",
                                    "Ignorar colisões de hash levando a falsos positivos."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Executar Modificação Seletiva dos Atributos",
                                  "subSteps": [
                                    "Verifique se ponteiro da entrada é válido (não NULL).",
                                    "Atualize apenas atributos alvo: ex: entry->tipo = novo_tipo; entry->dimensoes = novo_array;",
                                    "Mantenha atomicidade com locks ou transações (ex: mutex_lock() antes, unlock() após).",
                                    "Copie entrada original para rollback se necessário.",
                                    "Atualize dependências (ex: recalcular tamanho se dimensões mudam)."
                                  ],
                                  "verification": "Compare entry antes/depois: apenas atributos alvo alterados.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Código fonte da função update",
                                    "Debugger (GDB ou IDE)"
                                  ],
                                  "tips": [
                                    "Use funções setter encapsuladas para validações.",
                                    "Evite raw pointers; prefira smart pointers."
                                  ],
                                  "learningObjective": "Modificar seletivamente sem corromper a estrutura.",
                                  "commonMistakes": [
                                    "Atualizar todos os campos em vez de seletivos.",
                                    "Esquecer unlock levando a deadlocks."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Validar Atomicidade e Consistência Final",
                                  "subSteps": [
                                    "Execute verificações pós-update: hash da entrada inalterado exceto atributos.",
                                    "Teste concorrência se multi-threaded (ex: múltiplas threads atualizando).",
                                    "Registre logs ou asserts para auditoria.",
                                    "Simule falhas (ex: segfault) e confirme rollback.",
                                    "Re-busque a entrada para confirmar persistência."
                                  ],
                                  "verification": "Todos os testes de regressão passam sem corrupções.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Suite de testes de integração",
                                    "Ferramentas de profiling (Valgrind)"
                                  ],
                                  "tips": [
                                    "Use compare-and-swap (CAS) para atomicidade lock-free.",
                                    "Monitore memory leaks pós-update."
                                  ],
                                  "learningObjective": "Garantir operações atômicas e robustas.",
                                  "commonMistakes": [
                                    "Não testar cenários de falha.",
                                    "Assumir single-threaded em ambientes multi-thread."
                                  ]
                                }
                              ],
                              "practicalExample": "Em um compilador para MiniC, localize o símbolo 'foto' no escopo global via hash_lookup('foto', global_scope), modifique entry->tipo de 'int' para 'Image*' e entry->dimensoes para {1920, 1080}, mantendo entry->endereco inalterado, tudo dentro de um mutex para atomicidade.",
                              "finalVerifications": [
                                "Entrada localizada corretamente pelo nome e escopo.",
                                "Apenas atributos especificados ('tipo', 'dimensões') foram alterados.",
                                "Atomicidade confirmada: nenhuma operação parcial em falhas.",
                                "Tabela de símbolos permanece consistente (sem duplicatas ou vazios).",
                                "Re-busca retorna valores atualizados.",
                                "Sem memory leaks ou corrupções detectadas por Valgrind.",
                                "Logs auditam a operação com timestamps."
                              ],
                              "assessmentCriteria": [
                                "Eficiência da busca: O(1) médio comprovado por profiling.",
                                "Seletividade: 100% dos testes confirmam apenas campos alvo alterados.",
                                "Atomicidade: testes de concorrência passam sem races.",
                                "Robustez: lida com entradas não encontradas sem crashes.",
                                "Clareza: código legível com comentários e funções modulares.",
                                "Escalabilidade: performance estável com 10k+ entradas.",
                                "Documentação: README com exemplos de uso."
                              ],
                              "crossCurricularConnections": [
                                "Banco de Dados: Equivalente a SQL UPDATE com WHERE por chave primária.",
                                "Algoritmos e Estruturas: Hash tables e gerenciamento de colisões.",
                                "Programação Concorrente: Mutexes e transações ACID.",
                                "Engenharia de Software: Refatoração segura em IDEs.",
                                "Sistemas Operacionais: Gerenciamento de memória e ponteiros."
                              ],
                              "realWorldApplication": "Em compiladores como GCC ou Clang, atualiza atributos de símbolos durante inferência de tipos ou otimizações de código; em IDEs como VS Code, suporta refactoring atômico de variáveis sem quebrar referências, prevenindo bugs em grandes codebases."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.3.5.2.1"
                            ]
                          },
                          {
                            "id": "10.1.3.5.3.2",
                            "name": "Atualizar em múltiplos escopos",
                            "description": "Gerenciar atualizações propagadas ou locais em escopos aninhados, como shadowing de variáveis, sem afetar entradas ocultas.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender Escopos Aninhados e Shadowing",
                                  "subSteps": [
                                    "Estude a definição de escopo léxico e exemplos em linguagens como C ou Python.",
                                    "Analise exemplos de shadowing, onde uma variável local oculta a global.",
                                    "Diferencie atualizações locais (apenas no escopo atual) de propagadas (afetam escopos ancestrais).",
                                    "Desenhe um diagrama de escopos aninhados com pelo menos 3 níveis."
                                  ],
                                  "verification": "Crie um diagrama manual ou digital mostrando shadowing e rotule entradas ocultas.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Documentação de linguagens (Python/C), papel/caneta ou ferramenta de diagramação como Draw.io.",
                                  "tips": "Use cores diferentes para escopos pai e filho para visualizar melhor a hierarquia.",
                                  "learningObjective": "Identificar e diferenciar tipos de escopos e impactos de shadowing em atualizações.",
                                  "commonMistakes": "Confundir shadowing com redefinição global, assumindo propagação automática."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar Estrutura de Dados para Tabelas de Símbolos",
                                  "subSteps": [
                                    "Defina uma classe ou estrutura para Scope com mapa de símbolos (nome -> entrada) e ponteiro para escopo pai.",
                                    "Crie uma classe Entry com campos como nome, tipo, valor e flags (local/propagada).",
                                    "Implemente construtor para criar escopo raiz e escopos filhos aninhados.",
                                    "Adicione método para inserir símbolo novo, detectando shadowing."
                                  ],
                                  "verification": "Construa uma tabela com 3 escopos aninhados e insira 5 símbolos, imprimindo a hierarquia.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Editor de código (VS Code), linguagem orientada a objetos (Python/JavaScript).",
                                  "tips": "Use dicionários/hashtables para o mapa de símbolos por eficiência O(1).",
                                  "learningObjective": "Modelar tabelas de símbolos que suportem navegação hierárquica.",
                                  "commonMistakes": "Esquecer o ponteiro para escopo pai, impedindo busca recursiva."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Desenvolver Algoritmo de Busca em Múltiplos Escopos",
                                  "subSteps": [
                                    "Implemente função lookup(nome) que busca do escopo atual para cima até encontrar ou raiz.",
                                    "Retorne a Entry do escopo mais interno (respeitando shadowing).",
                                    "Teste com casos onde símbolo existe em múltiplos escopos.",
                                    "Adicione log para rastrear caminho de busca."
                                  ],
                                  "verification": "Execute lookup em cenários de shadowing e confirme que retorna a entrada local correta.",
                                  "estimatedTime": "50 minutos",
                                  "materials": "Código da estrutura anterior, testes unitários (pytest/Jest).",
                                  "tips": "Implemente recursão ou loop while (pai != null) para evitar stack overflow em profundidade alta.",
                                  "learningObjective": "Localizar entradas corretas em hierarquias de escopos sem acessar ocultas.",
                                  "commonMistakes": "Parar na primeira ocorrência sem priorizar o escopo mais interno."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Implementar Operações de Atualização Local e Propagada",
                                  "subSteps": [
                                    "Crie função update(nome, novoValor, modo: 'local' | 'propagada').",
                                    "Para 'local': atualize apenas a Entry encontrada no lookup.",
                                    "Para 'propagada': atualize a Entry no escopo original e propague se flag permitir.",
                                    "Garanta que atualizações não afetem entradas ocultas em escopos paralelos.",
                                    "Adicione validação para entradas inexistentes."
                                  ],
                                  "verification": "Teste updates em shadowing: local não afeta pai, propagada sim se configurado.",
                                  "estimatedTime": "70 minutos",
                                  "materials": "Código completo anterior, framework de testes.",
                                  "tips": "Use um flag 'propagable' na Entry para controlar propagação seletiva.",
                                  "learningObjective": "Gerenciar atualizações seletivas sem colisões em escopos aninhados.",
                                  "commonMistakes": "Propagar sempre, alterando shadowed entries acidentalmente."
                                }
                              ],
                              "practicalExample": "Em um compilador para uma linguagem como Python, ao processar 'x = 10' dentro de uma função (escopo filho), lookup encontra x local (shadowing x global=5). Update local altera apenas x filho para 10, sem tocar global. Para propagada (raro, ex: módulos dinâmicos), atualiza ambos se flag ativado.",
                              "finalVerifications": [
                                "Diagrama de escopos mostra hierarquia correta com shadowing.",
                                "Código lookup retorna Entry do escopo interno em 100% dos testes.",
                                "Update local afeta apenas target, propagada respeita flags.",
                                "Nenhuma entrada oculta é alterada em testes de isolamento.",
                                "Logs de busca/update confirmam caminhos corretos."
                              ],
                              "assessmentCriteria": [
                                "Correção do lookup em escopos aninhados (40%)",
                                "Implementação precisa de updates local/propagada (30%)",
                                "Tratamento de shadowing sem vazamentos (15%)",
                                "Eficiência e ausência de loops infinitos (10%)",
                                "Cobertura de testes com casos edge (5%)"
                              ],
                              "crossCurricularConnections": [
                                "Estruturas de Dados: Árvores e navegação recursiva",
                                "Lógica de Programação: Condicionais e recursão",
                                "Análise Semântica: Similar a parsing em NLP",
                                "Banco de Dados: Transações em esquemas hierárquicos"
                              ],
                              "realWorldApplication": "Em compiladores (GCC, LLVM) para análise semântica e otimização; IDEs como VS Code para refactoring seguro de variáveis; interpreters dinâmicos em JavaScript engines (V8) gerenciando closures e hoisting."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.5.3.3",
                            "name": "Exemplificar em geração de código",
                            "description": "Demonstrar atualização de 'endereço de memória' após alocação durante geração de código intermediário.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Conceitos de Tabela de Símbolos e Alocação de Memória",
                                  "subSteps": [
                                    "Estude a estrutura básica de uma tabela de símbolos, incluindo campos como nome, tipo, escopo e endereço de memória.",
                                    "Entenda o processo de alocação de memória durante a análise semântica: stack para variáveis locais, heap para dinâmicas.",
                                    "Identifique quando o endereço de memória é atribuído: após declaração de variáveis em blocos.",
                                    "Revise código intermediário (ex: three-address code) e como ele referencia endereços.",
                                    "Anote diferenças entre endereços relativos e absolutos em compiladores."
                                  ],
                                  "verification": "Crie um diagrama da tabela de símbolos vazia e preencha com 3 entradas fictícias, incluindo campo endereço inicial como 'não alocado'.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Livro de compiladores (ex: Dragon Book), slides sobre tabelas de símbolos, editor de texto para diagramas.",
                                  "tips": "Use tabelas Markdown para visualizar entradas da tabela de símbolos.",
                                  "learningObjective": "Compreender o papel da tabela de símbolos na geração de código e o timing da alocação de endereços.",
                                  "commonMistakes": "Confundir alocação estática com dinâmica; ignorar escopo hierárquico."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Selecionar e Analisar um Exemplo de Código Fonte Simples",
                                  "subSteps": [
                                    "Escolha um programa fonte curto em uma linguagem como C: ex. int x = 5; int y = x + 1; com 2-3 variáveis.",
                                    "Parse manualmente o código para identificar declarações de variáveis e blocos.",
                                    "Liste todas as variáveis e seus escopos na tabela de símbolos inicial (endereços vazios).",
                                    "Simule a passagem pela árvore sintática, marcando pontos de alocação.",
                                    "Calcule offsets iniciais: assumir alinhamento de 4 bytes para ints."
                                  ],
                                  "verification": "Escreva o código fonte e a tabela de símbolos inicial com nomes, tipos e endereços 'TBD'.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Editor de código (VS Code), papel e caneta para parsing manual.",
                                  "tips": "Comece com código linear sem loops para simplificar.",
                                  "learningObjective": "Preparar um caso de teste concreto para demonstrar atualizações.",
                                  "commonMistakes": "Esquecer variáveis em escopos aninhados; não considerar tamanho do tipo."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Simular Alocação e Atualizar Endereços na Tabela",
                                  "subSteps": [
                                    "Inicie um contador de offset (ex: base = 0 para main).",
                                    "Para cada variável declarada, aloque espaço (ex: +4 para int), atualize endereço = base + offset, incremente offset.",
                                    "Registre a tabela após cada alocação, mostrando mudança de 'não alocado' para valor específico (ex: 0x1004).",
                                    "Trate múltiplos blocos: salve base atual, restaure ao sair do bloco.",
                                    "Valide alinhamentos e padding se aplicável."
                                  ],
                                  "verification": "Mostre tabelas antes/depois da alocação para todas variáveis, com endereços atualizados.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Planilha Excel/Google Sheets para simular tabela, calculadora para offsets.",
                                  "tips": "Use hexadecimal para endereços realistas.",
                                  "learningObjective": "Executar a lógica de alocação e atualização passo a passo.",
                                  "commonMistakes": "Não resetar offset ao sair de blocos; alocar em ordem errada (use ordem de declaração)."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Gerar Código Intermediário e Demonstrar Uso dos Endereços",
                                  "subSteps": [
                                    "Gere three-address code para o exemplo: ex. t1 = x + 1; y = t1.",
                                    "Substitua referências simbólicas por endereços reais da tabela (ex. LOAD R1, [0x1000]).",
                                    "Inclua instruções de alocação se necessário (ex. em registradores ou memória).",
                                    "Compare código intermediário com/ sem endereços atualizados.",
                                    "Explique como o código assembly final usaria esses endereços."
                                  ],
                                  "verification": "Escreva o código intermediário completo usando os endereços atualizados da tabela.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Ferramenta online de simulador de compilador (ex: onlinegdb), pseudocódigo template.",
                                  "tips": "Use notação como @endereco para temporários.",
                                  "learningObjective": "Integrar tabela atualizada na geração de código prático.",
                                  "commonMistakes": "Referenciar endereços errados; esquecer temporários."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Documentar e Apresentar a Demonstração Completa",
                                  "subSteps": [
                                    "Compile todas as tabelas (inicial, intermediárias, final) em um relatório.",
                                    "Crie um fluxograma: código fonte -> análise -> alocação -> tabela atualizada -> código intermediário.",
                                    "Grave uma explicação oral ou escrita passo a passo.",
                                    "Teste com variação: adicione array ou função para validar generalidade.",
                                    "Revise por erros e refine."
                                  ],
                                  "verification": "Produza um documento PDF ou Markdown com exemplo completo e fluxograma.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Ferramenta de diagrama (Draw.io), Markdown editor.",
                                  "tips": "Mantenha visual: use cores para 'antes/depois'.",
                                  "learningObjective": "Sintetizar o processo em uma exemplificação clara e comunicável.",
                                  "commonMistakes": "Explicação muito técnica sem passos visuais; inconsistências nos endereços."
                                }
                              ],
                              "practicalExample": "Código C: int main() { int x = 5; int y = x + 1; return y; }\nTabela inicial: x (int, addr=TBD), y (int, addr=TBD)\nApós alocação: x (int, addr=0x1000), y (int, addr=0x1004)\nCódigo intermediário: LOAD R1, 5; STORE R1, [0x1000]; LOAD R2, [0x1000]; ADD R2, 1; STORE R2, [0x1004];",
                              "finalVerifications": [
                                "Tabela de símbolos final mostra endereços corretamente atualizados e sequenciais.",
                                "Código intermediário usa endereços exatos da tabela sem erros de referência.",
                                "Explicação oral demonstra o 'por quê' da atualização (evitar sobreposição de memória).",
                                "Variação com escopo aninhado mantém offsets corretos.",
                                "Fluxograma cobre todo o pipeline sem lacunas.",
                                "Nenhum erro comum detectado na simulação manual."
                              ],
                              "assessmentCriteria": [
                                "Precisão na alocação de offsets e endereços (100% corretos).",
                                "Clareza na documentação: tabelas e código legíveis (visuais auxiliares).",
                                "Completude: todos passos do processo cobertos.",
                                "Generalidade: exemplo extensível a casos mais complexos.",
                                "Comunicação: explicação fluida e didática.",
                                "Criatividade: uso de ferramentas visuais eficazes."
                              ],
                              "crossCurricularConnections": [
                                "Arquitetura de Computadores: mapeamento para registradores e memória real.",
                                "Programação: depuração de ponteiros e alocações manuais em C.",
                                "Matemática: cálculos de offsets e alinhamento binário.",
                                "Engenharia de Software: otimização de layout de dados em compiladores."
                              ],
                              "realWorldApplication": "Em compiladores como GCC ou LLVM, essa atualização garante código assembly eficiente sem overlaps de memória, essencial para performance em aplicações como jogos (Unity) ou sistemas embarcados (Arduino), onde memória é limitada."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.3.5.4",
                        "name": "Remoção de Entradas",
                        "description": "Eliminação de entradas ao final de um escopo para gerenciar memória e visibilidade, tipicamente no fim de blocos ou funções na análise sintática.",
                        "specificSkills": [
                          {
                            "id": "10.1.3.5.4.1",
                            "name": "Implementar remoção por escopo",
                            "description": "Desenvolver lógica para remover todas as entradas de um escopo específico ao sair de um bloco, usando pilha de escopos ou listas encadeadas.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender e Configurar Estrutura de Escopos com Pilha",
                                  "subSteps": [
                                    "Revise a estrutura atual da tabela de símbolos, confirmando uso de pilha de escopos ou listas encadeadas.",
                                    "Defina uma estrutura para representar um escopo: lista de entradas (nome, tipo, etc.) e ponteiro para escopo pai.",
                                    "Implemente ou verifique a pilha global de escopos atuais.",
                                    "Crie funções auxiliares para push de novo escopo (ao entrar em bloco)."
                                  ],
                                  "verification": "Compile e execute um teste simples de push de escopo; verifique se novo escopo é adicionado à pilha sem erros.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Editor de código (VS Code), compilador C/C++, diagrama de pilha de escopos.",
                                  "tips": "Use ponteiros para listas encadeadas para eficiência em memória.",
                                  "learningObjective": "Compreender como pilhas modelam escopos aninhados em blocos de código.",
                                  "commonMistakes": "Esquecer de inicializar ponteiro para escopo pai, causando vazamentos de memória."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Projetar Lógica de Remoção por Escopo",
                                  "subSteps": [
                                    "Identifique o escopo atual no topo da pilha.",
                                    "Planeje remoção: libere todas as entradas locais desse escopo (não recursivo, só locais).",
                                    "Defina estratégia: traverse lista de entradas locais e delete cada uma; então pop o escopo da pilha.",
                                    "Considere edge cases: escopo vazio, escopo raiz, múltiplos níveis.",
                                    "Esboce pseudocódigo para função popScope()."
                                  ],
                                  "verification": "Desenhe fluxograma ou pseudocódigo e revise manualmente com exemplos de blocos aninhados.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Papel e caneta ou ferramenta de diagrama (Draw.io), exemplos de código com blocos { }.",
                                  "tips": "Sempre restaure o escopo pai após pop para lookups corretos.",
                                  "learningObjective": "Projetar algoritmos de remoção que preservem integridade da tabela de símbolos.",
                                  "commonMistakes": "Remover entradas do escopo pai acidentalmente, quebrando visibilidade."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar Função de Remoção por Escopo",
                                  "subSteps": [
                                    "Codifique a função popScope(): acesse topo da pilha, delete entradas locais uma a uma.",
                                    "Use loop para liberar memória de cada entrada (free struct SymbolEntry).",
                                    "Pop o escopo da pilha e retorne ponteiro para novo topo (escopo pai).",
                                    "Integre chamadas em parser: chame popScope() ao encontrar '}' ou fim de bloco.",
                                    "Adicione logs ou prints para depuração de remoções."
                                  ],
                                  "verification": "Compile código; execute parser em código-fonte simples com blocos e verifique logs de remoção.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Editor de código, compilador, código-fonte de teste com blocos aninhados.",
                                  "tips": "Use valgrind ou similar para detectar vazamentos de memória pós-remoção.",
                                  "learningObjective": "Implementar gerenciamento de memória seguro em estruturas dinâmicas.",
                                  "commonMistakes": "Não liberar memória das entradas, causando leaks; ou double-free em ponteiros compartilhados."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Testar e Validar Implementação Completa",
                                  "subSteps": [
                                    "Crie testes unitários: push/pop múltiplos escopos, verifique tamanhos e conteúdos.",
                                    "Teste lookups após pop: confirme que símbolos locais sumiram, mas pai persiste.",
                                    "Simule parser real: processe código com variáveis locais em funções/blocos.",
                                    "Verifique edge cases: pop em escopo vazio, pilha com um só escopo.",
                                    "Meça performance: tempo para pop em escopos grandes (100+ entradas)."
                                  ],
                                  "verification": "Todos testes passam (asserts em tamanhos, conteúdos); sem leaks via valgrind.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Framework de testes (Unity para C), valgrind, scripts de teste automatizados.",
                                  "tips": "Automatize testes com asserts para robustez.",
                                  "learningObjective": "Validar corretude e eficiência através de testes abrangentes.",
                                  "commonMistakes": "Ignorar edge cases como escopo raiz, levando a crashes."
                                }
                              ],
                              "practicalExample": "Em um parser para linguagem simples: ao processar 'int x = 1; { int y = 2; }', push escopo para '{', adicione 'y', pop ao '}', removendo apenas 'y' mas mantendo 'x' visível.",
                              "finalVerifications": [
                                "Pilha de escopos retorna ao estado pai após popScope().",
                                "Nenhuma entrada local permanece após remoção (lookup falha).",
                                "Sem vazamentos de memória (valgrind clean).",
                                "Lookups em escopo pai funcionam corretamente pós-pop.",
                                "Performance aceitável: O(n) para n entradas no escopo.",
                                "Edge cases (escopo vazio, único escopo) não crasham."
                              ],
                              "assessmentCriteria": [
                                "Correção: Todas entradas locais removidas, pai preservado.",
                                "Eficiência: Tempo linear no número de entradas locais.",
                                "Gerenciamento de memória: Sem leaks ou double-frees.",
                                "Integração: Funciona seamless com pushScope e lookups.",
                                "Robustez: Lida com edge cases sem erros.",
                                "Clareza: Código legível com comentários."
                              ],
                              "crossCurricularConnections": [
                                "Estruturas de Dados: Pilhas e listas encadeadas (Ciência da Computação).",
                                "Algoritmos: Gerenciamento de escopos aninhados (Análise de Algoritmos).",
                                "Matemática: Teoria de grafos para dependências de escopos.",
                                "Engenharia de Software: Gerenciamento de recursos e testes unitários."
                              ],
                              "realWorldApplication": "Em compiladores como GCC/Clang, remoção por escopo limpa variáveis locais ao sair de funções/blocos, otimizando memória e garantindo corretude sem conflitos de nomes em programas grandes."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.5.4.2",
                            "name": "Gerenciar remoção em tabelas hash",
                            "description": "Criar pseudocódigo para remoção segura em hash com encadeamento, evitando vazamentos e mantendo integridade da tabela.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Estrutura de Tabelas Hash com Encadeamento",
                                  "subSteps": [
                                    "Estude a estrutura básica: array de buckets, cada bucket aponta para lista encadeada de entradas (chave, valor, próximo).",
                                    "Implemente funções auxiliares de hash: função hash(key) para índice do bucket.",
                                    "Revise busca: compute hash, traverse lista encadeada até encontrar chave exata.",
                                    "Identifique ponteiros next para manter integridade da chain.",
                                    "Desenhe um diagrama simples de uma tabela com 3 buckets e entradas encadeadas."
                                  ],
                                  "verification": "Desenhe e explique um diagrama de tabela hash com pelo menos 2 colisões resolvidas por chaining.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e caneta ou ferramenta de diagramação como draw.io",
                                    "Referência: Algoritmos de Knuth ou CLRS capítulo de Hash Tables"
                                  ],
                                  "tips": "Sempre anote a fórmula da função hash usada para consistência.",
                                  "learningObjective": "Compreender a topologia de tabelas hash com chaining para preparar remoção.",
                                  "commonMistakes": [
                                    "Confundir busca linear com encadeamento",
                                    "Ignorar colisões múltiplas"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar Problemas na Remoção Simples",
                                  "subSteps": [
                                    "Simule remoção ingênua: encontre nó, libere memória, mas observe quebra na chain se não ajustar ponteiros.",
                                    "Discuta vazamentos de memória: se lista alocada dinamicamente, remoção sem free causa leak.",
                                    "Analise cenários: remoção do primeiro nó (ajustar bucket head), nó do meio (ajustar prev->next), último nó.",
                                    "Considere tombstone: marcar como deletado para preservar estrutura de busca.",
                                    "Liste riscos: chain quebrada leva a perda de entradas subsequentes."
                                  ],
                                  "verification": "Liste 3 problemas específicos com código pseudocódigo de remoção falha e explique impactos.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Editor de texto para pseudocódigo",
                                    "Exemplos de código C ou pseudocódigo de hash tables"
                                  ],
                                  "tips": "Use setas para rastrear ponteiros prev e next durante simulação manual.",
                                  "learningObjective": "Reconhecer falhas comuns na remoção para motivar abordagem segura.",
                                  "commonMistakes": [
                                    "Não considerar remoção de head da lista",
                                    "Esquecer free() após unlink"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Desenhar Pseudocódigo de Remoção Segura",
                                  "subSteps": [
                                    "Defina parâmetros: tabela, chave; retorne sucesso/falha.",
                                    "Compute hash(key), acesse bucket, traverse com ponteiro dummy ou prev.",
                                    "Caso encontrado: ajuste ponteiros (se head: bucket = next; else prev->next = current->next), free(current).",
                                    "Opção tombstone: set flag deleted=true sem free, rehash periódico.",
                                    "Adicione checks: chave não encontrada, tabela vazia."
                                  ],
                                  "verification": "Escreva pseudocódigo completo e simule com exemplo de 4 entradas.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Editor de pseudocódigo",
                                    "Referência: Implementação de hash tables em linguagens como Java HashMap remove()"
                                  ],
                                  "tips": "Use ponteiro 'prev' para evitar traverse duplo; inicialize prev = null.",
                                  "learningObjective": "Criar pseudocódigo que remove sem vazamentos ou quebras de chain.",
                                  "commonMistakes": [
                                    "Não nullificar ponteiros após free",
                                    "Loop infinito por ponteiro circular acidental"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Testar e Verificar Integridade Pós-Remoção",
                                  "subSteps": [
                                    "Crie tabela teste com 5 entradas, remova 2 (head, meio, fim).",
                                    "Verifique: busca por restantes retorna correto; contagem de entradas atualizada.",
                                    "Simule load factor: remoção não deve degradar performance de busca.",
                                    "Cheque memória: use valgrind ou contador manual para leaks.",
                                    "Itere tabela pós-remoção para listar todas entradas e confirmar ausência."
                                  ],
                                  "verification": "Execute testes manuais/simulados e liste resultados para cenários de sucesso/falha.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Pseudocódigo implementado",
                                    "Ferramenta de simulação ou código real em C/Python"
                                  ],
                                  "tips": "Teste edge cases: tabela vazia, única entrada, todas colidindo no mesmo bucket.",
                                  "learningObjective": "Garantir que remoção mantém invariantes da tabela hash.",
                                  "commonMistakes": [
                                    "Não testar remoção múltipla sequencial",
                                    "Ignorar rehash após remoções em massa"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um compilador, remova o símbolo 'variavelX' da tabela de símbolos durante otimização: compute hash('variavelX'), traverse chain no bucket 3, unlink nó sem perder símbolos subsequentes como 'variavelY' e 'funcaoZ', free memória do nó.",
                              "finalVerifications": [
                                "Pseudocódigo lida com remoção de head, meio e fim da chain corretamente.",
                                "Busca pós-remoção ignora entrada removida e encontra outras intactas.",
                                "Nenhum vazamento de memória simulado (contadores ou free chamado).",
                                "Estrutura da chain permanece ligada sem nós órfãos.",
                                "Função retorna false graciosamente se chave não existe.",
                                "Load factor e performance de busca mantidos."
                              ],
                              "assessmentCriteria": [
                                "Pseudocódigo cobre todos casos de remoção (head/meio/fim) com ponteiros corretos.",
                                "Evita vazamentos via free() e unlink atômico.",
                                "Mantém integridade: busca/iteração pós-remoção funcionam.",
                                "Clareza e legibilidade do código com comentários em pontos críticos.",
                                "Tratamento de erros (não encontrada, vazia).",
                                "Eficiência: O(1) médio, sem degradação desnecessária."
                              ],
                              "crossCurricularConnections": [
                                "Gerenciamento de Memória (CS Fundamentos): free() e ponteiros dinâmicos.",
                                "Estruturas de Dados: Listas encadeadas e colisões em árvores/dicionários.",
                                "Bancos de Dados: Remoção em índices hash para queries eficientes.",
                                "Compiladores: Tabelas de símbolos dinâmicas em passes de otimização.",
                                "Algoritmos: Análise de worst-case em hashing com deleções."
                              ],
                              "realWorldApplication": "Em compiladores como GCC, remoção segura de símbolos obsoletos em tabelas hash durante análise semântica evita perda de definições e leaks em builds longos; similar em caches Redis ou dicionários Python para garbage collection eficiente."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.3.5.1.2"
                            ]
                          },
                          {
                            "id": "10.1.3.5.4.3",
                            "name": "Tratar erros em remoção",
                            "description": "Integrar tratamento de erros como tentativa de remoção de escopo inexistente, logando para depuração do compilador.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Analisar cenários de erro na remoção de escopos",
                                  "subSteps": [
                                    "Revise o código atual da função de remoção de entradas na tabela de símbolos.",
                                    "Identifique pontos onde um escopo inexistente pode ser tentado remover (ex: chave nula ou ausente).",
                                    "Liste 3-5 cenários comuns de erro, como escopo não declarado ou remoção prematura.",
                                    "Documente o impacto atual: crash, comportamento indefinido ou silêncio.",
                                    "Estude exemplos de tabelas de símbolos em compiladores open-source (ex: LLVM)."
                                  ],
                                  "verification": "Criar um diagrama ou lista documentada dos cenários de erro identificados.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Código fonte da tabela de símbolos",
                                    "IDE com depurador",
                                    "Documentação de compiladores"
                                  ],
                                  "tips": "Use printfs ou breakpoints para simular remoções falhas antes de codificar.",
                                  "learningObjective": "Compreender os pontos de falha na remoção de escopos para preparar tratamento robusto.",
                                  "commonMistakes": [
                                    "Ignorar remoções em escopos aninhados",
                                    "Não considerar escopos vazios"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar verificação de existência do escopo",
                                  "subSteps": [
                                    "Adicione uma consulta prévia à tabela usando a chave do escopo (ex: hashmap.get(key) != null).",
                                    "Retorne um código de erro ou lance exceção se o escopo não existir.",
                                    "Modifique a assinatura da função para retornar bool ou enum de status (sucesso/erro).",
                                    "Atualize chamadas existentes para checar o retorno antes de prosseguir.",
                                    "Teste unitário simples: remova escopo existente e inexistente."
                                  ],
                                  "verification": "Executar teste unitário que falha em remoção inexistente sem crash.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Framework de testes (JUnit ou similar)",
                                    "Código fonte atualizado",
                                    "IDE"
                                  ],
                                  "tips": "Prefira retornar status em vez de exceções para performance em compiladores.",
                                  "learningObjective": "Desenvolver lógica de detecção segura de escopos inexistentes.",
                                  "commonMistakes": [
                                    "Não tratar chaves nulas na consulta",
                                    "Alterar lógica principal sem preservar compatibilidade"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Integrar logging para depuração do compilador",
                                  "subSteps": [
                                    "Escolha uma biblioteca de logging (ex: log4j ou std::log em C++).",
                                    "No bloco de erro, logue detalhes: nome do escopo, linha do código fonte, stack trace parcial.",
                                    "Defina níveis de log: WARN para erros não fatais, ERROR para falhas críticas.",
                                    "Configure logs para saída em arquivo ou console durante compilação.",
                                    "Teste logs em cenários de erro sem interromper a compilação."
                                  ],
                                  "verification": "Compilar código com erro de remoção e verificar log gerado com detalhes corretos.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Biblioteca de logging",
                                    "Configurações de log",
                                    "Exemplos de código com erros"
                                  ],
                                  "tips": "Inclua timestamp e contexto do compilador no log para facilitar depuração.",
                                  "learningObjective": "Habilitar rastreamento de erros para depuração eficiente em tempo de compilação.",
                                  "commonMistakes": [
                                    "Logs excessivos que degradam performance",
                                    "Omitir contexto como ID do arquivo"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Testar e validar o tratamento de erros integrado",
                                  "subSteps": [
                                    "Crie suíte de testes: 5+ casos cobrindo escopos existentes/inexistentes, aninhados e vazios.",
                                    "Simule compilação com erros intencionais e verifique continuidade sem crash.",
                                    "Analise logs gerados e ajuste mensagens para clareza.",
                                    "Meça cobertura de código no tratamento de erros (>90%).",
                                    "Integre ao pipeline de compilação e teste end-to-end."
                                  ],
                                  "verification": "Todos testes passam e logs são precisos em cenários de falha.",
                                  "estimatedTime": "50 minutos",
                                  "materials": [
                                    "Ferramentas de coverage (JaCoCo)",
                                    "Suite de testes",
                                    "Compilador em desenvolvimento"
                                  ],
                                  "tips": "Use mocks para tabelas de símbolos em testes unitários.",
                                  "learningObjective": "Garantir robustez do tratamento de erros através de testes abrangentes.",
                                  "commonMistakes": [
                                    "Testes só para casos felizes",
                                    "Ignorar edge cases como escopos com caracteres especiais"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um compilador para uma linguagem como uma mini-Python, ao processar 'end function main' onde 'main' nunca foi declarado, a remoção falha graciosamente: loga 'Escopo 'main' não encontrado na linha 15, ignorando remoção' e continua compilação, permitindo depuração posterior.",
                              "finalVerifications": [
                                "Função de remoção retorna status correto para escopos inexistentes.",
                                "Logs são gerados com detalhes úteis (nome, linha, contexto).",
                                "Compilação não crasha em erros de remoção.",
                                "Testes unitários cobrem 100% dos cenários de erro.",
                                "Performance não degradada em remoções bem-sucedidas.",
                                "Logs facilitam identificação rápida do problema no código fonte."
                              ],
                              "assessmentCriteria": [
                                "Detecção precisa de escopo inexistente sem falsos positivos.",
                                "Logs informativos e não verbosos para depuração.",
                                "Integração seamless com o fluxo do compilador.",
                                "Cobertura de testes >90% no módulo de remoção.",
                                "Tratamento idempotente: múltiplas falhas não acumulam erros.",
                                "Documentação atualizada com novos comportamentos."
                              ],
                              "crossCurricularConnections": [
                                "Programação Defensiva (Engenharia de Software): Tratamento robusto de exceções.",
                                "Debugging e Logging (Desenvolvimento de Software): Melhores práticas de rastreamento.",
                                "Teoria de Autômatos (Ciência da Computação): Estados de erro em analisadores.",
                                "Gestão de Recursos (Sistemas Operacionais): Liberação segura de memória em tabelas."
                              ],
                              "realWorldApplication": "Em compiladores como GCC ou Clang, tratamento de erros em tabelas de símbolos previne falhas durante builds de projetos grandes, permitindo diagnósticos precisos para desenvolvedores e mantendo a estabilidade em CI/CD pipelines."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      }
                    ]
                  }
                ]
              },
              {
                "id": "10.1.4",
                "name": "Tratamento de Erros",
                "description": "Técnicas para detectar, reportar e recuperar de erros léxicos, sintáticos e semânticos no código-fonte.",
                "totalSkills": 36,
                "atomicTopics": [
                  {
                    "id": "10.1.4.1",
                    "name": "Tratamento de Erros Léxicos",
                    "description": "Técnicas para detectar tokens inválidos, reportá-los e recuperar a análise léxica, como exclusão ou inserção de caracteres.",
                    "individualConcepts": [
                      {
                        "id": "10.1.4.1.1",
                        "name": "Detecção de Tokens Inválidos",
                        "description": "Processos para identificar sequências de caracteres que não correspondem a nenhum padrão de token definido na gramática léxica, utilizando autômatos finitos ou funções manuais de análise léxica.",
                        "specificSkills": [
                          {
                            "id": "10.1.4.1.1.1",
                            "name": "Identificar falhas no reconhecimento de tokens via autômato",
                            "description": "Explicar como um autômato finito determinístico (AFD) ou não determinístico (AFN) detecta tokens inválidos ao falhar em transições ou estados finais, incluindo exemplos com expressões regulares.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Conceitos Básicos de Autômatos Finitos",
                                  "subSteps": [
                                    "Defina autômato finito determinístico (AFD) e não determinístico (AFN), destacando diferenças em transições.",
                                    "Explique os componentes: estados, alfabeto, função de transição, estado inicial e estados finais.",
                                    "Descreva o papel de autômatos na análise léxica de compiladores para reconhecimento de tokens.",
                                    "Identifique como expressões regulares são convertidas em autômatos.",
                                    "Liste exemplos simples de tokens como identificadores e números."
                                  ],
                                  "verification": "Resuma os componentes de um AFD/AFN em um diagrama simples e explique sua relação com tokens.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Diagrama de autômato em papel ou ferramenta como draw.io",
                                    "Notas sobre teoria dos autômatos"
                                  ],
                                  "tips": "Use setas para transições e destaque estados finais com dupla borda.",
                                  "learningObjective": "Compreender os fundamentos de autômatos finitos e seu uso em reconhecimento léxico.",
                                  "commonMistakes": [
                                    "Confundir AFD com AFN nas transições múltiplas",
                                    "Ignorar o estado inicial na simulação"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Simular Reconhecimento de Tokens Válidos",
                                  "subSteps": [
                                    "Construa ou revise um AFD para um token simples, como números inteiros (ex: regex [0-9]+).",
                                    "Simule passo a passo um input válido, rastreando estados e transições.",
                                    "Verifique se o autômato termina em um estado final para aceitação.",
                                    "Compare com AFN, mostrando epsilon-transições opcionais.",
                                    "Registre o caminho de estados para o input."
                                  ],
                                  "verification": "Simule um input válido e confirme aceitação em estado final com um log de transições.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Ferramenta online de autômatos como JFLAP ou papel",
                                    "Exemplos de regex para tokens"
                                  ],
                                  "tips": "Anote cada caractere processado e estado resultante em uma tabela.",
                                  "learningObjective": "Dominar a simulação de reconhecimento bem-sucedido de tokens.",
                                  "commonMistakes": [
                                    "Pular transições sem consumir input",
                                    "Não resetar ao estado inicial"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Identificar Mecanismos de Falha no Reconhecimento",
                                  "subSteps": [
                                    "Liste falhas comuns: ausência de transição para um símbolo, término em estado não final.",
                                    "Simule um input inválido, como '12a' para regex [0-9]+, mostrando travamento.",
                                    "Explique rejeição: se não há transição ou não acaba em estado final.",
                                    "Diferencie falhas em AFD (única transição falha) vs AFN (nenhum caminho aceita).",
                                    "Analise como o lexer reporta erro léxico nessa detecção."
                                  ],
                                  "verification": "Para um input inválido, identifique o ponto exato de falha e justifique rejeição.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Mesmos autômatos do step anterior",
                                    "Lista de inputs válidos/inválidos"
                                  ],
                                  "tips": "Marque o caractere problemático e estado atual na simulação.",
                                  "learningObjective": "Reconhecer e explicar precisamente as falhas em autômatos para tokens inválidos.",
                                  "commonMistakes": [
                                    "Assumir aceitação se estado intermediário é final",
                                    "Ignorar consumo total do input"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar a Exemplos com Expressões Regulares",
                                  "subSteps": [
                                    "Converta uma regex como [a-zA-Z][a-zA-Z0-9]* (identificador) em AFD usando Thompson ou Glushkov.",
                                    "Teste inputs: válido 'var123', inválido '123var', inválido 'var!'.",
                                    "Documente falhas: transição ausente para '!' ou não final após '123var'.",
                                    "Compare detecção em AFD vs AFN para o mesmo caso.",
                                    "Crie um relatório de erros léxicos simulados."
                                  ],
                                  "verification": "Gere diagramas e simulações para 3 exemplos, identificando falhas corretamente.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Ferramentas de regex to NFA como RegExr ou JFLAP",
                                    "Papel para diagramas"
                                  ],
                                  "tips": "Use cores para diferenciar caminhos válidos de falhas.",
                                  "learningObjective": "Integrar expressões regulares com detecção de falhas em autômatos.",
                                  "commonMistakes": [
                                    "Regex incorreta na conversão",
                                    "Não consumir todo input em validação"
                                  ]
                                }
                              ],
                              "practicalExample": "Para um AFD reconhecendo identificadores (regex: [a-z][a-z0-9]*), input 'abc123' é válido (termina em estado final Q3). Input '123abc' falha na transição de Q0 para '1' (sem transição numérica inicial). Input 'abc!' falha após 'abc' em Q3 (transição para '!' inexistente, e não consumiu todo input).",
                              "finalVerifications": [
                                "Simular corretamente 5 inputs em um AFD, identificando falhas exatas.",
                                "Explicar diferenças entre falha por transição ausente e estado não final.",
                                "Converter uma regex simples em AFD e detectar inválidos.",
                                "Diferenciar comportamento em AFD vs AFN para inputs inválidos.",
                                "Relatar erro léxico com posição e motivo preciso.",
                                "Desenhar diagrama de autômato com falha destacada."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de pontos de falha (transição/estado final).",
                                "Correta simulação passo a passo com logs de estados.",
                                "Integração correta de regex com autômatos.",
                                "Explicações claras e exemplos relevantes.",
                                "Tratamento de edge cases como input vazio ou símbolos especiais.",
                                "Uso adequado de terminologia (AFD, AFN, rejeição)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria dos autômatos e linguagens regulares.",
                                "Lógica: Estados como proposições verdadeiras/falsas em transições.",
                                "Programação: Implementação de lexers em ferramentas como Flex/ANTLR.",
                                "Engenharia de Software: Detecção de erros em parsers.",
                                "Inteligência Artificial: Autômatos em reconhecimento de padrões."
                              ],
                              "realWorldApplication": "Em compiladores como GCC ou editores como VS Code, autômatos detectam erros léxicos (ex: variável inválida '1var') destacando no código, melhorando depuração e UX em IDEs."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.4.1.1.2",
                            "name": "Detectar erros em analisadores léxicos manuais",
                            "description": "Descrever a verificação sequencial de padrões em funções lexer personalizadas, como loops que testam identificadores, literais e operadores, retornando erro quando nenhum match ocorre.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar a Estrutura Básica de um Analisador Léxico Manual",
                                  "subSteps": [
                                    "Examine o código fonte de um lexer simples que processa entrada caractere por caractere.",
                                    "Identifique o loop principal que avança pelo input e testa padrões de tokens.",
                                    "Liste os padrões suportados: identificadores (letras e dígitos), literais numéricos, strings e operadores.",
                                    "Anote o estado atual (posição no input) e como tokens são emitidos.",
                                    "Desenhe um fluxograma do processo de tokenização."
                                  ],
                                  "verification": "Explique verbalmente ou por escrito o fluxo do lexer, identificando o loop de matching.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Código fonte de lexer exemplo em Python ou C",
                                    "Papel e caneta para fluxograma"
                                  ],
                                  "tips": "Comece pelo input buffer e avance passo a passo simulando um input simples como 'var x = 10;'",
                                  "learningObjective": "Compreender os componentes fundamentais de um lexer manual e seu loop de processamento.",
                                  "commonMistakes": [
                                    "Ignorar o ponteiro de posição no input",
                                    "Confundir tokenização com parsing sintático"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar o Loop de Matching Sequencial de Padrões",
                                  "subSteps": [
                                    "Localize o loop while que consome caracteres e testa sequencialmente cada padrão possível.",
                                    "Simule o matching para identificadores (inicia com letra, seguido de alfanuméricos).",
                                    "Teste literais (números inteiros/flutuantes, strings delimitadas por aspas).",
                                    "Verifique operadores (++, =, +, etc.) e símbolos especiais.",
                                    "Identifique o que acontece quando o caractere atual não matches nenhum padrão."
                                  ],
                                  "verification": "Simule manualmente o loop em um papel para um input válido e anote matches.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Lexer código",
                                    "Inputs de teste variados (válidos e inválidos)"
                                  ],
                                  "tips": "Use um depurador ou prints para rastrear qual padrão é testado em cada iteração.",
                                  "learningObjective": "Mapear o comportamento sequencial do matching e pontos potenciais de falha.",
                                  "commonMistakes": [
                                    "Assumir matching prioritário sem ordem sequencial",
                                    "Esquecer de consumir caracteres após match parcial"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar Lógica de Detecção de Erro por Falha de Match",
                                  "subSteps": [
                                    "Adicione uma condição no final do loop: se nenhum padrão matchou o caractere atual, retorne token de erro.",
                                    "Crie um token de erro com posição, caractere inválido e mensagem descritiva.",
                                    "Garanta que o lexer pare ou reporte erro sem avançar indefinidamente.",
                                    "Teste com inputs contendo caracteres inválidos como '@', '#', ou sequências não reconhecidas.",
                                    "Registre o erro com contexto (linha/coluna aproximada)."
                                  ],
                                  "verification": "Execute o lexer com input inválido e confirme que um token de erro é emitido corretamente.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Editor de código",
                                    "Lexer modificado",
                                    "Suite de testes unitários"
                                  ],
                                  "tips": "Use try-catch ou return early para propagar o erro sem crashar o programa.",
                                  "learningObjective": "Inserir detecção robusta de tokens inválidos no fluxo do lexer.",
                                  "commonMistakes": [
                                    "Continuar loop após erro sem reportar",
                                    "Erro em cálculo de posição do input"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Testar e Refinar a Detecção de Erros",
                                  "subSteps": [
                                    "Crie casos de teste: caracteres isolados inválidos, sequências mistas, edge cases como fim de input inválido.",
                                    "Execute testes e verifique se erros são detectados precocemente sem false positives.",
                                    "Debug falsos negativos (inputs inválidos aceitos como válidos).",
                                    "Adicione logs detalhados para matching falhado.",
                                    "Otimize para performance em inputs longos com erros."
                                  ],
                                  "verification": "Todos os testes de erro passam e lexer não crasha ou ignora inválidos.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Framework de testes (pytest ou similar)",
                                    "Lista de 10+ inputs de teste"
                                  ],
                                  "tips": "Priorize testes que cubram todos os padrões + inválidos comuns em linguagens reais.",
                                  "learningObjective": "Validar e aprimorar a detecção de erros através de testes exaustivos.",
                                  "commonMistakes": [
                                    "Testes insuficientes para edge cases",
                                    "Ignorar erros em whitespaces ou comentários"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um lexer Python simples para uma mini-linguagem, input 'x = 123 + @@@;' deve matching 'x', '=', '123', '+', então detectar '@' como inválido no loop sequencial (testa id, num, op, str - nenhum match), retornando TokenErro(pos=7, char='@', msg='Caractere inválido').",
                              "finalVerifications": [
                                "Lexer detecta e reporta erro para qualquer caractere não coberto pelos padrões.",
                                "Posição do erro é calculada corretamente (linha/coluna).",
                                "Input válido é processado completamente sem falsos erros.",
                                "Lexer para graciosamente após primeiro erro detectado.",
                                "Mensagem de erro inclui contexto do token inválido.",
                                "Testes unitários cobrem 100% dos casos de erro léxico."
                              ],
                              "assessmentCriteria": [
                                "Precisão na detecção: 100% de taxa de acerto em tokens inválidos.",
                                "Eficiência: Não degrada performance em inputs longos.",
                                "Robustez: Lida com edge cases como EOF inválido ou multibyte chars.",
                                "Clareza do código: Lógica de erro bem comentada e modular.",
                                "Cobertura de testes: Pelo menos 10 casos, incluindo sequenciais.",
                                "Usabilidade: Erros reportados de forma legível para desenvolvedor."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Autômatos Finitos e Expressões Regulares para matching.",
                                "Lógica e Algoritmos: Análise de casos exaustivos e fluxos condicionais.",
                                "Desenvolvimento de Software: Práticas de debugging e error handling.",
                                "Engenharia de Software: Design de parsers e tratamento de exceções.",
                                "Linguística Computacional: Análise de padrões em linguagens formais."
                              ],
                              "realWorldApplication": "Em compiladores como GCC/Clang ou interpretadores (Python tokenizer), detecta erros léxicos cedo (ex: caractere inválido em código C++), permitindo feedback imediato em IDEs como VSCode; essencial para linters, validadores de config (JSON/YAML) e processadores de logs."
                            },
                            "estimatedTime": "0.5 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.4.1.1.3",
                            "name": "Analisar tipos comuns de erros léxicos",
                            "description": "Classificar erros como caracteres isolados inválidos, números malformados ou strings não fechadas, com exemplos de entrada e saída esperada do lexer.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os conceitos fundamentais de erros léxicos",
                                  "subSteps": [
                                    "Estude a definição de lexer e sua função na análise de código fonte.",
                                    "Identifique os três tipos principais: caracteres isolados inválidos, números malformados e strings não fechadas.",
                                    "Revise regras léxicas básicas de uma linguagem simples (ex: tokens como ID, NUM, STRING).",
                                    "Anote exemplos iniciais de cada tipo de erro em um caderno.",
                                    "Compare erros léxicos com erros sintáticos para diferenciar."
                                  ],
                                  "verification": "Crie um mapa mental ou tabela resumindo os três tipos com um exemplo cada.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Documentação de lexer de uma linguagem simples (ex: especificação de tokens)",
                                    "Caderno ou ferramenta de mind mapping como Draw.io"
                                  ],
                                  "tips": [
                                    "Use diagramas de fluxo para visualizar o processo de tokenização.",
                                    "Foquem em regras exatas da gramática léxica."
                                  ],
                                  "learningObjective": "Entender e diferenciar os tipos comuns de erros léxicos dos válidos.",
                                  "commonMistakes": [
                                    "Confundir erros léxicos com sintáticos.",
                                    "Ignorar contexto de posição no código."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar erros de caracteres isolados inválidos",
                                  "subSteps": [
                                    "Defina caractere inválido: símbolos não definidos na gramática léxica (ex: @ em posição isolada).",
                                    "Examine entrada: 'a + b @ c' e saída esperada: tokens 'a', '+', 'b', ERRO('@'), 'c'.",
                                    "Simule o lexer manualmente, parando no caractere inválido e reportando posição.",
                                    "Teste variações: isolado vs. em palavra (ex: 'abc@' vs '@').",
                                    "Registre a saída esperada em formato JSON ou tabela."
                                  ],
                                  "verification": "Classifique 5 exemplos de entrada e valide contra saída esperada.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Arquivo de exemplos de entradas com erros (prepare 10 snippets)",
                                    "Simulador de lexer online ou papel"
                                  ],
                                  "tips": [
                                    "Sempre reporte posição (linha/coluna) do erro para precisão.",
                                    "Ignore caracteres após erro até próximo token válido."
                                  ],
                                  "learningObjective": "Identificar e classificar precisamente erros de caracteres isolados inválidos.",
                                  "commonMistakes": [
                                    "Tratar símbolos válidos como inválidos.",
                                    "Não reportar posição exata."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar erros em números malformados",
                                  "subSteps": [
                                    "Defina número malformado: sequências que violam regras numéricas (ex: '12a3', '1.2.3').",
                                    "Examine entrada: 'int x = 12a3;' e saída: 'int', 'x', '=', ERRO('12a3'), ';'.",
                                    "Simule tokenização: consumir dígitos até inválido, reportar como erro.",
                                    "Diferencie de IDs: números começam com dígito, mas falham se contêm não-dígitos.",
                                    "Crie 3 exemplos personalizados e classifique."
                                  ],
                                  "verification": "Analise 5 entradas numéricas malformadas e produza saídas corretas.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Lista de regras numéricas da gramática",
                                    "Editor de texto para snippets"
                                  ],
                                  "tips": [
                                    "Números válidos: apenas dígitos opcionais com ponto decimal único.",
                                    "Pare na primeira violação."
                                  ],
                                  "learningObjective": "Reconhecer padrões de números malformados durante tokenização.",
                                  "commonMistakes": [
                                    "Aceitar números com letras como IDs válidos.",
                                    "Não truncar no erro."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar erros em strings não fechadas",
                                  "subSteps": [
                                    "Defina string não fechada: aspas abertas sem fechamento (ex: '\"hello').",
                                    "Examine entrada: 'print(\"hello);' e saída: ERRO('\"hello'), ';'.",
                                    "Simule lexer: consumir até fim de linha ou arquivo se não encontrar aspas.",
                                    "Considere escapes: \"\\\" não fecha imediatamente.",
                                    "Teste casos: multiline implícito, com escapes inválidos."
                                  ],
                                  "verification": "Classifique 5 strings malformadas e descreva saída do lexer.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Exemplos de strings com escapes",
                                    "Ferramenta de regex para prática"
                                  ],
                                  "tips": [
                                    "Conte aspas e verifique paridade.",
                                    "Reporte todo conteúdo até fim como erro."
                                  ],
                                  "learningObjective": "Detectar e tratar strings não delimitadas corretamente.",
                                  "commonMistakes": [
                                    "Fechar string prematuramente com aspas internas.",
                                    "Ignorar conteúdo após aspa aberta."
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Praticar classificação integrada e verificação",
                                  "subSteps": [
                                    "Combine todos os tipos em um snippet complexo com múltiplos erros.",
                                    "Analise entrada completa e produza saída total do lexer.",
                                    "Compare com lexer real (ex: flex ou handmade).",
                                    "Itere em 3 cenários variados: código com 2+ erros mistos.",
                                    "Documente lições aprendidas."
                                  ],
                                  "verification": "Analise um código de 10 linhas com erros mistos e acerte 100% na classificação.",
                                  "estimatedTime": "50 minutos",
                                  "materials": [
                                    "Código fonte teste com erros mistos",
                                    "Lexer de referência (ex: online tool)"
                                  ],
                                  "tips": [
                                    "Priorize erros na ordem de detecção.",
                                    "Mantenha estado do lexer entre tokens."
                                  ],
                                  "learningObjective": "Aplicar análise de todos os tipos de erros em contextos reais.",
                                  "commonMistakes": [
                                    "Pular erros após o primeiro.",
                                    "Confundir tipos entre si."
                                  ]
                                }
                              ],
                              "practicalExample": "Entrada: int x = 12a3 + \"hello@world;\nSaída esperada do lexer: ['int', 'x', '=', ERRO('12a3'), '+', ERRO('\"hello@world'), ';'] (string não fechada até fim de linha, @ como inválido dentro dela, mas tratado como parte do erro string).",
                              "finalVerifications": [
                                "Classificar corretamente caracteres isolados inválidos em 5/5 exemplos.",
                                "Identificar números malformados reportando prefixo válido vs. erro.",
                                "Detectar strings não fechadas consumindo até delimitador ausente.",
                                "Produzir saída de lexer precisa para código com múltiplos erros mistos.",
                                "Explicar diferenças entre os três tipos com exemplos próprios.",
                                "Simular análise manual sem erros em snippet de 10 linhas."
                              ],
                              "assessmentCriteria": [
                                "Precisão na classificação: 90%+ acerto em testes mistos.",
                                "Relato completo: inclui tipo, posição e saída esperada.",
                                "Compreensão conceitual: explica regras léxicas subjacentes.",
                                "Eficiência: análise em tempo razoável sem simulações desnecessárias.",
                                "Criatividade: gera exemplos variados e edge cases.",
                                "Documentação: saídas formatadas claramente (JSON/tabela)."
                              ],
                              "crossCurricularConnections": [
                                "Linguística: Análise morfológica e detecção de anomalias em textos.",
                                "Matemática: Reconhecimento de padrões e expressões regulares.",
                                "Programação Geral: Debugging e parsing em qualquer linguagem.",
                                "Inglês Técnico: Leitura de especificações de gramáticas formais."
                              ],
                              "realWorldApplication": "Em compiladores como GCC/Clang ou IDEs (VS Code, IntelliJ), onde lexers detectam erros de syntax highlight em tempo real, ajudando desenvolvedores a corrigir código inválido antes da compilação, economizando tempo em projetos grandes."
                            },
                            "estimatedTime": "0.5 hora",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.4.1.2",
                        "name": "Reporte de Erros Léxicos",
                        "description": "Geração de mensagens de diagnóstico claras e precisas para informar o usuário sobre erros léxicos, incluindo localização exata no código fonte.",
                        "specificSkills": [
                          {
                            "id": "10.1.4.1.2.1",
                            "name": "Gerar mensagens de erro com posição precisa",
                            "description": "Implementar relatórios que incluam número da linha, coluna e trecho do código fonte ao redor do erro, usando contadores de posição no lexer.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Implementar contadores de posição no lexer",
                                  "subSteps": [
                                    "Declare variáveis para rastrear linha atual (line) e coluna atual (column), inicializando em 1.",
                                    "Inclua uma variável para o caractere atual ou buffer de contexto.",
                                    "Atualize os contadores no início do loop principal do lexer.",
                                    "Defina funções auxiliares para resetar contadores ao processar nova linha.",
                                    "Teste inicial com input simples para validar contagens."
                                  ],
                                  "verification": "Execute o lexer com um arquivo de teste de múltiplas linhas e imprima os contadores após cada token; verifique se linha e coluna incrementam corretamente.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Código base do lexer",
                                    "Editor de texto/IDE",
                                    "Arquivo de teste com 10 linhas variadas"
                                  ],
                                  "tips": "Use variáveis inteiras unsigned para evitar underflow; sempre incremente coluna antes de processar '\\n'.",
                                  "learningObjective": "Entender como manter estado de posição durante o scanning de tokens.",
                                  "commonMistakes": [
                                    "Esquecer de resetar coluna para 1 em nova linha",
                                    "Incrementar linha após '\\n' em vez de ao detectá-lo",
                                    "Não inicializar contadores em 1"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Atualizar contadores durante o processamento de caracteres",
                                  "subSteps": [
                                    "No loop de leitura de caracteres, incremente coluna para cada caractere não-nova-linha.",
                                    "Ao encontrar '\\n', incremente linha e resete coluna para 1.",
                                    "Capture o caractere atual e posições antes de avançar o ponteiro de input.",
                                    "Mantenha um buffer de contexto com os últimos N caracteres (ex: 10) para snippet.",
                                    "Integre atualizações em todas as transições do autômato do lexer."
                                  ],
                                  "verification": "Insira logs nos pontos de update e rode com input contendo tabs, espaços e novas linhas; confirme contagens via output.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Lexer atualizado do step 1",
                                    "Inputs de teste com caracteres especiais (tabs, '\\n')",
                                    "Debugger ou printf statements"
                                  ],
                                  "tips": "Considere tabs como múltiplas colunas (ex: tab = 4 colunas) se aplicável à linguagem.",
                                  "learningObjective": "Dominar a manutenção dinâmica de posições em fluxos de caracteres variáveis.",
                                  "commonMistakes": [
                                    "Incrementar coluna após nova linha",
                                    "Ignorar caracteres de controle como tab",
                                    "Buffer de contexto sobrescrito incorretamente"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Detectar erros e formatar mensagens com posições precisas",
                                  "subSteps": [
                                    "No handler de erro léxico (ex: caractere inválido), capture line, column e buffer de contexto.",
                                    "Construa string de mensagem: 'Erro na linha X, coluna Y: [snippet ao redor] Esperado: ...'.",
                                    "Extraia snippet centrado na posição de erro (ex: 5 chars antes + erro + 5 depois).",
                                    "Use funções de formatação como sprintf ou stringstream para montar a mensagem.",
                                    "Imprima ou retorne a mensagem formatada e pare o scanning ou continue."
                                  ],
                                  "verification": "Introduza erros intencionais em input de teste e verifique se mensagens mostram linha/coluna/snippet exatos.",
                                  "estimatedTime": "50 minutos",
                                  "materials": [
                                    "Lexer com contadores do step 2",
                                    "Inputs com erros plantados (ex: '@' inválido)",
                                    "Ferramentas de string formatting da linguagem"
                                  ],
                                  "tips": "Limite snippet a 20-30 chars para legibilidade; destaque o erro com '^'.",
                                  "learningObjective": "Criar relatórios de erro informativos e localizados.",
                                  "commonMistakes": [
                                    "Off-by-one em posições do snippet",
                                    "Mensagem sem contexto útil",
                                    "Não pausar scanning após erro fatal"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Testar e refinar o sistema de reporte de erros",
                                  "subSteps": [
                                    "Crie suíte de testes com erros em posições variadas (início, meio, fim de linha).",
                                    "Execute testes automatizados verificando parsing de mensagens (extrair linha/coluna).",
                                    "Refatore para suportar múltiplos erros por arquivo, listando todos.",
                                    "Adicione suporte a erros em EOF ou inputs vazios.",
                                    "Otimize performance medindo impacto nos contadores."
                                  ],
                                  "verification": "Todos testes passam com mensagens precisas; cobertura de 100% dos casos edge.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Suite de testes unitários",
                                    "Framework de testing (ex: unittest)",
                                    "Inputs edge-case"
                                  ],
                                  "tips": "Use asserts para validar extração de posições das mensagens geradas.",
                                  "learningObjective": "Garantir robustez e precisão em cenários reais de depuração.",
                                  "commonMistakes": [
                                    "Testes só em casos simples",
                                    "Ignorar erros em whitespaces",
                                    "Sobrecarga de performance em arquivos grandes"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um lexer para MiniLang, input: 'int x = abc;' gera erro 'Erro léxico na linha 1, coluna 8: 'abc' ^ Caractere inválido 'a', esperado dígito ou identificador válido.' com snippet 'x = abc'.",
                              "finalVerifications": [
                                "Contadores de linha e coluna reportam posições corretas em 10+ testes variados.",
                                "Mensagens incluem snippet contextualizado destacando o erro.",
                                "Sistema lida com múltiplos erros sem perder precisão em posições subsequentes.",
                                "Erros em EOF ou arquivos vazios são reportados com linha/coluna apropriadas.",
                                "Performance não degrada em arquivos de 1000+ linhas.",
                                "Mensagens são legíveis e parseáveis por ferramentas externas."
                              ],
                              "assessmentCriteria": [
                                "Precisão absoluta de linha e coluna em todos testes (100% acurácia).",
                                "Formatação de mensagem clara, com snippet útil e sem ambiguidades.",
                                "Cobertura completa de atualizações de contadores em todos caracteres.",
                                "Tratamento robusto de caracteres especiais (\\n, tab, etc.).",
                                "Eficiência: O(1) por caractere para updates.",
                                "Facilidade de extensão para erros semanais."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Contadores como coordenadas cartesianas em strings.",
                                "Desenvolvimento de Software: Logging e debugging em pipelines de compilação.",
                                "UX/UI: Design de mensagens de erro user-friendly.",
                                "Algoritmos: Autômatos finitos com estado estendido para tracking."
                              ],
                              "realWorldApplication": "Em compiladores profissionais como GCC/Clang ou editores como VS Code, mensagens precisas permitem depuração rápida em código real, reduzindo tempo de desenvolvimento em projetos grandes."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.4.1.2.2",
                            "name": "Classificar e descrever tipos de erro léxico",
                            "description": "Definir categorias de erros (ex: 'caractere inesperado', 'identificador inválido') e criar templates de mensagens padronizadas para melhor usabilidade.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender Fundamentos de Análise Léxica e Erros Léxicos",
                                  "subSteps": [
                                    "Estude o processo de tokenização em um lexer/analisador léxico.",
                                    "Identifique a diferença entre erros léxicos e erros sintáticos/semânticos.",
                                    "Revise exemplos de tokens válidos vs. inválidos em linguagens como C ou Python.",
                                    "Analise fluxogramas de um lexer simples para ver onde erros são detectados.",
                                    "Liste 3-5 fontes comuns de erros léxicos em código fonte."
                                  ],
                                  "verification": "Crie um diagrama simples do fluxo de um lexer destacando pontos de detecção de erros.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Livro 'Compilers: Principles, Techniques, and Tools' (Dragon Book), capítulo 3",
                                    "Tutoriais online sobre Flex/Lex",
                                    "Exemplos de código lexer em GitHub"
                                  ],
                                  "tips": "Use diagramas visuais para mapear o processo; foque em estados finitos.",
                                  "learningObjective": "Compreender o papel do lexer e origens de erros léxicos.",
                                  "commonMistakes": [
                                    "Confundir erros léxicos com sintáticos",
                                    "Ignorar contexto de lookahead no lexer"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Classificar Categorias de Erros Léxicos",
                                  "subSteps": [
                                    "Liste categorias principais: caractere inesperado, identificador inválido, string não fechada, comentário não fechado, número malformado.",
                                    "Pesquise em documentações de compiladores reais (GCC, Clang) exemplos de cada categoria.",
                                    "Crie uma tabela com categoria, descrição breve e exemplo de input inválido.",
                                    "Agrupe erros por similaridade (ex: erros de delimitadores vs. erros de caracteres especiais).",
                                    "Valide a lista com pelo menos 8-10 categorias comuns."
                                  ],
                                  "verification": "Produza uma tabela classificatória com pelo menos 8 categorias, incluindo exemplos.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Documentação GCC error messages",
                                    "Repositórios de lexers open-source",
                                    "Ferramenta Markdown para tabelas"
                                  ],
                                  "tips": "Priorize categorias por frequência em código real; use regex para simular detecção.",
                                  "learningObjective": "Dominar classificação sistemática de erros léxicos.",
                                  "commonMistakes": [
                                    "Listas incompletas (menos de 5 categorias)",
                                    "Classificações vagas sem exemplos concretos"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Descrever Tipos de Erros com Exemplos Detalhados",
                                  "subSteps": [
                                    "Para cada categoria, escreva uma descrição clara (1-2 frases).",
                                    "Forneça 2-3 exemplos de input inválido e o token esperado vs. encontrado.",
                                    "Explique o impacto no processo de compilação e por que é léxico.",
                                    "Crie casos edge (ex: EOF prematuro em string).",
                                    "Documente em formato estruturado (JSON ou YAML) para reutilização."
                                  ],
                                  "verification": "Gere um documento com descrições completas para todas as categorias da tabela anterior.",
                                  "estimatedTime": "2.5 horas",
                                  "materials": [
                                    "Editor de texto com suporte a JSON/YAML",
                                    "Exemplos de código de teste para lexer",
                                    "Ferramentas de linting como ESLint para inspiração"
                                  ],
                                  "tips": "Use linguagem acessível, como se explicando para um programador júnior.",
                                  "learningObjective": "Capacitar descrições precisas e ilustrativas de erros.",
                                  "commonMistakes": [
                                    "Descrições genéricas sem exemplos",
                                    "Falta de distinção entre tipos semelhantes"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Criar Templates de Mensagens Padronizadas",
                                  "subSteps": [
                                    "Defina estrutura de template: [Categoria]: [Descrição] em linha X, coluna Y. Input próximo: '...'.",
                                    "Crie um template para cada categoria, com placeholders para posição e contexto.",
                                    "Teste templates com exemplos simulados de input.",
                                    "Avalie usabilidade: clareza, brevidade, sugestões de correção opcionais.",
                                    "Implemente uma função simples em Python/JS para gerar mensagens a partir de templates."
                                  ],
                                  "verification": "Desenvolva e teste 8+ templates, gerando mensagens para inputs de exemplo.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Python ou JavaScript REPL",
                                    "Bibliotecas de templating como Jinja2 ou string.format",
                                    "Exemplos de mensagens de erro de IDEs"
                                  ],
                                  "tips": "Inclua contexto (snippet de código) para melhor debug; evite jargão excessivo.",
                                  "learningObjective": "Projetar mensagens de erro user-friendly e padronizadas.",
                                  "commonMistakes": [
                                    "Templates muito verbosos",
                                    "Falta de placeholders para localização exata"
                                  ]
                                }
                              ],
                              "practicalExample": "Implemente um lexer simples em Python para uma mini-linguagem de expressões aritméticas (ex: 2+3*var). Teste inputs inválidos como '2@3' (caractere inesperado '@'), 'var_' (identificador inválido com underscore final) e gere relatórios usando templates: 'Erro léxico: Caractere inesperado '@' na linha 1, coluna 2. Esperado: operador (+,-,*,/).'",
                              "finalVerifications": [
                                "Lista completa de pelo menos 8 categorias de erros léxicos com exemplos.",
                                "Descrições detalhadas e tabelas classificatórias produzidas.",
                                "Templates funcionais testados em 5+ cenários de erro.",
                                "Função de geração de mensagens implementada e validada.",
                                "Diagrama de fluxo do lexer com pontos de erro mapeados.",
                                "Mensagens geradas são claras, localizadas e úteis para correção."
                              ],
                              "assessmentCriteria": [
                                "Precisão e completude das classificações (90%+ cobertura de erros comuns).",
                                "Clareza e detalhe nas descrições e exemplos (linguagem acessível).",
                                "Usabilidade dos templates (inclui posição, contexto e sugestões).",
                                "Consistência na estrutura de steps e documentação.",
                                "Criatividade em casos edge e conexões práticas.",
                                "Eficiência: tempo dentro do estimado com verificações passadas."
                              ],
                              "crossCurricularConnections": [
                                "Linguística: Análise morfológica e categorização de tokens como palavras inválidas.",
                                "Design de UX/UI: Criação de mensagens de erro intuitivas, similar a feedback em apps.",
                                "Matemática: Autômatos finitos e expressões regulares para detecção de padrões inválidos.",
                                "Engenharia de Software: Boas práticas de logging e error handling em sistemas.",
                                "Psicologia Cognitiva: Redução de carga cognitiva em mensagens de erro para desenvolvedores."
                              ],
                              "realWorldApplication": "Em compiladores e IDEs como GCC, Clang, VS Code ou PyCharm, onde classificações precisas e templates padronizados de erros léxicos aceleram o debugging, melhoram a experiência do desenvolvedor e reduzem tempo de correção em projetos reais de software."
                            },
                            "estimatedTime": "0.5 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.4.1.2.3",
                            "name": "Integrar logging de erros sem interromper execução",
                            "description": "Configurar o lexer para registrar erros em arquivo ou console sem abortar a análise, permitindo múltiplos diagnósticos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Configurar o Mecanismo de Logging",
                                  "subSteps": [
                                    "Escolha um logger apropriado (ex: logging module em Python, spdlog em C++, ou console.log em JS).",
                                    "Defina níveis de log (ERROR, WARNING) e configure saída para arquivo e/ou console.",
                                    "Crie funções helper para logar erros léxicos com timestamp, linha e mensagem.",
                                    "Teste o logger isoladamente com mensagens de amostra.",
                                    "Garanta que o logging seja thread-safe se aplicável."
                                  ],
                                  "verification": "Execute um teste simples de logging e confirme que mensagens aparecem no console/arquivo sem erros.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Biblioteca de logging da linguagem (ex: Python logging), editor de código, arquivo de teste.",
                                  "tips": "Use formato estruturado como JSON para logs para facilitar parsing posterior.",
                                  "learningObjective": "Entender e implementar um sistema de logging robusto para diagnósticos.",
                                  "commonMistakes": "Esquecer de flush o buffer do arquivo, causando perda de logs; usar print em vez de logger estruturado."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar e Capturar Pontos de Erro no Lexer",
                                  "subSteps": [
                                    "Analise o código do lexer e marque todos os pontos onde erros léxicos são detectados (ex: caractere inválido, EOF prematuro).",
                                    "Substitua throws/exceptions/returns por flags de erro continuado.",
                                    "Colete metadados do erro: posição (linha/coluna), caractere/token inválido, contexto.",
                                    "Defina uma estrutura de dados para armazenar erros (lista de dicts com campos padronizados).",
                                    "Atualize o loop principal do lexer para pular tokens inválidos após log."
                                  ],
                                  "verification": "Insira um erro léxico intencional e verifique se metadados são capturados corretamente sem abortar.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Código fonte do lexer, debugger/inspector.",
                                  "tips": "Use enum ou constantes para tipos de erro léxico para padronização.",
                                  "learningObjective": "Mapear e isolar detecções de erro no fluxo do lexer.",
                                  "commonMistakes": "Não avançar o ponteiro de input após erro, causando loop infinito; ignorar contexto como último token válido."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Integrar Logging nos Handlers de Erro sem Interromper Fluxo",
                                  "subSteps": [
                                    "Em cada handler de erro, chame a função de log com metadados coletados.",
                                    "Adicione o erro à lista global de diagnósticos.",
                                    "Continue o scanning: avance o input stream e tente próximo token.",
                                    "Implemente limite de erros por linha para evitar spam (ex: max 5 por linha).",
                                    "Opcionalmente, sincronize com estado válido próximo (ex: skip até whitespace)."
                                  ],
                                  "verification": "Rode lexer em input com múltiplos erros consecutivos e confirme que todos são logados e scanning completa.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Input de teste com erros múltiplos, arquivo de log para inspeção.",
                                  "tips": "Logue erros de forma idempotente para evitar duplicatas em reescaneios.",
                                  "learningObjective": "Garantir resiliência do lexer via logging não-bloqueante.",
                                  "commonMistakes": "Logar após avançar input, perdendo posição exata; não tratar erros em strings/comentários."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Implementar Relatório Final e Testes de Validação",
                                  "subSteps": [
                                    "No fim do scanning, itere lista de erros e gere relatório consolidado.",
                                    "Adicione estatísticas: total erros, por tipo, linhas afetadas.",
                                    "Crie suíte de testes: casos com 0, 1, múltiplos erros; edge cases como EOF.",
                                    "Meça performance: tempo de scanning com/ sem erros.",
                                    "Refatore para suportar callbacks de erro customizáveis."
                                  ],
                                  "verification": "Execute suíte de testes; confirme 100% cobertura de casos e relatório preciso.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Framework de testes (ex: unittest em Python), inputs variados.",
                                  "tips": "Use mocks para input stream em testes unitários.",
                                  "learningObjective": "Validar e reportar diagnósticos de forma agregada.",
                                  "commonMistakes": "Relatar erros duplicados; não ordenar por posição para legibilidade."
                                }
                              ],
                              "practicalExample": "Em um lexer Python custom para uma linguagem simples, input 'abc123!@#def' deve logar 'Caractere inválido '!' na linha 1 col 7', 'Caractere inválido '@' na linha 1 col 8', '#' na col 9', mas retornar tokens 'abc', '123', 'def' sem abortar, com relatório final listando 3 erros léxicos.",
                              "finalVerifications": [
                                "Lexer processa input completo mesmo com múltiplos erros.",
                                "Todos erros são logados com posição precisa (linha/coluna).",
                                "Lista de tokens válidos é gerada corretamente.",
                                "Relatório final resume erros sem duplicatas.",
                                "Performance degradada <10% com 100 erros.",
                                "Não há crashes ou loops infinitos em edge cases."
                              ],
                              "assessmentCriteria": [
                                "Precisão dos logs: 100% dos erros capturados e reportados corretamente.",
                                "Continuidade: Taxa de sucesso de scanning em inputs errôneos >95%.",
                                "Estrutura dos logs: Inclui tipo, posição, contexto; legível/parseável.",
                                "Eficiência: Tempo de execução linear com número de erros.",
                                "Robustez: Lida com EOF, strings malformadas, sem vazamentos.",
                                "Extensibilidade: Fácil adicionar novos tipos de erro."
                              ],
                              "crossCurricularConnections": [
                                "Engenharia de Software: Práticas de logging e monitoramento (ex: ELK stack).",
                                "Debugging e Testing: Estratégias de fault tolerance em parsers.",
                                "Sistemas Operacionais: Gerenciamento de streams e buffers de I/O.",
                                "Análise de Dados: Agregação e visualização de logs de erros."
                              ],
                              "realWorldApplication": "Em compiladores como GCC/Clang, permite desenvolvedores verem todos erros léxicos/sintáticos em um arquivo grande sem parar na primeira falha, acelerando iterações de correção em projetos reais."
                            },
                            "estimatedTime": "0.5 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.4.1.3",
                        "name": "Recuperação de Erros Léxicos",
                        "description": "Técnicas para sincronizar e continuar a análise léxica após detectar um erro, minimizando a propagação e permitindo análise global do código.",
                        "specificSkills": [
                          {
                            "id": "10.1.4.1.3.1",
                            "name": "Aplicar exclusão de caracteres inválidos",
                            "description": "Implementar estratégia de pular ou deletar um caractere inválido e tentar matching novamente, com exemplo em código C ou Java para lexer.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender Erros Léxicos e Estratégia de Exclusão",
                                  "subSteps": [
                                    "Estude o que é um token válido em análise léxica e identifique caracteres inválidos comuns (ex: símbolos não esperados).",
                                    "Analise como um lexer falha em matching e entra em estado de erro.",
                                    "Revise estratégias de recuperação: pular (skip) vs. deletar (delete) caractere inválido e retry matching.",
                                    "Examine fluxogramas de lexers com recuperação de erro.",
                                    "Discuta impacto na robustez do compilador."
                                  ],
                                  "verification": "Resuma em 3 frases o conceito e desenhe um fluxograma simples da estratégia.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Documentação de lexers (Flex manual), slides de compiladores.",
                                  "tips": "Use diagramas para visualizar estados do lexer antes/depois do erro.",
                                  "learningObjective": "Entender o papel da exclusão na recuperação de erros léxicos.",
                                  "commonMistakes": "Confundir exclusão com inserção de caracteres; ignorar perda de sincronização."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Projetar Lógica de Exclusão no Lexer",
                                  "subSteps": [
                                    "Defina regras: ao falhar matching, avance ponteiro de input em 1 caractere e reporte erro.",
                                    "Especifique condições: tente matching novamente no próximo caractere sem consumir input extra.",
                                    "Planeje relatório de erro: logue posição e caractere inválido.",
                                    "Considere limites: máximo de skips consecutivos para evitar loops infinitos.",
                                    "Crie pseudocódigo para a função de nextToken() com branch de erro."
                                  ],
                                  "verification": "Escreva pseudocódigo validado por auto-revisão ou peer review.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Papel/caneta para fluxogramas, editor de texto para pseudocódigo.",
                                  "tips": "Inclua contadores de erro para debug; priorize minimalismo na recuperação.",
                                  "learningObjective": "Projetar lógica robusta de recuperação sem quebrar o lexer normal.",
                                  "commonMistakes": "Não resetar estado do lexer após skip; skips ilimitados causando perda total de input."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar Exclusão em Código Java",
                                  "subSteps": [
                                    "Crie classe Lexer com métodos nextToken(), currentChar(), advance().",
                                    "No loop de matching, adicione if (!isValidChar()) { reportError(); advance(); retryMatch(); }.",
                                    "Implemente reportError() com linha/coluna e caractere.",
                                    "Teste unitário inline: input '123@abc' deve pular '@' e retornar tokens 123, abc.",
                                    "Integre com estado finito para diferentes tipos de tokens (números, IDs)."
                                  ],
                                  "verification": "Compile e rode código com input inválido; confirme tokens corretos pós-skip.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "IDE Java (Eclipse/IntelliJ), JUnit para testes.",
                                  "tips": "Use StringBuilder para buffer de token; debug com System.out.println(posição).",
                                  "learningObjective": "Codificar estratégia de exclusão funcional em lexer Java.",
                                  "commonMistakes": "Avançar ponteiro sem retry; reportar erro sem posição precisa."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Testar e Refinar Recuperação de Erros",
                                  "subSteps": [
                                    "Crie casos de teste: inválido isolado, múltiplos inválidos, no início/fim de input.",
                                    "Meça sincronização: lexer deve recuperar e parse resto corretamente.",
                                    "Analise logs de erro para cobertura.",
                                    "Otimize: adicione limite de skips (ex: 10) e fallback para panic mode.",
                                    "Documente código com comentários sobre recuperação."
                                  ],
                                  "verification": "90%+ taxa de recuperação em 10+ testes; zero crashes.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "JUnit, inputs de teste em arquivos .txt.",
                                  "tips": "Automatize testes com assertions em tokens esperados.",
                                  "learningObjective": "Validar implementação através de testes abrangentes.",
                                  "commonMistakes": "Testes só com casos felizes; ignorar edge cases como EOF após erro."
                                }
                              ],
                              "practicalExample": "Em um lexer Java para expressões aritméticas, input '2+3@*5' (onde '@' é inválido): reporte erro em '@' (posição 4), avance, match '*' e '5', retornando tokens: NUM(2), PLUS, MUL, NUM(5). Código snippet: if (!Character.isLetterOrDigit(c) && !isOperator(c)) { error(\"Invalid char: \" + c); advance(); continue; }",
                              "finalVerifications": [
                                "Lexer reporta exatamente o caractere e posição inválida.",
                                "Matching recomeça corretamente após skip único ou múltiplo.",
                                "Tokens restantes são extraídos sem perda de sincronização.",
                                "Não há loops infinitos ou crashes em inputs 100% inválidos.",
                                "Logs de erro são claros e úteis para debug.",
                                "Performance não degrada >10% com erros."
                              ],
                              "assessmentCriteria": [
                                "Pseudocódigo e implementação corretos (80% peso).",
                                "Cobertura de testes >80% para cenários de erro.",
                                "Relatórios de erro precisos e informativos.",
                                "Recuperação mantém integridade dos tokens válidos.",
                                "Código limpo, comentado e modular.",
                                "Tratamento de edge cases (EOF, skips múltiplos)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Autômatos finitos e transições de erro em teoria da computação.",
                                "Programação: Programação defensiva e exception handling.",
                                "Inglês: Documentação técnica de erros em relatórios.",
                                "Design de Software: UX em ferramentas de parsing (IDEs, editores)."
                              ],
                              "realWorldApplication": "Parsers de linguagens de configuração (JSON/XML em apps web), editores de código que sugerem correções (VS Code), compiladores industriais (GCC/Clang) para código com typos, scanners de segurança que ignoram ruído em inputs maliciosos."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.4.1.3.2",
                            "name": "Usar inserção de caracteres esperados",
                            "description": "Detectar contexto (ex: falta de ';' ou aspas) e inserir automaticamente o caractere faltante para prosseguir, reportando a correção sugerida.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o Conceito de Inserção de Caracteres Esperados em Analisadores Léxicos",
                                  "subSteps": [
                                    "Estude a fase léxica de um compilador e o papel da recuperação de erros.",
                                    "Analise estados do autômato finito do lexer quando um token esperado falha.",
                                    "Identifique caracteres comuns faltantes: ';', '\"', '(', '{', etc.",
                                    "Revise exemplos de fluxos de erro em analisadores léxicos como Flex ou hand-written.",
                                    "Discuta como a inserção evita paralisação total do parsing."
                                  ],
                                  "verification": "Explique em suas palavras como a inserção de ';' resolve um erro léxico em uma declaração if sem ponto e vírgula.",
                                  "estimatedTime": "45 min",
                                  "materials": [
                                    "Documentação de compiladores (Dragon Book capítulo 3)",
                                    "Exemplos de código lexer em C/Python",
                                    "Diagrama de autômato lexer"
                                  ],
                                  "tips": "Visualize o estado do lexer com ferramentas como Graphviz para autômatos.",
                                  "learningObjective": "Entender o mecanismo de recuperação por inserção em erros léxicos.",
                                  "commonMistakes": [
                                    "Confundir erros léxicos com sintáticos.",
                                    "Ignorar impacto na precisão do parsing subsequente."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Detectar Contextos de Caracteres Faltantes",
                                  "subSteps": [
                                    "Implemente uma pilha de estados ou lookahead para rastrear tokens esperados.",
                                    "Defina regras para contextos: após declaração (espera ';'), string aberta (espera '\"'), etc.",
                                    "Crie funções para verificar lookahead e estado atual do buffer de input.",
                                    "Teste detecção em inputs sintéticos com erros intencionais.",
                                    "Registre logs de detecção para depuração."
                                  ],
                                  "verification": "Forneça um input com '\"' faltante em string e mostre log confirmando detecção.",
                                  "estimatedTime": "60 min",
                                  "materials": [
                                    "Editor de código (VS Code)",
                                    "Lexer base em Python/C",
                                    "Inputs de teste com erros léxicos"
                                  ],
                                  "tips": "Use lookahead de 1-2 caracteres para precisão sem overhead excessivo.",
                                  "learningObjective": "Desenvolver lógica para identificar precisamente quando inserir caracteres.",
                                  "commonMistakes": [
                                    "Falsos positivos em contextos ambíguos.",
                                    "Lookahead insuficiente levando a detecções erradas."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar Inserção Automática e Relato de Correção",
                                  "subSteps": [
                                    "Modifique o lexer para inserir o caractere no buffer e avançar o estado.",
                                    "Gere mensagem de erro: 'Inserido \";\" esperado após declaração na linha X'.",
                                    "Continue parsing sem pausar, atualizando contadores de linha/coluna.",
                                    "Integre com handler de erros existente para múltiplas recuperações.",
                                    "Valide que o token subsequente é consumido corretamente."
                                  ],
                                  "verification": "Execute lexer em código com múltiplos erros e confirme inserções e relatórios corretos.",
                                  "estimatedTime": "75 min",
                                  "materials": [
                                    "Lexer modificável",
                                    "Suite de testes unitários para lexer",
                                    "Ferramenta de linting para validação"
                                  ],
                                  "tips": "Limite inserções por declaração para evitar loops infinitos.",
                                  "learningObjective": "Codificar inserção seamless com feedback ao usuário.",
                                  "commonMistakes": [
                                    "Inserir caractere errado baseado em lookahead fraco.",
                                    "Não atualizar posições de erro corretamente."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Testar e Avaliar a Recuperação de Erros",
                                  "subSteps": [
                                    "Crie casos de teste: 10+ cenários com ;, \", (, etc. faltantes.",
                                    "Meça taxa de recuperação: % de códigos parcialmente parseados.",
                                    "Compare output com lexer sem recuperação.",
                                    "Otimize para performance em inputs grandes.",
                                    "Documente limitações e casos não cobertos."
                                  ],
                                  "verification": "Relatório de testes mostrando >80% de recuperação bem-sucedida em suite padrão.",
                                  "estimatedTime": "50 min",
                                  "materials": [
                                    "Framework de testes (Pytest/JUnit)",
                                    "Corpus de códigos com erros artificiais",
                                    "Profiler de performance"
                                  ],
                                  "tips": "Priorize erros comuns em linguagens reais como C/JavaScript.",
                                  "learningObjective": "Validar robustez da implementação em cenários reais.",
                                  "commonMistakes": [
                                    "Testes insuficientes para edge cases.",
                                    "Ignorar impacto cumulativo de múltiplas inserções."
                                  ]
                                }
                              ],
                              "practicalExample": "Em um lexer para uma linguagem similar a C, input: 'int x = 1 if (x>0)'. Detecção após '1': estado espera ';'. Inserção: 'int x = 1; if (x>0)', relatório: 'Inserido \";\" na linha 1, coluna 10'. Parsing continua com 'if'.",
                              "finalVerifications": [
                                "Lexer recupera de falta de ';' após 90% das declarações testadas.",
                                "Inserção de '\"' fecha strings abertas corretamente sem quebrar parsing.",
                                "Relatórios de correção incluem linha/coluna precisos.",
                                "Múltiplas inserções consecutivas não causam loops ou crashes.",
                                "Performance degradada <10% em inputs com erros.",
                                "Tokens subsequentes são reconhecidos após inserção."
                              ],
                              "assessmentCriteria": [
                                "Precisão na detecção de contextos ( >95% acurácia).",
                                "Corretude das inserções em tokens esperados.",
                                "Qualidade dos relatórios de erro (informativos e localizados).",
                                "Robustez contra inputs maliciosos ou edge cases.",
                                "Eficiência computacional (O(1) por inserção).",
                                "Integração seamless com parsing sintático subsequente."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Autômatos finitos e estados de erro em teoria da computação.",
                                "Linguística: Análise morfológica e recuperação em processamento de linguagem natural.",
                                "Engenharia de Software: Tratamento de exceções e resiliência em sistemas.",
                                "Design de UX: Feedback amigável em ferramentas de desenvolvimento."
                              ],
                              "realWorldApplication": "IDEs como Visual Studio Code ou IntelliJ usam inserção automática de ';' ou aspas em editores inteligentes, permitindo edição contínua sem interrupções, melhorando produtividade de desenvolvedores em linguagens como JavaScript ou Python."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.4.1.3.3",
                            "name": "Estratégias de modo pânico para léxico",
                            "description": "Pular até o próximo delimitador válido (espaço, nova linha ou token conhecido) para recuperar sincronização rápida.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o Conceito de Modo Pânico no Lexer",
                                  "subSteps": [
                                    "Estude a função do lexer em compiladores e os desafios de erros léxicos.",
                                    "Analise exemplos de entrada inválida que causam dessincronização.",
                                    "Explique por que estratégias locais como modo pânico são preferíveis a paradas abruptas.",
                                    "Compare modo pânico com outras estratégias de recuperação léxica.",
                                    "Identifique cenários onde a sincronização rápida é crítica para relatórios de múltiplos erros."
                                  ],
                                  "verification": "Escreva um parágrafo resumindo o conceito e seus benefícios em suas próprias palavras.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Documentação de compiladores (ex: Dragon Book)",
                                    "Exemplos de código fonte com erros léxicos"
                                  ],
                                  "tips": "Visualize o lexer como um 'scanner' que precisa 'pular buracos' para continuar escaneando.",
                                  "learningObjective": "Dominar os fundamentos teóricos do modo pânico para recuperação léxica.",
                                  "commonMistakes": [
                                    "Confundir modo pânico com recuperação sintática",
                                    "Subestimar o impacto em diagnósticos de erros múltiplos"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar e Classificar Delimitadores Válidos",
                                  "subSteps": [
                                    "Liste delimitadores comuns: espaços, novas linhas, ponto e vírgula, chaves e parênteses.",
                                    "Defina critérios para 'token conhecido': palavras-chave, identificadores válidos.",
                                    "Crie uma tabela categorizando delimitadores por tipo (branco, estrutural, simbólico).",
                                    "Teste em amostras de código real para validar classificações.",
                                    "Considere variações por linguagem (ex: ; em C vs. fim de linha em Python)."
                                  ],
                                  "verification": "Crie e valide uma tabela de delimitadores com pelo menos 10 exemplos.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Especificações de linguagens (C, Java)",
                                    "Editor de texto para análise manual"
                                  ],
                                  "tips": "Priorize delimitadores de alta sincronização como ; e } para recuperação robusta.",
                                  "learningObjective": "Capacitar a seleção precisa de pontos de sincronização no fluxo léxico.",
                                  "commonMistakes": [
                                    "Incluir tokens inválidos como delimitadores",
                                    "Ignorar delimitadores contextuais"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar a Lógica de Pulo no Lexer",
                                  "subSteps": [
                                    "Modifique o loop principal do lexer para detectar caracteres inválidos.",
                                    "Adicione lógica condicional: avance até encontrar delimitador válido.",
                                    "Registre o erro (posição, caractere inválido) sem interromper o scan.",
                                    "Integre flags de modo pânico para alternar comportamentos.",
                                    "Teste unitário com input simples contendo erro único."
                                  ],
                                  "verification": "Execute o lexer em input com erro e confirme que pula corretamente para o próximo token válido.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Código base de um lexer simples (Flex ou handmade)",
                                    "Ambiente de desenvolvimento (VS Code, GCC)"
                                  ],
                                  "tips": "Use um buffer de lookahead para evitar loops infinitos no pulo.",
                                  "learningObjective": "Desenvolver código funcional para recuperação automática via pulo.",
                                  "commonMistakes": [
                                    "Pular demais e perder tokens válidos subsequentes",
                                    "Não registrar erros adequadamente"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Testar e Validar a Estratégia de Recuperação",
                                  "subSteps": [
                                    "Crie casos de teste: erro isolado, múltiplos erros, erros no fim de linha.",
                                    "Meça métricas: tempo de recuperação, tokens perdidos, precisão de relatório.",
                                    "Compare saída com/ sem modo pânico em inputs complexos.",
                                    "Ajuste thresholds para pulo baseado em testes.",
                                    "Documente lições aprendidas em um relatório de testes."
                                  ],
                                  "verification": "Todos os testes passam: recuperação sem crash e relatórios corretos.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Suite de testes unitários (JUnit ou scripts bash)",
                                    "Inputs de teste variados"
                                  ],
                                  "tips": "Automatize testes para cobrir edge cases como strings longas inválidas.",
                                  "learningObjective": "Garantir robustez e eficiência da implementação através de validação empírica.",
                                  "commonMistakes": [
                                    "Testes insuficientes para erros compostos",
                                    "Ignorar performance em inputs grandes"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um lexer para C, input: 'int main() { x = abc@def; }'. Ao encontrar '@', modo pânico pula até ';', reporta erro em '@' e continua tokenizando 'def;' corretamente, permitindo detecção de erros subsequentes.",
                              "finalVerifications": [
                                "Lexer recupera sincronização sem crashar em 100% dos casos testados.",
                                "Relatórios de erro incluem posição exata do inválido.",
                                "Tokens válidos após erro são reconhecidos corretamente.",
                                "Não há consumo excessivo de input durante pulo.",
                                "Performance degradada <10% em inputs com erros.",
                                "Múltiplos erros consecutivos são todos reportados."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação e pulo para delimitadores (90%+ acurácia).",
                                "Eficiência: tempo de execução comparável ao lexer sem erros.",
                                "Robustez: lida com edge cases sem loops ou vazamentos.",
                                "Clareza do código: comentários e estrutura modular.",
                                "Qualidade dos relatórios de erro: informativos e posicionais.",
                                "Escalabilidade: funciona em inputs >1MB."
                              ],
                              "crossCurricularConnections": [
                                "Análise Sintática: sincronização similar em recovery de parsers.",
                                "Engenharia de Software: técnicas de fault-tolerance e resiliência.",
                                "Processamento de Linguagem Natural: tokenização robusta em NLP.",
                                "Debugging: estratégias para diagnósticos em ferramentas de dev."
                              ],
                              "realWorldApplication": "Implementado em compiladores como GCC e Clang para fornecer diagnósticos úteis em código com múltiplos erros, permitindo desenvolvedores corrigirem issues sem recompilações parciais por erro único."
                            },
                            "estimatedTime": "0.5 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.4.1.3.4",
                            "name": "Avaliar trade-offs de recuperação",
                            "description": "Comparar eficácia de técnicas como exclusão vs. inserção em termos de precisão de diagnóstico e completude da análise, com casos de teste.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender as Técnicas Básicas de Recuperação de Erros Léxicos",
                                  "subSteps": [
                                    "Estude a técnica de exclusão: remover caracteres ou tokens suspeitos até encontrar um token válido.",
                                    "Estude a técnica de inserção: adicionar caracteres ou tokens faltantes para sincronizar o lexer.",
                                    "Compare definições formais das duas técnicas usando diagramas de fluxo.",
                                    "Implemente um lexer simples em Python ou C que demonstre ambas as técnicas sem tratamento de erros.",
                                    "Analise exemplos de código-fonte onde erros léxicos ocorrem, como caracteres inválidos ou faltantes."
                                  ],
                                  "verification": "Implemente um lexer básico que tokeniza input válido corretamente para ambas as técnicas.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Documentação de lexers (Flex manual)",
                                    "Editor de código (VS Code)",
                                    "Exemplos de gramáticas léxicas simples"
                                  ],
                                  "tips": "Use regex para definir tokens iniciais e foque em casos edge como strings malformadas.",
                                  "learningObjective": "Identificar diferenças fundamentais entre exclusão e inserção em recuperação léxica.",
                                  "commonMistakes": [
                                    "Confundir exclusão com skipping total do input",
                                    "Ignorar sincronização pós-erro",
                                    "Não considerar impacto na análise sintática subsequente"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Definir Métricas de Avaliação para Trade-offs",
                                  "subSteps": [
                                    "Defina precisão de diagnóstico: porcentagem de erros corretamente identificados sem falsos positivos.",
                                    "Defina completude da análise: porcentagem do código processado após recuperação sem perda excessiva.",
                                    "Crie fórmulas matemáticas para métricas, ex: Precisão = (TP / (TP + FP)) * 100.",
                                    "Liste outros trade-offs: tempo de processamento, overhead computacional, legibilidade do diagnóstico.",
                                    "Desenvolva uma tabela comparativa de métricas esperadas para exclusão vs. inserção."
                                  ],
                                  "verification": "Crie um documento com fórmulas e tabela de métricas definidas e justificadas.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Planilha (Google Sheets ou Excel)",
                                    "Artigos sobre avaliação de compiladores (Dragon Book capítulo 4)",
                                    "Calculadora ou Python para simulações"
                                  ],
                                  "tips": "Priorize métricas quantificáveis; use exemplos numéricos para ilustrar.",
                                  "learningObjective": "Estabelecer critérios objetivos para comparar eficácia das técnicas.",
                                  "commonMistakes": [
                                    "Definir métricas vagas sem fórmulas",
                                    "Ignorar trade-offs de performance",
                                    "Focar apenas em precisão sem completude"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Criar e Executar Casos de Teste",
                                  "subSteps": [
                                    "Gere 10-15 casos de teste com erros léxicos: caracteres inválidos, tokens incompletos, sequências ambíguas.",
                                    "Implemente o lexer com ambas as técnicas de recuperação e rode os testes.",
                                    "Registre saídas: tokens recuperados, diagnósticos emitidos, tempo gasto.",
                                    "Meça métricas para cada técnica em todos os casos.",
                                    "Automatize testes com scripts para reprodutibilidade."
                                  ],
                                  "verification": "Produza um relatório com resultados tabulados de pelo menos 10 casos testados.",
                                  "estimatedTime": "3 horas",
                                  "materials": [
                                    "Lexer código-fonte (Python/Flex)",
                                    "Suite de testes (arquivos .input com erros)",
                                    "Ferramentas de profiling (timeit em Python)"
                                  ],
                                  "tips": "Inclua casos reais de erros comuns em código fonte; randomize alguns para robustez.",
                                  "learningObjective": "Aplicar técnicas em cenários controlados e coletar dados empíricos.",
                                  "commonMistakes": [
                                    "Casos de teste insuficientes ou não representativos",
                                    "Não registrar falsos positivos/negativos",
                                    "Ignorar variações de input size"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar Trade-offs e Concluir Avaliação",
                                  "subSteps": [
                                    "Compare métricas quantitativamente: gráficos de precisão vs. completude.",
                                    "Avalie qualitativamente: cenários onde uma técnica supera a outra (ex: exclusão para ruído, inserção para omissões).",
                                    "Discuta trade-offs gerais: impacto na fase sintática, escalabilidade.",
                                    "Recomende técnica híbrida baseada em análise.",
                                    "Documente lições aprendidas e sugestões de melhoria."
                                  ],
                                  "verification": "Gere um relatório final com gráficos, comparações e recomendações.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Ferramentas de plotagem (Matplotlib ou Excel)",
                                    "Templates de relatório LaTeX/Markdown"
                                  ],
                                  "tips": "Use visualizações para destacar trade-offs; considere thresholds de decisão.",
                                  "learningObjective": "Sintetizar dados em insights acionáveis sobre trade-offs.",
                                  "commonMistakes": [
                                    "Análise superficial sem gráficos",
                                    "Viés em favor de uma técnica sem dados",
                                    "Não propor soluções híbridas"
                                  ]
                                }
                              ],
                              "practicalExample": "Considere input: 'int x = ;' (erro: ';' faltante após valor). Exclusão: remove ';' inválido, diagnostica 'valor faltante', completa análise com 90% precisão mas perde sincronização. Inserção: insere '0;' após '=', diagnostica 'valor omitido', mantém 95% completude mas risco de falsos positivos em contextos complexos.",
                              "finalVerifications": [
                                "Implementou lexer com ambas técnicas e rodou 10+ testes.",
                                "Calculou precisão e completude com fórmulas corretas.",
                                "Produziu gráficos comparativos de métricas.",
                                "Identificou pelo menos 3 cenários onde uma técnica é superior.",
                                "Recomendou abordagem baseada em evidências.",
                                "Documentou erros comuns observados nos testes."
                              ],
                              "assessmentCriteria": [
                                "Precisão nas definições de métricas (20%)",
                                "Qualidade e diversidade dos casos de teste (25%)",
                                "Exatidão dos cálculos e análises quantitativas (20%)",
                                "Profundidade da discussão de trade-offs (20%)",
                                "Clareza do relatório e visualizações (10%)",
                                "Criatividade em recomendações híbridas (5%)"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Análise de trade-offs via funções de utilidade e otimização.",
                                "Engenharia de Software: Design de sistemas resilientes a falhas.",
                                "Estatística: Métricas de avaliação empírica e testes de hipótese.",
                                "Análise de Dados: Visualização e interpretação de resultados experimentais."
                              ],
                              "realWorldApplication": "Em compiladores como GCC ou Clang, avaliar trade-offs otimiza mensagens de erro para desenvolvedores, reduzindo tempo de debug em IDEs como VS Code, e melhora robustez em ferramentas de linting como ESLint para JavaScript."
                            },
                            "estimatedTime": "0.5 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.4.2",
                    "name": "Tratamento de Erros Sintáticos em Parsers Top-Down",
                    "description": "Métodos de recuperação em analisadores descendentes, incluindo simplificação de lookahead e produções de erro.",
                    "individualConcepts": [
                      {
                        "id": "10.1.4.2.1",
                        "name": "Detecção de Erros Sintáticos em Parsers Top-Down",
                        "description": "Processo pelo qual os analisadores sintáticos descendentes identificam discrepâncias entre o token de entrada atual e as expectativas definidas pelas regras de produção, utilizando lookahead para prever expansões possíveis de não-terminais.",
                        "specificSkills": [
                          {
                            "id": "10.1.4.2.1.1",
                            "name": "Explicar o papel do lookahead na detecção de erros",
                            "description": "Descrever como o conjunto FIRST de uma produção é comparado com o lookahead para detectar falhas em parsers recursive descent ou LL(1), incluindo exemplos de gramáticas simples onde o erro ocorre.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender os Conceitos Fundamentais de Lookahead e Conjuntos FIRST",
                                  "subSteps": [
                                    "Defina lookahead como o token atual ou próximo na entrada do parser.",
                                    "Explique que em parsers recursive descent ou LL(1), lookahead é usado para decidir qual produção aplicar.",
                                    "Descreva o conjunto FIRST de uma produção como os terminais que podem iniciar strings derivadas dela.",
                                    "Estude a tabela LL(1) e como ela usa FIRST para previsibilidade.",
                                    "Revise uma gramática simples, como E → T + E | T, e calcule seus FIRST sets."
                                  ],
                                  "verification": "Liste corretamente os FIRST sets para uma gramática de expressões aritméticas simples.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Documentação de compiladores (ex: Dragon Book capítulo 4)",
                                    "Editor de texto para anotar gramáticas",
                                    "Ferramenta online de cálculo de FIRST sets (ex: JFLAP)"
                                  ],
                                  "tips": [
                                    "Comece com gramáticas sem recursão esquerda para simplicidade.",
                                    "Use diagramas de árvore de derivação para visualizar FIRST."
                                  ],
                                  "learningObjective": "Compreender como lookahead e FIRST sets são calculados e usados em parsers top-down.",
                                  "commonMistakes": [
                                    "Confundir FIRST com FOLLOW sets.",
                                    "Ignorar ε-produções ao calcular FIRST.",
                                    "Assumir que lookahead é sempre 1 token à frente."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar o Mecanismo de Detecção de Erros via Comparação Lookahead-FIRST",
                                  "subSteps": [
                                    "Descreva o algoritmo: ao tentar uma produção, verifique se lookahead ∈ FIRST(produção).",
                                    "Explique falha: se lookahead não pertence a nenhum FIRST das alternativas, sinalize erro sintático.",
                                    "Simule o processo em pseudocódigo para uma função de parsing não-terminal.",
                                    "Discuta como parsers LL(1) usam tabelas de parsing para automatizar essa checagem.",
                                    "Compare com backtracking em parsers não-LL(k), destacando eficiência do lookahead fixo."
                                  ],
                                  "verification": "Escreva pseudocódigo que detecta erro quando lookahead não matches FIRST.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Pseudocódigo de parser recursive descent",
                                    "Compilador simples em Python ou Java para teste",
                                    "Notas sobre tabelas LL(1)"
                                  ],
                                  "tips": [
                                    "Trace o parser passo a passo com entrada inválida.",
                                    "Use debug prints para mostrar lookahead e FIRST checks."
                                  ],
                                  "learningObjective": "Dominar o fluxo de decisão de lookahead vs. FIRST para detecção precoce de erros.",
                                  "commonMistakes": [
                                    "Pensar que erro só ocorre no final da entrada.",
                                    "Esquecer de tratar lookahead para produções nullable.",
                                    "Confundir detecção local com correção global de erros."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Aplicar em Exemplos de Gramáticas Simples com Erros",
                                  "subSteps": [
                                    "Pegue gramática: S → a S b | ε. Calcule FIRST(S) = {a, ε}.",
                                    "Simule entrada 'a b c': lookahead 'a' OK, mas após matching, lookahead 'c' ∉ FOLLOW ou FIRST esperados.",
                                    "Identifique erro: lookahead 'c' não em FIRST das produções de S após recursão.",
                                    "Teste gramática ambígua como E → id + E | id * E, mostrando conflito LL(1).",
                                    "Implemente um parser toy que reporta 'Unexpected token: X (expected FIRST: Y)'."
                                  ],
                                  "verification": "Simule parsing de entrada inválida e identifique exatamente onde lookahead falha.",
                                  "estimatedTime": "75 minutos",
                                  "materials": [
                                    "Exemplos de gramáticas LL(1) e não-LL(1)",
                                    "Parser generator online (ex: ANTLR playground)",
                                    "Papel e lápis para tracing manual"
                                  ],
                                  "tips": [
                                    "Escolha entradas que falhem no primeiro lookahead para clareza.",
                                    "Registre estado do parser (posição, pilha) em cada check."
                                  ],
                                  "learningObjective": "Reconhecer padrões de erro via lookahead em gramáticas concretas.",
                                  "commonMistakes": [
                                    "Não calcular FIRST corretamente para recursão.",
                                    "Ignorar contexto FOLLOW em erros propagados.",
                                    "Assumir que todo mismatch é erro de lookahead (pode ser semântico)."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Sintetizar e Verificar o Papel do Lookahead na Detecção",
                                  "subSteps": [
                                    "Resuma: lookahead permite detecção local e eficiente sem backtrack excessivo.",
                                    "Compare parsers sem lookahead (ex: pure recursive descent ingênuo) vs. com FIRST checks.",
                                    "Crie diagrama ilustrando fluxo: match? → sim/produção | não → erro.",
                                    "Discuta limitações: erros em FOLLOW requerem lookahead extra (LL(k) k>1).",
                                    "Teste com variação: adicione recuperação de erro básica pós-detecção."
                                  ],
                                  "verification": "Explique verbalmente ou por escrito o papel com um exemplo completo.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Ferramenta de diagramação (ex: Draw.io)",
                                    "Código fonte de um parser real (ex: mini-compilador em C)"
                                  ],
                                  "tips": [
                                    "Use analogia: lookahead como 'olhar à frente no trânsito' para evitar colisões.",
                                    "Foquem em eficiência: O(1) check vs. tentativa/erro."
                                  ],
                                  "learningObjective": "Integrar conceitos em explicação coesa sobre detecção de erros.",
                                  "commonMistakes": [
                                    "Superestimar lookahead como 'corrigidor' de gramáticas não-LL(1).",
                                    "Omitir exemplos onde lookahead sozinho não basta.",
                                    "Confundir sintático com léxico."
                                  ]
                                }
                              ],
                              "practicalExample": "Gramática: Expr → Term + Expr | Term; Term → id | num. FIRST(Expr) = {id, num}. Entrada: 'id * id'. Ao parse Expr, lookahead 'id' OK → Term → id OK, então + esperado mas lookahead '*' ∉ FIRST(Expr após +), erro detectado: 'Unexpected * (expected id/num or +)'.",
                              "finalVerifications": [
                                "Calcula corretamente FIRST sets para gramáticas dadas.",
                                "Simula detecção de erro apontando mismatch lookahead-FIRST.",
                                "Explica diferenças entre parsers com/sem lookahead checks.",
                                "Identifica gramáticas LL(1) vs. não-LL(1) baseadas em FIRST.",
                                "Implementa pseudocódigo simples de checagem de lookahead.",
                                "Reporta erros com mensagem precisa incluindo lookahead atual."
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição e cálculo de FIRST e lookahead (90%+ correto).",
                                "Clareza na explicação do mecanismo de detecção (lógica sequencial).",
                                "Uso de exemplos relevantes e simulações passo a passo.",
                                "Identificação correta de pontos de falha em traces de parsing.",
                                "Compreensão de limitações e contextos LL(1)/recursive descent.",
                                "Capacidade de generalizar para gramáticas mais complexas."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria de Conjuntos (operações em FIRST).",
                                "Lógica e Algoritmos: Decisão baseada em membership testing.",
                                "Programação: Implementação de recursão e parsing em linguagens.",
                                "Engenharia de Software: Tratamento de exceções e robustez em ferramentas."
                              ],
                              "realWorldApplication": "Em compiladores como GCC/Clang ou IDEs (VS Code, IntelliJ), lookahead detecta erros sintáticos em tempo real durante digitação, fornecendo feedback imediato como 'Expected ; after statement' em editores com syntax highlighting e error squiggles."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.4.2.1.2",
                            "name": "Identificar pontos comuns de falha em parsers descendentes",
                            "description": "Reconhecer cenários típicos de erros sintáticos, como mismatch de tokens esperados versus recebidos, e ilustrar com pseudocódigo de uma função de parsing que entra em modo de erro.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Fundamentos de Parsers Descendentes",
                                  "subSteps": [
                                    "Leia a definição de parser descendente recursivo e como ele usa funções recursivas para matching de gramáticas LL(1).",
                                    "Desenhe um diagrama simples de uma gramática de exemplo (ex: expressões aritméticas) e trace a chamada de funções para uma entrada válida.",
                                    "Identifique o papel do lookahead token no processo de decisão de parsing.",
                                    "Compile uma lista de componentes chave: tokenizer, current token, consume function.",
                                    "Teste compreensão simulando parsing manual de uma string simples como '1 + 2 * 3'."
                                  ],
                                  "verification": "Você pode manualmente parsear uma entrada válida sem erros e explicar cada transição de função.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Documentação sobre parsers LL(1)",
                                    "Papel e caneta para diagramas",
                                    "Exemplos de gramáticas simples"
                                  ],
                                  "tips": "Comece com gramáticas simples sem left-recursion para evitar confusão inicial.",
                                  "learningObjective": "Entender a mecânica básica de matching recursivo em parsers descendentes.",
                                  "commonMistakes": [
                                    "Confundir tokenizer com parser",
                                    "Ignorar lookahead e assumir parsing greedy",
                                    "Não considerar recursão na estrutura"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar Mismatches de Tokens como Ponto de Falha Primário",
                                  "subSteps": [
                                    "Analise o que acontece quando o token atual não matches o esperado (ex: expect(')', got 'ID')).",
                                    "Estude a função 'consume(expected)' e como ela sinaliza erro se mismatch.",
                                    "Liste 3 cenários: fim prematuro de input, token inesperado, sequência inválida.",
                                    "Simule em pseudocódigo: if (currentToken != expected) { error('Unexpected token') }.",
                                    "Compare com parsing bottom-up para destacar diferenças em detecção de erro."
                                  ],
                                  "verification": "Descreva verbalmente ou por escrito 3 exemplos de mismatch e o estado do parser neles.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Pseudocódigo de parser simples",
                                    "Editor de texto para simulações",
                                    "Lista de tokens de exemplo"
                                  ],
                                  "tips": "Use um debugger mental: pause no mismatch e pergunte 'o que o parser esperava vs. recebeu?'.",
                                  "learningObjective": "Reconhecer o mismatch de tokens como erro sintático clássico em descendentes.",
                                  "commonMistakes": [
                                    "Assumir que erro é no tokenizer",
                                    "Não diferenciar erro léxico de sintático",
                                    "Ignorar contexto de pilha de chamadas"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explorar Outros Pontos Comuns de Falha e Modo de Erro",
                                  "subSteps": [
                                    "Identifique falhas como recursão excessiva devido a left-recursion (embora LL evite, simule).",
                                    "Estude panic mode: skip tokens até sincronização (ex: próximo ';').",
                                    "Analise stack overflow em recursão profunda sem tail recursion.",
                                    "Crie pseudocódigo de função parseExpr() que entra em error handling.",
                                    "Teste com inputs inválidos e trace o fluxo até recovery."
                                  ],
                                  "verification": "Implemente ou trace um pseudocódigo que detecta e reporta 2 falhas diferentes.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Pseudocódigo template de parser",
                                    "Ferramenta online como Replit para simulação",
                                    "Exemplos de inputs inválidos"
                                  ],
                                  "tips": "Sempre inclua linha/coluna no report de erro para precisão.",
                                  "learningObjective": "Mapear múltiplos pontos de falha e introduzir recovery básico.",
                                  "commonMistakes": [
                                    "Não considerar recovery e parar no primeiro erro",
                                    "Confundir falha sintática com semântica",
                                    "Subestimar impacto da recursão"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Praticar Identificação com Pseudocódigo Completo",
                                  "subSteps": [
                                    "Escreva pseudocódigo de parseStmt(): expect('ID'); expect('='); parseExpr(); expect(';').",
                                    "Introduza erros: input 'x = y + ;' e identifique mismatch em expect(';').",
                                    "Adicione error mode: while not syncToken, advance().",
                                    "Debugue 3 variações de input e liste pontos de falha.",
                                    "Refatore para melhor reporting: 'Expected ; at line 1, got EOF'."
                                  ],
                                  "verification": "Produza relatório de erros para 3 inputs inválidos usando seu pseudocódigo.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Editor de código",
                                    "Lista de gramáticas de statements",
                                    "Inputs de teste inválidos"
                                  ],
                                  "tips": "Use print statements simulados para visualizar estado durante erro.",
                                  "learningObjective": "Aplicar conhecimento para diagnosticar falhas reais em pseudocódigo.",
                                  "commonMistakes": [
                                    "Parar parsing após primeiro erro sem recovery",
                                    "Erro no cálculo de posição do token",
                                    "Não ilustrar com pseudocódigo claro"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um parser para expressões: function parseExpr() { parseTerm(); while (current == '+') { consume('+'); parseTerm(); } } Falha comum: input '1 + )' causa mismatch em while (espera term após +, recebe ')'), entrando em error: 'Expected term, got ) at position 4'. Recovery: skip até ')'.",
                              "finalVerifications": [
                                "Liste 5 pontos comuns de falha em parsers descendentes com exemplos.",
                                "Trace um pseudocódigo completo com input inválido e identifique mismatch exato.",
                                "Explique diferença entre error detection em top-down vs. bottom-up.",
                                "Implemente função consume() com error handling em pseudocódigo.",
                                "Simule panic mode recovery para input com múltiplos erros.",
                                "Descreva como reportar erro com linha/coluna."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de mismatches (esperado vs. recebido).",
                                "Uso correto de pseudocódigo para ilustrar falhas.",
                                "Compreensão de recovery modes como panic.",
                                "Capacidade de listar múltiplos cenários de erro.",
                                "Clareza em relatórios de erro com contexto.",
                                "Diferenciação entre erros léxicos e sintáticos."
                              ],
                              "crossCurricularConnections": [
                                "Debugging em programação geral (identificar falhas em código).",
                                "Linguística computacional (análise sintática de linguagens naturais).",
                                "Engenharia de software (design de ferramentas de IDE com syntax highlighting).",
                                "Matemática discreta (árvores de parsing e recursão)."
                              ],
                              "realWorldApplication": "Em compiladores como GCC ou IDEs como VS Code, detectar erros sintáticos em código-fonte (ex: missing ';' em C++) fornece feedback imediato ao desenvolvedor, melhorando produtividade e aprendizado de programação."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.4.2.1.3",
                            "name": "Diferenciar erros sintáticos de léxicos em top-down",
                            "description": "Explicar a distinção entre erros reportados pelo analisador léxico e aqueles detectados pelo parser sintático descendente, com foco na propagação de tokens inválidos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o Papel do Analisador Léxico",
                                  "subSteps": [
                                    "Estude a função do analisador léxico: converter caracteres em tokens válidos.",
                                    "Identifique exemplos de erros léxicos: caracteres inválidos, números malformados ou identificadores reservados incorretos.",
                                    "Simule o processo de tokenização em um fluxograma simples.",
                                    "Observe como erros léxicos param o processo antes do parser.",
                                    "Pratique com um scanner simples em pseudocódigo."
                                  ],
                                  "verification": "Crie um fluxograma do processo léxico e liste 3 exemplos de erros léxicos detectados.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Documentação de analisadores léxicos",
                                    "Editor de texto",
                                    "Pseudocódigo de scanner"
                                  ],
                                  "tips": "Use ferramentas como Lex/Flex para visualização prática se disponível.",
                                  "learningObjective": "Explicar como o analisador léxico detecta e reporta erros antes da análise sintática.",
                                  "commonMistakes": [
                                    "Confundir erros de tokenização com parsing",
                                    "Ignorar que erros léxicos não chegam ao parser"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Explorar Erros Sintáticos em Parsers Top-Down",
                                  "subSteps": [
                                    "Revise o funcionamento de parsers descendentes: começam da raiz e expandem via produções.",
                                    "Identifique erros sintáticos: sequências de tokens que não seguem gramática, como falta de ponto e vírgula.",
                                    "Simule propagação: como um token inválido afeta expectativas do parser.",
                                    "Compare com parsers bottom-up para destacar diferenças em detecção.",
                                    "Anote mensagens de erro típicas de parsers top-down (ex: 'esperado X, encontrado Y')."
                                  ],
                                  "verification": "Descreva um erro sintático em pseudocódigo e simule o traceback do parser.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Gramática simples em BNF",
                                    "Simulador de parser online",
                                    "Exemplos de código com erros"
                                  ],
                                  "tips": "Desenhe a árvore de parsing esperada vs. real para visualizar falhas.",
                                  "learningObjective": "Diferenciar detecção de erros sintáticos pela falha em matching de produções.",
                                  "commonMistakes": [
                                    "Achar que todos os erros de token são sintáticos",
                                    "Não notar propagação em lookahead"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Diferenciar Erros Léxicos de Sintáticos",
                                  "subSteps": [
                                    "Crie uma tabela comparativa: origem (léxico vs. sintático), detecção (scanner vs. parser), exemplos.",
                                    "Analise códigos com ambos os tipos de erros e classifique cada um.",
                                    "Estude propagação: token inválido léxico é rejeitado cedo; sintático propaga até mismatch.",
                                    "Pratique identificando em logs de compiladores reais.",
                                    "Discuta impacto: léxico para código inválido, sintático para estrutura errada."
                                  ],
                                  "verification": "Classifique 5 erros em um log de compilação fornecido.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Tabela comparativa em branco",
                                    "Logs de compiladores (GCC/Clang)",
                                    "Códigos de teste"
                                  ],
                                  "tips": "Lembre: léxico falha na tokenização; sintático assume tokens válidos mas ordem errada.",
                                  "learningObjective": "Distinguir com precisão erros baseados em fase de detecção e sintomas.",
                                  "commonMistakes": [
                                    "Classificar mismatch de token como léxico",
                                    "Ignorar contexto de lookahead em top-down"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar Diferenciação em Cenários Práticos",
                                  "subSteps": [
                                    "Implemente um mini-scanner e parser top-down simples.",
                                    "Insira erros léxicos e sintáticos, observe reports.",
                                    "Analise propagação de tokens inválidos no parser.",
                                    "Melhore mensagens de erro para clareza na diferenciação.",
                                    "Teste com variações e refine compreensão."
                                  ],
                                  "verification": "Gere reports de erros para 3 códigos e explique diferenciação.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Linguagem de programação (Python/Java)",
                                    "Gramática de teste",
                                    "Debugger"
                                  ],
                                  "tips": "Use print statements para rastrear fase de erro.",
                                  "learningObjective": "Aplicar diferenciação em implementação real de parser.",
                                  "commonMistakes": [
                                    "Não isolar fases corretamente",
                                    "Confundir lookahead com token inválido"
                                  ]
                                }
                              ],
                              "practicalExample": "Considere o código: 'int x = abc + ;' Erro léxico: 'abc' pode ser token inválido se não reconhecido; sintático: falta operador após '+', detectado pelo parser top-down ao falhar em expressão esperada, propagando o ';' como mismatch.",
                              "finalVerifications": [
                                "Explica corretamente a distinção entre fases léxica e sintática.",
                                "Identifica erros léxicos em exemplos sem parsing.",
                                "Descreve propagação de tokens inválidos em top-down.",
                                "Classifica erros em logs reais com 90% acurácia.",
                                "Simula detecção em pseudocódigo.",
                                "Diferencia impactos em compilação."
                              ],
                              "assessmentCriteria": [
                                "Precisão na distinção de fases de detecção (léxico vs. sintático).",
                                "Compreensão de propagação em parsers descendentes.",
                                "Uso correto de terminologia (token, lookahead, mismatch).",
                                "Capacidade de análise em exemplos concretos.",
                                "Clareza em explicações comparativas.",
                                "Aplicação prática em simulações."
                              ],
                              "crossCurricularConnections": [
                                "Programação: Debugging em IDEs como VS Code.",
                                "Linguística Computacional: Análise morfológica vs. sintática.",
                                "Engenharia de Software: Tratamento de exceções em parsers.",
                                "Matemática: Autômatos finitos (léxico) vs. gramáticas livres.",
                                "Design de Sistemas: UX em mensagens de erro de compiladores."
                              ],
                              "realWorldApplication": "Em desenvolvimento de compiladores (GCC, Javac) ou IDEs (IntelliJ), permite diagnósticos precisos de erros, melhorando produtividade de programadores ao destacar se o problema é digitação (léxico) ou lógica estrutural (sintático)."
                            },
                            "estimatedTime": "0.25 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.4.2.2",
                        "name": "Simplificação de Lookahead para Recuperação",
                        "description": "Técnica de recuperação de erros que reduz ou simplifica o conjunto de lookahead, permitindo que o parser avance pulando tokens inesperados ou aceitando aproximações para sincronizar com a entrada válida subsequente.",
                        "specificSkills": [
                          {
                            "id": "10.1.4.2.2.1",
                            "name": "Descrever a simplificação de lookahead em recuperação",
                            "description": "Explicar como diminuir o escopo do lookahead (de LL(k) para LL(1) ou ignorar certos tokens) ajuda na recuperação, com exemplos de implementação em pseudocódigo de parser descendente.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Fundamentos de Lookahead em Parsers Descendentes LL(k)",
                                  "subSteps": [
                                    "Defina lookahead como o número de tokens à frente que o parser examina para decidir a produção a usar.",
                                    "Compare LL(1) (um token) com LL(k) (k tokens), destacando maior precisão mas complexidade em LL(k).",
                                    "Estude pseudocódigo básico de um parser descendente recursivo com lookahead configurável.",
                                    "Analise como lookahead afeta a predição de não-terminais em gramáticas LL.",
                                    "Identifique o papel do lookahead na recuperação de erros sintáticos."
                                  ],
                                  "verification": "Escreva um resumo de 200 palavras explicando lookahead e forneça um exemplo simples de pseudocódigo LL(1) vs LL(2).",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Documentação de compiladores (ex: Dragon Book capítulo 4), editor de texto para pseudocódigo.",
                                  "tips": "Use diagramas de árvore de parsing para visualizar o escopo do lookahead.",
                                  "learningObjective": "Compreender o conceito e impacto do lookahead na eficiência do parsing.",
                                  "commonMistakes": "Confundir lookahead com backtracking; lembre-se que LL é preditivo sem backtrack."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar Desafios na Recuperação de Erros com Lookahead Amplo",
                                  "subSteps": [
                                    "Discuta como lookahead k>1 complica detecção de erros devido a ambiguidades em sequências longas.",
                                    "Examine cenários onde erros em tokens distantes propagam falhas em predições LL(k).",
                                    "Simule um erro sintático em uma gramática simples e observe falhas em recuperação com k=2 vs k=1.",
                                    "Liste desvantagens: maior overhead computacional e pior localização de erros.",
                                    "Compare com recuperação em LL(1), que é mais local e rápida."
                                  ],
                                  "verification": "Crie um exemplo de gramática onde LL(2) falha na recuperação e LL(1) succeeds; documente o raciocínio.",
                                  "estimatedTime": "50 minutos",
                                  "materials": "Papel e caneta para diagramas de parsing, simulador online de parsers (ex: LL parser demo).",
                                  "tips": "Foque em gramáticas com prefixos comuns para destacar ambiguidades.",
                                  "learningObjective": "Identificar limitações do lookahead amplo em cenários de erro.",
                                  "commonMistakes": "Ignorar impacto em performance; sempre meça complexidade O(k*n)."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Estudar Técnicas de Simplificação de Lookahead para Recuperação",
                                  "subSteps": [
                                    "Aprenda redução de LL(k) para LL(1) limitando escopo durante recuperação de erros.",
                                    "Explore ignorar tokens específicos (ex: ignorar comentários ou whitespace em lookahead).",
                                    "Estude heurísticas como 'panic mode' com lookahead mínimo.",
                                    "Analise trade-offs: perda de precisão vs ganho em velocidade e localização de erros.",
                                    "Revise exemplos teóricos de literatura de compiladores sobre simplificação condicional."
                                  ],
                                  "verification": "Liste 3 técnicas de simplificação com prós/contras em uma tabela.",
                                  "estimatedTime": "40 minutos",
                                  "materials": "Artigos ou capítulos sobre error recovery in parsers (ex: 'Engineering a Compiler' seção de errors).",
                                  "tips": "Pense em contextos onde precisão é secundária à robustez (ex: IDEs interativas).",
                                  "learningObjective": "Dominar métodos para diminuir escopo de lookahead na recuperação.",
                                  "commonMistakes": "Simplificar globalmente; aplique só em modos de erro."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Implementar Simplificação de Lookahead em Pseudocódigo",
                                  "subSteps": [
                                    "Escreva pseudocódigo de parser descendente com parâmetro lookahead k configurável.",
                                    "Adicione lógica de recuperação: se erro, set k=1 e ignore tokens não-essenciais.",
                                    "Inclua funções como skipTokens() para ignorar lookahead em certos casos.",
                                    "Teste com input inválido: verifique se recuperação sincroniza mais rápido.",
                                    "Otimize e comente o código destacando mudanças."
                                  ],
                                  "verification": "Execute pseudocódigo manualmente em 2 casos de erro e compare recuperação LL(2) vs simplificado.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Editor de código (ex: VS Code), exemplos de gramáticas sintáticas simples.",
                                  "tips": "Use console.log para tokens lookahead durante simulação.",
                                  "learningObjective": "Aplicar simplificação em código prático para recuperação eficiente.",
                                  "commonMistakes": "Não restaurar k original pós-recuperação; sempre volte ao modo normal."
                                }
                              ],
                              "practicalExample": "Em uma gramática para expressões: Expr ::= Term (('+'|'-') Term)*. Com input 'a + + b', LL(2) pode falhar prevendo após primeiro '+', mas simplificando para LL(1) na recuperação, ignora o segundo '+' como erro e sincroniza em 'b', produzindo diagnóstico preciso: 'erro inesperado +'. Pseudocódigo: if error and lookahead==2 then lookahead=1; skipIf(token in ignorable).",
                              "finalVerifications": [
                                "Explicar verbalmente como simplificação reduz overhead em recuperação.",
                                "Implementar pseudocódigo funcional para um parser com simplificação.",
                                "Simular 3 cenários de erro mostrando melhoria na localização.",
                                "Comparar tempos de recuperação LL(k) vs LL(1) em exemplos.",
                                "Identificar quando NÃO simplificar (ex: gramáticas altamente ambíguas)."
                              ],
                              "assessmentCriteria": [
                                "Precisão na explicação de conceitos de lookahead (80% cobertura).",
                                "Corretude do pseudocódigo com lógica de simplificação (testado em erros).",
                                "Profundidade de substeps e exemplos práticos fornecidos.",
                                "Análise clara de trade-offs e benefícios na recuperação.",
                                "Criatividade em conexões com aplicações reais.",
                                "Ausência de erros comuns como confusão LL vs LR."
                              ],
                              "crossCurricularConnections": [
                                "Algoritmos: Otimização de complexidade em parsing preditivo.",
                                "Teoria da Computação: Gramáticas livres de contexto e reconhecimento.",
                                "Programação: Implementação de parsers em linguagens como Python (ex: Lark library).",
                                "Engenharia de Software: Tratamento robusto de erros em ferramentas de desenvolvimento."
                              ],
                              "realWorldApplication": "Em IDEs como VS Code ou IntelliJ, parsers top-down usam simplificação de lookahead para recuperação rápida de erros de digitação, permitindo autocompletar e diagnósticos em tempo real sem travar o editor, como no parser TypeScript ou JavaScript."
                            },
                            "estimatedTime": "0.75 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.4.2.1"
                            ]
                          },
                          {
                            "id": "10.1.4.2.2.2",
                            "name": "Implementar recuperação via simplificação de lookahead",
                            "description": "Codificar uma função de parsing que, ao detectar erro, simplifica o lookahead consultando FOLLOW sets para pular até um token sincronizador.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar os FOLLOW sets para a gramática do parser",
                                  "subSteps": [
                                    "Analise a gramática da linguagem alvo e identifique os não-terminais.",
                                    "Calcule manualmente ou use uma ferramenta para gerar os FOLLOW sets de cada não-terminal.",
                                    "Implemente uma estrutura de dados (ex: Map ou Set) para armazenar os FOLLOW sets no código do parser.",
                                    "Valide os FOLLOW sets com exemplos de sentenças válidas e inválidas.",
                                    "Documente os FOLLOW sets em comentários no código."
                                  ],
                                  "verification": "Verifique se os FOLLOW sets corretamente incluem tokens sincronizadores como ';' ou EOF para produções relevantes.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Gramática da linguagem (arquivo .g4 ou similar)",
                                    "Editor de código (VS Code)",
                                    "Ferramenta de análise léxica/sintática opcional (ANTLR)"
                                  ],
                                  "tips": "Comece com uma gramática pequena para testar; FOLLOW(A) sempre inclui EOF se A pode ser o último.",
                                  "learningObjective": "Compreender e computar FOLLOW sets para suporte à recuperação de erros.",
                                  "commonMistakes": [
                                    "Confundir FOLLOW com FIRST sets",
                                    "Esquecer de propagar FOLLOW de chamadas recursivas",
                                    "Não incluir tokens de sincronização como ';'"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar detecção de erro no parser recursivo descendente",
                                  "subSteps": [
                                    "Estruture o parser com funções para cada não-terminal (ex: parseExpr(), parseStmt()).",
                                    "Adicione verificação de lookahead: consuma token apenas se match com expected.",
                                    "Ao detectar mismatch (erro), lance uma exceção ou retorne sinal de erro sem crashar.",
                                    "Mantenha um ponteiro de token atual (lookahead) atualizável.",
                                    "Teste detecção com input inválido simples, como 'a +;' em gramática de expressões."
                                  ],
                                  "verification": "O parser detecta e reporta erro sem avançar incorretamente o stream de tokens.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Código base do parser recursivo descendente",
                                    "Lexer gerado ou mock",
                                    "Exemplos de input inválido"
                                  ],
                                  "tips": "Use funções como consume() e match(token) para encapsular lookahead.",
                                  "learningObjective": "Detectar erros sintáticos precocemente sem interromper o parsing total.",
                                  "commonMistakes": [
                                    "Avançar o lookahead acidentalmente em match falho",
                                    "Não sincronizar posição após erro",
                                    "Ignorar contexto de pilha de chamadas"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Codificar a lógica de simplificação de lookahead para recuperação",
                                  "subSteps": [
                                    "Crie uma função recoverFromError(nonTerminal) que recebe o não-terminal em erro.",
                                    "No erro, avance o lookahead para o próximo token em FOLLOW(nonTerminal).",
                                    "Se múltiplos tokens em FOLLOW, escolha o menor ou mais sincronizador (ex: priorize ';').",
                                    "Pule tokens intermediários descartando-os silenciosamente ou reportando.",
                                    "Retorne ao parsing após sincronização, evitando loops infinitos."
                                  ],
                                  "verification": "Simule erro e confirme que lookahead pula para token em FOLLOW correto.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "FOLLOW sets do Step 1",
                                    "Parser com detecção de erro do Step 2",
                                    "Casos de teste com erros inseridos"
                                  ],
                                  "tips": "Implemente como while loop: while (!FOLLOW.contains(lookahead)) advance().",
                                  "learningObjective": "Simplificar lookahead usando FOLLOW para sincronização local.",
                                  "commonMistakes": [
                                    "Loop infinito se FOLLOW vazio ou mal calculado",
                                    "Pular demais e perder contexto",
                                    "Não reportar tokens pulados"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Integrar recuperação no parser e realizar testes completos",
                                  "subSteps": [
                                    "Integre recoverFromError() em todas funções de parsing onde erro pode ocorrer.",
                                    "Crie suíte de testes: inputs válidos (parsing ok), inválidos (recupera e continua).",
                                    "Meça taxa de recuperação: % de erros onde parser continua sem crash.",
                                    "Otimize para múltiplos erros consecutivos.",
                                    "Gere relatório de erros com posições e sugestões."
                                  ],
                                  "verification": "Parser processa programa com erros, reporta e parseia o resto corretamente.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Parser completo",
                                    "Framework de testes (JUnit/Pytest)",
                                    "Programa de teste com erros sintáticos intencionais"
                                  ],
                                  "tips": "Use asserts para verificar árvore sintática parcial após recuperação.",
                                  "learningObjective": "Aplicar recuperação em parser funcional com avaliação quantitativa.",
                                  "commonMistakes": [
                                    "Recuperação falha em erros aninhados",
                                    "Falsos positivos em sincronização",
                                    "Performance degradada por loops excessivos"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um parser para expressões aritméticas (E -> T E' | ε; T -> F T' | ε; etc.), ao encontrar 'x + 2;' onde 'x' é inválido após operador, simplifique lookahead: FOLLOW(E) inclui '+', ';'. Pule 'x' até '+', reporte 'token inesperado x', e continue parsing '2;' recuperando sincronização em ';'.",
                              "finalVerifications": [
                                "Parser recupera de mismatch pulando para token em FOLLOW sem crash.",
                                "Tokens pulados são reportados com posição exata.",
                                "Parsing continua corretamente após recuperação em 90% dos casos testados.",
                                "FOLLOW sets estão corretos e usados dinamicamente.",
                                "Nenhum loop infinito ou perda total de contexto.",
                                "Relatórios de erro são claros e úteis para depuração."
                              ],
                              "assessmentCriteria": [
                                "Precisão da recuperação: sincroniza corretamente sem over/under-skipping (40%).",
                                "Eficiência: tempo de parsing com erros < 2x sem erros (20%).",
                                "Cobertura de testes: pelo menos 10 casos com erros variados (20%).",
                                "Qualidade do código: modular, comentado, sem bugs em casos válidos (10%).",
                                "Relatórios de erro: informativos com sugestões (10%)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria de Linguagens Formais e Autômatos (FOLLOW como closure).",
                                "Engenharia de Software: Resiliência e Tratamento de Exceções Robustas.",
                                "Inteligência Artificial: Parsing em Processamento de Linguagem Natural (NLP).",
                                "Algoritmos: Otimização de Backtracking em Busca.",
                                "Design de Sistemas: User Experience em Ferramentas de Desenvolvimento."
                              ],
                              "realWorldApplication": "Em compiladores profissionais como GCC/Clang ou IDEs como VS Code IntelliSense, essa técnica permite diagnósticos de erro amigáveis em código fonte grande, continuando análise mesmo com múltiplos erros, acelerando depuração de programadores."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.4.2.1"
                            ]
                          },
                          {
                            "id": "10.1.4.2.2.3",
                            "name": "Avaliar eficácia da simplificação em exemplos",
                            "description": "Analisar casos de teste onde a simplificação permite recuperação sem perda excessiva de contexto, comparando com parsing sem recuperação.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os Conceitos de Parsing sem Recuperação e com Simplificação de Lookahead",
                                  "subSteps": [
                                    "Revise o funcionamento de um parser top-down recursivo sem mecanismos de recuperação de erro.",
                                    "Estude como a simplificação de lookahead reduz a complexidade ao limitar o lookahead a tokens específicos.",
                                    "Identifique diferenças chave: perda potencial de contexto vs. velocidade de recuperação.",
                                    "Anote exemplos teóricos de gramáticas onde simplificação pode falhar ou suceder.",
                                    "Compare diagramas de parsing para ambos os cenários."
                                  ],
                                  "verification": "Crie um fluxograma comparativo dos dois métodos e explique verbalmente as diferenças.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Documentação de parsers top-down, diagramas de gramáticas LL(1), editor de texto para anotações.",
                                  "tips": "Use pseudocódigo para ilustrar lookahead ilimitado vs. simplificado.",
                                  "learningObjective": "Diferenciar parsing sem recuperação de parsing com simplificação de lookahead.",
                                  "commonMistakes": "Confundir lookahead com backtracking; ignorar impacto na pilha de parsing."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Preparar Casos de Teste com Erros Sintáticos Controlados",
                                  "subSteps": [
                                    "Selecione uma gramática simples, como expressões aritméticas (e.g., E -> T + E | T).",
                                    "Crie 5-7 inputs com erros: token extra, faltante, ou mal posicionado.",
                                    "Classifique erros por tipo: inserção, deleção, substituição.",
                                    "Prepare inputs que testem perda de contexto (e.g., erro no meio de uma expressão longa).",
                                    "Documente o parsing esperado sem recuperação (falha total após erro)."
                                  ],
                                  "verification": "Liste os casos de teste em uma tabela com input, erro esperado e posição.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Editor de código, gramática de exemplo em arquivo .g4 ou texto, planilha para tabela.",
                                  "tips": "Comece com erros locais para contrastar com erros que propagam contexto.",
                                  "learningObjective": "Gerar casos de teste representativos para avaliação de recuperação.",
                                  "commonMistakes": "Casos muito simples que não revelam perda de contexto; inputs ambíguos."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Executar e Registrar Resultados de Parsing com Simplificação",
                                  "subSteps": [
                                    "Implemente ou use um parser top-down com simplificação de lookahead (e.g., limite a 1-2 tokens).",
                                    "Rode cada caso de teste e registre: ponto de detecção de erro, tokens recuperados, contexto perdido.",
                                    "Meça métricas: tokens parseados corretamente pós-erro, tempo de recuperação.",
                                    "Repita sem simplificação para baseline (falha imediata).",
                                    "Capture logs ou traces de parsing para análise."
                                  ],
                                  "verification": "Gere relatório com tabelas de resultados para cada caso, destacando recuperação vs. falha.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Implementação de parser (ANTLR, Java/Yacc), inputs de teste, debugger ou logger.",
                                  "tips": "Use verbose logging para rastrear lookahead usado.",
                                  "learningObjective": "Aplicar simplificação em prática e coletar dados empíricos.",
                                  "commonMistakes": "Não sincronizar corretamente pós-erro; ignorar overhead de tempo."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar e Comparar Eficácia, Identificando Perdas de Contexto",
                                  "subSteps": [
                                    "Compare resultados: % de contexto recuperado (tokens válidos pós-erro).",
                                    "Calcule perda excessiva: se >20% do restante é perdido, marque como ineficaz.",
                                    "Identifique padrões: simplificação eficaz em erros locais, falha em contextos aninhados.",
                                    "Visualize com gráficos: barras de recuperação por tipo de erro.",
                                    "Conclua com thresholds para 'eficaz' (e.g., >80% recuperação sem perda crítica)."
                                  ],
                                  "verification": "Escreva um parágrafo resumindo eficácia geral e casos problemáticos.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Planilha para cálculos (Excel/Google Sheets), ferramenta de gráficos (Matplotlib).",
                                  "tips": "Defina métricas quantitativas claras antes da análise.",
                                  "learningObjective": "Avaliar quantitativamente e qualitativamente a eficácia da simplificação.",
                                  "commonMistakes": "Viés subjetivo sem métricas; generalizar de poucos casos."
                                }
                              ],
                              "practicalExample": "Considere uma gramática de expressões: E → T + E | T; T → num | (E). Input com erro: '2 + (3 * a) + 4', onde 'a' é inválido. Sem recuperação: falha após 'a', ignora ') + 4'. Com simplificação (lookahead=1): detecta erro em 'a', pula para ')', recupera ') + 4' parcialmente, perdendo pouco contexto.",
                              "finalVerifications": [
                                "Pode listar pelo menos 3 casos onde simplificação recupera >80% do contexto.",
                                "Identifica 2 casos de perda excessiva e explica por quê.",
                                "Compara corretamente com parsing sem recuperação (falha total).",
                                "Métricas calculadas consistentemente (e.g., % recuperação).",
                                "Relatório inclui visualizações ou tabelas claras.",
                                "Conclusões alinhadas com dados empíricos."
                              ],
                              "assessmentCriteria": [
                                "Precisão na detecção de perda de contexto (90%+ acurácia).",
                                "Profundidade da comparação quantitativa (métricas usadas).",
                                "Qualidade dos casos de teste (diversidade e relevância).",
                                "Clareza na documentação e visualizações.",
                                "Identificação de padrões e thresholds razoáveis.",
                                "Aplicação correta de conceitos teóricos."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Análise estatística de métricas de recuperação.",
                                "Design de Software: Avaliação de trade-offs em algoritmos de erro.",
                                "Análise de Dados: Processamento e visualização de resultados de testes.",
                                "Lógica e Raciocínio: Identificação de padrões em falhas sintáticas."
                              ],
                              "realWorldApplication": "Em compiladores como GCC ou Clang, simplificação de lookahead acelera recuperação de erros em código-fonte real, permitindo diagnósticos úteis em arquivos grandes sem crash total, melhorando UX em IDEs como VS Code."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.4.2.2.1"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "10.1.4.2.3",
                        "name": "Produções de Erro em Parsers Top-Down",
                        "description": "Uso de produções sintáticas especiais na gramática que capturam padrões de erro comuns, permitindo diagnósticos precisos e recuperação local sem interromper todo o parsing.",
                        "specificSkills": [
                          {
                            "id": "10.1.4.2.3.1",
                            "name": "Definir e inserir produções de erro em uma gramática",
                            "description": "Criar regras como 'erro -> token_inválido ;' ou similares para gramáticas LL(1), garantindo que não conflitem com produções regulares via análise de FIRST/FOLLOW.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar e calcular conjuntos FIRST e FOLLOW da gramática original",
                                  "subSteps": [
                                    "Identifique todos os terminais e não-terminais na gramática LL(1) fornecida.",
                                    "Calcule o conjunto FIRST para cada não-terminal, começando pelos terminais e propagando através das produções.",
                                    "Calcule o conjunto FOLLOW para cada não-terminal, considerando o FOLLOW do lado direito das produções e o $ para o start symbol.",
                                    "Verifique se a gramática é LL(1) listando as tabelas de parsing sem conflitos."
                                  ],
                                  "verification": "Conjuntos FIRST e FOLLOW documentados corretamente e tabela de parsing LL(1) sem ambiguidades.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Gramática em formato BNF",
                                    "Planilha ou editor de texto para tabelas",
                                    "Referência de regras FIRST/FOLLOW"
                                  ],
                                  "tips": "Use iteração até fixpoint para FIRST com ε-produções; inclua lookahead em FOLLOW.",
                                  "learningObjective": "Compreender como FIRST e FOLLOW determinam previsibilidade em parsers top-down.",
                                  "commonMistakes": [
                                    "Esquecer de adicionar FOLLOW(A) ao FIRST do resto da produção em FIRST(αAβ)",
                                    "Não incluir $ no FOLLOW do símbolo inicial",
                                    "Ignorar nullable não-terminais"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar pontos de erro sintático em cenários de parsing top-down",
                                  "subSteps": [
                                    "Simule o parsing de entradas inválidas com tokens inesperados (ex: token_inválido em posições críticas).",
                                    "Mapeie onde o lookahead falha, comparando token atual com FIRST das alternativas.",
                                    "Liste tokens inválidos comuns baseados em FOLLOW dos não-terminais afetados.",
                                    "Priorize erros em estruturas como expressões ou statements onde recuperação é essencial."
                                  ],
                                  "verification": "Lista de 5-10 cenários de erro com tokens inválidos e posições de falha documentada.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Ferramenta de simulação de parser simples (ex: Python script)",
                                    "Exemplos de entradas válidas/inválidas"
                                  ],
                                  "tips": "Foque em erros de lookahead=1 típicos de LL(1), como operadores faltantes.",
                                  "learningObjective": "Reconhecer falhas de parsing top-down para guiar inserção de produções de erro.",
                                  "commonMistakes": [
                                    "Confundir erros léxicos com sintáticos",
                                    "Ignorar contexto FOLLOW para tokens permitidos",
                                    "Sobrestimar cobertura de erros triviais"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Definir produções de erro atômicas para tokens inválidos",
                                  "subSteps": [
                                    "Crie produções como 'erro -> token_inválido ;' onde token_inválido é um terminal novo ou sincronia.",
                                    "Garanta que FIRST(erro) cubra apenas tokens de erro não cobertos por FIRST das produções regulares.",
                                    "Adicione FOLLOW(erro) compatível com o contexto do não-terminal pai.",
                                    "Defina 3-5 produções de erro específicas para os cenários identificados no step 2.",
                                    "Nomeie semanticamente, ex: syntax_error -> unexpected_id ;"
                                  ],
                                  "verification": "Produções de erro definidas com FIRST/FOLLOW não sobrepondo produções válidas.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Papel ou diagrama para FIRST/FOLLOW das novas produções",
                                    "Exemplos de gramáticas com error handling (ex: ANTLR)"
                                  ],
                                  "tips": "Use tokens de sincronização como ';' para recuperação em statements.",
                                  "learningObjective": "Criar produções de erro que capturam falhas sem ambiguidades LL(1).",
                                  "commonMistakes": [
                                    "FIRST(erro) intersectando FIRST(produções válidas)",
                                    "Produções de erro muito gerais causando loops infinitos",
                                    "Esquecer ponto e vírgula ou terminais de recuperação"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Inserir produções de erro na gramática e verificar conflitos",
                                  "subSteps": [
                                    "Adicione as produções de erro aos não-terminais apropriados (ex: statement -> erro | ...).",
                                    "Recalcule FIRST e FOLLOW para toda a gramática expandida.",
                                    "Construa a tabela de parsing LL(1) e verifique ausência de conflitos múltiplos.",
                                    "Ajuste produções se houver sobreposições, priorizando erro apenas em FOLLOW inesperados."
                                  ],
                                  "verification": "Tabela de parsing LL(1) expandida sem conflitos, com entradas para erro direcionando corretamente.",
                                  "estimatedTime": "50 minutos",
                                  "materials": [
                                    "Implementação de parser generator simples ou planilha para tabela M[NT,T]",
                                    "Debugging tool para LL(1)"
                                  ],
                                  "tips": "Teste incremental: adicione um erro por vez e valide.",
                                  "learningObjective": "Integrar error handling mantendo propriedades LL(1) da gramática.",
                                  "commonMistakes": [
                                    "Não recalcular FOLLOW após inserções",
                                    "Conflitos em células da tabela por FIRST sobreposto",
                                    "Produções de erro consumindo lookahead incorretamente"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Testar e refinar o parser com produções de erro",
                                  "subSteps": [
                                    "Implemente um parser LL(1) simples em código para a gramática expandida.",
                                    "Teste com entradas inválidas dos cenários identificados, verificando detecção e recuperação.",
                                    "Meça taxa de detecção de erros e qualidade de mensagens.",
                                    "Refine produções baseadas em falhas de teste, iterando steps anteriores se necessário.",
                                    "Documente casos de teste passados/falhados."
                                  ],
                                  "verification": "Parser roda sem crash em 80% das entradas inválidas, reportando erros corretos.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Linguagem de programação (Python/Java)",
                                    "Suite de testes com 10+ entradas inválidas"
                                  ],
                                  "tips": "Use try-catch para simular recovery; logue stack de parsing.",
                                  "learningObjective": "Validar error handling em prática para robustez do parser.",
                                  "commonMistakes": [
                                    "Parser entra em loop infinito em erros",
                                    "Falsos positivos em entradas válidas",
                                    "Recuperação falha propagando pânico"
                                  ]
                                }
                              ],
                              "practicalExample": "Gramática de expressões aritméticas: Expr -> Term (('+'|'-') Term)* ; Term -> Factor (('*'|'/') Factor)* ; Factor -> '(' Expr ')' | number | id ; Adicione erro: Expr -> syntax_error ExprTail ; syntax_error -> unexpected_token ; Onde FIRST(syntax_error) = {tokens não em FIRST(Term)}, FOLLOW(Expr) inclui +,-,etc. Teste com '2 + abc * 3': detecta 'abc' como unexpected_token e recupera em '*'.",
                              "finalVerifications": [
                                "Calcula FIRST/FOLLOW corretamente para gramática com erros inseridos.",
                                "Identifica e define pelo menos 3 produções de erro sem conflitos LL(1).",
                                "Constrói tabela de parsing sem múltiplas entradas por célula.",
                                "Parser simulado detecta e recupera de tokens inválidos.",
                                "Documenta 5 cenários de teste com resultados esperados.",
                                "Explica impacto de uma produção de erro em FIRST/FOLLOW."
                              ],
                              "assessmentCriteria": [
                                "Precisão nos cálculos de FIRST/FOLLOW (100% correto).",
                                "Produções de erro cobrem cenários identificados sem ambiguidades (cobertura >80%).",
                                "Tabela LL(1) livre de conflitos demonstrada.",
                                "Explicação clara de inserção e verificação de conflitos.",
                                "Testes práticos mostram recuperação efetiva.",
                                "Documentação acionável e exemplos concretos."
                              ],
                              "crossCurricularConnections": [
                                "Teoria da Computação: Autômatos pushdown e linguagens livres de contexto.",
                                "Engenharia de Software: Desenvolvimento de ferramentas de parsing (ex: yacc/bison).",
                                "Linguística Computacional: Modelagem de erros em processamento de linguagem natural.",
                                "Programação Funcional: Parsers combinadores e error monads.",
                                "Segurança da Informação: Detecção de input malicioso em parsers."
                              ],
                              "realWorldApplication": "Em compiladores como o de Java (javac) ou JavaScript (V8), produções de erro permitem recuperação rápida em IDEs como IntelliJ ou VSCode, fornecendo diagnósticos úteis como 'unexpected token' em código quebrado, melhorando produtividade de desenvolvedores e suportando edição incremental sem recompilação total."
                            },
                            "estimatedTime": "0.75 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.4.2.1"
                            ]
                          },
                          {
                            "id": "10.1.4.2.3.2",
                            "name": "Implementar parsing com produções de erro",
                            "description": "Modificar um parser descendente para reconhecer e aplicar produções de erro, gerando mensagens específicas como 'semicolon esperado após declaração'.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar o parser descendente existente e identificar pontos de falha potenciais",
                                  "subSteps": [
                                    "Analise a gramática da linguagem suportada pelo parser.",
                                    "Execute o parser com entradas válidas para confirmar funcionamento básico.",
                                    "Teste com entradas inválidas intencionais, como falta de ponto e vírgula após declaração, e observe o comportamento atual de erro.",
                                    "Liste 3-5 pontos comuns de erro sintático na gramática (ex: fim de declaração, separadores obrigatórios).",
                                    "Documente o token atual e o estado de lookahead quando erros ocorrem."
                                  ],
                                  "verification": "Lista de pontos de erro identificados com exemplos de entradas que falham, e logs do parser mostrando pânico ou rejeição genérica.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Código fonte do parser descendente",
                                    "Editor de código (VS Code ou similar)",
                                    "Exemplos de gramática LL(1)"
                                  ],
                                  "tips": "Use depuração passo a passo para pausar no lookahead e inspecionar tokens.",
                                  "learningObjective": "Compreender a estrutura atual do parser e locais onde erros sintáticos interrompem a análise.",
                                  "commonMistakes": [
                                    "Ignorar erros em regras não-terminais profundas",
                                    "Não registrar o token atual durante falhas",
                                    "Confundir lookahead com consumo de tokens"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Definir produções de erro para casos comuns de erro sintático",
                                  "subSteps": [
                                    "Para cada ponto de erro identificado, crie uma produção de erro como: error_stmt ::= 'identifier' '=' expr ';' | error_stmt ::= 'identifier' '=' expr error ';'? onde error gera mensagem.",
                                    "Especifique mensagens claras, ex: 'Ponto e vírgula esperado após declaração'.",
                                    "Garanta que produções de erro sejam LL(1) compatíveis, priorizando sincronização sem loops infinitos.",
                                    "Defina ações de recuperação: pular tokens até sincronizar (ex: próximo ';').",
                                    "Escreva pseudocódigo para 2-3 produções de erro principais."
                                  ],
                                  "verification": "Pseudocódigo de produções de erro documentadas com mensagens específicas e regras de recuperação.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Gramática anotada do parser",
                                    "Referências sobre error productions em livros como 'Compilers: Principles, Techniques, and Tools'",
                                    "Papel ou ferramenta de diagramação"
                                  ],
                                  "tips": "Produções de erro devem ser opcionais e de baixa precedência para não afetar parsing válido.",
                                  "learningObjective": "Projetar produções de erro que melhorem diagnósticos sem quebrar a gramática válida.",
                                  "commonMistakes": [
                                    "Produções muito amplas que mascaram erros reais",
                                    "Mensagens vagas como 'erro de sintaxe'",
                                    "Ignorar recuperação para evitar cascata de erros"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Modificar o código do parser para incorporar produções de erro",
                                  "subSteps": [
                                    "No código da função de parsing relevante (ex: parseStatement), adicione match para produções de erro após match padrão falhar.",
                                    "Implemente geração de mensagem: console.error(`Semicolon esperado após declaração no token ${currentToken.lexeme}`);",
                                    "Adicione lógica de sincronização: consuma tokens até encontrar ';' ou EOF.",
                                    "Integre em múltiplas regras não-terminais, testando incrementalmente.",
                                    "Atualize o lookahead para resetar após erro."
                                  ],
                                  "verification": "Código modificado compila e roda sem erros em entradas válidas; gera mensagens específicas em inválidas.",
                                  "estimatedTime": "90 minutos",
                                  "materials": [
                                    "Código fonte modificável",
                                    "Compilador/interpretador da linguagem do parser (ex: Python, Java)",
                                    "Testes unitários iniciais"
                                  ],
                                  "tips": "Use funções auxiliares como reportError(token, expected) para reutilização.",
                                  "learningObjective": "Integrar produções de erro no fluxo de parsing descendente de forma robusta.",
                                  "commonMistakes": [
                                    "Consumir lookahead incorretamente após erro",
                                    "Gerar mensagens sem contexto de posição",
                                    "Quebrar parsing válido ao adicionar checks extras"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Testar e refinar o parser com produções de erro",
                                  "subSteps": [
                                    "Crie suíte de testes: 5 entradas válidas, 10 inválidas cobrindo cada produção de erro.",
                                    "Execute e verifique: mensagens corretas, recuperação sem crash, parsing continua após erro.",
                                    "Meça precisão: compare com parser sem erros para garantir funcionalidade.",
                                    "Refine mensagens baseadas em testes, adicionando posição linha/coluna.",
                                    "Documente casos edge como múltiplos erros consecutivos."
                                  ],
                                  "verification": "Relatório de testes mostrando 100% pass em válidos, mensagens específicas em inválidos, e taxa de recuperação >80%.",
                                  "estimatedTime": "75 minutos",
                                  "materials": [
                                    "Ferramenta de testes (ex: pytest, JUnit)",
                                    "Entradas de teste em arquivo",
                                    "Logs de saída comparados"
                                  ],
                                  "tips": "Automatize testes com asserts em mensagens de erro esperadas.",
                                  "learningObjective": "Validar que produções de erro melhoram usabilidade sem comprometer corretude.",
                                  "commonMistakes": [
                                    "Testes insuficientes para casos edge",
                                    "Ignorar performance em grandes inputs com erros",
                                    "Não testar recuperação em EOF"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Avaliar e otimizar o parser para uso prático",
                                  "subSteps": [
                                    "Analise cobertura de erros com ferramenta de análise estática se disponível.",
                                    "Otimize mensagens para serem localizadas ou multilíngues se aplicável.",
                                    "Integre com frontend: destaque erro na UI com linha/coluna.",
                                    "Compare com parsers profissionais (ex: ANTLR error handling).",
                                    "Escreva documentação de uso e extensão."
                                  ],
                                  "verification": "Parser otimizado processa inputs reais com diagnósticos úteis; documentação completa.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Parser final",
                                    "Exemplos reais de código fonte",
                                    "Ferramentas de linting"
                                  ],
                                  "tips": "Priorize erros comuns primeiro para impacto máximo.",
                                  "learningObjective": "Transformar parser acadêmico em ferramenta robusta para desenvolvimento.",
                                  "commonMistakes": [
                                    "Sobre-otimizar sem necessidade",
                                    "Mensagens muito verbosas",
                                    "Não considerar extensibilidade futura"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um parser descendente para uma mini-linguagem de declarações como 'x = 5;', modifique parseDeclaration para: se match('identifier') e match('=') e parseExpr mas !match(';'), então reportError('Ponto e vírgula esperado após declaração') e skipUntil(';'). Teste com 'x = 5' (erro: gera \"Ponto e vírgula esperado após declaração no token EOF\"), recuperando graciosamente.",
                              "finalVerifications": [
                                "Parser gera mensagens específicas como 'semicolon esperado após declaração' para erros correspondentes.",
                                "Parsing válido permanece inalterado (100% pass rate).",
                                "Recuperação de erro permite continuar parsing após falha única.",
                                "Mensagens incluem contexto: token atual, posição linha/coluna.",
                                "Cobertura de pelo menos 80% dos erros sintáticos comuns testados.",
                                "Não há loops infinitos ou crashes em inputs malformados."
                              ],
                              "assessmentCriteria": [
                                "Precisão das mensagens de erro: específicas e acionáveis (nota 1-5).",
                                "Robustez da recuperação: continua parsing sem crash (nota 1-5).",
                                "Manutenibilidade do código: produções modulares e comentadas (nota 1-5).",
                                "Cobertura de testes: variedade de casos válidos/inválidos (nota 1-5).",
                                "Eficiência: tempo de parsing similar ao original (+/-20%).",
                                "Conformidade LL(1): sem ambiguidades introduzidas."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria de linguagens formais e autômatos (gramáticas LL(1)).",
                                "Inglês/Comunicação: Redação clara de mensagens de erro para usuários finais.",
                                "Design de Software: Princípios de UX em ferramentas de desenvolvimento.",
                                "Lógica: Raciocínio sobre estados de erro e recuperação determinística.",
                                "Ética em Computação: Transparência em diagnósticos para depuração segura."
                              ],
                              "realWorldApplication": "Em compiladores como GCC/Clang ou IDEs como VS Code IntelliSense, onde parsers com produções de erro fornecem diagnósticos precisos (ex: 'expected ; after variable declaration at line 42'), acelerando depuração em projetos reais e reduzindo tempo de desenvolvimento em 30-50%."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.4.2.2.1",
                              "10.1.4.2.3.1"
                            ]
                          },
                          {
                            "id": "10.1.4.2.3.3",
                            "name": "Comparar produções de erro com modos panic",
                            "description": "Discutir vantagens das produções de erro (recuperação local e melhores diagnósticos) versus modos panic (pulo global), usando exemplos de código fonte com erros.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o Modo Panic em Parsers Top-Down",
                                  "subSteps": [
                                    "Estude a definição de modo panic: quando um erro sintático é detectado, o parser pula tokens até encontrar um sincronizador (ex: ';', '}').",
                                    "Analise como isso causa 'pulo global', perdendo contexto local do erro.",
                                    "Examine um exemplo simples de gramática LL(1) com erro de sintaxe.",
                                    "Simule manualmente o parsing com modo panic em papel.",
                                    "Registre os diagnósticos gerados (geralmente genéricos e imprecisos)."
                                  ],
                                  "verification": "Descreva verbalmente ou por escrito o fluxo de parsing com modo panic em um exemplo dado.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Livro de compiladores (ex: Dragon Book), editor de texto para gramáticas, papel e caneta.",
                                  "tips": "Comece com gramáticas simples para visualizar o 'pulo' claramente.",
                                  "learningObjective": "Identificar como o modo panic recupera do erro via sincronização global.",
                                  "commonMistakes": "Confundir modo panic com backtracking; lembrar que é forward-only em top-down."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Explorar Produções de Erro em Parsers Top-Down",
                                  "subSteps": [
                                    "Defina produções de erro: regras gramaticais especiais que reconhecem padrões de erro comuns (ex: missing token).",
                                    "Estude como elas permitem recuperação local, consumindo tokens errôneos próximos.",
                                    "Implemente uma produção de erro simples em uma gramática de exemplo.",
                                    "Teste com código fonte inválido e observe diagnósticos específicos.",
                                    "Compare o consumo de tokens com modo panic no mesmo exemplo."
                                  ],
                                  "verification": "Modifique uma gramática para incluir uma produção de erro e parse um input inválido com sucesso.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Compilador simples ou parser generator (ex: ANTLR trial), exemplos de código fonte com erros.",
                                  "tips": "Use produções como 'erro -> ID inválido' para capturar erros comuns.",
                                  "learningObjective": "Construir produções de erro que forneçam diagnósticos precisos e recuperação local.",
                                  "commonMistakes": "Fazer produções de erro muito gerais, perdendo especificidade."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar Exemplos Práticos de Ambos os Mecanismos",
                                  "subSteps": [
                                    "Crie um código fonte com erros múltiplos (ex: missing ';', extra token).",
                                    "Implemente um parser top-down com modo panic e gere saída de erro.",
                                    "Modifique para usar produções de erro e compare saídas.",
                                    "Meça métricas: número de tokens pulados, qualidade do diagnóstico.",
                                    "Documente diferenças em um relatório curto."
                                  ],
                                  "verification": "Execute ambos os parsers no mesmo input e capture screenshots ou logs das mensagens de erro.",
                                  "estimatedTime": "90 minutos",
                                  "materials": "Linguagem de programação (Python/Java), parser hand-written ou tool como yacc/bison.",
                                  "tips": "Use prints de debug para rastrear estado do parser durante erros.",
                                  "learningObjective": "Aplicar ambos mecanismos em código real e observar comportamentos.",
                                  "commonMistakes": "Ignorar erros múltiplos; teste com vários cenários."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Comparar Vantagens e Desvantagens",
                                  "subSteps": [
                                    "Liste vantagens de produções de erro: recuperação local, diagnósticos melhores (ex: 'missing ; after ID').",
                                    "Liste desvantagens: mais complexas para gramáticas grandes.",
                                    "Discuta modo panic: simples, mas pulo global perde erros subsequentes.",
                                    "Crie uma tabela comparativa com exemplos.",
                                    "Debata cenários onde um é preferível ao outro."
                                  ],
                                  "verification": "Escreva um parágrafo resumindo vantagens de produções de erro vs. panic, com exemplo.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Tabela em Markdown ou Excel, exemplos de código dos steps anteriores.",
                                  "tips": "Use métricas como 'taxa de recuperação' para quantificar.",
                                  "learningObjective": "Articular trade-offs entre os dois abordagens de forma crítica.",
                                  "commonMistakes": "Superestimar simplicidade do panic sem considerar diagnósticos ruins."
                                }
                              ],
                              "practicalExample": "Considere gramática para expressões: expr -> term (('+'|'-') term)*. Input inválido: 'a + b -'. Modo panic pula até EOF após '-', perdendo contexto. Produção de erro: expr -> term erro_term, onde erro_term -> . (recupera localmente e reporta 'unexpected EOF').",
                              "finalVerifications": [
                                "Explicar verbalmente diferenças em recuperação e diagnósticos.",
                                "Demonstrar parsing de input com erro usando ambos métodos.",
                                "Identificar cenário onde produções de erro falham e panic succeeds.",
                                "Listar 3 vantagens específicas de cada abordagem.",
                                "Criar exemplo personalizado de código com erro múltiplo."
                              ],
                              "assessmentCriteria": [
                                "Precisão na descrição técnica de cada mecanismo (80%).",
                                "Uso de exemplos concretos com código fonte (90%).",
                                "Análise equilibrada de vantagens/desvantagens (85%).",
                                "Clareza na tabela ou comparação visual (75%).",
                                "Aplicação correta em implementação prática (95%).",
                                "Profundidade nos diagnósticos gerados (80%)."
                              ],
                              "crossCurricularConnections": [
                                "Debugging em programação geral: similar a handling exceptions locais vs. global.",
                                "Design de UX em software: diagnósticos amigáveis vs. crashes.",
                                "Teoria da Computação: autômatos com estados de erro.",
                                "Engenharia de Software: robustez em parsers de configs (JSON/XML)."
                              ],
                              "realWorldApplication": "Em compiladores como GCC/Clang, produções de erro melhoram mensagens de erro legíveis; editores como VS Code usam parsers robustos para highlighting em tempo real sem travar em código inválido."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.4.2.3.1"
                            ]
                          },
                          {
                            "id": "10.1.4.2.3.4",
                            "name": "Otimizar gramáticas com múltiplas produções de erro",
                            "description": "Estruturar uma gramática com várias produções de erro hierarquizadas para cobrir erros comuns em linguagens de programação, testando com ferramentas como Yacc ou manuais.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Identificar erros comuns e analisar gramática existente",
                                  "subSteps": [
                                    "Revise a gramática original e liste 5-10 erros sintáticos comuns em linguagens de programação (ex: ponto e vírgula faltante, parênteses desbalanceados).",
                                    "Classifique os erros por frequência e impacto usando exemplos de código real de linguagens como C ou Python.",
                                    "Crie um diagrama hierárquico dos erros, priorizando os mais comuns no topo.",
                                    "Documente padrões de erro com expressões regulares ou exemplos de input inválido.",
                                    "Valide a lista com manuais de compiladores ou ferramentas como ANTLR."
                                  ],
                                  "verification": "Lista completa de erros com exemplos e diagrama hierárquico salva em um documento.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Gramática original (.y ou .g4)",
                                    "Exemplos de código com erros",
                                    "Ferramenta de diagramação como Draw.io",
                                    "Manuais de Yacc/Bison"
                                  ],
                                  "tips": "Foquem em erros que ocorrem em 80% dos casos reais para otimização eficiente.",
                                  "learningObjective": "Compreender a hierarquia de erros sintáticos comuns em parsers top-down.",
                                  "commonMistakes": [
                                    "Ignorar erros raros mas críticos",
                                    "Não priorizar por frequência real",
                                    "Listar erros sem exemplos concretos"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Projetar produções de erro hierarquizadas",
                                  "subSteps": [
                                    "Defina produções de erro primárias para os erros mais comuns (ex: error_token ::= missing_semicolon).",
                                    "Crie produções secundárias para erros compostos, usando precedência hierárquica.",
                                    "Incorpore ações de recuperação como inserção de tokens ou skip de input.",
                                    "Garanta que as produções não entrem em loop infinito com lookahead limitado.",
                                    "Esboce a gramática expandida em pseudocódigo antes de codificar."
                                  ],
                                  "verification": "Pseudocódigo da gramática com 3-5 produções de erro hierarquizadas revisado e sem conflitos.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Editor de texto ou IDE como VS Code",
                                    "Documentação de Yacc/Bison para error handling",
                                    "Papel e caneta para esboços"
                                  ],
                                  "tips": "Use %error_verbose em Yacc para depuração inicial de hierarquias.",
                                  "learningObjective": "Estruturar produções de erro em níveis hierárquicos para cobertura ótima.",
                                  "commonMistakes": [
                                    "Produções sobrepostas causando ambiguidades",
                                    "Recuperação agressiva que mascara erros reais",
                                    "Esquecer precedência entre produções"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar e compilar a gramática otimizada",
                                  "subSteps": [
                                    "Integre as produções de erro na gramática Yacc/Bison existente.",
                                    "Adicione ações semânticas para reportar erros específicos e sugestões de correção.",
                                    "Compile a gramática com yacc -d ou bison e resolva warnings de shift/reduce.",
                                    "Teste unitariamente com inputs inválidos para cada produção de erro.",
                                    "Ajuste precedências com %left/%right se necessário para hierarquia."
                                  ],
                                  "verification": "Parser compilado sem erros e gerando .tab.c/.tab.h corretos.",
                                  "estimatedTime": "2.5 horas",
                                  "materials": [
                                    "Yacc/Bison instalado",
                                    "Compilador C/GCC",
                                    "Lexer simples (flex)",
                                    "Scripts de teste"
                                  ],
                                  "tips": "Use yyerror() customizado para mensagens hierárquicas baseadas no tipo de erro.",
                                  "learningObjective": "Implementar gramáticas com error productions de forma funcional em ferramentas reais.",
                                  "commonMistakes": [
                                    "Conflitos shift/reduce não resolvidos",
                                    "Ações de erro vazias sem recuperação",
                                    "Falta de integração com lexer"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Testar, otimizar e validar cobertura",
                                  "subSteps": [
                                    "Crie suíte de testes com 20+ casos: válidos, erros comuns e edge cases.",
                                    "Execute o parser e meça taxa de recuperação (>90% para erros comuns).",
                                    "Analise logs de erro e refine produções para reduzir falsos positivos.",
                                    "Compare performance com gramática original (tempo de parse e qualidade de mensagens).",
                                    "Documente métricas de cobertura e otimizações aplicadas."
                                  ],
                                  "verification": "Relatório de testes com >90% cobertura de erros e parser otimizado funcional.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Suite de testes em Bash/Python",
                                    "Ferramentas de profiling como valgrind",
                                    "Logs de yydebug=1"
                                  ],
                                  "tips": "Ative %define parse.error verbose para mensagens detalhadas durante testes.",
                                  "learningObjective": "Otimizar e validar gramáticas para robustez em cenários reais de erro.",
                                  "commonMistakes": [
                                    "Testes insuficientes para edge cases",
                                    "Ignorar performance de recuperação",
                                    "Não medir cobertura quantitativamente"
                                  ]
                                }
                              ],
                              "practicalExample": "Otimizando uma gramática para expressões aritméticas em C-like: adicione produções como expr: error ';' { report_missing_semicolon(); } | ... para erros como '1 + 2' sem ';', hierarquizando com expr: '(' error ')' para parênteses desbalanceados, testando com Yacc em inputs como 'if (x = 1' e medindo recuperação.",
                              "finalVerifications": [
                                "Parser recupera de todos erros comuns sem crash.",
                                "Mensagens de erro são específicas e hierárquicas.",
                                "Cobertura de testes >90% para erros priorizados.",
                                "Performance similar ou melhor que gramática original.",
                                "Nenhum conflito shift/reduce reportado.",
                                "Documentação completa com métricas."
                              ],
                              "assessmentCriteria": [
                                "Hierarquia de produções cobre 80%+ erros comuns.",
                                "Recuperação elegante sem perda de sincronia.",
                                "Mensagens de erro acionáveis e priorizadas.",
                                "Testes abrangentes com métricas quantitativas.",
                                "Integração limpa com parser top-down.",
                                "Otimização comprovada por benchmarks."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria de linguagens formais e autômatos.",
                                "Engenharia de Software: Design de sistemas tolerantes a falhas.",
                                "Design de UX: Criação de mensagens de erro intuitivas.",
                                "Inteligência Artificial: Parsing em PLN para recuperação de erros semânticos."
                              ],
                              "realWorldApplication": "Em compiladores como GCC/Clang para diagnósticos precisos em código com erros de sintaxe, IDEs como VS Code para sugestões automáticas, e ferramentas de linting que guiam desenvolvedores em fixes rápidos, reduzindo tempo de debug em 50%+."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.4.2.3.2"
                            ]
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.4.3",
                    "name": "Tratamento de Erros Sintáticos em Parsers Bottom-Up",
                    "description": "Estratégias como modo pânico e recuperação por frase em analisadores ascendentes.",
                    "individualConcepts": [
                      {
                        "id": "10.1.4.3.1",
                        "name": "Modo Pânico",
                        "description": "Estratégia de recuperação de erros sintáticos em parsers bottom-up (ascendentes), como os parsers LR, onde o analisador descarta tokens de entrada até encontrar um símbolo sincronizador (ex.: ';', '}'), permitindo continuar a análise sem propagar o erro excessivamente.",
                        "specificSkills": [
                          {
                            "id": "10.1.4.3.1.1",
                            "name": "Descrever o algoritmo do modo pânico",
                            "description": "Explicar os passos detalhados: detecção de erro via conflito shift/reduce ou reduce/reduce, empilhamento de sincronizadores, descarte de tokens não-sincronizadores e retomada da análise no estado válido.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender a detecção de erros em parsers bottom-up",
                                  "subSteps": [
                                    "Estude os conflitos shift/reduce e reduce/reduce em tabelas de parsing LR.",
                                    "Identifique como o parser detecta ambiguidades durante a análise.",
                                    "Revise o stack do parser e o lookahead token no momento do erro.",
                                    "Simule um exemplo simples de conflito em uma gramática básica.",
                                    "Anote as condições exatas para acionar o modo pânico."
                                  ],
                                  "verification": "Explique verbalmente ou por escrito os dois tipos de conflitos e como o parser os detecta.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Livro de compiladores (ex: 'Compilers: Principles, Techniques, and Tools'), tabela de parsing LR exemplo, simulador de parser online.",
                                  "tips": "Desenhe o stack e a tabela de ação para visualizar melhor os conflitos.",
                                  "learningObjective": "Compreender os mecanismos de detecção de erros sintáticos em parsers bottom-up.",
                                  "commonMistakes": "Confundir shift/reduce com reduce/reduce; ignorar o papel do lookahead."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar e empilhar tokens sincronizadores",
                                  "subSteps": [
                                    "Defina o que são tokens sincronizadores (ex: ponto-e-vírgula, chaves).",
                                    "Para cada estado no stack, encontre os estados que aceitam sincronizadores.",
                                    "Empilhe ficticiamente os sincronizadores nos estados válidos do stack.",
                                    "Priorize sincronizadores de maior precedência ou cobertura.",
                                    "Documente o stack modificado após empilhamento."
                                  ],
                                  "verification": "Construa um stack exemplo com sincronizadores empilhados e valide contra definição.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Pseudocódigo do algoritmo de pânico, gramática de exemplo (ex: expressões aritméticas), papel e caneta para diagramas.",
                                  "tips": "Use FOLLOW sets da gramática para identificar sincronizadores eficazes.",
                                  "learningObjective": "Dominar a seleção e empilhamento de sincronizadores para recuperação.",
                                  "commonMistakes": "Escolher sincronizadores irrelevantes; não considerar múltiplos estados no stack."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Descartar tokens não-sincronizadores",
                                  "subSteps": [
                                    "Examine o input stream a partir do token atual.",
                                    "Descarte tokens sequencialmente até encontrar um sincronizador empilhado.",
                                    "Registre os tokens descartados para relatório de erro.",
                                    "Atualize o lookahead para o próximo token válido.",
                                    "Verifique se o descarte não remove sincronizadores prematuros."
                                  ],
                                  "verification": "Simule o descarte em um input com erro e confirme o token de retomada.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Exemplo de código fonte com erro sintático, depurador de parser ou simulador.",
                                  "tips": "Mantenha um log de tokens descartados para depuração posterior.",
                                  "learningObjective": "Aplicar o descarte seletivo de input para sincronização.",
                                  "commonMistakes": "Descarte excessivo levando a perda de contexto; ignorar lookahead múltiplo."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Retomar a análise sintática no estado válido",
                                  "subSteps": [
                                    "Pop o stack até o estado sincronizador mais profundo.",
                                    "Execute shift ou reduce baseado no novo lookahead.",
                                    "Continue o parsing normalmente, reportando o erro recuperado.",
                                    "Teste a robustez com múltiplos erros consecutivos.",
                                    "Avalie o impacto na árvore sintática final."
                                  ],
                                  "verification": "Execute um parsing completo com erro e confirme recuperação sem crash.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Implementação simples de parser LR em Python/Java, testes com inputs errôneos.",
                                  "tips": "Implemente em código para validar; use asserts para verificações.",
                                  "learningObjective": "Finalizar o ciclo de recuperação e retomar parsing eficiente.",
                                  "commonMistakes": "Não popar stack corretamente; falhar em reduzir após sincronização."
                                }
                              ],
                              "practicalExample": "Em uma gramática de expressões aritméticas (E -> E + T | T; T -> id), com input 'id + id ; id extra ;', ao detectar erro após primeiro ';', empilhe sincronizador ';', descarte 'id extra', retome no próximo ';'.",
                              "finalVerifications": [
                                "Descreva os 4 passos principais do algoritmo sem consultar notas.",
                                "Simule corretamente um exemplo com shift/reduce conflict.",
                                "Identifique sincronizadores em uma gramática dada.",
                                "Explique por que o modo pânico é 'local' e não global.",
                                "Compare com modo pânico em parsers top-down.",
                                "Implemente pseudocódigo básico do algoritmo."
                              ],
                              "assessmentCriteria": [
                                "Precisão na detecção de conflitos (shift/reduce vs reduce/reduce).",
                                "Correta seleção e empilhamento de sincronizadores.",
                                "Eficiência no descarte de tokens (mínimo necessário).",
                                "Sucesso na retomada sem perda excessiva de contexto.",
                                "Capacidade de lidar com erros múltiplos.",
                                "Clareza na explicação oral/escrita do algoritmo."
                              ],
                              "crossCurricularConnections": [
                                "Teoria da Computação: Autômatos de empilhamento e reconhecimento de linguagens.",
                                "Algoritmos: Estratégias de recuperação em grafos e árvores de parsing.",
                                "Engenharia de Software: Tratamento de exceções e robustez em sistemas.",
                                "Inteligência Artificial: Recuperação de erros em processadores de linguagem natural."
                              ],
                              "realWorldApplication": "Usado em compiladores como GCC e Clang para parsers LR(1), permitindo compilação parcial de código com erros sintáticos isolados, melhorando produtividade de desenvolvedores ao reportar múltiplos erros sem parar na primeira falha."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.4.3.1.2",
                            "name": "Identificar e justificar sincronizadores",
                            "description": "Listar símbolos comuns como sincronizadores em gramáticas de linguagens de programação (ex.: ponto e vírgula para instruções, chaves para blocos) e explicar critérios para escolha baseados na estrutura da gramática.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o Conceito de Sincronizadores no Modo Pânico de Parsers Bottom-Up",
                                  "subSteps": [
                                    "Estude a definição de modo pânico em parsers bottom-up (LR, LALR).",
                                    "Identifique o papel dos sincronizadores: símbolos que ajudam a recuperar o parser de erros sintáticos pulando tokens irrelevantes.",
                                    "Revise exemplos iniciais: ';' para separar instruções, '}' para fechar blocos.",
                                    "Analise diagramas de pilha de parser durante erro e recuperação.",
                                    "Compare com outros modos de recuperação de erros."
                                  ],
                                  "verification": "Explique em suas palavras o que é um sincronizador e dê um exemplo simples de uso em uma pilha de parser.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Livro 'Compilers: Principles, Techniques, and Tools' (Dragon Book), slides sobre parsers LR, vídeo tutorial sobre recuperação de erros.",
                                  "tips": "Desenhe diagramas da pilha antes e depois da recuperação para visualizar melhor.",
                                  "learningObjective": "Dominar a definição e o mecanismo de sincronizadores em parsers bottom-up.",
                                  "commonMistakes": "Confundir sincronizadores com tokens de fim de arquivo ou reservar palavras em vez de símbolos terminais."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Listar Símbolos Comuns como Sincronizadores em Gramáticas de Programação",
                                  "subSteps": [
                                    "Compile uma lista de 10 símbolos comuns: ';', '{', '}', ')', 'if', 'else', 'while', etc.",
                                    "Classifique-os por contexto: separadores de instruções, delimitadores de blocos, palavras-chave condicionais.",
                                    "Pesquise gramáticas reais: C, Java, Python (use ferramentas como ANTLR grammar viewer).",
                                    "Crie uma tabela com símbolo, gramática exemplo e frequência de uso como sincronizador.",
                                    "Teste em parsers online simulando erros."
                                  ],
                                  "verification": "Crie uma tabela com pelo menos 8 símbolos e seus contextos gramaticais.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Gramáticas de referência (C99, Java), ferramentas como yacc/bison exemplos, notepad para tabela.",
                                  "tips": "Priorize símbolos de baixa precedência que aparecem frequentemente em posições de sincronização.",
                                  "learningObjective": "Identificar e catalogar símbolos potenciais de sincronização em linguagens comuns.",
                                  "commonMistakes": "Incluir símbolos não-terminais ou variáveis em vez de terminais fixos."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar Critérios para Escolha de Sincronizadores Baseados na Estrutura da Gramática",
                                  "subSteps": [
                                    "Estude critérios: frequência na gramática, posições de follow sets, minimizar perda de tokens.",
                                    "Calcule follow sets manualmente para uma regra de produção simples.",
                                    "Avalie trade-offs: sincronizadores muito comuns causam perda excessiva vs. raros que falham na recuperação.",
                                    "Simule cenários de erro com diferentes escolhas de sincronizador.",
                                    "Documente prós e contras para 3 símbolos em uma gramática exemplo."
                                  ],
                                  "verification": "Justifique por que ';' é bom para instruções mas não para blocos, com base em follow sets.",
                                  "estimatedTime": "75 minutos",
                                  "materials": "Calculadora de follow sets online, gramática mini-linguagem (ex.: expressões aritméticas), papel para simulações.",
                                  "tips": "Use o algoritmo FIRST/FOLLOW para validar critérios quantitativamente.",
                                  "learningObjective": "Aplicar análise formal (follow sets, cobertura gramatical) para justificar escolhas.",
                                  "commonMistakes": "Ignorar follow sets e basear escolha só em intuição ou frequência absoluta."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Praticar Identificação e Justificação em uma Gramática Real",
                                  "subSteps": [
                                    "Escolha uma gramática simples (ex.: mini-C com instruções e blocos).",
                                    "Identifique 5 sincronizadores ótimos e justifique com critérios.",
                                    "Implemente modo pânico em um parser toy (use Python ou Java).",
                                    "Teste com inputs errôneos e observe recuperação.",
                                    "Refine escolhas baseado em testes empíricos."
                                  ],
                                  "verification": "Produza um relatório com gramática, sincronizadores escolhidos, justificação e resultados de testes.",
                                  "estimatedTime": "90 minutos",
                                  "materials": "Editor de código (VS Code), parser generator como ANTLR ou handwritten LR(0), conjunto de testes com erros.",
                                  "tips": "Comece com gramáticas pequenas para evitar complexidade; logue a pilha durante parsing.",
                                  "learningObjective": "Integrar conhecimento em prática hands-on com justificação formal.",
                                  "commonMistakes": "Escolher sincronizadores que não cobrem follow sets principais, levando a loops infinitos."
                                }
                              ],
                              "practicalExample": "Em uma gramática mini-C: stmt -> if ( expr ) stmt | '{' stmt* '}' | assign ';' . Para erro após 'if (x', sincronizador '}' pula até fim de bloco, justificativa: '}' está no follow de stmt e minimiza perda.",
                              "finalVerifications": [
                                "Lista pelo menos 8 símbolos comuns com contextos corretos.",
                                "Calcula follow sets para 3 regras e identifica sincronizadores válidos.",
                                "Justifica escolhas com critérios formais em um exemplo completo.",
                                "Implementa e testa parser com recuperação em 2 cenários de erro.",
                                "Identifica trade-offs em pelo menos 2 sincronizadores alternativos.",
                                "Explica diferenças entre sincronizadores para instruções vs. blocos."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de símbolos terminais como sincronizadores (90%+ corretos).",
                                "Profundidade da justificação usando follow sets e estrutura gramatical.",
                                "Qualidade da implementação prática e resultados de testes empíricos.",
                                "Cobertura de critérios: frequência, cobertura, perda mínima de tokens.",
                                "Clareza na documentação e exemplos concretos.",
                                "Capacidade de refinar escolhas baseado em análise."
                              ],
                              "crossCurricularConnections": [
                                "Linguística Computacional: Paralelo com recuperação em parsers naturais.",
                                "Matemática Discreta: Conjuntos FIRST/FOLLOW como teoria de conjuntos.",
                                "Engenharia de Software: Tratamento de exceções em compiladores industriais.",
                                "Design de Linguagens: Impacto na usabilidade de linguagens de programação."
                              ],
                              "realWorldApplication": "Em compiladores como GCC/Clang para C++, sincronizadores como ';' e '}' permitem edição robusta de código com erros, reduzindo crashes e melhorando IDEs com diagnósticos precisos durante digitação."
                            },
                            "estimatedTime": "0.25 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.4.3.1.3",
                            "name": "Implementar modo pânico em pseudocódigo",
                            "description": "Escrever pseudocódigo para modificar um parser shift-reduce LR, incluindo detecção de erro, conjunto de sincronizadores e lógica de recuperação, com exemplo de aplicação em uma gramática simples.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar conceitos fundamentais de parser shift-reduce LR e modo pânico",
                                  "subSteps": [
                                    "Estude o funcionamento básico de um parser shift-reduce LR: pilha de estados, ações shift e reduce.",
                                    "Identifique pontos de detecção de erro: erro de shift (sem ação válida) e erro de reduce (não há reduce possível).",
                                    "Compreenda o modo pânico: descarte tokens até encontrar um sincronizador e retome parsing.",
                                    "Liste os componentes necessários: conjunto de sincronizadores, lógica de pop da pilha até estado de sincronização.",
                                    "Anote definições chave em um papel para referência rápida."
                                  ],
                                  "verification": "Explique verbalmente ou por escrito os 3 tipos principais de erro em shift-reduce e como o pânico os trata.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Notas de aula sobre compiladores",
                                    "Papel e caneta",
                                    "Referência online sobre parsers LR (ex: Dragon Book capítulo 4)"
                                  ],
                                  "tips": "Use diagramas da pilha para visualizar shift/reduce; foque em exemplos simples primeiro.",
                                  "learningObjective": "Compreender os mecanismos de parsing LR e o papel do modo pânico na recuperação de erros sintáticos.",
                                  "commonMistakes": [
                                    "Confundir shift-reduce com top-down parsers",
                                    "Ignorar a importância da pilha de estados",
                                    "Subestimar o papel dos FOLLOW sets nos sincronizadores"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Definir uma gramática simples e calcular o conjunto de sincronizadores",
                                  "subSteps": [
                                    "Escolha uma gramática simples, ex: E → T | E + T | E * T | (E) | id.",
                                    "Calcule os FOLLOW sets para cada não-terminal (ex: FOLLOW(E) = {$}).",
                                    "Defina o conjunto de sincronizadores como a união dos FOLLOW sets de todos os não-terminais.",
                                    "Liste explicitamente os tokens sincronizadores para sua gramática (ex: +, *, ), $).",
                                    "Valide com um exemplo: para erro em 'id +', sincronizadores incluem +."
                                  ],
                                  "verification": "Escreva a gramática e seus FOLLOW sets; confirme que sincronizadores cobrem pontos de retomada.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Papel e caneta para tabelas FOLLOW",
                                    "Ferramenta online de FIRST/FOLLOW (opcional)",
                                    "Compilador de gramáticas como Yacc/Bison docs"
                                  ],
                                  "tips": "Comece com gramática sem ambiguidade; use algoritmo padrão para FOLLOW para evitar erros manuais.",
                                  "learningObjective": "Calcular corretamente conjuntos FOLLOW e derivar sincronizadores para uma gramática dada.",
                                  "commonMistakes": [
                                    "Esquecer de propagar FOLLOW do pai para filho",
                                    "Incluir terminais nos FOLLOW incorretamente",
                                    "Não considerar o fim de entrada ($)"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Escrever pseudocódigo para detecção de erro no parser shift-reduce",
                                  "subSteps": [
                                    "Estruture o loop principal: while não aceita: lookup ação na tabela LR.",
                                    "Implemente detecção: se ação = shift ou reduce, execute; senão, sinalize erro.",
                                    "Inclua pop da pilha em caso de erro shift (descartar estados inválidos).",
                                    "Adicione skip de tokens lookahead até encontrar possível shift válido.",
                                    "Teste logicamente com pseudocódigo seco: simule pilha vazia + 'id +'.",
                                    "verification]: "
                                  ],
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Editor de texto para pseudocódigo",
                                    "Tabela LR exemplo para sua gramática (gere manualmente ou use ferramenta)"
                                  ],
                                  "tips": "Use indentação clara no pseudocódigo; nomeie variáveis como stack, lookahead, actionTable.",
                                  "learningObjective": "Implementar a lógica de parsing normal com detecção precisa de erros sintáticos.",
                                  "commonMistakes": [
                                    "Não checar pilha antes de reduce",
                                    "Loop infinito em erro sem break",
                                    "Confundir estado atual com símbolo na pilha"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Integrar lógica de recuperação no modo pânico e validar com exemplo",
                                  "subSteps": [
                                    "No bloco de erro: while lookahead não em sincronizadores: avance lookahead.",
                                    "Pop pilha até estado cujo núcleo tenha lookahead como possível shift ou goto.",
                                    "Após pop, shift o sincronizador e continue parsing normal.",
                                    "Aplique a uma entrada errônea: ex: 'id + * id $' (erro em * após +).",
                                    "Simule passo a passo e anote pilha/tokens em cada iteração."
                                  ],
                                  "verification": "Execute simulação manual; confirme que parser recupera e reporta erro sem crash.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Pseudocódigo do passo 3",
                                    "Papel para simulação de pilha",
                                    "Exemplo de gramática do passo 2"
                                  ],
                                  "tips": "Sempre reporte o erro uma vez; evite múltiplos pops desnecessários para eficiência.",
                                  "learningObjective": "Combinar detecção e recuperação em pseudocódigo funcional para modo pânico.",
                                  "commonMistakes": [
                                    "Pop excessivo perdendo contexto válido",
                                    "Não shiftar sincronizador após pop",
                                    "Ignorar recursão em gramáticas left-recursive"
                                  ]
                                }
                              ],
                              "practicalExample": "Gramática: E → T | E + T | id. Sincronizadores: {+, $}. Entrada errônea: 'id + + id $'. Parser detecta erro após primeiro +, descarta segundo +, popa até estado que aceite +, shift + e continua para 'id $'.",
                              "finalVerifications": [
                                "Pseudocódigo detecta corretamente erros de shift e reduce.",
                                "Conjunto de sincronizadores é calculado e usado adequadamente.",
                                "Lógica de pop e skip avança corretamente para sincronizador.",
                                "Simulação com entrada errônea recupera parsing sem falha.",
                                "Código inclui relatório de erro no token problemático.",
                                "Estrutura segue loop while padrão de shift-reduce."
                              ],
                              "assessmentCriteria": [
                                "Precisão na detecção de erro (100% dos casos cobertos).",
                                "Correção do conjunto de sincronizadores (validação via FOLLOW).",
                                "Eficiência da recuperação (mínimo pop/skip desnecessário).",
                                "Clareza e legibilidade do pseudocódigo (indentação, comentários).",
                                "Validação via simulação em pelo menos 2 entradas errôneas.",
                                "Integração completa sem loops infinitos ou crashes."
                              ],
                              "crossCurricularConnections": [
                                "Teoria da Computação: Autômatos de pilha e linguagens livres de contexto.",
                                "Engenharia de Software: Tratamento de exceções e resiliência em sistemas.",
                                "Matemática Discreta: Conjuntos e relações em tabelas LR.",
                                "Desenvolvimento de Software: Debugging e error recovery em parsers reais (ex: JSON parsers)."
                              ],
                              "realWorldApplication": "Em compiladores como GCC e Clang, o modo pânico permite diagnósticos úteis em código com erros sintáticos, como em 'int x = ;', descartando ';' inválido e continuando para sugerir correções, melhorando UX para desenvolvedores."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.4.3.1.4",
                            "name": "Analisar vantagens e limitações",
                            "description": "Discutir prós (simplicidade, evita cascata de erros) e contras (pode pular código válido, perda de precisão em diagnósticos), com referências ao livro de Aho et al.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar o funcionamento do Modo Pânico em Parsers Bottom-Up",
                                  "subSteps": [
                                    "Leia a seção relevante do livro 'Compilers: Principles, Techniques, and Tools' de Aho et al. sobre tratamento de erros em parsers LR.",
                                    "Desenhe um diagrama de um parser bottom-up simples (LR(0) ou SLR) e marque onde o modo pânico é acionado ao detectar um erro sintático.",
                                    "Simule um exemplo de entrada inválida e trace o processo de recuperação no modo pânico, identificando estados de pânico e sincronização.",
                                    "Compare brevemente com parsers top-down para contextualizar diferenças."
                                  ],
                                  "verification": "Você pode explicar verbalmente ou por escrito como o modo pânico recupera de um erro sem colapso total do parser.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Livro 'Compilers: Principles, Techniques, and Tools' de Aho et al. (capítulo sobre sintaxe e análise semântica)",
                                    "Papel e caneta ou ferramenta de diagramação como Draw.io",
                                    "Exemplos de gramáticas simples em notação BNF"
                                  ],
                                  "tips": "Foque em estados de follow sets para sincronização; isso facilita a análise posterior de limitações.",
                                  "learningObjective": "Compreender o mecanismo preciso do modo pânico para basear a análise de prós e contras.",
                                  "commonMistakes": [
                                    "Confundir modo pânico com backtracking (comum em top-down)",
                                    "Ignorar o papel dos sets FOLLOW na recuperação"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar e detalhar as vantagens do Modo Pânico",
                                  "subSteps": [
                                    "Liste as vantagens principais: simplicidade de implementação, prevenção de cascata de erros e eficiência computacional.",
                                    "Para cada vantagem, forneça um exemplo: simplicidade (poucas linhas de código extras); evita cascata (continua parsing após erro).",
                                    "Quantifique onde possível: compare tempo de parsing com/ sem recuperação usando pseudocódigo.",
                                    "Referencie Aho et al.: destaque como o modo pânico é 'robusto' para linguagens reais."
                                  ],
                                  "verification": "Crie uma tabela com pelo menos 3 vantagens, exemplos e citações do livro.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Livro de Aho et al.",
                                    "Planilha ou editor de texto para tabela"
                                  ],
                                  "tips": "Use bullet points para listar prós e contras lado a lado para visualização clara.",
                                  "learningObjective": "Mapear vantagens específicas ao funcionamento do parser, preparando para discussão equilibrada.",
                                  "commonMistakes": [
                                    "Superestimar simplicidade sem considerar gramáticas ambíguas",
                                    "Omitir comparação com não-recuperação (cascata de erros)"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar as limitações e desvantagens do Modo Pânico",
                                  "subSteps": [
                                    "Liste desvantagens: pode pular código válido (falsos negativos), perda de precisão em diagnósticos de erro e dependência de sets FOLLOW precisos.",
                                    "Simule um exemplo onde o parser pula tokens válidos após erro, mostrando perda de precisão.",
                                    "Discuta impactos: diagnósticos ruins para programadores, ineficiência em gramáticas complexas.",
                                    "Cite Aho et al. sobre limitações em parsers reais e sugestões de melhorias híbridas."
                                  ],
                                  "verification": "Escreva um parágrafo crítico com 3 limitações e um exemplo de código afetado.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Exemplos de código fonte com erros sintáticos (e.g., em C ou gramática customizada)",
                                    "Livro de Aho et al."
                                  ],
                                  "tips": "Teste com um parser real como yacc/bison para validar simulações.",
                                  "learningObjective": "Criticar o modo pânico de forma fundamentada, identificando cenários de falha.",
                                  "commonMistakes": [
                                    "Confundir perda de precisão com correção total do erro",
                                    "Ignorar que limitações são trade-offs inevitáveis em recuperação local"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Sintetizar análise com referências e comparações",
                                  "subSteps": [
                                    "Integre prós e contras em uma análise equilibrada, pesando-os para contextos específicos (e.g., compiladores de produção).",
                                    "Compare com outras técnicas: modo pânico vs. recuperação por frase ou global.",
                                    "Inclua citações diretas de Aho et al. e discuta evoluções modernas (e.g., em LLVM).",
                                    "Prepare um resumo executivo: 'O modo pânico é ideal para robustez básica, mas requer híbridos para precisão'."
                                  ],
                                  "verification": "Redija um ensaio curto (300 palavras) com análise completa e referências bibliográficas.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Notas dos steps anteriores",
                                    "Livro de Aho et al., artigos sobre parsers modernos (opcional)"
                                  ],
                                  "tips": "Use estrutura IMRAD (Introdução, Métodos, Resultados, Análise, Discussão) para síntese acadêmica.",
                                  "learningObjective": "Produzir uma análise crítica holística, pronta para aplicação educacional ou pesquisa.",
                                  "commonMistakes": [
                                    "Viés para prós sem equilíbrio",
                                    "Citar livro sem página ou seção específica"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Validar análise com experimentação prática",
                                  "subSteps": [
                                    "Implemente um parser bottom-up mínimo em Python ou use bison/yacc com modo pânico.",
                                    "Insira erros variados e registre: tempo de recuperação, precisão do diagnóstico, código pulado.",
                                    "Meça métricas: % de código recuperado corretamente, # de erros detectados.",
                                    "Ajuste análise inicial com dados empíricos e atualize tabela de prós/contras."
                                  ],
                                  "verification": "Gere relatório com métricas e gráficos (e.g., bar chart de precisão).",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Ferramentas: Python com ply ou bison",
                                    "Código de exemplo de parser LR"
                                  ],
                                  "tips": "Comece com gramática aritmética simples para depuração rápida.",
                                  "learningObjective": "Conectar teoria à prática, validando análise com evidências experimentais.",
                                  "commonMistakes": [
                                    "Implementar parser top-down por engano",
                                    "Ignorar overhead de performance na medição"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um parser LR para uma gramática de expressões aritméticas, ao encontrar um ';' extra após 'x = 1 +', o modo pânico descarta tokens até ';', recuperando para parse o resto 'y = 2;', evitando cascata, mas pulando possivelmente um operador válido se mal posicionado.",
                              "finalVerifications": [
                                "Lista precisa de 3+ vantagens com exemplos.",
                                "Lista equilibrada de 3+ limitações com contraexemplos.",
                                "Referências corretas a Aho et al. com seções específicas.",
                                "Análise sintetizada em tabela ou matriz.",
                                "Validação prática com pelo menos um experimento simulado."
                              ],
                              "assessmentCriteria": [
                                "Profundidade: Detalhes técnicos e citações (30%)",
                                "Equilíbrio: Prós e contras bem pesados (25%)",
                                "Clareza: Estrutura lógica e linguagem acessível (20%)",
                                "Originalidade: Exemplos concretos e insights pessoais (15%)",
                                "Precisão: Ausência de erros conceituais (10%)"
                              ],
                              "crossCurricularConnections": [
                                "Engenharia de Software: Design de sistemas tolerantes a falhas e recuperação de erros.",
                                "Matemática Discreta: Autômatos e grafos de estados em parsing.",
                                "Linguística Computacional: Análise sintática em PLN comparada a compiladores.",
                                "Gestão de Projetos: Trade-offs em simplicidade vs. precisão em desenvolvimento."
                              ],
                              "realWorldApplication": "Em compiladores como GCC ou Clang, o modo pânico permite diagnósticos rápidos em código buggy de desenvolvedores, melhorando produtividade em IDEs como VS Code, onde erros sintáticos são destacados sem travar o parser inteiro."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.4.3.2",
                        "name": "Recuperação por Frase",
                        "description": "Técnica mais sofisticada em parsers bottom-up que tenta corrigir erros inserindo, deletando ou alterando frases inteiras (sequências de símbolos) para sincronizar o estado do parser com a entrada, minimizando alterações locais.",
                        "specificSkills": [
                          {
                            "id": "10.1.4.3.2.1",
                            "name": "Explicar mecanismos de inserção e deleção",
                            "description": "Detalhar como o parser testa inserções (ex.: adicionar token esperado) ou deleções (remover prefixos conflitantes) de frases, usando lookahead para escolher a correção de menor custo.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os Conceitos Fundamentais de Inserção e Deleção em Parsers Bottom-Up",
                                  "subSteps": [
                                    "Estude a recuperação de erros por frase em parsers bottom-up (LR).",
                                    "Defina inserção: adicionar um token esperado ausente no input para sincronizar com a gramática.",
                                    "Defina deleção: remover prefixos conflitantes do input para permitir redução válida.",
                                    "Revise lookahead: tokens futuros usados para prever e escolher ações.",
                                    "Entenda custo: métrica como número de inserções/deleções para minimizar impacto."
                                  ],
                                  "verification": "Resuma em suas palavras os conceitos de inserção, deleção, lookahead e custo mínimo.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Documentação de parsers LR, slides sobre tratamento de erros sintáticos.",
                                  "tips": "Use diagramas de pilha do parser para visualizar conflitos.",
                                  "learningObjective": "Dominar definições e papéis dos mecanismos básicos.",
                                  "commonMistakes": "Confundir inserção com shift ou deleção com pop sem contexto de erro."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Explorar o Mecanismo de Inserção Detalhadamente",
                                  "subSteps": [
                                    "Identifique estado de erro: pilha sem redução possível no token atual.",
                                    "Liste tokens esperados pela gramática no estado atual (usando tabelas LR).",
                                    "Teste inserção: simule adicionar cada token esperado e avance o parser.",
                                    "Calcule custo: 1 por inserção + penalidades por lookahead mismatch.",
                                    "Registre input modificado e estado resultante pós-inserção."
                                  ],
                                  "verification": "Simule inserção em um exemplo simples e liste tokens testados com custos.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Tabela LR de uma gramática simples, simulador de parser online.",
                                  "tips": "Comece com lookahead curto (1-2 tokens) para simplicidade.",
                                  "learningObjective": "Saber como o parser testa e valida inserções hipotéticas.",
                                  "commonMistakes": "Ignorar lookahead ao testar inserções, levando a loops infinitos."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar o Mecanismo de Deleção em Prefixos Conflitantes",
                                  "subSteps": [
                                    "No estado de erro, examine prefixos na pilha (últimos símbolos).",
                                    "Teste deleções: pop 1 ou mais símbolos até permitir shift/reduce.",
                                    "Simule parser após deleção com input restante e lookahead.",
                                    "Calcule custo: 1 por token deletado + verificação de lookahead.",
                                    "Compare múltiplas deleções para encontrar a de menor custo."
                                  ],
                                  "verification": "Descreva um prefixo deletado em exemplo e mostre estado restaurado.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Exemplos de gramáticas ambíguas, ferramenta de debugging de parser.",
                                  "tips": "Limite deleções a 3 símbolos para evitar explosão combinatória.",
                                  "learningObjective": "Entender como remover conflitos locais na pilha.",
                                  "commonMistakes": "Deletar demais, perdendo contexto válido da frase."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Integrar Lookahead e Seleção por Menor Custo",
                                  "subSteps": [
                                    "Colete todas as correções viáveis (inserções + deleções).",
                                    "Para cada uma, avance parser com 2-3 tokens de lookahead.",
                                    "Pontue custos: soma de operações + penalidade se lookahead falhar.",
                                    "Selecione e aplique a correção de menor custo; reporte erro ao usuário.",
                                    "Teste recuperação: continue parsing pós-correção."
                                  ],
                                  "verification": "Compare custos de 3 opções e justifique a escolhida.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Código fonte de parser com error recovery (ex: yacc/bison).",
                                  "tips": "Implemente em pseudocódigo para clareza antes de código real.",
                                  "learningObjective": "Dominar heurística de escolha ótima para recuperação.",
                                  "commonMistakes": "Não penalizar lookahead mismatch, causando recuperações ruins."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Simular e Verificar a Recuperação Completa",
                                  "subSteps": [
                                    "Crie input com erro sintático em gramática conhecida.",
                                    "Execute simulação passo a passo: erro → testes → correção.",
                                    "Valide se parsing continua corretamente pós-recuperação.",
                                    "Analise impacto: precisão da correção e performance.",
                                    "Documente lições aprendidas."
                                  ],
                                  "verification": "Produza log de simulação mostrando inserção/deleção aplicada.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Simulador LR parser, exemplos de inputs errôneos.",
                                  "tips": "Use gramática aritmética simples para testes rápidos.",
                                  "learningObjective": "Aplicar mecanismos em fluxo completo de parsing.",
                                  "commonMistakes": "Não testar pós-recuperação, assumindo sucesso automático."
                                }
                              ],
                              "practicalExample": "Gramática: E → E + T | T; T → id. Input: 'id + + id'. No erro após primeiro '+', parser testa: inserção 'id' (custo 1), deleção '+' (custo 1). Com lookahead '+', deleção permite shift, custo menor; aplica deleção e continua como 'id + id'.",
                              "finalVerifications": [
                                "Explicar inserção com exemplo de token adicionado.",
                                "Descrever deleção de prefixo com estado da pilha antes/depois.",
                                "Demonstrar cálculo de custo com lookahead de 2 tokens.",
                                "Simular recuperação completa em input errôneo.",
                                "Comparar 2-3 opções de correção e justificar menor custo.",
                                "Identificar limitações (ex: erros múltiplos)."
                              ],
                              "assessmentCriteria": [
                                "Precisão técnica: definições e mecanismos corretos (30%).",
                                "Clareza na explicação: passos lógicos e exemplos (25%).",
                                "Profundidade: cobertura de lookahead e custos (20%).",
                                "Exemplos práticos: simulações viáveis (15%).",
                                "Análise crítica: erros comuns e limitações (10%)."
                              ],
                              "crossCurricularConnections": [
                                "Algoritmos: heurísticas de busca de menor custo (A*).",
                                "Inteligência Artificial: recuperação de erros em PLN.",
                                "Linguística Computacional: parsing robusto de linguagem natural.",
                                "Engenharia de Software: debugging e fault tolerance."
                              ],
                              "realWorldApplication": "Em compiladores como GCC/Clang (usando bison), editores IDE (VSCode IntelliSense) para sugestões automáticas em código com typos, e parsers de linguagens naturais em assistentes como ChatGPT para lidar com inputs malformados."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.4.3.2.2",
                            "name": "Aplicar em exemplo de gramática LR",
                            "description": "Resolver um erro sintático em uma entrada inválida para uma gramática de expressões aritméticas, demonstrando passo a passo a recuperação por frase em um parser SLR ou LALR.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Definir a gramática e calcular os conjuntos de itens LR(0)",
                                  "subSteps": [
                                    "Escreva a gramática aumentada para expressões aritméticas: S' → S, S → E, E → E + T | T, T → T * F | F, F → (E) | id.",
                                    "Calcule os estados I0 a I(n) usando o algoritmo de construção de conjuntos de itens LR(0), listando closure e goto para símbolos não-terminais.",
                                    "Identifique os conflitos shift-reduce ou reduce-reduce, se houver, e note que para SLR/LALR usaremos FOLLOW sets.",
                                    "Liste os FOLLOW sets para não-terminais: FOLLOW(E) = {$, )}, FOLLOW(T) = {+, )}, FOLLOW(F) = {*, + , $, ) }.",
                                    "Desenhe o autômato dos estados LR."
                                  ],
                                  "verification": "Verifique se todos os estados foram calculados corretamente comparando com uma referência padrão para esta gramática.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Papel e caneta ou editor de texto como VS Code",
                                    "Tabela de referência de gramática LR para expressões aritméticas"
                                  ],
                                  "tips": "Comece sempre pelo estado inicial I0 com S' → .S; use kernel e closure sistematicamente.",
                                  "learningObjective": "Compreender a base dos parsers bottom-up através da construção de itens LR(0).",
                                  "commonMistakes": [
                                    "Esquecer o closure em itens não-kernel",
                                    "Erro em gotos para símbolos terminais/não-terminais",
                                    "Ignorar a produção aumentada S'"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Construir a tabela de parsing SLR/LALR",
                                  "subSteps": [
                                    "Preencha a tabela de ação (AÇÃO) para shifts e reduces usando itens LR(0) e FOLLOW sets para resolver conflitos.",
                                    "Preencha a coluna IR_AÇÃO para erros e a tabela GOTO para não-terminais.",
                                    "Exemplo: Para estado com E → E .+ T, ACTION[+] = s(k) onde k é goto(+).",
                                    "Valide a tabela com uma entrada válida curta como 'id + id' para shifts e reduces corretos.",
                                    "Anote estados com potencial para recuperação de erro."
                                  ],
                                  "verification": "Teste a tabela com uma string válida; deve aceitar sem erros.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Planilha Excel ou ferramenta online como JFLAP para LR parsing",
                                    "Papel quadriculado para tabela"
                                  ],
                                  "tips": "Use FOLLOW para decidir reduces em conflitos shift-reduce; SLR é mais simples que LALR.",
                                  "learningObjective": "Dominar a construção de tabelas de parsing determinísticas para gramáticas LR(0)/SLR(1).",
                                  "commonMistakes": [
                                    "Confundir shift com reduce em lookaheads",
                                    "FOLLOW sets incorretos",
                                    "Estados duplicados no autômato"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Simular o parsing na entrada inválida até detectar o erro",
                                  "subSteps": [
                                    "Escolha entrada inválida: 'id + * id' (erro: * após + sem T).",
                                    "Inicie pilha vazia, estado 0; processe tokens: id (shift para F), reduce F→id, etc., até 'id + ' (estado após E→E+T . ou similar).",
                                    "Ao token '*': procure ACTION[estado][*]; se erro (não shift nem reduce), detecte erro sintático.",
                                    "Registre pilha, estado atual e token lookahead no momento do erro.",
                                    "Explique por que é inválido: após + espera T, mas * não inicia T adequadamente."
                                  ],
                                  "verification": "Pilha e estados devem coincidir com simulação manual passo a passo.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Tabela de parsing impressa",
                                    "Simulador de stack online ou papel"
                                  ],
                                  "tips": "Mantenha pilha de estados e símbolos visíveis; anote cada shift/reduce/goto.",
                                  "learningObjective": "Executar parsing bottom-up e identificar precisamente o ponto de erro.",
                                  "commonMistakes": [
                                    "Erro em reduces múltiplos",
                                    "Confundir estado atual",
                                    "Pular gotos após reduce"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar recuperação por frase (phrase-level recovery)",
                                  "subSteps": [
                                    "No estado de erro com lookahead '*', pop símbolos da pilha até encontrar um handle válido (frase completa) que permita sincronização.",
                                    "Delete tokens lookahead até que ACTION[estado][novo_lookahead] ≠ erro (ex: delete '*' e shift 'id').",
                                    "Identifique 'frase inválida' como '+ *' e recupere pulando para próximo viável, simulando deleção de frase E → E + T parcial.",
                                    "Registre nova pilha após pops e próximo shift.",
                                    "Continue parsing até $ para ver recuperação completa."
                                  ],
                                  "verification": "Parsing deve prosseguir e aceitar o resto após recuperação, produzindo árvore parcial válida.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Tabela de parsing",
                                    "Exemplo anotado de recuperação"
                                  ],
                                  "tips": "Pop até estado com ACTION viável no lookahead atual; priorize frases maiores para menos perda.",
                                  "learningObjective": "Implementar heurística de recuperação por frase em parsers LR.",
                                  "commonMistakes": [
                                    "Pop excessivo perdendo contexto válido",
                                    "Não atualizar lookahead após delete",
                                    "Ignorar FOLLOW na sincronização"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Verificar e analisar a recuperação completa",
                                  "subSteps": [
                                    "Complete o parsing até EOF ($); note símbolos recuperados e árvore sintática resultante.",
                                    "Compare com entrada original: relatório de erro 'erro sintático em * recuperado pulando frase'.",
                                    "Teste variações: 'id + + id' ou '( id + ) * id'.",
                                    "Discuta limitações: cascata de erros vs. recuperação local.",
                                    "Documente o processo em diagrama pilha-estado."
                                  ],
                                  "verification": "Relatório final mostra detecção, recuperação e parse parcial bem-sucedido.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Ferramenta como Bison/Yacc com debug",
                                    "Papel para diagramas"
                                  ],
                                  "tips": "Use debug flags em ferramentas reais para validar.",
                                  "learningObjective": "Avaliar eficácia da recuperação por frase em cenários reais.",
                                  "commonMistakes": [
                                    "Não reportar localização exata do erro",
                                    "Recuperação que falha no final",
                                    "Confundir com panic mode"
                                  ]
                                }
                              ],
                              "practicalExample": "Gramática: S → E | ε, E → E + T | T, T → T * F | F, F → (E) | id. Tabela SLR construída. Entrada: 'id + * id $'. Parsing: shift id, reduce F→id, T→F, E→T; shift +, goto E→E.+T; lookahead *: ACTION=erro. Recuperação: pop até após +, delete *, shift id, reduce F→id, T→F, E→E+T. Resultado: E → id + id (recuperado).",
                              "finalVerifications": [
                                "Construção correta de pelo menos 8 estados LR(0) sem conflitos não-resolvidos.",
                                "Simulação exata do parsing até erro com pilha precisa.",
                                "Recuperação por frase deleta exatamente os tokens necessários sem perda excessiva.",
                                "Parse final produz árvore sintática válida para entrada corrigida.",
                                "Relatório inclui localização do erro e estratégia usada.",
                                "Teste com 2 entradas inválidas adicionais funciona."
                              ],
                              "assessmentCriteria": [
                                "Precisão na construção da tabela SLR/LALR (90% ações corretas).",
                                "Correta detecção e localização do erro sintático.",
                                "Aplicação fiel da heurística de recuperação por frase.",
                                "Análise clara de antes/depois da recuperação.",
                                "Uso correto de FOLLOW sets em decisões.",
                                "Documentação completa com diagramas."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Parsing de expressões aritméticas relaciona-se a avaliação de precedência e associatividade.",
                                "Programação: Implementação em linguagens como C++ usando Yacc/Bison para compiladores.",
                                "Lógica: Autômatos finitos e pilhas em teoria da computação.",
                                "Engenharia de Software: Tratamento de erros robusto em ferramentas de desenvolvimento."
                              ],
                              "realWorldApplication": "Em compiladores como GCC ou Clang, recuperação por frase permite editar código com erros sintáticos menores (ex: operador extra) sem rejeitar todo o arquivo, fornecendo diagnósticos úteis como 'expected ';' before '*' mas recuperado'."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.4.3.2.3",
                            "name": "Comparar com modo pânico",
                            "description": "Contrastar recuperação por frase (mais precisa, custo computacional maior) versus modo pânico (rápido, mas grosseiro), com cenários onde cada um é preferível, baseado em Santos e Langlois.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Conceito de Recuperação por Frase",
                                  "subSteps": [
                                    "Leia a seção sobre recuperação por frase em parsers bottom-up nos materiais de referência.",
                                    "Identifique como ela sincroniza o parser com a entrada após um erro sintático, agrupando tokens em frases válidas.",
                                    "Anote os passos: descartar tokens inválidos até encontrar uma frase viável, inserir tokens faltantes se necessário.",
                                    "Registre o custo computacional: análise mais profunda de lookahead.",
                                    "Compare brevemente com recuperação local para contextualizar."
                                  ],
                                  "verification": "Resuma em 3-5 frases os princípios da recuperação por frase e liste 2 vantagens principais.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Livro 'Compiladores' de Santos e Langlois, notas de aula sobre parsers bottom-up",
                                  "tips": "Foque em exemplos de frases como 'if (cond) stmt;' para visualizar sincronização.",
                                  "learningObjective": "Compreender o mecanismo preciso de recuperação por frase e seu impacto em precisão.",
                                  "commonMistakes": "Confundir com recuperação por token único; ignorar custo de lookahead extenso."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Revisar Conceito de Modo Pânico",
                                  "subSteps": [
                                    "Estude a descrição do modo pânico: pular tokens até sincronização em delimitadores como ';' ou '}'",
                                    "Anote características: rápido, simples, mas perde contexto e pode descartar código válido.",
                                    "Liste os passos típicos: marcar erro, ignorar entrada até token sincronizador.",
                                    "Registre cenários onde é usado: erros graves em blocos de código.",
                                    "Compare superficialmente com recuperação por frase para antecipar diferenças."
                                  ],
                                  "verification": "Descreva o algoritmo do modo pânico em pseudocódigo simples e cite 2 desvantagens.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Livro 'Compiladores' de Santos e Langlois, exemplos de código com erros sintáticos",
                                  "tips": "Pense em código como 'x = 1 + ; y = 2;' para ver como pula até ';' próximo.",
                                  "learningObjective": "Dominar o mecanismo grosseiro e eficiente do modo pânico.",
                                  "commonMistakes": "Subestimar perda de precisão; achar que é sempre inferior sem contexto."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Comparar Mecanismos: Prós, Contras e Métricas",
                                  "subSteps": [
                                    "Crie uma tabela comparativa: precisão (frase > pânico), custo computacional (frase > pânico), taxa de recuperação.",
                                    "Analise prós da frase: recupera mais código, diagnósticos melhores; contras: mais lento.",
                                    "Analise prós do pânico: velocidade, simplicidade; contras: grosseiro, pode falhar em estruturas aninhadas.",
                                    "Calcule métricas hipotéticas: tempo de execução em exemplos simples vs. complexos.",
                                    "Referencie Santos e Langlois para suporte teórico às diferenças."
                                  ],
                                  "verification": "Preencha tabela comparativa com pelo menos 4 métricas e justifique com referências.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Planilha ou papel para tabela, trechos de Santos e Langlois sobre tratamento de erros",
                                  "tips": "Use métricas quantificáveis como 'número de tokens recuperados' para objetividade.",
                                  "learningObjective": "Realizar comparação estruturada entre os dois modos de recuperação.",
                                  "commonMistakes": "Focar só em teoria sem métricas; ignorar trade-offs contextuais."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Identificar Cenários de Preferência e Aplicação",
                                  "subSteps": [
                                    "Liste cenários para frase: erros locais em expressões, linguagens com lookahead moderado.",
                                    "Liste cenários para pânico: erros em blocos grandes, compiladores em tempo real.",
                                    "Simule 2 exemplos: um onde frase é melhor (erro em if-stmt), um para pânico (bloco inválido).",
                                    "Avalie baseado em Santos e Langlois: quando custo justifica precisão.",
                                    "Conclua com híbridos ou escolhas em compiladores reais."
                                  ],
                                  "verification": "Escreva 3 cenários específicos com justificativa de escolha do modo.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Exemplos de código fonte com erros, resumo de Santos e Langlois",
                                  "tips": "Considere performance: pânico para IDEs rápidas, frase para análise estática profunda.",
                                  "learningObjective": "Aplicar comparação a contextos práticos para decisões informadas.",
                                  "commonMistakes": "Generalizar um como sempre melhor; não considerar custo vs. benefício."
                                }
                              ],
                              "practicalExample": "Em um parser LR(1) para uma linguagem simples, ao encontrar 'x = 1 + ; y=2;', recuperação por frase insere ')' e sincroniza em 'y=2;', recuperando mais código (precisa, mas analisa lookahead). Modo pânico pula até próximo ';', descartando 'y=2;' (rápido, mas grosseiro). Teste em código Python simulando parser.",
                              "finalVerifications": [
                                "Explicar diferenças em precisão e custo sem consultar notas.",
                                "Criar tabela comparativa precisa de memória.",
                                "Identificar 2 cenários reais onde cada modo é preferível.",
                                "Referenciar corretamente Santos e Langlois em argumentos.",
                                "Simular recuperação em um exemplo de código fornecido."
                              ],
                              "assessmentCriteria": [
                                "Precisão na descrição de mecanismos (80% match com referências).",
                                "Profundidade da comparação (métricas quantitativas incluídas).",
                                "Relevância de cenários (alinhados a contextos reais de compiladores).",
                                "Uso correto de referências teóricas.",
                                "Clareza e estrutura na tabela/comparação.",
                                "Identificação de trade-offs custo-benefício."
                              ],
                              "crossCurricularConnections": [
                                "Análise de Algoritmos: Complexidade temporal em recuperação de erros.",
                                "Engenharia de Software: Trade-offs em design de ferramentas de desenvolvimento.",
                                "Matemática Discreta: Autômatos e sincronização em linguagens formais.",
                                "UX/UI: Impacto de diagnósticos de erro na experiência do programador."
                              ],
                              "realWorldApplication": "Em compiladores como GCC ou Clang, modo pânico é usado para erros graves em funções grandes para feedback rápido em IDEs; recuperação por frase em ferramentas de linting como ESLint para diagnósticos precisos em JavaScript, melhorando produtividade de desenvolvedores."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.4.4",
                    "name": "Tratamento de Erros Semânticos",
                    "description": "Detecção de erros contextuais, como incompatibilidades de tipos e escopo, com reporte e recuperação via tabelas de símbolos.",
                    "individualConcepts": [
                      {
                        "id": "10.1.4.4.1",
                        "name": "Detecção de Incompatibilidades de Tipos",
                        "description": "Identificação e verificação de erros semânticos relacionados a incompatibilidades entre tipos de dados em operações, atribuições e chamadas de funções durante a análise semântica.",
                        "specificSkills": [
                          {
                            "id": "10.1.4.4.1.1",
                            "name": "Verificar compatibilidade de tipos em atribuições",
                            "description": "Analisar expressões de atribuição para detectar quando o tipo do valor à direita é incompatível com o tipo da variável à esquerda, utilizando regras de promoção e coerção de tipos definidas na linguagem.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os tipos primitivos e regras de promoção/coerção da linguagem",
                                  "subSteps": [
                                    "Liste os tipos primitivos suportados (ex: int, float, string, bool).",
                                    "Estude a tabela de promoção de tipos (ex: int -> float, mas não string -> int).",
                                    "Identifique regras de coerção implícita vs explícita (casts).",
                                    "Anote exceções, como promoção numérica em linguagens como C ou Java.",
                                    "Crie um diagrama de hierarquia de tipos compatíveis."
                                  ],
                                  "verification": "Crie uma tabela resumida de compatibilidades e teste com 3 exemplos manuais.",
                                  "estimatedTime": "30-45 minutos",
                                  "materials": [
                                    "Documentação da linguagem de referência (ex: C, Java)",
                                    "Papel e caneta ou ferramenta de diagramação como Draw.io"
                                  ],
                                  "tips": "Comece com tipos numéricos, pois são os mais comuns em atribuições.",
                                  "learningObjective": "Dominar as regras fundamentais de tipos e suas intercompatibilidades.",
                                  "commonMistakes": [
                                    "Confundir promoção com conversão unidirecional.",
                                    "Ignorar coerções implícitas em linguagens weakly-typed."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar a sintaxe da atribuição para extrair tipos da esquerda e direita",
                                  "subSteps": [
                                    "Identifique o identificador da variável à esquerda e busque seu tipo na tabela de símbolos.",
                                    "Parseie a expressão à direita recursivamente para inferir seu tipo.",
                                    "Lide com expressões compostas (ex: operações aritméticas que promovem tipos).",
                                    "Registre tipos em uma estrutura de dados temporária para comparação.",
                                    "Trate casos especiais como literais (ex: '42' é string ou int?)."
                                  ],
                                  "verification": "Aplique em 5 trechos de código simples e anote os tipos extraídos corretamente.",
                                  "estimatedTime": "45-60 minutos",
                                  "materials": [
                                    "Editor de código com sintaxe highlight",
                                    "Exemplos de código de atribuições variadas"
                                  ],
                                  "tips": "Use uma árvore de parsing para expressões complexas à direita.",
                                  "learningObjective": "Extrair e inferir tipos com precisão de expressões de atribuição.",
                                  "commonMistakes": [
                                    "Não considerar promoção em operadores binários.",
                                    "Erros em inferência de literais ambíguos."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar a lógica de verificação de compatibilidade de tipos",
                                  "subSteps": [
                                    "Compare tipo_esquerda com tipo_direita usando a tabela de regras.",
                                    "Aplique promoções automáticas se aplicável (ex: int para float).",
                                    "Rejeite se incompatível e sem coerção possível.",
                                    "Gere um código de erro semântico específico (ex: TYPE_MISMATCH).",
                                    "Teste unitário com casos de borda (ex: void* em C)."
                                  ],
                                  "verification": "Implemente uma função checker() e rode testes com asserts para 10 cenários.",
                                  "estimatedTime": "60-90 minutos",
                                  "materials": [
                                    "Linguagem de implementação (Python/C++)",
                                    "Framework de testes (unittest/pytest)"
                                  ],
                                  "tips": "Use switch/case ou mapa de regras para comparações eficientes.",
                                  "learningObjective": "Aplicar regras de compatibilidade de forma programática e detectar erros.",
                                  "commonMistakes": [
                                    "Permitir downgrades sem cast (ex: float para int).",
                                    "Ignorar null/undefined como tipos wildcard."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Integrar verificação no fluxo do compilador e gerar relatórios de erro",
                                  "subSteps": [
                                    "Insira a verificação na fase semântica pós-parsing.",
                                    "Colete posição (linha/coluna) para relatório preciso.",
                                    "Emita mensagem de erro amigável com sugestões (ex: 'Use cast (int)').",
                                    "Atualize tabela de símbolos se atribuição válida.",
                                    "Valide em um compilador toy completo."
                                  ],
                                  "verification": "Compile 5 programas com erros e confirme detecção + mensagens corretas.",
                                  "estimatedTime": "45-60 minutos",
                                  "materials": [
                                    "Compilador toy ou parser generator (ANTLR/Yacc)",
                                    "Exemplos de código com erros intencionais"
                                  ],
                                  "tips": "Priorize erros de atribuição sobre outros para depuração inicial.",
                                  "learningObjective": "Integrar detecção em um pipeline de compilação realista.",
                                  "commonMistakes": [
                                    "Relatórios vagos sem contexto (posição).",
                                    "Não propagar erros para fases subsequentes."
                                  ]
                                }
                              ],
                              "practicalExample": "Em uma linguagem similar a C: 'int score = 95.5;' → Detectar incompatibilidade (double não atribui a int sem cast). Parser infere tipo_esquerda=int, tipo_direita=double → incompatível → erro: 'Tipo double incompatível com int em linha 5, use (int)95.5'.",
                              "finalVerifications": [
                                "Lista corretamente tipos e regras de promoção para 5 linguagens diferentes.",
                                "Analisa 10 atribuições complexas extraindo tipos sem erros.",
                                "Implementa checker que passa em todos testes unitários incluindo borda cases.",
                                "Gera relatórios de erro precisos e úteis.",
                                "Integra em compilador toy sem quebrar fluxo normal.",
                                "Explica verbalmente o processo para um par de programação."
                              ],
                              "assessmentCriteria": [
                                "Precisão na inferência de tipos (100% em testes).",
                                "Cobertura completa de regras de promoção/coerção.",
                                "Eficiência da implementação (O(1) por verificação).",
                                "Qualidade das mensagens de erro (claras e acionáveis).",
                                "Robustez contra casos edge (null, arrays, unions).",
                                "Documentação do código com comentários."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Hierarquias de conjuntos e subtipos (teoria de tipos).",
                                "Lógica: Inferência dedutiva em regras de compatibilidade.",
                                "Engenharia de Software: Validação estática e análise semântica.",
                                "Design de Sistemas: Abstrações de tipos em linguagens modernas (TypeScript)."
                              ],
                              "realWorldApplication": "Usado em compiladores como GCC/Clang para C/C++, javac para Java, e linters como ESLint/Pylint para detecção precoce de bugs de tipo, prevenindo runtime errors e melhorando performance ao evitar casts desnecessários."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.4.4.1.2",
                            "name": "Detectar erros em operações aritméticas binárias",
                            "description": "Implementar verificações para operações como soma, subtração e multiplicação, garantindo que os operandos tenham tipos compatíveis ou passíveis de conversão implícita.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Definir regras de compatibilidade de tipos para operações aritméticas binárias",
                                  "subSteps": [
                                    "Identificar tipos primitivos suportados pela linguagem (ex: int, float, double, char).",
                                    "Especificar pares compatíveis para cada operação: soma (+), subtração (-) e multiplicação (*).",
                                    "Definir regras de promoção implícita (ex: int + float promove para float).",
                                    "Criar uma tabela ou estrutura de dados representando as regras de compatibilidade e promoção.",
                                    "Documentar exceções, como evitar overflow implícito ou tipos não numéricos (string, bool)."
                                  ],
                                  "verification": "Gerar uma tabela ou mapa que retorne true/false para pelo menos 10 combinações de tipos e operações.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Documentação da linguagem de programação alvo",
                                    "Editor de texto ou planilha para tabela",
                                    "Referências sobre type systems"
                                  ],
                                  "tips": [
                                    "Priorize tipos numéricos comuns antes de edge cases.",
                                    "Use enums para representar tipos na implementação futura."
                                  ],
                                  "learningObjective": "Compreender e formalizar as regras de type compatibility para operações aritméticas binárias.",
                                  "commonMistakes": [
                                    "Esquecer promoção implícita (ex: int + double).",
                                    "Incluir tipos não numéricos como compatíveis.",
                                    "Confundir compatibilidade com coerção explícita."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar função de verificação de compatibilidade de tipos",
                                  "subSteps": [
                                    "Definir assinatura da função: checkBinaryOpTypes(leftType, operator, rightType) -> {compatible: bool, resultType: Type, errorMsg: string}.",
                                    "Implementar lógica com switch/case para operadores (+, -, *).",
                                    "Aplicar regras de promoção: promover tipos menores para maiores se possível.",
                                    "Retornar tipo resultante se compatível, ou mensagem de erro detalhada se incompatível.",
                                    "Adicionar suporte para auto-boxing se aplicável (ex: Integer + int)."
                                  ],
                                  "verification": "Executar unit tests com 5 casos válidos e 5 inválidos, verificando retorno correto.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "IDE com suporte a testes unitários (ex: VS Code, IntelliJ)",
                                    "Biblioteca de tipos da linguagem"
                                  ],
                                  "tips": [
                                    "Teste incrementalmente: valide um operador por vez.",
                                    "Mantenha mensagens de erro claras e específicas."
                                  ],
                                  "learningObjective": "Desenvolver uma função reutilizável para detecção de erros de tipo em ops binárias.",
                                  "commonMistakes": [
                                    "Não retornar tipo resultante após promoção.",
                                    "Ignorar associatividade da operação.",
                                    "Erros em comparações de tipos (ex: usar == em vez de equals para objetos)."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Integrar verificação no analisador semântico do compilador",
                                  "subSteps": [
                                    "Identificar nós AST para BinaryOp (ex: visitBinaryExpression no visitor pattern).",
                                    "Chamar checkBinaryOpTypes nos nós de operação aritmética durante a fase semântica.",
                                    "Propagar erros para tabela de símbolos ou lista de erros do compilador.",
                                    "Haltar compilação ou marcar como erro semântico se incompatível.",
                                    "Atualizar tipo do nó resultante se compatível."
                                  ],
                                  "verification": "Processar um AST simples com ops binárias e confirmar detecção de erros.",
                                  "estimatedTime": "50 minutos",
                                  "materials": [
                                    "Código base do compilador/AST walker",
                                    "Exemplos de árvores de sintaxe sinteticamente corretas"
                                  ],
                                  "tips": [
                                    "Use visitor pattern para separação de responsabilidades.",
                                    "Registre erros com linha/coluna para debugging."
                                  ],
                                  "learningObjective": "Integrar detecção de erros em um fluxo semântico real de compilador.",
                                  "commonMistakes": [
                                    "Verificar tipos na fase lexical/sintática em vez de semântica.",
                                    "Não propagar erros para fases subsequentes.",
                                    "Modificar AST prematuramente."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Testar, depurar e refinar a detecção de erros",
                                  "subSteps": [
                                    "Criar casos de teste: compatíveis, incompatíveis, com promoção, edge cases (divisão por zero indireta).",
                                    "Executar analisador em códigos fonte com erros intencionais.",
                                    "Depurar falhas: usar debugger ou logs para inspecionar tipos.",
                                    "Refinar regras baseadas em testes falhados e adicionar mais verificações.",
                                    "Gerar relatório de cobertura de testes (>80%)."
                                  ],
                                  "verification": "Todos testes passam e relatório confirma detecção precisa em 20+ cenários.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Suite de testes unitários e de integração",
                                    "Códigos fonte de teste com erros semânticos"
                                  ],
                                  "tips": [
                                    "Automatize testes com framework (ex: JUnit, pytest).",
                                    "Inclua casos reais de bugs comuns em código legado."
                                  ],
                                  "learningObjective": "Validar robustez da implementação através de testes abrangentes.",
                                  "commonMistakes": [
                                    "Testes insuficientes para edge cases.",
                                    "Ignorar performance em grandes ASTs.",
                                    "Não limpar estado entre testes."
                                  ]
                                }
                              ],
                              "practicalExample": "Em um código fonte como: int result = 10 + \"hello\"; o analisador semântico, ao visitar o nó BinaryOp('+', int, string), chama checkBinaryOpTypes(int, '+', string), detecta incompatibilidade, reporta erro 'Incompatibilidade de tipos: operandos de soma devem ser numéricos' na linha 1, col 12, e impede geração de código.",
                              "finalVerifications": [
                                "Lista corretamente regras de compatibilidade para +,-,* em pelo menos 3 pares de tipos.",
                                "Implementa checkBinaryOpTypes que passa em 10 unit tests mistos.",
                                "Integra detecção em AST sem quebrar análise semântica válida.",
                                "Gera mensagens de erro precisas com localização.",
                                "Testa e corrige edge cases como promoção int+float."
                              ],
                              "assessmentCriteria": [
                                "Precisão: Detecta 100% dos erros de tipo em ops binárias testadas.",
                                "Cobertura: Trata todos operadores aritméticos binários (+,-,*).",
                                "Eficiência: Tempo de análise O(n) no AST.",
                                "Usabilidade: Mensagens de erro claras e acionáveis.",
                                "Robustez: Não crasha em inputs malformados."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Sistemas numéricos e propriedades algébricas (fechamento sob operações).",
                                "Lógica e Teoria da Computação: Verificação de pré-condições em autómatos.",
                                "Engenharia de Software: Design de APIs para análise estática e type checking.",
                                "Linguagens Formais: Gramáticas atribuídas e análise semântica."
                              ],
                              "realWorldApplication": "Compiladores como GCC, Clang e Javac usam detecção similar para prevenir erros em runtime, como TypeError em Python ou crashes em C++; ferramentas como ESLint/TS checker aplicam em JS/TS, melhorando qualidade de código em produção e reduzindo debugging."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.4.4.1.3",
                            "name": "Validar parâmetros em chamadas de funções",
                            "description": "Comparar os tipos dos argumentos reais com os tipos dos parâmetros formais declarados na função, reportando erros de incompatibilidade de assinatura.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Analisar a declaração da função e extrair parâmetros formais",
                                  "subSteps": [
                                    "Localize a declaração da função no símbolo table ou AST (Abstract Syntax Tree).",
                                    "Identifique o nome da função e liste os parâmetros formais em ordem.",
                                    "Registre os tipos esperados para cada parâmetro formal (ex: int, float, string).",
                                    "Anote o número de parâmetros e se há suporte a varargs.",
                                    "Valide se a função existe; se não, reporte erro separado."
                                  ],
                                  "verification": "Confirme que a lista de parâmetros formais e seus tipos foi extraída corretamente comparando com o código fonte.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Código fonte do programa, tabela de símbolos do compilador, documentação da linguagem.",
                                  "tips": "Sempre priorize a declaração mais próxima no escopo para funções sobrecarregadas.",
                                  "learningObjective": "Compreender e extrair assinaturas de funções para validação posterior.",
                                  "commonMistakes": "Ignorar sobrecarga de funções ou confundir parâmetros com variáveis locais."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar e parsear a chamada de função no código",
                                  "subSteps": [
                                    "Encontre a chamada de função no AST durante a análise semântica.",
                                    "Conte o número de argumentos reais fornecidos.",
                                    "Identifique cada argumento real (expressões, variáveis, literais).",
                                    "Registre a posição de cada argumento na lista.",
                                    "Verifique sintaxe básica da chamada (parênteses, vírgulas)."
                                  ],
                                  "verification": "A chamada foi parseada corretamente se o número e posições dos argumentos coincidem com o código.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "AST do código, parser do compilador, exemplos de código com chamadas.",
                                  "tips": "Use caminhamento em árvore no AST para localizar nodos de FunctionCall.",
                                  "learningObjective": "Localizar e decompor chamadas de funções para análise de argumentos.",
                                  "commonMistakes": "Contar argumentos incorretamente em expressões aninhadas ou com macros."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Resolver e extrair tipos dos argumentos reais",
                                  "subSteps": [
                                    "Para cada argumento, realize type inference ou lookup na tabela de símbolos.",
                                    "Resolva tipos de expressões compostas (ex: promoções implícitas).",
                                    "Liste os tipos resolvidos dos argumentos em ordem.",
                                    "Aplique regras de coerção de tipos da linguagem se aplicável.",
                                    "Marque argumentos indefinidos ou ambíguos para erro posterior."
                                  ],
                                  "verification": "Tipos resolvidos devem corresponder a inferências manuais em exemplos simples.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Tabela de símbolos, regras de type inference da linguagem, exemplos de expressões.",
                                  "tips": "Cache tipos resolvidos para evitar reprocessamento em chamadas múltiplas.",
                                  "learningObjective": "Inferir tipos precisos de argumentos em contextos variados.",
                                  "commonMistakes": "Esquecer promoções automáticas como int para float."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Comparar tipos e reportar incompatibilidades",
                                  "subSteps": [
                                    "Compare tipo do argumento i com tipo do parâmetro formal i.",
                                    "Verifique igualdade exata ou coerções permitidas pela linguagem.",
                                    "Se número de argumentos != parâmetros (exceto varargs), reporte erro.",
                                    "Gere mensagem de erro detalhada com nomes, tipos e posições.",
                                    "Integre o erro no sistema de diagnósticos do compilador."
                                  ],
                                  "verification": "Execute o validador em código com erros conhecidos e confirme relatórios corretos.",
                                  "estimatedTime": "35 minutos",
                                  "materials": "Lista de parâmetros formais, tipos de argumentos, exemplos de código inválido.",
                                  "tips": "Use uma tabela de compatibilidade de tipos para comparações rápidas.",
                                  "learningObjective": "Implementar comparação de assinaturas e geração de erros semânticos.",
                                  "commonMistakes": "Permitir coerções inválidas ou falhar em varargs."
                                }
                              ],
                              "practicalExample": "Função declarada: int calculateArea(int width, double height). Chamada: calculateArea(10, \"ten\"). O segundo argumento é string, incompatível com double. O validador deve reportar: 'Erro semântico na linha 15: argumento 2 tem tipo string, esperado double em calculateArea'.",
                              "finalVerifications": [
                                "Extrai corretamente parâmetros formais de declarações de funções.",
                                "Parseia chamadas e conta argumentos reais com precisão.",
                                "Infere tipos de argumentos incluindo expressões complexas.",
                                "Detecta e reporta incompatibilidades de assinatura com mensagens claras.",
                                "Lida com casos edge como varargs e sobrecarga.",
                                "Integra validação sem interromper fluxo semântico geral."
                              ],
                              "assessmentCriteria": [
                                "Precisão na extração de assinaturas (100% match com fonte).",
                                "Correção na inferência de tipos (taxa de acerto >95%).",
                                "Detecção completa de erros de incompatibilidade.",
                                "Mensagens de erro informativas e localizadas.",
                                "Eficiência: tempo de execução linear no número de chamadas.",
                                "Robustez contra códigos malformados ou indefinidos."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria de tipos e funções tipadas.",
                                "Lógica: Inferência e dedução de tipos.",
                                "Engenharia de Software: Verificação estática e testes unitários.",
                                "Linguística Computacional: Parsing e análise semântica."
                              ],
                              "realWorldApplication": "Em compiladores como GCC ou Clang, essa validação detecta erros de tipo em chamadas de funções durante a compilação, prevenindo falhas em runtime, otimizando código e melhorando a experiência do desenvolvedor com diagnósticos precisos."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.4.4.2",
                        "name": "Verificação de Escopo e Declarações",
                        "description": "Uso de tabelas de símbolos para detectar erros contextuais relacionados a escopo de variáveis, como uso de identificadores não declarados ou fora de escopo.",
                        "specificSkills": [
                          {
                            "id": "10.1.4.4.2.1",
                            "name": "Consultar tabelas de símbolos para resolução de identificadores",
                            "description": "Implementar busca em pilha de tabelas de símbolos para verificar se um identificador está declarado no escopo atual ou em escopos aninhados.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender e Configurar a Estrutura de Pilha de Tabelas de Símbolos",
                                  "subSteps": [
                                    "Estude o conceito de tabela de símbolos como um mapa {nome: atributos} para escopos.",
                                    "Defina uma estrutura de dados para TabelaDeSimbolos (ex: dicionário ou hashmap).",
                                    "Crie uma Pilha como lista ou stack para armazenar múltiplas tabelas de símbolos.",
                                    "Implemente funções básicas: push (novo escopo) e pop (fim de escopo).",
                                    "Inicialize a pilha com escopo global vazio."
                                  ],
                                  "verification": "Verifique se push e pop funcionam imprimindo o estado da pilha após operações.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Linguagem de programação com dicionários (Python, Java, C++)",
                                    "Editor de código",
                                    "Documentação de estruturas de dados"
                                  ],
                                  "tips": "Use dicionários para lookups O(1); evite listas para tabelas internas.",
                                  "learningObjective": "Compreender como pilhas modelam escopos aninhados dinamicamente.",
                                  "commonMistakes": [
                                    "Confundir escopo local com global ao fazer push sem limpar",
                                    "Não inicializar tabela vazia no push"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar Inserção de Identificadores em Escopos",
                                  "subSteps": [
                                    "Crie função insert(nome, atributos) que adiciona à tabela no topo da pilha.",
                                    "Verifique se o identificador já existe no escopo atual (redeclaração).",
                                    "Se não existir, insira; caso contrário, reporte erro semântico.",
                                    "Teste inserção em escopo global e local.",
                                    "Garanta que inserções em escopo filho não afetem pais."
                                  ],
                                  "verification": "Insira 'x' no global e 'x' no local; confirme que local sobrescreve só localmente.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Código do Step 1",
                                    "Exemplos de código fonte simples com declarações"
                                  ],
                                  "tips": "Sempre cheque redeclaração ANTES de inserir para evitar shadowing indesejado.",
                                  "learningObjective": "Dominar inserção com detecção de redeclarações em escopos.",
                                  "commonMistakes": [
                                    "Inserir sem checar duplicatas",
                                    "Modificar tabelas de escopos ancestrais"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar Função de Lookup para Resolução de Identificadores",
                                  "subSteps": [
                                    "Crie função resolve(nome) que começa na tabela topo da pilha.",
                                    "Se encontrado, retorne atributos; senão, pop e recursa no pai.",
                                    "Continue até escopo global ou pilha vazia (não declarado).",
                                    "Retorne None ou lance erro se não encontrado.",
                                    "Otimize para não modificar a pilha durante lookup."
                                  ],
                                  "verification": "Declare 'x' global, 'y' local; resolva 'x' e 'y' corretamente de escopo filho.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Código dos Steps 1-2",
                                    "Pseudocódigo de compiladores",
                                    "Debugger"
                                  ],
                                  "tips": "Use loop while pilha não vazia ao invés de recursão profunda para evitar stack overflow.",
                                  "learningObjective": "Implementar busca linear em profundidade de escopos aninhados.",
                                  "commonMistakes": [
                                    "Buscar só no escopo atual",
                                    "Pop permanente durante lookup"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Integrar e Testar na Análise Semântica",
                                  "subSteps": [
                                    "Simule parser que chama insert em declarações e resolve em usos.",
                                    "Crie casos de teste: escopo ok, não declarado, shadowing.",
                                    "Reporte erros semânticos como 'Undeclared identifier' com linha.",
                                    "Teste pop ao fim de bloco/ função.",
                                    "Meça performance em pilha profunda (10+ escopos)."
                                  ],
                                  "verification": "Execute parser em código com erros; confirme detecção precisa.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Parser simples ou lexer mock",
                                    "Suite de testes unitários",
                                    "Exemplos de código com escopos"
                                  ],
                                  "tips": "Use asserts em testes para automação; cubra bordas como pilha vazia.",
                                  "learningObjective": "Aplicar lookup em fluxo real de compilação semântica.",
                                  "commonMistakes": [
                                    "Não restaurar pilha após testes",
                                    "Ignorar erros em shadowing"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um compilador para mini-linguagem: int x = 1; { int x = 2; print(x); } // Deve imprimir 2, resolvendo local primeiro, depois global se não achado.",
                              "finalVerifications": [
                                "Lookup resolve corretamente em escopo local sem buscar pais.",
                                "Shadowing permite redeclaração sem perda do global.",
                                "Erro 'undeclared' só após esgotar toda pilha.",
                                "Push/pop mantém integridade da pilha.",
                                "Performance aceitável (O(profundidade) por lookup).",
                                "Integração com parser simulado sem crashes."
                              ],
                              "assessmentCriteria": [
                                "Correção: 100% dos testes passam (escopos, erros).",
                                "Eficiência: Busca não excede profundidade da pilha.",
                                "Robustez: Trata pilha vazia e redeclarações.",
                                "Clareza: Código comentado e modular.",
                                "Cobertura: Testes incluem casos positivos/negativos.",
                                "Extensibilidade: Fácil adicionar atributos extras."
                              ],
                              "crossCurricularConnections": [
                                "Estruturas de Dados: Pilhas e Hashmaps.",
                                "Algoritmos: Busca linear em hierarquia.",
                                "Programação Funcional: Closures e escopos léxicos.",
                                "Engenharia de Software: Gerenciamento de estado em parsers."
                              ],
                              "realWorldApplication": "Em compiladores como GCC/Clang para C++, ou interpretadores Python/JavaScript, resolvendo variáveis em funções aninhadas, prevenindo erros de escopo em apps reais."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.4.4.2.2",
                            "name": "Detectar redeclarações em escopos conflitantes",
                            "description": "Identificar tentativas de redeclarar variáveis ou funções no mesmo escopo, violando regras de unicidade de nomes.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender Conceitos Fundamentais de Escopo e Redeclaração",
                                  "subSteps": [
                                    "Defina escopo léxico e dinâmico com exemplos simples em linguagens como C ou JavaScript.",
                                    "Explique a regra de unicidade de nomes: identificadores devem ser únicos no mesmo escopo.",
                                    "Identifique tipos de redeclarações: variáveis, funções, classes no mesmo bloco ou namespace.",
                                    "Analise exemplos de código válido vs. inválido para redeclarações.",
                                    "Discuta shadowing (ocultação) vs. conflito real de redeclaração."
                                  ],
                                  "verification": "Crie um diagrama manual de escopos para um código de exemplo e destaque potenciais conflitos.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Documentação de linguagens (MDN para JS, CPP Reference)",
                                    "Editor de texto para exemplos de código"
                                  ],
                                  "tips": "Use diagramas de árvore de escopos para visualizar hierarquias.",
                                  "learningObjective": "Compreender as regras semânticas de escopo que proíbem redeclarações conflitantes.",
                                  "commonMistakes": [
                                    "Confundir shadowing com redeclaração",
                                    "Ignorar escopos aninhados",
                                    "Assumir que escopo global permite duplicatas"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar Representação de Escopos com Tabelas de Símbolos",
                                  "subSteps": [
                                    "Crie uma estrutura de dados para tabela de símbolos (hash map ou árvore para escopos aninhados).",
                                    "Defina campos: nome do identificador, tipo, escopo pai, visibilidade.",
                                    "Implemente entrada na tabela durante a fase de declaração (AST traversal).",
                                    "Adicione suporte a escopos locais (funções, blocos) e globais.",
                                    "Teste inserção em escopos vazios e aninhados."
                                  ],
                                  "verification": "Insira declarações de um código de teste na tabela e imprima a estrutura para confirmar hierarquia.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Linguagem de programação (Python ou Java)",
                                    "Biblioteca de parsing AST (se disponível, como ANTLR)"
                                  ],
                                  "tips": "Use uma pilha de tabelas para escopos aninhados: push/pop no enter/exit de blocos.",
                                  "learningObjective": "Construir uma representação hierárquica de escopos para rastrear declarações.",
                                  "commonMistakes": [
                                    "Não empilhar escopos corretamente",
                                    "Verificar unicidade no escopo errado",
                                    "Vazar declarações para escopos pais"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Desenvolver Lógica de Detecção de Redeclarações",
                                  "subSteps": [
                                    "Ao encontrar uma declaração, busque o identificador no escopo atual.",
                                    "Se encontrado, dispare erro semântico com mensagem detalhada (posição, tipo conflitante).",
                                    "Diferencie redeclaração de redefinição válida (ex: parâmetros vs. locais).",
                                    "Implemente busca em escopo atual apenas (não propagar para pais para conflitos locais).",
                                    "Registre erros sem interromper a análise (coletar todos os erros)."
                                  ],
                                  "verification": "Execute em código com redeclarações conhecidas e confirme que erros são reportados corretamente.",
                                  "estimatedTime": "75 minutos",
                                  "materials": [
                                    "Código-fonte de um mini-compilador ou parser simples",
                                    "Exemplos de testes unitários"
                                  ],
                                  "tips": "Use enums para tipos de erros e posições no AST para diagnósticos precisos.",
                                  "learningObjective": "Implementar verificação de unicidade durante a análise semântica.",
                                  "commonMistakes": [
                                    "Buscar em escopos ancestrais para conflitos locais",
                                    "Ignorar case-sensitivity",
                                    "Reportar falsos positivos em shadowing"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Testar e Integrar Detecção em Pipeline de Compilação",
                                  "subSteps": [
                                    "Crie casos de teste: redeclaração variável/função, escopos globais/locais, aninhados.",
                                    "Integre a detecção após parsing AST, antes de type-checking.",
                                    "Gere relatórios de erros com linha/coluna e sugestões de correção.",
                                    "Otimize para performance em códigos grandes (O(1) lookups com hash).",
                                    "Valide com compiladores reais (ex: gcc -fsyntax-only)."
                                  ],
                                  "verification": "Rode suíte de testes: 100% detecção de casos positivos/negativos sem falsos positivos.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Framework de testes (JUnit, pytest)",
                                    "Exemplos de códigos inválidos de repositórios open-source"
                                  ],
                                  "tips": "Automatize testes com fuzzing para nomes aleatórios e escopos profundos.",
                                  "learningObjective": "Garantir robustez da detecção em cenários reais de compilação.",
                                  "commonMistakes": [
                                    "Não testar escopos vazios ou unitários",
                                    "Erros em relatórios (posição errada)",
                                    "Performance degradada por buscas lineares"
                                  ]
                                }
                              ],
                              "practicalExample": "Em JavaScript: function foo() { var x = 1; var x = 2; } // Erro: redeclaração de 'x' no escopo local. O compilador deve detectar no escopo da função e reportar violação de unicidade.",
                              "finalVerifications": [
                                "Construa tabela de símbolos para código complexo sem erros de inserção.",
                                "Detecte e reporte corretamente 5 casos de redeclaração em escopos variados.",
                                "Diferencie shadowing válido de conflito real.",
                                "Gere diagnósticos precisos com posições no código.",
                                "Teste performance em 1000 declarações sem slowdown.",
                                "Compare saída com ferramentas reais como ESLint ou gcc."
                              ],
                              "assessmentCriteria": [
                                "Precisão na detecção: 100% taxa de acerto em testes padrão.",
                                "Eficiência: Lookups em O(1) tempo médio.",
                                "Qualidade de erros: Mensagens claras, posicionadas corretamente.",
                                "Robustez: Lida com escopos profundamente aninhados (>10 níveis).",
                                "Modularidade: Código reutilizável em diferentes linguagens.",
                                "Cobertura de testes: >90% linhas cobertas."
                              ],
                              "crossCurricularConnections": [
                                "Lógica e Teoria da Computação: Autômatos e gramáticas context-free-free.",
                                "Estruturas de Dados: Hash tables e árvores para gerenciamento de símbolos.",
                                "Programação Funcional: Conceitos de escopo em closures e lambdas.",
                                "Engenharia de Software: Design de APIs para análise semântica."
                              ],
                              "realWorldApplication": "Em compiladores como GCC/Clang ou IDEs como VS Code, detecta erros precocemente evitando runtime crashes; essencial em linters como ESLint para JavaScript ou Pylint para Python, melhorando produtividade de desenvolvedores."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.4.4.2.3",
                            "name": "Gerenciar escopos aninhados em blocos e funções",
                            "description": "Criar e destruir entradas em tabelas de símbolos ao entrar e sair de blocos condicionais, loops e funções, garantindo visibilidade correta.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Configurar Estrutura de Tabelas de Símbolos Aninhadas",
                                  "subSteps": [
                                    "Defina uma estrutura de dados para tabela de símbolos usando uma pilha de mapas (ex: stack de HashMap em Java/Python).",
                                    "Crie um escopo global inicial e empilhe-o na stack.",
                                    "Implemente funções básicas: pushScope() para novo escopo e popScope() para remover.",
                                    "Adicione suporte para armazenar nome da variável, tipo e escopo pai.",
                                    "Teste push/pop com prints para visualizar a pilha."
                                  ],
                                  "verification": "Execute um teste que empilha 3 escopos e desempilha, confirmando ordem correta via logs.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Editor de código (VS Code)",
                                    "Linguagem com mapas/dicionários (Python/Java)"
                                  ],
                                  "tips": "Use uma lista/stack para gerenciar escopos, com o topo sendo o escopo atual.",
                                  "learningObjective": "Compreender a representação hierárquica de escopos como uma pilha.",
                                  "commonMistakes": [
                                    "Usar array fixo em vez de stack dinâmica",
                                    "Esquecer de linkar escopo pai"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Criar Escopos ao Entrar em Blocos e Funções",
                                  "subSteps": [
                                    "Identifique pontos de entrada: início de funções, blocos if/while/for.",
                                    "Ao detectar '{' ou def de função, chame pushScope() e registre tipo de escopo.",
                                    "Insira variáveis declaradas no escopo atual (topo da stack).",
                                    "Propague visibilidade de escopos pai para lookup.",
                                    "Registre metadados como linha do código para depuração."
                                  ],
                                  "verification": "Parse um código com if { int x; } e confirme que x está no novo escopo via dump da tabela.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Parser simples (ANTLR ou handmade)",
                                    "Código de teste com blocos aninhados"
                                  ],
                                  "tips": "Associe escopo à árvore sintática (AST) para traverser fácil.",
                                  "learningObjective": "Implementar detecção e criação dinâmica de escopos em tempo de análise.",
                                  "commonMistakes": [
                                    "Criar escopo em declarações isoladas",
                                    "Não empilhar em loops"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Gerenciar Visibilidade e Lookup em Escopos Aninhados",
                                  "subSteps": [
                                    "Implemente lookup(varName): busque do escopo atual para cima até global.",
                                    "Ao encontrar, retorne símbolo; senão, reporte erro semântico 'undeclared'.",
                                    "Diferencie declaração vs uso: insira só em declarações.",
                                    "Teste com variáveis shadow (mesmo nome em escopos filhos).",
                                    "Adicione cache opcional para lookups frequentes."
                                  ],
                                  "verification": "Teste referência a var de escopo pai dentro de filho; confirme resolução correta.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "AST walker",
                                    "Códigos de teste com shadowing e undeclared vars"
                                  ],
                                  "tips": "Sempre busque linearmente da stack.top para bottom.",
                                  "learningObjective": "Garantir resolução léxica de símbolos em hierarquia de escopos.",
                                  "commonMistakes": [
                                    "Lookup apenas no escopo local",
                                    "Permitir shadow em escopos não permitidos"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Destruir Escopos ao Sair de Blocos e Funções",
                                  "subSteps": [
                                    "Detecte '}' ou fim de função, chame popScope().",
                                    "Ao pop, remova o escopo e restaure visibilidade ao pai.",
                                    "Valide que não há referências pendentes no escopo removido.",
                                    "Reporte erros se var usada após pop (ex: loop var fora do loop).",
                                    "Limpe memória e logs para depuração."
                                  ],
                                  "verification": "Parse código completo, dump tabela final vazia exceto global; sem erros falsos.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Código de teste full program",
                                    "Debugger para stack traces"
                                  ],
                                  "tips": "Use try-finally ou recursão para garantir pop mesmo em erros.",
                                  "learningObjective": "Implementar destruição simétrica de escopos para limpeza.",
                                  "commonMistakes": [
                                    "Pop prematuro",
                                    "Não pop em todos os blocos"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um compilador para mini-linguagem: def func() { if (true) { int x = 1; } print(x); } → Erro: x undeclared (escopo if destruído). Correto: int x=1; if(true){int y=2;} print(x); → OK, x visível.",
                              "finalVerifications": [
                                "Desenhe pilha de escopos para código aninhado e simule push/pop.",
                                "Implemente e rode parser em 3 códigos: válido, shadow, undeclared → sem falsos positivos.",
                                "Explique por que var em loop não vaza para fora.",
                                "Modifique código para bug comum e corrija.",
                                "Compare com escopo em C/Python via exemplos."
                              ],
                              "assessmentCriteria": [
                                "Stack de escopos gerencia corretamente 5+ níveis aninhados.",
                                "Lookup resolve símbolos pai sem vazamento de filho.",
                                "Push/pop sincronizados com AST, sem leaks de memória.",
                                "Erros semânticos precisos com linha/coluna.",
                                "Performance: lookup O(n) com n<10 escopos.",
                                "Testes unitários cobrem 80% dos casos."
                              ],
                              "crossCurricularConnections": [
                                "Estruturas de Dados: Pilha e árvores para hierarquia.",
                                "Linguagens de Programação: Escopo léxico em C++/JavaScript.",
                                "Análise Estática: Linters como ESLint usam tabelas similares.",
                                "Teoria da Computação: Autômatos com memória empilhada."
                              ],
                              "realWorldApplication": "Compiladores como GCC/Clang usam tabelas de símbolos para checar declarações em funções/recursão; IDEs (VSCode) para autocompletar/intellisense em código aninhado."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.4.4.3",
                        "name": "Reporte e Recuperação de Erros Semânticos",
                        "description": "Estratégias para notificar o programador sobre erros semânticos e continuar a análise para detectar múltiplos erros, utilizando tabelas de símbolos para contexto.",
                        "specificSkills": [
                          {
                            "id": "10.1.4.4.3.1",
                            "name": "Gerar mensagens de erro informativas",
                            "description": "Construir mensagens claras com linha, coluna, tipo de erro e contexto da tabela de símbolos, como 'Tipo incompatível: esperado int, encontrado float na linha 42'.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Identificar e Documentar Componentes Essenciais de uma Mensagem de Erro Informativa",
                                  "subSteps": [
                                    "Analise exemplos reais de mensagens de erro semânticos de compiladores como GCC ou LLVM.",
                                    "Liste os componentes obrigatórios: tipo de erro, valor esperado vs encontrado, linha e coluna, e contexto da tabela de símbolos.",
                                    "Estude a tabela de símbolos: identifique entradas relevantes como tipo declarado da variável e escopo.",
                                    "Crie um diagrama ou tabela mapeando esses componentes para o exemplo dado: 'Tipo incompatível: esperado int, encontrado float na linha 42'.",
                                    "Defina regras para priorizar informações: localização primeiro, depois detalhes técnicos."
                                  ],
                                  "verification": "Escreva uma lista numerada com os 5 componentes essenciais e forneça um exemplo preenchido para um erro hipotético.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Documentação de GCC/Clang",
                                    "Exemplos de código com erros semânticos",
                                    "Papel ou editor de texto para diagrama"
                                  ],
                                  "tips": "Use cores ou negrito para destacar componentes no diagrama para melhor visualização.",
                                  "learningObjective": "Compreender e catalogar os elementos fundamentais que tornam uma mensagem de erro clara e acionável.",
                                  "commonMistakes": [
                                    "Ignorar a tabela de símbolos",
                                    "Confundir linha com coluna",
                                    "Listar componentes sem exemplos concretos"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Capturar Metadados do Erro Durante a Análise Semântica",
                                  "subSteps": [
                                    "Implemente funções para registrar linha e coluna no nó AST (Abstract Syntax Tree) onde o erro ocorre.",
                                    "Crie uma estrutura de dados para erros: {tipo: string, esperado: string, encontrado: string, linha: int, coluna: int, simbolo: object}.",
                                    "Integre captura automática de tipos da tabela de símbolos usando chaves como nome da variável e escopo.",
                                    "Teste captura com um código simples: var x: int; x = 3.14; (erro na atribuição linha 2, col 5).",
                                    "Adicione validação para metadados incompletos, gerando fallback genérico."
                                  ],
                                  "verification": "Execute um parser simples e demonstre captura correta de metadados para pelo menos 2 erros diferentes.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Editor de código (VSCode ou similar)",
                                    "Biblioteca de parsing como ANTLR ou código-fonte de um mini-compilador",
                                    "Exemplos de AST"
                                  ],
                                  "tips": "Use logging intermediário para depurar captura de metadados antes de formatar.",
                                  "learningObjective": "Desenvolver código para coletar precisamente todos os dados necessários do contexto de erro.",
                                  "commonMistakes": [
                                    "Capturar linha errada (do token anterior)",
                                    "Não consultar tabela de símbolos corretamente",
                                    "Ignorar offset de coluna em expressões compostas"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Consultar Tabela de Símbolos e Construir Contexto Relevante",
                                  "subSteps": [
                                    "Implemente uma função de lookup na tabela de símbolos por nome e escopo atual.",
                                    "Extraia contexto: tipo declarado, valor atual, histórico de declarações relacionadas.",
                                    "Formule frases contextuais: 'Variável 'x' declarada como int na linha 1, mas atribuída float aqui'.",
                                    "Combine com metadados: tipoErro + esperado/encontrado + contexto + localização.",
                                    "Refine para brevidade: limite a 1-2 linhas, evitando jargão desnecessário."
                                  ],
                                  "verification": "Para um símbolo dado, gere manualmente o contexto e valide contra tabela simulada.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Estrutura de tabela de símbolos simulada em JSON",
                                    "Código do passo 2",
                                    "Ferramentas de debug como console.log"
                                  ],
                                  "tips": "Priorize o símbolo mais próximo no escopo para contexto relevante.",
                                  "learningObjective": "Integrar tabela de símbolos para enriquecer mensagens com dados semânticos acionáveis.",
                                  "commonMistakes": [
                                    "Lookup em escopo errado",
                                    "Incluir contexto irrelevante (ex: símbolos não relacionados)",
                                    "Frases muito longas ou técnicas"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Formatar, Gerar e Validar a Mensagem Final",
                                  "subSteps": [
                                    "Crie um template string: '{tipoErro}: esperado {esperado}, encontrado {encontrado} [{contexto}] na linha {linha}, coluna {coluna}'.",
                                    "Implemente função geradora que recebe estrutura de erro e retorna string formatada.",
                                    "Teste com 3 cenários: tipo incompatível, variável não declarada, escopo incorreto.",
                                    "Valide clareza: leia em voz alta e verifique se um iniciante entenderia a correção.",
                                    "Adicione recuperação: sugira fixes como 'Converta para int com cast'."
                                  ],
                                  "verification": "Gere mensagens para 3 códigos de teste e confirme que todas incluem todos os componentes.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Código dos passos anteriores",
                                    "3 arquivos de teste com erros semânticos",
                                    "Checklist de validação"
                                  ],
                                  "tips": "Use cores ANSI no terminal para destacar localização na mensagem.",
                                  "learningObjective": "Montar e refinar mensagens completas, prontas para uso em compiladores.",
                                  "commonMistakes": [
                                    "Template rígido sem flexibilidade",
                                    "Omitir sugestões de fix",
                                    "Erros de formatação como aspas mal colocadas"
                                  ]
                                }
                              ],
                              "practicalExample": "Código de teste: linha 1: int x; linha 2: x = 3.14; Tabela de símbolos: {x: {tipo: 'int', escopo: global}}. Mensagem gerada: 'Tipo incompatível: esperado int, encontrado float para variável x (declarada como int na linha 1) na linha 2, coluna 5. Sugestão: use cast (int)3.14.'",
                              "finalVerifications": [
                                "Construa uma mensagem completa para um erro semântico dado em código fonte.",
                                "Identifique todos os 5 componentes em uma mensagem existente de compilador.",
                                "Implemente e teste a função geradora em um mini-parser.",
                                "Explique como a tabela de símbolos melhora a mensagem.",
                                "Gere mensagens para 3 tipos diferentes de erros semânticos.",
                                "Valide se mensagens são < 100 caracteres e acionáveis."
                              ],
                              "assessmentCriteria": [
                                "Mensagem inclui linha, coluna, tipo esperado/encontrado e contexto de símbolo.",
                                "Clareza: linguagem simples, sem ambiguidades para programadores iniciantes.",
                                "Precisão: metadados corretos do AST e tabela de símbolos.",
                                "Concisão: mensagem útil em 1-2 linhas com sugestão de fix opcional.",
                                "Consistência: formato uniforme para múltiplos erros.",
                                "Utilidade: permite correção rápida sem busca adicional."
                              ],
                              "crossCurricularConnections": [
                                "Comunicação Técnica: redação clara e persuasiva em relatórios de erro.",
                                "Design de UX: princípios de feedback amigável em ferramentas de software.",
                                "Lógica e Estruturas de Dados: uso eficiente de tabelas hash para símbolos.",
                                "Testes de Software: validação de mensagens em cenários de erro.",
                                "Inglês Técnico: padrões de phrasing em documentação de programação."
                              ],
                              "realWorldApplication": "Em compiladores como GCC, Rustc ou TypeScript, onde mensagens de erro semânticos guiam desenvolvedores a fixes rápidos, reduzindo tempo de debug em IDEs como VSCode ou IntelliJ, e em linters como pylint para Python."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.4.4.3.2",
                            "name": "Implementar recuperação de erros via modo pânico",
                            "description": "Ao detectar um erro semântico, pular até o próximo ponto de sincronização (como fim de declaração ou bloco) para continuar a análise sem abortar.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Definir pontos de sincronização no parser",
                                  "subSteps": [
                                    "Analise a gramática da linguagem e identifique tokens de sincronização comuns, como ';', '}', ')', 'EOF'.",
                                    "Crie uma lista ou conjunto de tokens sincronizadores no código do parser.",
                                    "Implemente uma função auxiliar que verifica se um token é um ponto de sincronização.",
                                    "Teste a função com exemplos de tokens válidos e inválidos.",
                                    "Documente os pontos escolhidos e justifique sua seleção."
                                  ],
                                  "verification": "Execute testes unitários na função de verificação de sincronização e confirme que retorna true apenas para tokens corretos.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Código fonte do parser, documentação da gramática da linguagem, ambiente de desenvolvimento (IDE como VS Code ou IntelliJ).",
                                  "tips": "Priorize pontos de sincronização que fechem escopos para minimizar perda de contexto.",
                                  "learningObjective": "Compreender e mapear estruturas sintáticas para recuperação eficiente de erros.",
                                  "commonMistakes": "Escolher pontos muito granulares que causem loops infinitos ou perda excessiva de código."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Detectar erros semânticos e ativar modo pânico",
                                  "subSteps": [
                                    "Identifique locais no analisador semântico onde erros são detectados (ex: variável não declarada).",
                                    "Adicione uma flag booleana 'panicMode' no estado do parser.",
                                    "Ao detectar erro, defina panicMode = true e reporte o erro.",
                                    "Modifique a lógica de lookahead para ignorar certas verificações enquanto em panicMode.",
                                    "Registre logs ou contadores para monitorar ativações do modo pânico."
                                  ],
                                  "verification": "Insira um erro semântico manualmente e verifique se panicMode é ativado via depurador ou logs.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Código do analisador semântico, depurador (GDB ou debugger da IDE), exemplos de código com erros semânticos.",
                                  "tips": "Use asserts ou breakpoints para pausar na detecção de erro e inspecionar o estado.",
                                  "learningObjective": "Implementar detecção condicional de erros com transição de estado no parser.",
                                  "commonMistakes": "Não resetar panicMode corretamente, causando análise incorreta em códigos válidos subsequentes."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar pulo para ponto de sincronização",
                                  "subSteps": [
                                    "No loop principal do parser, verifique se panicMode está ativo.",
                                    "Se sim, consuma tokens até encontrar um ponto de sincronização.",
                                    "Pule construções sintáticas incompletas sem processá-las.",
                                    "Ao encontrar sincronizador, consuma-o e defina panicMode = false.",
                                    "Adicione tratamento para evitar loops infinitos (ex: limite de tokens consumidos)."
                                  ],
                                  "verification": "Compile um código com erro semântico e confirme que o parser pula corretamente até o sincronizador sem crash.",
                                  "estimatedTime": "75 minutos",
                                  "materials": "Parser recursivo descendente ou tabela-based, lexer/tokenizer, conjunto de testes com erros.",
                                  "tips": "Visualize o fluxo de tokens com impressões para depurar o consumo durante pânico.",
                                  "learningObjective": "Criar lógica de recuperação que resincronize o parser sem perder o contexto global.",
                                  "commonMistakes": "Consumir sincronizadores em contextos normais, quebrando parsing de códigos válidos."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Testar, depurar e integrar reporte de erros",
                                  "subSteps": [
                                    "Crie suíte de testes com erros semânticos em diferentes posições (início, meio, fim de bloco).",
                                    "Execute testes e verifique se múltiplos erros são reportados sem abortar.",
                                    "Depure casos onde recuperação falha (ex: nested blocks).",
                                    "Integre com sistema de reporte: liste erros com posições e sugestões.",
                                    "Meça eficácia: taxa de recuperação e falsos positivos."
                                  ],
                                  "verification": "Todos os testes passam: parser completa análise, reporta erros corretos e gera AST parcial utilizável.",
                                  "estimatedTime": "90 minutos",
                                  "materials": "Framework de testes (JUnit, pytest), códigos de teste artificiais com erros, ferramentas de profiling.",
                                  "tips": "Use códigos reais de linguagens como C ou mini-linguagens para testes realistas.",
                                  "learningObjective": "Validar implementação através de testes abrangentes e otimizar usabilidade.",
                                  "commonMistakes": "Ignorar erros em escopos aninhados, levando a recuperação incompleta."
                                }
                              ],
                              "practicalExample": "Em um parser para uma mini-linguagem similar a C, código com erro: 'int x = undeclared_var + 5;' Deve reportar 'undeclared_var não declarada', pular até ';', continuar parsing funções subsequentes sem abortar.",
                              "finalVerifications": [
                                "Parser detecta erro semântico e ativa modo pânico corretamente.",
                                "Consumo de tokens até sincronizador sem loops infinitos.",
                                "Desativação do modo pânico após sincronização.",
                                "Reporte de erro com posição precisa (linha/coluna).",
                                "Análise continua para o resto do código com múltiplos erros.",
                                "Geração de AST parcial sem crashes."
                              ],
                              "assessmentCriteria": [
                                "Precisão na detecção e ativação do modo pânico (100% nos testes).",
                                "Eficiência de recuperação: consome <20 tokens extras por erro.",
                                "Robustez: lida com 5+ erros consecutivos sem falha.",
                                "Clareza do código: funções modulares e bem documentadas.",
                                "Relatórios de erro informativos e não duplicados.",
                                "Integração seamless com parsing normal."
                              ],
                              "crossCurricularConnections": [
                                "Engenharia de Software: Princípios de resiliência e fault-tolerance em sistemas.",
                                "Teoria da Computação: Autômatos e recuperação em parsers LL/LR.",
                                "Programação Funcional: Uso de estados monádicos para gerenciar panicMode.",
                                "Análise de Algoritmos: Otimização de lookahead em parsing."
                              ],
                              "realWorldApplication": "Em compiladores como GCC ou Clang, modo pânico permite diagnósticos múltiplos em códigos com erros, acelerando desenvolvimento ao mostrar todos os problemas de uma vez, em vez de parar no primeiro."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.4.4.3.3",
                            "name": "Estratégias de recuperação baseadas em frases",
                            "description": "Usar tabelas de símbolos para inserir temporariamente símbolos ausentes ou ajustar tipos durante a recuperação, minimizando falsos positivos em erros subsequentes.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o papel da tabela de símbolos na análise semântica",
                                  "subSteps": [
                                    "Estude a estrutura básica de uma tabela de símbolos, incluindo entradas para variáveis, tipos e escopos.",
                                    "Analise como a tabela é populada durante a análise semântica em compiladores.",
                                    "Identifique cenários comuns onde erros semânticos ocorrem, como variáveis indefinidas ou incompatibilidades de tipo.",
                                    "Revise exemplos de código fonte com erros semânticos para mapear impactos na tabela de símbolos.",
                                    "Pratique consultando e atualizando uma tabela de símbolos simulada manualmente."
                                  ],
                                  "verification": "Crie um diagrama da tabela de símbolos antes e depois de um erro semântico detectado.",
                                  "estimatedTime": "45 minutes",
                                  "materials": [
                                    "Livro de compiladores (ex: Dragon Book)",
                                    "Editor de código",
                                    "Papel e caneta para diagramas"
                                  ],
                                  "tips": "Sempre mantenha rastreamento de escopos para evitar confusões em tabelas aninhadas.",
                                  "learningObjective": "Entender como a tabela de símbolos suporta detecção e recuperação de erros semânticos.",
                                  "commonMistakes": [
                                    "Ignorar escopos hierárquicos",
                                    "Não diferenciar declarações de usos"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar erros recuperáveis baseados em frases",
                                  "subSteps": [
                                    "Classifique erros semânticos como ausência de símbolo ou mismatch de tipo em contextos fraseológicos.",
                                    "Defina critérios para 'recuperáveis': erros locais que não quebram o parsing global.",
                                    "Simule detecção de erros em um compilador toy, focando em frases como declarações ou atribuições.",
                                    "Registre o estado da tabela de símbolos no momento do erro.",
                                    "Priorize erros que minimizem cascata, como inserções temporárias."
                                  ],
                                  "verification": "Liste 3 exemplos de erros recuperáveis com frases afetadas e estado da symtab.",
                                  "estimatedTime": "30 minutes",
                                  "materials": [
                                    "Compilador toy (ex: implementado em Python)",
                                    "Exemplos de código com erros semânticos"
                                  ],
                                  "tips": "Use logging para capturar o estado exato da symtab durante detecção.",
                                  "learningObjective": "Reconhecer oportunidades de recuperação semântica usando contexto fraseológico.",
                                  "commonMistakes": [
                                    "Confundir erros sintáticos com semânticos",
                                    "Sobrestimar impacto de erros locais"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar inserção ou ajuste temporário na tabela de símbolos",
                                  "subSteps": [
                                    "Crie funções para inserir símbolo temporário (ex: flag 'temp_recovery') na symtab.",
                                    "Desenvolva lógica para ajustar tipos temporariamente, como promover a 'any' ou inferir contexto.",
                                    "Integre a recuperação na fase semântica do compilador, aplicando apenas em erros recuperáveis.",
                                    "Garanta que alterações sejam marcadas para remoção pós-análise da frase.",
                                    "Teste com código fonte contendo múltiplos erros para validar não-cascata."
                                  ],
                                  "verification": "Execute compilador em código com erros e confirme que symtab é alterada temporariamente sem falsos positivos.",
                                  "estimatedTime": "60 minutes",
                                  "materials": [
                                    "Código fonte do compilador toy",
                                    "IDE com debugger",
                                    "Exemplos de testes unitários"
                                  ],
                                  "tips": "Use transações na symtab (push/pop) para isolar mudanças temporárias.",
                                  "learningObjective": "Aplicar modificações atômicas na symtab para recuperação de erros semânticos.",
                                  "commonMistakes": [
                                    "Não marcar entradas como temporárias",
                                    "Alterar symtab globalmente"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Avaliar e otimizar para minimizar falsos positivos",
                                  "subSteps": [
                                    "Colete métricas: número de erros reportados vs. falsos positivos induzidos.",
                                    "Compare recuperação com e sem estratégia em benchmarks de código com erros.",
                                    "Refine heurísticas baseadas em frequência de frases (ex: priorize declarações sobre expressões).",
                                    "Implemente limpeza pós-frase para restaurar symtab original.",
                                    "Documente lições aprendidas e itere na implementação."
                                  ],
                                  "verification": "Gere relatório mostrando redução de falsos positivos em pelo menos 50% dos casos testados.",
                                  "estimatedTime": "45 minutes",
                                  "materials": [
                                    "Scripts de benchmark",
                                    "Ferramentas de profiling",
                                    "Relatórios de erros gerados"
                                  ],
                                  "tips": "Automatize testes com conjuntos de código mutados para erros semânticos.",
                                  "learningObjective": "Medir eficácia da recuperação e iterar para precisão.",
                                  "commonMistakes": [
                                    "Ignorar limpeza de symtab",
                                    "Não benchmarkar múltiplos cenários"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um compilador para uma linguagem simples, ao encontrar 'x = 5;' onde 'x' não está na symtab, insira temporariamente 'x' como int na symtab com flag recovery, continue analisando a frase, reporte o erro, e remova após a frase para evitar falsos positivos em usos subsequentes de 'x'.",
                              "finalVerifications": [
                                "Tabela de símbolos é corretamente modificada e restaurada após recuperação.",
                                "Número de falsos positivos é minimizado em testes com múltiplos erros.",
                                "Compilador continua reportando erros subsequentes sem cascata.",
                                "Estratégia funciona em pelo menos 80% dos cenários fraseológicos testados.",
                                "Logs mostram inserções/ajustes temporários isolados por frase.",
                                "Benchmark confirma performance aceitável (overhead <20%)."
                              ],
                              "assessmentCriteria": [
                                "Precisão na detecção de erros recuperáveis (90%+).",
                                "Eficácia na minimização de falsos positivos (redução >50%).",
                                "Corretude na manipulação da symtab (sem vazamentos).",
                                "Clareza e modularidade do código de implementação.",
                                "Cobertura de testes em cenários fraseológicos variados.",
                                "Documentação de heurísticas e limitações."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria de grafos para modelagem de dependências na symtab.",
                                "Lógica e Algoritmos: Heurísticas de busca para inserções ótimas.",
                                "Engenharia de Software: Padrões de design para transações em estruturas de dados.",
                                "Inteligência Artificial: Inferência de tipos similar a sistemas especialistas."
                              ],
                              "realWorldApplication": "Em compiladores reais como GCC ou Clang, estratégias semelhantes permitem diagnósticos precisos em código buggy, ajudando desenvolvedores a corrigir múltiplos erros sem sobrecarga de mensagens falsas, acelerando o ciclo de desenvolvimento de software."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      }
                    ]
                  }
                ]
              },
              {
                "id": "10.1.5",
                "name": "Análise Semântica",
                "description": "Verificação do significado e contexto das construções sintáticas, incluindo verificação de tipos e escopo.",
                "totalSkills": 40,
                "atomicTopics": [
                  {
                    "id": "10.1.5.1",
                    "name": "Verificação de Tipos",
                    "description": "Verificação da compatibilidade e correção de tipos em expressões, declarações e atribuições.",
                    "individualConcepts": [
                      {
                        "id": "10.1.5.1.1",
                        "name": "Verificação de Tipos em Declarações",
                        "description": "Processo de análise semântica que verifica a validade e consistência dos tipos declarados para variáveis, funções e estruturas de dados, incluindo detecção de declarações duplicadas e tipos indefinidos.",
                        "specificSkills": [
                          {
                            "id": "10.1.5.1.1.1",
                            "name": "Identificar tipos válidos em declarações",
                            "description": "Reconhecer e validar declarações de variáveis e funções com tipos primitivos (int, float, string) e compostos (arrays, structs), consultando a tabela de símbolos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os tipos primitivos e compostos suportados",
                                  "subSteps": [
                                    "Liste os tipos primitivos: int (inteiro), float (ponto flutuante) e string (texto)",
                                    "Descreva tipos compostos: arrays (ex: array<int>) e structs (ex: struct Ponto {int x; float y;})",
                                    "Identifique regras de composição: arrays podem conter primitivos ou structs; structs definem campos tipados",
                                    "Exemplifique declarações válidas: int x; array<string> nomes; struct Pessoa {string nome; int idade;}",
                                    "Diferencie tipos válidos de inválidos: array<void> é inválido"
                                  ],
                                  "verification": "Crie uma tabela resumindo 5 tipos válidos e 3 inválidos, explicando por quê",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Documentação da linguagem de programação ou especificação do compilador; papel e caneta para tabela",
                                  "tips": "Use mnemônicos: 'IFS' para primitivos (Int, Float, String)",
                                  "learningObjective": "Dominar a hierarquia e regras de validade dos tipos suportados",
                                  "commonMistakes": "Confundir float com int em precisão; ignorar que structs precisam de campos tipados"
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Construir e consultar a tabela de símbolos",
                                  "subSteps": [
                                    "Defina a estrutura da tabela: colunas para nome, tipo, escopo e atributos (ex: tamanho para arrays)",
                                    "Simule inserção: ao declarar 'int x', insira {nome: 'x', tipo: 'int'}",
                                    "Pratique lookup: para uma declaração, busque pelo nome na tabela atual (escopo)",
                                    "Gerencie escopos: tabelas aninhadas para blocos ou funções",
                                    "Trate colisões: erro se nome já existe no escopo"
                                  ],
                                  "verification": "Construa uma tabela de símbolos para um código com 3 declarações e realize 2 lookups corretos",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Planilha ou editor de texto para simular tabela; exemplo de código fonte",
                                  "tips": "Sempre verifique escopo primeiro: global > local",
                                  "learningObjective": "Implementar operações básicas de inserção e consulta na tabela de símbolos",
                                  "commonMistakes": "Ignorar escopos, causando lookup em tabela errada; inserir sem validar tipo"
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Validar declarações de variáveis",
                                  "subSteps": [
                                    "Parse a declaração: identifique nome, tipo explícito ou inferido (ex: array<int> lista[10])",
                                    "Lookup na tabela: verifique se tipo base existe (ex: 'int' para array<int>)",
                                    "Valide composição: para array, tipo elemento válido?; para struct, todos campos tipados corretamente?",
                                    "Cheque duplicatas: nome já declarado no escopo?",
                                    "Registre resultado: válido (insira) ou erro semântico (ex: 'tipo desconhecido')"
                                  ],
                                  "verification": "Analise 5 declarações de variáveis, marcando válidas/inválidas com justificativa",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Código de exemplo com variáveis; tabela de símbolos simulada",
                                  "tips": "Separe parse sintático (já feito) do semântico (tipos)",
                                  "learningObjective": "Aplicar tabela de símbolos para validar tipos em variáveis",
                                  "commonMistakes": "Não validar tipos recursivos em arrays/structs; confundir inicialização com declaração"
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Validar declarações de funções",
                                  "subSteps": [
                                    "Parse assinatura: nome, lista de parâmetros (nome:tipo), tipo de retorno",
                                    "Valide parâmetros: cada tipo válido? duplicatas de nome?",
                                    "Lookup função: overload permitido? assinatura única?",
                                    "Cheque retorno: tipo válido na tabela?",
                                    "Insira na tabela: {nome, params: [...], retorno: tipo}"
                                  ],
                                  "verification": "Valide 4 declarações de funções, simulando inserções e detectando 2 erros",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Exemplos de funções em código; tabela de símbolos estendida",
                                  "tips": "Compare assinaturas completas para overload: int f(int) vs int f(float)",
                                  "learningObjective": "Estender validação de tipos para funções com parâmetros e retorno",
                                  "commonMistakes": "Ignorar tipos de parâmetros; permitir assinaturas idênticas"
                                }
                              ],
                              "practicalExample": "Código: struct Cor {int r; float g;}; int main() { int x; array<Cor> cores[5]; string msg; func soma(int a, float b): int { return a+b; } } Validação: Todas declarações válidas. Tabela: x:int, cores:array<struct Cor>, msg:string, soma:func(params:[int,float],ret:int). Erro exemplo: array<void> invalido -> 'tipo void não suportado'.",
                              "finalVerifications": [
                                "Lista corretamente todos primitivos e dá exemplos de compostos válidos",
                                "Simula tabela de símbolos com pelo menos 5 entradas e 3 lookups",
                                "Valida 10 declarações de variáveis sem erros",
                                "Valida 5 declarações de funções, detectando overload inválido",
                                "Explica 3 erros semânticos comuns em tipos",
                                "Integra validação em fluxo de análise semântica"
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de tipos válidos/inválidos (90%+ correto)",
                                "Uso correto da tabela de símbolos em todos steps",
                                "Detalhamento de subSteps com pelo menos 4 itens por step",
                                "Identificação de erros comuns e soluções",
                                "Tempo total de execução dentro de 2 horas",
                                "Explicações claras e exemplos concretos"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria de conjuntos para tipos compostos (arrays como conjuntos indexados)",
                                "Lógica: Validações booleanas e árvores de decisão para fluxos de erro",
                                "Programação Geral: Tipagem estática em linguagens como C++ ou Rust",
                                "Banco de Dados: Tabelas de metadados semelhantes a esquemas relacionais"
                              ],
                              "realWorldApplication": "Em compiladores profissionais como GCC ou Clang, essa verificação previne erros em tempo de compilação, otimizando código e evitando falhas em runtime, essencial em desenvolvimento de software embarcado ou sistemas críticos onde tipos incorretos causam crashes caros."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.1.1.2",
                            "name": "Detectar declarações duplicadas",
                            "description": "Implementar verificação para evitar redeclarações de identificadores no mesmo escopo, reportando erros semânticos apropriados.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender Conceitos de Escopo e Declarações Duplicadas",
                                  "subSteps": [
                                    "Estude a definição de escopo em linguagens de programação (global, local, blocos).",
                                    "Identifique exemplos de declarações duplicadas em diferentes escopos usando uma linguagem simples como uma mini-linguagem de exemplo.",
                                    "Analise o impacto semântico de redeclarações: shadowing vs. erro.",
                                    "Revise regras da linguagem-alvo para redeclarações permitidas ou proibidas.",
                                    "Crie um fluxograma mental de quando uma declaração é considerada duplicada."
                                  ],
                                  "verification": "Resuma em um parágrafo os tipos de escopo e forneça 3 exemplos de código com duplicatas destacadas.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Documentação da linguagem-alvo, exemplos de código fonte, diagrama de escopos.",
                                  "tips": "Use um editor de texto para anotar códigos de exemplo e destacar identificadores.",
                                  "learningObjective": "Dominar os fundamentos teóricos de escopos e redeclarações para basear a implementação.",
                                  "commonMistakes": "Confundir shadowing com duplicação real; ignorar escopos aninhados."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Projetar Estrutura de Tabela de Símbolos para Rastreamento",
                                  "subSteps": [
                                    "Escolha uma estrutura de dados (hash map ou árvore) para armazenar identificadores por escopo.",
                                    "Defina chaves compostas: (escopo_id, nome_identificador).",
                                    "Implemente entrada na tabela ao processar declarações.",
                                    "Planeje consultas para checar existência antes de inserir.",
                                    "Considere pilha de escopos para handling de blocos aninhados."
                                  ],
                                  "verification": "Desenhe um diagrama da tabela de símbolos com exemplo de 2 escopos aninhados e uma duplicata.",
                                  "estimatedTime": "1 hora",
                                  "materials": "Ferramenta de diagramação (Draw.io), pseudocódigo para tabela de símbolos.",
                                  "tips": "Comece com uma implementação simples em Python para prototipar a tabela antes de integrar ao compilador.",
                                  "learningObjective": "Projetar uma tabela de símbolos eficiente para detecção de duplicatas em escopos.",
                                  "commonMistakes": "Não considerar escopos aninhados; usar chaves inadequadas que ignorem escopo."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar Lógica de Detecção na Análise Semântica",
                                  "subSteps": [
                                    "No visitor ou walker semântico, ao encontrar uma declaração, consulte a tabela atual do escopo.",
                                    "Se identificador existir no escopo atual, sinalize erro semântico.",
                                    "Empilhe/despilhe escopos ao entrar/sair de blocos.",
                                    "Insira apenas se não duplicado.",
                                    "Passe o contexto (posição no código) para relatório preciso."
                                  ],
                                  "verification": "Adicione prints ou logs para rastrear consultas e insersões durante parsing de um exemplo.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": "Código fonte do compilador/analisador semântico, debugger.",
                                  "tips": "Use breakpoints no debugger para observar o estado da tabela em tempo real.",
                                  "learningObjective": "Codificar a detecção integrada ao fluxo de análise semântica.",
                                  "commonMistakes": "Checar escopos errados (ex: globais em vez de locais); falhar em despilhar escopos."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Reportar Erros Semânticos e Integrar ao Compilador",
                                  "subSteps": [
                                    "Crie uma classe ou função para erros semânticos com mensagem: 'Redeclaração de [id] no escopo atual'.",
                                    "Inclua linha/coluna do código fonte na mensagem.",
                                    "Pare a compilação ou colete todos os erros antes de reportar.",
                                    "Teste integração com fases anteriores (léxico/sintático).",
                                    "Adicione flags opcionais para warnings em vez de erros."
                                  ],
                                  "verification": "Compile um código com duplicata e verifique se o erro é reportado corretamente sem crash.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Exemplos de código com erros intencionais, sistema de logging do compilador.",
                                  "tips": "Formate mensagens de erro amigáveis, inspiradas em compiladores como GCC.",
                                  "learningObjective": "Gerar relatórios de erros claros e úteis para desenvolvedores.",
                                  "commonMistakes": "Mensagens vagas sem localização; continuar compilação após erros fatais."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Testar e Validar a Implementação",
                                  "subSteps": [
                                    "Crie suíte de testes: duplicata local, global, aninhada, shadowing permitido.",
                                    "Teste casos edge: escopos vazios, identificadores case-sensitive.",
                                    "Meça cobertura com ferramenta de profiling.",
                                    "Corrija bugs baseados em falhas de teste.",
                                    "Documente testes em README."
                                  ],
                                  "verification": "Execute todos os testes e confirme 100% pass com relatório de cobertura >90%.",
                                  "estimatedTime": "1 hora",
                                  "materials": "Framework de testes (JUnit/Pytest), códigos de teste variados.",
                                  "tips": "Automatize testes com scripts para regressão rápida.",
                                  "learningObjective": "Garantir robustez da detecção através de testes abrangentes.",
                                  "commonMistakes": "Testes insuficientes para edge cases; ignorar sensibilidade a maiúsculas/minúsculas."
                                }
                              ],
                              "practicalExample": "Em uma mini-linguagem: 'int x; { int x; }' – Ao processar a segunda 'int x;', a tabela de símbolos do escopo local detecta duplicata e reporta: 'Erro semântico na linha 2: Redeclaração de identificador \"x\" no escopo local.' O compilador para sem gerar código.",
                              "finalVerifications": [
                                "Tabela de símbolos rastreia corretamente identificadores por escopo.",
                                "Declarações duplicadas no mesmo escopo geram erro semântico preciso.",
                                "Escopos aninhados não interferem indevidamente.",
                                "Código sem duplicatas passa na análise sem erros.",
                                "Mensagens de erro incluem localização exata no fonte.",
                                "Testes cobrem 100% dos casos positivos e negativos."
                              ],
                              "assessmentCriteria": [
                                "Precisão na detecção: zero falsos positivos/negativos em testes.",
                                "Eficiência: O(1) médio para consultas na tabela.",
                                "Clareza de erros: mensagens legíveis com contexto.",
                                "Integração: não quebra fases prévias do compilador.",
                                "Robustez: lida com escopos profundos sem stack overflow.",
                                "Documentação: comentários e testes bem explicados."
                              ],
                              "crossCurricularConnections": [
                                "Estruturas de Dados: uso de hash maps e pilhas para escopos.",
                                "Lógica e Algoritmos: detecção de duplicatas como problema de busca.",
                                "Engenharia de Software: testes unitários e relatórios de erros.",
                                "Teoria da Computação: análise semântica em autômatos.",
                                "Design de Linguagens: regras de escopo em PLs reais."
                              ],
                              "realWorldApplication": "Compiladores como GCC/Clang usam essa verificação para prevenir bugs em C/C++; IDEs como VSCode IntelliSense alertam redeclarações em tempo real, evitando erros em software de produção como sistemas operacionais."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.1.1.3",
                            "name": "Verificar escopos e tipos em blocos",
                            "description": "Analisar declarações dentro de blocos condicionais e de repetição, respeitando regras de escopo e propagando tipos para tabelas de símbolos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender conceitos de escopo e blocos em análise semântica",
                                  "subSteps": [
                                    "Estude as regras de escopo léxico em linguagens de programação.",
                                    "Identifique tipos de blocos: condicionais (if, else) e de repetição (while, for).",
                                    "Revise a estrutura da tabela de símbolos e como ela armazena tipos e escopos.",
                                    "Analise exemplos de shadowing de variáveis em blocos aninhados.",
                                    "Diferencie escopo local de blocos de escopo global."
                                  ],
                                  "verification": "Resuma em um diagrama como o escopo muda em um bloco if aninhado.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Documentação de compiladores (ex: Dragon Book)",
                                    "Exemplos de código em C ou Pascal"
                                  ],
                                  "tips": "Use diagramas de pilha para visualizar escopos aninhados.",
                                  "learningObjective": "Entender como escopos isolam declarações e propagam tipos localmente.",
                                  "commonMistakes": "Confundir escopo dinâmico com léxico; ignorar aninhamento."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar entrada em novo escopo ao iniciar bloco",
                                  "subSteps": [
                                    "Crie uma nova camada na tabela de símbolos ao encontrar '{' ou início de bloco.",
                                    "Salve o escopo pai como referência para restauração posterior.",
                                    "Inicialize a tabela local vazia para declarações no bloco.",
                                    "Propague tipos de parâmetros ou condições do bloco (ex: tipo da condição if).",
                                    "Registre metadados do bloco (tipo: condicional ou repetição)."
                                  ],
                                  "verification": "Teste com código simples: insira bloco e confirme nova camada na tabela.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Implementação de tabela de símbolos em pseudocódigo",
                                    "Editor de código ou Jupyter Notebook"
                                  ],
                                  "tips": "Use uma pilha de hash maps para simular tabelas de símbolos.",
                                  "learningObjective": "Criar e ativar escopo local corretamente no início de blocos.",
                                  "commonMistakes": "Não salvar escopo pai, causando perda de variáveis externas."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Processar declarações e expressões dentro do bloco",
                                  "subSteps": [
                                    "Para cada declaração: verifique tipo, insira na tabela local se não shadow.",
                                    "Analise expressões: resolva símbolos na tabela local primeiro, depois pai.",
                                    "Verifique compatibilidade de tipos em atribuições e operações.",
                                    "Para repetições: garanta que tipos não mudem entre iterações.",
                                    "Registre warnings para declarações não usadas ou tipos incompatíveis."
                                  ],
                                  "verification": "Execute análise em código com declarações mistas e confira tabela populada.",
                                  "estimatedTime": "90 minutos",
                                  "materials": [
                                    "Parser gerado (ex: ANTLR)",
                                    "Exemplos de código com erros de tipo em blocos"
                                  ],
                                  "tips": "Implemente busca recursiva: local > pais até global.",
                                  "learningObjective": "Propagar e verificar tipos respeitando hierarquia de escopos.",
                                  "commonMistakes": "Buscar apenas no escopo global, ignorando locais."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Sair do escopo e realizar verificações finais do bloco",
                                  "subSteps": [
                                    "Ao encontrar '}', pop a tabela local e restaure escopo pai.",
                                    "Verifique variáveis locais não inicializadas ou sem uso.",
                                    "Confirme que tipos propagados não afetam escopo externo.",
                                    "Gere relatório de erros semânticos no bloco.",
                                    "Teste consistência em blocos aninhados múltiplos."
                                  ],
                                  "verification": "Simule saída de bloco e valide que escopo pai é restaurado corretamente.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Código de teste com blocos aninhados",
                                    "Ferramenta de debug de tabela de símbolos"
                                  ],
                                  "tips": "Automatize testes unitários para cada pop de escopo.",
                                  "learningObjective": "Gerenciar saída de escopo sem vazamentos ou perdas.",
                                  "commonMistakes": "Pop incorreto, deixando resíduos na tabela."
                                }
                              ],
                              "practicalExample": "Considere o código: if (x > 0) { int y = x + 1; string z = \"ok\"; } y deve ser int local, acessível só no if; z string local; ao sair, tabela volta ao escopo anterior sem y/z.",
                              "finalVerifications": [
                                "Tabela de símbolos reflete corretamente escopos aninhados.",
                                "Nenhum vazamento de variáveis locais para escopo externo.",
                                "Tipos de expressões em condições/loop são bool ou compatíveis.",
                                "Declarações dentro do bloco têm tipos propagados sem erros.",
                                "Shadowing é detectado e reportado se necessário.",
                                "Blocos vazios não geram camadas desnecessárias."
                              ],
                              "assessmentCriteria": [
                                "Precisão na criação e destruição de escopos (100% de casos testados).",
                                "Correta propagação de tipos em 95% das declarações.",
                                "Detecção de todos erros de shadowing e tipo incompatível.",
                                "Eficiência: tempo de análise O(n) para blocos.",
                                "Relatórios claros de erros semânticos.",
                                "Robustez em aninhamentos profundos (>5 níveis)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Árvores e grafos para representar escopos hierárquicos.",
                                "Lógica: Verificação de proposições em condições de blocos.",
                                "Linguagens Formais: Gramáticas livres de contexto para blocos.",
                                "Engenharia de Software: Gerenciamento de estado em analisadores."
                              ],
                              "realWorldApplication": "Em compiladores como GCC ou Clang, essa verificação previne erros em estruturas condicionais complexas de software embarcado ou aplicações web, garantindo portabilidade e debugabilidade."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.5.1.2",
                        "name": "Verificação de Tipos em Expressões",
                        "description": "Análise da compatibilidade de tipos entre operadores e operandos em expressões aritméticas, lógicas e relacionais, incluindo promoção e coerção de tipos.",
                        "specificSkills": [
                          {
                            "id": "10.1.5.1.2.1",
                            "name": "Aplicar regras de tipos para operadores binários",
                            "description": "Verificar se os operandos de operadores como +, -, *, / possuem tipos compatíveis, aplicando conversões implícitas quando permitido.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender as regras de tipos para operadores binários aritméticos",
                                  "subSteps": [
                                    "Estude as regras padrão para operadores +, -, *, / em linguagens tipadas como C ou Java.",
                                    "Identifique hierarquias de promoção de tipos: int -> long -> float -> double.",
                                    "Memorize casos de conversão implícita permitida (ex: int + float promove int para float).",
                                    "Liste operadores que requerem tipos exatos iguais (ex: == para structs).",
                                    "Revise regras para overflow ou underflow em promoções."
                                  ],
                                  "verification": "Liste corretamente 5 regras de promoção para operadores binários sem consultar materiais.",
                                  "estimatedTime": "20-30 minutos",
                                  "materials": [
                                    "Documentação de tipos da linguagem (ex: C99 spec, Java Language Spec)",
                                    "Tabela de promoção de tipos impressa"
                                  ],
                                  "tips": "Comece com operadores aritméticos básicos antes de lógicos ou bitwis.",
                                  "learningObjective": "Compreender as regras de compatibilidade e promoção de tipos para operadores binários.",
                                  "commonMistakes": [
                                    "Confundir promoção implícita com casting explícito.",
                                    "Ignorar que booleanos não promovem para numéricos.",
                                    "Esquecer que string + numérico pode concatenar em algumas linguagens."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar e extrair tipos dos operandos em uma expressão",
                                  "subSteps": [
                                    "Parseie a árvore sintática abstrata (AST) para localizar nós de operadores binários.",
                                    "Recupere o tipo de cada operando esquerdo e direito via tabela de símbolos.",
                                    "Registre tipos primitivos (int, float, etc.) e compostos (arrays, pointers).",
                                    "Anote tipos indefinidos ou forward references para tratamento posterior.",
                                    "Teste com expressões aninhadas como (a + b) * c."
                                  ],
                                  "verification": "Para uma expressão dada, extraia e liste tipos de todos os operandos corretamente.",
                                  "estimatedTime": "15-25 minutos",
                                  "materials": [
                                    "Exemplos de AST em ferramentas como Clang ou ANTLR",
                                    "Editor de código com highlighter de sintaxe"
                                  ],
                                  "tips": "Use walkers recursivos na AST para propagar tipos bottom-up.",
                                  "learningObjective": "Extrair tipos de operandos de forma precisa de expressões binárias.",
                                  "commonMistakes": [
                                    "Não resolver referências a variáveis não declaradas.",
                                    "Confundir tipo de literal (ex: 3.14 é double, não float).",
                                    "Ignorar qualificadores como const ou volatile."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Verificar compatibilidade e aplicar conversões implícitas",
                                  "subSteps": [
                                    "Compare tipos dos operandos usando a hierarquia de promoção.",
                                    "Aplique regra usual: ambos promovem ao tipo maior (ex: int + double -> double).",
                                    "Para tipos incompatíveis (ex: int + string), gere diagnóstico de erro.",
                                    "Atualize a AST com tipos promovidos nos nós de resultado.",
                                    "Valide exceções como pointer + int em C."
                                  ],
                                  "verification": "Transforme uma expressão inválida em erro e uma válida em tipos promovidos corretos.",
                                  "estimatedTime": "25-35 minutos",
                                  "materials": [
                                    "Compilador de referência (GCC com -Wall)",
                                    "Simulador de verificador de tipos online"
                                  ],
                                  "tips": "Implemente uma função de 'least upper bound' para tipos numéricos.",
                                  "learningObjective": "Aplicar regras de verificação e promoção de tipos automaticamente.",
                                  "commonMistakes": [
                                    "Permitir promoção inválida como struct + int.",
                                    "Não promover corretamente em operações compostas como +=.",
                                    "Esquecer divisões inteiras vs float."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Reportar erros e confirmar validade da expressão",
                                  "subSteps": [
                                    "Se incompatível, emita mensagem de erro com linha, coluna e tipos envolvidos.",
                                    "Para válida, atribua tipo final ao nó da expressão binária.",
                                    "Propague o tipo resultado para usos superiores na AST.",
                                    "Teste cenários edge como 0/0 ou null pointers.",
                                    "Integre com fluxo de análise semântica global."
                                  ],
                                  "verification": "Gere relatório correto para 3 expressões: válida, inválida e com promoção.",
                                  "estimatedTime": "20-30 minutos",
                                  "materials": [
                                    "Templates de mensagens de erro de compiladores",
                                    "Ferramenta de linting como ESLint para JS"
                                  ],
                                  "tips": "Faça mensagens de erro amigáveis: 'intélico incompatível com string em +'.",
                                  "learningObjective": "Finalizar verificação com feedback apropriado e atualização de tipos.",
                                  "commonMistakes": [
                                    "Erros genéricos sem contexto (tipos, posições).",
                                    "Não propagar tipos para expressões pais.",
                                    "Falsos positivos em casos de promoção válida."
                                  ]
                                }
                              ],
                              "practicalExample": "Em C: int x = 5; float y = 2.5; double z = x + y; // x promove para float, então para double; z recebe double. Se z fosse int, erro de truncamento.",
                              "finalVerifications": [
                                "Identifica corretamente promoção int + float -> float.",
                                "Detecta e rejeita int + string.",
                                "Atualiza AST com tipo promovido em expressões aninhadas.",
                                "Emite erro preciso para pointer + string.",
                                "Confirma validade de double - long.",
                                "Trata literais: 1 + 2.0 -> double."
                              ],
                              "assessmentCriteria": [
                                "Precisão na aplicação de regras de promoção (100% em testes).",
                                "Detecção correta de incompatibilidades sem falsos positivos.",
                                "Mensagens de erro claras e posicionadas.",
                                "Propagação correta de tipos na AST.",
                                "Eficiência em expressões complexas (sem recursão infinita).",
                                "Cobertura de edge cases como divisão por zero tipada."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Hierarquias de tipos semelhantes a conjuntos ordenados.",
                                "Lógica: Inferência de tipos como dedução automática.",
                                "Programação Geral: Type checking em IDEs e linters.",
                                "Engenharia de Software: Design de APIs tipadas seguras."
                              ],
                              "realWorldApplication": "Em compiladores como GCC/Clang para C/C++ ou Javac para Java, previne erros de runtime como perda de precisão em cálculos científicos ou crashes por tipos errados em apps de alta performance."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.1.2.2",
                            "name": "Tratar expressões unárias e sobrecarga",
                            "description": "Validar operadores unários (negativo, lógico) e detectar sobrecarga de funções com base em assinaturas de tipos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender operadores unários e suas regras de tipo",
                                  "subSteps": [
                                    "Estude os operadores unários comuns: unário negativo (-) para numéricos e lógico (! ) para booleanos.",
                                    "Analise regras de tipo: - aplica-se a int/float, ! a bool; rejeitar tipos incompatíveis.",
                                    "Revise sintaxe AST para expressões unárias: nó UnaryOp com operador e operando.",
                                    "Examine exemplos de código fonte com erros de tipo unário para identificar falhas semânticas.",
                                    "Documente uma tabela de compatibilidade de tipos para operadores unários."
                                  ],
                                  "verification": "Crie uma tabela de tipos compatíveis e teste com 3 exemplos de expressões unárias válidas/inválidas.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Documentação de linguagem de programação alvo (ex: C-like), diagrama AST, exemplos de código fonte.",
                                  "tips": "Sempre priorize promoção de tipo implícita antes da validação unária.",
                                  "learningObjective": "Identificar e listar regras de tipo para operadores unários negativos e lógicos.",
                                  "commonMistakes": "Confundir operador unário negativo com subtração binária; ignorar promoção de inteiros para float."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar validação de tipos para expressões unárias",
                                  "subSteps": [
                                    "Adicione função 'validateUnaryType' no visitor de análise semântica que recebe nó AST e tipo do operando.",
                                    "Implemente lógica condicional: se operador == '-', cheque se operando é numérico; se '!', cheque bool.",
                                    "Retorne tipo resultante: mesmo tipo do operando para - e bool para !.",
                                    "Gere erro semântico se incompatível, com mensagem detalhada incluindo tipo esperado vs. encontrado.",
                                    "Teste unitário com casos: válido (-5, !true), inválido (-'a', !5)."
                                  ],
                                  "verification": "Execute testes unitários passando sem erros em casos válidos e gerando erros corretos em inválidos.",
                                  "estimatedTime": "1 hora",
                                  "materials": "Código fonte do analisador semântico, framework de testes (JUnit/Pytest), exemplos AST serializados.",
                                  "tips": "Use recursão para inferir tipo do operando antes de validar o unário.",
                                  "learningObjective": "Codificar e testar validação automática de tipos unários no compilador.",
                                  "commonMistakes": "Não propagar o tipo resultante para o nó pai; falhar em tipos derivados como subclasses."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Estudar sobrecarga de funções e matching de assinaturas",
                                  "subSteps": [
                                    "Defina sobrecarga: múltiplas funções com mesmo nome, diferenciadas por número/tipos de parâmetros.",
                                    "Crie estrutura de assinatura: lista de tipos de parâmetros e tipo de retorno.",
                                    "Implemente algoritmo de matching: para chamada f(args), encontre assinatura exata ou com conversões implícitas.",
                                    "Ordene candidatos por especificidade: exata > promoção > varargs.",
                                    "Analise ambiguidades: se múltiplas matches perfeitas, reporte erro.",
                                    "Liste exemplos: int add(int,int) vs. double add(double,double)."
                                  ],
                                  "verification": "Construa uma tabela de 5 funções sobrecarregadas e simule matches para 4 chamadas variadas.",
                                  "estimatedTime": "50 minutos",
                                  "materials": "Especificação de sobrecarga da linguagem, exemplos de código com funções sobrecarregadas.",
                                  "tips": "Comece com matching exato antes de considerar conversões para eficiência.",
                                  "learningObjective": "Explicar e simular resolução de sobrecarga baseada em tipos de argumentos.",
                                  "commonMistakes": "Ignorar ordem dos parâmetros; permitir matches ambíguos sem erro."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Implementar detecção e resolução de sobrecarga em chamadas de função",
                                  "subSteps": [
                                    "No visitor semântico, para nó FunctionCall, colete tipos de argumentos via inferência recursiva.",
                                    "Busque no escopo símbolo da função e filtre lista de sobrecargas por matching de assinaturas.",
                                    "Selecione melhor match usando métrica de custo (0=exato, 1=conversão).",
                                    "Atribua tipo de retorno à chamada e valide operadores unários no retorno se aplicável.",
                                    "Integre com validação unária: ex. !add(1,2). Teste casos compostos.",
                                    "Adicione testes para sobrecarga com unários: -f(1.5)."
                                  ],
                                  "verification": "Testes unitários cobrindo 80% dos casos: match exato, promoção, ambiguidade, falha.",
                                  "estimatedTime": "1 hora 15 minutos",
                                  "materials": "Código do escopo/symbol table, AST walker, testes de integração.",
                                  "tips": "Cache matches para otimização em chamadas repetidas.",
                                  "learningObjective": "Integrar resolução de sobrecarga com verificação de tipos unários no fluxo semântico.",
                                  "commonMistakes": "Não inferir tipos de argumentos antes do matching; esquecer varargs como último recurso."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Testar e depurar integração completa",
                                  "subSteps": [
                                    "Compile programa teste com mix de unários e sobrecargas: ex. int x = -add(1,2); bool b = !max(3.0,true);",
                                    "Execute análise semântica e verifique tabela de símbolos para tipos corretos.",
                                    "Corrija erros: ajuste regras de promoção, refine mensagens de erro.",
                                    "Meça cobertura de testes >90% para nós unários e chamadas.",
                                    "Otimize performance para grandes escopos com muitas sobrecargas.",
                                    "Documente casos edge: unário em argumento de sobrecarga."
                                  ],
                                  "verification": "Programa teste compila sem erros semânticos e gera código IR correto.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Programa de teste completo, debugger do compilador, coverage tool.",
                                  "tips": "Use logging intermediário para rastrear inferência de tipos.",
                                  "learningObjective": "Validar sistema integrado de verificação de tipos para unários e sobrecarga.",
                                  "commonMistakes": "Testes insuficientes para interações unário-sobrecarga; vazamentos de escopo."
                                }
                              ],
                              "practicalExample": "Em um compilador para linguagem similar a C: código 'int res = -max(3.14, 2); bool flag = !min(true, false);'. O analisador valida: max(double,int) promove int para double, retorna double; aplica - (válido); min(bool,bool) retorna bool para ! (válido). Erro se '!-max(1,2)': ! espera bool, max retorna int.",
                              "finalVerifications": [
                                "Todas expressões unárias têm tipo inferido e validado corretamente.",
                                "Chamadas sobrecarregadas resolvem para assinatura única sem ambiguidades.",
                                "Erros semânticos são reportados com linha/coluna e tipos esperados/encontrados.",
                                "Casos compostos (unário em arg de sobrecarga) passam sem regressões.",
                                "Cobertura de testes >90% para nós relevantes.",
                                "Performance: análise <1s para 1000 expressões."
                              ],
                              "assessmentCriteria": [
                                "Precisão: 100% de matches corretos em 20 testes variados.",
                                "Robustez: Trata ambiguidades e erros com mensagens claras.",
                                "Eficiência: Algoritmo O(n*m) onde n=sobrecargas, m=args.",
                                "Integração: Funciona com fases semânticas prévias (escopo, inferência).",
                                "Documentação: Comentários em código e tabela de regras.",
                                "Extensibilidade: Fácil adicionar novos operadores unários."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Lógica booleana e aritmética de tipos (promoção).",
                                "Programação Funcional: Pattern matching similar a overload.",
                                "Engenharia de Software: Design de APIs com overload (Java/C++).",
                                "Teoria da Computação: Inferência de tipos (Hindley-Milner)."
                              ],
                              "realWorldApplication": "Compiladores reais como GCC/Clang usam isso para C++ overload resolution; Java/JVM para método dispatch dinâmico; garante código type-safe evitando runtime errors em apps como browsers (V8) ou sistemas embedded."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.1.2.3",
                            "name": "Propagar tipos em subexpressões",
                            "description": "Realizar verificação recursiva em árvores de expressões, inferindo e unificando tipos de subexpressões complexas.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Modelar a Árvore de Expressões com Nós Tipados",
                                  "subSteps": [
                                    "Defina classes base para Node, LeafNode (variáveis/literais) e InternalNode (operadores).",
                                    "Adicione atributos obrigatórios: tipo (inicialmente None ou Unknown), filhos esquerdo/direito para binários.",
                                    "Implemente um método toString() para visualização da árvore.",
                                    "Crie exemplos de árvores simples como 'a + b' e '(a + b) * c'.",
                                    "Teste serialização e parsing básico de expressões em árvore."
                                  ],
                                  "verification": "Construa e imprima 3 árvores de expressões diferentes sem erros de sintaxe.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Editor de código (Python ou Java), diagramas de árvores de sintaxe (AST).",
                                  "tips": "Use herança para diferentes tipos de nós para facilitar extensibilidade.",
                                  "learningObjective": "Compreender e representar hierarquicamente expressões como árvores para análise recursiva.",
                                  "commonMistakes": "Esquecer de lidar com nós unários ou n-ários; não inicializar tipos como Unknown."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar Verificação Recursiva para Nós Folhas",
                                  "subSteps": [
                                    "Defina um método inferType() recursivo que começa nas folhas.",
                                    "Para literais: atribua int para números inteiros, float para decimais, string para literais de texto.",
                                    "Para variáveis: busque no ambiente de símbolos (SymbolTable) o tipo declarado.",
                                    "Retorne o tipo inferido e armazene no nó.",
                                    "Adicione logging para rastrear inferências em folhas."
                                  ],
                                  "verification": "Inferir tipos corretamente em uma árvore só com folhas e imprimir os tipos atribuídos.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Código do Step 1, tabela de símbolos simples (dict em Python).",
                                  "tips": "Use um Type enum (INT, FLOAT, STRING, UNKNOWN) para padronizar tipos.",
                                  "learningObjective": "Dominar inferência bottom-up iniciando pelas folhas da árvore.",
                                  "commonMistakes": "Não tratar variáveis não declaradas (lançar erro semântico); confundir tipos de literais."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Propagar Tipos para Nós Internos Binários",
                                  "subSteps": [
                                    "No inferType() para nós internos: chame recursivamente nos filhos esquerdo e direito.",
                                    "Baseado no operador (+, -, *, /): unifique tipos dos filhos (ex: int+int=int, int+float=float).",
                                    "Defina regras de promoção de tipo (type promotion) para operadores aritméticos.",
                                    "Armazene o tipo unificado no nó pai após propagação.",
                                    "Teste com expressões mistas como int + float."
                                  ],
                                  "verification": "Propague tipos em uma árvore com 3 níveis de operadores e verifique saídas esperadas.",
                                  "estimatedTime": "50 minutos",
                                  "materials": "Código dos Steps 1-2, tabela de regras de operadores (switch ou dict).",
                                  "tips": "Implemente uma função unifyTypes(type1, type2, op) para centralizar lógica.",
                                  "learningObjective": "Aplicar regras de propagação de tipos baseadas em operadores e filhos.",
                                  "commonMistakes": "Não propagar recursivamente (chamar inferType só uma vez); ignorar associatividade."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Lidar com Unificação Complexa e Erros de Tipo",
                                  "subSteps": [
                                    "Estenda para operadores relacionais (==, <) com regras específicas (ex: bool resultado).",
                                    "Implemente detecção de conflitos: se tipos incompatíveis, levante TypeError.",
                                    "Adicione suporte a casts explícitos e funções com assinaturas de tipo.",
                                    "Crie um visitor pattern para percorrer toda a árvore pós-inferência.",
                                    "Valide uma árvore complexa com subexpressões aninhadas."
                                  ],
                                  "verification": "Execute em 5 expressões variadas, incluindo uma com erro, e confirme diagnósticos corretos.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Código completo anterior, exemplos de expressões com erros.",
                                  "tips": "Use exceções hierárquicas como TypeMismatchError para diagnósticos precisos.",
                                  "learningObjective": "Resolver unificações em subexpressões complexas e detectar erros semânticos.",
                                  "commonMistakes": "Unificar incorretamente tipos não compatíveis (ex: string + int); recursão infinita em ciclos."
                                }
                              ],
                              "practicalExample": "Dada a expressão '(intVar + 3.14) * boolVar ? 5 : \"error\"' em uma árvore AST, a verificação recursiva deve inferir: subexpr (int + float)=float, então float * bool=erro (detectar mismatch), propagar erro para ternário, reportando TypeError em *.",
                              "finalVerifications": [
                                "Inferência correta em 100% das folhas e nós simples.",
                                "Propagação bem-sucedida em árvores de profundidade 4+.",
                                "Detecção e relatório preciso de 3+ erros de tipo comuns.",
                                "Unificação segue regras padrão (ex: promoção int->float).",
                                "Tempo de execução O(n) para árvores de tamanho n.",
                                "Saída de debug mostra caminho de inferência completa."
                              ],
                              "assessmentCriteria": [
                                "Precisão da inferência de tipos: 90%+ acurácia em testes.",
                                "Cobertura de operadores: pelo menos 6 operadores suportados.",
                                "Tratamento de erros: diagnósticos claros e localizados.",
                                "Eficiência recursiva: sem stack overflow em árvores profundas.",
                                "Extensibilidade: fácil adicionar novo operador/tipo.",
                                "Documentação: comentários em regras de unificação."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Álgebra abstrata e sistemas de tipos como em teoria de categorias.",
                                "Lógica: Inferência em provas automáticas e resolução de unificações.",
                                "Engenharia de Software: Design patterns (Visitor) em análise estática.",
                                "Inteligência Artificial: Type inference em linguagens dinâmicas como Python."
                              ],
                              "realWorldApplication": "Em compiladores como GCC/Clang para C++, ou JITs como V8 no JavaScript, propaga tipos em ASTs para otimização de código, detecção precoce de bugs e geração eficiente de bytecode/machine code."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.1.2.4",
                            "name": "Gerar erros de incompatibilidade de tipos",
                            "description": "Implementar mensagens de erro específicas para mismatches de tipos em expressões, com sugestões de correção.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Inferir tipos nas expressões da árvore sintática",
                                  "subSteps": [
                                    "Implemente uma função recursiva para travessia da árvore de expressões (AST).",
                                    "Defina um mapa de tipos para operadores binários e unários (ex: + aceita int ou float).",
                                    "Para cada nó folha (variável ou literal), recupere ou atribua o tipo do símbolo ou valor.",
                                    "Propage tipos para nós internos combinando tipos dos filhos.",
                                    "Retorne o tipo inferido para o nó pai ou sinalize incompatibilidade preliminar."
                                  ],
                                  "verification": "Execute a inferência em expressões válidas e inválidas; verifique se tipos são corretamente propagados sem erros prematuros.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Código fonte da AST do compilador, tabela de tipos de operadores, exemplos de expressões em linguagem de teste.",
                                  "tips": "Use um visitor pattern para travessia limpa da AST.",
                                  "learningObjective": "Dominar inferência de tipos bottom-up em árvores de expressões.",
                                  "commonMistakes": "Ignorar tipos de literais (ex: 'abc' como string), não lidar com operadores sobrecarregados."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Detectar mismatches de tipos durante a inferência",
                                  "subSteps": [
                                    "No nó operador, compare tipos dos operandos com os suportados pelo operador.",
                                    "Defina funções de compatibilidade (ex: isCompatible(int, float) retorna true via promoção).",
                                    "Se incompatível, capture contexto: posição no código, tipos envolvidos, operador.",
                                    "Colete múltiplos erros sem parar na primeira detecção (modo de coleta).",
                                    "Armazene detalhes do mismatch em uma estrutura de erro (tipo esperado vs. encontrado)."
                                  ],
                                  "verification": "Teste com expressões como '1 + \"a\"'; confirme detecção sem crash e captura de contexto.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Função de inferência do Step 1, casos de teste com mismatches (int+string, bool*float).",
                                  "tips": "Priorize erros semânticos sobre sintáticos para evitar falsos positivos.",
                                  "learningObjective": "Identificar precisamente incompatibilidades de tipos em operações.",
                                  "commonMistakes": "Parar na primeira incompatibilidade, perdendo erros múltiplos; confundir subtipo com incompatível."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Construir mensagens de erro específicas e sugestões",
                                  "subSteps": [
                                    "Crie template de mensagem: 'Incompatibilidade em linha X: operador + espera (int/float) mas encontrou (int/string)'.",
                                    "Inclua snippet do código fonte ao redor da posição do erro.",
                                    "Gere sugestões baseadas em tipos: 'Converta string para int com parseInt()' ou 'Use concatenação para strings'.",
                                    "Priorize sugestões por frequência comum (casting, mudança de operador).",
                                    "Formate mensagem para ser legível: cor no terminal ou link para docs de tipos."
                                  ],
                                  "verification": "Gere mensagens para 5 casos variados; revise se são claras e úteis manualmente.",
                                  "estimatedTime": "40 minutos",
                                  "materials": "Estrutura de erro do Step 2, snippets de código fonte, biblioteca de formatação de strings.",
                                  "tips": "Use localização léxica precisa para apontar o token exato do erro.",
                                  "learningObjective": "Criar feedback de erro amigável e acionável para desenvolvedores.",
                                  "commonMistakes": "Mensagens genéricas como 'tipo inválido'; sugestões irrelevantes ou complexas."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Integrar geração de erros no fluxo de análise semântica",
                                  "subSteps": [
                                    "Chame detecção durante a fase de verificação de tipos em expressões.",
                                    "Colete todos erros e emita após análise completa (não interrompa compilação).",
                                    "Adicione flag para modo 'warnings only' vs. 'erros fatais'.",
                                    "Integre com sistema de relatório de erros existente (ex: lista de diagnostics).",
                                    "Teste end-to-end: compile programa com mismatches e valide saída de erros."
                                  ],
                                  "verification": "Compile programas de teste; confirme que erros são emitidos corretamente sem afetar análises posteriores.",
                                  "estimatedTime": "35 minutos",
                                  "materials": "Pipeline de análise semântica completo, suíte de testes com expressões inválidas.",
                                  "tips": "Mantenha análise robusta: erros não devem causar stack overflow.",
                                  "learningObjective": "Integrar verificação de erros em compiladores de forma não-intrusiva.",
                                  "commonMistakes": "Interromper análise cedo, perdendo contexto completo; vazamento de memória em erros."
                                }
                              ],
                              "practicalExample": "Em uma expressão 'int x = 5 + \"hello\";', detecte mismatch em + (int + string). Gere: 'Erro linha 1: Operador + incompatível - esperado numérico, encontrou string \"hello\". Sugestão: Use + para concatenação ou parseInt(\"hello\").'",
                              "finalVerifications": [
                                "Mensagens de erro incluem posição exata, tipos envolvidos e operador.",
                                "Sugestões de correção são práticas e cobrem 80% dos casos comuns.",
                                "Análise continua após erros, coletando todos mismatches.",
                                "Testes unitários passam para expressões válidas e inválidas.",
                                "Saída de erro é formatada e legível em terminais padrão.",
                                "Não há falsos positivos em casos de promoção de tipos (int to float)."
                              ],
                              "assessmentCriteria": [
                                "Precisão na detecção: 100% dos mismatches identificados corretamente.",
                                "Qualidade da mensagem: Clara, concisa, com contexto fonte (nota 1-5).",
                                "Utilidade das sugestões: Acionáveis e relevantes (nota 1-5).",
                                "Robustez: Sem crashes ou loops infinitos em inputs malformados.",
                                "Cobertura de testes: Pelo menos 10 casos, incluindo edge cases.",
                                "Integração limpa: Não quebra fluxo semântico existente."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Lógica de compatibilidade de tipos similar a conjuntos e relações.",
                                "Linguagens: Melhoria de UX em mensagens de erro, como em Python/JavaScript.",
                                "Design de Software: Princípios de reporting de erros e diagnósticos.",
                                "Inteligência Artificial: Geração de sugestões similar a auto-correção em IDEs."
                              ],
                              "realWorldApplication": "Em compiladores como GCC ou Clang, erros de tipo em expressões ajudam desenvolvedores a corrigir bugs cedo, reduzindo tempo de debug em projetos grandes; em linguagens como Rust, sugestões evitam erros comuns em código produtivo."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.5.1.3",
                        "name": "Verificação de Tipos em Atribuições",
                        "description": "Garantir que o tipo do valor à direita da atribuição seja compatível com o tipo da variável à esquerda, considerando conversões e subtipos.",
                        "specificSkills": [
                          {
                            "id": "10.1.5.1.3.1",
                            "name": "Validar atribuições simples",
                            "description": "Checar compatibilidade direta entre tipo da variável e tipo da expressão atribuída, permitindo coerções numéricas básicas.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender conceitos fundamentais de tipos e atribuições",
                                  "subSteps": [
                                    "Defina o que é um tipo de dado em linguagens de programação (ex: int, float, string).",
                                    "Explique a sintaxe de uma declaração e atribuição de variável (ex: int x = expr;).",
                                    "Diferencie compatibilidade direta (mesmo tipo) de coerção implícita básica.",
                                    "Liste exemplos de coerções numéricas permitidas (int para float, float para double).",
                                    "Identifique quando uma atribuição é inválida (ex: string para int)."
                                  ],
                                  "verification": "Escreva uma definição curta e 3 exemplos corretos/incorretos em um papel ou editor.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Documentação de tipos em C ou Java",
                                    "Editor de texto simples"
                                  ],
                                  "tips": "Use tabelas para mapear tipos compatíveis e incompatíveis.",
                                  "learningObjective": "Dominar definições básicas para análise semântica.",
                                  "commonMistakes": [
                                    "Confundir tipo da variável com o da expressão inicial.",
                                    "Ignorar literais como tendo tipo implícito."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar tipos na declaração e na expressão atribuída",
                                  "subSteps": [
                                    "Parseie a declaração: extraia nome e tipo da variável (lado esquerdo).",
                                    "Analise a expressão do lado direito: determine seu tipo (variável, literal, operação simples).",
                                    "Registre tipos explicitamente (ex: var_type = int, expr_type = float).",
                                    "Considere literais: 5 é int, 5.0 é double, 'a' é char.",
                                    "Pratique com 5 exemplos variados de atribuições simples."
                                  ],
                                  "verification": "Crie uma tabela com 5 atribuições e seus tipos identificados corretamente.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Lista de 10 exemplos de código preparados",
                                    "Planilha ou quadro"
                                  ],
                                  "tips": "Comece sempre pelo lado esquerdo, depois direito.",
                                  "learningObjective": "Extrair tipos com precisão de forma sistemática.",
                                  "commonMistakes": [
                                    "Assumir tipo da expressão sem analisar subcomponentes.",
                                    "Esquecer que operações aritméticas promovem tipos (int + float = float)."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Verificar compatibilidade direta e coerções numéricas básicas",
                                  "subSteps": [
                                    "Compare var_type e expr_type: se iguais, compatível diretamente.",
                                    "Se diferentes, verifique coerção numérica: int->float, float->double, int->double permitidas.",
                                    "Rejeite coerções inválidas: string->int, bool->int (exceto 0/1 em alguns casos, mas básico não).",
                                    "Aplique regra: coerção só para hierarquia numérica básica (integral para real).",
                                    "Marque como 'válida' ou 'inválida' com justificativa."
                                  ],
                                  "verification": "Valide 5 atribuições e justifique cada decisão em voz alta ou por escrito.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Exemplos de código com coerções",
                                    "Tabela de regras de coerção"
                                  ],
                                  "tips": "Crie uma matriz de compatibilidade para consulta rápida.",
                                  "learningObjective": "Aplicar regras de verificação de tipos com coerções.",
                                  "commonMistakes": [
                                    "Permitir coerções não-numéricas.",
                                    "Confundir promoção aritmética com atribuição."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Implementar e testar a validação em pseudocódigo ou ferramenta simples",
                                  "subSteps": [
                                    "Escreva pseudocódigo para função validateAssignment(var_type, expr_type).",
                                    "Inclua lógica if para compatibilidade direta e elif para coerções numéricas.",
                                    "Teste com casos: compatível, coerção OK, inválido.",
                                    "Simule em uma ferramenta como Python ou playground online.",
                                    "Registre resultados e depure erros na lógica."
                                  ],
                                  "verification": "Execute testes em 10 casos e obtenha 100% de acerto.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Editor de código online (Replit, JSFiddle)",
                                    "Pseudocódigo template"
                                  ],
                                  "tips": "Use funções auxiliares para mapear tipos numéricos hierárquicos.",
                                  "learningObjective": "Codificar a lógica de validação para reforço prático.",
                                  "commonMistakes": [
                                    "Lógica invertida em ifs.",
                                    "Não tratar literais corretamente."
                                  ]
                                }
                              ],
                              "practicalExample": "Considere o código: int x = 5.5; // expr_type=double, var_type=int -> coerção numérica básica permitida? Em contextos simples, sim se truncar, mas valide como OK para numéricos. Contraexemplo inválido: int x = \"hello\"; // rejeitar por incompatibilidade direta.",
                              "finalVerifications": [
                                "Identifica corretamente tipos de variáveis e expressões em 10 exemplos.",
                                "Detecta e justifica incompatibilidades diretas sem coerção.",
                                "Aplica coerções numéricas básicas apenas para int/float/double.",
                                "Implementa pseudocódigo funcional sem erros lógicos.",
                                "Explica diferenças entre validação estática e runtime.",
                                "Lista 3 erros comuns em atribuições reais."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de tipos (90%+ acerto).",
                                "Correta aplicação de regras de coerção numérica.",
                                "Justificativas claras e concisas para cada validação.",
                                "Pseudocódigo lógico e testável.",
                                "Uso adequado de exemplos práticos.",
                                "Compreensão demonstrada em verificações finais."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Hierarquia de números reais e inteiros (coerções como casting).",
                                "Lógica: Regras de inferência e tabelas verdade para compatibilidade.",
                                "Programação Geral: Debugging e prevenção de erros em tempo de execução.",
                                "Física/Engenharia: Modelagem de grandezas com tipos precisos (ex: int vs float em simulações)."
                              ],
                              "realWorldApplication": "Em compiladores como GCC ou Clang, essa validação ocorre na fase de análise semântica, prevenindo erros como atribuição de string a inteiro, otimizando código e garantindo portabilidade em software embarcado ou aplicativos críticos."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.1.3.2",
                            "name": "Tratar atribuições compostas",
                            "description": "Verificar atribuições a arrays, structs e ponteiros, acessando campos e índices com tipos corretos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender Tipos Compostos e Atribuições Básicas",
                                  "subSteps": [
                                    "Revise definições de arrays, structs e ponteiros na linguagem-alvo (ex: C).",
                                    "Identifique sintaxe de atribuições simples vs. compostas (ex: arr[0] = valor;).",
                                    "Analise árvores de sintaxe (AST) para nodos de atribuição envolvendo tipos compostos.",
                                    "Liste regras de compatibilidade de tipos para cada tipo composto.",
                                    "Pratique parsing manual de 3 exemplos de atribuições compostas."
                                  ],
                                  "verification": "Crie um diagrama da AST para uma atribuição composta e anote tipos esperados.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Documentação da linguagem (ex: C99 spec), exemplos de código fonte, editor de texto.",
                                  "tips": "Use um visualizador de AST online para validar seu diagrama.",
                                  "learningObjective": "Compreender a representação sintática e semântica inicial de atribuições compostas.",
                                  "commonMistakes": "Confundir l-value (lado esquerdo) com r-value; ignorar qualificadores de tipo como const."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Verificar Atribuições a Arrays",
                                  "subSteps": [
                                    "Confirme que o lado esquerdo é um array válido e o índice é inteiro compatível.",
                                    "Verifique bounds checking: índice dentro dos limites declarados.",
                                    "Garanta que o tipo do r-value seja compatível com o tipo do elemento do array.",
                                    "Trate arrays multidimensionais recursivamente.",
                                    "Implemente uma função auxiliar para typeCheckArrayAccess()."
                                  ],
                                  "verification": "Teste com 5 casos: bounds ok, out-of-bounds, tipo mismatch, multi-dim, ponteiro para array.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Código de exemplo com arrays, debugger ou linter semântico simples.",
                                  "tips": "Sempre propague tipos de dentro para fora na AST.",
                                  "learningObjective": "Dominar verificação de tipos e bounds para acessos a arrays em atribuições.",
                                  "commonMistakes": "Não verificar se índice é constante em tempo de compilação quando possível; ignorar arrays de tamanho zero."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Verificar Atribuições a Structs",
                                  "subSteps": [
                                    "Identifique o struct type no l-value e valide o campo acessado.",
                                    "Confirme que o campo existe e extraia seu tipo declarado.",
                                    "Verifique compatibilidade do r-value com o tipo do campo.",
                                    "Lide com structs aninhados ou unions (se aplicável).",
                                    "Adicione suporte para acessos via ponteiro (->)."
                                  ],
                                  "verification": "Parse e cheque 4 structs: campo simples, aninhado, inexistente, tipo errado.",
                                  "estimatedTime": "50 minutos",
                                  "materials": "Exemplos de structs em C, tabela de símbolos mockup.",
                                  "tips": "Mantenha uma tabela de símbolos com offsets de campos para otimização futura.",
                                  "learningObjective": "Implementar type checking preciso para acessos a campos de structs.",
                                  "commonMistakes": "Confundir . (direto) com -> (ponteiro); não propagar erros de tipo em campos aninhados."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificar Atribuições a Ponteiros e Integração",
                                  "subSteps": [
                                    "Desreferencie ponteiros (*) e verifique tipo apontado.",
                                    "Combine verificações: ponteiro para array/struct (ex: (*p).field ou p->field).",
                                    "Trate atribuições de ponteiro (p = &var) vs. desreferenciadas (*p = val).",
                                    "Integre em um visitor de AST unificado para atribuições compostas.",
                                    "Teste casos edge: ponteiro nulo, void*, casting inválido."
                                  ],
                                  "verification": "Execute o verificador em um programa com 10 atribuições mistas e liste erros semânticos.",
                                  "estimatedTime": "70 minutos",
                                  "materials": "AST walker framework (ex: em Python ou C), testes unitários.",
                                  "tips": "Use recursão para desreferenciação múltipla (**p).",
                                  "learningObjective": "Integrar verificações de ponteiros com arrays/structs em um fluxo semântico coeso.",
                                  "commonMistakes": "Esquecer de checar se ponteiro é void ou incompatível; loops infinitos em recursão."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Testar e Refinar o Verificador Completo",
                                  "subSteps": [
                                    "Colete casos de teste abrangentes: válidos, inválidos, edge cases.",
                                    "Implemente relatórios de erro descritivos (ex: 'tipo mismatch em arr[5]').",
                                    "Otimize para performance em grandes ASTs.",
                                    "Compare com output de compiladores reais (gcc -fsyntax-only).",
                                    "Documente limitações e extensões futuras."
                                  ],
                                  "verification": "Alcance 100% acurácia em 20 testes padronizados.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Suite de testes, gcc/clang para golden outputs.",
                                  "tips": "Priorize false positives em verificações conservadoras.",
                                  "learningObjective": "Refinar o módulo para robustez em cenários reais de compiladores.",
                                  "commonMistakes": "Erros de relatório vagos; não testar interações entre tipos."
                                }
                              ],
                              "practicalExample": "Em C: int arr[5]; arr[2] = 42.0; // Erro: int vs float. struct Point { int x; }; Point p; p.x = 'a'; // Erro: int vs char. int *ptr = malloc(sizeof(int)); *ptr = 10; // OK se alocado.",
                              "finalVerifications": [
                                "Verificador detecta mismatch de tipos em array/struct/ponteiro.",
                                "Bounds checking correto para arrays.",
                                "Campos inexistentes em structs reportados.",
                                "Desreferenciação de ponteiros válida.",
                                "Casos compostos (ponteiro para struct array) processados.",
                                "Sem falsos positivos em código válido.",
                                "Relatórios de erro incluem linha/coluna e detalhes."
                              ],
                              "assessmentCriteria": [
                                "Precisão na detecção de erros de tipo (90%+).",
                                "Cobertura de todos subtipos (arrays, structs, ponteiros).",
                                "Eficiência: O(1) por nodo AST.",
                                "Qualidade dos erros reportados (clareza e utilidade).",
                                "Robustez contra inputs malformados.",
                                "Integração seamless com fases semânticas anteriores."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Vetores e álgebra linear para arrays multidim.",
                                "Programação: POO e encapsulamento em structs.",
                                "Engenharia de Software: Design de APIs para walkers de AST.",
                                "Lógica: Inferência de tipos e teoremas semânticos."
                              ],
                              "realWorldApplication": "Implementado em compiladores como GCC/LLVM para análise semântica, prevenindo erros em tempo de compilação em software crítico como kernels de OS, jogos e sistemas embarcados."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.1.3.3",
                            "name": "Implementar conversões de tipos",
                            "description": "Aplicar regras de casting implícito e explícito em atribuições, diferenciando erros de conversão inválida.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender Conceitos de Casting Implícito e Explícito",
                                  "subSteps": [
                                    "Defina tipos primitivos comuns (int, float, char, bool) e sua hierarquia de compatibilidade.",
                                    "Estude regras de widening (implícito: int para float) e narrowing (explícito: float para int).",
                                    "Identifique cenários inválidos, como bool para int sem cast.",
                                    "Analise exemplos de código fonte com atribuições que falham ou succeedem.",
                                    "Crie um fluxograma das regras de conversão."
                                  ],
                                  "verification": "Crie um documento com fluxograma e 5 exemplos comentados; revise se cobre todos os casos básicos.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Documentação de tipos em compiladores (ex: LLVM Type System), exemplos de código em C-like language.",
                                  "tips": "Use diagramas UML para hierarquia de tipos para visualização clara.",
                                  "learningObjective": "Dominar regras teóricas de casting para basear implementações práticas.",
                                  "commonMistakes": "Confundir widening com narrowing; ignorar promoção de tipos (int + char -> int)."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar Função de Verificação de Casting Implícito",
                                  "subSteps": [
                                    "Defina uma função booleana isImplicitConvertible(Type from, Type to).",
                                    "Implemente lógica para widening: int->float, char->int, etc.",
                                    "Adicione suporte para promoções aritméticas comuns.",
                                    "Teste unitariamente com casos como int para float (true), float para int (false).",
                                    "Registre logs para depuração de falhas."
                                  ],
                                  "verification": "Execute testes unitários com pelo menos 10 casos; 100% pass rate.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Código base do analisador semântico, framework de testes (JUnit ou similar).",
                                  "tips": "Use switch-case ou tabela de lookup para eficiência em tipos primitivos.",
                                  "learningObjective": "Criar lógica reutilizável para detecção automática de casts seguros.",
                                  "commonMistakes": "Esquecer promoções em operadores binários; não tratar ponteiros ou refs."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar Parsing e Verificação de Casting Explícito",
                                  "subSteps": [
                                    "Parseie sintaxe de cast: (Type)expr em árvore de sintaxe.",
                                    "Crie função applyExplicitCast(Type target, Type source) que sempre succeede mas avisa narrowing.",
                                    "Diferencie erros: cast inválido como (int)struct.",
                                    "Integre com parser para extrair tipo de cast.",
                                    "Adicione warnings para narrowing lossy."
                                  ],
                                  "verification": "Parse e verifique 5 expressões com casts explícitos; sem crashes ou falsos positivos.",
                                  "estimatedTime": "75 minutos",
                                  "materials": "Parser AST existente, exemplos de código com casts como (int)3.14f.",
                                  "tips": "Valide tipo do cast contra tipos conhecidos antes de aplicar.",
                                  "learningObjective": "Manipular casts forçados com detecção de potenciais perdas de dados.",
                                  "commonMistakes": "Permitir casts sempre sem checagem de compatibilidade básica; parsing falho em nested casts."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Integrar Conversões na Verificação de Atribuições e Tratar Erros",
                                  "subSteps": [
                                    "Na visitor de atribuição (lhs = rhs), pegue types T1 e T2.",
                                    "Se T1 != T2: tente implicit, senão cheque explicit cast em rhs.",
                                    "Gere erros semânticos para conversões inválidas (ex: string = int).",
                                    "Propague tipos convertidos para próxima análise.",
                                    "Teste end-to-end com programa completo."
                                  ],
                                  "verification": "Compile programa de teste com atribuições mistas; erros corretos reportados.",
                                  "estimatedTime": "90 minutos",
                                  "materials": "Código completo do verificador de tipos, suite de testes com 20 atribuições variadas.",
                                  "tips": "Use TypeError hierarchy para erros específicos (ImplicitCastError, InvalidCastError).",
                                  "learningObjective": "Aplicar conversões contextualmente em atribuições reais de compiladores.",
                                  "commonMistakes": "Não propagar tipo convertido; reportar erro em vez de warning para narrowing."
                                }
                              ],
                              "practicalExample": "Em um mini-compilador: Para código 'int x = 3.14f;' gere erro (no implicit float->int). Para 'int x = (int)3.14f;' succeeda com warning. Para 'float y = 42;' implicit ok.",
                              "finalVerifications": [
                                "Função isImplicitConvertible retorna correto para 15+ casos primitivos.",
                                "Parser de cast explícito lida com (int)(float)var sem erros.",
                                "Atribuições com mismatch geram erro semântico preciso.",
                                "Programa de teste com 10 atribuições compila sem crashes.",
                                "Warnings para lossy casts são emitidos.",
                                "Integração não quebra verificações de tipos existentes."
                              ],
                              "assessmentCriteria": [
                                "Correção: 100% dos testes passam sem falsos positivos/negativos.",
                                "Eficiência: O(1) para pares de tipos primitivos via tabela.",
                                "Robustez: Trata edge cases como void ou unknown types.",
                                "Clareza: Código comentado com nomes descritivos.",
                                "Extensibilidade: Fácil adicionar novos tipos.",
                                "Documentação: README com regras implementadas."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Hierarquias de tipos semelhantes a conjuntos ordenados e inclusões.",
                                "Lógica: Dedução de tipos como raciocínio por inferência.",
                                "Engenharia de Software: Design de APIs para extensibilidade em compiladores.",
                                "Física/Engenharia: Modelagem de precisão numérica em simulações."
                              ],
                              "realWorldApplication": "Em compiladores como GCC/Clang, isso previne bugs em C/C++ ao validar casts em atribuições, evitando overflows silenciosos em apps como jogos (float positions) ou finanças (currency conversions)."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.1.3.4",
                            "name": "Verificar atribuições em parâmetros de funções",
                            "description": "Analisar passagem de argumentos para funções, verificando correspondência de tipos com parâmetros formais.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender parâmetros formais e argumentos reais em funções",
                                  "subSteps": [
                                    "Estude a sintaxe de declaração de funções, identificando parâmetros formais e seus tipos declarados.",
                                    "Analise exemplos de chamadas de funções, distinguindo argumentos reais passados.",
                                    "Revise conceitos de tipos de dados (primitivos e compostos) e sua representação em árvores de sintaxe abstrata (AST).",
                                    "Pratique mapeando parâmetros formais para posições posicionais ou nomeadas nos argumentos.",
                                    "Discuta covariância e contravariância em tipos para funções."
                                  ],
                                  "verification": "Crie um diagrama manual ligando parâmetros formais a argumentos em 3 exemplos de código fornecidos.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Documentação de sintaxe da linguagem-alvo (ex: mini-C), exemplos de código fonte, editor de texto.",
                                  "tips": "Use cores diferentes para destacar parâmetros vs. argumentos em diagramas.",
                                  "learningObjective": "Diferenciar e mapear corretamente parâmetros formais e argumentos reais.",
                                  "commonMistakes": "Confundir ordem posicional com nomes de argumentos; ignorar tipos implícitos."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar extração de tipos dos parâmetros formais",
                                  "subSteps": [
                                    "Traverse a AST da declaração da função para coletar lista de parâmetros e tipos.",
                                    "Armazene em uma estrutura de dados (ex: array ou mapa de {nome: tipo}).",
                                    "Lide com funções sobrecarregadas selecionando a assinatura correta via resolução de sobrecarga.",
                                    "Implemente um visitor ou walker para funções na AST.",
                                    "Teste unitário com funções simples e com múltiplos parâmetros."
                                  ],
                                  "verification": "Execute testes unitários que imprimam corretamente os tipos extraídos para 5 declarações variadas.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Código base do analisador semântico, AST parser, framework de testes (ex: JUnit ou pytest).",
                                  "tips": "Comece com funções sem sobrecarga para simplificar.",
                                  "learningObjective": "Extrair e representar tipos de parâmetros formais de forma programática.",
                                  "commonMistakes": "Falhar em lidar com parâmetros default ou variádicos; erro em resolução de escopo."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Extrair e inferir tipos dos argumentos na chamada de função",
                                  "subSteps": [
                                    "Localize nós de chamada de função na AST.",
                                    "Para cada argumento, determine seu tipo via inferência (literais, variáveis, expressões).",
                                    "Implemente type resolution para expressões complexas (operações binárias, casts).",
                                    "Mapeie argumentos por posição ou nome aos parâmetros formais.",
                                    "Valide argumentos faltantes ou extras."
                                  ],
                                  "verification": "Adicione logs ou asserts que mostrem tipos inferidos corretos em chamadas de teste.",
                                  "estimatedTime": "75 minutos",
                                  "materials": "AST walker existente, tabela de símbolos para type lookup, exemplos de chamadas com erros.",
                                  "tips": "Integre com o type checker de expressões já implementado.",
                                  "learningObjective": "Inferir tipos de argumentos reais de forma precisa e associá-los a parâmetros.",
                                  "commonMistakes": "Inferência incorreta em expressões (ex: int + string); ignorar casts explícitos."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificar correspondência de tipos e reportar erros",
                                  "subSteps": [
                                    "Compare tipo do argumento com tipo do parâmetro formal (exata, promoção implícita).",
                                    "Defina regras de compatibilidade de tipos (subtipagem, conversões seguras).",
                                    "Gere mensagens de erro descritivas com linha/coluna e tipos envolvidos.",
                                    "Integre ao fluxo principal do analisador semântico.",
                                    "Teste end-to-end com casos de sucesso e falha."
                                  ],
                                  "verification": "Compile 10 programas de teste; verifique ausência de falsos positivos/negativos em erros reportados.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Regras de type compatibility documentadas, compilador de teste com casos edge.",
                                  "tips": "Use enums para níveis de erro (warning vs. error).",
                                  "learningObjective": "Implementar verificação robusta de tipos em chamadas de funções.",
                                  "commonMistakes": "Permitir conversões perigosas como float para int sem cast; erros em tipos void."
                                }
                              ],
                              "practicalExample": "Em mini-C:\nint soma(int x, float y) { return x + y; }\n...\nsoma(5, \"texto\"); // Erro: \"texto\" (string) não compatível com float y\nsoma(3.0, 2); // OK: 3.0 (float) para int x via promoção, 2 (int) para float y.",
                              "finalVerifications": [
                                "Implementa extração correta de parâmetros para funções com 0-5 params.",
                                "Infere tipos de argumentos em expressões compostas.",
                                "Detecta e reporta mismatch de tipos em todas posições.",
                                "Lida com funções sobrecarregadas sem ambiguidades.",
                                "Passa em suíte de 20 testes incluindo edge cases (null, void).",
                                "Gera mensagens de erro legíveis e posicionadas."
                              ],
                              "assessmentCriteria": [
                                "Precisão na extração e inferência de tipos (>95% em testes automáticos).",
                                "Cobertura de casos edge (overloading, variádicos, casts).",
                                "Eficiência: O(N) onde N é número de chamadas.",
                                "Qualidade das mensagens de erro (claras, acionáveis).",
                                "Integração limpa sem quebrar outras fases do compilador.",
                                "Documentação de código com comentários em pontos chave."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria de tipos e subtipagem (relações de ordem parcial).",
                                "Lógica: Verificação de pré-condições e pós-condições em funções.",
                                "Engenharia de Software: Design de APIs e contratos de interface.",
                                "Linguagens Formais: Autômatos e gramáticas livres de contexto para parsing."
                              ],
                              "realWorldApplication": "Em compiladores como GCC/Clang, essa verificação previne runtime errors em chamadas de funções; em IDEs (VSCode, IntelliJ), fornece autocompletar e warnings em tempo real, acelerando desenvolvimento e reduzindo bugs."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.5.2",
                    "name": "Análise de Escopo",
                    "description": "Determinação do escopo de visibilidade e resolução de referências a identificadores.",
                    "individualConcepts": [
                      {
                        "id": "10.1.5.2.1",
                        "name": "Escopo de Visibilidade",
                        "description": "Conceito fundamental que define as regiões do código-fonte onde um identificador declarado é visível e pode ser referenciado, considerando escopos estáticos (léxicos) típicos em compiladores.",
                        "specificSkills": [
                          {
                            "id": "10.1.5.2.1.1",
                            "name": "Identificar tipos de escopo",
                            "description": "Diferenciar escopo global, local, de bloco e aninhado em linguagens como C ou Pascal, reconhecendo regras de visibilidade estática.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender Conceitos Fundamentais de Escopo",
                                  "subSteps": [
                                    "Defina escopo como a região do código onde uma variável é visível e acessível.",
                                    "Explique visibilidade estática: determinada em tempo de compilação, não em runtime.",
                                    "Compare com binding dinâmico em outras linguagens para contraste.",
                                    "Liste os quatro tipos principais: global, local (função), de bloco e aninhado.",
                                    "Desenhe um diagrama hierárquico de escopos."
                                  ],
                                  "verification": "Crie um resumo de 1 página explicando os conceitos e compartilhe com um par para feedback.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Papel e caneta ou ferramenta de diagrama como Draw.io; documentação de C (cppreference.com).",
                                  "tips": "Use analogias como 'quartos em uma casa' para visualizar escopos aninhados.",
                                  "learningObjective": "Entender a definição e importância da visibilidade estática em escopos.",
                                  "commonMistakes": "Confundir visibilidade estática com dinâmica (ex: Python)."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Diferenciar Escopo Global e Local",
                                  "subSteps": [
                                    "Declare uma variável global fora de qualquer função e acesse-a de múltiplas funções.",
                                    "Crie uma variável local dentro de uma função e tente acessá-la fora dela (deve falhar).",
                                    "Compile e execute código C mostrando shadowing: variável local com mesmo nome que global.",
                                    "Analise erros de compilação ao acessar local de fora do escopo.",
                                    "Explique regras: global visível em todo programa, local só na função."
                                  ],
                                  "verification": "Escreva e compile um programa C com global e local, demonstrando acesso e shadowing.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Compilador GCC, editor como VS Code ou Code::Blocks.",
                                  "tips": "Use 'gcc -Wall' para warnings sobre variáveis não usadas.",
                                  "learningObjective": "Distinguir acessibilidade e regras de conflito entre global e local.",
                                  "commonMistakes": "Achar que global é sempre preferida sobre local (não, shadowing prevalece)."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explorar Escopo de Bloco e Aninhado",
                                  "subSteps": [
                                    "Declare variáveis dentro de {} (bloco if, for) e teste visibilidade fora do bloco.",
                                    "Crie escopos aninhados: função > bloco if > bloco for, declarando variáveis em cada nível.",
                                    "Demonstre shadowing em blocos aninhados com nomes iguais.",
                                    "Analise código Pascal similar usando 'begin-end' para blocos.",
                                    "Verifique regras: cada bloco cria novo escopo, visibilidade só dentro."
                                  ],
                                  "verification": "Compile código C/Pascal com blocos aninhados e identifique erros de escopo.",
                                  "estimatedTime": "75 minutos",
                                  "materials": "Compilador Free Pascal ou GCC; exemplos de código online (GeeksforGeeks).",
                                  "tips": "Indentação ajuda a visualizar blocos; use 'static' para persistência em locais.",
                                  "learningObjective": "Identificar e diferenciar escopo de bloco e aninhamento hierárquico.",
                                  "commonMistakes": "Pensar que variáveis de bloco pai são acessíveis em filho (são, mas shadowing possível)."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Praticar Identificação e Regras de Visibilidade Estática",
                                  "subSteps": [
                                    "Analise código fornecido: marque escopo de cada variável com setas coloridas.",
                                    "Simule compilador: preveja erros de 'undeclared identifier' antes de compilar.",
                                    "Compare C e Pascal: note semelhanças em regras estáticas.",
                                    "Crie quiz próprio com 10 declarações mistas e resolva.",
                                    "Discuta casos edge: variáveis em headers (extern global)."
                                  ],
                                  "verification": "Resolva 5 exercícios de identificação de escopo com 100% acerto e explique cada um.",
                                  "estimatedTime": "90 minutos",
                                  "materials": "Exercícios impressos ou online (LeetCode-style para escopo); debugger GDB.",
                                  "tips": "Use 'gdb' para inspecionar símbolos em runtime, mas foque em estática.",
                                  "learningObjective": "Aplicar conhecimento para identificar tipos de escopo em código real.",
                                  "commonMistakes": "Ignorar 'extern' ou 'static' que alteram visibilidade."
                                }
                              ],
                              "practicalExample": "Em C: int globalVar = 10; void func() { int localVar = 20; if(true) { int blockVar = 30; printf(\"%d %d %d\", globalVar, localVar, blockVar); } /* blockVar inacessível aqui */ } // Chame func(); acessa globalVar fora.",
                              "finalVerifications": [
                                "Lista corretamente os 4 tipos de escopo com exemplos.",
                                "Explica shadowing em código compilável.",
                                "Identifica erros de escopo em snippet desconhecido.",
                                "Diferencia visibilidade estática vs dinâmica.",
                                "Desenha diagrama de escopo aninhado sem erros.",
                                "Compara C e Pascal corretamente."
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição de cada tipo de escopo (90%+).",
                                "Capacidade de prever erros de compilação (sem falhas em 10 testes).",
                                "Explicações claras com exemplos práticos.",
                                "Uso correto de terminologia (visibilidade estática).",
                                "Diagrama hierárquico completo e legível.",
                                "Aplicação em código real sem shadowing indesejado."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Hierarquias e conjuntos aninhados (teoria de conjuntos).",
                                "Lógica: Tabelas de símbolos como tabelas verdade.",
                                "Física: Analogia com campos de força (visibilidade limitada).",
                                "Linguística: Escopo como contexto gramatical em frases."
                              ],
                              "realWorldApplication": "Em desenvolvimento de software, entender escopos previne bugs de variáveis não declaradas ou shadowing inesperado em grandes projetos como kernels Linux ou jogos em C, garantindo modularidade e depuração eficiente."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.2.1.2",
                            "name": "Determinar regiões de declaração",
                            "description": "Analisar o código para mapear a região de declaração de variáveis e funções, identificando o início e fim de cada escopo.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender conceitos fundamentais de escopo e declaração",
                                  "subSteps": [
                                    "Estude definições de escopo léxico e dinâmico.",
                                    "Identifique diferenças entre declaração, definição e uso de variáveis/funções.",
                                    "Analise exemplos de escopos globais, locais e aninhados.",
                                    "Revise regras de visibilidade em linguagens como C, Java ou Python.",
                                    "Registre anotações sobre início (abertura de bloco) e fim (fechamento de bloco) de escopos."
                                  ],
                                  "verification": "Resuma em um diagrama simples os tipos de escopo e forneça 3 exemplos corretos.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Documentação de linguagens (MDN, Python docs), papel e caneta para diagramas.",
                                  "tips": "Use cores diferentes para escopos globais e locais nos diagramas.",
                                  "learningObjective": "Dominar terminologia e regras básicas de escopo de visibilidade.",
                                  "commonMistakes": "Confundir escopo léxico com dinâmico; ignorar escopos aninhados."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar delimitadores de escopo no código fonte",
                                  "subSteps": [
                                    "Localize chaves {}, parênteses (), ou indentação (Python) que definem blocos.",
                                    "Marque funções, loops (for/while), condicionais (if/else) e classes.",
                                    "Crie uma lista de todos os delimitadores em um código curto.",
                                    "Destaque aninhamentos de blocos.",
                                    "Verifique compatibilidade com a sintaxe da linguagem escolhida."
                                  ],
                                  "verification": "Anote todos os delimitadores em um snippet de código e confirme com um parser online.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Editor de código (VS Code), snippets de código exemplo.",
                                  "tips": "Use extensão de syntax highlighting para visualizar blocos facilmente.",
                                  "learningObjective": "Reconhecer visualmente os limites de escopo no código.",
                                  "commonMistakes": "Ignorar indentação em Python; confundir expressões com blocos."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Mapear regiões de declaração para variáveis e funções",
                                  "subSteps": [
                                    "Para cada variável/função declarada, trace o bloco mais próximo de abertura.",
                                    "Anote linha inicial e final da região de declaração.",
                                    "Construa uma tabela: Nome | Linha Início | Linha Fim | Escopo Pai.",
                                    "Repita para todos os identificadores no código.",
                                    "Valide se declarações não vazam de escopos filhos."
                                  ],
                                  "verification": "Gere um mapa de regiões e compare com análise manual de um colega ou ferramenta.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Planilha (Google Sheets), código fonte anotado.",
                                  "tips": "Comece com código simples (uma função) antes de complexos.",
                                  "learningObjective": "Aplicar mapeamento prático de regiões em código real.",
                                  "commonMistakes": "Errar escopo pai em aninhamentos profundos; esquecer variáveis globais."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Validar e analisar regiões em cenários complexos",
                                  "subSteps": [
                                    "Introduza shadowing (redeclaração em escopo filho).",
                                    "Teste visibilidade em chamadas de funções e loops.",
                                    "Use ferramentas como linters para confirmar mapeamento.",
                                    "Crie um diagrama de árvore de escopos.",
                                    "Documente ambiguidades ou erros semânticos detectados."
                                  ],
                                  "verification": "Resolva um exercício com código buggy e corrija identificando regiões erradas.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Linter (pylint para Python), exemplos de código com erros.",
                                  "tips": "Simule com debugger stepwise para visualizar escopos.",
                                  "learningObjective": "Detectar e resolver problemas de escopo via análise de regiões.",
                                  "commonMistakes": "Subestimar impacto de shadowing; ignorar escopos condicionais."
                                }
                              ],
                              "practicalExample": "Em Python:\n```python\ndef outer():\n    global_var = 'global'  # Região: linha 2-10 (escopo outer)\n    def inner():\n        local_var = 'inner'  # Região: linha 4-7 (escopo inner)\n        if True:\n            shadowed = 'shadow'  # Região: linha 5-6 (escopo if dentro inner)\n    inner()\n```\nMapa: global_var (2-10), local_var (4-7), shadowed (5-6).",
                              "finalVerifications": [
                                "Mapeia corretamente regiões em código com 3+ níveis de aninhamento.",
                                "Identifica shadowing e visibilidade limitada.",
                                "Constrói árvore de escopos sem erros.",
                                "Valida com linter ou parser sem discrepâncias.",
                                "Explica regiões para um código de 50 linhas."
                              ],
                              "assessmentCriteria": [
                                "Precisão no mapeamento de 90%+ das regiões.",
                                "Uso correto de delimitadores e escopos pai/filho.",
                                "Detecção de todos os casos de shadowing e vazamento.",
                                "Clareza na documentação (tabelas/diagramas).",
                                "Tempo de análise eficiente (<10min por função média)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Árvores e grafos para representar escopos hierárquicos.",
                                "Linguística: Parsing sintático similar a análise de frases.",
                                "Lógica: Predicados de visibilidade como regras formais."
                              ],
                              "realWorldApplication": "Em compiladores (GCC/Clang) para análise semântica e detecção de erros; IDEs (VS Code) para autocomplete e refactoring; depuração em sistemas embarcados onde escopos afetam memória."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.2.1.3",
                            "name": "Reconhecer sombreamento de identificadores",
                            "description": "Explicar o fenômeno de shadowing, onde um identificador local oculta um global ou de escopo externo, e suas implicações na visibilidade.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender Conceitos Fundamentais de Escopo e Visibilidade",
                                  "subSteps": [
                                    "Estude a definição de escopo lexical: região do código onde um identificador é válido.",
                                    "Diferencie escopo global (todo o programa) de escopo local (dentro de função ou bloco).",
                                    "Analise regras de visibilidade: como identificadores são resolvidos de dentro para fora.",
                                    "Desenhe um diagrama simples de escopos aninhados.",
                                    "Compare com exemplos em linguagens como Python ou C++."
                                  ],
                                  "verification": "Explique em suas palavras a diferença entre escopo global e local, com um diagrama.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Documentação oficial de Python/JavaScript sobre escopos",
                                    "Papel e caneta para diagramas",
                                    "Editor de código online (Replit)"
                                  ],
                                  "tips": "Visualize escopos como 'caixas chinesas' aninhadas para melhor compreensão.",
                                  "learningObjective": "Definir escopo e visibilidade, distinguindo tipos de escopo.",
                                  "commonMistakes": [
                                    "Confundir escopo com tempo de vida da variável",
                                    "Ignorar que visibilidade é resolvida lexicalmente",
                                    "Assumir que escopo global sempre prevalece"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar Exemplos de Shadowing",
                                  "subSteps": [
                                    "Examine código com identificador local homônimo a global: ex. 'x' global e 'x' local.",
                                    "Execute o código e observe o valor acessado dentro do escopo local vs. externo.",
                                    "Modifique o código para acessar explicitamente o global (ex: globals() em Python).",
                                    "Identifique shadowing em blocos aninhados (if, loops).",
                                    "Compare com não-shadowing: renomeie local para evitar."
                                  ],
                                  "verification": "Forneça um snippet de código com shadowing e aponte o identificador sombreado.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Editor de código (VS Code ou online)",
                                    "Snippets de exemplo em Python/C++",
                                    "Debugger integrado"
                                  ],
                                  "tips": "Use print statements ou debugger para rastrear valores em cada escopo.",
                                  "learningObjective": "Reconhecer quando um identificador local oculta um externo.",
                                  "commonMistakes": [
                                    "Pensar que shadowing altera o global",
                                    "Não notar shadowing em blocos não-funcionais",
                                    "Confundir com redeclaração/erros de compilação"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar Implicações e Riscos do Shadowing",
                                  "subSteps": [
                                    "Discuta bugs comuns: valores inesperados devido a shadowing acidental.",
                                    "Explore warnings de compiladores/linters (ex: pylint em Python).",
                                    "Avalie boas práticas: evitar nomes duplicados, usar 'self.' ou namespaces.",
                                    "Simule cenários: shadowing em loops ou recursão.",
                                    "Pesquise casos reais de bugs famosos causados por shadowing."
                                  ],
                                  "verification": "Descreva um risco de shadowing e como mitigá-lo em um exemplo.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Linter online (pylint.org)",
                                    "Artigos sobre bugs de escopo (Stack Overflow)",
                                    "Documentação de linters"
                                  ],
                                  "tips": "Ative warnings de shadowing no seu IDE para prática imediata.",
                                  "learningObjective": "Explicar implicações na visibilidade e depuração.",
                                  "commonMistakes": [
                                    "Subestimar impacto em código legado",
                                    "Ignorar shadowing em bibliotecas externas",
                                    "Confundir com captura de variáveis em closures"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Praticar Reconhecimento e Verificação em Código Real",
                                  "subSteps": [
                                    "Analise 3-5 snippets complexos com múltiplos escopos aninhados.",
                                    "Marque todos os casos de shadowing e preveja comportamento.",
                                    "Refatore código para eliminar shadowing desnecessário.",
                                    "Teste com unit tests para validar visibilidade.",
                                    "Crie seu próprio exemplo com shadowing intencional."
                                  ],
                                  "verification": "Resolva um exercício: identifique e corrija shadowing em código fornecido.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Exercícios de código (LeetCode ou repositórios GitHub)",
                                    "Ferramentas de teste (pytest)",
                                    "IDE com suporte a linting"
                                  ],
                                  "tips": "Comece com códigos simples e aumente complexidade gradualmente.",
                                  "learningObjective": "Aplicar reconhecimento de shadowing em cenários práticos.",
                                  "commonMistakes": [
                                    "Não testar fora do escopo local",
                                    "Esquecer shadowing em parâmetros de função",
                                    "Não considerar linguagens com escopo dinâmico"
                                  ]
                                }
                              ],
                              "practicalExample": "Em Python:\n\nglobal_var = 10\n\ndef outer():\n    local_outer = 20\n    def inner():\n        local_outer = 30  # Shadows outer's local_outer\n        print(local_outer)  # Outputs 30\n    inner()\n    print(local_outer)  # Outputs 20\n\nouter()\nprint(global_var)  # Outputs 10\n\nAqui, 'local_outer' na inner() shadows o da outer(), mas não afeta o global_var.",
                              "finalVerifications": [
                                "Explicar shadowing com exemplo próprio.",
                                "Identificar corretamente shadowing em snippet desconhecido.",
                                "Prever saída de código com shadowing em 3 cenários.",
                                "Sugerir refatoração para evitar shadowing problemático.",
                                "Discutir quando shadowing é intencional e útil.",
                                "Reconhecer diferenças entre shadowing e hoisting."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de shadowing (90%+ acertos).",
                                "Clareza na explicação de implicações (detalhes sobre visibilidade).",
                                "Criatividade em exemplos práticos e refatorações.",
                                "Compreensão de contextos linguísticos variados.",
                                "Uso correto de terminologia (escopo lexical, visibilidade).",
                                "Aplicação de boas práticas em exercícios."
                              ],
                              "crossCurricularConnections": [
                                "Linguística: Ambiguidade semântica em linguagem natural (palavras com múltiplos significados por contexto).",
                                "Matemática: Namespaces e escopos em álgebra abstrata.",
                                "Design de Software: Princípios de modularidade e encapsulamento.",
                                "Física: Analogia com sombras (objeto local bloqueia luz de fonte externa)."
                              ],
                              "realWorldApplication": "Em compiladores e intérpretes, para análise semântica e geração de warnings; em depuração de software, para resolver bugs de variáveis 'mágicas'; em grandes codebases, para manter clareza e evitar erros caros em produção, como em sistemas bancários ou embedded."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.5.2.2",
                        "name": "Tabelas de Símbolos para Escopos",
                        "description": "Estruturas de dados hierárquicas usadas na análise semântica para armazenar informações sobre identificadores em diferentes níveis de escopo.",
                        "specificSkills": [
                          {
                            "id": "10.1.5.2.2.1",
                            "name": "Implementar tabelas de símbolos hierárquicas",
                            "description": "Construir tabelas de símbolos com pilha ou árvore para representar escopos aninhados, incluindo inserção e busca em escopos específicos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Design the Hierarchical Symbol Table Structure",
                                  "subSteps": [
                                    "Study flat vs. hierarchical symbol tables and their use in nested scopes.",
                                    "Choose between stack-based (linked lists) or tree-based implementation.",
                                    "Define the Symbol class with name, type, and scope info.",
                                    "Define the Scope class with symbol map and parent pointer.",
                                    "Sketch a diagram of the hierarchy for nested functions."
                                  ],
                                  "verification": "Draw a UML diagram or pseudocode representing the structure with at least 3 nested scopes.",
                                  "estimatedTime": "1-2 hours",
                                  "materials": [
                                    "Paper/whiteboard for diagrams",
                                    "Programming language reference (Python/C++)",
                                    "Online resources on symbol tables"
                                  ],
                                  "tips": "Start with stack-of-maps for simplicity; use dict in Python or unordered_map in C++ for fast lookups.",
                                  "learningObjective": "Understand and model hierarchical scopes using stacks or trees.",
                                  "commonMistakes": [
                                    "Ignoring parent pointers",
                                    "Using global scope for all symbols",
                                    "Forgetting to handle scope IDs"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implement Scope Management (Enter and Exit Scopes)",
                                  "subSteps": [
                                    "Create a SymbolTable class with a stack of Scope objects.",
                                    "Implement enterScope(): push new Scope with parent reference.",
                                    "Implement exitScope(): pop current scope and verify stack integrity.",
                                    "Add currentScope() to access top of stack.",
                                    "Handle errors like popping empty stack."
                                  ],
                                  "verification": "Test enter/exit with 3 nested scopes; print stack depth before/after.",
                                  "estimatedTime": "1 hour",
                                  "materials": [
                                    "IDE (VS Code/PyCharm)",
                                    "Programming language compiler/interpreter"
                                  ],
                                  "tips": "Use a std::vector<Scope*> or list in C++; Python list of dicts works well.",
                                  "learningObjective": "Manage dynamic scope hierarchy during parsing.",
                                  "commonMistakes": [
                                    "Not linking parent scopes",
                                    "Memory leaks in tree structures",
                                    "Infinite recursion in parent traversal"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implement Symbol Insertion into Specific Scopes",
                                  "subSteps": [
                                    "Define insert(symbolName, symbolType, scopeDepth): insert into current or specified scope.",
                                    "Check for duplicates in target scope before inserting.",
                                    "Update symbol with scope ID.",
                                    "Handle insertion in parent scopes if needed.",
                                    "Log insertions for debugging."
                                  ],
                                  "verification": "Insert symbols in different scopes and print table contents level-by-level.",
                                  "estimatedTime": "1-2 hours",
                                  "materials": [
                                    "Unit testing framework (pytest/GoogleTest)",
                                    "Debugger"
                                  ],
                                  "tips": "Always insert in innermost scope first; use scope depth for specificity.",
                                  "learningObjective": "Accurately place symbols in hierarchical scopes without collisions.",
                                  "commonMistakes": [
                                    "Overwriting symbols in parent scopes",
                                    "Inserting without scope check",
                                    "Scope depth mismatches"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Implement Symbol Lookup and Resolution",
                                  "subSteps": [
                                    "Define lookup(symbolName, fromScope): search from current scope upwards.",
                                    "Traverse parents until symbol found or root reached.",
                                    "Return symbol with scope info or null/not found.",
                                    "Cache lookups if performance critical.",
                                    "Test shadowing: local shadows parent."
                                  ],
                                  "verification": "Lookup symbols in shadowed scopes; assert correct resolution.",
                                  "estimatedTime": "1-2 hours",
                                  "materials": [
                                    "Test cases file",
                                    "Profiler for lookup speed"
                                  ],
                                  "tips": "Linear search up parents is O(depth); optimize with hash tables per scope.",
                                  "learningObjective": "Resolve names correctly respecting lexical scoping rules.",
                                  "commonMistakes": [
                                    "Stopping at first match without scope check",
                                    "Global fallback always",
                                    "Cyclic parent traversal"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Test and Validate the Implementation",
                                  "subSteps": [
                                    "Write unit tests for enter/exit, insert, lookup.",
                                    "Simulate a program parse tree with nested blocks.",
                                    "Edge cases: empty scopes, deep nesting, shadowing.",
                                    "Measure performance on 1000 symbols.",
                                    "Refactor based on test failures."
                                  ],
                                  "verification": "All tests pass with 100% coverage; no leaks.",
                                  "estimatedTime": "2 hours",
                                  "materials": [
                                    "Testing library",
                                    "Valgrind (C++) or memory profiler"
                                  ],
                                  "tips": "Use property-based testing for random scope depths.",
                                  "learningObjective": "Ensure robustness through comprehensive testing.",
                                  "commonMistakes": [
                                    "Untested edge cases like max depth",
                                    "Ignoring memory management",
                                    "No shadowing tests"
                                  ]
                                }
                              ],
                              "practicalExample": "Simule um compilador para uma linguagem com funções aninhadas: main { x=1; foo { x=2; bar { x=3; } } }. Inserir x em main, foo, bar. Busca de x em bar retorna x=3 (local), em foo retorna x=2, ignorando bar.",
                              "finalVerifications": [
                                "Inserção em escopo específico sem afetar pais/filhos.",
                                "Busca resolve shadowing corretamente (local > parent).",
                                "Enter/exit scopes mantém hierarquia intacta.",
                                "Tratamento de erros: símbolo não encontrado, escopo inválido.",
                                "Performance: lookup em profundidade 10 < 1ms.",
                                "Sem vazamentos de memória em 1000 operações."
                              ],
                              "assessmentCriteria": [
                                "Correção: 100% testes passam incluindo shadowing.",
                                "Eficiência: O(1) inserção, O(depth) busca.",
                                "Robustez: Trata erros graciosamente.",
                                "Clareza: Código legível com comentários.",
                                "Extensibilidade: Fácil adicionar atributos ao Symbol.",
                                "Documentação: README com uso e diagramas."
                              ],
                              "crossCurricularConnections": [
                                "Estruturas de Dados: Pilhas, árvores, hash tables.",
                                "Banco de Dados: Namespaces e schemas hierárquicos.",
                                "Matemática: Grafos direcionados acíclicos (DAGs).",
                                "Engenharia de Software: Gerenciamento de estado em parsers.",
                                "Lógica: Resolução de escopos como busca em grafo."
                              ],
                              "realWorldApplication": "Em compiladores como GCC/Clang para C++, interpreters Python/JavaScript para resolução de variáveis em funções/blocos aninhados, evitando conflitos de nomes em código modular."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.2.2.2",
                            "name": "Gerenciar entrada e saída de escopos",
                            "description": "Descrever operações de push (entrada em novo escopo) e pop (saída de escopo) nas tabelas de símbolos durante a travessia da árvore sintática.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender Conceitos de Escopos e Tabelas de Símbolos",
                                  "subSteps": [
                                    "Defina escopo lexical como região do código onde um símbolo é visível.",
                                    "Explique tabela de símbolos como uma pilha (stack) de mapas ou dicionários para múltiplos escopos.",
                                    "Identifique escopos globais (base da pilha) versus locais (topo da pilha).",
                                    "Descreva como símbolos são resolvidos procurando do topo para a base da pilha.",
                                    "Diferencie símbolos com mesmo nome em escopos aninhados (shadowing)."
                                  ],
                                  "verification": "Desenhe um diagrama de pilha de tabelas de símbolos para um programa com função e bloco interno.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Papel e caneta para diagramas, documentação de compiladores (ex: Dragon Book capítulo sobre análise semântica).",
                                  "tips": "Use analogia de caixas aninhadas: cada caixa é um escopo, itens dentro são símbolos locais.",
                                  "learningObjective": "Entender a estrutura hierárquica de escopos representada por uma pilha de tabelas de símbolos.",
                                  "commonMistakes": "Confundir busca linear em uma única tabela com busca em pilha hierárquica."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar Operação de Push para Entrada em Novo Escopo",
                                  "subSteps": [
                                    "Crie uma estrutura de dados para tabela de símbolos (ex: lista de dicionários em Python).",
                                    "Defina função push() que adiciona um novo dicionário vazio no topo da pilha.",
                                    "Associe push a nós da AST como FunctionDeclaration ou BlockStatement (entrada em {).",
                                    "Inicialize o novo escopo com parâmetros ou símbolos locais ao empurrar.",
                                    "Teste push isoladamente imprimindo a pilha antes/depois."
                                  ],
                                  "verification": "Execute push e confirme que novo escopo está no topo e símbolos globais ainda acessíveis abaixo.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Editor de código (Python ou pseudo-código), exemplo de AST simples em JSON.",
                                  "tips": "Sempre empurre antes de processar declarações locais para evitar vazamento de símbolos.",
                                  "learningObjective": "Capacitar a criação de um novo contexto de símbolos ao entrar em escopo.",
                                  "commonMistakes": "Esquecer de inicializar o novo dicionário vazio, causando herança indesejada."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar Operação de Pop para Saída de Escopo",
                                  "subSteps": [
                                    "Defina função pop() que remove o topo da pilha de tabelas.",
                                    "Associe pop a nós da AST como fim de BlockStatement ou FunctionDeclaration (saída de }).",
                                    "Garanta que pop só ocorra após processar todo conteúdo do escopo.",
                                    "Salve informações do escopo removido se necessário para análise posterior (ex: relatório de uso).",
                                    "Teste pop isoladamente e verifique restauração do escopo pai."
                                  ],
                                  "verification": "Após pop, confirme que símbolos locais foram removidos e pai está acessível novamente.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Mesmo editor de código, testes unitários para push/pop.",
                                  "tips": "Use recursão na travessia para garantir push/pop pareados automaticamente.",
                                  "learningObjective": "Habilitar a limpeza correta de contexto ao sair de escopo, restaurando visibilidade anterior.",
                                  "commonMistakes": "Pop prematuro, perdendo símbolos ainda necessários no escopo."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Integrar Push e Pop na Travessia da Árvore Sintática",
                                  "subSteps": [
                                    "Implemente visitor recursivo para AST que chama push ao entrar em nós de escopo.",
                                    "Processe declarações dentro do escopo atual (inserir símbolos no topo).",
                                    "Resolva referências procurando no topo da pilha primeiro.",
                                    "Chame pop ao sair recursivamente do nó de escopo.",
                                    "Adicione logging para rastrear mudanças de escopo durante travessia."
                                  ],
                                  "verification": "Traverse uma AST completa e verifique ausência de erros de escopo não resolvido ou vazamento.",
                                  "estimatedTime": "90 minutos",
                                  "materials": "Parser gerador de AST (ex: ANTLR ou hand-made), código de visitor pattern.",
                                  "tips": "Pré e pós-visitors: push na pré-visita, pop na pós-visita.",
                                  "learningObjective": "Aplicar gerenciamento de escopos dinamicamente durante análise semântica.",
                                  "commonMistakes": "Mismatch de push/pop devido a nós condicionais ou loops na AST."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Testar e Depurar Gerenciamento de Escopos",
                                  "subSteps": [
                                    "Crie casos de teste: escopos aninhados, shadowing, escopo global.",
                                    "Simule erros: pop sem push, busca em escopo errado.",
                                    "Use debugger para inspecionar pilha em pontos críticos.",
                                    "Gere relatório de símbolos por escopo para validação.",
                                    "Otimize para performance em ASTs grandes."
                                  ],
                                  "verification": "Todos testes passam; pilha vazia no fim da travessia.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Framework de testes (pytest), exemplos de programas com escopos complexos.",
                                  "tips": "Asserções em cada push/pop para tamanho da pilha esperado.",
                                  "learningObjective": "Validar robustez do sistema de gerenciamento de escopos.",
                                  "commonMistakes": "Ignorar escopos vazios ou não empurrar para escopos implícitos."
                                }
                              ],
                              "practicalExample": "Em uma mini-linguagem: programa 'int x=1; { int x=2; { int x=3; print(x); } print(x); } print(x);'. Travessia: push global (x=1), push block1 (x=2), push block2 (x=3), print usa x=3 (topo), pop block2 (topo=x=2), print usa x=2, pop block1 (topo=global x=1), print usa x=1. Implemente em Python: symbol_table = []; def push(): symbol_table.append({}); def pop(): symbol_table.pop();",
                              "finalVerifications": [
                                "Pilha de símbolos inicia vazia e termina vazia após travessia completa.",
                                "Símbolos locais visíveis apenas no seu escopo e shadowing correto.",
                                "Nenhuma referência a símbolo não resolvido durante resolução.",
                                "Diagrama manual de pilha corresponde ao log de push/pop.",
                                "Testes com aninhamento profundo (5+ níveis) sem stack overflow.",
                                "Relatório lista símbolos por escopo sem duplicatas indevidas."
                              ],
                              "assessmentCriteria": [
                                "Precisão conceitual de push/pop (25%)",
                                "Correção na implementação do visitor AST (30%)",
                                "Robustez em testes edge-case (20%)",
                                "Eficiência e clareza do código (15%)",
                                "Documentação de erros comuns evitados (10%)"
                              ],
                              "crossCurricularConnections": [
                                "Estruturas de Dados: Pilha (stack) para gerenciamento hierárquico.",
                                "Algoritmos: Travessia recursiva de árvores.",
                                "Lógica e Verificação Formal: Estados consistentes em automatos.",
                                "Engenharia de Software: Padrão Visitor para extensibilidade."
                              ],
                              "realWorldApplication": "Em compiladores como GCC ou V8 (JavaScript), gerencia visibilidade de variáveis em funções, blocos e closures, prevenindo erros de nome e otimizando alocação de memória em escopos locais."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.2.2.3",
                            "name": "Armazenar atributos de identificadores",
                            "description": "Definir e armazenar atributos como tipo, endereço e escopo em entradas da tabela de símbolos para suporte à análise semântica.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os Atributos Essenciais de Identificadores",
                                  "subSteps": [
                                    "Identificar os atributos principais: tipo (ex: int, string), endereço (offset ou ponteiro de memória) e escopo (global, local, função).",
                                    "Analisar exemplos de código fonte para mapear identificadores a esses atributos.",
                                    "Estudar como atributos suportam análise semântica, como verificação de tipos.",
                                    "Diferenciar atributos mutáveis (ex: endereço calculado em runtime) de fixos (ex: tipo declarado).",
                                    "Revisar hierarquia de escopos e impacto nos atributos."
                                  ],
                                  "verification": "Descrever corretamente os três atributos principais e dar um exemplo de cada em um diagrama.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Livro 'Compilers: Principles, Techniques, and Tools' (Dragon Book)",
                                    "Notas de aula sobre análise semântica",
                                    "Exemplos de código em C ou pseudocódigo"
                                  ],
                                  "tips": "Use diagramas de Venn para visualizar sobreposições entre tipo, endereço e escopo.",
                                  "learningObjective": "Dominar a definição e propósito de cada atributo de identificador na tabela de símbolos.",
                                  "commonMistakes": "Confundir endereço com valor da variável ou ignorar escopo aninhado."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Projetar a Estrutura de Entrada na Tabela de Símbolos",
                                  "subSteps": [
                                    "Definir campos da estrutura: nome (string), tipo (enum ou string), endereço (int ou ponteiro), escopo (ID do escopo pai).",
                                    "Escolher representação de dados: struct em C, classe em Python ou mapa em JavaScript.",
                                    "Incluir campos auxiliares: visibilidade, inicializado (bool), usado (bool).",
                                    "Planejar chaves únicas: combinação de nome + escopo para evitar colisões.",
                                    "Documentar a estrutura em pseudocódigo ou UML."
                                  ],
                                  "verification": "Criar e apresentar um esboço da estrutura com pelo menos 4 campos obrigatórios.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Ferramenta de diagramação como Draw.io",
                                    "Exemplos de tabelas de símbolos de compiladores open-source (GCC)",
                                    "Editor de código"
                                  ],
                                  "tips": "Priorize campos que suportam análise semântica futura, como linha de declaração.",
                                  "learningObjective": "Projetar uma entrada robusta e escalável para armazenamento de atributos.",
                                  "commonMistakes": "Usar apenas nome como chave única, ignorando escopos aninhados."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar o Armazenamento de Atributos na Tabela",
                                  "subSteps": [
                                    "Implementar função de inserção: inserir ou atualizar entrada baseada em nome e escopo atual.",
                                    "Capturar atributos durante parsing: extrair tipo da declaração, calcular endereço relativo ao escopo.",
                                    "Gerenciar escopos: empilhar/despilhar tabelas para escopos aninhados.",
                                    "Tratar erros: duplicatas em mesmo escopo, tipos inválidos.",
                                    "Codificar em linguagem escolhida (ex: C struct array ou hashmap)."
                                  ],
                                  "verification": "Executar código com input de declarações e inspecionar tabela gerada.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Compilador/IDE (GCC, VS Code)",
                                    "Exemplos de código fonte simples com variáveis em escopos",
                                    "Debugger"
                                  ],
                                  "tips": "Use hash tables para busca O(1) em tabelas grandes.",
                                  "learningObjective": "Codificar mecanismos de armazenamento dinâmico de atributos em tabelas de símbolos.",
                                  "commonMistakes": "Não propagar escopo pai corretamente, levando a vazamentos de símbolos."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificar e Integrar Armazenamento com Análise Semântica",
                                  "subSteps": [
                                    "Implementar consultas: buscar atributo por nome e escopo.",
                                    "Testar com casos: escopos aninhados, redeclarações, shadowing.",
                                    "Integrar com fases semânticas: usar tipo armazenado para verificações.",
                                    "Debuggar: imprimir tabela em pontos chave.",
                                    "Otimizar: limpar escopos ao sair de blocos."
                                  ],
                                  "verification": "Rodar testes unitários que confirmem atributos corretos em 5 cenários diferentes.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Framework de testes (Unity para C, pytest para Python)",
                                    "Casos de teste prontos para tabelas de símbolos"
                                  ],
                                  "tips": "Sempre busque do escopo atual para cima na hierarquia.",
                                  "learningObjective": "Garantir integridade e usabilidade dos atributos armazenados na análise.",
                                  "commonMistakes": "Falhar em resolver shadowing, declarando múltiplos tipos para mesmo nome."
                                }
                              ],
                              "practicalExample": "Em um compilador para mini-linguagem: código 'int x = 5; { float x = 3.14; }' resulta em tabela com: escopo0: x(tipo:int, end:0, escopo:0); escopo1: x(tipo:float, end:4, escopo:1). Após sair de escopo1, escopo0.x é acessível novamente.",
                              "finalVerifications": [
                                "Tabela armazena tipo correto para identificadores declarados.",
                                "Endereços são calculados relativamente ao escopo atual.",
                                "Escopo pai é registrado corretamente em entradas aninhadas.",
                                "Busca por símbolo resolve no escopo mais interno primeiro.",
                                "Não há duplicatas inválidas ou vazamentos entre escopos.",
                                "Atributos suportam verificação semântica básica (ex: tipo mismatch)."
                              ],
                              "assessmentCriteria": [
                                "Estrutura da entrada inclui todos os atributos obrigatórios (tipo, endereço, escopo).",
                                "Implementação lida corretamente com escopos aninhados e shadowing.",
                                "Código é eficiente (busca rápida) e livre de erros comuns.",
                                "Testes cobrem pelo menos 80% dos casos edge (redeclarações, globals).",
                                "Integração com análise semântica usa atributos armazenados adequadamente.",
                                "Documentação explica design e uso da tabela."
                              ],
                              "crossCurricularConnections": [
                                "Programação: Estruturas de dados como hashmaps e árvores para tabelas.",
                                "Banco de Dados: Chaves compostas e índices semelhantes a tabelas relacionais.",
                                "Engenharia de Software: Gerenciamento de estado em sistemas distribuídos.",
                                "Lógica Matemática: Resolução de escopos como pilhas e contextos lógicos."
                              ],
                              "realWorldApplication": "Em compiladores como GCC ou Clang, tabelas de símbolos armazenam atributos para otimização de código, detecção de erros semânticos e geração de assembly eficiente, essencial em desenvolvimento de software e sistemas embarcados."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.2.2.4",
                            "name": "Buscar identificadores em escopos aninhados",
                            "description": "Implementar busca que inicia no escopo atual e sobe hierarquicamente até o global, resolvendo referências corretamente.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Definir a Estrutura de Classe para Escopos Aninhados",
                                  "subSteps": [
                                    "Crie uma classe Scope com um mapa (ex: unordered_map<string, Symbol*>) para armazenar símbolos locais.",
                                    "Adicione um ponteiro para o escopo pai (Scope* parent) para formar a hierarquia.",
                                    "Inclua campos auxiliares como string name (ex: 'global', 'functionX') e bool isGlobal.",
                                    "Implemente construtor para escopo global (parent = nullptr) e para escopos filhos.",
                                    "Adicione método para inserir símbolo, verificando duplicatas locais."
                                  ],
                                  "verification": "Compile a classe Scope sem erros e crie instâncias global e local com parent apontando corretamente.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Editor de código (VS Code ou IntelliJ), linguagem C++/Java/Python, documentação de mapas/hashtables.",
                                  "tips": "Use ponteiros inteligentes (shared_ptr) em C++ para gerenciar memória e evitar vazamentos em chains longas.",
                                  "learningObjective": "Modelar hierarquias de escopos usando composição e referências parentais.",
                                  "commonMistakes": "Esquecer de inicializar parent como nullptr no escopo global; permitir inserções duplicadas sem aviso."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar Busca de Identificador no Escopo Local",
                                  "subSteps": [
                                    "Crie método Symbol* lookupLocal(const string& id) que retorna o símbolo do mapa local se existir.",
                                    "Se não encontrado, retorne nullptr imediatamente.",
                                    "Adicione logs ou debug prints para rastrear consultas locais.",
                                    "Teste isoladamente inserindo símbolos e buscando locais.",
                                    "Garanta que o método seja const para não modificar o escopo."
                                  ],
                                  "verification": "Insira 'x' localmente e confirme que lookupLocal('x') retorna o símbolo correto; teste com ID ausente.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Unidade de teste simples (JUnit, Google Test ou asserts manuais), exemplos de símbolos (variáveis, funções).",
                                  "tips": "Use find() em mapas para eficiência O(1) ao invés de loop linear.",
                                  "learningObjective": "Implementar busca eficiente em estruturas de dados associativas para símbolos locais.",
                                  "commonMistakes": "Retornar nullptr sem diferenciar de símbolo nulo; modificar mapa durante busca."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar Busca Hierárquica Subindo a Cadeia de Pais",
                                  "subSteps": [
                                    "Crie método Symbol* lookup(const string& id) que chama lookupLocal primeiro.",
                                    "Se local falhar e parent != nullptr, chame recursivamente parent->lookup(id).",
                                    "Adicione limite de profundidade (ex: max 100) para evitar loops infinitos.",
                                    "Implemente versão iterativa alternativa com loop while(parent) para eficiência em chains profundas.",
                                    "Registre o caminho da busca (escopos percorridos) para debug."
                                  ],
                                  "verification": "Crie chain global -> func -> block; busque ID local em block (deve achar), global em block (deve subir).",
                                  "estimatedTime": "35 minutos",
                                  "materials": "Ferramentas de debug (gdb, debugger IDE), exemplos de código com nesting (funções aninhadas).",
                                  "tips": "Prefira iteração sobre recursão para evitar stack overflow em linguagens com limite de recursão.",
                                  "learningObjective": "Resolver referências navegando hierarquias dinâmicas de forma segura e eficiente.",
                                  "commonMistakes": "Loop infinito se parent ciclico; esquecer de parar no global (parent==nullptr)."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Tratar Casos Especiais e Integrar na Análise Semântica",
                                  "subSteps": [
                                    "Implemente suporte a shadowing: inserção local sobrescreve pai temporariamente.",
                                    "Adicione busca para built-ins (escopo global especial com funções pré-definidas).",
                                    "Integre lookup na visitor semântica: ao encontrar ID, chame scope->lookup e reporte erros.",
                                    "Lide com qualificadores (ex: ::global em C++ apontando direto para global).",
                                    "Otimize cache de resultados comuns em análises múltiplas."
                                  ],
                                  "verification": "Teste shadowing (local x=2 esconde global x=1); confirme built-ins resolvidos; erros em IDs indefinidos.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Parser simples ou mock para análise semântica, casos de teste com shadowing e built-ins.",
                                  "tips": "Sempre reporte linha/coluna do ID indefinido para diagnósticos úteis.",
                                  "learningObjective": "Gerenciar complexidades como sombreamento e namespaces em resoluções reais.",
                                  "commonMistakes": "Não detectar shadowing corretamente; buscar built-ins após chain normal."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Testar e Validar a Implementação Completa",
                                  "subSteps": [
                                    "Escreva suíte de testes: lookup local, chain simples, chain profunda, shadowing, indefinido.",
                                    "Simule análise em código fonte com escopos aninhados (ex: funcs dentro funcs).",
                                    "Meça performance em chains longas (100+ níveis).",
                                    "Corrija bugs baseados em falhas de teste.",
                                    "Documente API de lookup com exemplos."
                                  ],
                                  "verification": "100% pass em testes unitários; análise semântica resolve todos IDs corretamente sem falsos positivos.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Framework de testes, gerador de chains profundas, valgrind para leaks.",
                                  "tips": "Use dados-driven tests com múltiplos cenários em tabela.",
                                  "learningObjective": "Validar robustez através de testes abrangentes e cobertura.",
                                  "commonMistakes": "Testes insuficientes para edge cases como chain vazia ou só global."
                                }
                              ],
                              "practicalExample": "Considere este código:\nint globalVar = 10;\nvoid outer() {\n  int outerVar = 20;\n  void inner() {\n    int innerVar = 30;\n    print(globalVar); // Resolve para 10 (sobe chain)\n    print(outerVar);  // Resolve para 20\n    print(innerVar);  // Resolve local 30\n  }\n}\nImplemente scopes: global -> outer -> inner. lookup('globalVar') em inner deve subir até global.",
                              "finalVerifications": [
                                "Busca local retorna símbolo correto sem subir chain desnecessariamente.",
                                "Chain hierárquica resolve referências de escopos pais corretamente.",
                                "Escopo global atua como fallback final sem erros.",
                                "Shadowing permite locals sobrescreverem pais temporariamente.",
                                "IDs indefinidos geram erro com posição exata no código.",
                                "Sem loops infinitos ou stack overflow em chains profundas."
                              ],
                              "assessmentCriteria": [
                                "Correção: 100% dos lookups resolvem IDs conforme regras de escopo.",
                                "Eficiência: O(depth) tempo, sem buscas lineares desnecessárias.",
                                "Robustez: Lida com shadowing, built-ins e erros graciosamente.",
                                "Manutenibilidade: Código limpo com comentários e testes.",
                                "Escalabilidade: Funciona em programas com 100+ níveis de nesting.",
                                "Debuggabilidade: Logs e traces mostram caminho da resolução."
                              ],
                              "crossCurricularConnections": [
                                "Estruturas de Dados: Navegação em árvores/linked lists (hierarquia de escopos).",
                                "Algoritmos: Busca em grafos acíclicos direcionados (DAGs de escopos).",
                                "Linguagens de Programação: Namespaces e módulos (C++, Python).",
                                "Engenharia de Software: Design patterns (Composite para hierarquias)."
                              ],
                              "realWorldApplication": "Em compiladores como GCC/Clang, essa busca resolve nomes de variáveis/funções em C++ com blocos aninhados, lambdas e namespaces, permitindo detecção precoce de erros semânticos em projetos grandes como kernels Linux."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.5.2.3",
                        "name": "Resolução de Referências a Identificadores",
                        "description": "Processo de associar usos de identificadores às suas declarações correspondentes, verificando escopo e detectando erros semânticos.",
                        "specificSkills": [
                          {
                            "id": "10.1.5.2.3.1",
                            "name": "Resolver declarações e usos",
                            "description": "Durante a análise semântica, vincular cada referência a sua declaração no escopo apropriado, usando tabelas de símbolos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Construir Tabela de Símbolos para Escopos",
                                  "subSteps": [
                                    "Analise a AST para identificar escopos (funções, blocos, classes).",
                                    "Para cada escopo, crie uma entrada na tabela de símbolos com identificador único.",
                                    "Ao encontrar declarações (var, fun), insira na tabela do escopo atual com detalhes (tipo, posição).",
                                    "Herde tabelas de escopos pai para suporte a shadowing.",
                                    "Implemente push/pop de escopos durante traversais."
                                  ],
                                  "verification": "Verifique se a tabela contém todas declarações com escopos corretos via dump ou print.",
                                  "estimatedTime": "2 hours",
                                  "materials": [
                                    "AST parser código-fonte",
                                    "Exemplos de código com escopos aninhados",
                                    "Dragon Book capítulo sobre símbolos"
                                  ],
                                  "tips": "Use hash maps aninhados para tabelas; sempre entre com escopo global primeiro.",
                                  "learningObjective": "Dominar construção hierárquica de tabelas de símbolos para representar escopos.",
                                  "commonMistakes": [
                                    "Ignorar herança de escopos pai",
                                    "Inserir declarações em escopo errado",
                                    "Não tratar shadowing"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar e Marcar Referências (Usos) na AST",
                                  "subSteps": [
                                    "Traverse a AST pós-fix ou in-order para encontrar usos de identificadores (args, vars).",
                                    "Marque cada uso com um ponteiro temporário para binding futuro.",
                                    "Colete lista de usos pendentes por escopo atual.",
                                    "Ignore literais e keywords; foque apenas em IDs.",
                                    "Atualize AST nodes com flag 'unresolved' inicialmente."
                                  ],
                                  "verification": "Confirme que todos usos estão marcados e lista pendente não vazia para casos complexos.",
                                  "estimatedTime": "1.5 hours",
                                  "materials": [
                                    "AST visitor pattern implementação",
                                    "Código de teste com múltiplos usos",
                                    "Ferramenta de debug AST"
                                  ],
                                  "tips": "Use visitor pattern para traversais eficientes; logue usos encontrados.",
                                  "learningObjective": "Identificar precisamente referências em estruturas sintáticas.",
                                  "commonMistakes": [
                                    "Marcar declarações como usos",
                                    "Perder usos em expressões compostas",
                                    "Não escopar corretamente usos"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Executar Resolução de Referências via Lookup",
                                  "subSteps": [
                                    "Para cada uso marcado, inicie lookup no escopo local atual.",
                                    "Busque sequencialmente em escopo atual, pais até global.",
                                    "Ao encontrar match (nome exato), bind o uso à declaração (atualize ponteiro na AST).",
                                    "Se não encontrado, marque como erro e reporte.",
                                    "Otimize com caches se escopos profundos."
                                  ],
                                  "verification": "Simule resolução em código exemplo; verifique bindings via inspeção AST.",
                                  "estimatedTime": "2.5 hours",
                                  "materials": [
                                    "Implementação de SymbolTable class",
                                    "Código teste com shadowing e forward refs",
                                    "Debugger stepwise"
                                  ],
                                  "tips": "Prefira matches mais próximos (shadowing); valide tipos durante bind opcional.",
                                  "learningObjective": "Implementar algoritmo de resolução eficiente com busca em escopos aninhados.",
                                  "commonMistakes": [
                                    "Buscar em escopo errado primeiro",
                                    "Não parar em primeiro match",
                                    "Ignorar forward references"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Validar Bindings e Integrar na Análise Semântica",
                                  "subSteps": [
                                    "Traverse AST novamente para verificar todos usos resolvidos.",
                                    "Reporte erros semânticos (undeclared, tipo mismatch).",
                                    "Propague informações de tipo das declarações para usos.",
                                    "Atualize tabela de símbolos com bindings finais.",
                                    "Teste end-to-end com compilação simulada."
                                  ],
                                  "verification": "Execute testes unitários; zero erros de resolução em suíte de testes.",
                                  "estimatedTime": "2 hours",
                                  "materials": [
                                    "Suite de testes para compilador mini",
                                    "Error reporting framework",
                                    "Type checker stub"
                                  ],
                                  "tips": "Integre com phase de type checking; use warnings para ambiguidades.",
                                  "learningObjective": "Garantir integridade semântica pós-resolução.",
                                  "commonMistakes": [
                                    "Não validar pós-bind",
                                    "Reportar falsos positivos",
                                    "Quebrar AST durante updates"
                                  ]
                                }
                              ],
                              "practicalExample": "Em código: int globalX = 10; void func() { int localX = 20; print(localX); print(globalX); } Resolução: print(localX) binds a localX (escopo func), print(globalX) a globalX (escopo global). Implemente tabela: global {globalX: decl1}, func {localX: decl2} herda global.",
                              "finalVerifications": [
                                "Todas referências bindadas corretamente em escopos aninhados.",
                                "Shadowing resolvido priorizando escopo local.",
                                "Erros reportados para identificadores não declarados.",
                                "Forward references dentro de escopo resolvidas.",
                                "Performance aceitável em ASTs de 1000+ nodes.",
                                "Integração com type checking sem conflitos."
                              ],
                              "assessmentCriteria": [
                                "Precisão: 100% de bindings corretos em testes.",
                                "Cobertura: Trata escopos globais, locais, aninhados.",
                                "Eficiência: O(n) tempo para resolução.",
                                "Robustez: Lida com erros graciosamente.",
                                "Manutenibilidade: Código modular com SymbolTable.",
                                "Testabilidade: Cobertura >90% com unit tests."
                              ],
                              "crossCurricularConnections": [
                                "Estruturas de Dados: Hash tables e árvores para escopos.",
                                "Algoritmos: Busca em grafos hierárquicos.",
                                "Lógica: Validação de proposições semânticas.",
                                "Matemática: Teoria de conjuntos para símbolos únicos."
                              ],
                              "realWorldApplication": "Em compiladores como GCC/Clang para type checking e otimização; IDEs (VSCode, IntelliJ) para autocomplete, go-to-definition e refactoring seguro em linguagens como C++, Java, Python."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.2.3.2",
                            "name": "Detectar erros de escopo",
                            "description": "Identificar e reportar erros como uso antes de declaração, identificador não declarado ou ambiguidade em escopos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender conceitos de escopo e tabela de símbolos",
                                  "subSteps": [
                                    "Estude os tipos de escopo: global, local (função), bloco.",
                                    "Aprenda a estrutura de uma tabela de símbolos: identificador, tipo, escopo pai, posição de declaração.",
                                    "Implemente uma tabela de símbolos simples em pseudocódigo ou Python para simular escopos aninhados.",
                                    "Pratique inserindo declarações em escopos corretos.",
                                    "Visualize a tabela após parsing de um código simples."
                                  ],
                                  "verification": "Crie uma tabela de símbolos para um código com 3 escopos aninhados e confirme que as entradas estão corretas.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Documentação de análise semântica",
                                    "Editor de código (VS Code)",
                                    "Exemplos de código fonte simples"
                                  ],
                                  "tips": "Use uma pilha de tabelas para representar escopos aninhados dinamicamente.",
                                  "learningObjective": "Dominar a representação de escopos via tabelas de símbolos.",
                                  "commonMistakes": [
                                    "Confundir escopo local com global",
                                    "Não empilhar/pop escopos corretamente"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Detectar uso antes de declaração",
                                  "subSteps": [
                                    "Durante a fase de resolução de referências, verifique se o identificador foi declarado antes de seu uso no escopo atual ou ancestrais.",
                                    "Implemente uma busca linear na pilha de tabelas de cima para baixo.",
                                    "Ao encontrar uma referência sem declaração prévia, marque como erro 'uso antes de declaração'.",
                                    "Teste com código onde variável é usada antes de 'let' ou 'var'.",
                                    "Registre a linha e posição exata do erro."
                                  ],
                                  "verification": "Analise um código com uso antes de declaração e gere relatório correto sem falsos positivos.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Código de teste com erros intencionais",
                                    "AST parser simples"
                                  ],
                                  "tips": "Busque primeiro no escopo local, depois em ancestrais, parando no primeiro match.",
                                  "learningObjective": "Identificar e reportar precisamente usos prematuros de variáveis.",
                                  "commonMistakes": [
                                    "Buscar em ordem reversa",
                                    "Ignorar shadowing de variáveis"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Detectar identificador não declarado",
                                  "subSteps": [
                                    "Para cada referência, busque exaustivamente na pilha de escopos; se não encontrado, reporte 'identificador não declarado'.",
                                    "Diferencie de 'uso antes de declaração' checando se existe em qualquer escopo acessível.",
                                    "Implemente logging com mensagem clara incluindo nome do ID e linha.",
                                    "Teste com referências a funções ou variáveis inexistentes.",
                                    "Integre com o passo anterior para priorizar erros."
                                  ],
                                  "verification": "Compile um código com ID não declarado e confirme detecção sem erros em códigos válidos.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Exemplos de código com IDs ausentes",
                                    "Ferramenta de linting para validação"
                                  ],
                                  "tips": "Mantenha um contador de erros para relatório final.",
                                  "learningObjective": "Detectar referências a elementos indefinidos no programa.",
                                  "commonMistakes": [
                                    "Reportar falso positivo em escopos shadowed",
                                    "Não checar escopos globais"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Detectar e resolver ambiguidades em escopos",
                                  "subSteps": [
                                    "Identifique ambiguidades quando múltiplos IDs com mesmo nome em escopos acessíveis (shadowing inválido).",
                                    "Implemente regras: shadowing só permitido se tipos compatíveis ou em blocos distintos.",
                                    "Reporte 'ambiguidade de escopo' com lista de candidatos.",
                                    "Pratique com nested functions e blocos condicionais.",
                                    "Gere relatório consolidado com todos os erros de escopo."
                                  ],
                                  "verification": "Analise código com shadowing ambíguo e produza relatório preciso.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Códigos complexos com ambiguidades",
                                    "Diagrama de escopos"
                                  ],
                                  "tips": "Use depth-first search na pilha para detectar múltiplos matches.",
                                  "learningObjective": "Gerenciar e reportar conflitos de nomes em hierarquias de escopo.",
                                  "commonMistakes": [
                                    "Permitir shadowing sempre",
                                    "Não reportar em escopos deeply nested"
                                  ]
                                }
                              ],
                              "practicalExample": "Considere o código: function foo() { x = 10; var x = 20; } // Erro: uso antes de declaração. function bar() { print(y); } // Erro: y não declarado. if (true) { var z = 5; } print(z); // OK, hoisting em alguns langs, mas detecte ambiguidade se shadowed.",
                              "finalVerifications": [
                                "Lista corretamente 3 tipos de erros de escopo em código teste.",
                                "Gera tabela de símbolos completa sem vazamentos de escopo.",
                                "Reporta posições exatas de erros (linha/coluna).",
                                "Passa em 5 testes unitários de detecção.",
                                "Diferencia uso antes vs. não declarado corretamente.",
                                "Detecta ambiguidades em 80% dos casos complexos."
                              ],
                              "assessmentCriteria": [
                                "Precisão na detecção: zero falsos positivos/negativos.",
                                "Completude do relatório: todos erros listados com detalhes.",
                                "Eficiência: tempo de análise O(n) para AST.",
                                "Clareza das mensagens de erro.",
                                "Correta manipulação de escopos aninhados.",
                                "Integração com fases anteriores de análise semântica."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Árvores e grafos para AST e escopos.",
                                "Lógica: Resolução de referências como busca em estruturas hierárquicas.",
                                "Programação: Implementação em linguagens como Python ou C++.",
                                "Linguística: Analogia com escopos semânticos em linguagem natural."
                              ],
                              "realWorldApplication": "Em compiladores como GCC/Clang para C++, ou analisadores em IDEs como IntelliJ/VSCode, detectando erros em tempo real para melhorar produtividade de desenvolvedores e prevenir bugs em software crítico."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.2.3.3",
                            "name": "Tratar referências cruzadas entre escopos",
                            "description": "Gerenciar referências de funções ou parâmetros que transcendem escopos locais, garantindo resolução correta em chamadas.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender Escopos e Referências Cruzadas",
                                  "subSteps": [
                                    "Defina escopo léxico e dinâmico com exemplos de linguagens como C e Python.",
                                    "Identifique referências cruzadas: usos de identificadores declarados em escopos ancestrais.",
                                    "Estude shadowing: quando identificadores locais ocultam globais.",
                                    "Analise exemplos de código com erros de resolução de escopo.",
                                    "Crie um diagrama de árvore de escopos para um programa simples."
                                  ],
                                  "verification": "Desenhe um diagrama de escopos para um código fornecido e explique resoluções corretas.",
                                  "estimatedTime": "2 horas",
                                  "materials": "Documentação de linguagens (C, Python), exemplos de código fonte, papel e caneta para diagramas.",
                                  "tips": "Use cores diferentes para escopos pai e filho no diagrama para visualização clara.",
                                  "learningObjective": "Dominar os fundamentos teóricos de escopos e identificar referências cruzadas.",
                                  "commonMistakes": "Confundir escopo léxico com dinâmico; ignorar shadowing."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar Tabela de Símbolos Hierárquica",
                                  "subSteps": [
                                    "Crie uma classe Scope com mapa de símbolos (nome -> declaração) e ponteiro para escopo pai.",
                                    "Implemente pushScope() e popScope() para gerenciar pilha de escopos durante parsing.",
                                    "Adicione lookup local: busque no escopo atual primeiro.",
                                    "Estenda para lookup recursivo: suba na hierarquia até encontrar o símbolo.",
                                    "Teste com inserções em diferentes níveis de escopo."
                                  ],
                                  "verification": "Insira símbolos em escopos aninhados e execute lookups bem-sucedidos sem vazamentos.",
                                  "estimatedTime": "3 horas",
                                  "materials": "Linguagem de programação (Python ou Java), IDE com depurador.",
                                  "tips": "Use recursão com profundidade máxima para evitar stack overflow em testes.",
                                  "learningObjective": "Construir uma estrutura de dados que suporte navegação entre escopos.",
                                  "commonMistakes": "Não tratar null em escopo pai; lookup sem checar shadowing."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Desenvolver Algoritmo de Resolução de Referências",
                                  "subSteps": [
                                    "Durante análise semântica, para cada uso de identificador, chame resolveReference(id).",
                                    "No resolveReference: procure no escopo atual, depois recursivamente no pai.",
                                    "Registre binding: associe uso à declaração encontrada.",
                                    "Lide com funções/parâmetros: verifique tipos e aridade em chamadas cruzadas.",
                                    "Gere erros para referências não resolvidas ou ambiguidades."
                                  ],
                                  "verification": "Parse um AST com referências cruzadas e confirme que todos os bindings estão corretos.",
                                  "estimatedTime": "4 horas",
                                  "materials": "Parser simples (ANTLR ou handmade), AST walker.",
                                  "tips": "Registre caminhos de lookup em logs para depuração visual.",
                                  "learningObjective": "Implementar resolução precisa de referências entre escopos.",
                                  "commonMistakes": "Resolução infinita sem parada em escopo global; ignorar sobrecarga de funções."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Testar e Otimizar com Casos Especiais",
                                  "subSteps": [
                                    "Crie testes unitários: shadowing, recursão mútua, parâmetros default.",
                                    "Teste performance em árvores de escopo profundas (cache opcional).",
                                    "Integre com análise de tipos para validação cruzada.",
                                    "Depure falhas comuns como forward references em escopos irmãos.",
                                    "Refatore para eficiência: use chains de escopos ou caching."
                                  ],
                                  "verification": "Execute suíte de testes com 100% cobertura e zero falhas em resolução.",
                                  "estimatedTime": "2 horas",
                                  "materials": "Framework de testes (JUnit/Pytest), benchmarks simples.",
                                  "tips": "Priorize testes edge-case primeiro para validar robustez.",
                                  "learningObjective": "Garantir que o sistema lida com cenários reais e performa bem.",
                                  "commonMistakes": "Testes insuficientes para escopos não-lineares; otimização prematura."
                                }
                              ],
                              "practicalExample": "Em um compilador para uma linguagem similar a C: função global 'int globalVar = 10;' usada dentro de uma função local em outro módulo via include. O resolvedor deve subir da função local -> módulo local -> global scope, binding corretamente apesar de shadowing parcial.",
                              "finalVerifications": [
                                "Todas as referências em um programa de teste com 5 escopos aninhados resolvem corretamente.",
                                "Shadowing é respeitado: variáveis locais ocultam globais sem erros.",
                                "Erros são gerados para identificadores não declarados em qualquer escopo.",
                                "Tipos de funções/parâmetros em chamadas cruzadas são validados.",
                                "Performance: resolução em <1ms para 1000 referências.",
                                "Nenhum vazamento de escopo após popScope() múltiplos."
                              ],
                              "assessmentCriteria": [
                                "Precisão: 100% de resoluções corretas em suíte de testes.",
                                "Robustez: Lida com escopos profundos (>10 níveis) sem crash.",
                                "Eficiência: Tempo de lookup O(profundidade) médio.",
                                "Clareza: Código comentado com explicações de lookup paths.",
                                "Extensibilidade: Fácil adicionar suporte a módulos/namespaces.",
                                "Documentação: README com diagramas de escopos de exemplo."
                              ],
                              "crossCurricularConnections": [
                                "Linguagens de Programação: Entender closures em JS/Python.",
                                "Análise Estática: Similar a symbol resolution em linters como ESLint.",
                                "Engenharia de Software: Gerenciamento de dependências em builds (npm/Webpack).",
                                "Teoria da Computação: Autômatos e pilhas para parsing.",
                                "Bancos de Dados: Resolução de nomes em schemas relacionais."
                              ],
                              "realWorldApplication": "Em compiladores como GCC/Clang para C++, resolve referências entre translation units via linker symbols; em IDEs como VSCode IntelliSense para navegação rápida em grandes codebases."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.5.3",
                    "name": "Gerenciamento de Tabelas de Símbolos",
                    "description": "Organização e manipulação de tabelas para armazenar atributos semânticos de símbolos.",
                    "individualConcepts": [
                      {
                        "id": "10.1.5.3.1",
                        "name": "Estruturas de Dados para Tabelas de Símbolos",
                        "description": "Definição e escolha de estruturas adequadas para armazenar símbolos e seus atributos semânticos, como tabelas hash, árvores balanceadas ou listas encadeadas, considerando eficiência em inserção, busca e gerenciamento de memória.",
                        "specificSkills": [
                          {
                            "id": "10.1.5.3.1.1",
                            "name": "Identificar estruturas de dados para tabelas de símbolos",
                            "description": "Comparar tabelas hash, árvores binárias de busca e pilhas de escopos, avaliando complexidade temporal O(1) para hash e O(log n) para árvores em compiladores.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o Conceito de Tabelas de Símbolos em Compiladores",
                                  "subSteps": [
                                    "Defina tabela de símbolos e seu papel na análise semântica.",
                                    "Identifique operações principais: inserção, busca e remoção de símbolos.",
                                    "Explique a necessidade de suporte a escopos aninhados em linguagens block-structured.",
                                    "Discuta desafios como colisões de nomes em diferentes escopos.",
                                    "Revise exemplos de símbolos: variáveis, funções e tipos."
                                  ],
                                  "verification": "Escreva um parágrafo resumindo o propósito das tabelas de símbolos e liste 3 operações chave.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Capítulo 2 do 'Dragon Book' (Compilers: Principles, Techniques, and Tools)",
                                    "Notas de aula sobre análise semântica"
                                  ],
                                  "tips": "Associe tabelas de símbolos a um 'dicionário' que o compilador consulta durante a tradução.",
                                  "learningObjective": "Entender a função fundamental das tabelas de símbolos no fluxo de compilação.",
                                  "commonMistakes": "Confundir tabelas de símbolos com tabelas de análise léxica ou sintática."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar Tabelas Hash como Estrutura de Dados",
                                  "subSteps": [
                                    "Estude funções hash e resolução de colisões (chaining ou open addressing).",
                                    "Descreva inserção, busca e remoção em tabelas hash.",
                                    "Analise complexidade temporal: O(1) médio para operações principais.",
                                    "Discuta adaptação para tabelas de símbolos: hashing de nomes de identificadores.",
                                    "Implemente pseudocódigo simples para busca de símbolo."
                                  ],
                                  "verification": "Implemente e teste pseudocódigo de busca em hash table com 5 entradas exemplo.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Implementação em Python/C de hash tables",
                                    "CLRS (Introduction to Algorithms), capítulo sobre hash tables"
                                  ],
                                  "tips": "Use hashes consistentes para nomes como 'x' e 'main' para evitar colisões artificiais.",
                                  "learningObjective": "Dominar tabelas hash e sua complexidade O(1) para lookups rápidos.",
                                  "commonMistakes": "Ignorar casos ruins de hash levando a O(n) worst-case."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explorar Árvores Binárias de Busca (BST)",
                                  "subSteps": [
                                    "Revise estrutura de BST: nós com chaves, filhos esquerdo/direito.",
                                    "Detalhe inserção, busca e remoção balanceadas.",
                                    "Calcule complexidade: O(log n) para operações em árvores balanceadas.",
                                    "Adapte para tabelas de símbolos: ordenação lexicográfica de nomes.",
                                    "Compare com AVL ou Red-Black para balanceamento."
                                  ],
                                  "verification": "Desenhe uma BST com 7 símbolos e trace uma busca para 'var3'.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Visualizador de BST online (ex: VisuAlgo)",
                                    "CLRS, capítulo sobre árvores de busca"
                                  ],
                                  "tips": "Sempre insira em ordem para visualizar degenerescência em listas ligadas.",
                                  "learningObjective": "Compreender BST e sua complexidade O(log n) garantida com balanceamento.",
                                  "commonMistakes": "Esquecer que BST não balanceadas viram O(n)."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Estudar Pilhas de Escopos para Gerenciamento Hierárquico",
                                  "subSteps": [
                                    "Explique pilha de escopos: topo para escopo atual, pop em fim de bloco.",
                                    "Descreva shadowing: símbolos locais ocultam globais.",
                                    "Integre com hash/BST: cada frame da pilha é uma hash ou BST.",
                                    "Trace resolução de nomes em código com { } aninhados.",
                                    "Analise complexidade: depende da estrutura subjacente + O(1) push/pop."
                                  ],
                                  "verification": "Simule pilha para código com 3 escopos aninhados e resolva 3 lookups.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Exemplos de código C/Python com escopos",
                                    "Notas sobre symbol tables em compiladores"
                                  ],
                                  "tips": "Pense na pilha como frames de pilha de execução, mas para símbolos.",
                                  "learningObjective": "Aplicar pilhas para modelar escopos léxicos estáticos.",
                                  "commonMistakes": "Confundir escopos estáticos (léxicos) com dinâmicos (runtime)."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Comparar Estruturas e Avaliar Complexidades",
                                  "subSteps": [
                                    "Tabela comparativa: hash vs BST vs pilha (complexidade, prós/contras).",
                                    "Avalie O(1) hash vs O(log n) BST para n=10^6 símbolos.",
                                    "Discuta trade-offs: memória, worst-case, ordenação.",
                                    "Escolha estrutura por caso: hash para velocidade, BST para iteração ordenada.",
                                    "Simule benchmarks fictícios para validação."
                                  ],
                                  "verification": "Crie tabela Markdown comparando 3 estruturas com complexidades e 2 prós/contras cada.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Planilha para benchmarks",
                                    "Artigos sobre symbol tables em LLVM/GCC"
                                  ],
                                  "tips": "Use Big-O notation rigorosa: especifique average/worst/best.",
                                  "learningObjective": "Comparar criticamente estruturas para seleção otimizada em compiladores.",
                                  "commonMistakes": "Afirmar O(1) sempre para hash sem mencionar worst-case."
                                }
                              ],
                              "practicalExample": "Em um compilador mini para uma linguagem como Mini-C, implemente uma tabela de símbolos usando pilha de hash tables: ao entrar em uma função { }, push nova hash table; lookup busca do topo para baixo. Teste com código: int x=1; { int x=2; print(x); } // deve imprimir 2, resolvendo shadowing em O(1) médio.",
                              "finalVerifications": [
                                "Explique por que hash é preferida para lookups frequentes em compiladores.",
                                "Calcule número de comparações em BST para busca em árvore de altura 10.",
                                "Trace resolução de 'x' em 3 escopos aninhados com pilha.",
                                "Liste 2 cenários onde BST supera hash.",
                                "Descreva impacto de colisões em hash tables de símbolos.",
                                "Compare memória: hash vs BST para 1000 símbolos."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de complexidades O(1) e O(log n) (peso 25%).",
                                "Correta modelagem de pilhas de escopos com shadowing (20%).",
                                "Tabela comparativa completa com prós/contras (20%).",
                                "Pseudocódigo funcional para pelo menos uma estrutura (15%).",
                                "Explicações claras de trade-offs em contextos reais (10%).",
                                "Ausência de erros comuns como confusão de escopos (10%)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Análise assintótica e notação Big-O.",
                                "Algoritmos: Estruturas de dados avançadas (CLRS).",
                                "Engenharia de Software: Otimização de performance em ferramentas.",
                                "Linguagens: Escopos léxicos em Python/Java/C++."
                              ],
                              "realWorldApplication": "Em compiladores como GCC e LLVM, tabelas hash com pilhas de escopos aceleram resolução de nomes em projetos grandes (milhões de linhas), reduzindo tempo de compilação de horas para minutos; usado em IDEs para autocompletar e refatoração."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.3.1.2",
                            "name": "Implementar tabela hash para símbolos",
                            "description": "Criar uma tabela hash com resolução de colisões por encadeamento, armazenando identificadores, tipos e escopos de variáveis em linguagens como C ou Pascal.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Definir estruturas de dados para a tabela hash",
                                  "subSteps": [
                                    "Crie uma struct para o nó da lista encadeada, contendo identificador (string), tipo (enum ou string), escopo (int) e ponteiro para próximo nó.",
                                    "Defina a struct da tabela hash com array de ponteiros para listas encadeadas (buckets) e tamanho do array (ex: 101 buckets).",
                                    "Implemente typedefs para clareza, como SymbolEntry e HashTable.",
                                    "Inicialize a tabela alocando memória para os buckets e definindo ponteiro next como NULL nos nós vazios.",
                                    "Adicione função para criar uma nova tabela vazia."
                                  ],
                                  "verification": "Compilar o código sem erros e imprimir a tabela inicial mostrando todos buckets como NULL.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Compilador C (GCC)",
                                    "Editor de texto (VS Code)",
                                    "Documentação de malloc/free em C"
                                  ],
                                  "tips": "Use tamanhos de tabela primos para melhor distribuição; comece com 101 buckets.",
                                  "learningObjective": "Compreender e implementar as estruturas fundamentais para tabela hash com encadeamento.",
                                  "commonMistakes": [
                                    "Esquecer de inicializar ponteiros para NULL",
                                    "Não usar malloc para alocação dinâmica",
                                    "Definir structs sem considerar alinhamento de memória"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar função de hash e cálculo de índice",
                                  "subSteps": [
                                    "Escolha uma função hash simples como djb2 ou multiplicação por primo (ex: 31 * hash + char).",
                                    "Converta string do identificador em hash unsigned long.",
                                    "Calcule índice como hash % tamanho_da_tabela, garantindo índice válido (0 a tamanho-1).",
                                    "Teste a função com strings como 'x', 'var1', 'scope1' e verifique distribuição em buckets.",
                                    "Adicione tratamento para strings vazias ou NULL."
                                  ],
                                  "verification": "Executar testes unitários imprimindo hash e índice para 10 identificadores variados, confirmando uniformidade.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Compilador C",
                                    "Funções hash de referência online",
                                    "Strings de teste pré-definidas"
                                  ],
                                  "tips": "Evite overflow com unsigned long; teste com colisões intencionais.",
                                  "learningObjective": "Dominar o cálculo de hash eficiente para chaves string em contextos de símbolos.",
                                  "commonMistakes": [
                                    "Hash case-sensitive sem normalização",
                                    "Divisão por zero ou tamanho zero",
                                    "Ignorar caracteres maiúsculos/minúsculos"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar inserção com resolução de colisões por encadeamento",
                                  "subSteps": [
                                    "Na função insert, calcule hash e índice, vá para o bucket.",
                                    "Se bucket vazio, crie novo nó com malloc e insira dados (id, tipo, escopo).",
                                    "Se colisão, percorra lista até fim e adicione novo nó no final.",
                                    "Atualize ponteiro next corretamente e verifique duplicatas (não inserir se id+escopo já existe).",
                                    "Libere memória apenas em remoção, não em insert."
                                  ],
                                  "verification": "Inserir 5 símbolos com colisões intencionais e imprimir tabela mostrando encadeamento correto.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Compilador C",
                                    "Função de print da tabela para debug"
                                  ],
                                  "tips": "Use ponteiro auxiliar para percorrer lista sem perder cabeça; sempre cheque malloc falhou.",
                                  "learningObjective": "Implementar inserção robusta lidando com colisões via listas ligadas.",
                                  "commonMistakes": [
                                    "Ciclos infinitos por ponteiro next errado",
                                    "Inserir duplicatas sem checagem",
                                    "Memory leak por não usar malloc"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Implementar busca, remoção e gerenciamento de escopos",
                                  "subSteps": [
                                    "Função lookup: calcule hash/índice, percorra lista comparando id e escopo exatos.",
                                    "Função remove: similar a lookup, mas libere nó com free e ajuste ponteiros next.",
                                    "Para escopos, implemente push/pop de tabelas (pilha para blocos aninhados).",
                                    "Teste busca em escopo específico ignorando símbolos de escopos filhos/pais.",
                                    "Adicione função print_table para visualizar toda estrutura."
                                  ],
                                  "verification": "Executar sequência: insert 10 símbolos em escopos 1-3, lookup/remove 5, imprimir sem vazamentos (use valgrind).",
                                  "estimatedTime": "75 minutos",
                                  "materials": [
                                    "Valgrind para leaks",
                                    "Compilador C",
                                    "Casos de teste com escopos aninhados"
                                  ],
                                  "tips": "Gerencie pilha de tabelas para escopos; compare escopo na busca para precisão semântica.",
                                  "learningObjective": "Completar operações CRUD com suporte a escopos hierárquicos em compiladores.",
                                  "commonMistakes": [
                                    "Remover nó errado ajustando ponteiros",
                                    "Buscar em escopo errado",
                                    "Não tratar lista vazia"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Testar e otimizar a tabela hash em contexto de compilador",
                                  "subSteps": [
                                    "Crie mini-parser simples para declarações como 'int x; scope 1;' e insira símbolos.",
                                    "Meça tempo de insert/lookup para 1000 símbolos e calcule fator de carga.",
                                    "Otimize redimensionando tabela se load factor > 0.7 (rehash).",
                                    "Integre em loop de análise semântica simulada.",
                                    "Documente código com comentários."
                                  ],
                                  "verification": "Rodar testes completos com 100+ operações, assert 100% acertos em lookups, sem crashes ou leaks.",
                                  "estimatedTime": "90 minutos",
                                  "materials": [
                                    "Valgrind",
                                    "Timer em C (clock())",
                                    "Parser simples lexer-free"
                                  ],
                                  "tips": "Monitore load factor; rehash dobra tamanho e re-insere tudo.",
                                  "learningObjective": "Validar implementação em cenário real de compilador com performance.",
                                  "commonMistakes": [
                                    "Rehash sem copiar dados antigos",
                                    "Ignorar performance em testes pequenos",
                                    "Parser com erros de sintaxe"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um compilador para Pascal, ao processar 'var x: integer; begin y: real; end;', crie tabela com escopo 0 para 'x:integer', push escopo 1, insira 'y:real', pop escopo. Lookup 'x' em escopo 1 retorna escopo 0, 'y' retorna escopo 1.",
                              "finalVerifications": [
                                "Tabela insere/busca sem perda de dados para 100 símbolos com 30% colisões.",
                                "Gerenciamento de escopos push/pop isola símbolos corretamente.",
                                "Sem memory leaks ou dangling pointers (valgrind clean).",
                                "Tempo médio de lookup < 5us para 1000 símbolos.",
                                "Função hash distribui uniformemente (max 10% buckets vazios).",
                                "Remove não quebra encadeamento restante."
                              ],
                              "assessmentCriteria": [
                                "Correção: Todas operações CRUD funcionam sem bugs em testes edge-case.",
                                "Eficiência: Load factor gerenciado, O(1) médio para operações.",
                                "Robustez: Trata NULL, duplicatas, escopos hierárquicos.",
                                "Código limpo: Bem comentado, structs claras, sem warnings de compilação.",
                                "Escalabilidade: Rehash implementado para crescimento.",
                                "Integração: Funciona em mini-contexto de análise semântica."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria de números primos e funções hash modulares.",
                                "Algoritmos: Listas ligadas e análise de complexidade amortizada.",
                                "Engenharia de Software: Gerenciamento de memória e debugging com Valgrind.",
                                "Linguagens de Programação: Estruturas em C/Pascal para compiladores.",
                                "Análise Semântica: Conceitos de escopos e símbolos em teoria da compilação."
                              ],
                              "realWorldApplication": "Usado em compiladores como GCC/Clang para rastrear variáveis durante análise semântica, evitando erros de redeclaração e resolvendo escopos em blocos if/while; também em IDEs para autocompletar e depuração."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.3.1.3",
                            "name": "Definir atributos semânticos em entradas de tabela",
                            "description": "Especificar campos como nome, tipo (int, float), escopo, visibilidade e endereço de memória para cada símbolo na tabela.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender os atributos semânticos essenciais para entradas de tabela",
                                  "subSteps": [
                                    "Revise a definição de atributos semânticos: nome, tipo de dado (ex: int, float), escopo (local/global), visibilidade (public/private) e endereço de memória.",
                                    "Estude exemplos de símbolos em código fonte, como variáveis, funções e constantes.",
                                    "Liste os atributos obrigatórios para diferentes tipos de símbolos (variáveis vs. funções).",
                                    "Compare com estruturas de tabelas de símbolos em compiladores reais, como LLVM ou GCC.",
                                    "Anote como cada atributo impacta a análise semântica subsequente."
                                  ],
                                  "verification": "Crie um glossário pessoal com definições e exemplos de cada atributo; revise se cobre todos os 5 atributos principais.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Documentação de compiladores (ex: Dragon Book PDF), papel e caneta ou editor de notas.",
                                  "tips": "Use mnemônicos como 'NT-SVA' (Nome, Tipo, Escopo, Visibilidade, Endereço) para memorizar.",
                                  "learningObjective": "Compreender o papel e propósito de cada atributo semântico em uma entrada de tabela.",
                                  "commonMistakes": "Confundir visibilidade (acesso) com escopo (visibilidade léxica); ignorar endereço de memória em símbolos primitivos."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar um símbolo em código fonte e mapear atributos iniciais",
                                  "subSteps": [
                                    "Selecione um trecho de código fonte simples com declarações de variáveis.",
                                    "Identifique o símbolo (ex: variável 'int x;') e extraia o nome diretamente do identificador.",
                                    "Determine o tipo de dado analisando a declaração (int, float, etc.).",
                                    "Avalie o escopo baseado no contexto (função local ou global).",
                                    "Inferir visibilidade e reservar espaço para endereço de memória (simulado ou real)."
                                  ],
                                  "verification": "Anote os 5 atributos para 3 símbolos diferentes; confirme com um colega ou ferramenta de linting.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Editor de código (VS Code), exemplos de código C simples.",
                                  "tips": "Comece com código em C ou Java para simplicidade; use parse trees se disponível.",
                                  "learningObjective": "Extrair e mapear atributos semânticos de forma precisa a partir de código fonte.",
                                  "commonMistakes": "Assumir tipo sem verificar qualificadores (ex: unsigned int); ignorar escopo aninhado em blocos."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Estruturar e popular a entrada da tabela de símbolos",
                                  "subSteps": [
                                    "Crie uma estrutura de dados para a entrada (ex: struct em pseudocódigo com campos nome, tipo, etc.).",
                                    "Preencha cada campo com valores mapeados, convertendo para formatos padronizados (ex: tipo como enum).",
                                    "Atribua um endereço de memória simulado (ex: offset crescente).",
                                    "Adicione metadados opcionais como linha de declaração.",
                                    "Valide consistência interna (ex: tipo compatível com escopo)."
                                  ],
                                  "verification": "Implemente a entrada em JSON ou código e serialize para visualização; cheque por campos vazios.",
                                  "estimatedTime": "50 minutos",
                                  "materials": "Pseudocódigo ou Python para protótipo de tabela, calculadora para offsets de memória.",
                                  "tips": "Use hashes para nomes únicos; padronize tipos com strings como 'int32' para portabilidade.",
                                  "learningObjective": "Construir uma entrada de tabela completa e consistente com atributos semânticos.",
                                  "commonMistakes": "Sobrescrever endereços em escopos aninhados; usar strings não normalizadas para tipos."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificar e integrar a entrada na tabela de símbolos",
                                  "subSteps": [
                                    "Insira a entrada em uma tabela hierárquica (escopos pai-filho).",
                                    "Busque conflitos (ex: nome duplicado no mesmo escopo).",
                                    "Simule lookup e resolução de símbolos usando a tabela.",
                                    "Atualize atributos dinamicamente se necessário (ex: endereço após alocação).",
                                    "Documente a entrada para depuração futura."
                                  ],
                                  "verification": "Execute uma simulação de compilação em código de teste; confirme que todos símbolos resolvem corretamente.",
                                  "estimatedTime": "40 minutos",
                                  "materials": "Implementação simples de tabela em Python ou JavaScript.",
                                  "tips": "Implemente com dicts aninhados para escopos; teste com código com múltiplas declarações.",
                                  "learningObjective": "Integrar e validar entradas em uma tabela funcional de símbolos.",
                                  "commonMistakes": "Não lidar com shadowing de símbolos; falhar em lookups cross-escopo."
                                }
                              ],
                              "practicalExample": "Dado o código C: 'int globalVar; void func() { float localVar; }' - Crie entradas: Para 'globalVar': {nome: 'globalVar', tipo: 'int', escopo: 'global', visibilidade: 'public', endereco: 0x1000}. Para 'localVar': {nome: 'localVar', tipo: 'float', escopo: 'func', visibilidade: 'private', endereco: 0x2004}. Insira em tabela com escopo global e filho 'func'.",
                              "finalVerifications": [
                                "Todos os 5 atributos estão presentes e corretamente preenchidos para 5 símbolos teste.",
                                "Tabela hierárquica resolve lookups sem conflitos ou duplicatas.",
                                "Simulação de alocação de memória atribui endereços sequenciais por escopo.",
                                "Mudanças de escopo (enter/leave) mantêm integridade das entradas.",
                                "Exporte da tabela em formato legível (JSON/CSV) sem erros de serialização.",
                                "Teste de shadowing: símbolo local oculta global corretamente."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de atributos (100% cobertura dos 5 campos).",
                                "Consistência na estrutura de dados (campos uniformes, tipos padronizados).",
                                "Correção em cenários de escopo aninhado e shadowing.",
                                "Eficiência na alocação de endereços (sem sobreposições).",
                                "Capacidade de depuração: identificar e corrigir erros em entradas inválidas.",
                                "Documentação clara das entradas criadas."
                              ],
                              "crossCurricularConnections": [
                                "Bancos de Dados: Similar a definir esquemas e metadados em tabelas relacionais.",
                                "Programação Orientada a Objetos: Atributos como campos de classe com visibilidade (private/public).",
                                "Arquitetura de Computadores: Gerenciamento de memória e offsets em registradores/heap.",
                                "Lógica e Verificação Formal: Validação semântica como pré-condições em provas.",
                                "Engenharia de Software: Modelagem de dados em design de sistemas."
                              ],
                              "realWorldApplication": "Em compiladores como GCC ou Clang, define atributos durante análise semântica para gerar código otimizado, detectar erros em tempo de compilação e suportar depuração em IDEs como Visual Studio, evitando bugs de tipo ou escopo em software de produção como navegadores ou sistemas operacionais."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.5.3.2",
                        "name": "Operações Básicas de Manipulação",
                        "description": "Realização de inserção, busca, atualização e remoção de símbolos nas tabelas, garantindo integridade semântica durante a análise.",
                        "specificSkills": [
                          {
                            "id": "10.1.5.3.2.1",
                            "name": "Executar inserção de novos símbolos",
                            "description": "Inserir um símbolo verificando duplicatas no escopo atual, atualizando contadores de endereços e lidando com redeclarações.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Identificar o Escopo Atual e Preparar o Símbolo para Inserção",
                                  "subSteps": [
                                    "Acesse a pilha de escopos (scope stack) para obter o escopo atual no topo.",
                                    "Extraia os atributos do símbolo: nome, tipo, escopo pai (se aplicável) e outros metadados.",
                                    "Valide que o nome do símbolo não está vazio e é válido (ex: sem caracteres especiais inválidos).",
                                    "Inicialize uma estrutura temporária para o novo SymbolEntry com valores padrão.",
                                    "Registre o contexto de inserção (linha/coluna no código fonte para debug)."
                                  ],
                                  "verification": "Confirme que escopoAtual != null e símbolo possui nome válido; imprima log de preparação.",
                                  "estimatedTime": "10 minutos",
                                  "materials": "Diagrama de pilha de escopos, estrutura de dados SymbolEntry (pseudocódigo ou código em C/Python), exemplo de código fonte AST.",
                                  "tips": "Sempre use o escopo local primeiro antes de propagar para escopos pais.",
                                  "learningObjective": "Compreender a hierarquia de escopos em tabelas de símbolos aninhadas.",
                                  "commonMistakes": "Confundir escopo global com local; inserir sem validar nome vazio."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Verificar Duplicatas no Escopo Atual",
                                  "subSteps": [
                                    "Inicie uma busca no hash table ou lista do escopo atual usando o nome do símbolo como chave.",
                                    "Compare nomes de forma case-sensitive e exata (considere namespaces se aplicável).",
                                    "Se encontrado, defina flag 'duplicata = true' e armazene referência ao entry existente.",
                                    "Otimize a busca com hash para O(1) em tabelas grandes.",
                                    "Registre o tempo de busca para profiling (opcional)."
                                  ],
                                  "verification": "Execute teste unitário com símbolo existente; flag duplicata deve ser true.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Implementação de hash table para escopo, casos de teste com duplicatas (ex: dois 'int x').",
                                  "tips": "Use equals() robusto para strings; ignore case apenas se a linguagem permitir.",
                                  "learningObjective": "Dominar algoritmos de lookup eficiente em estruturas de dados de símbolos.",
                                  "commonMistakes": "Busca case-insensitive quando deve ser sensível; esquecer namespaces."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Lidar com Casos de Redeclaração",
                                  "subSteps": [
                                    "Se duplicata == false, prossiga para inserção (pule para step 4).",
                                    "Se duplicata == true, verifique regras da linguagem: emitir erro semântico ou permitir shadowing.",
                                    "Para erro: gere mensagem 'Redeclaração de símbolo X no escopo atual' e retorne falha.",
                                    "Para shadowing: atualize o entry existente ou crie novo no escopo local.",
                                    "Atualize logs de erros e retorne ponteiro para entry ou null."
                                  ],
                                  "verification": "Teste com redeclaração: deve emitir erro ou shadow corretamente sem crash.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Regras semânticas da linguagem (ex: C-like), sistema de erros semânticos, testes de shadowing.",
                                  "tips": "Consulte spec da linguagem; shadowing é comum em blocos locais.",
                                  "learningObjective": "Aplicar regras semânticas para resolução de conflitos de nomes.",
                                  "commonMistakes": "Permitir redeclaração quando deve erro; propagar para escopo pai indevidamente."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Inserir Símbolo e Atualizar Contadores de Endereços",
                                  "subSteps": [
                                    "Crie novo SymbolEntry com nome, tipo, endereço = escopoAtual.nextAddress.",
                                    "Incremente escopoAtual.nextAddress (para próxima variável).",
                                    "Insira o entry na hash table ou lista do escopo atual.",
                                    "Atualize estatísticas do escopo (ex: numSymbols++).",
                                    "Retorne ponteiro para o novo entry para uso posterior (ex: atribuição de valores)."
                                  ],
                                  "verification": "Inspecione tabela: novo entry presente, nextAddress incrementado corretamente.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Código da função insertSymbol(), debugger para inspecionar tabela, casos de teste sem duplicatas.",
                                  "tips": "Garanta atomicidade com locks se multi-threaded (raro em compiladores single-pass).",
                                  "learningObjective": "Gerenciar alocação dinâmica de endereços em memória simbólica.",
                                  "commonMistakes": "Incrementar nextAddress antes de inserir; overflow de endereço."
                                }
                              ],
                              "practicalExample": "Em um compilador para linguagem simples, ao processar 'int x = 5;' em função foo(), escopo atual é foo's scope (nextAddress=0). Verifica 'x' não existe, insere SymbolEntry('x', INT, 0), nextAddress=4 (assumindo 4 bytes/int), retorna entry para bindar valor 5.",
                              "finalVerifications": [
                                "Tabela de símbolos do escopo atual contém o novo entry com endereço correto.",
                                "Contador nextAddress foi incrementado adequadamente.",
                                "Nenhuma duplicata foi inserida (teste com redeclaração falha).",
                                "Função retorna ponteiro válido ou erro apropriado.",
                                "Logs mostram inserção ou erro semântico corretos.",
                                "Testes unitários passam para casos happy path e edge cases."
                              ],
                              "assessmentCriteria": [
                                "Eficiência: lookup e insert em O(1) médio com hash.",
                                "Correção: Detecta 100% das duplicatas no escopo local.",
                                "Robustez: Lida com redeclarações emitindo erros sem crash.",
                                "Escalabilidade: Suporta 1000+ símbolos por escopo sem degradação.",
                                "Documentação: Código comentado com exemplos de uso.",
                                "Testes: Cobertura >90% incluindo shadowing."
                              ],
                              "crossCurricularConnections": [
                                "Estruturas de Dados: Hash tables e árvores para gerenciamento eficiente de símbolos.",
                                "Algoritmos: Busca e inserção em estruturas dinâmicas.",
                                "Banco de Dados: Conceitos de chaves únicas e índices em tabelas relacionais.",
                                "Gerenciamento de Memória: Alocação de endereços semelhantes a stack frames."
                              ],
                              "realWorldApplication": "Em compiladores como GCC/Clang, essa operação é crítica durante análise semântica para detectar redeclarações (ex: 'int x; int x;') e alocar offsets em frames de ativação, evitando erros de linker e otimizando uso de registradores."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.3.2.2",
                            "name": "Realizar busca por símbolos",
                            "description": "Buscar símbolo por nome em escopos aninhados, retornando ponteiro para entrada ou sinalizando não encontrado, com suporte a shadowing.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender a Estrutura de Escopos Aninhados na Tabela de Símbolos",
                                  "subSteps": [
                                    "Revise o conceito de escopos aninhados: cada escopo tem uma tabela local e um ponteiro para o escopo pai.",
                                    "Desenhe um diagrama de exemplo com 3 níveis de escopo: global, função e bloco local.",
                                    "Identifique como shadowing ocorre: um símbolo no escopo filho oculta o do pai com o mesmo nome.",
                                    "Liste os componentes de uma entrada de símbolo: nome, tipo, ponteiro para dados.",
                                    "Implemente uma classe simples em pseudocódigo para representar Scope e SymbolTableEntry."
                                  ],
                                  "verification": "Crie um diagrama manual ou digital da estrutura e explique shadowing verbalmente ou por escrito.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Papel e caneta ou ferramenta de diagramação (Draw.io)",
                                    "Pseudocódigo de exemplo de tabela de símbolos"
                                  ],
                                  "tips": "Comece pelo escopo global como raiz da árvore; visualize como uma árvore de escopos.",
                                  "learningObjective": "Compreender a hierarquia de escopos e o mecanismo de shadowing para buscas eficientes.",
                                  "commonMistakes": [
                                    "Confundir ponteiro para pai com lista de filhos",
                                    "Ignorar que shadowing é por nome exato e case-sensitive"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar Busca no Escopo Atual",
                                  "subSteps": [
                                    "Escreva uma função que recebe o nome do símbolo e o escopo atual.",
                                    "Percorra a tabela local do escopo atual usando um mapa ou hash table para lookup O(1).",
                                    "Se encontrado, retorne o ponteiro para a entrada do símbolo imediatamente.",
                                    "Se não encontrado, prepare para propagar ao escopo pai.",
                                    "Adicione logging para rastrear o escopo atual durante a busca."
                                  ],
                                  "verification": "Teste a função com um símbolo presente apenas no escopo atual e confirme retorno correto.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Editor de código ou IDE",
                                    "Estrutura de dados Map/Dictionary em sua linguagem preferida"
                                  ],
                                  "tips": "Use hash maps para lookups rápidos; evite listas lineares para performance.",
                                  "learningObjective": "Implementar lookup eficiente no escopo local antes de recursão.",
                                  "commonMistakes": [
                                    "Usar busca linear em vez de hash",
                                    "Retornar null prematuramente sem checar pais"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar Propagação Recursiva para Escopos Pais com Suporte a Shadowing",
                                  "subSteps": [
                                    "Torne a função recursiva: se não encontrado localmente, chame a função no escopo pai.",
                                    "Implemente condição de parada: se escopo pai é null (raiz), retorne sinal de não encontrado (ex: nullptr).",
                                    "Teste shadowing: insira símbolo com mesmo nome em escopo filho e confirme que retorna o local.",
                                    "Adicione tratamento para escopos vazios ou corrompidos.",
                                    "Otimize para evitar recursão profunda com versão iterativa usando loop while pai != null."
                                  ],
                                  "verification": "Execute testes com símbolo shadowed e não-shadowed, verificando ponteiro correto retornado.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Código do Step 2",
                                    "Ferramentas de teste unitário (JUnit, pytest)"
                                  ],
                                  "tips": "Prefira iteração a recursão para profundidades altas; use ponteiro pai diretamente.",
                                  "learningObjective": "Gerenciar busca hierárquica respeitando shadowing e evitando loops infinitos.",
                                  "commonMistakes": [
                                    "Recursão infinita sem checagem de pai null",
                                    "Retornar símbolo pai quando shadowed"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Testar e Refinar a Função de Busca Completa",
                                  "subSteps": [
                                    "Crie cenários de teste: símbolo local, shadowed, em escopo avô, não existente.",
                                    "Meça performance com 1000 buscas em árvore profunda.",
                                    "Adicione tratamento de erros: exceções para nomes inválidos ou escopos corrompidos.",
                                    "Documente a função com comentários sobre complexidade (O(d) onde d é profundidade).",
                                    "Integre em um mini-compilador de teste com código fonte simples."
                                  ],
                                  "verification": "Todos os testes passam com 100% de cobertura; performance abaixo de 1ms por busca.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Suite de testes",
                                    "Exemplos de código fonte com escopos (C-like)"
                                  ],
                                  "tips": "Use asserts para verificações; mock escopos para testes isolados.",
                                  "learningObjective": "Validar robustez da busca em cenários reais de compiladores.",
                                  "commonMistakes": [
                                    "Testes insuficientes para casos edge como escopo vazio",
                                    "Ignorar case-sensitivity"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Avaliar e Otimizar para Uso em Análise Semântica",
                                  "subSteps": [
                                    "Analise uso em contexto maior: resolução de identificadores em AST.",
                                    "Implemente cache para buscas frequentes (memoization por nome global).",
                                    "Compare com implementações padrão (ex: LLVM SymbolTable).",
                                    "Escreva relatório de lições aprendidas e melhorias potenciais.",
                                    "Refatore código para thread-safety se aplicável."
                                  ],
                                  "verification": "Código refatorado passa revisões de pares e benchmarks melhorados.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Documentação de LLVM/GCC symbol tables",
                                    "Ferramentas de profiling"
                                  ],
                                  "tips": "Considere global symbol table para otimização em compiladores reais.",
                                  "learningObjective": "Aplicar busca em pipeline de compilador e otimizar para produção.",
                                  "commonMistakes": [
                                    "Sobre-otimizar prematuramente sem profiling",
                                    "Ignorar mutabilidade em multi-thread"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um compilador para linguagem similar a C: escopo global tem 'int x = 1'; função tem 'int x = 2'; busca por 'x' dentro da função retorna ponteiro para x=2 (shadowed), ignorando global. Se buscar 'y' não existente, propaga até raiz e retorna nullptr.",
                              "finalVerifications": [
                                "Busca retorna ponteiro correto para símbolo local shadowed.",
                                "Propaga corretamente para escopo pai quando não encontrado localmente.",
                                "Sinaliza não encontrado (nullptr) após esgotar hierarquia.",
                                "Performance O(1) por nível de escopo em testes com 10 níveis.",
                                "Nenhum crash em escopos vazios ou null.",
                                "Logging rastreia caminho da busca corretamente."
                              ],
                              "assessmentCriteria": [
                                "Correção: 100% de acertos em testes de shadowing e propagação.",
                                "Eficiência: Tempo de busca < 1ms para profundidade 20.",
                                "Robustez: Trata nulls, vazios e nomes inválidos sem exceções inesperadas.",
                                "Clareza: Código comentado com complexidade Big-O explicada.",
                                "Completo: Suporte iterativo/recursivo com escolha justificada.",
                                "Escalável: Funciona com >1000 símbolos por escopo."
                              ],
                              "crossCurricularConnections": [
                                "Estruturas de Dados: Árvores e hash tables para representação eficiente.",
                                "Algoritmos: Busca recursiva/iterativa e análise de complexidade.",
                                "Programação Orientada a Objetos: Encapsulamento de Scope como classe.",
                                "Teoria da Computação: Autômatos e análise léxica/semântica.",
                                "Engenharia de Software: Testes unitários e refactoring."
                              ],
                              "realWorldApplication": "Em compiladores como GCC/Clang para resolução de variáveis em C++; interpretadores Python para namespaces; IDEs como VSCode para IntelliSense e autocompletar em escopos aninhados."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.3.2.3",
                            "name": "Atualizar atributos de símbolos existentes",
                            "description": "Modificar tipo ou escopo de um símbolo após declarações condicionais ou inferência de tipos na análise semântica.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a estrutura de símbolos na tabela de símbolos",
                                  "subSteps": [
                                    "Estude os atributos comuns de um símbolo: nome, tipo, escopo, visibilidade e inferido.",
                                    "Analise exemplos de declarações condicionais que afetam tipos (ex: if com inferência).",
                                    "Revise como a tabela de símbolos é organizada (hash map, árvore de escopos).",
                                    "Identifique atributos mutáveis como tipo e escopo.",
                                    "Pratique visualizando uma tabela de símbolos antes e após atualizações."
                                  ],
                                  "verification": "Crie um diagrama manual de uma tabela de símbolos com 3 símbolos e liste atributos mutáveis.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Documentação de compiladores (ex: Dragon Book), editor de texto para diagramas.",
                                  "tips": "Use pseudocódigo para representar a estrutura do símbolo antes de codificar.",
                                  "learningObjective": "Dominar os atributos editáveis de símbolos para preparar atualizações.",
                                  "commonMistakes": "Confundir atributos imutáveis (como nome) com mutáveis; ignorar hierarquia de escopos."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar triggers para atualização de atributos",
                                  "subSteps": [
                                    "Liste cenários: inferência de tipos em atribuições, mudanças de escopo em blocos condicionais.",
                                    "Analise código-fonte de exemplo com declarações como 'var x = cond ? 1 : 'a';'.",
                                    "Defina regras para propagar atualizações (ex: union de tipos).",
                                    "Simule fluxos semânticos passo a passo.",
                                    "Documente condições de gatilho em um fluxograma."
                                  ],
                                  "verification": "Para um snippet de código dado, liste 2-3 triggers e atributos a atualizar.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Exemplos de código em linguagens com inferência (TypeScript, Rust), fluxogramas online.",
                                  "tips": "Sempre priorize inferência bottom-up após parsing.",
                                  "learningObjective": "Reconhecer precisamente quando e por quê atualizar símbolos.",
                                  "commonMistakes": "Atualizar prematuramente antes de análise completa; ignorar condicionais aninhadas."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar a lógica de localização e atualização",
                                  "subSteps": [
                                    "Implemente busca na tabela: procure por nome no escopo atual e pais.",
                                    "Crie função updateSymbol(nome, novoTipo, novoEscopo) com locks para thread-safety se aplicável.",
                                    "Aplique modificações: valide compatibilidade de tipos antes de alterar.",
                                    "Registre histórico de mudanças para debugging.",
                                    "Teste unitário com casos de inferência simples."
                                  ],
                                  "verification": "Execute código que atualiza um símbolo e imprima tabela antes/depois.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Linguagem de programação (Python/C++), framework de testes (pytest/unittest).",
                                  "tips": "Use ponteiros ou referências para símbolos para evitar cópias desnecessárias.",
                                  "learningObjective": "Codificar atualizações seguras e eficientes em tabelas de símbolos.",
                                  "commonMistakes": "Não lidar com símbolos não encontrados (fallback para declaração); perda de dados antigos."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Validar e testar atualizações em cenários complexos",
                                  "subSteps": [
                                    "Teste com escopos aninhados e condicionais múltiplos.",
                                    "Verifique propagação de erros (ex: tipos incompatíveis).",
                                    "Integre com passes semânticos anteriores (type checking).",
                                    "Meça performance em tabelas grandes (1000+ símbolos).",
                                    "Refatore com base em falhas identificadas."
                                  ],
                                  "verification": "Rodar suíte de testes com 80%+ cobertura e zero falhas em casos edge.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Ferramentas de profiling (ex: cProfile), exemplos de compiladores open-source (Clang).",
                                  "tips": "Automatize verificações com asserts em atributos pós-atualização.",
                                  "learningObjective": "Garantir robustez das atualizações em contextos reais de compiladores.",
                                  "commonMistakes": "Sobrescrever sem validação; falhar em escopos shadowed."
                                }
                              ],
                              "practicalExample": "Em um compilador para uma linguagem com inferência, ao processar 'let x = if (flag) 42 else \"hello\";', localize o símbolo 'x', infira tipo union<int, string> e atualize o atributo 'type' de 'unknown' para 'union<int,string>', propagando para usos subsequentes.",
                              "finalVerifications": [
                                "Tabela de símbolos reflete corretamente tipos inferidos após condicionais.",
                                "Busca e atualização funcionam em escopos aninhados sem vazamentos.",
                                "Nenhum erro de tipo incompatível em testes de inferência.",
                                "Performance aceitável (O(1) médio para lookups).",
                                "Histórico de mudanças permite debugging eficaz.",
                                "Integração com type checker sem conflitos."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de triggers (100% em exemplos).",
                                "Corretude da implementação (passa todos unit tests).",
                                "Eficiência: tempo de execução < 1s para 10k símbolos.",
                                "Cobertura de edge cases (condicionais vazios, shadowed vars).",
                                "Clareza do código: comentários e nomes descritivos.",
                                "Validação de compatibilidade de tipos antes de update."
                              ],
                              "crossCurricularConnections": [
                                "Programação Funcional: Inferência de tipos em linguagens como Haskell.",
                                "Banco de Dados: Atualização de metadados em catálogos de esquemas.",
                                "Engenharia de Software: Versionamento de objetos em IDEs (ex: IntelliJ).",
                                "Inteligência Artificial: Atualização de embeddings em modelos de NLP.",
                                "Sistemas Operacionais: Gerenciamento de descritores de processos."
                              ],
                              "realWorldApplication": "Em compiladores como GCC ou Clang, atualiza tipos durante otimização de código; em IDEs como VS Code, suporta autocompletar dinâmico e refatoração segura em linguagens tipadas dinamicamente."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.5.3.3",
                        "name": "Gerenciamento de Escopos e Visibilidade",
                        "description": "Controle de entrada e saída de blocos de código, usando pilhas de tabelas para suportar escopos locais, globais e aninhados.",
                        "specificSkills": [
                          {
                            "id": "10.1.5.3.3.1",
                            "name": "Implementar pilha de tabelas para escopos",
                            "description": "Criar uma pilha onde cada frame representa um escopo, com push na entrada de bloco e pop na saída, preservando símbolos locais.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Definir estruturas de dados para Tabela de Símbolos e Pilha de Escopos",
                                  "subSteps": [
                                    "Crie uma classe SymbolTable representando um frame de escopo, usando um mapa (HashMap) para associar nomes de símbolos a seus atributos (tipo, escopo, etc.).",
                                    "Defina uma classe StackOfSymbolTables para gerenciar a pilha, com lista ou vetor de SymbolTable.",
                                    "Inclua atributos como currentScopeLevel para rastrear profundidade.",
                                    "Adicione métodos auxiliares como isEmpty() e size() para a pilha.",
                                    "Inicialize a pilha com um escopo global vazio."
                                  ],
                                  "verification": "Compile e instancie a pilha; verifique se o escopo global está no topo e vazio.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "IDE com suporte a linguagem orientada a objetos (Java/Python/C++)",
                                    "Documentação de HashMap/Dict"
                                  ],
                                  "tips": "Use interfaces para abstrair o mapa, facilitando testes unitários.",
                                  "learningObjective": "Compreender como representar hierarquias de escopos em memória.",
                                  "commonMistakes": [
                                    "Usar lista simples sem distinção de frames",
                                    "Esquecer escopo global inicial"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar operação PUSH para entrada em novo escopo",
                                  "subSteps": [
                                    "Crie método push() que instancie novo SymbolTable e adicione ao topo da pilha.",
                                    "Incremente o nível de escopo atual.",
                                    "Copie símbolos visíveis do escopo pai (herança de visibilidade, se aplicável).",
                                    "Registre metadados como nome do bloco ou linha de código.",
                                    "Teste push isolado imprimindo o topo da pilha."
                                  ],
                                  "verification": "Chame push() múltiplas vezes e confirme que frames são empilhados corretamente via toString().",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Exemplos de código fonte com blocos { }",
                                    "Ferramenta de depuração (debugger)"
                                  ],
                                  "tips": "Evite cópia profunda desnecessária; use referências para símbolos herdados.",
                                  "learningObjective": "Dominar criação dinâmica de escopos locais.",
                                  "commonMistakes": [
                                    "Não incrementar nível de escopo",
                                    "Copiar todos símbolos sem filtro de visibilidade"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar operação POP e LOOKUP com resolução de escopo",
                                  "subSteps": [
                                    "Crie método pop() que remova o topo da pilha e retorne seus símbolos para limpeza.",
                                    "Descremente o nível de escopo.",
                                    "Implemente lookup(nome) que busca do topo para baixo até encontrar o símbolo.",
                                    "Diferencie símbolos locais vs. globais durante busca.",
                                    "Adicione insert(nome, atributos) apenas no escopo atual."
                                  ],
                                  "verification": "Após push/pop, verifique que lookup retorna valores corretos de escopos ancestrais.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Testes unitários (JUnit/Pytest)",
                                    "AST simples de um parser"
                                  ],
                                  "tips": "Use loop while(!isEmpty()) na lookup para eficiência.",
                                  "learningObjective": "Garantir resolução correta de visibilidade em escopos aninhados.",
                                  "commonMistakes": [
                                    "Buscar apenas no escopo atual",
                                    "Vazar memória ao pop sem limpeza"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Integrar pilha com analisador semântico (Visitor Pattern)",
                                  "subSteps": [
                                    "Crie visitor para AST que chame push() em NodeBlock.enter().",
                                    "Em NodeBlock.exit(), chame pop().",
                                    "Para declarações de variáveis, use insert() no escopo atual.",
                                    "Para referências, use lookup() e reporte erros de não-encontrado.",
                                    "Trate escopos especiais como funções ou loops."
                                  ],
                                  "verification": "Parse código com blocos aninhados; depure pilha em pontos chave.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Parser gerado (ANTLR/Yacc)",
                                    "Exemplos de código com shadowing de variáveis"
                                  ],
                                  "tips": "Use callbacks pré/pós-visita para push/pop precisos.",
                                  "learningObjective": "Aplicar gerenciamento de escopo em fluxo de análise semântica.",
                                  "commonMistakes": [
                                    "Push/pop desalinhados com blocos",
                                    "Ignorar shadowing (mesmo nome em escopos diferentes)"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Testar e depurar a implementação completa",
                                  "subSteps": [
                                    "Escreva testes para código com variáveis locais, globais e shadowing.",
                                    "Simule entrada/saída de blocos e verifique estado da pilha.",
                                    "Meça performance com 1000 escopos aninhados.",
                                    "Adicione logs para rastrear operações.",
                                    "Corrija erros comuns como vazamentos de escopo."
                                  ],
                                  "verification": "Todos testes passam; pilha vazia após análise completa.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Framework de testes",
                                    "Profiler de performance"
                                  ],
                                  "tips": "Comece com casos simples, escale para complexos.",
                                  "learningObjective": "Validar robustez da implementação em cenários reais.",
                                  "commonMistakes": [
                                    "Testes insuficientes para escopos profundos",
                                    "Não testar pop em blocos vazios"
                                  ]
                                }
                              ],
                              "practicalExample": "Para um código como: global x=1; { local y=2; { x=3; y=4; } } – push no primeiro {, insert y; push no segundo {, resolve x do global, insert y local; pop restaura y anterior; pop remove y local.",
                              "finalVerifications": [
                                "Pilha inicia com escopo global e termina vazia após análise.",
                                "Lookup resolve corretamente símbolos em escopos ancestrais.",
                                "Insert só afeta escopo atual, sem poluição.",
                                "Push/pop balanceados para todo AST.",
                                "Sem vazamentos de memória após múltiplos testes.",
                                "Performance O(1) médio para operações básicas."
                              ],
                              "assessmentCriteria": [
                                "Correção: símbolos preservados e visíveis corretamente.",
                                "Eficiência: buscas em profundidade razoável (máx 20 escopos).",
                                "Robustez: trata erros como símbolo não declarado.",
                                "Modularidade: classes bem separadas e testáveis.",
                                "Documentação: comentários em métodos chave.",
                                "Integração: funciona seamless com parser/visitor."
                              ],
                              "crossCurricularConnections": [
                                "Estruturas de Dados: Pilha (LIFO) e Dicionários.",
                                "Paradigmas de Programação: Escopos léxicos vs. dinâmicos.",
                                "Engenharia de Software: Gerenciamento de estado em walkers/visitors.",
                                "Análise de Algoritmos: Complexidade em resoluções de nomes."
                              ],
                              "realWorldApplication": "Essencial em compiladores (GCC, Clang), interpreters (CPython, JVM) e ferramentas como linters (ESLint), para análise semântica precisa em linguagens com blocos aninhados."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.3.3.2",
                            "name": "Gerenciar visibilidade e resolução de nomes",
                            "description": "Resolver referências a símbolos buscando da tabela atual para cima na pilha, aplicando regras de shadowing e hiding.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender a estrutura de pilha de tabelas de símbolos e conceitos básicos",
                                  "subSteps": [
                                    "Estude o conceito de escopo léxico e pilha de tabelas de símbolos.",
                                    "Aprenda as diferenças entre shadowing (sobrescrever símbolo no escopo atual) e hiding (ocultar símbolos de escopos superiores).",
                                    "Desenhe um diagrama de pilha com múltiplos escopos aninhados.",
                                    "Identifique exemplos de código fonte onde visibilidade é aplicada.",
                                    "Revise regras de resolução: busca da tabela atual para cima na pilha."
                                  ],
                                  "verification": "Crie um diagrama manual de pilha para um código simples e explique shadowing/hiding verbalmente.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Documentação de compiladores (ex: Dragon Book), papel e caneta para diagramas, exemplos de código em C ou Java.",
                                  "tips": "Use cores diferentes para escopos no diagrama para visualizar melhor a pilha.",
                                  "learningObjective": "Compreender os fundamentos teóricos de escopos e visibilidade em análise semântica.",
                                  "commonMistakes": "Confundir shadowing com overriding de métodos ou ignorar busca upward na pilha."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar inserção de símbolos na pilha de tabelas",
                                  "subSteps": [
                                    "Crie uma estrutura de dados para Tabela de Símbolos (map ou dict com nome, tipo, escopo).",
                                    "Implemente push/pop de tabelas para novos escopos (ex: função ou bloco).",
                                    "Adicione símbolo à tabela atual, verificando duplicatas no escopo local.",
                                    "Teste inserção com shadowing: permitir redeclaração local sem erro.",
                                    "Implemente hiding implícito via busca em pilha."
                                  ],
                                  "verification": "Execute código de inserção e imprima pilha após múltiplas inserções; confirme símbolos corretos por escopo.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Editor de código (VS Code), linguagem como Python ou C++, pseudocódigo de tabela de símbolos.",
                                  "tips": "Use uma lista de dicionários para simular pilha; sempre imprima estado da pilha após operações.",
                                  "learningObjective": "Desenvolver código para gerenciar inserção respeitando escopos e shadowing.",
                                  "commonMistakes": "Inserir em escopo errado ou falhar em pop ao sair de escopo, causando vazamentos."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar resolução de referências (lookup de símbolos)",
                                  "subSteps": [
                                    "Escreva função lookup que inicia na tabela atual e sobe a pilha até encontrar o símbolo.",
                                    "Pare na primeira ocorrência (regra de visibilidade mais próxima).",
                                    "Retorne atributos do símbolo (tipo, valor) ou erro se não encontrado.",
                                    "Teste com referências em escopos aninhados, incluindo shadowing.",
                                    "Adicione logs para rastrear caminho de busca na pilha."
                                  ],
                                  "verification": "Teste lookup em cenários com shadowing/hiding; verifique se resolve corretamente sem acessar ocultos.",
                                  "estimatedTime": "75 minutos",
                                  "materials": "Código do Step 2, casos de teste com AST simples (Abstract Syntax Tree).",
                                  "tips": "Implemente lookup recursivo ou iterativo com loop pela pilha para eficiência.",
                                  "learningObjective": "Capacitar resolução precisa de nomes aplicando regras de visibilidade.",
                                  "commonMistakes": "Buscar apenas no escopo global ou continuar busca após shadowing."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Integrar e testar gerenciamento completo de visibilidade",
                                  "subSteps": [
                                    "Combine inserção e lookup em um parser semântico simples.",
                                    "Parse um programa com funções aninhadas e variáveis locais/globais.",
                                    "Detecte erros semânticos como referências não resolvidas.",
                                    "Execute testes unitários para cenários de shadowing e hiding.",
                                    "Otimize para performance em pilhas profundas."
                                  ],
                                  "verification": "Rode parser em 5 exemplos variados; confirme 100% de resolução correta sem falsos positivos.",
                                  "estimatedTime": "90 minutos",
                                  "materials": "Código dos steps anteriores, suíte de testes (ex: pytest), exemplos reais de código fonte.",
                                  "tips": "Use um mini-AST para simular análise semântica real.",
                                  "learningObjective": "Integrar inserção e resolução em um fluxo completo de análise semântica.",
                                  "commonMistakes": "Não limpar pilha adequadamente, levando a resoluções incorretas em loops."
                                }
                              ],
                              "practicalExample": "Em um compilador para uma linguagem como C: função global int x; dentro de main() { int x = 5; } – lookup de 'x' em main resolve para 5 (shadowing), não o global.",
                              "finalVerifications": [
                                "Pilha de tabelas reflete corretamente escopos aninhados após push/pop.",
                                "Lookup resolve símbolos locais antes de globais (shadowing testado).",
                                "Símbolos de escopos superiores são hidden por locais equivalentes.",
                                "Erros de 'undeclared identifier' são reportados precisamente.",
                                "Performance de lookup é O(profundidade da pilha) em testes.",
                                "Logs mostram caminho exato de busca para cada resolução."
                              ],
                              "assessmentCriteria": [
                                "Precisão na resolução: 100% em testes com 10+ casos de visibilidade.",
                                "Correta implementação de shadowing sem alterar símbolos superiores.",
                                "Eficiência: lookup não excede profundidade da pilha desnecessariamente.",
                                "Tratamento de erros semânticos claros e localizados.",
                                "Código limpo com comentários explicando regras de visibilidade.",
                                "Capacidade de debugar falhas em cenários complexos."
                              ],
                              "crossCurricularConnections": [
                                "Linguagens de Programação: Entender escopo em Python/Java para depuração.",
                                "Estruturas de Dados: Uso de stacks e hash maps em gerenciamento de memória.",
                                "Design de Software: Padrões para namespaces em APIs e módulos.",
                                "Teoria da Computação: Autômatos e gramáticas context-free livres."
                              ],
                              "realWorldApplication": "Em compiladores como GCC/Clang para C++, resolve nomes em funções recursivas ou templates; em interpreters como CPython para Python, gerencia visibilidade em comprehensions aninhadas, evitando erros em apps web escaláveis."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.3.3.3",
                            "name": "Tratar erros de escopo em tabelas",
                            "description": "Detectar e reportar erros como uso de variável fora de escopo ou redeclaração ilegal durante inserção e busca.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Configurar estrutura de tabela de símbolos com suporte a escopos",
                                  "subSteps": [
                                    "Defina uma estrutura de dados para representar escopos (ex: pilha de tabelas hash).",
                                    "Implemente funções para criar novo escopo (push) e sair de escopo (pop).",
                                    "Adicione metadados em cada símbolo: nome, tipo, escopo de declaração.",
                                    "Teste a navegação básica entre escopos pai e filho.",
                                    "Registre o escopo atual em uma variável global ou contexto."
                                  ],
                                  "verification": "Crie um programa simples com blocos aninhados e verifique se símbolos são isolados por escopo.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Linguagem de programação (ex: Python, C++)",
                                    "Editor de código (VS Code)",
                                    "Documentação de hash tables"
                                  ],
                                  "tips": "Use uma pilha para escopos para simular lexical scoping automaticamente.",
                                  "learningObjective": "Compreender e implementar gerenciamento hierárquico de escopos em tabelas de símbolos.",
                                  "commonMistakes": [
                                    "Não limpar símbolos ao sair de escopo",
                                    "Confundir escopo local com global",
                                    "Ignorar shadowing em escopos aninhados"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar detecção de redeclaração ilegal durante inserção",
                                  "subSteps": [
                                    "Na função de inserção, busque o nome no escopo atual.",
                                    "Se encontrado, gere erro de redeclaração e pare a compilação.",
                                    "Permita shadowing (declaração em escopo filho), mas proíba no mesmo escopo.",
                                    "Armazene o símbolo apenas se não houver conflito.",
                                    "Registre posição no código fonte para o erro (linha/coluna)."
                                  ],
                                  "verification": "Tente inserir variável duplicada no mesmo escopo e confirme que erro é reportado sem inserir.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Código da tabela do step 1",
                                    "Exemplos de código com redeclarações",
                                    "Ferramenta de linting para testes"
                                  ],
                                  "tips": "Busque apenas no escopo atual para redeclaração; escopos pai são para shadowing.",
                                  "learningObjective": "Detectar e prevenir redeclarações ilegais em um escopo específico.",
                                  "commonMistakes": [
                                    "Permitir redeclaração acidentalmente",
                                    "Buscar em escopos pai durante inserção",
                                    "Não reportar posição exata do erro"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar detecção de uso fora de escopo durante busca",
                                  "subSteps": [
                                    "Na função de busca, inicie no escopo atual e suba para pais se não encontrado.",
                                    "Se não encontrado em nenhum escopo acessível, gere erro de variável indefinida.",
                                    "Retorne o símbolo com escopo de origem para verificações adicionais.",
                                    "Integre com análise semântica para checar visibilidade em tempo de compilação.",
                                    "Adicione suporte a escopos especiais (ex: global, parâmetros de função)."
                                  ],
                                  "verification": "Use uma variável declarada em escopo pai de forma incorreta em filho e confirme erro na busca.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Código dos steps anteriores",
                                    "Parser simples para gerar AST",
                                    "Casos de teste com escopos variados"
                                  ],
                                  "tips": "Implemente busca recursiva na pilha de escopos para eficiência.",
                                  "learningObjective": "Garantir que referências a símbolos respeitem regras de visibilidade.",
                                  "commonMistakes": [
                                    "Buscar além do escopo global",
                                    "Ignorar escopos de função/loop",
                                    "Confundir forward references"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Integrar reporte de erros e validar implementação",
                                  "subSteps": [
                                    "Crie um sistema de erros com mensagens claras (ex: 'Redeclaração de x na linha 5').",
                                    "Colete todos os erros sem parar na compilação, mas liste no final.",
                                    "Implemente testes unitários para cenários de erro positivos e negativos.",
                                    "Execute em um programa completo com múltiplos erros de escopo.",
                                    "Otimize para performance em tabelas grandes."
                                  ],
                                  "verification": "Compile um código com erros mistos e verifique relatório completo e correto.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Framework de testes (ex: unittest, pytest)",
                                    "Códigos de teste com erros intencionais",
                                    "Debugger"
                                  ],
                                  "tips": "Use enums para tipos de erro para facilitar extensibilidade futura.",
                                  "learningObjective": "Reportar erros de escopo de forma informativa e robusta.",
                                  "commonMistakes": [
                                    "Parar na compilação após primeiro erro",
                                    "Mensagens vagas sem contexto",
                                    "Testes insuficientes para bordas"
                                  ]
                                }
                              ],
                              "practicalExample": "No código fonte: int x = 1; { int x = 2; } // Erro: redeclaração de x no escopo interno. Durante inserção do segundo x, busca no escopo atual detecta conflito e reporta 'Redeclaração ilegal de variável x na linha 2, coluna 5'. Para uso fora: { int y; } y = 3; // Erro na busca: y não visível no escopo atual.",
                              "finalVerifications": [
                                "Explica diferença entre redeclaração ilegal e shadowing.",
                                "Implementa inserção sem duplicatas no mesmo escopo.",
                                "Busca corretamente símbolos em escopos ancestrais.",
                                "Gera relatórios de erro com posição precisa.",
                                "Passa em testes com 10+ cenários de erro.",
                                "Identifica uso de variável indefinida em qualquer escopo."
                              ],
                              "assessmentCriteria": [
                                "Precisão na detecção de 100% dos erros de escopo testados.",
                                "Eficiência: busca O(1) médio por inserção/busca.",
                                "Mensagens de erro claras e localizadas.",
                                "Robustez: lida com escopos aninhados profundos (>10).",
                                "Cobertura de testes >90%.",
                                "Integração seamless com análise semântica."
                              ],
                              "crossCurricularConnections": [
                                "Estruturas de Dados: Pilhas e tabelas hash para escopos.",
                                "Lógica e Algoritmos: Busca recursiva e detecção de conflitos.",
                                "Programação: Conceitos de lexical scoping em linguagens como C++ ou Java.",
                                "Matemática Discreta: Teoria de conjuntos para visibilidade.",
                                "Engenharia de Software: Tratamento de exceções em compiladores."
                              ],
                              "realWorldApplication": "Em compiladores profissionais como GCC/Clang para C/C++, ou Rust (com borrow checker estendido), detecta erros de escopo em tempo de compilação, prevenindo bugs em runtime e melhorando depuração em IDEs como Visual Studio ou IntelliJ."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.5.4",
                    "name": "Detecção de Erros Semânticos",
                    "description": "Identificação e tratamento de erros no significado e contexto das construções sintáticas.",
                    "individualConcepts": [
                      {
                        "id": "10.1.5.4.1",
                        "name": "Classificação de Erros Semânticos",
                        "description": "Identificação dos principais tipos de erros semânticos, como variáveis não declaradas, incompatibilidades de tipos e redeclarações, que violam as regras de significado das construções sintáticas válidas.",
                        "specificSkills": [
                          {
                            "id": "10.1.5.4.1.1",
                            "name": "Identificar erros de escopo e declaração",
                            "description": "Reconhecer erros como uso de variável não declarada ou fora de escopo, consultando tabelas de símbolos durante a análise semântica.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender Conceitos Fundamentais de Declaração e Escopo de Variáveis",
                                  "subSteps": [
                                    "Estude a definição de declaração de variáveis em linguagens como C ou Java.",
                                    "Analise tipos de escopo: local, global, bloco e função.",
                                    "Compare exemplos de código com escopos corretos e incorretos.",
                                    "Crie um diagrama mental de como o escopo é resolvido em tempo de compilação.",
                                    "Liste diferenças entre escopo léxico e dinâmico."
                                  ],
                                  "verification": "Crie um mapa conceitual resumindo declaração e escopo, sem erros factuais.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Documentação de linguagens (C/Java), editor de texto para diagramas.",
                                  "tips": "Use exemplos simples de funções aninhadas para visualizar escopos.",
                                  "learningObjective": "Definir e diferenciar declaração de variáveis e tipos de escopo.",
                                  "commonMistakes": "Confundir escopo léxico com dinâmico; ignorar escopo de bloco."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Aprender Estrutura e Uso de Tabelas de Símbolos",
                                  "subSteps": [
                                    "Descreva o que é uma tabela de símbolos e seus campos (nome, tipo, escopo).",
                                    "Simule a construção de uma tabela de símbolos para um programa simples.",
                                    "Entenda operações: inserção, busca e remoção durante parsing.",
                                    "Pratique atualizando a tabela ao entrar/sair de blocos de escopo.",
                                    "Identifique como tabelas aninhadas representam escopos hierárquicos."
                                  ],
                                  "verification": "Construa manualmente uma tabela de símbolos para um código de 10 linhas.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Papel ou planilha Excel, exemplos de código fonte simples.",
                                  "tips": "Use pilhas para simular tabelas aninhadas por escopo.",
                                  "learningObjective": "Construir e manipular tabelas de símbolos para rastrear declarações.",
                                  "commonMistakes": "Esquecer de remover símbolos ao sair de um escopo; busca em escopo errado."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Detectar Erros de Declaração Não Existente",
                                  "subSteps": [
                                    "Identifique uso de variável antes da declaração na tabela.",
                                    "Simule busca linear na tabela de símbolos durante análise semântica.",
                                    "Marque erros quando busca falha em todos os escopos ancestrais.",
                                    "Teste com códigos contendo variáveis indefinidas.",
                                    "Registre mensagens de erro padrão como 'undeclared identifier'."
                                  ],
                                  "verification": "Analise 5 trechos de código e liste erros de declaração corretamente.",
                                  "estimatedTime": "50 minutos",
                                  "materials": "Compilador online (GCC, javac), códigos de teste com erros.",
                                  "tips": "Sempre busque do escopo atual para global.",
                                  "learningObjective": "Reconhecer e reportar variáveis não declaradas via tabela de símbolos.",
                                  "commonMistakes": "Reportar falso positivo em variáveis globais; ignorar pré-declarações."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Identificar Erros de Escopo Inválido",
                                  "subSteps": [
                                    "Simule resolução de nomes em escopos hierárquicos.",
                                    "Detecte uso de variável fora de seu escopo de declaração.",
                                    "Pratique com shadowing de variáveis (mesmo nome em escopos diferentes).",
                                    "Analise exemplos de loops, condicionais e funções aninhadas.",
                                    "Gere relatórios de erro como 'out of scope' com linha e símbolo."
                                  ],
                                  "verification": "Corrija 3 códigos com erros de escopo e explique as mudanças.",
                                  "estimatedTime": "55 minutos",
                                  "materials": "Editor de código (VS Code), exemplos de análise semântica.",
                                  "tips": "Visualize escopos como árvore para rastrear visibilidade.",
                                  "learningObjective": "Detectar acessos a variáveis fora de escopo usando tabelas.",
                                  "commonMistakes": "Confundir shadowing com erro; permitir acesso cross-bloco indevido."
                                }
                              ],
                              "practicalExample": "Em C: int main() { x = 5; int x; return 0; } → Erro: 'x' usado antes da declaração (busca falha). Correção: declare antes. Outro: { int a=1; } printf(\"%d\", a); → Erro de escopo: 'a' fora do bloco.",
                              "finalVerifications": [
                                "Explica como tabelas de símbolos detectam erros de declaração e escopo.",
                                "Analisa código com múltiplos erros e identifica todos corretamente.",
                                "Diferencia erros de declaração de escopo em exemplos reais.",
                                "Simula análise semântica passo a passo para um programa médio.",
                                "Propõe mensagens de erro claras e posicionadas.",
                                "Identifica shadowing válido vs. erro de escopo."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de 90%+ dos erros em testes.",
                                "Explicação correta do papel da tabela de símbolos.",
                                "Uso apropriado de conceitos de escopo hierárquico.",
                                "Capacidade de simular análise manual sem falhas lógicas.",
                                "Clareza em relatórios de erros (linha, tipo, descrição).",
                                "Integração de conceitos em cenários complexos."
                              ],
                              "crossCurricularConnections": [
                                "Lógica e Estruturas de Dados (pilhas para escopos).",
                                "Programação Imperativa (debugging em linguagens reais).",
                                "Teoria da Computação (autômatos e parsing).",
                                "Engenharia de Software (ferramentas de análise estática)."
                              ],
                              "realWorldApplication": "Desenvolvedores de compiladores (GCC, Clang) usam isso para diagnósticos precisos; IDEs como VS Code IntelliSense detectam erros em tempo real; debugging em projetos grandes previne runtime errors."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.4.1.2",
                            "name": "Detectar incompatibilidades de tipos",
                            "description": "Analisar operações aritméticas ou atribuições para identificar conflitos de tipos, como atribuir string a inteiro, usando regras de tipagem estática.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender Conceitos Fundamentais de Tipagem Estática",
                                  "subSteps": [
                                    "Estude os tipos primitivos comuns (int, float, string, bool).",
                                    "Aprenda regras de compatibilidade: promoção implícita (int para float) vs. incompatibilidade (string para int).",
                                    "Revise hierarquia de tipos e coercão automática.",
                                    "Identifique operações permitidas por tipo (ex: + em int vs. string).",
                                    "Pratique com diagramas de tipos compatíveis."
                                  ],
                                  "verification": "Crie um diagrama de compatibilidade de tipos para 5 tipos primitivos e liste 3 regras chave.",
                                  "estimatedTime": "45 min",
                                  "materials": [
                                    "Documentação de tipagem estática (ex: C ou Java specs)",
                                    "Papel e caneta para diagramas",
                                    "Editor de texto para anotações"
                                  ],
                                  "tips": "Use tabelas para visualizar combinações de tipos rapidamente.",
                                  "learningObjective": "Dominar regras básicas de compatibilidade de tipos em linguagens com tipagem estática.",
                                  "commonMistakes": [
                                    "Confundir coerção implícita com casting explícito",
                                    "Ignorar promoção numérica (int + double)"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar Operações Aritméticas para Conflitos de Tipos",
                                  "subSteps": [
                                    "Identifique operadores aritméticos (+, -, *, /) e seus requisitos de tipo.",
                                    "Verifique binários: ambos operandos devem ser numéricos ou compatíveis.",
                                    "Analise unários: ex: - em string é inválido.",
                                    "Detecte sobrecarga de operadores em linguagens como C++.",
                                    "Simule avaliação de expressões com tipos mistos."
                                  ],
                                  "verification": "Analise 3 expressões aritméticas e classifique cada uma como válida ou inválida, justificando.",
                                  "estimatedTime": "30 min",
                                  "materials": [
                                    "Exemplos de código em C ou Java com operações aritméticas",
                                    "Compilador online (ex: repl.it)"
                                  ],
                                  "tips": "Comece avaliando o tipo de cada operando isoladamente antes da operação.",
                                  "learningObjective": "Detectar incompatibilidades em expressões aritméticas usando regras de tipagem.",
                                  "commonMistakes": [
                                    "Permitir string + int sem concatenação explícita",
                                    "Esquecer promoção de tipos inteiros"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Verificar Atribuições e Declarações de Variáveis",
                                  "subSteps": [
                                    "Examine declarações: tipo declarado vs. inicializador.",
                                    "Analise atribuições: tipo da expressão deve coincidir com o da variável.",
                                    "Considere casting explícito (int) vs. implícito.",
                                    "Verifique parâmetros de funções e retornos.",
                                    "Rastreie inferência de tipos em linguagens como TypeScript."
                                  ],
                                  "verification": "Corrija 4 snippets de código com erros de atribuição de tipos.",
                                  "estimatedTime": "40 min",
                                  "materials": [
                                    "Snippets de código com erros comuns",
                                    "IDE com realce de erros (ex: VS Code com extensões)"
                                  ],
                                  "tips": "Acompanhe o 'tipo fluxo' da variável ao longo do escopo.",
                                  "learningObjective": "Identificar e classificar erros de tipo em atribuições e declarações.",
                                  "commonMistakes": [
                                    "Confundir tipo da variável com tipo da expressão",
                                    "Ignorar inicializadores em declarações implícitas"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Simular Detecção em um Programa Completo",
                                  "subSteps": [
                                    "Construa uma tabela de símbolos com tipos de variáveis.",
                                    "Percorra o AST (Abstract Syntax Tree) simulando análise semântica.",
                                    "Implemente uma função simples de verificação de tipos.",
                                    "Teste com código inválido e valide saídas.",
                                    "Refatore para múltiplos módulos ou funções."
                                  ],
                                  "verification": "Implemente um checker simples que detecta 3 erros em um programa de 20 linhas.",
                                  "estimatedTime": "60 min",
                                  "materials": [
                                    "Parser simples ou ferramenta como ANTLR",
                                    "Código-fonte exemplo com erros semânticos"
                                  ],
                                  "tips": "Use caminhada em profundidade no AST para análise bottom-up.",
                                  "learningObjective": "Aplicar detecção de incompatibilidades em contexto de programa inteiro.",
                                  "commonMistakes": [
                                    "Não propagar tipos em chamadas de função",
                                    "Esquecer escopos aninhados"
                                  ]
                                }
                              ],
                              "practicalExample": "Em C: int x = \"hello\"; // Erro: incompatibilidade string para int. Correção: usar strcmp ou casting inválido detectado.",
                              "finalVerifications": [
                                "Identifica corretamente 90% dos erros de tipo em 10 snippets aleatórios.",
                                "Explica regras de compatibilidade para 5 pares de tipos.",
                                "Simula tabela de símbolos com tipos para um programa de 50 linhas.",
                                "Distingue erros de tipo de erros sintáticos.",
                                "Propõe correções viáveis para incompatibilidades detectadas.",
                                "Verifica expressões compostas com operadores mistos."
                              ],
                              "assessmentCriteria": [
                                "Precisão na classificação de incompatibilidades (sem falsos positivos).",
                                "Completude na análise de todos os nós relevantes (atribuições, ops).",
                                "Justificativa clara baseada em regras de tipagem estática.",
                                "Eficiência na simulação (tempo < 5 min por programa médio).",
                                "Capacidade de lidar com casos edge (void, pointers).",
                                "Integração com tabela de símbolos."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria de conjuntos para hierarquias de tipos.",
                                "Lógica: Provas formais de compatibilidade (predicados tipados).",
                                "Física/Engenharia: Modelagem de sistemas com tipos seguros (ex: simulações numéricas).",
                                "Linguística: Analogia com gramática e semântica natural."
                              ],
                              "realWorldApplication": "Em compiladores como GCC/Clang para C/C++, ou javac para Java, previne runtime crashes por erros como divisão string/int, garantindo robustez em software crítico como sistemas operacionais ou apps bancários."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.4.1.3",
                            "name": "Reconhecer redeclarações e duplicatas",
                            "description": "Verificar se identificadores são redeclarados no mesmo escopo, gerando erros semânticos para manter a unicidade de símbolos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender Conceitos Fundamentais de Escopo e Identificadores",
                                  "subSteps": [
                                    "Defina identificador como um nome único para variáveis, funções ou estruturas em uma linguagem de programação.",
                                    "Explique escopo como a região do código onde um identificador é visível e acessível.",
                                    "Diferencie escopos globais, locais e aninhados com diagramas simples.",
                                    "Discuta a importância da unicidade de símbolos para evitar ambiguidades semânticas.",
                                    "Estude exemplos de linguagens como C ou JavaScript onde redeclarações causam erros."
                                  ],
                                  "verification": "Crie um diagrama de escopo para um código simples e identifique regiões de visibilidade corretamente.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Documentação de linguagens de programação (C, JavaScript), papel e caneta para diagramas, editor de texto.",
                                  "tips": "Use setas para mapear visibilidade de identificadores em blocos de código.",
                                  "learningObjective": "Entender os conceitos básicos de escopo e unicidade de identificadores.",
                                  "commonMistakes": "Confundir escopo léxico com escopo dinâmico; ignorar blocos condicionais como {if}."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar Redeclarações em Escopos Simples",
                                  "subSteps": [
                                    "Escreva um código fonte simples com uma variável declarada duas vezes no mesmo escopo.",
                                    "Simule a tabela de símbolos linha por linha, marcando entradas duplicadas.",
                                    "Gere um erro semântico quando um identificador já existir na tabela atual.",
                                    "Teste variações: redeclaração imediata vs. após uso.",
                                    "Compare com código válido sem duplicatas."
                                  ],
                                  "verification": "Analise 5 trechos de código e liste corretamente todos os erros de redeclaração.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Editor de código (VS Code), exemplos de código pré-preparados, tabela de símbolos em planilha.",
                                  "tips": "Mantenha pilha de escopos para rastrear ativações/desativações.",
                                  "learningObjective": "Detectar redeclarações básicas em um único escopo.",
                                  "commonMistakes": "Não considerar declarações em loops como redeclarações se scoped corretamente."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar Escopos Aninhados e Duplicatas Hierárquicas",
                                  "subSteps": [
                                    "Construa uma árvore de escopos para funções com blocos internos.",
                                    "Percorra o código em profundidade, checando duplicatas no escopo atual e herança de pais.",
                                    "Identifique shadowings (mesmo nome em escopos filhos) vs. redeclarações reais.",
                                    "Simule pop/push de escopos em estruturas como funções e classes.",
                                    "Teste casos com múltiplas duplicatas em níveis diferentes."
                                  ],
                                  "verification": "Parse um código com 3 níveis de escopo e reporte erros semânticos sem falsos positivos.",
                                  "estimatedTime": "75 minutos",
                                  "materials": "Ferramenta de visualização de árvores (draw.io), compilador simples ou simulador em Python.",
                                  "tips": "Use mapas hash para tabelas de símbolos com chaves compostas (escopo + nome).",
                                  "learningObjective": "Gerenciar detecção de duplicatas em hierarquias de escopo.",
                                  "commonMistakes": "Confundir shadowing com redeclaração; falhar em escopos de loop/condicional."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Implementar e Testar Detector de Redeclarações",
                                  "subSteps": [
                                    "Escreva um parser simbólico básico em pseudocódigo ou Python para análise semântica.",
                                    "Integre verificação de unicidade durante a primeira passada semântica.",
                                    "Gere relatórios de erro com linha, escopo e tipo de duplicata.",
                                    "Teste com suíte de casos: válidos, inválidos, edge cases como namespaces.",
                                    "Otimize para eficiência em códigos grandes."
                                  ],
                                  "verification": "Execute o detector em 10 programas variados e valide 100% dos erros reportados.",
                                  "estimatedTime": "90 minutos",
                                  "materials": "Python ou JavaScript runtime, conjunto de testes unitários, debugger.",
                                  "tips": "Implemente como visitor pattern para árvores de sintaxe.",
                                  "learningObjective": "Construir um módulo funcional de detecção de erros semânticos.",
                                  "commonMistakes": "Não limpar tabela de símbolos ao sair de escopos; ignorar imports/aliases."
                                }
                              ],
                              "practicalExample": "Em C: int x = 1; int x = 2; // Erro: redeclaração de 'x' no mesmo escopo. Código válido: { int x=1; } int x=2; // Diferentes escopos.",
                              "finalVerifications": [
                                "Identifica corretamente redeclarações em escopo global e local.",
                                "Distingue duplicatas de shadowings em escopos aninhados.",
                                "Gera erros semânticos precisos com localização (linha/escopo).",
                                "Processa códigos com múltiplos níveis de escopo sem falhas.",
                                "Valida ausência de erros em códigos semanticamente corretos.",
                                "Testa edge cases como loops e condicionais."
                              ],
                              "assessmentCriteria": [
                                "Precisão na detecção: 95%+ sem falsos positivos/negativos.",
                                "Eficiência: Processa 100 linhas em <1s.",
                                "Relatórios claros: Inclui contexto de escopo e sugestões.",
                                "Cobertura de casos: Lida com linguagens block-scoped.",
                                "Robustez: Não crasha em inputs malformados.",
                                "Documentação: Explica lógica de verificação."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria de Conjuntos (unicidade como chaves únicas em mapas).",
                                "Lógica: Árvores e grafos para modelar escopos hierárquicos.",
                                "Linguística: Analogia com gramática e ambiguidade semântica.",
                                "Engenharia de Software: Princípios de design de APIs para tabelas de símbolos."
                              ],
                              "realWorldApplication": "Em compiladores como GCC/Clang, detecta erros em tempo de compilação evitando runtime crashes; em IDEs como VS Code, fornece linting instantâneo para refatoração de código legado."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.5.4.2",
                        "name": "Uso de Tabelas de Símbolos na Detecção",
                        "description": "Organização e consulta de tabelas de símbolos para armazenar informações semânticas e realizar verificações durante a análise semântica.",
                        "specificSkills": [
                          {
                            "id": "10.1.5.4.2.1",
                            "name": "Implementar inserção e busca em tabelas de símbolos",
                            "description": "Inserir entradas com tipo, escopo e atributos em tabelas de símbolos e realizar buscas eficientes para validar declarações e usos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Projetar a estrutura de dados para a tabela de símbolos",
                                  "subSteps": [
                                    "Defina uma estrutura para representar um símbolo (nome, tipo, escopo, atributos como visibilidade ou valor inicial).",
                                    "Escolha uma estrutura de dados base como hash table ou árvore para armazenar símbolos por escopo.",
                                    "Implemente uma pilha de escopos para suportar escopos aninhados (global, função, bloco).",
                                    "Crie classes ou structs para SymbolTable e Scope.",
                                    "Adicione suporte para metadados como linha de declaração."
                                  ],
                                  "verification": "Compile e execute um teste unitário que cria uma tabela vazia e verifica se os escopos iniciais são criados corretamente.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Linguagem de programação como C++, Python ou Java",
                                    "Editor de código (VS Code)",
                                    "Biblioteca de hash maps (std::unordered_map em C++)"
                                  ],
                                  "tips": "Use composição para aninhar escopos: cada escopo aponta para o pai.",
                                  "learningObjective": "Compreender e modelar estruturas hierárquicas para gerenciamento de escopos.",
                                  "commonMistakes": [
                                    "Ignorar escopos aninhados",
                                    "Não incluir tipo e atributos no símbolo",
                                    "Usar arrays lineares em vez de hash para buscas eficientes"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar a inserção de entradas na tabela de símbolos",
                                  "subSteps": [
                                    "Crie uma função insert(symbolName, type, attributes, currentScope).",
                                    "Verifique se o símbolo já existe no escopo atual; se sim, reporte erro de redeclaração.",
                                    "Adicione o símbolo à hash table do escopo atual com todos os atributos.",
                                    "Registre informações de escopo e linha para depuração.",
                                    "Teste inserção em escopo global e local."
                                  ],
                                  "verification": "Insira símbolos duplicados e verifique se erros são lançados; insira únicos e confirme presença via dump da tabela.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Código do Step 1",
                                    "Framework de testes unitários (Google Test para C++, unittest para Python)"
                                  ],
                                  "tips": "Sempre busque no escopo atual antes de inserir para evitar shadowing desnecessário.",
                                  "learningObjective": "Dominar inserção com detecção de duplicatas em escopos hierárquicos.",
                                  "commonMistakes": [
                                    "Inserir sem checar duplicatas",
                                    "Não propagar erros para o caller",
                                    "Esquecer de atualizar escopo atual"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar busca eficiente em tabelas de símbolos",
                                  "subSteps": [
                                    "Crie uma função lookup(symbolName, fromScope) que começa no escopo fornecido.",
                                    "Percorra a cadeia de pais (escopos ancestrais) até encontrar ou falhar.",
                                    "Retorne o símbolo completo (tipo, atributos) ou null/indique não encontrado.",
                                    "Otimize com cache se aplicável, mas priorize corretude.",
                                    "Adicione logging para rastrear caminhos de busca."
                                  ],
                                  "verification": "Teste lookup em escopo local, shadowing e escopo global; confirme retorno correto ou erro.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Código dos Steps 1-2",
                                    "Exemplos de código fonte com declarações e usos"
                                  ],
                                  "tips": "Busca linear na cadeia de escopos é aceitável para compiladores; evite buscas globais desnecessárias.",
                                  "learningObjective": "Implementar resolução de símbolos respeitando regras de visibilidade e escopo.",
                                  "commonMistakes": [
                                    "Parar na primeira ocorrência sem considerar shadowing",
                                    "Não subir para escopos pais",
                                    "Retornar símbolo errado por falha em comparação de nomes"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Gerenciar pilha de escopos (enter/leave scope)",
                                  "subSteps": [
                                    "Implemente enterScope() para push de novo escopo na pilha.",
                                    "Implemente leaveScope() para pop e descartar escopo local.",
                                    "Integre com inserção e busca para usar escopo atual da pilha.",
                                    "Mantenha ponteiro para escopo global raiz.",
                                    "Teste sequência: enter > insert local > lookup > leave > lookup global."
                                  ],
                                  "verification": "Simule parsing de um programa com blocos {} e verifique símbolos acessíveis corretamente após leave.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Código anterior",
                                    "Parser simples ou simulador de AST"
                                  ],
                                  "tips": "Use uma stack<Scope*> para fácil push/pop.",
                                  "learningObjective": "Gerenciar dinamicamente escopos durante análise semântica.",
                                  "commonMistakes": [
                                    "Vazar memória ao leave scope",
                                    "Não restaurar escopo pai corretamente",
                                    "Permitir acesso a escopos popped"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Testar e integrar em um fluxo de análise semântica",
                                  "subSteps": [
                                    "Crie um driver que simula parsing: enter scopes baseados em {}, insert declarações, lookup usos.",
                                    "Valide tipos e reporte erros semânticos (redeclaração, uso não declarado).",
                                    "Execute com casos de teste: shadowing, forward reference, erros.",
                                    "Meça performance em tabelas grandes (1000+ símbolos).",
                                    "Refatore para eficiência se necessário."
                                  ],
                                  "verification": "Todos os testes passam; dump da tabela final mostra estrutura correta.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Código completo",
                                    "Suite de testes com 10+ casos",
                                    "Ferramenta de profiling"
                                  ],
                                  "tips": "Comece com mini-linguagem como expressões com vars e funções.",
                                  "learningObjective": "Aplicar tabela de símbolos em detecção de erros semânticos reais.",
                                  "commonMistakes": [
                                    "Testes insuficientes para edge cases",
                                    "Ignorar performance em buscas",
                                    "Erros de scope leak"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um compilador para uma linguagem simples, ao parsear 'int x = 5; { int x = 10; print(x); } print(x);', insira 'x:int' global, enter scope, insira 'x:int' local (shadowing), lookup retorna local em print interno e global no externo.",
                              "finalVerifications": [
                                "Inserção detecta e rejeita redeclarações no mesmo escopo.",
                                "Busca resolve corretamente com shadowing e propagação para pais.",
                                "Enter/leave scope mantém pilha consistente sem vazamentos.",
                                "Todos atributos (tipo, escopo, linha) são armazenados e recuperados.",
                                "Testes cobrem 100% dos casos: sucesso, erros, performance.",
                                "Dump da tabela reflete estado final correto após parsing."
                              ],
                              "assessmentCriteria": [
                                "Corretude: 100% dos testes passam sem falsos positivos/negativos.",
                                "Eficiência: Busca O(1) médio via hash, cadeia de escopos curta.",
                                "Robustez: Lida com escopos profundos (até 50) e milhares de símbolos.",
                                "Clareza: Código modular com funções bem nomeadas e documentadas.",
                                "Extensibilidade: Fácil adicionar novos atributos ao símbolo.",
                                "Tratamento de erros: Mensagens claras com linha/escopo."
                              ],
                              "crossCurricularConnections": [
                                "Estruturas de Dados: Hash tables e árvores para gerenciamento eficiente.",
                                "Banco de Dados: Índices e namespaces semelhantes a schemas.",
                                "Análise de Software: Symbol resolution em debuggers/IDEs.",
                                "Algoritmos: Percurso em grafos hierárquicos (escopos como árvore).",
                                "Engenharia de Software: Design patterns como Composite para escopos."
                              ],
                              "realWorldApplication": "Em compiladores como GCC/Clang para C++, tabelas de símbolos validam declarações, tipos e escopos durante análise semântica, detectando erros como variáveis não declaradas ou redefinições, essencial para linguagens com blocos e namespaces."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.4.2.2",
                            "name": "Gerenciar escopos aninhados",
                            "description": "Tratar escopos locais e globais em tabelas de símbolos hierárquicas, resolvendo referências com busca em escopos pai.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender conceitos fundamentais de escopos locais e globais",
                                  "subSteps": [
                                    "Defina escopo local como região de código onde uma variável é visível apenas dentro de um bloco ou função.",
                                    "Defina escopo global como região visível em todo o programa, fora de blocos locais.",
                                    "Analise exemplos em linguagens como C (chaves {}) ou Python (indentação).",
                                    "Identifique shadowing: quando variável local oculta uma global com mesmo nome.",
                                    "Desenhe um diagrama simples de escopos hierárquicos."
                                  ],
                                  "verification": "Explique verbalmente ou por escrito a diferença entre escopo local, global e shadowing, com um exemplo.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Documentação de C/Python",
                                    "Papel e caneta para diagramas",
                                    "Editor de código para testes"
                                  ],
                                  "tips": "Use cores diferentes nos diagramas para representar níveis de escopo.",
                                  "learningObjective": "Diferenciar e ilustrar escopos locais, globais e shadowing.",
                                  "commonMistakes": [
                                    "Confundir visibilidade com declaração",
                                    "Ignorar que shadowing não remove a variável pai"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Estruturar tabelas de símbolos hierárquicas",
                                  "subSteps": [
                                    "Crie uma estrutura de dados para tabela de símbolos: cada escopo tem um mapa {nome: símbolo} e ponteiro para escopo pai.",
                                    "Implemente em pseudocódigo ou Python uma classe Scope com campos: symbols (dict), parent (Scope ou null).",
                                    "Inicialize o escopo global como raiz (parent = null).",
                                    "Crie método para novo escopo filho: novo Scope com parent = escopo_atual.",
                                    "Teste criação de cadeia: global -> função -> bloco interno."
                                  ],
                                  "verification": "Implemente e imprima a hierarquia de escopos vazia para um programa fictício.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Editor de código (VS Code ou similar)",
                                    "Pseudocódigo template"
                                  ],
                                  "tips": "Use JSON para serializar e visualizar a estrutura de escopos.",
                                  "learningObjective": "Modelar tabelas de símbolos com hierarquia de escopos pai-filho.",
                                  "commonMistakes": [
                                    "Esquecer ponteiro para parent",
                                    "Criar loops infinitos na hierarquia"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Inserir símbolos em escopos aninhados",
                                  "subSteps": [
                                    "Ao encontrar declaração de variável, insira no escopo atual: symbols[nome] = {tipo, linha, etc.}.",
                                    "Diferencie inserção local: sempre no escopo atual, independentemente de existência em pais.",
                                    "Implemente método insert(nome, simbolo) que permite shadowing.",
                                    "Simule passagem por um AST simples: traverse blocos e crie/insira símbolos.",
                                    "Registre linha de declaração para depuração."
                                  ],
                                  "verification": "Insira símbolos em uma hierarquia de 3 escopos e liste todos os símbolos por escopo.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Código da Step 2",
                                    "AST simples em JSON"
                                  ],
                                  "tips": "Sempre cheque o escopo atual antes de inserir para evitar vazamentos.",
                                  "learningObjective": "Gerenciar inserções locais permitindo shadowing em escopos aninhados.",
                                  "commonMistakes": [
                                    "Inserir em escopo errado (ex: global em vez de local)",
                                    "Não permitir shadowing"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Resolver referências com busca em cadeia de escopos",
                                  "subSteps": [
                                    "Ao encontrar uso de identificador, busque primeiro no escopo atual.",
                                    "Se não encontrado, recurse no parent até global ou falha.",
                                    "Implemente método lookup(nome): retorne símbolo ou null.",
                                    "Registre escopo resolvido para verificação semântica.",
                                    "Teste com referências que cruzam escopos (local usa global).",
                                    "Integre com detecção de erro: se null, reporte 'undeclared identifier'."
                                  ],
                                  "verification": "Para um código com referências mistas, resolva todas e liste escopo de origem.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Código das Steps anteriores",
                                    "Exemplos de código com referências"
                                  ],
                                  "tips": "Implemente lookup com profundidade máxima para evitar recursão infinita.",
                                  "learningObjective": "Realizar resolução de nomes via busca hierárquica em escopos pai.",
                                  "commonMistakes": [
                                    "Parar busca cedo (não subir para pai)",
                                    "Retornar múltiplos matches sem priorizar local"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Detectar e tratar erros semânticos em escopos",
                                  "subSteps": [
                                    "Identifique erros: uso antes de declaração no mesmo escopo, shadowing indesejado.",
                                    "Adicione verificações pós-população: forward references dentro de escopo.",
                                    "Implemente relatório de erros com linha e escopo.",
                                    "Teste casos: variável usada antes de declarada, shadowing excessivo.",
                                    "Limpe escopos ao sair de blocos (opcional para otimização)."
                                  ],
                                  "verification": "Compile um código com erros intencionais e verifique se todos são detectados corretamente.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Códigos de teste com erros",
                                    "Lista de erros esperados"
                                  ],
                                  "tips": "Ordene verificações por prioridade: undeclared primeiro, depois shadowing.",
                                  "learningObjective": "Integrar gerenciamento de escopos com detecção de erros semânticos.",
                                  "commonMistakes": [
                                    "Falsos positivos em shadowing válido",
                                    "Não detectar forward refs"
                                  ]
                                }
                              ],
                              "practicalExample": "Considere o código C: int globalVar = 10; void func() { int localVar = 20; { int shadowed = 30; printf(\"%d\", globalVar + localVar); } }. Crie tabela: escopo global {globalVar}, escopo func {localVar, parent=global}, escopo bloco {shadowed, parent=func}. Resolva printf: globalVar de global, localVar de func.",
                              "finalVerifications": [
                                "Construa tabela de símbolos completa para código com 3 níveis de aninhamento.",
                                "Resolva todas referências corretamente, indicando escopo de origem.",
                                "Detecte e reporte erros como 'undeclared' ou shadowing em casos inválidos.",
                                "Visualize hierarquia via diagrama ou dump JSON.",
                                "Teste com código real de 50 linhas, sem erros falsos.",
                                "Explique funcionamento para um par (peer review)."
                              ],
                              "assessmentCriteria": [
                                "Precisão na hierarquia de escopos (sem vazamentos ou loops).",
                                "Correção na inserção (local sempre priorizada).",
                                "Eficiência na lookup (busca termina corretamente).",
                                "Detecção completa de erros semânticos relacionados a escopos.",
                                "Clareza na implementação (código legível com comentários).",
                                "Robustez em testes com casos edge (ex: escopo vazio, nomes duplicados)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Estruturas hierárquicas e árvores (busca em profundidade).",
                                "Linguística: Escopos em gramáticas formais e análise sintática.",
                                "Programação: Namespaces e módulos em linguagens modernas (Python, Java).",
                                "Engenharia de Software: Gerenciamento de dependências em sistemas modulares.",
                                "Lógica: Resolução de ambiguidades em contextos aninhados."
                              ],
                              "realWorldApplication": "Em compiladores como GCC/Clang, para análise semântica de programas com funções/blocos aninhados; em IDEs (VS Code) para IntelliSense e detecção de erros em tempo real; em interpretadores de linguagens dinâmicas como JavaScript para resolução de variáveis em closures."
                            },
                            "estimatedTime": "0.75 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.4.2.3",
                            "name": "Atualizar atributos semânticos",
                            "description": "Atualizar informações como tipo inferido ou endereço na tabela de símbolos durante a travessia da árvore sintática.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender atributos semânticos e tabela de símbolos",
                                  "subSteps": [
                                    "Estude a estrutura da tabela de símbolos, incluindo campos como nome, tipo, escopo e endereço.",
                                    "Identifique atributos semânticos comuns: tipo inferido, endereço de memória, visibilidade.",
                                    "Analise exemplos de como atributos são inicializados na fase de declaração.",
                                    "Revise a árvore sintática (AST) e como ela representa declarações e expressões.",
                                    "Mapeie nós da AST que requerem atualização de atributos (ex: declarações de variáveis)."
                                  ],
                                  "verification": "Liste 5 atributos semânticos comuns e explique sua relação com a tabela de símbolos em um diagrama simples.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Documentação de compiladores (ex: Dragon Book capítulo 6)",
                                    "Exemplo de AST em JSON",
                                    "Editor de diagramas como Draw.io"
                                  ],
                                  "tips": "Comece com linguagens simples como C para visualizar melhor os fluxos.",
                                  "learningObjective": "Entender o papel dos atributos semânticos na análise semântica e sua armazenagem na tabela de símbolos.",
                                  "commonMistakes": [
                                    "Confundir atributos sintáticos com semânticos",
                                    "Ignorar escopos aninhados",
                                    "Não diferenciar inferência de tipo de declaração explícita"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Configurar estruturas de dados para atualização",
                                  "subSteps": [
                                    "Defina uma estrutura para o registro na tabela de símbolos (ex: struct Symbol { string name; Type* inferredType; int address; }).",
                                    "Implemente funções auxiliares: inserir símbolo, buscar por nome e escopo.",
                                    "Crie um visitor pattern ou recursão para percorrer a AST.",
                                    "Inicialize a tabela de símbolos vazia antes da travessia.",
                                    "Defina regras de inferência de tipo para expressões básicas (ex: int + int -> int)."
                                  ],
                                  "verification": "Implemente e teste uma tabela de símbolos que insere e busca 3 símbolos corretamente.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Linguagem de programação como Python/C++",
                                    "Templates de tabela de símbolos online",
                                    "AST parser simples (ex: ANTLR ou hand-made)"
                                  ],
                                  "tips": "Use mapas hash para busca eficiente e pilha para escopos.",
                                  "learningObjective": "Configurar dados persistentes para armazenar e acessar atributos durante a análise.",
                                  "commonMistakes": [
                                    "Não gerenciar escopos corretamente",
                                    "Vazamentos de memória em alocações de endereço",
                                    "Busca sem considerar escopo atual"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar lógica de atualização na travessia da AST",
                                  "subSteps": [
                                    "Percorra nós de declaração: busque ou insira símbolo e defina tipo explícito/inferido.",
                                    "Para expressões: inferir tipos recursivamente e propagar para nós pais.",
                                    "Atualize endereço: calcule offset baseado no escopo atual e tamanho do tipo.",
                                    "Integre verificações de erros (ex: tipo incompatível) durante atualização.",
                                    "Salve atributos na tabela e propague para nós dependentes."
                                  ],
                                  "verification": "Execute travessia em uma AST simples e verifique se atributos foram atualizados corretamente via debug prints.",
                                  "estimatedTime": "90 minutos",
                                  "materials": [
                                    "Código base de parser/AST",
                                    "Debugger do IDE (ex: VSCode, CLion)",
                                    "Exemplos de código fonte simples"
                                  ],
                                  "tips": "Use pós-ordem na recursão para garantir que filhos sejam processados antes.",
                                  "learningObjective": "Aplicar regras semânticas para atualizar atributos dinamicamente durante a análise.",
                                  "commonMistakes": [
                                    "Atualizar fora de ordem (pré vs pós)",
                                    "Não propagar inferências",
                                    "Sobrescrever símbolos de escopos pai"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Testar e depurar atualizações de atributos",
                                  "subSteps": [
                                    "Crie casos de teste: declarações simples, expressões mistas, escopos aninhados.",
                                    "Compare atributos esperados vs reais após travessia.",
                                    "Depure erros comuns como tipos não inferidos ou endereços incorretos.",
                                    "Otimize para performance em ASTs maiores.",
                                    "Documente o fluxo de atualização em pseudocódigo."
                                  ],
                                  "verification": "Todos os testes passam com 100% de cobertura de atributos atualizados.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Framework de testes (ex: unittest em Python)",
                                    "Casos de teste pré-definidos",
                                    "Ferramentas de profiling"
                                  ],
                                  "tips": "Comece com testes unitários por nó da AST antes de integração.",
                                  "learningObjective": "Validar a robustez da implementação de atualizações semânticas.",
                                  "commonMistakes": [
                                    "Testes insuficientes para edge cases",
                                    "Ignorar warnings de tipo",
                                    "Não limpar tabela entre testes"
                                  ]
                                }
                              ],
                              "practicalExample": "Em uma AST para 'int x = 5 + y;' (onde y é float declarado antes): durante travessia, inferir tipo de '5 + y' como float, atualizar símbolo 'x' com tipo float e endereço 0x100, inserindo na tabela de símbolos do escopo atual.",
                              "finalVerifications": [
                                "Pode percorrer manualmente uma AST pequena e listar atributos atualizados?",
                                "Implementa uma tabela que gerencia 3 escopos aninhados corretamente?",
                                "Detecta e reporta erro se tipo inferido não match declaração explícita?",
                                "Calcula endereços sequenciais corretos para múltiplas variáveis?",
                                "Explica a diferença entre atualização em declaração vs uso?",
                                "Depura um caso onde inferência falha em expressões binárias?"
                              ],
                              "assessmentCriteria": [
                                "Precisão na inferência e atualização de tipos (100% nos testes)",
                                "Gerenciamento correto de escopos e endereços",
                                "Eficiência da travessia (O(n) tempo)",
                                "Tratamento de erros semânticos durante atualização",
                                "Clareza e modularidade do código implementado",
                                "Cobertura completa de nós AST relevantes"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Inferência de tipos como resolução de sistemas lineares",
                                "Engenharia de Software: Padrões Visitor e Gerenciamento de Estado",
                                "Banco de Dados: Tabelas de símbolos semelhantes a catálogos de metadados",
                                "Lógica: Propagação de atributos como encadeamento de inferências"
                              ],
                              "realWorldApplication": "Em compiladores profissionais como GCC ou LLVM, atualizar atributos semânticos permite geração de código otimizado, detecção precoce de erros e suporte a otimizações como inlining e eliminação de código morto."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.5.4.3",
                        "name": "Estratégias de Tratamento e Recuperação",
                        "description": "Técnicas para reportar erros semânticos de forma clara e estratégias de recuperação para continuar a análise semântica.",
                        "specificSkills": [
                          {
                            "id": "10.1.5.4.3.1",
                            "name": "Gerar mensagens de erro informativas",
                            "description": "Produzir mensagens detalhadas com linha, coluna e contexto do erro semântico, facilitando depuração pelo programador.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Configurar rastreamento de posições no lexer e parser",
                                  "subSteps": [
                                    "Modifique o lexer para registrar linha e coluna de cada token.",
                                    "Passe informações de posição (linha, coluna) para o parser durante a análise sintática.",
                                    "Crie uma estrutura de dados (ex: TokenPosition) para armazenar linha, coluna e texto do token.",
                                    "Integre o rastreamento no nó da árvore de sintaxe (AST) para análise semântica.",
                                    "Teste com um código simples para verificar captura correta de posições."
                                  ],
                                  "verification": "Execute o lexer/parser em um arquivo de teste e inspecione os tokens/AST para confirmar que posições estão registradas corretamente.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Código fonte do lexer/parser (ex: ANTLR, Flex/Bison ou implementação customizada), editor de código, debugger.",
                                  "tips": "Use estruturas imutáveis para posições para evitar bugs de mutação acidental.",
                                  "learningObjective": "Entender como propagar metadados de posição do código fonte através das fases do compilador.",
                                  "commonMistakes": "Ignorar que quebras de linha afetam a coluna; não resetar contadores de posição corretamente."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Detectar erros semânticos e capturar contexto",
                                  "subSteps": [
                                    "Identifique pontos comuns de erros semânticos (ex: variável não declarada, tipo incompatível).",
                                    "Ao detectar erro, colete posição exata do token problemático.",
                                    "Extraia snippet de contexto: 1-2 linhas antes/depois do erro do código fonte.",
                                    "Armazene detalhes do erro em uma estrutura (ex: SemanticError com descrição, posição, contexto).",
                                    "Evite pausar análise prematuramente; colete múltiplos erros."
                                  ],
                                  "verification": "Simule um erro semântico em código teste e verifique se SemanticError contém posição e contexto corretos.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Código do analisador semântico, exemplos de código com erros semânticos, tabela de símbolos.",
                                  "tips": "Priorize erros mais críticos para contexto mais detalhado, mas limite tamanho para performance.",
                                  "learningObjective": "Capturar informações ricas de erro durante a análise semântica sem interromper o fluxo.",
                                  "commonMistakes": "Capturar posição errada (ex: do token seguinte); contexto muito longo que polui a mensagem."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Construir e formatar mensagens de erro detalhadas",
                                  "subSteps": [
                                    "Defina templates padronizados: 'Erro semântico: [descrição]. Linha [linha], Coluna [coluna].'",
                                    "Inclua contexto formatado: destaque o token problemático com setas (^).",
                                    "Adicione sugestões de correção quando possível (ex: 'Talvez declare a variável?').",
                                    "Use cores ou formatação ANSI para saída em terminal se suportado.",
                                    "Implemente função geradora de mensagem que recebe SemanticError e retorna string formatada."
                                  ],
                                  "verification": "Gere mensagens para 3 erros diferentes e compare com exemplos de compiladores profissionais (GCC/Clang).",
                                  "estimatedTime": "50 minutos",
                                  "materials": "Função de formatação de strings, exemplos de mensagens de erro de compiladores reais.",
                                  "tips": "Mantenha mensagens concisas (máx 100 chars + contexto) para facilitar leitura rápida.",
                                  "learningObjective": "Criar mensagens legíveis e padronizadas que acelerem depuração.",
                                  "commonMistakes": "Mensagens vagas como 'erro na linha X'; formatação inconsistente entre erros."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Integrar geração de erros e testar recuperação",
                                  "subSteps": [
                                    "Chame gerador de mensagem no visitor/analisador semântico ao detectar erro.",
                                    "Colete e emita todas mensagens ao final da análise (modo batch).",
                                    "Teste com códigos complexos contendo múltiplos erros.",
                                    "Meça impacto na performance e otimize se necessário.",
                                    "Adicione suporte a saída em arquivo ou JSON para ferramentas externas."
                                  ],
                                  "verification": "Compile 5 arquivos com erros variados; verifique se todas mensagens são emitidas corretamente sem crash.",
                                  "estimatedTime": "40 minutos",
                                  "materials": "Suite de testes unitários/integração, códigos de teste com erros semânticos conhecidos.",
                                  "tips": "Use logging levels para diferenciar warnings de erros fatais.",
                                  "learningObjective": "Integrar mensagens informativas em um fluxo de compilação robusto com recuperação de erros.",
                                  "commonMistakes": "Parar na primeira mensagem (perdendo erros subsequentes); vazamentos de memória em coletas de erros."
                                }
                              ],
                              "practicalExample": "Código fonte: linha 5: x = 5; (variável x não declarada). Mensagem gerada: 'Erro semântico: Variável \"x\" não declarada. Linha 5, Coluna 3.\nContexto:\n  4 | int y = 10;\n  5 | x = 5;     ^\nSugestão: Declare \"x\" antes do uso.'",
                              "finalVerifications": [
                                "Mensagem inclui linha e coluna exatas do erro.",
                                "Contexto de código fonte é exibido com destaque do problema.",
                                "Descrição é clara e específica ao tipo de erro semântico.",
                                "Múltiplos erros são reportados sem interrupção.",
                                "Mensagem é formatada consistentemente e legível em terminal.",
                                "Sugestões de correção estão presentes quando aplicáveis."
                              ],
                              "assessmentCriteria": [
                                "Precisão da localização (linha/coluna correta em 100% dos testes).",
                                "Clareza da descrição (entendível por programador iniciante).",
                                "Utilidade do contexto (facilita identificação visual do problema).",
                                "Eficiência (não degrada performance da análise >10%).",
                                "Robustez (lida com erros edge como EOF ou multiline).",
                                "Consistência com padrões de compiladores profissionais."
                              ],
                              "crossCurricularConnections": [
                                "Design de UX/UI: Princípios de feedback claro e erro humano-centrado.",
                                "Engenharia de Software: Logging e debugging em sistemas complexos.",
                                "Linguística Computacional: Análise de linguagem natural para descrições de erro.",
                                "Testes e QA: Estratégias de teste para cenários de falha."
                              ],
                              "realWorldApplication": "Em compiladores como GCC/Clang ou IDEs como VS Code, mensagens detalhadas reduzem tempo de depuração de horas para minutos, essencial em desenvolvimento de software profissional e open-source."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.4.3.2",
                            "name": "Aplicar recuperação de erros",
                            "description": "Implementar estratégias como pular declarações inválidas ou inserir símbolos fictícios para prosseguir com a análise semântica.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender Conceitos de Recuperação de Erros em Análise Semântica",
                                  "subSteps": [
                                    "Estude os tipos comuns de erros semânticos (ex.: tipo incompatível, variável não declarada).",
                                    "Analise estratégias de recuperação: pular declaração inválida, inserção de símbolos fictícios, sincronização em pontos delimitadores.",
                                    "Revise exemplos de árvores de sintaxe abstrata (AST) antes e depois da recuperação.",
                                    "Compare com análise léxica e sintática para diferenciar contextos.",
                                    "Documente prós e contras de cada estratégia em um quadro comparativo."
                                  ],
                                  "verification": "Criar um resumo de 1 página listando 5 erros semânticos comuns e 3 estratégias de recuperação com exemplos.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Livro 'Compilers: Principles, Techniques, and Tools' (Dragon Book), capítulos sobre análise semântica",
                                    "Artigos online sobre error recovery in parsers",
                                    "Notebook para anotações"
                                  ],
                                  "tips": "Use diagramas de fluxo para visualizar como o parser prossegue após erro.",
                                  "learningObjective": "Identificar e explicar diferentes estratégias de recuperação de erros semânticos.",
                                  "commonMistakes": [
                                    "Confundir recuperação semântica com sintática",
                                    "Ignorar impacto na precisão de diagnósticos subsequentes"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar Estratégia de Pular Declarações Inválidas",
                                  "subSteps": [
                                    "Configure um ambiente de compilador simples (ex.: usando ANTLR ou Yacc para análise semântica).",
                                    "Identifique no código do analisador semântico o ponto de detecção de erro (ex.: verificação de tipos).",
                                    "Adicione lógica condicional: ao detectar erro, avance o ponteiro para o próximo ';'.",
                                    "Registre o erro em um log sem interromper o parsing.",
                                    "Teste com código fonte contendo uma declaração inválida seguida de válida."
                                  ],
                                  "verification": "Executar o compilador em um arquivo com erro semântico e confirmar que declarações subsequentes são processadas corretamente.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "IDE com suporte a Java/Python (ex.: IntelliJ, VS Code)",
                                    "Gramática de exemplo para mini-linguagem",
                                    "Código base de analisador semântico open-source"
                                  ],
                                  "tips": "Use try-catch ou flags de erro para isolar a recuperação sem propagar exceções.",
                                  "learningObjective": "Codificar uma estratégia básica de recuperação que permita continuidade da análise.",
                                  "commonMistakes": [
                                    "Avançar incorretamente e pular código válido",
                                    "Não registrar erros adequadamente para diagnósticos"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar Inserção de Símbolos Fictícios",
                                  "subSteps": [
                                    "No ponto de erro (ex.: variável não declarada), crie um símbolo fictício no escopo atual.",
                                    "Defina atributos mínimos para o símbolo (ex.: tipo inferido como 'unknown').",
                                    "Substitua referências à variável inválida pelo fictício na AST.",
                                    "Continue a análise semântica com o símbolo inserido.",
                                    "Adicione limpeza ou marcação para diferenciar símbolos fictícios em relatórios de erro."
                                  ],
                                  "verification": "Compilar código com referência a variável indefinida e verificar se o erro é reportado, mas análise prossegue com tipo inferido.",
                                  "estimatedTime": "2.5 horas",
                                  "materials": [
                                    "Código base do Step 2",
                                    "Ferramentas de visualização de AST (ex.: ANTLR GUI)",
                                    "Exemplos de código com erros semânticos variados"
                                  ],
                                  "tips": "Mantenha um contador de símbolos fictícios para evitar conflitos de nomes.",
                                  "learningObjective": "Desenvolver recuperação proativa inserindo elementos para manter consistência semântica.",
                                  "commonMistakes": [
                                    "Inserir símbolo sem atributos adequados, causando erros em cascata",
                                    "Não marcar como fictício, confundindo o usuário"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Testar, Integrar e Refinar Estratégias de Recuperação",
                                  "subSteps": [
                                    "Crie suíte de testes com 10+ casos: erros isolados, múltiplos erros, edge cases.",
                                    "Integre múltiplas estratégias (panic mode, inserção) com heurísticas de seleção.",
                                    "Meça métricas: taxa de recuperação, precisão de diagnósticos, tempo de análise.",
                                    "Otimize baseado em resultados (ex.: priorize inserção para erros de declaração).",
                                    "Gere relatório de erros amigável destacando recuperações aplicadas."
                                  ],
                                  "verification": "80% dos testes de erro devem permitir análise completa de pelo menos 70% do código fonte.",
                                  "estimatedTime": "3 horas",
                                  "materials": [
                                    "Framework de testes unitários (JUnit/Pytest)",
                                    "Gerador de códigos com erros aleatórios",
                                    "Ferramentas de profiling (ex.: VisualVM)"
                                  ],
                                  "tips": "Priorize recuperação que minimize falsos positivos em diagnósticos.",
                                  "learningObjective": "Avaliar e otimizar estratégias de recuperação para robustez em compiladores.",
                                  "commonMistakes": [
                                    "Testes insuficientes para cenários reais",
                                    "Ignorar performance em códigos grandes"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um compilador para mini-linguagem: código 'int x = 'abc'; int y = x + 1;' detecta erro de tipo em x, insere símbolo fictício 'x' como int, prossegue calculando y=2, reportando apenas o erro original.",
                              "finalVerifications": [
                                "Compilador processa 100% do código após erro semântico único.",
                                "Relatório lista todos erros sem duplicatas ou omissões.",
                                "AST gerada mantém integridade para código válido subsequente.",
                                "Tempo de análise aumenta <20% com recuperação ativada.",
                                "Estratégia selecionada varia corretamente por tipo de erro.",
                                "Símbolos fictícios são removidos ou marcados na saída final."
                              ],
                              "assessmentCriteria": [
                                "Precisão na detecção e recuperação (sem falsos negativos).",
                                "Eficiência computacional da implementação.",
                                "Qualidade dos diagnósticos de erro gerados.",
                                "Flexibilidade para múltiplos tipos de erros semânticos.",
                                "Robustez em códigos com erros compostos.",
                                "Facilidade de manutenção do código de recuperação."
                              ],
                              "crossCurricularConnections": [
                                "Programação Defensiva: Tratamento de exceções em aplicações gerais.",
                                "Design de UX em Software: Mensagens de erro claras e recuperação automática.",
                                "Inteligência Artificial: Recuperação em parsing de linguagem natural.",
                                "Engenharia de Software: Logging e monitoramento de falhas."
                              ],
                              "realWorldApplication": "Em compiladores como GCC/Clang, permite edição contínua em IDEs (ex.: VS Code IntelliSense continua sugestões após erros), debuggers que analisam código parcial, e ferramentas de linting que reportam múltiplos issues sem parar."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.4.3.3",
                            "name": "Integrar detecção na árvore sintática",
                            "description": "Executar verificações semânticas em visitors ou traversais pós-sintáticas na árvore de análise sintática.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Configurar a infraestrutura da Árvore Sintática Abstrata (AST) para suporte semântico",
                                  "subSteps": [
                                    "Analise a estrutura atual da AST gerada pelo parser.",
                                    "Adicione campos auxiliares nos nós da AST para armazenar informações semânticas (ex: símbolo table pointers).",
                                    "Implemente um construtor de AST que propague contexto semântico durante a construção.",
                                    "Teste a construção da AST com códigos fonte simples.",
                                    "Documente os nós modificados."
                                  ],
                                  "verification": "Compile um programa simples e inspecione a AST gerada para confirmar campos semânticos adicionados via debugger ou dump.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Código fonte do parser",
                                    "Documentação da linguagem alvo",
                                    "Ferramentas de debug como GDB ou print statements"
                                  ],
                                  "tips": "Use herança ou composição para estender nós existentes sem quebrar o parser.",
                                  "learningObjective": "Entender como preparar a AST para análises semânticas eficientes.",
                                  "commonMistakes": [
                                    "Modificar nós sem atualizar o parser, causando crashes",
                                    "Ignorar propagação de contexto, levando a informações incompletas"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Mapear e definir verificações semânticas aos nós da AST",
                                  "subSteps": [
                                    "Liste erros semânticos comuns (ex: variável não declarada, type mismatch).",
                                    "Identifique nós da AST relevantes para cada verificação (ex: VarDecl, VarRef).",
                                    "Defina funções de verificação para cada tipo de nó, com parâmetros de contexto.",
                                    "Crie uma tabela de símbolos global ou por escopo para consultas.",
                                    "Priorize verificações independentes de ordem para execução pós-sintática.",
                                    "Escreva pseudocódigo para cada verificação."
                                  ],
                                  "verification": "Crie um diagrama ou tabela mapeando erros a nós e valide com exemplos de código inválido.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Especificação da linguagem",
                                    "Exemplos de códigos com erros semânticos",
                                    "Ferramentas de diagramação como Draw.io"
                                  ],
                                  "tips": "Comece com verificações locais (intra-nó) antes de globais para simplicidade.",
                                  "learningObjective": "Mapear regras semânticas estáticas aos elementos sintáticos.",
                                  "commonMistakes": [
                                    "Esquecer escopos aninhados, causando falsos positivos",
                                    "Definir verificações sem acesso a tabela de símbolos"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar o padrão Visitor ou Traversal para detecção de erros",
                                  "subSteps": [
                                    "Escolha entre Visitor (double dispatch) ou traversal recursivo simples.",
                                    "Defina a interface Visitor com métodos visit para cada tipo de nó.",
                                    "Implemente o visitor principal que chama verificações em cada visit.",
                                    "Colete e armazene erros semânticos em uma lista global com posições fonte.",
                                    "Adapte o traversal para pré, pós ou in-order conforme necessidade.",
                                    "Integre tabela de símbolos no visitor para consultas dinâmicas."
                                  ],
                                  "verification": "Execute o visitor em uma AST de teste e confirme que todos nós são visitados sem erros de runtime.",
                                  "estimatedTime": "3 horas",
                                  "materials": [
                                    "Código da AST",
                                    "Exemplos de implementação Visitor em linguagens como Java/C++",
                                    "IDE com suporte a refatoração"
                                  ],
                                  "tips": "Use polimorfismo para dispatch automático por tipo de nó.",
                                  "learningObjective": "Aplicar padrões de design para traversals estruturados em árvores.",
                                  "commonMistakes": [
                                    "Visitor recursivo causando stack overflow em ASTs profundas",
                                    "Não propagar contexto entre visitas"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Integrar o detector na pipeline do compilador e gerenciar recuperação de erros",
                                  "subSteps": [
                                    "Chame o visitor imediatamente após a construção da AST no parser.",
                                    "Implemente relatório de erros com linha/coluna e mensagens claras.",
                                    "Adicione suporte a recuperação (ex: continue após erro, mas flag como inválido).",
                                    "Teste end-to-end com códigos válidos e inválidos.",
                                    "Otimize para performance (ex: early exit em erros fatais)."
                                  ],
                                  "verification": "Compile códigos com erros semânticos e verifique relatórios corretos sem crashar o compilador.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Pipeline completa do compilador",
                                    "Testes unitários com JUnit ou similar",
                                    "Códigos de teste variados"
                                  ],
                                  "tips": "Use flags para habilitar/desabilitar detecção durante desenvolvimento.",
                                  "learningObjective": "Integrar análises semânticas de forma robusta no fluxo de compilação.",
                                  "commonMistakes": [
                                    "Parar compilação no primeiro erro, perdendo diagnósticos múltiplos",
                                    "Relatórios sem posições precisas"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um compilador para uma linguagem como Cool (Classroom Object-Oriented Language), implemente um visitor pós-sintático que traverse a AST para detectar redeclarações de atributos em classes. Por exemplo, no nó ClassNode, visite filhos AttributeNode e use uma tabela de símbolos local para checar duplicatas, reportando 'Attribute redeclared' na posição do segundo decl.",
                              "finalVerifications": [
                                "Todos os nós da AST são visitados corretamente sem exceções.",
                                "Erros semânticos são detectados com 100% de precisão em testes conhecidos.",
                                "Posições de erro (linha/coluna) correspondem ao fonte original.",
                                "Tabela de símbolos é populada e consultada sem vazamentos de memória.",
                                "Compilador continua após erros para múltiplos diagnósticos.",
                                "Performance de traversal é aceitável (<1s para arquivos médios)."
                              ],
                              "assessmentCriteria": [
                                "Correção da implementação do visitor/traversal (30%)",
                                "Cobertura completa de verificações semânticas mapeadas (25%)",
                                "Qualidade dos relatórios de erro (20%)",
                                "Integração seamless na pipeline sem quebrar fases anteriores (15%)",
                                "Eficiência e ausência de bugs comuns (10%)"
                              ],
                              "crossCurricularConnections": [
                                "Estruturas de Dados: Traversals em árvores e grafos.",
                                "Design Patterns: Aplicação do Visitor para extensibilidade.",
                                "Teoria da Computação: Análise estática de linguagens formais.",
                                "Engenharia de Software: Integração modular em pipelines complexos."
                              ],
                              "realWorldApplication": "Em compiladores como GCC ou Clang, visitors pós-sintáticos detectam erros como variáveis não inicializadas ou violações de tipo em C/C++, permitindo diagnósticos precisos em IDEs como VS Code e otimizações subsequentes apenas em código semântico válido."
                            },
                            "estimatedTime": "0.75 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.4.3.4",
                            "name": "Priorizar erros semânticos",
                            "description": "Classificar e reportar erros por severidade, evitando cascata de erros desnecessários na análise.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender Tipos de Erros Semânticos e Níveis de Severidade",
                                  "subSteps": [
                                    "Estude os principais tipos de erros semânticos: variáveis não declaradas, incompatibilidades de tipo, violações de escopo e sobrecarga incorreta.",
                                    "Classifique erros em categorias: fatais (impedem execução), graves (afetam lógica), moderados (otimizações perdidas) e leves (estilo).",
                                    "Analise exemplos de código fonte com erros mistos e identifique dependências entre eles.",
                                    "Crie uma tabela de classificação com critérios como impacto na execução, frequência e facilidade de correção.",
                                    "Discuta com pares ou documente justificativas para cada classificação."
                                  ],
                                  "verification": "Tabela de classificação completa com pelo menos 10 exemplos de erros categorizados corretamente.",
                                  "estimatedTime": "2 horas",
                                  "materials": "Documentação de compiladores (ex: Dragon Book), exemplos de código em C ou mini-linguagens.",
                                  "tips": "Use diagramas de fluxo para visualizar dependências entre erros.",
                                  "learningObjective": "Dominar a taxonomia de erros semânticos e sua severidade.",
                                  "commonMistakes": "Confundir erros sintáticos com semânticos; superestimar severidade de warnings."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Desenvolver Algoritmo de Priorização e Classificação",
                                  "subSteps": [
                                    "Defina regras de priorização: erros fatais primeiro, depois graves, evitando análises dependentes.",
                                    "Implemente uma função em pseudocódigo que ordene erros por severidade e ID único.",
                                    "Incorpore detecção de cascata: marque erros 'bloqueadores' que invalidem análises subsequentes.",
                                    "Crie heurísticas para agrupar erros relacionados (ex: múltiplas usos de variável não declarada).",
                                    "Teste o algoritmo manualmente com 5 cenários de código com erros múltiplos."
                                  ],
                                  "verification": "Pseudocódigo funcional que prioriza corretamente erros em pelo menos 5 testes manuais.",
                                  "estimatedTime": "3 horas",
                                  "materials": "Editor de texto, papel para fluxogramas, exemplos de código com erros semânticos.",
                                  "tips": "Priorize erros por 'custo de correção' para otimizar o feedback ao programador.",
                                  "learningObjective": "Criar lógica para classificar e priorizar erros evitando cascata.",
                                  "commonMistakes": "Ignorar dependências entre erros, levando a relatórios redundantes."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar e Integrar em um Analisador Semântico Simples",
                                  "subSteps": [
                                    "Construa um analisador semântico básico em Python ou Java para uma mini-linguagem.",
                                    "Integre o algoritmo de priorização no relatório de erros.",
                                    "Adicione filtros para suprimir erros em cascata após detectar um bloqueador.",
                                    "Gere saídas formatadas: lista ordenada com severidade, linha e sugestão de correção.",
                                    "Execute em códigos de teste e ajuste com base em falsos positivos/negativos."
                                  ],
                                  "verification": "Analisador roda em 3 arquivos de teste e produz relatórios priorizados sem cascata.",
                                  "estimatedTime": "4 horas",
                                  "materials": "Python/Java IDE, biblioteca ANTLR ou Ply para parsing, códigos de teste preparados.",
                                  "tips": "Use logging para rastrear decisões de priorização durante depuração.",
                                  "learningObjective": "Aplicar priorização em um contexto real de análise semântica.",
                                  "commonMistakes": "Implementar priorização só por linha, ignorando dependências lógicas."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Testar, Refinar e Documentar o Sistema",
                                  "subSteps": [
                                    "Crie suíte de testes com 20 casos: isolados, múltiplos e com potenciais cascatas.",
                                    "Meça eficácia: taxa de detecção, redução de falsos positivos e tempo de análise.",
                                    "Refine regras baseadas em resultados, adicionando pesos dinâmicos por contexto.",
                                    "Documente o sistema: guia de uso, limitações e extensões futuras.",
                                    "Apresente um relatório comparando antes/depois da priorização."
                                  ],
                                  "verification": "Suíte de testes passa 90%+ e documentação cobre todos os aspectos.",
                                  "estimatedTime": "2.5 horas",
                                  "materials": "Ferramentas de teste unitário (pytest/JUnit), planilha para métricas.",
                                  "tips": "Automatize testes para regressão futura.",
                                  "learningObjective": "Validar e iterar o sistema de priorização para robustez.",
                                  "commonMistakes": "Testes insuficientes em cenários edge-case como recursão ou herança."
                                }
                              ],
                              "practicalExample": "Em um compilador para MiniLang, código com 'x = undeclared_var + 1.5;' (não declarada: fatal) e 'int y = \"string\";' (tipo incompatível: grave). Priorize 'undeclared_var' primeiro, suprimindo análise de tipo em usos subsequentes, reportando apenas: 1. Fatal: linha 5, var não declarada. 2. Grave: linha 6, tipo incompatível.",
                              "finalVerifications": [
                                "Classifica corretamente 95% dos erros em testes padrão por severidade.",
                                "Evita cascata: relatórios reduzem >30% em códigos com erros múltiplos.",
                                "Gera sugestões acionáveis para 80% dos erros priorizados.",
                                "Sistema roda em <1s para arquivos de 1000 linhas.",
                                "Documentação permite reprodução por terceiros.",
                                "Integra sem quebrar análises sem erros."
                              ],
                              "assessmentCriteria": [
                                "Precisão na classificação de severidade (pontos por acerto em testes).",
                                "Efetividade na prevenção de cascata (medida por redução de erros reportados).",
                                "Clareza e utilidade dos relatórios gerados.",
                                "Robustez em cenários variados (unit tests pass rate).",
                                "Eficiência computacional (tempo e memória).",
                                "Qualidade da documentação e extensibilidade."
                              ],
                              "crossCurricularConnections": [
                                "Engenharia de Software: Práticas de debugging e linting em IDEs.",
                                "Gestão de Riscos: Priorização de falhas em sistemas críticos como segurança.",
                                "Inteligência Artificial: Classificação de anomalias em ML pipelines.",
                                "Lógica e Matemática: Teoria de grafos para dependências de erros."
                              ],
                              "realWorldApplication": "Em compiladores como GCC/Clang ou IDEs (VSCode, IntelliJ), priorização otimiza feedback ao desenvolvedor, reduzindo tempo de debug em projetos grandes e evitando overwhelm com centenas de warnings irrelevantes."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      }
                    ]
                  }
                ]
              },
              {
                "id": "10.1.6",
                "name": "Geração de Código Intermediário e Objeto",
                "description": "Processos de transformação do código analisado em representações intermediárias e código executável final.",
                "totalSkills": 46,
                "atomicTopics": [
                  {
                    "id": "10.1.6.1",
                    "name": "Código de Três Endereços",
                    "description": "Representação intermediária comum que expressa operações com no máximo três operandos, facilitando otimizações.",
                    "individualConcepts": [
                      {
                        "id": "10.1.6.1.1",
                        "name": "Definição e Estrutura Básica do Código de Três Endereços",
                        "description": "Conceito fundamental que define o código de três endereços como uma representação intermediária linear onde cada instrução possui no máximo três operandos (um resultado e dois operandos de entrada), facilitando a tradução de expressões arbóreas em sequências lineares.",
                        "specificSkills": [
                          {
                            "id": "10.1.6.1.1.1",
                            "name": "Identificar a forma geral de instruções de três endereços",
                            "description": "Reconhecer e descrever a sintaxe padrão x = y op z, incluindo casos especiais como cópias (x = y), unárias (x = op y) e sem resultado (if x goto L), com exemplos de código fonte traduzido.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a sintaxe básica da instrução de três endereços",
                                  "subSteps": [
                                    "Estude a forma geral: x = y op z, onde x é o destino, y e z são operandos, e op é um operador binário.",
                                    "Identifique os componentes: variáveis temporárias (t1, t2), constantes ou identificadores.",
                                    "Revise exemplos simples como t1 = a + b.",
                                    "Compare com expressões aritméticas em linguagens de alto nível.",
                                    "Anote as restrições: cada instrução usa no máximo três endereços."
                                  ],
                                  "verification": "Escreva 3 exemplos de instruções na forma x = y op z e rotule cada componente (x, y, op, z).",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Documentação de código de três endereços (PDF ou wiki)",
                                    "Bloco de notas ou editor de texto"
                                  ],
                                  "tips": "Sempre pense em como uma expressão complexa é quebrada em instruções atômicas.",
                                  "learningObjective": "Reconhecer e decompor a estrutura fundamental x = y op z.",
                                  "commonMistakes": [
                                    "Confundir operadores unários com binários",
                                    "Usar mais de três endereços por instrução"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar casos especiais: cópias e operações unárias",
                                  "subSteps": [
                                    "Analise cópias: x = y (onde op está implícito como atribuição).",
                                    "Estude unárias: x = op y (ex: x = -y ou x = !y).",
                                    "Diferencie de binárias: unárias têm apenas dois endereços.",
                                    "Pratique convertendo expressões como x = -a + b em TAC.",
                                    "Liste operadores comuns unários: negação, not lógico, incremento."
                                  ],
                                  "verification": "Converta x = -a em TAC e explique por que é unária.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Exemplos de código fonte simples (Java/Python)",
                                    "Simulador de compilador online opcional"
                                  ],
                                  "tips": "Lembre-se: unárias evitam operandos desnecessários para eficiência.",
                                  "learningObjective": "Distinguir e gerar instruções de cópia e unárias corretamente.",
                                  "commonMistakes": [
                                    "Tratar cópias como binárias adicionando z desnecessário",
                                    "Esquecer o destino x em unárias"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Reconhecer instruções sem resultado (condicionais e saltos)",
                                  "subSteps": [
                                    "Estude if x goto L (condicional sem atribuição).",
                                    "Identifique goto L (salto incondicional).",
                                    "Compare com estruturas if/else em código fonte.",
                                    "Analise param e call para funções (sem x = ...).",
                                    "Pratique identificando todas as formas não-atribuição em um bloco TAC."
                                  ],
                                  "verification": "Classifique 5 instruções TAC como 'com resultado' ou 'sem resultado' e justifique.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Lista de instruções TAC padrão",
                                    "Exemplos de fluxos de controle compilados"
                                  ],
                                  "tips": "Essas instruções controlam fluxo, não computam valores.",
                                  "learningObjective": "Identificar instruções que não seguem x = ... para controle de fluxo.",
                                  "commonMistakes": [
                                    "Forçar atribuição em saltos",
                                    "Ignorar labels como L"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Praticar identificação em código fonte traduzido",
                                  "subSteps": [
                                    "Pegue um snippet de código fonte (ex: a = b + c * d).",
                                    "Traduza manualmente para TAC passo a passo.",
                                    "Identifique todas as formas: binária, unária, cópia, sem resultado.",
                                    "Compare sua tradução com uma referência.",
                                    "Analise erros comuns em traduções reais de compiladores."
                                  ],
                                  "verification": "Traduza um expressão composta para TAC e rotule cada instrução com seu tipo.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Código fonte exemplo: função simples em C/Python",
                                    "Ferramenta de visualização TAC (opcional)"
                                  ],
                                  "tips": "Quebre expressões em ordem de precedência para TAC correto.",
                                  "learningObjective": "Aplicar identificação em cenários reais de compilação.",
                                  "commonMistakes": [
                                    "Violação de precedência na tradução",
                                    "Uso excessivo de temporárias"
                                  ]
                                }
                              ],
                              "practicalExample": "Código fonte: if (a > b) c = a - b; else c = b - a;\nTAC traduzido:\nt1 = a > b\nif t1 goto L1\nc = b - a\ngoto L2\nL1: c = a - b\nL2: ...",
                              "finalVerifications": [
                                "Classifica corretamente instruções como binária, unária, cópia ou sem resultado.",
                                "Decompõe x = y op z em componentes precisos.",
                                "Traduz expressões simples de código fonte para TAC sem erros.",
                                "Identifica labels e saltos em blocos TAC.",
                                "Explica diferenças entre formas gerais e especiais.",
                                "Gera TAC para fluxos condicionais básicos."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de componentes (90%+ correto).",
                                "Correta distinção de tipos de instruções (sem confusões unária/binária).",
                                "Qualidade da tradução de código fonte (respeita precedência).",
                                "Explicações claras e concisas para cada identificação.",
                                "Ausência de erros comuns como atribuições inválidas.",
                                "Eficiência no uso de temporárias (mínimas necessárias)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Álgebra e precedência de operadores.",
                                "Programação: Assembly e linguagens de baixo nível.",
                                "Lógica: Expressões booleanas e fluxos condicionais.",
                                "Engenharia de Software: Otimização de código intermediário."
                              ],
                              "realWorldApplication": "Em compiladores como GCC ou LLVM, o TAC facilita otimizações como eliminação de código morto e alocação de registradores, essencial para gerar código executável eficiente em processadores reais."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.6.1.1.2",
                            "name": "Diferenciar representações de três endereços",
                            "description": "Comparar quadruplas (com rótulo), triplas (sem rótulo explícito) e pares de ponteiros, explicando vantagens de cada uma em termos de compactação e facilidade de otimização.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Fundamentos do Código de Três Endereços (3AC)",
                                  "subSteps": [
                                    "Defina 3AC como instruções com no máximo três endereços (operador, dois operandos e resultado).",
                                    "Identifique exemplos básicos como x = y + z.",
                                    "Explique o propósito: simplificar geração de código e otimizações.",
                                    "Diferencie de código de máquina ou assembly."
                                  ],
                                  "verification": "Explique verbalmente ou por escrito o que é 3AC e dê um exemplo simples.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Notas de aula sobre compiladores",
                                    "Capítulo relevante do 'Compilers: Principles, Techniques, and Tools' (Dragon Book)"
                                  ],
                                  "tips": "Foquem em como 3AC facilita análises de fluxo de dados.",
                                  "learningObjective": "Compreender a estrutura básica e motivação do 3AC.",
                                  "commonMistakes": "Confundir 3AC com código assembly de baixo nível, ignorando abstrações."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar Representação por Quadruplas",
                                  "subSteps": [
                                    "Descreva quadrupla como tupla (rótulo, operador, arg1, arg2/resultado).",
                                    "Construa exemplo: para 't1 = a + b', use (1, +, a, b) com resultado implícito ou explícito.",
                                    "Discuta armazenamento: array de structs com campo rótulo para saltos.",
                                    "Avalie compactação: cada instrução tem tamanho fixo."
                                  ],
                                  "verification": "Construa quadruplas para uma expressão aritmética simples e verifique sintaxe.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Papel e caneta ou editor de texto",
                                    "Exemplos de slides sobre geração de código"
                                  ],
                                  "tips": "Sempre inclua rótulos para instruções de controle de fluxo.",
                                  "learningObjective": "Dominar a estrutura e construção de quadruplas em 3AC.",
                                  "commonMistakes": "Omitir rótulos em quadruplas, confundindo com triplas."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explorar Representação por Triplas",
                                  "subSteps": [
                                    "Defina tripla como (operador, arg1, arg2), com resultado como índice da tripla anterior.",
                                    "Exemplo: para 't1 = a + b', tripla1 (+, a, b), t1 aponta para tripla1.",
                                    "Descreva tabela única para operadores e argumentos compartilhados.",
                                    "Compare compactação: mais denso que quadruplas devido a referências por índice."
                                  ],
                                  "verification": "Converta um conjunto de quadruplas em triplas equivalentes sem erros.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Ferramenta de desenho de grafos ou papel",
                                    "Referências online sobre representações de 3AC"
                                  ],
                                  "tips": "Use diagramas para visualizar dependências entre triplas.",
                                  "learningObjective": "Entender como triplas economizam espaço via referências implícitas.",
                                  "commonMistakes": "Confundir índice de resultado com rótulo explícito de quadruplas."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Estudar Representação por Pares de Ponteiros",
                                  "subSteps": [
                                    "Explique pares de ponteiros: cada instrução é (ponteiro para operador, ponteiro para lista de args).",
                                    "Exemplo: nó operador aponta para args, formando grafo para DAGs comuns.",
                                    "Discuta vantagens para otimizações: fácil detecção de subexpressões comuns.",
                                    "Avalie compactação: ótima para expressões DAG, compartilhando subárvores."
                                  ],
                                  "verification": "Desenhe representação de pares de ponteiros para uma expressão com subexpressões compartilhadas.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Software de grafos como Graphviz",
                                    "Exemplos da Dragon Book seção de geração de código"
                                  ],
                                  "tips": "Pense em estruturas de árvores para visualizar ponteiros.",
                                  "learningObjective": "Compreender representação gráfica para otimizações avançadas.",
                                  "commonMistakes": "Ignorar benefícios para DAGs, tratando como linear como triplas."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Comparar Representações e Analisar Vantagens",
                                  "subSteps": [
                                    "Compare compactação: pares > triplas > quadruplas.",
                                    "Analise facilidade de otimização: pares melhores para CSE, triplas para fluxo, quadruplas simples.",
                                    "Crie tabela comparativa com exemplos de código fonte para cada.",
                                    "Discuta trade-offs: quadruplas mais legíveis, pares mais eficientes em memória."
                                  ],
                                  "verification": "Preencha tabela comparativa corretamente e explique uma vantagem de cada.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Planilha ou tabela em Markdown",
                                    "Todos materiais anteriores"
                                  ],
                                  "tips": "Use exemplos concretos de expressões para comparações justas.",
                                  "learningObjective": "Diferenciar vantagens em compactação e otimização entre representações.",
                                  "commonMistakes": "Generalizar vantagens sem considerar cenários específicos como DAGs."
                                }
                              ],
                              "practicalExample": "Para a expressão 't3 = (a + b) * (a + b)':\n- Quadruplas: (1, +, a, b) -> t1; (2, +, a, b) -> t2; (3, *, t1, t2) -> t3.\n- Triplas: tripla1(+,a,b)=t1; tripla2(+,a,b)=t2; tripla3(*,t1,t2)=t3.\n- Pares: Nó + aponta para a e b (compartilhado para ambos *).",
                              "finalVerifications": [
                                "Liste corretamente as três representações sem confusões.",
                                "Explique vantagens de compactação para cada uma com exemplo.",
                                "Descreva como pares facilitam otimização de subexpressões comuns.",
                                "Compare facilidade de implementação em um compilador hipotético.",
                                "Construa uma representação alternativa para um código dado.",
                                "Identifique quando usar cada uma em cenários reais.",
                                "Verifique ausência de erros em uma conversão entre representações."
                              ],
                              "assessmentCriteria": [
                                "Precisão nas definições (100% correto).",
                                "Completude da comparação (todas vantagens cobertas).",
                                "Uso de exemplos concretos e corretos.",
                                "Clareza na explicação de trade-offs.",
                                "Profundidade na discussão de otimizações.",
                                "Criatividade em aplicações práticas.",
                                "Coerência e organização da resposta."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Representação de expressões como Grafos Acíclicos Direcionados (DAGs).",
                                "Algoritmos: Otimizações baseadas em análise de dependências e fluxo de dados.",
                                "Engenharia de Software: Estruturas de dados eficientes para IR em compiladores.",
                                "Banco de Dados: Índices e ponteiros em estruturas de armazenamento.",
                                "Inteligência Artificial: Representações gráficas em árvores de decisão ou redes neurais."
                              ],
                              "realWorldApplication": "Em compiladores como LLVM, IR similar a 3AC usa representações otimizadas (como DAGs via pares de ponteiros) para reduzir tamanho de código e acelerar otimizações, economizando memória em builds de software grandes como kernels do Linux."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.6.1.1.3",
                            "name": "Traduzir expressões simples para três endereços",
                            "description": "Converter expressões aritméticas lineares e com parênteses, como a + b * c + d, em sequências de instruções de três endereços, respeitando precedência de operadores.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender Conceitos Básicos de Código de Três Endereços e Precedência de Operadores",
                                  "subSteps": [
                                    "Estude a definição de código de três endereços (TAC): instruções na forma X = Y op Z ou op X, Y.",
                                    "Revise a precedência padrão de operadores aritméticos: * e / > + e -; associatividade da esquerda para a direita.",
                                    "Identifique temporários (t1, t2...) usados para quebrar operações complexas em instruções atômicas.",
                                    "Analise exemplos simples como 'a + b' → t1 = a + b.",
                                    "Pratique anotando precedência em uma expressão dada."
                                  ],
                                  "verification": "Liste corretamente a ordem de avaliação de operadores em uma expressão como a + b * c / d - e.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Folha de papel, quadro branco ou editor de texto para anotações.",
                                  "tips": "Use uma tabela de precedência impressa como referência inicial.",
                                  "learningObjective": "Dominar a estrutura TAC e regras de precedência para preparar tradução.",
                                  "commonMistakes": "Ignorar associatividade esquerda-direita; confundir TAC com assembly."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Traduzir Expressões Lineares Sem Parênteses",
                                  "subSteps": [
                                    "Identifique a operação de maior precedência (ex: * ou /) e gere uma instrução TAC para ela usando um temporário.",
                                    "Substitua a subexpressão pelo temporário e repita para a próxima maior precedência.",
                                    "Continue até que a expressão seja totalmente reduzida a um único valor final.",
                                    "Registre todas as instruções em sequência numerada.",
                                    "Teste com expressão simples como a + b * c."
                                  ],
                                  "verification": "Converta 'a + b * c - d / e' em TAC correto sem erros de ordem.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Editor de texto ou papel para escrever expressões e TAC.",
                                  "tips": "Sempre comece pelo operador de maior precedência, independentemente da posição.",
                                  "learningObjective": "Aplicar precedência para quebrar expressões lineares em TAC passo a passo.",
                                  "commonMistakes": "Processar da esquerda para direita sem respeitar precedência; omitir temporários."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Incorporar Parênteses em Expressões Complexas",
                                  "subSteps": [
                                    "Trate parênteses como subexpressões de maior precedência: traduza o conteúdo interno primeiro.",
                                    "Gere TAC para a subexpressão entre parênteses, usando um temporário para o resultado.",
                                    "Integre o temporário na expressão externa, aplicando precedência geral.",
                                    "Remova parênteses aninhados sequencialmente do interno para o externo.",
                                    "Valide com exemplo: (a + b) * c → t1 = a + b; t2 = t1 * c."
                                  ],
                                  "verification": "Traduza '(a + b * c) - d' corretamente, respeitando parênteses.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Exemplos impressos de expressões com parênteses; simulador online de TAC (opcional).",
                                  "tips": "Pinte os parênteses para visualizar subexpressões claramente.",
                                  "learningObjective": "Lidar com precedência alterada por parênteses em TAC.",
                                  "commonMistakes": "Ignorar parênteses ou tratá-los como precedência padrão; erros em aninhamento."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Praticar, Verificar e Otimizar Traduções",
                                  "subSteps": [
                                    "Escolha 5 expressões variadas (lineares e com parênteses) e traduza para TAC.",
                                    "Compare sua tradução com uma referência, checando número de instruções e ordem.",
                                    "Otimize removendo temporários desnecessários se possível.",
                                    "Simule execução do TAC com valores numéricos para validar resultado.",
                                    "Registre erros e corrija iterativamente."
                                  ],
                                  "verification": "Todas as 5 traduções produzem o mesmo resultado numérico que a expressão original.",
                                  "estimatedTime": "35 minutos",
                                  "materials": "Lista de 10 expressões de teste; calculadora para validação numérica.",
                                  "tips": "Use valores concretos (a=1, b=2...) para depurar rapidamente.",
                                  "learningObjective": "Consolidar habilidades através de prática e autoavaliação.",
                                  "commonMistakes": "TAC com mais de 3 endereços por linha; ordem errada levando a resultados incorretos."
                                }
                              ],
                              "practicalExample": "Expressão: a + b * (c + d)\nTAC:\nt1 = c + d\nt2 = b * t1\nt3 = a + t2\nResultado final: t3",
                              "finalVerifications": [
                                "Converte corretamente expressões lineares respeitando precedência.",
                                "Trata parênteses como subexpressões prioritárias.",
                                "Gera instruções TAC válidas com no máximo 3 endereços cada.",
                                "Simula execução com valores numéricos e obtém resultado idêntico.",
                                "Identifica e corrige erros comuns em traduções próprias.",
                                "Otimiza TAC minimizando temporários desnecessários."
                              ],
                              "assessmentCriteria": [
                                "Precisão na ordem de operações (100% correto em 5/5 exemplos).",
                                "Uso correto de temporários (sem violações de 3 endereços).",
                                "Respeito total a precedência e parênteses.",
                                "Validação numérica bem-sucedida em todos os casos.",
                                "Eficiência: mínimo de instruções possível.",
                                "Explicação clara do raciocínio passo a passo."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Álgebra e avaliação de expressões aritméticas.",
                                "Programação: Estruturas de controle e geração de código em compiladores.",
                                "Lógica: Análise de precedência e parsing de expressões.",
                                "Engenharia de Software: Otimização de código intermediário."
                              ],
                              "realWorldApplication": "Em compiladores como GCC ou LLVM, o TAC é gerado a partir de expressões em linguagens como C/Java para otimizar e traduzir para código máquina eficiente, permitindo análises como dead code elimination e registro alocação."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.6.1.2",
                        "name": "Instruções Comuns e Controle de Fluxo",
                        "description": "Conjunto de instruções primitivas usadas no código de três endereços para operações aritméticas, lógicas, cópias, saltos condicionais e incondicionais, além de chamadas de procedimento.",
                        "specificSkills": [
                          {
                            "id": "10.1.6.1.2.1",
                            "name": "Listar e exemplificar instruções aritméticas e lógicas",
                            "description": "Descrever instruções como ADD, SUB, MUL, DIV, EQ, NE, LT, GT, com exemplos de uso em quadruplas para expressões booleanas e aritméticas compostas.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender a sintaxe básica de quadruplas em código de três endereços",
                                  "subSteps": [
                                    "Estude a estrutura geral de uma quadrupla: (operador, operando1, operando2, resultado).",
                                    "Identifique exemplos simples como t1 = a + b representado por (ADD, a, b, t1).",
                                    "Revise convenções de temporários (t1, t2, etc.) e variáveis originais.",
                                    "Pratique anotando 3 quadruplas manuais para operações básicas.",
                                    "Compare com código assembly para visualizar similaridades."
                                  ],
                                  "verification": "Crie 5 quadruplas corretas para expressões dadas e valide contra exemplos padrão.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Documentação de código de três endereços",
                                    "Exemplos de quadruplas em PDF ou wiki",
                                    "Bloco de notas para anotações"
                                  ],
                                  "tips": [
                                    "Sempre use temporários para resultados intermediários.",
                                    "Mantenha operando1 e operando2 como fontes, resultado como destino único."
                                  ],
                                  "learningObjective": "Compreender e reproduzir a sintaxe padrão de quadruplas para instruções básicas.",
                                  "commonMistakes": [
                                    "Confundir ordem dos operandos.",
                                    "Omitir temporários em expressões compostas.",
                                    "Usar variáveis finais como temporárias."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Dominar instruções aritméticas: ADD, SUB, MUL, DIV",
                                  "subSteps": [
                                    "Liste as 4 instruções aritméticas e seus significados: ADD (soma), SUB (subtração), MUL (multiplicação), DIV (divisão).",
                                    "Construa quadruplas para expressões simples: ex. t1 = x + y → (ADD, x, y, t1).",
                                    "Expanda para expressões compostas: (x + y) * z requer múltiplas quadruplas.",
                                    "Teste com divisão: t1 = a / b → (DIV, a, b, t1), considerando precedência.",
                                    "Registre 10 exemplos variados em uma tabela."
                                  ],
                                  "verification": "Gere quadruplas corretas para 5 expressões aritméticas dadas, sem erros de precedência.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Tabela de operadores aritméticos",
                                    "Calculadora para validar resultados",
                                    "Editor de texto para simular código"
                                  ],
                                  "tips": [
                                    "Respeite precedência: MUL/DIV antes de ADD/SUB.",
                                    "Use temporários sequenciais para evitar conflitos."
                                  ],
                                  "learningObjective": "Aplicar instruções aritméticas em quadruplas para expressões simples e compostas.",
                                  "commonMistakes": [
                                    "Ignorar precedência de operadores.",
                                    "Reutilizar temporários sem calcular dependências.",
                                    "Confundir SUB com ADD negativo."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explorar instruções lógicas/relacionais: EQ, NE, LT, GT",
                                  "subSteps": [
                                    "Defina cada instrução: EQ (igual), NE (diferente), LT (menor), GT (maior).",
                                    "Crie quadruplas booleanas: if x == y → (EQ, x, y, t1), onde t1 é booleano.",
                                    "Expanda para compostas: x > y && z < w requer temporários lógicos.",
                                    "Pratique conversão de expressões condicionais em sequências de quadruplas.",
                                    "Valide com cenários numéricos: teste valores e resultados esperados."
                                  ],
                                  "verification": "Converta 4 expressões booleanas em quadruplas válidas e simule execução.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Lista de operadores relacionais",
                                    "Exemplos de fluxos condicionais",
                                    "Ferramenta online de simulador TAC (opcional)"
                                  ],
                                  "tips": [
                                    "Resultados lógicos vão para temporários booleanos (true/false ou 1/0).",
                                    "Combine com jumps para controle de fluxo posterior."
                                  ],
                                  "learningObjective": "Gerar quadruplas para comparações lógicas em expressões booleanas.",
                                  "commonMistakes": [
                                    "Usar operadores aritméticos em lógicos.",
                                    "Esquecer temporários para resultados booleanos.",
                                    "Confundir LT com GT."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Construir e verificar expressões aritméticas e booleanas compostas",
                                  "subSteps": [
                                    "Combine aritméticas e lógicas: ex. if (a + b * c) > d → múltiplas quadruplas.",
                                    "Gere código completo para 3 expressões complexas mistas.",
                                    "Otimize manualmente: elimine temporários desnecessários.",
                                    "Simule execução passo a passo com valores de exemplo.",
                                    "Documente o processo em um fluxograma de quadruplas."
                                  ],
                                  "verification": "Produza código TAC completo para 3 expressões compostas e valide simulação.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Papel para fluxogramas",
                                    "Valores de teste numéricos",
                                    "Compilador simples ou simulador online"
                                  ],
                                  "tips": [
                                    "Processe da direita para esquerda respeitando precedência.",
                                    "Numere quadruplas sequencialmente para rastreamento."
                                  ],
                                  "learningObjective": "Integrar todas as instruções em expressões reais compostas.",
                                  "commonMistakes": [
                                    "Erro na ordem de cálculo de dependências.",
                                    "Sobrecarregar temporários.",
                                    "Misturar tipos de resultados."
                                  ]
                                }
                              ],
                              "practicalExample": "Converta a expressão 'if ((x + y * 2) > z && a != b) { ... }' em quadruplas: t1 = y * 2; t2 = x + t1; t3 = t2 > z; t4 = a != b; t5 = t3 && t4; if t5 goto L1; ...",
                              "finalVerifications": [
                                "Liste corretamente ADD, SUB, MUL, DIV, EQ, NE, LT, GT com definições.",
                                "Gere quadruplas para 5 expressões aritméticas compostas sem erros.",
                                "Construa TAC para 3 expressões booleanas mistas.",
                                "Simule execução de um exemplo completo com valores numéricos.",
                                "Identifique e corrija 3 erros comuns em quadruplas fornecidas.",
                                "Explique precedência em uma expressão complexa."
                              ],
                              "assessmentCriteria": [
                                "Precisão na sintaxe de quadruplas (100% correta).",
                                "Correta aplicação de precedência em compostas.",
                                "Uso adequado de temporários sem conflitos.",
                                "Validação lógica de resultados booleanos.",
                                "Clareza e completude nos exemplos gerados.",
                                "Capacidade de otimização básica."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Operações aritméticas e precedência de operadores.",
                                "Lógica: Expressões booleanas e tabelas-verdade.",
                                "Programação: Estruturas condicionais em linguagens de alto nível.",
                                "Engenharia de Software: Otimização de código intermediário."
                              ],
                              "realWorldApplication": "Em compiladores como GCC ou LLVM, essas instruções formam a base do código intermediário (TAC), permitindo otimizações como alocação de registradores e geração de assembly eficiente para processadores reais."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.6.1.2.2",
                            "name": "Gerar código para estruturas de controle",
                            "description": "Traduzir if-then-else, while e for em código de três endereços usando instruções condicionais (if x goto L), saltos incondicionais (goto L) e rótulos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender instruções de controle em código de três endereços (TAC)",
                                  "subSteps": [
                                    "Estude a sintaxe básica: if x goto L (condicional), goto L (incondicional) e L: (rótulo).",
                                    "Identifique como essas instruções simulam fluxo de controle sem blocos aninhados.",
                                    "Revise exemplos simples de atribuições em TAC: t1 = op x y.",
                                    "Pratique anotando rótulos em fluxogramas de controle.",
                                    "Compare TAC com assembly para visualizar similaridades."
                                  ],
                                  "verification": "Liste e explique corretamente as 3 instruções principais com exemplos.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Folha de referência de TAC",
                                    "Editor de texto para anotações",
                                    "Fluxogramas impressos"
                                  ],
                                  "tips": "Sempre numere rótulos sequencialmente (L1, L2) para evitar confusão.",
                                  "learningObjective": "Compreender as instruções fundamentais de controle em TAC.",
                                  "commonMistakes": "Confundir 'if x goto L' com atribuições; esquecer que condições são booleanas simples."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Gerar código TAC para estruturas if-then-else",
                                  "subSteps": [
                                    "Analise o if simples: if (cond) stmt -> ifFalse: goto L1; stmt; L1: (fim).",
                                    "Expanda para if-then-else: ifTrue: goto L1; else_stmts; L1: ifFalse: goto fim; then_stmts; fim:",
                                    "Traduza expressões condicionais em temporários: t1 = a > b; if t1 goto L_then.",
                                    "Atribua rótulos únicos e verifique saltos para saída correta.",
                                    "Teste com código fonte simples e simule execução passo a passo."
                                  ],
                                  "verification": "Gere TAC correto para um if-then-else aninhado e simule o fluxo.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Exemplos de código fonte em C/Python",
                                    "Simulador de TAC online ou papel"
                                  ],
                                  "tips": "Use rótulos como L1 (início then), L2 (início else), L3 (fim) para clareza.",
                                  "learningObjective": "Traduzir if-then-else em TAC com saltos condicionais e incondicionais.",
                                  "commonMistakes": "Esquecer salto para fim após 'then'; duplicar rótulos."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Gerar código TAC para loops while",
                                  "subSteps": [
                                    "Estrutura while (cond) body: L_start: if cond goto L_body; goto L_end; L_body: body; goto L_start; L_end:",
                                    "Converta condição em temporário: t1 = x > 0; if t1 goto L_body.",
                                    "Inclua corpo do loop com atribuições TAC.",
                                    "Verifique saída do loop via falha da condição.",
                                    "Simule iterações com valores de teste."
                                  ],
                                  "verification": "Produza TAC para while com corpo complexo e trace 3 iterações.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Código fonte de loops while",
                                    "Papel para traçar execução"
                                  ],
                                  "tips": "O goto de volta ao topo garante loop infinito até condição falhar.",
                                  "learningObjective": "Implementar controle de loop while usando rótulos e saltos.",
                                  "commonMistakes": "Colocar goto fim dentro do corpo; inverter if cond goto body."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Gerar código TAC para loops for e integração",
                                  "subSteps": [
                                    "Desmonte for: init; while (cond) {body; incr;} em TAC sequencial.",
                                    "Gere: init; L_start: cond -> if goto L_body; goto L_end; L_body: body; incr; goto L_start; L_end:",
                                    "Traduza init, cond e incr em temporários TAC.",
                                    "Integre com if-then-else em loops compostos.",
                                    "Valide com múltiplos exemplos e corrija erros."
                                  ],
                                  "verification": "Gere TAC completo para for aninhado com if e execute simulação.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Compilador simples ou exemplos GCC IR",
                                    "Editor para codificação"
                                  ],
                                  "tips": "Trate for como while com init/incr explícitos para padronizar.",
                                  "learningObjective": "Traduzir for loops e combinar estruturas de controle em TAC.",
                                  "commonMistakes": "Executar incr antes de cond; faltar goto de volta no incr."
                                }
                              ],
                              "practicalExample": "Exemplo: int a=1, b=2; if (a > b) { a=3; } else { b=4; } for(int i=0; i<5; i++) { a++; }\nTAC gerado:\nt1 = a > b\nif t1 goto L1\ngoto L2\nt1 = 3\na = t1\ngoto L3\nL2: t1 = 4\nb = t1\nL1: L3: i = 0\nL4: t2 = i < 5\nif t2 goto L5\ngoto L6\nL5: a = a + 1\nt3 = i + 1\ni = t3\ngoto L4\nL6:",
                              "finalVerifications": [
                                "Gera TAC correto para if-then-else simples sem erros de salto.",
                                "Implementa while com loop funcional e saída correta.",
                                "Traduz for equivalente a while com init/cond/incr.",
                                "Integra múltiplas estruturas sem conflitos de rótulos.",
                                "Simula execução com valores de entrada variados.",
                                "Identifica e corrige erros comuns em fluxos compostos."
                              ],
                              "assessmentCriteria": [
                                "Uso preciso de if x goto L e goto L com condições booleanas.",
                                "Rótulos únicos e sequenciais sem sobreposições.",
                                "Todas atribuições em formato de três endereços (t = op x y).",
                                "Fluxo de controle simula semântica exata da estrutura original.",
                                "Ausência de saltos desnecessários ou loops infinitos.",
                                "Simulação manual confirma corretude para casos edge."
                              ],
                              "crossCurricularConnections": [
                                "Lógica proposicional e fluxogramas (Matemática).",
                                "Análise de algoritmos e complexidade (Ciência da Computação).",
                                "Teoria de autómatos e linguagens formais (Teoria da Computação).",
                                "Engenharia de software: abstrações de baixo nível."
                              ],
                              "realWorldApplication": "Em compiladores como GCC ou LLVM, essa geração de TAC intermediário otimiza código para máquinas, permitindo análises de fluxo de controle, dead code elimination e geração de assembly eficiente em ferramentas de desenvolvimento real."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.6.1.2.3",
                            "name": "Implementar cópias e acessos a índices",
                            "description": "Criar instruções de atribuição (x = y), indexação (x = y[i]) e endereçamento indireto (x = *y), demonstrando tradução de arrays e ponteiros.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender e Implementar Atribuições Simples (x = y)",
                                  "subSteps": [
                                    "Estude a sintaxe básica do Código de Três Endereços (TAC) para atribuições: resultado = operando1 operador operando2, focando em x = y onde não há operador.",
                                    "Analise exemplos de código fonte simples como 'a = b;' e identifique os registradores temporários necessários.",
                                    "Escreva manualmente o TAC equivalente, garantindo que cada instrução tenha no máximo três endereços.",
                                    "Teste a tradução executando o TAC em um interpretador simples.",
                                    "Documente o mapeamento de variáveis para registradores temporários."
                                  ],
                                  "verification": "O TAC gerado executa corretamente a atribuição sem erros de sintaxe ou semântica.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Editor de texto (VS Code)",
                                    "Exemplos de código C simples",
                                    "Interpretador de TAC online ou local"
                                  ],
                                  "tips": "Sempre use registradores temporários (t1, t2) para evitar conflitos de nomes de variáveis.",
                                  "learningObjective": "Dominar a geração de instruções de cópia simples em TAC.",
                                  "commonMistakes": "Confundir variáveis locais com temporárias; esquecer de declarar temporários."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar Indexação de Arrays (x = y[i])",
                                  "subSteps": [
                                    "Revise o cálculo de endereço de array: endereço = base + i * tamanho_elemento.",
                                    "Gere TAC para o cálculo do offset: t1 = i * tamanho; t2 = base + t1.",
                                    "Em seguida, gere x = y[t2] como uma carga indireta ou cópia indexada.",
                                    "Traduza um exemplo como 'a = b[3];' considerando alinhamento de memória.",
                                    "Valide com um programa teste que acesse o array corretamente."
                                  ],
                                  "verification": "O endereço calculado corresponde ao índice correto no array simulado.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Papel e caneta para diagramas de memória",
                                    "Simulador de memória de array",
                                    "Código fonte com arrays"
                                  ],
                                  "tips": "Lembre-se do tamanho do tipo (ex: int=4 bytes) para offsets precisos.",
                                  "learningObjective": "Gerar TAC para acessos indexados, simulando aritmética de ponteiros.",
                                  "commonMistakes": "Ignorar multiplicação pelo tamanho do elemento; usar soma direta sem offset."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar Endereçamento Indireto (x = *y)",
                                  "subSteps": [
                                    "Entenda que *y carrega o valor no endereço apontado por y: x = conteúdo[y].",
                                    "Gere TAC: t1 = y; x = *t1 (usando instrução de load indireto).",
                                    "Diferencie de indexação: aqui y é ponteiro direto, sem cálculo de offset.",
                                    "Traduza 'x = *ptr;' onde ptr é um ponteiro para int.",
                                    "Teste com um ponteiro dinâmico alocado."
                                  ],
                                  "verification": "O valor carregado via indireto é o conteúdo correto da memória.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Documentação de instruções TAC (load/store indireto)",
                                    "Exemplos de ponteiros em C",
                                    "Depurador de TAC"
                                  ],
                                  "tips": "Use sempre um temporário para o endereço antes do dereference para clareza.",
                                  "learningObjective": "Implementar cargas e stores via ponteiros em TAC.",
                                  "commonMistakes": "Confundir *y com y[i]; tratar ponteiro como valor direto."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Integrar e Demonstrar Tradução de Arrays e Ponteiros",
                                  "subSteps": [
                                    "Combine atribuições, indexação e indireto em uma expressão complexa como 'x = *a[i];'.",
                                    "Gere TAC sequencial: calcule offset, endereço, então dereference.",
                                    "Otimize o TAC removendo temporários desnecessários.",
                                    "Traduza um snippet completo de código fonte com arrays e ponteiros.",
                                    "Compare sua tradução com saída de um compilador real como GCC -S."
                                  ],
                                  "verification": "O TAC integrado compila e executa o snippet original corretamente.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Compilador GCC com flag -S",
                                    "Snippets de código C com ponteiros e arrays",
                                    "Ferramenta de comparação de diff"
                                  ],
                                  "tips": "Mantenha o TAC linear e evite saltos prematuros nesta fase.",
                                  "learningObjective": "Traduzir estruturas de dados reais (arrays/ponteiros) para TAC eficiente.",
                                  "commonMistakes": "Perder a ordem de avaliação; gerar temporários excessivos."
                                }
                              ],
                              "practicalExample": "Traduza o código C: int a[5] = {1,2,3,4,5}; int *p = &a[2]; int x = *p; Para TAC: t1 = 2 * 4; t2 = base_a + t1; p = t2; x = *p;",
                              "finalVerifications": [
                                "Gere TAC correto para x = y sem erros.",
                                "Calcule offset exato para array indexado y[3].",
                                "Implemente *y carregando valor correto da memória.",
                                "Traduza snippet completo com arrays e ponteiros.",
                                "Otimize TAC removendo 20% de temporários desnecessários."
                              ],
                              "assessmentCriteria": [
                                "TAC usa no máximo 3 endereços por instrução.",
                                "Offsets de array incluem multiplicação por tamanho.",
                                "Indiretos usam load/store corretos.",
                                "Tradução preserva semântica original.",
                                "Eficiência: mínimo de temporários e instruções."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Aritmética de ponteiros e cálculo de offsets lineares.",
                                "Lógica e Algoritmos: Representação de estruturas de dados em assembly intermediário.",
                                "Engenharia de Software: Otimização de código gerado por compiladores.",
                                "Física Computacional: Simulação de memória em modelos discretos."
                              ],
                              "realWorldApplication": "Em compiladores como GCC ou LLVM, essa habilidade gera código assembly eficiente para acessos a vetores em aplicações científicas, jogos e bancos de dados, otimizando performance em hardware real."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.6.1.2.4",
                            "name": "Gerenciar parâmetros e chamadas de funções",
                            "description": "Gerar instruções PARAM, CALL e RETURN para passagem de parâmetros por valor ou referência em chamadas de procedimentos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender Passagem de Parâmetros por Valor e Referência",
                                  "subSteps": [
                                    "Diferencie passagem por valor (cópia do valor) de passagem por referência (endereço da variável).",
                                    "Analise a assinatura da função para identificar tipos de parâmetros (in, out, inout).",
                                    "Revise a semântica da linguagem-alvo para regras de passagem.",
                                    "Mapeie variáveis locais para registradores ou memória temporária.",
                                    "Estude exemplos de código intermediário com PARAM para ambos os modos."
                                  ],
                                  "verification": "Crie um diagrama comparando cópia de valor vs. endereço e explique diferenças em um teste escrito.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Livro de Compiladores (ex: Dragon Book), exemplos de código de três endereços, quadro branco.",
                                  "tips": "Use setas para visualizar fluxo de dados em diagramas.",
                                  "learningObjective": "Distinguir e preparar parâmetros corretamente para geração de código PARAM.",
                                  "commonMistakes": "Confundir passagem por valor com referência, levando a cópias desnecessárias ou modificações incorretas."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Gerar Instruções PARAM para Parâmetros",
                                  "subSteps": [
                                    "Para cada parâmetro por valor: Emita PARAM <var> onde <var> é o valor ou registrador.",
                                    "Para parâmetro por referência: Emita PARAM <endereço de var> usando instruções de load address.",
                                    "Reserve espaço na pilha ou registradores para parâmetros na ordem correta (direita para esquerda).",
                                    "Inclua tipo de parâmetro se suportado pelo código intermediário.",
                                    "Teste com múltiplos parâmetros mistos (valor e ref)."
                                  ],
                                  "verification": "Gere código PARAM para uma função com 3 parâmetros (2 valor, 1 ref) e simule execução manual.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Editor de texto para código intermediário, simulador de pilha, exemplos de AST.",
                                  "tips": "Sempre emita PARAMs antes do CALL e na ordem reversa para evitar sobrescrita.",
                                  "learningObjective": "Emitir instruções PARAM precisas baseadas no modo de passagem.",
                                  "commonMistakes": "Ordem errada de parâmetros, causando desalinhamento na pilha."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Emitir Instruções CALL e Gerenciar Contexto",
                                  "subSteps": [
                                    "Após todos PARAMs, emita CALL <nome_da_função> ou CALL <endereço>.",
                                    "Salve registradores de chamador e configure frame de pilha para callee.",
                                    "Alinhe parâmetros com convenções de chamada (stdcall, cdecl).",
                                    "Prepare espaço para valor de retorno se função não-void.",
                                    "Valide alinhamento de pilha pós-CALL."
                                  ],
                                  "verification": "Compile um programa simples com chamadas aninhadas e verifique código gerado sem erros de pilha.",
                                  "estimatedTime": "50 minutos",
                                  "materials": "Ferramenta de geração de código intermediário (ex: LLVM IR viewer), debugger de assembly.",
                                  "tips": "Use labels para funções e calcule offsets de parâmetros dinamicamente.",
                                  "learningObjective": "Coordenar CALL com PARAMs para transições de contexto corretas.",
                                  "commonMistakes": "Esquecer de salvar registradores, causando corrupção de estado."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Implementar RETURN e Verificações Finais",
                                  "subSteps": [
                                    "Emita RETURN <valor> ou RETURN para funções void.",
                                    "Carregue valor de retorno do frame da função para registrador apropriado.",
                                    "Restaure registradores e pop da pilha após retorno.",
                                    "Otimize PARAMs desnecessários (ex: constantes por valor).",
                                    "Teste cenários de recursão e múltiplos retornos."
                                  ],
                                  "verification": "Execute ciclo completo CALL-RETURN em simulador e confirme valores corretos.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Simulador de máquina virtual, testes unitários para código intermediário.",
                                  "tips": "Para ref, dereferencie apenas no corpo da função, não no caller.",
                                  "learningObjective": "Finalizar chamadas com RETURN eficiente e restaurar estado.",
                                  "commonMistakes": "Não limpar pilha após RETURN, levando a vazamentos de memória."
                                }
                              ],
                              "practicalExample": "Função soma(int a por valor, int* b por ref): Em código intermediário: PARAM a; PARAM b_addr (load addr b); CALL soma; RETURN result. Simulação: a=5 copiado, b_addr=0x100, soma modifica *b.",
                              "finalVerifications": [
                                "Código PARAM/CALL/RETURN compila sem erros de pilha.",
                                "Valores por valor não alteram originais; por ref sim.",
                                "Chamadas recursivas mantêm frames corretos.",
                                "Otimizações reduzem instruções desnecessárias.",
                                "Testes com 10+ funções confirmam consistência.",
                                "Simulação manual reproduz execução sem falhas."
                              ],
                              "assessmentCriteria": [
                                "Precisão na distinção valor/ref (90% acerto em testes).",
                                "Código gerado executável e eficiente (sem overflows).",
                                "Cobertura de edge cases (void, recursão).",
                                "Documentação clara de offsets e registradores.",
                                "Tempo de geração < 5min por função complexa.",
                                "Integração perfeita com fluxo de controle existente."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Álgebra linear para modelagem de pilha como vetores.",
                                "Programação: Conceitos de ponteiros em C/Python.",
                                "Engenharia de Software: Convenções ABI em sistemas operacionais.",
                                "Lógica: Árvores de sintaxe abstrata (AST) para análise."
                              ],
                              "realWorldApplication": "Em compiladores como GCC/LLVM, otimiza passagem de parâmetros para reduzir overhead em apps de alto desempenho como jogos e IA, evitando cópias desnecessárias e melhorando cache locality."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.6.1.3",
                        "name": "Geração e Otimizações no Código de Três Endereços",
                        "description": "Processo de geração a partir de análises semânticas e árvores sintáticas, com técnicas de otimização local como eliminação de cópias comuns e redução de força bruta.",
                        "specificSkills": [
                          {
                            "id": "10.1.6.1.3.1",
                            "name": "Gerar código a partir de árvores sintáticas",
                            "description": "Aplicar tradução sintaxe-dirigida para converter árvores de expressões em código de três endereços, usando pós-ordem para avaliação.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender Fundamentos de Árvores Sintáticas e Código de Três Endereços",
                                  "subSteps": [
                                    "Estude a estrutura de uma árvore sintática para expressões aritméticas, identificando nós folha (variáveis/constantes) e nós internos (operadores).",
                                    "Aprenda o formato do código de três endereços (TAC): instruções como 't1 = id1 op id2' ou 't1 = op id'.",
                                    "Revise a avaliação em pós-ordem: processar filhos esquerdos e direitos antes do nó raiz.",
                                    "Analise exemplos simples de árvores e seu TAC equivalente.",
                                    "Identifique como temporários (t1, t2...) evitam empilhamento excessivo."
                                  ],
                                  "verification": "Crie manualmente o TAC para uma árvore simples como (a + b) * c e compare com referências.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Livro de Compiladores (ex: Dragon Book)",
                                    "Papel e lápis para diagramas",
                                    "Editor de texto para anotações"
                                  ],
                                  "tips": "Desenhe árvores à mão para visualizar melhor a recursão pós-ordem.",
                                  "learningObjective": "Dominar os conceitos básicos de árvores sintáticas e TAC para preparar a tradução.",
                                  "commonMistakes": "Confundir pré-ordem com pós-ordem; ignorar precedência de operadores."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Estudar Tradução Sintaxe-Dirigida (SDT)",
                                  "subSteps": [
                                    "Defina SDT: regras de produção com ações semânticas executadas durante a análise sintática.",
                                    "Aprenda atributos sintéticos (calculados bottom-up) para geração de código.",
                                    "Estude como associar a cada nó da árvore um atributo 'code' que armazena o TAC gerado.",
                                    "Analise regras LALR(1) ou recursivas para expressões: E -> E op T { código = E.code + T.code + 't = E.res op T.res' }.",
                                    "Pratique com gramáticas simples para expressões binárias."
                                  ],
                                  "verification": "Escreva regras SDT para uma gramática de expressões e simule a geração de TAC.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Documentação de ferramentas como Yacc/Bison",
                                    "Exemplos de gramáticas em PDF",
                                    "Simulador online de parsing"
                                  ],
                                  "tips": "Use diagramas de dependência de atributos para evitar ciclos.",
                                  "learningObjective": "Compreender como SDT integra análise sintática com geração de código intermediário.",
                                  "commonMistakes": "Executar ações na ordem errada (não bottom-up); esquecer de propagar resultados."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar Algoritmo Recursivo em Pós-Ordem para Geração de TAC",
                                  "subSteps": [
                                    "Defina uma estrutura de dados para nós da árvore (classe Node com left, right, op, value).",
                                    "Crie função recursiva generateTAC(Node): gere código dos filhos primeiro, aloque temporário e adicione instrução.",
                                    "Implemente alocador de temporários (contador global para t1, t2...).",
                                    "Teste com expressões binárias: a + b * c → pós-ordem gera t1=b*c; t2=a+t1.",
                                    "Adicione suporte para operadores unários e parênteses."
                                  ],
                                  "verification": "Codifique em Python/Java e execute para input 'a + b * c', verificando saída TAC correta.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Editor de código (VS Code)",
                                    "Linguagem: Python ou Java",
                                    "Exemplos de árvores em JSON"
                                  ],
                                  "tips": "Use print statements para debugar a ordem de visitação.",
                                  "learningObjective": "Desenvolver código funcional para converter árvores em TAC via pós-ordem.",
                                  "commonMistakes": "Erro na recursão (stack overflow em árvores profundas); não resetar temporários."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Testar, Otimizar e Verificar a Implementação",
                                  "subSteps": [
                                    "Crie suíte de testes com 5-10 expressões variadas (com precedência, unários).",
                                    "Verifique equivalência semântica: execute TAC gerado em interpretador simples.",
                                    "Aplique otimizações básicas: eliminar temporários desnecessários (a + 5 → t1=a+5 apenas se preciso).",
                                    "Compare com ferramentas reais como LLVM IR para expressões.",
                                    "Documente limitações (ex: sem declaração de variáveis)."
                                  ],
                                  "verification": "Todos testes passam e TAC é semanticamente correto sem temporários extras.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Unit tests framework (pytest/JUnit)",
                                    "Interpretador TAC simples",
                                    "LLVM playground online"
                                  ],
                                  "tips": "Comece com casos edge: expressões vazias ou só constantes.",
                                  "learningObjective": "Garantir robustez e corretude da geração de código.",
                                  "commonMistakes": "Ignorar associatividade (esquerda/direita); gerar TAC com variáveis indefinidas."
                                }
                              ],
                              "practicalExample": "Árvore para 'a + b * c': Nó raiz '+', esquerdo 'a', direito '*'(esq 'b', dir 'c'). Pós-ordem: visite '*': t1 = b * c; visite 'a'; raiz: t2 = a + t1. TAC: t1 = b * c\nt2 = a + t1",
                              "finalVerifications": [
                                "Gera TAC correto para expressões com precedência e associatividade.",
                                "Usa pós-ordem corretamente, sem visitas prematuras.",
                                "Aloca temporários sequencialmente sem reutilização errada.",
                                "Maneja operadores unários e constantes adequadamente.",
                                "TAC resultante é executável em interpretador de três endereços.",
                                "Não há erros de compilação no código gerador."
                              ],
                              "assessmentCriteria": [
                                "Precisão na geração de TAC (100% match com esperado).",
                                "Eficiência no uso de temporários (mínimo necessário).",
                                "Corretude da recursão pós-ordem.",
                                "Robustez contra entradas variadas.",
                                "Clareza e documentação do código.",
                                "Tempo de execução razoável para árvores médias."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Estruturas de árvores e travessias (grafos).",
                                "Algoritmos: Recursão e programação funcional.",
                                "Engenharia de Software: Parsers e geração de código (Yacc/ANTLR).",
                                "Lógica: Semântica operacional de linguagens."
                              ],
                              "realWorldApplication": "Em compiladores como GCC ou Clang, essa técnica gera código intermediário eficiente para otimizações; usada em JIT compilers (V8, JVM) para expressões dinâmicas em linguagens como JavaScript ou Java."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.6.1.3.2",
                            "name": "Aplicar otimizações locais básicas",
                            "description": "Identificar e eliminar cópias comuns (x = t1; y = x → y = t1), algebricidades (x = -x → x = 0 - x) e instruções mortas no código de três endereços.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender Código de Três Endereços e Conceitos de Otimizações Locais",
                                  "subSteps": [
                                    "Estude a estrutura básica do código de três endereços: cada instrução na forma x = y op z ou x = op y.",
                                    "Identifique os tipos de otimizações locais: eliminação de cópias comuns, simplificação algébrica e remoção de código morto.",
                                    "Revise exemplos simples de código de três endereços gerado por compiladores.",
                                    "Analise o impacto das otimizações: redução de instruções e melhoria de performance.",
                                    "Pratique anotando um código exemplo com potenciais otimizações."
                                  ],
                                  "verification": "Explique verbalmente ou por escrito os três tipos de otimizações e forneça um exemplo de cada.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Documentação sobre código de três endereços (PDF ou wiki)",
                                    "Editor de texto para anotar códigos",
                                    "Exemplos de códigos de compiladores como LLVM IR"
                                  ],
                                  "tips": "Comece com códigos pequenos (5-10 linhas) para visualizar melhor as otimizações.",
                                  "learningObjective": "Entender a base teórica e identificar oportunidades de otimização em código de três endereços.",
                                  "commonMistakes": [
                                    "Confundir cópias comuns com subexpressões comuns",
                                    "Ignorar dependências de fluxo de dados",
                                    "Não considerar o escopo local das otimizações"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Eliminar Cópias Comuns (Copy Propagation)",
                                  "subSteps": [
                                    "Identifique padrões como x = t1; y = x; onde y recebe cópia direta de x.",
                                    "Substitua y = x por y = t1, preservando o valor original.",
                                    "Remova a instrução x = t1 se x não for mais usado após a propagação.",
                                    "Rastreie usos de variáveis para evitar propagação incorreta em loops ou condicionais.",
                                    "Aplique em múltiplas ocorrências sequencialmente no código."
                                  ],
                                  "verification": "Transforme um código com 3-5 cópias comuns e confirme que o número de instruções diminuiu sem alterar semântica.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Códigos de exemplo com cópias comuns",
                                    "Ferramenta de análise estática simples ou papel e caneta"
                                  ],
                                  "tips": "Use reaching definitions para rastrear origens de valores com precisão.",
                                  "learningObjective": "Aplicar copy propagation corretamente, reduzindo redundâncias.",
                                  "commonMistakes": [
                                    "Propagar cópias em contextos onde variáveis são redefinidas",
                                    "Esquecer de remover a cópia original desnecessária",
                                    "Aplicar em expressões complexas sem simplificar primeiro"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Simplificar Expressões Algébricas",
                                  "subSteps": [
                                    "Reconheça padrões algébricos como x = -x (substituir por x = 0 - x ou x = 0)",
                                    "Identifique identidades como x = x + 0 → remover ou x = x * 1 → remover.",
                                    "Aplique regras básicas: x = y - y → x = 0; x = x * 0 → x = 0.",
                                    "Substitua a instrução original pela forma simplificada.",
                                    "Verifique se a simplificação preserva o valor semântico."
                                  ],
                                  "verification": "Simplifique 5 expressões algébricas isoladas e prove equivalência matemática.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Lista de identidades algébricas comuns em compiladores",
                                    "Calculadora simbólica opcional (como SymPy)"
                                  ],
                                  "tips": "Memorize as 10 regras algébricas mais comuns para agilizar.",
                                  "learningObjective": "Reconhecer e aplicar simplificações algébricas em instruções de três endereços.",
                                  "commonMistakes": [
                                    "Aplicar regras em expressões com side-effects",
                                    "Confundir simplificação com eliminação de código morto",
                                    "Ignorar precedência de operadores"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Identificar e Remover Instruções Mortas",
                                  "subSteps": [
                                    "Realize análise de fluxo de dados para encontrar variáveis live (usadas após definição).",
                                    "Marque instruções que definem variáveis não live como mortas.",
                                    "Remova instruções mortas, exceto se tiverem side-effects (como I/O).",
                                    "Reaplique otimizações anteriores após remoções para propagar efeitos.",
                                    "Valide o código otimizado executando em interpretador de três endereços."
                                  ],
                                  "verification": "Otimize um código completo removendo todas instruções mortas e confirme ausência de mudanças no output.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Interpretador simples de código de três endereços",
                                    "Gráficos de fluxo de controle para análise live/dead"
                                  ],
                                  "tips": "Comece pela análise backward para live variables.",
                                  "learningObjective": "Eliminar código morto de forma segura usando análise de liveness.",
                                  "commonMistakes": [
                                    "Remover instruções com side-effects",
                                    "Não reanalisar após remoções iniciais",
                                    "Confundir dead code com unreachable code"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Integrar Todas as Otimizações e Verificar Resultados",
                                  "subSteps": [
                                    "Aplique as otimizações em sequência: cópias → algébricas → mortas, iterando 2-3 vezes.",
                                    "Compare código original e otimizado linha por linha.",
                                    "Teste com casos de entrada variados para validar semântica.",
                                    "Meça redução percentual de instruções.",
                                    "Documente as mudanças realizadas."
                                  ],
                                  "verification": "Produza um relatório de otimização para um código de 20 linhas, mostrando antes/depois.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Código de teste complexo",
                                    "Ferramenta de diff para códigos"
                                  ],
                                  "tips": "Automatize com script simples se possível para prática repetida.",
                                  "learningObjective": "Combinar otimizações locais em um pipeline completo.",
                                  "commonMistakes": [
                                    "Parar após uma iteração (otimizações cascata)",
                                    "Alterar semântica por ordem errada",
                                    "Não testar com edge cases"
                                  ]
                                }
                              ],
                              "practicalExample": "Código original:\nt1 = a + b\nt2 = -t1\nt3 = t2 + 0\nt4 = t1\nt5 = t4 * c\nx = t5\n// t2, t3, t4 não usados depois\nCódigo otimizado:\nt1 = a + b\nt2 = 0 - t1  // ou simplificar mais se possível\nx = t1 * c  // propagação de cópias e remoção de mortas",
                              "finalVerifications": [
                                "Otimize corretamente um código com pelo menos 3 cópias comuns.",
                                "Simplifique 5 expressões algébricas sem erros.",
                                "Remova todas instruções mortas em um código de 15 linhas.",
                                "O código otimizado produz o mesmo output que o original para 5 inputs.",
                                "Reduza o número de instruções em pelo menos 30%.",
                                "Explique cada mudança realizada."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de padrões (100% das oportunidades capturadas).",
                                "Preservação da semântica (testes passam sem falhas).",
                                "Eficiência: redução significativa de instruções.",
                                "Documentação clara das otimizações aplicadas.",
                                "Tratamento correto de dependências e side-effects.",
                                "Tempo de execução otimizado em interpretador."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Álgebra simbólica e simplificação de expressões.",
                                "Programação: Análise estática de código e refatoração.",
                                "Engenharia de Software: Otimização de performance e profiling.",
                                "Algoritmos: Análise de fluxo de dados e grafos de controle."
                              ],
                              "realWorldApplication": "Em compiladores como GCC e LLVM, essas otimizações locais básicas reduzem o tamanho do código gerado, aceleram a execução em 10-30% em benchmarks reais, e são a base para otimizações globais em aplicações como navegadores web e jogos."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.6.1.3.3",
                            "name": "Explicar vantagens para otimizações globais",
                            "description": "Discutir como a forma de três endereços facilita análises de fluxo de dados, eliminação de variáveis comuns e registro alocação em fases posteriores de compilação.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a estrutura básica do código de três endereços e otimizações globais",
                                  "subSteps": [
                                    "Defina código de três endereços como instruções na forma x = y op z ou x = op y.",
                                    "Explique otimizações globais como análises que consideram o programa inteiro, não só blocos locais.",
                                    "Identifique por que a forma linear e simples facilita análises em grafos de fluxo de controle.",
                                    "Compare com código de máquina ou quádruplos para destacar simplicidade.",
                                    "Liste vantagens iniciais: facilidade de parsing e representação em tabelas de símbolos."
                                  ],
                                  "verification": "Escreva uma definição precisa e liste 3 vantagens estruturais em um parágrafo.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Livro de compiladores (ex: Dragon Book), slides sobre código intermediário.",
                                  "tips": "Use diagramas de grafo para visualizar o fluxo de controle.",
                                  "learningObjective": "Entender como a forma canônica simplifica representações para otimizações.",
                                  "commonMistakes": "Confundir com código assembly; ignorar o impacto na portabilidade."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar facilitação de análise de fluxo de dados",
                                  "subSteps": [
                                    "Descreva análise de fluxo de dados: reaching definitions, live variables, available expressions.",
                                    "Mostre como cada instrução afeta GEN/KILL sets devido à forma x = y op z.",
                                    "Construa um exemplo simples de grafo de controle com 4 blocos básicos.",
                                    "Calcule conjuntos de reaching definitions manualmente.",
                                    "Discuta como isso propaga informações globais para detecção de redundâncias."
                                  ],
                                  "verification": "Aplique análise de reaching definitions a um código de exemplo e verifique resultados.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Ferramenta online de compiladores ou simulador de fluxo de dados, papel e lápis.",
                                  "tips": "Comece com blocos básicos lineares antes de loops.",
                                  "learningObjective": "Dominar como a estrutura simplifica iterações em data-flow equations.",
                                  "commonMistakes": "Esquecer propagação bidirecional (forward/backward analyses)."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explicar eliminação de expressões comuns (common subexpression elimination)",
                                  "subSteps": [
                                    "Defina CSE: remover recomputações de y op z se disponível.",
                                    "Use available expressions analysis para identificar oportunidades globais.",
                                    "Transforme código: introduza temporários compartilhados para expressões idênticas.",
                                    "Aplique em loop com múltiplos caminhos.",
                                    "Meça redução de instruções e impacto em performance."
                                  ],
                                  "verification": "Otimize um código de exemplo eliminando 2 CSEs e conte instruções antes/depois.",
                                  "estimatedTime": "40 minutos",
                                  "materials": "Exemplos de código em LLVM IR ou pseudocódigo.",
                                  "tips": "Procure padrões como t1 = a + b em múltiplos lugares.",
                                  "learningObjective": "Aplicar CSE globalmente graças à forma padronizada.",
                                  "commonMistakes": "Eliminar expressões que mudam devido a side-effects."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Discutir alocação de registradores e outras otimizações",
                                  "subSteps": [
                                    "Explique graph coloring para register allocation em código linear.",
                                    "Mostre interference graph: variáveis vivas simultaneamente não compartilham registradores.",
                                    "Construa grafo de interferência de um exemplo otimizado.",
                                    "Discuta spill code mínimo devido a lives precisas de data-flow.",
                                    "Ligue a otimizações como dead code elimination."
                                  ],
                                  "verification": "Construa interference graph e aloque registradores para 3 variáveis.",
                                  "estimatedTime": "35 minutos",
                                  "materials": "Simulador de register allocation online, Dragon Book capítulo 10.",
                                  "tips": "Use cores fixos (ex: 4 registradores) para simplicidade.",
                                  "learningObjective": "Compreender como data-flow preciso habilita alocação ótima.",
                                  "commonMistakes": "Ignorar liveness em branches."
                                }
                              ],
                              "practicalExample": "Código original: t1 = a + b; ... t2 = a + b; Otimizado via CSE: t1 = a + b; t2 = t1; Em loop: reduz recomputações de 50% em benchmarks como SPEC.",
                              "finalVerifications": [
                                "Explicar data-flow analysis em código de três endereços sem erros.",
                                "Identificar e eliminar CSE em exemplo com branches.",
                                "Construir interference graph correto para alocação.",
                                "Discutir limitações: side-effects em funções.",
                                "Comparar com IRs mais complexos como SSA.",
                                "Medir impacto quantitativo em performance."
                              ],
                              "assessmentCriteria": [
                                "Precisão na descrição de análises facilitadas (data-flow, liveness).",
                                "Uso correto de exemplos com antes/depois.",
                                "Compreensão de dependências globais vs locais.",
                                "Capacidade de aplicar em código não-trivial.",
                                "Integração de múltiplas otimizações.",
                                "Clareza na explicação oral/escrita."
                              ],
                              "crossCurricularConnections": [
                                "Análise de Algoritmos: Grafos e iterações fixpoint.",
                                "Programação Paralela: Dependências de dados semelhantes.",
                                "Engenharia de Software: Otimização de performance em pipelines CI/CD.",
                                "Matemática Discreta: Conjuntos e álgebra de fluxo."
                              ],
                              "realWorldApplication": "Em compiladores como GCC/LLVM, código de três endereços permite otimizações globais que reduzem código executável em 20-30%, melhorando velocidade em apps como browsers (Chrome V8) e jogos."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.6.2",
                    "name": "Notação Pós-Fixa",
                    "description": "Forma intermediária baseada em notação polonesa reversa, usada para representar expressões sem parênteses.",
                    "individualConcepts": [
                      {
                        "id": "10.1.6.2.1",
                        "name": "Definição e Características da Notação Pós-Fixa",
                        "description": "Compreensão da notação pós-fixa como forma intermediária baseada na notação polonesa reversa, que elimina a necessidade de parênteses ao representar operandos antes dos operadores.",
                        "specificSkills": [
                          {
                            "id": "10.1.6.2.1.1",
                            "name": "Identificar a estrutura básica da notação pós-fixa",
                            "description": "Reconhecer que em notação pós-fixa, os operandos precedem o operador, permitindo avaliação sequencial sem ambiguidades, como em '3 4 +' para 3+4.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender as noções básicas de notações de expressões",
                                  "subSteps": [
                                    "Estude a notação infixa: operandos com operador no meio, ex: 3 + 4.",
                                    "Aprenda a notação prefixa: operador primeiro, ex: + 3 4.",
                                    "Identifique a notação pós-fixa: operandos primeiro, operador depois, ex: 3 4 +.",
                                    "Note as vantagens da pós-fixa: avaliação sequencial sem parênteses ou precedência.",
                                    "Compare as três noções com uma tabela simples."
                                  ],
                                  "verification": "Crie uma tabela comparando infixa, prefixa e pós-fixa com exemplos e explique verbalmente as diferenças.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Vídeo introdutório sobre notações (YouTube: 'Polish Notation')"
                                  ],
                                  "tips": [
                                    "Use cores diferentes para operandos e operadores nas anotações."
                                  ],
                                  "learningObjective": "Diferenciar as três notações principais de expressões matemáticas.",
                                  "commonMistakes": [
                                    "Confundir pós-fixa com infixa invertendo a ordem operador-operando."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Reconhecer operandos e operadores na notação pós-fixa",
                                  "subSteps": [
                                    "Analise uma expressão pós-fixa simples: identifique números como operandos.",
                                    "Localize símbolos como +, -, *, / como operadores.",
                                    "Verifique que cada operador segue exatamente seus operandos necessários (2 para binários).",
                                    "Pratique com 3 exemplos: 3 4 +, 5 6 -, 2 3 *.",
                                    "Descreva a sequência de leitura da esquerda para a direita."
                                  ],
                                  "verification": "Marque 5 expressões pós-fixa destacando operandos (verde) e operadores (vermelho), explicando a ordem.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Folha com exemplos impressos ou digitais",
                                    "Marcadores coloridos"
                                  ],
                                  "tips": [
                                    "Leia sempre da esquerda para direita, como uma fila de instruções."
                                  ],
                                  "learningObjective": "Identificar corretamente componentes em expressões pós-fixa.",
                                  "commonMistakes": [
                                    "Interpretar operadores como operandos ou vice-versa."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Converter expressões infixas simples para pós-fixa",
                                  "subSteps": [
                                    "Pegue uma infixa sem parênteses: ex: 3 + 4.",
                                    "Escreva operandos primeiro: 3 4.",
                                    "Adicione operador depois: 3 4 +.",
                                    "Teste com mais: 5 - 2 → 5 2 -, 10 * 2 → 10 2 *.",
                                    "Verifique convertendo de volta para infixa."
                                  ],
                                  "verification": "Converta 5 infixas simples para pós-fixa e confirme avaliando o resultado.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Lista de 10 expressões infixas simples",
                                    "Calculadora para verificação"
                                  ],
                                  "tips": [
                                    "Para binárias simples, apenas mova operador para o final."
                                  ],
                                  "learningObjective": "Transformar expressões infixas básicas em pós-fixa.",
                                  "commonMistakes": [
                                    "Esquecer a ordem operandos-operador ou adicionar parênteses desnecessários."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Avaliar expressões pós-fixa usando pilha mental",
                                  "subSteps": [
                                    "Simule uma pilha: leia da esquerda, empilhe operandos.",
                                    "Ao encontrar operador, desempilhe operandos, aplique e empilhe resultado.",
                                    "Exemplo: 3 4 + → empilha 3,4; + → 7.",
                                    "Pratique com 4 expressões: 3 4 + 5 *, etc.",
                                    "Confirme resultado com cálculo infixo equivalente."
                                  ],
                                  "verification": "Avalie 5 expressões pós-fixa e liste passos da pilha para cada.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel para desenhar pilha",
                                    "Simulador online de RPN (opcional)"
                                  ],
                                  "tips": [
                                    "Use lista ou pilha física com post-its para visualizar."
                                  ],
                                  "learningObjective": "Demonstrar avaliação sequencial da pós-fixa sem ambiguidades.",
                                  "commonMistakes": [
                                    "Aplicar operador antes de ter operandos suficientes na pilha."
                                  ]
                                }
                              ],
                              "practicalExample": "Converta a infixa 3 + 4 * 2 para pós-fixa: 3 4 2 * +. Avaliação: empilha 3,4,2; * desempilha 4,2→8, empilha 8; + desempilha 3,8→11.",
                              "finalVerifications": [
                                "Explica que operandos precedem operadores na pós-fixa.",
                                "Identifica corretamente operandos e operadores em uma expressão dada.",
                                "Converte infixa simples (sem parênteses) para pós-fixa.",
                                "Avalia expressão pós-fixa básica usando pilha.",
                                "Distingue pós-fixa de infixa e prefixa em exemplos.",
                                "Reconhece ausência de ambiguidades na pós-fixa."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de estrutura (operandos antes de operadores): 100%.",
                                "Correção em conversões infixa → pós-fixa: ≥90%.",
                                "Avaliação correta de expressões: resultado exato.",
                                "Explicação clara da avaliação sequencial sem parênteses.",
                                "Uso apropriado de pilha na simulação.",
                                "Comparação precisa com outras noções."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Avaliação de expressões algébricas e precedência de operadores.",
                                "Lógica e Algoritmos: Processamento em pilha (LIFO).",
                                "Engenharia de Computação: Fundamento para compiladores e máquinas virtuais.",
                                "Programação: Similar a linguagens de script ou assembly postfix.",
                                "Física: Modelagem sequencial em simulações computacionais."
                              ],
                              "realWorldApplication": "Na geração de código intermediário de compiladores, a notação pós-fixa (Reverse Polish Notation - RPN) permite avaliação eficiente sem tabelas de precedência, usada em calculadoras HP, interpretadores Forth e otimizadores de JVM."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.6.2.1.2",
                            "name": "Comparar notação pós-fixa com infixa e prefixa",
                            "description": "Diferenciar as três notações polonesas, destacando vantagens da pós-fixa na geração de código intermediário por evitar pilhas de parênteses.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar a notação infixa padrão",
                                  "subSteps": [
                                    "Explique que a notação infixa coloca operadores entre operandos, como A + B.",
                                    "Discuta a necessidade de parênteses para precedência, ex: (A + B) * C.",
                                    "Identifique ambiguidades resolvidas por regras de precedência e associatividade.",
                                    "Pratique convertendo expressões simples para infixa com parênteses explícitos.",
                                    "Analise como parênteses criam pilhas aninhadas em parsing."
                                  ],
                                  "verification": "Converta 3 expressões aritméticas complexas para infixa fully parenthesized e explique precedência.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Editor de texto ou quadro branco"
                                  ],
                                  "tips": "Sempre parenthesize fully para evitar ambiguidades iniciais.",
                                  "learningObjective": "Compreender a estrutura e desafios da notação infixa em expressões.",
                                  "commonMistakes": [
                                    "Ignorar associatividade esquerda/direita",
                                    "Esquecer parênteses em operações aninhadas"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Introduzir notação prefixa (Polonesa)",
                                  "subSteps": [
                                    "Defina prefixa como operador antes dos operandos, ex: * + A B C para (A + B) * C.",
                                    "Aprenda a ler prefixa: operador primeiro, seguido de sub-expressões recursivas.",
                                    "Converta infixa para prefixa usando árvore de expressões ou algoritmo recursivo.",
                                    "Avalie prefixa usando pilha: leia da direita para esquerda.",
                                    "Compare legibilidade com infixa."
                                  ],
                                  "verification": "Converta (A + B) * (C - D) para prefixa e avalie o resultado.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Calculadora ou simulador de pilha online",
                                    "Lista de expressões de teste"
                                  ],
                                  "tips": "Pense recursivamente: cada operador consome operandos à direita.",
                                  "learningObjective": "Dominar sintaxe e conversão para notação prefixa.",
                                  "commonMistakes": [
                                    "Confundir ordem de leitura (esquerda vs direita)",
                                    "Erros em sub-expressões aninhadas"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explorar notação pós-fixa (Reverse Polonesa)",
                                  "subSteps": [
                                    "Defina pós-fixa como operandos primeiro, operador depois, ex: A B + C *.",
                                    "Converta infixa para pós-fixa usando algoritmo de Shunting-yard (pilha para operadores).",
                                    "Avalie pós-fixa com pilha: operandos empilham, operadores desempilham e aplicam.",
                                    "Destaque ausência de parênteses: precedência implícita pela ordem.",
                                    "Pratique com expressões multilineares."
                                  ],
                                  "verification": "Use Shunting-yard para converter 3 infixas para pós-fixa e avalie com pilha.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Implementação simples de pilha em Python ou pseudocódigo",
                                    "Exemplos impressos"
                                  ],
                                  "tips": "Simule pilha manualmente para visualizar operações.",
                                  "learningObjective": "Entender conversão e avaliação eficiente da pós-fixa.",
                                  "commonMistakes": [
                                    "Aplicar operador errado na ordem de desempilhamento",
                                    "Esquecer precedência no Shunting-yard"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Comparar as três notações com foco em compiladores",
                                  "subSteps": [
                                    "Liste prós/contras: infixa (legível, parênteses); prefixa (sem parênteses, difícil ler); pós-fixa (sem parênteses, fácil stack-based).",
                                    "Explique vantagens pós-fixa em geração de código: evita pilha de parênteses, direto para código de máquina com stack.",
                                    "Compare parsing: infixa (recursivo descendente complexo), pós-fixa (simples pilha única).",
                                    "Discuta usos: pós-fixa em JVM bytecode, calculadoras.",
                                    "Crie tabela comparativa de complexidade e eficiência."
                                  ],
                                  "verification": "Crie tabela comparando 3 expressões nas 3 notações e justifique superioridade pós-fixa para compiladores.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Planilha ou tabela em Markdown",
                                    "Artigos sobre Shunting-yard e postfix em compiladores"
                                  ],
                                  "tips": "Foque métricas: número de operações de pilha, legibilidade humana vs máquina.",
                                  "learningObjective": "Diferenciar vantagens, especialmente pós-fixa em geração de código intermediário.",
                                  "commonMistakes": [
                                    "Subestimar overhead de parênteses em infixa",
                                    "Confundir prefixa com pós-fixa na avaliação"
                                  ]
                                }
                              ],
                              "practicalExample": "Converta a expressão infixa ((A + B) * C) - D: Prefixa: - * + A B C D; Pós-fixa: A B + C * D -. Avalie pós-fixa com pilha: empilhe A,B; + -> A+B; empilhe C; * -> (A+B)*C; empilhe D; - -> resultado. Note zero parênteses na pós-fixa.",
                              "finalVerifications": [
                                "Converta corretamente 5 expressões infixas para prefixa e pós-fixa.",
                                "Avalie pós-fixa sem erros usando pilha simulada.",
                                "Explique por que pós-fixa evita pilhas de parênteses em compiladores.",
                                "Crie tabela comparativa precisa das três notações.",
                                "Identifique cenários onde cada notação é preferível.",
                                "Simule geração de código assembly simples a partir de pós-fixa."
                              ],
                              "assessmentCriteria": [
                                "Precisão nas conversões entre notações (100% correto).",
                                "Explicação clara das vantagens da pós-fixa em compiladores.",
                                "Uso correto de algoritmos como Shunting-yard.",
                                "Profundidade na comparação de eficiência de parsing.",
                                "Criatividade em exemplos e aplicações práticas.",
                                "Ausência de erros comuns em avaliação de pilha."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Árvores de expressões e recursão.",
                                "Lógica: Avaliação bottom-up vs top-down.",
                                "Engenharia de Software: Design de linguagens e parsing.",
                                "Algoritmos: Estruturas de dados (pilhas e filas)."
                              ],
                              "realWorldApplication": "Em compiladores como GCC ou JVM, notação pós-fixa gera bytecode eficiente sem parsing complexo de parênteses, usado em calculadoras stack-based (HP), interpretadores Forth e otimização de expressões em linguagens funcionais."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.6.2.1.3",
                            "name": "Reconhecer exemplos simples de expressões pós-fixas",
                            "description": "Analisar expressões como 'A B + C *' equivalente a (A + B) * C, identificando ordem de avaliação.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender Conceitos Básicos da Notação Pós-Fixa",
                                  "subSteps": [
                                    "Leia a definição: na notação pós-fixa (RPN), operandos vêm antes do operador, eliminando necessidade de parênteses.",
                                    "Compare com notação infixa: ex. 'A + B' vira 'A B +'; '(A + B) * C' vira 'A B + C *'.",
                                    "Identifique características: avaliação da esquerda para direita usando pilha.",
                                    "Anote exemplos simples: '2 3 +' = 5; '2 3 4 + *' = 2 * (3 + 4) = 14.",
                                    "Visualize com diagrama: desenhe pilha para um exemplo."
                                  ],
                                  "verification": "Explique verbalmente ou por escrito a conversão de uma infixa simples para pós-fixa.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Folha de papel e caneta",
                                    "Vídeo tutorial sobre RPN (ex: Khan Academy)",
                                    "Lista de exemplos impressos"
                                  ],
                                  "tips": "Pense na pilha como uma 'caixa' que empilha operandos até encontrar operador.",
                                  "learningObjective": "Diferenciar notação infixa e pós-fixa, reconhecendo a ordem operandos-operador.",
                                  "commonMistakes": [
                                    "Confundir ordem: colocar operador antes dos operandos",
                                    "Ignorar precedência implícita na pós-fixa"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Simular Avaliação de Expressões Pós-Fixas com Pilha",
                                  "subSteps": [
                                    "Revise algoritmo de pilha: empilhe operandos; ao encontrar operador, desempilhe dois operandos, aplique e empilhe resultado.",
                                    "Aplique a '3 4 +': empilhe 3, empilhe 4, +: desempilhe 4 e 3, some (7), empilhe.",
                                    "Teste 'A B + C *': empilhe A, B; +: (A+B); empilhe C; *: (A+B)*C.",
                                    "Registre passos em tabela: coluna para entrada, pilha atual, ação.",
                                    "Repita com 3 expressões variadas."
                                  ],
                                  "verification": "Desenhe tabela de pilha para '2 3 4 + *' mostrando resultado final 14.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Simulador online de pilha RPN (ex: repl.it)",
                                    "Papel quadriculado para tabelas"
                                  ],
                                  "tips": "Sempre desempilhe direito primeiro (último empilhado), depois esquerdo.",
                                  "learningObjective": "Executar avaliação passo a passo usando pilha para expressões pós-fixas simples.",
                                  "commonMistakes": [
                                    "Desempilhar na ordem errada",
                                    "Aplicar operador a mais/menos de dois operandos"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Converter Infixa Simples para Pós-Fixa e Vice-Versa",
                                  "subSteps": [
                                    "Aprenda regra de conversão infixa para pós-fixa: use pilha para operadores, precedência (* > +).",
                                    "Converta '(A + B) * C': A B + C *.",
                                    "Inverso: de 'A B + C *' para (A + B) * C, reconstruindo com parênteses.",
                                    "Pratique 5 pares: ex. 'A + B * C' → A B C * +.",
                                    "Valide convertendo de volta e avaliando."
                                  ],
                                  "verification": "Converta corretamente 3 expressões infixas para pós-fixa e explique equivalência.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Algoritmo Shunting-Yard impresso",
                                    "Exercícios pré-preparados"
                                  ],
                                  "tips": "Precedência: multiplica/divide antes de soma/subtração; mesma precedência, esquerda-direita.",
                                  "learningObjective": "Converter bidirecionalmente expressões simples, confirmando equivalência.",
                                  "commonMistakes": [
                                    "Esquecer parênteses na reconstrução infixa",
                                    "Ignorar associatividade"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Identificar e Reconhecer Exemplos Pós-Fixos em Contextos",
                                  "subSteps": [
                                    "Analise expressões mistas: identifique se 'A B C + *' é pós-fixa válida.",
                                    "Compare inválidas: 'A + B C' não é pós-fixa (operador no meio).",
                                    "Crie 4 exemplos próprios e avalie.",
                                    "Discuta em contexto de compiladores: por que pós-fixa facilita geração de código.",
                                    "Teste reconhecimento rápido: liste 10 expressões e classifique."
                                  ],
                                  "verification": "Classifique 5 expressões como pós-fixa ou não, justificando.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Lista de 20 expressões de teste",
                                    "Quiz online sobre RPN"
                                  ],
                                  "tips": "Conte operadores e operandos: operadores = operandos - 1 em pós-fixa válida.",
                                  "learningObjective": "Reconhecer padrões de expressões pós-fixas simples e inválidas.",
                                  "commonMistakes": [
                                    "Aceitar expressões com operadores iniciais",
                                    "Contar mal operandos/operadores"
                                  ]
                                }
                              ],
                              "practicalExample": "Analise 'A B + C *': 1. Empilhe A, B. 2. +: desempilhe B e A, some (A+B), empilhe. 3. Empilhe C. 4. *: desempilhe C e (A+B), multiplique. Resultado: (A + B) * C. Teste com números: A=2, B=3, C=4 → 28.",
                              "finalVerifications": [
                                "Avalia corretamente '3 4 + 5 *' como 35.",
                                "Converte '(A + B) * C' para 'A B + C *'.",
                                "Identifica 'A + B C' como inválida pós-fixa.",
                                "Reconstrói infixa de '2 3 +' como '2 + 3'.",
                                "Conta corretamente: 3 operandos, 2 operadores.",
                                "Explica uso de pilha sem erros."
                              ],
                              "assessmentCriteria": [
                                "Precisão na ordem de avaliação (100% correto em 5 exemplos).",
                                "Correta simulação de pilha sem inversão de operandos.",
                                "Bidirecionalidade: conversões infixa-pós-fixa exatas.",
                                "Reconhecimento de inválidas com justificativa lógica.",
                                "Eficiência: completa em tempo estimado com poucos erros.",
                                "Criatividade: gera exemplos próprios válidos."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Avaliação de expressões algébricas e precedência de operadores.",
                                "Estruturas de Dados: Aplicação prática de pilhas (stacks).",
                                "Lógica e Programação: Algoritmos de parsing em linguagens.",
                                "Física/Engenharia: Modelagem de cálculos em simuladores sem parênteses."
                              ],
                              "realWorldApplication": "Em compiladores (ex: Forth, Java JVM bytecode), calculadoras HP (RPN), e interpretadores para evitar ambiguidades de precedência, otimizando geração de código intermediário."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.6.2.1.1"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "10.1.6.2.2",
                        "name": "Algoritmo de Conversão de Infixa para Pós-Fixa",
                        "description": "Método utilizando pilha para converter expressões infixas em pós-fixas, respeitando precedência e associatividade de operadores.",
                        "specificSkills": [
                          {
                            "id": "10.1.6.2.2.1",
                            "name": "Aplicar o algoritmo de Shunting-Yard para conversão",
                            "description": "Executar passo a passo o algoritmo: processar tokens da esquerda para direita, empilhar operadores por precedência, saída para pós-fixa.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar a expressão infixa e estruturas de dados",
                                  "subSteps": [
                                    "Tokenizar a expressão infixa em uma lista de tokens, identificando operandos (variáveis ou números), operadores (+, -, *, /) e parênteses.",
                                    "Criar uma tabela de precedência para operadores (ex: * e / têm precedência 3, + e - têm 2, ( tem 0).",
                                    "Inicializar uma pilha vazia para operadores e uma lista vazia para a saída pós-fixa."
                                  ],
                                  "verification": "Lista de tokens completa e correta; pilha e saída vazias; tabela de precedência definida sem erros.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Papel e caneta ou editor de texto",
                                    "Tabela de precedência de operadores impressa ou digital"
                                  ],
                                  "tips": "Sempre inclua espaços ou vírgulas para separar tokens claramente; teste tokenização com expressões simples primeiro.",
                                  "learningObjective": "Configurar corretamente os dados iniciais para execução fluida do algoritmo.",
                                  "commonMistakes": [
                                    "Tokenizar incorretamente (ex: 'AB' como um token)",
                                    "Esquecer associatividade à esquerda para operadores de mesma precedência",
                                    "Precedências invertidas"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Processar tokens da esquerda para a direita",
                                  "subSteps": [
                                    "Para cada token: se for operando, adicionar diretamente à saída.",
                                    "Se for operador: enquanto a pilha não estiver vazia e o topo da pilha tiver precedência maior ou igual (considerando associatividade), desempilhar para a saída; então empilhar o operador atual.",
                                    "Se for '(': empilhar diretamente.",
                                    "Se for ')': desempilhar operadores para a saída até encontrar '(', então desempilhar o '(' sem adicioná-lo à saída.",
                                    "Manter registro do estado da pilha e saída após cada token."
                                  ],
                                  "verification": "Para cada token processado, a pilha e saída refletem as regras corretas; nenhum operador pendente incorreto.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Papel quadriculado para rastrear pilha e saída",
                                    "Simulador online de pilha opcional"
                                  ],
                                  "tips": "Use setas para mostrar pops e pushes; precedência igual usa associatividade à esquerda (pop).",
                                  "learningObjective": "Aplicar as regras principais do loop de processamento token por token.",
                                  "commonMistakes": [
                                    "Não popar operadores de precedência igual",
                                    "Empilhar ')' incorretamente",
                                    "Adicionar '(' à saída"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Finalizar o processamento e esvaziar a pilha",
                                  "subSteps": [
                                    "Após processar todos os tokens, enquanto a pilha não estiver vazia, desempilhar todos os operadores restantes para a saída.",
                                    "Verificar se há '(' restantes na pilha (indica parênteses desbalanceados à esquerda).",
                                    "Concatenar a saída em uma string pós-fixa sem espaços desnecessários."
                                  ],
                                  "verification": "Pilha completamente vazia (exceto erro de parênteses); saída contém todos os tokens processados.",
                                  "estimatedTime": "10 minutos",
                                  "materials": [
                                    "Papel para anotar estado final"
                                  ],
                                  "tips": "Sempre verifique balanceamento de parênteses no final; ignore ')' pendentes como erro.",
                                  "learningObjective": "Completar o algoritmo garantindo que todos os operadores sejam posicionados corretamente.",
                                  "commonMistakes": [
                                    "Esquecer de esvaziar a pilha",
                                    "Deixar parênteses na saída",
                                    "Não detectar erros de balanceamento"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Validar a notação pós-fixa gerada",
                                  "subSteps": [
                                    "Contar operandos e operadores na saída (número de operandos = operadores + 1 para expressões válidas).",
                                    "Simular a avaliação da pós-fixa usando uma pilha de avaliação para confirmar que reproduz o valor ou estrutura da infixa.",
                                    "Comparar manualmente a precedência na saída com a original.",
                                    "Testar com uma entrada alternativa para reforçar."
                                  ],
                                  "verification": "Saída avalia corretamente; contagem balanceada; precedência preservada.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Calculadora para avaliação numérica",
                                    "Ferramenta online de notação polonesa"
                                  ],
                                  "tips": "Substitua variáveis por números para testar numericamente (ex: A=1, B=2).",
                                  "learningObjective": "Confirmar a correção da conversão e detectar erros residuais.",
                                  "commonMistakes": [
                                    "Ignorar contagem de balanceamento",
                                    "Avaliação errada da pós-fixa",
                                    "Não testar precedência"
                                  ]
                                }
                              ],
                              "practicalExample": "Converta a expressão infixa '(A + B) * C' para pós-fixa usando Shunting-Yard:\nTokens: '(', A, +, B, ')', *, C\n1. '(' → pilha: ['(']\n2. A → saída: A\n3. + → pilha: ['(', '+']\n4. B → saída: A B\n5. ')' → pop + → saída: A B +, pop '(' → pilha: []\n6. * → pilha: ['*']\n7. C → saída: A B + C\n8. Fim → pop * → saída: A B + C *\nResultado: 'AB+C*'",
                              "finalVerifications": [
                                "A saída é uma sequência válida de pós-fixa sem parênteses.",
                                "Precedência e associatividade dos operadores estão preservadas.",
                                "Número de operandos excede operadores por 1 (para expressões simples).",
                                "Avaliação da pós-fixa reproduz o resultado da infixa.",
                                "Nenhum parêntese ou token perdido na saída.",
                                "Processamento lida corretamente com expressões aninhadas."
                              ],
                              "assessmentCriteria": [
                                "Aplicação precisa das regras de precedência e pilha em todos os tokens.",
                                "Manipulação correta de parênteses de abertura e fechamento.",
                                "Detecção e tratamento de erros como parênteses desbalanceados.",
                                "Rastreamento completo do estado (pilha e saída) em cada passo.",
                                "Validação final robusta com simulação de avaliação.",
                                "Eficiência: sem passos redundantes ou loops infinitos."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Hierarquia de operações e precedência algébrica.",
                                "Estruturas de Dados: Uso de pilhas (LIFO) e filas para processamento.",
                                "Lógica e Algoritmos: Estados finitos e processamento sequencial.",
                                "Engenharia de Software: Parsing de expressões em compiladores e interpretadores.",
                                "Física/Engenharia: Modelagem de expressões em simulações computacionais."
                              ],
                              "realWorldApplication": "O algoritmo Shunting-Yard é fundamental em compiladores (ex: GCC, Java) para gerar código intermediário a partir de expressões, em calculadoras científicas (ex: TI-84), planilhas (Excel fórmulas) e parsers de linguagens de script (JavaScript, Python eval), permitindo avaliação eficiente de expressões sem recursão."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.6.2.1.1"
                            ]
                          },
                          {
                            "id": "10.1.6.2.2.2",
                            "name": "Tratar precedência e associatividade em conversões",
                            "description": "Determinar ordem de empilhamento para operadores como +, *, com parênteses, gerando saída correta como 'A B C + *' para A*(B+C).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender precedência e associatividade de operadores",
                                  "subSteps": [
                                    "Defina precedência: valor numérico atribuído a cada operador (ex: * > +).",
                                    "Defina associatividade: esquerda (esq-para-dir) ou direita (dir-para-esq).",
                                    "Liste operadores comuns: +, -, *, /, ^ com precedências (ex: + e -:1, * e /:2, ^:3).",
                                    "Exemplo: em A+B*C, * tem maior precedência que +, então B*C primeiro."
                                  ],
                                  "verification": "Crie uma tabela manual de precedência e associe 5 operadores corretamente.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Tabela de operadores aritméticos"
                                  ],
                                  "tips": "Sempre associe precedência mais alta a operações 'mais internas'.",
                                  "learningObjective": "Diferenciar e aplicar precedência e associatividade para ordenar operações.",
                                  "commonMistakes": [
                                    "Confundir associatividade esquerda/direita para ^ (direita).",
                                    "Ignorar que parênteses têm precedência máxima (infinita)."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Configurar estruturas de dados e tabela de precedência",
                                  "subSteps": [
                                    "Crie uma pilha vazia para operadores.",
                                    "Inicialize uma fila ou lista para saída (pós-fixa).",
                                    "Implemente função getPrecedence(op): retorna valor int (ex: '+'=1, '*'=2).",
                                    "Implemente função getAssociativity(op): retorna 'left' ou 'right'.",
                                    "Defina precedência de parênteses: '(' = alta na entrada, ')' = pop."
                                  ],
                                  "verification": "Teste funções: getPrecedence('*')==2 e getAssociativity('+')=='left'.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Editor de código (Python/JS)",
                                    "Pseudocódigo do Shunting-yard"
                                  ],
                                  "tips": "Use dicionários para tabelas de precedência para lookup rápido.",
                                  "learningObjective": "Preparar dados para algoritmo de conversão infixa-pós-fixa.",
                                  "commonMistakes": [
                                    "Esquecer associatividade para operadores unários.",
                                    "Precedência errada para ^ (direita-associativa)."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Processar tokens da expressão infixa",
                                  "subSteps": [
                                    "Tokenize entrada: identifique operandos (A,B), operadores (+,*), parênteses.",
                                    "Para operando: adicione diretamente à saída.",
                                    "Para operador: while pilha não vazia e topo tem >= precedência (considere assoc), pop para saída; push operador.",
                                    "Para '(': push na pilha.",
                                    "Para ')': pop até '(' para saída, pop '('."
                                  ],
                                  "verification": "Simule manualmente 'A*(B+C)': saída deve ser 'A B C + *'",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Papel para simulação passo-a-passo",
                                    "Código skeleton do algoritmo"
                                  ],
                                  "tips": "Compare precedência: para left-assoc, pop se topo >= atual; right-assoc, > atual.",
                                  "learningObjective": "Implementar lógica core do Shunting-yard para ordenação.",
                                  "commonMistakes": [
                                    "Não tratar parênteses corretamente (pop excessivo).",
                                    "Pop errada em associatividade esquerda vs direita."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Finalizar saída e validar conversão",
                                  "subSteps": [
                                    "Após todos tokens, pop toda pilha para saída.",
                                    "Valide: sem parênteses restantes na pilha.",
                                    "Teste com múltiplos casos: sem parên, com parên aninhados, associatividade direita.",
                                    "Gere árvore de expressão implícita via pós-fixa.",
                                    "Compare avaliação infixa vs pós-fixa (mesmo resultado)."
                                  ],
                                  "verification": "Todos testes passam: 'A+B*C' -> 'A B C * +'; '(A+B)*C' -> 'A B + C *'",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Calculadora ou interpretador para validar resultado numérico",
                                    "Lista de 5 expressões teste"
                                  ],
                                  "tips": "Pós-fixa é sem parênteses e operandos primeiro.",
                                  "learningObjective": "Completar algoritmo e garantir correção total.",
                                  "commonMistakes": [
                                    "Deixar operadores na pilha.",
                                    "Erro em expressões vazias ou só operandos."
                                  ]
                                }
                              ],
                              "practicalExample": "Para 'A*(B+C)': 1. A (saída: A). 2. * (push *). 3. ( (push (). 4. B (saída: A B). 5. + (push +). 6. C (saída: A B C). 7. ) (pop + para saída: A B C +, pop (). 8. ) (pop * para saída: A B C + *). Saída final: 'A B C + *'.",
                              "finalVerifications": [
                                "Pilha vazia após processamento.",
                                "Nenhum parêntese na saída.",
                                "Avaliação da pós-fixa dá mesmo resultado que infixa.",
                                "Trata corretamente associatividade direita em ^.",
                                "Converte expressões aninhadas sem erros."
                              ],
                              "assessmentCriteria": [
                                "Precisão em 90% dos testes com precedência variada.",
                                "Tempo de execução O(n) no algoritmo.",
                                "Código limpo com funções modulares.",
                                "Explicação correta de 3 erros comuns.",
                                "Aplicação em 2 cenários reais."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Ordem de operações (PEMDAS/BODMAS).",
                                "Algoritmos: Pilhas e filas em estruturas de dados.",
                                "Lógica: Árvores de expressão e parsing.",
                                "Engenharia de Software: Parsers em linguagens de programação."
                              ],
                              "realWorldApplication": "Usado em compiladores (GCC, LLVM) para otimizar expressões; calculadoras (HP Reverse Polish); interpretadores (Python eval pós-processamento); spreadsheets (Excel fórmulas)."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.6.2.2.1"
                            ]
                          },
                          {
                            "id": "10.1.6.2.2.3",
                            "name": "Converter expressões complexas manualmente",
                            "description": "Realizar conversão de expressões com múltiplos operadores e parênteses aninhados, verificando resultado com avaliação.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar precedência e associatividade dos operadores",
                                  "subSteps": [
                                    "Liste todos os operadores comuns (ex: +, -, *, /, ^) e suas precedências (alta para * / ^, baixa para + -).",
                                    "Defina associatividade: esquerda para +, -, *, /; direita para ^.",
                                    "Crie uma tabela de precedência com valores numéricos (ex: + e - = 1, * e / = 2, ^ = 3).",
                                    "Identifique operadores unários se aplicável (ex: -unário com precedência alta).",
                                    "Pratique comparando precedências entre dois operadores."
                                  ],
                                  "verification": "Construa e recite corretamente uma tabela de precedência para 5 operadores sem erros.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Tabela de precedência impressa ou digital"
                                  ],
                                  "tips": "Memorize precedências com mnemônicos como 'PEMDAS' adaptado para o algoritmo.",
                                  "learningObjective": "Compreender e aplicar regras de precedência para ordenar operações corretamente.",
                                  "commonMistakes": [
                                    "Confundir associatividade esquerda/direita",
                                    "Ignorar precedência de parênteses",
                                    "Tratar ^ como associativa à esquerda"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Inicializar estruturas de dados e tokenizar a expressão",
                                  "subSteps": [
                                    "Tokenize a expressão infixa em lista de tokens (operandos e operadores/parênteses).",
                                    "Inicialize uma pilha vazia para operadores.",
                                    "Inicialize uma fila ou lista vazia para a saída pós-fixa.",
                                    "Remova espaços e valide parênteses balanceados contando aberturas e fechamentos.",
                                    "Anote operandos como A, B (variáveis) ou números."
                                  ],
                                  "verification": "Mostre a lista de tokens e confirme que pilha e saída estão vazias e prontas.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Papel quadriculado",
                                    "Editor de texto simples"
                                  ],
                                  "tips": "Use símbolos claros para tokens; agrupe parênteses como unidades.",
                                  "learningObjective": "Preparar dados de entrada corretamente para o algoritmo Shunting-yard.",
                                  "commonMistakes": [
                                    "Esquecer de tokenizar parênteses",
                                    "Não validar balanceamento inicial",
                                    "Confundir operandos com operadores"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Processar tokens sequencialmente com regras de pilha",
                                  "subSteps": [
                                    "Para operando: adicione diretamente à saída.",
                                    "Para '(': empilhe na pilha de operadores.",
                                    "Para ')': pop da pilha para saída até encontrar '(', descartando-o.",
                                    "Para operador: enquanto pilha topo tem precedência >= (ou > se direita), pop para saída; então empilhe o atual.",
                                    "Repita para todos tokens, anotando estado da pilha e saída após cada."
                                  ],
                                  "verification": "A saída parcial e pilha refletem regras corretas após processar todos tokens.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Papel para desenhar pilha e saída",
                                    "Exemplo de expressão complexa"
                                  ],
                                  "tips": "Desenhe pilha como lista vertical; use setas para pops/pushes.",
                                  "learningObjective": "Aplicar algoritmo Shunting-yard para lidar com precedência e parênteses.",
                                  "commonMistakes": [
                                    "Pop incorreto na precedência (usar > em vez de >=)",
                                    "Não associar ^ à direita",
                                    "Pop excessivo em ')'"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Finalizar saída e verificar resultado",
                                  "subSteps": [
                                    "Após todos tokens, pop todos operadores restantes da pilha para saída.",
                                    "Confirme que pilha está vazia (exceto possivelmente erros).",
                                    "Avalie a expressão pós-fixa manualmente ou com calculadora para validar.",
                                    "Compare com conversão esperada ou avaliação infixa equivalente.",
                                    "Teste com valores numéricos atribuídos a variáveis."
                                  ],
                                  "verification": "Pilha vazia, saída completa e avaliação numérica coincide com infixa.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Calculadora",
                                    "Valores de teste para variáveis"
                                  ],
                                  "tips": "Atribua números pequenos para facilitar cálculo manual.",
                                  "learningObjective": "Completar e validar a conversão pós-fixa.",
                                  "commonMistakes": [
                                    "Esquecer de esvaziar pilha",
                                    "Erro na avaliação pós-fixa",
                                    "Não testar numericamente"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Iterar com expressões mais complexas e autoavaliação",
                                  "subSteps": [
                                    "Escolha uma nova expressão com parênteses aninhados e múltiplos ^.",
                                    "Repita todo o processo do início ao fim.",
                                    "Compare seu resultado com uma solução conhecida.",
                                    "Identifique e corrija qualquer erro usando a tabela de precedência.",
                                    "Documente lições aprendidas em um log."
                                  ],
                                  "verification": "Converta 2 expressões complexas com 100% acerto em avaliação.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Lista de expressões de teste",
                                    "Solução modelo"
                                  ],
                                  "tips": "Aumente complexidade gradualmente: comece sem ^, adicione depois.",
                                  "learningObjective": "Dominar conversão manual através de prática iterativa.",
                                  "commonMistakes": [
                                    "Rushing sem verificar passos",
                                    "Ignorar aninhamento profundo",
                                    "Não logar erros"
                                  ]
                                }
                              ],
                              "practicalExample": "Converta (A + B * (C ^ D - E / F)) para pós-fixa: ABCD^EF/ -*+",
                              "finalVerifications": [
                                "A expressão pós-fixa processa corretamente com algoritmo de avaliação.",
                                "Avaliação numérica com valores atribuídos coincide com a infixa original.",
                                "Todos parênteses foram tratados corretamente sem sobras na pilha.",
                                "Precedências e associatividades foram respeitadas na saída.",
                                "Nenhum operando ou operador foi perdido ou duplicado.",
                                "Pilha final está vazia após esvaziamento."
                              ],
                              "assessmentCriteria": [
                                "Precisão na tokenização e inicialização (sem erros de sintaxe).",
                                "Aplicação correta de regras de precedência durante processamento.",
                                "Manejo impecável de parênteses aninhados.",
                                "Validação numérica da saída pós-fixa.",
                                "Eficiência no número de steps e ausência de erros comuns.",
                                "Capacidade de explicar cada decisão em um passo."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Álgebra e avaliação de expressões hierárquicas.",
                                "Lógica: Estruturas de pilha e algoritmos de parsing.",
                                "Programação: Implementação em linguagens como Python ou C++.",
                                "Engenharia de Software: Parsers em compiladores e interpretadores."
                              ],
                              "realWorldApplication": "Em compiladores reais (ex: GCC), calculadoras científicas (ex: HP RPN), processadores de expressões em Excel ou linguagens de script, otimizando avaliação sem parênteses."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.6.2.2.2"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "10.1.6.2.3",
                        "name": "Aplicação na Geração de Código Intermediário",
                        "description": "Uso da notação pós-fixa em compiladores para representar árvores de expressões de forma linear, facilitando geração de código objeto.",
                        "specificSkills": [
                          {
                            "id": "10.1.6.2.3.1",
                            "name": "Avaliar expressões pós-fixas usando pilha",
                            "description": "Implementar avaliação com pilha: empilhar operandos, desempilhar para aplicar operador, resultando em valor final.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Inicializar a Pilha e Tokenizar a Expressão",
                                  "subSteps": [
                                    "Escolha uma linguagem de programação como Python ou Java para implementar a pilha.",
                                    "Crie uma estrutura de pilha vazia (use lista em Python ou Stack em Java).",
                                    "Receba a expressão pós-fixa como string (ex: '2 3 + 4 *').",
                                    "Divida a string em tokens usando split() ou tokenizer similar, ignorando espaços extras.",
                                    "Valide que a expressão não está vazia."
                                  ],
                                  "verification": "Pilha está vazia e lista de tokens é gerada corretamente (ex: ['2','3','+','4','*']).",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Editor de código (VS Code, PyCharm)",
                                    "Documentação de Stack/Queue na linguagem escolhida"
                                  ],
                                  "tips": [
                                    "Use collections.deque em Python para operações eficientes de pilha.",
                                    "Sempre imprima tokens para depuração inicial."
                                  ],
                                  "learningObjective": "Preparar o ambiente para avaliação de expressões pós-fixas entendendo tokenização.",
                                  "commonMistakes": [
                                    "Confundir notação pós-fixa com infixa.",
                                    "Não remover espaços extras nos tokens."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Processar Operandos e Empilhá-los",
                                  "subSteps": [
                                    "Inicie um loop iterando sobre cada token na lista.",
                                    "Se o token for um operando (dígito ou número), converta para inteiro/float e empilhe.",
                                    "Use isdigit() ou similar para identificar operandos (assuma expressões simples sem variáveis).",
                                    "Continue até encontrar o primeiro operador.",
                                    "Registre o estado da pilha após cada empilhamento para depuração."
                                  ],
                                  "verification": "Todos os operandos iniciais foram empilhados corretamente sem erros de conversão.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Calculadora para validar números",
                                    "Exemplos de expressões pós-fixas simples"
                                  ],
                                  "tips": [
                                    "Teste com expressão só de operandos primeiro (ex: '2 3') para isolar o passo.",
                                    "Mantenha pilha como lista de números, não strings."
                                  ],
                                  "learningObjective": "Identificar e empilhar operandos corretamente na sequência pós-fixa.",
                                  "commonMistakes": [
                                    "Empilhar operadores como operandos.",
                                    "Falhar na conversão de string para número (ex: int(token))."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Detectar Operadores, Desempilhar e Aplicar Operação",
                                  "subSteps": [
                                    "No loop, se token for operador ('+','-','*','/'), desempilhe dois operandos (b primeiro, depois a).",
                                    "Aplique a operação: resultado = a op b (atenção à ordem para subtração/divisão).",
                                    "Empilhe o resultado na pilha.",
                                    "Trate divisão por zero com exceção ou verificação prévia.",
                                    "Atualize a pilha após cada operação."
                                  ],
                                  "verification": "Para cada operador, pilha diminui em 1 após desempilhar dois e empilhar um.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Tabela de precedência de operadores (não necessária aqui, mas útil)",
                                    "Debugger do IDE"
                                  ],
                                  "tips": [
                                    "Lembre: em pós-fixa, desempilhe b primeiro (topo), depois a.",
                                    "Use if-elif para múltiplos operadores."
                                  ],
                                  "learningObjective": "Implementar lógica de operadores mantendo integridade da pilha.",
                                  "commonMistakes": [
                                    "Ordem errada de desempilhamento (a e b invertidos).",
                                    "Não tratar divisão por zero."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Finalizar Avaliação e Validar Resultado",
                                  "subSteps": [
                                    "Após processar todos os tokens, verifique se pilha tem exatamente 1 elemento.",
                                    "Pop o topo da pilha como resultado final.",
                                    "Teste com expressão completa e compare com cálculo manual.",
                                    "Adicione tratamento de erro se pilha vazia ou múltiplos elementos.",
                                    "Implemente função reutilizável para múltiplas expressões."
                                  ],
                                  "verification": "Resultado matches cálculo manual (ex: '2 3 + 4 *' -> 20) e pilha esvaziada exceto resultado.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Lista de expressões de teste (simples, compostas, edge cases)"
                                  ],
                                  "tips": [
                                    "Sempre limpe pilha entre testes.",
                                    "Adicione logs para rastrear pilha em cada iteração."
                                  ],
                                  "learningObjective": "Concluir avaliação garantindo validade do resultado.",
                                  "commonMistakes": [
                                    "Ignorar sobras na pilha (expressão inválida).",
                                    "Não testar edge cases como '2' (único operando)."
                                  ]
                                }
                              ],
                              "practicalExample": "Expressão: '2 3 + 4 *'\n1. Token: '2' → empilhe 2 [2]\n2. Token: '3' → empilhe 3 [2,3]\n3. Token: '+' → desempilhe 3 e 2, 2+3=5 → empilhe [5]\n4. Token: '4' → empilhe 4 [5,4]\n5. Token: '*' → desempilhe 4 e 5, 5*4=20 → empilhe [20]\nResultado: 20",
                              "finalVerifications": [
                                "Pilha contém exatamente um elemento no final.",
                                "Nenhum erro de desempilhamento insuficiente durante processamento.",
                                "Todos os tokens foram processados.",
                                "Resultado corresponde ao valor esperado de teste manual.",
                                "Tratamento de erros para expressões inválidas (ex: mais operadores que operandos).",
                                "Pilha é esvaziada corretamente após pop do resultado.",
                                "Logs mostram evolução correta da pilha."
                              ],
                              "assessmentCriteria": [
                                "Implementa empilhamento/desempilhamento corretamente para operandos e operadores.",
                                "Maneja ordem correta em operações não-comutativas (subtração, divisão).",
                                "Processa expressões com 3+ operadores sem erros de pilha.",
                                "Inclui verificações de erro (pilha insuficiente, divisão zero).",
                                "Função é eficiente (O(n) tempo) e reutilizável.",
                                "Código é legível com comentários e testes inline.",
                                "Correto em 100% dos casos de teste fornecidos."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Álgebra e avaliação de expressões aritméticas.",
                                "Lógica e Algoritmos: Estruturas de dados lineares (pilhas).",
                                "Engenharia de Software: Parsing e interpretadores.",
                                "Física/Engenharia: Simulações com expressões matemáticas postfix.",
                                "Inteligência Artificial: Processamento de linguagens em PLN."
                              ],
                              "realWorldApplication": "Essencial em compiladores e interpretadores para avaliar expressões durante geração de código intermediário; usado em calculadoras programáveis (HP Reverse Polish Notation); otimizações em processadores stack-based como JVM; parsers de linguagens de script e Forth."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.6.2.1.3"
                            ]
                          },
                          {
                            "id": "10.1.6.2.3.2",
                            "name": "Gerar código intermediário a partir de pós-fixa",
                            "description": "Mapear notação pós-fixa para instruções de máquina ou três endereços, como 't1 = A + B; t2 = t1 * C'.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender e preparar a notação pós-fixa",
                                  "subSteps": [
                                    "Identifique todos os tokens na expressão pós-fixa, separando operandos (variáveis ou constantes) de operadores (+, -, *, /).",
                                    "Crie uma lista ou array com os tokens na ordem exata da notação pós-fixa.",
                                    "Defina um contador de temporários iniciando em 't1' para uso em instruções de três endereços.",
                                    "Revise a expressão para garantir que está balanceada (número correto de operandos por operador).",
                                    "Escreva um exemplo simples manualmente para validar o parsing."
                                  ],
                                  "verification": "Lista de tokens corretamente identificados e contador de temporários pronto.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Papel e caneta ou editor de texto",
                                    "Exemplo de expressão pós-fixa como 'A B + C *'"
                                  ],
                                  "tips": "Sempre processe da esquerda para a direita; operandos primeiro.",
                                  "learningObjective": "Preparar a entrada para processamento eficiente com pilha.",
                                  "commonMistakes": [
                                    "Confundir ordem dos tokens",
                                    "Esquecer de diferenciar operandos de operadores",
                                    "Não inicializar contador de temporários"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Inicializar pilha e processar operandos",
                                  "subSteps": [
                                    "Crie uma pilha vazia para armazenar identificadores (variáveis ou temporários).",
                                    "Percorra os tokens da esquerda para a direita.",
                                    "Para cada operando encontrado, empilhe seu nome diretamente na pilha.",
                                    "Registre cada empilhamento em um log para depuração.",
                                    "Continue até encontrar o primeiro operador."
                                  ],
                                  "verification": "Pilha contém apenas operandos empilhados corretamente após processar todos os operandos iniciais.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Editor de código com pilha simulada (Python list ou Java Stack)",
                                    "Debugger ou console para printar pilha"
                                  ],
                                  "tips": "Use print statements para visualizar o estado da pilha após cada operação.",
                                  "learningObjective": "Dominar o empilhamento de operandos como base para avaliação pós-fixa.",
                                  "commonMistakes": [
                                    "Empilhar operadores prematuramente",
                                    "Inverter ordem de empilhamento",
                                    "Não limpar pilha anterior"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Processar operadores e gerar instruções de três endereços",
                                  "subSteps": [
                                    "Para cada operador encontrado, desempilhe dois operandos: direito primeiro, depois esquerdo.",
                                    "Gere um novo temporário (ex: t1, t2) e crie a instrução: 'novo_temp = esquerdo op direito'.",
                                    "Empilhe o novo temporário na pilha.",
                                    "Adicione a instrução gerada a uma lista de código intermediário.",
                                    "Repita até o final da expressão."
                                  ],
                                  "verification": "Pilha tem exatamente um elemento final (resultado) e lista de instruções completa.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Código de implementação em pseudocódigo ou linguagem real",
                                    "Exemplos de teste múltiplos"
                                  ],
                                  "tips": "Lembre-se: em pós-fixa, o segundo pop é o operando esquerdo.",
                                  "learningObjective": "Gerar código de três endereços correto usando pilha para operadores.",
                                  "commonMistakes": [
                                    "Pop errada ordem (esquerdo/direito)",
                                    "Incrementar temporário incorretamente",
                                    "Gerar instruções com sintaxe errada"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Validar e otimizar o código intermediário gerado",
                                  "subSteps": [
                                    "Verifique se a pilha tem um único elemento no topo (resultado final).",
                                    "Execute o código intermediário manualmente para confirmar o resultado.",
                                    "Procure otimizações como eliminação de temporários desnecessários.",
                                    "Teste com variações da expressão para robustez.",
                                    "Documente o código final com comentários."
                                  ],
                                  "verification": "Código executa corretamente e matches a avaliação da pós-fixa.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Calculadora ou interpretador simples",
                                    "Ferramentas de teste unitário"
                                  ],
                                  "tips": "Simule com valores numéricos concretos para A, B, C.",
                                  "learningObjective": "Garantir correção e eficiência do código intermediário.",
                                  "commonMistakes": [
                                    "Ignorar sobras na pilha",
                                    "Não testar com valores reais",
                                    "Omitir otimizações básicas"
                                  ]
                                }
                              ],
                              "practicalExample": "Para a pós-fixa 'A B + C *':\n1. t1 = A + B\n2. t2 = t1 * C\nResultado final: t2",
                              "finalVerifications": [
                                "Pilha final contém exatamente um temporário representando o resultado.",
                                "Todas as instruções de três endereços estão na ordem correta de geração.",
                                "Simulação manual com valores (ex: A=1, B=2, C=3) produz resultado esperado (9).",
                                "Nenhum erro de pilha (underflow/overflow).",
                                "Contador de temporários é mínimo e sequencial.",
                                "Código é legível e comentado."
                              ],
                              "assessmentCriteria": [
                                "Precisão na geração de temporários e operadores (100% match com esperado).",
                                "Eficiência: número mínimo de temporários usados.",
                                "Robustez: funciona para expressões com 3+ operadores.",
                                "Clareza: instruções bem formatadas e ordenadas.",
                                "Tratamento de erros: detecção de expressões inválidas.",
                                "Tempo de processamento: O(n) linear."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Avaliação de expressões algébricas e notação polonesa.",
                                "Lógica e Estruturas de Dados: Uso de pilhas (Stack ADT).",
                                "Engenharia de Software: Geração de código em compiladores.",
                                "Algoritmos: Parsing e avaliação bottom-up."
                              ],
                              "realWorldApplication": "Em compiladores reais (GCC, LLVM), geradores de bytecode (JVM), calculadoras RPN (HP), e otimizadores de expressões em linguagens como Python ou Java para evitar precedência de operadores."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.6.2.2.1",
                              "10.1.6.2.3.1"
                            ]
                          },
                          {
                            "id": "10.1.6.2.3.3",
                            "name": "Identificar vantagens em compiladores",
                            "description": "Explicar como pós-fixa simplifica análise semântica e otimização, referenciando Aho et al. e Santos & Langlois.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Fundamentos da Notação Pós-Fixa",
                                  "subSteps": [
                                    "Defina notação infixa, prefixa e pós-fixa com exemplos simples como 'a + b * c'.",
                                    "Converta expressões infixas para pós-fixa usando algoritmo de Shunting-yard.",
                                    "Explique o papel de pilhas na avaliação de expressões pós-fixa.",
                                    "Compare precedência e associatividade em diferentes notações.",
                                    "Identifique ausência de parênteses na pós-fixa."
                                  ],
                                  "verification": "Converta corretamente 3 expressões infixas complexas para pós-fixa sem erros.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Livro 'Compilers: Principles, Techniques, and Tools' (Aho et al., Capítulo 6); Ferramenta online de conversor de notação (ex: infix-to-postfix converter).",
                                  "tips": "Pratique com expressões aninhadas para internalizar o algoritmo.",
                                  "learningObjective": "Compreender a estrutura da notação pós-fixa como base para simplificações em compiladores.",
                                  "commonMistakes": "Confundir ordem de operandos ou esquecer associatividade à esquerda."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Entender Análise Semântica em Compiladores Tradicionais",
                                  "subSteps": [
                                    "Descreva fases da análise semântica: verificação de tipos, escopo e sobrecarga.",
                                    "Explique desafios em árvores sintáticas (AST) com expressões infixas: recursão profunda e dependências laterais.",
                                    "Analise como pilhas de símbolos são usadas em traversais bottom-up vs. top-down.",
                                    "Identifique gargalos: necessidade de múltiplas passagens para resolução de nomes.",
                                    "Compare com análise em código de três endereços."
                                  ],
                                  "verification": "Desenhe um diagrama comparando análise semântica em AST infixa vs. linear.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Aho et al. (Capítulos 6 e 7); Artigo de Santos & Langlois sobre geração de código intermediário.",
                                  "tips": "Use pseudocódigo para simular traversais de árvores.",
                                  "learningObjective": "Identificar complexidades da análise semântica em representações não-lineares.",
                                  "commonMistakes": "Ignorar dependências de contexto em escopo dinâmico."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explorar Simplificações na Análise Semântica com Pós-Fixa",
                                  "subSteps": [
                                    "Demonstre como pós-fixa permite análise left-to-right sem backtracking.",
                                    "Explique eliminação de pilha recursiva: operandos empilhados naturalmente.",
                                    "Verifique type-checking unário: operadores aplicados sequencialmente.",
                                    "Analise otimização de escopo: resolução linear sem tabelas profundas.",
                                    "Referencie Aho et al. seção sobre geração de código intermediário em RPN."
                                  ],
                                  "verification": "Aplique análise semântica em uma expressão pós-fixa e liste simplificações observadas.",
                                  "estimatedTime": "50 minutos",
                                  "materials": "Aho et al. (páginas específicas sobre RPN); Santos & Langlois (seção de notação pós-fixa).",
                                  "tips": "Simule com uma calculadora HP (RPN) para visualizar fluxo.",
                                  "learningObjective": "Explicar como linearidade da pós-fixa reduz complexidade da análise semântica.",
                                  "commonMistakes": "Subestimar benefícios em expressões com múltiplos operadores."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar Vantagens na Otimização com Pós-Fixa",
                                  "subSteps": [
                                    "Descreva otimizações locais: eliminação de comuns subexpressões em sequência linear.",
                                    "Explique dead code elimination facilitada por fluxo unidirecional.",
                                    "Discuta peephole optimization: janelas deslizantes em código pós-fixo.",
                                    "Compare com otimizações globais em IRs tradicionais: menos iterações necessárias.",
                                    "Cite Santos & Langlois sobre eficiência em geração de objeto."
                                  ],
                                  "verification": "Otimize uma sequência pós-fixa manualmente e compare ciclos de CPU estimados.",
                                  "estimatedTime": "55 minutos",
                                  "materials": "Aho et al. (Capítulo 9 sobre otimização); Exemplos de código Forth ou assembly RPN.",
                                  "tips": "Use um interpretador simples de pós-fixa para testar otimizações.",
                                  "learningObjective": "Identificar como estrutura pós-fixa acelera passes de otimização.",
                                  "commonMistakes": "Confundir otimizações locais com globais."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Sintetizar Vantagens e Referenciar Fontes",
                                  "subSteps": [
                                    "Liste 5 vantagens chave: simplicidade, eficiência, paralelismo potencial.",
                                    "Integre citações diretas de Aho et al. e Santos & Langlois.",
                                    "Crie um resumo comparativo em tabela: pós-fixa vs. infixa.",
                                    "Discuta limitações: legibilidade humana.",
                                    "Prepare argumentos para defesa em discussão."
                                  ],
                                  "verification": "Escreva um parágrafo explicativo citando fontes com pelo menos 3 vantagens.",
                                  "estimatedTime": "40 minutos",
                                  "materials": "Cópias digitais de Aho et al. e Santos & Langlois; Ferramenta de citação (Zotero).",
                                  "tips": "Use bullet points para brainstorm antes de redigir.",
                                  "learningObjective": "Articular vantagens com suporte acadêmico preciso.",
                                  "commonMistakes": "Citar incorretamente ou generalizar sem evidência."
                                }
                              ],
                              "practicalExample": "Converta 'a = (b + c) * d - e' para pós-fixa: 'b c + d * a = e -'. Analise semântica: empilhe b (int), c (int) -> + (int), * d (int) -> int, atribua a, subtraia e. Otimização: se b==e, elimine comuns subexpressões linearmente sem reparse.",
                              "finalVerifications": [
                                "Explicar sem pilha recursiva como pós-fixa evita backtracking em type-checking.",
                                "Identificar 4 simplificações específicas na análise semântica citando Aho et al.",
                                "Otimizar uma expressão pós-fixa demonstrando peephole em 2 passos.",
                                "Comparar tempo de análise: pós-fixa O(n) vs. AST O(n log n).",
                                "Referenciar corretamente Santos & Langlois em contexto de otimização.",
                                "Defender vantagens em um cenário de compilador real."
                              ],
                              "assessmentCriteria": [
                                "Precisão técnica: Correção das simplificações (40%)",
                                "Profundidade de análise: Detalhes sobre semântica e otimização (25%)",
                                "Uso de referências: Citações integradas de Aho et al. e Santos & Langlois (15%)",
                                "Clareza na explicação: Linguagem acessível e estruturada (10%)",
                                "Exemplos práticos: Demonstração concreta com conversões (10%)"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Álgebra abstrata e notação polonesa reversa em expressões.",
                                "Algoritmos: Estruturas de dados (pilhas) e análise de complexidade O(n).",
                                "Engenharia de Software: Otimização de código e geração de IR em pipelines CI/CD.",
                                "Lógica: Verificação formal de tipos semânticos."
                              ],
                              "realWorldApplication": "Em compiladores como GCC (usa formas semelhantes em otimizações RTL) e linguagens como Forth ou Joy, pós-fixa acelera JIT compilers em VMs como JVM para expressões dinâmicas, reduzindo latência em aplicações web e jogos."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.6.2.3.2"
                            ]
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.6.3",
                    "name": "Geração de Código Intermediário a partir de Análise Semântica",
                    "description": "Processo de construção de representações intermediárias durante ou após a análise semântica.",
                    "individualConcepts": [
                      {
                        "id": "10.1.6.3.1",
                        "name": "Representações Intermediárias em Compiladores",
                        "description": "Tipos de representações intermediárias geradas durante a análise semântica, como árvores de sintaxe abstrata (AST), código de três endereços e grafos de fluxo de controle, e suas características principais.",
                        "specificSkills": [
                          {
                            "id": "10.1.6.3.1.1",
                            "name": "Identificar tipos de representações intermediárias",
                            "description": "Diferenciar e exemplificar representações como AST, código de três endereços, quadruplos e grafos, explicando quando cada uma é apropriada no contexto da análise semântica.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender o Conceito de Representações Intermediárias em Compiladores",
                                  "subSteps": [
                                    "Defina representação intermediária como uma forma de código gerada após análise semântica e antes da geração de código objeto.",
                                    "Explique o propósito: facilitar otimizações, portabilidade e análise independente da linguagem fonte ou alvo.",
                                    "Classifique em representações em árvore (ex: AST), lineares (ex: três endereços) e gráficas (ex: grafos).",
                                    "Revise o pipeline do compilador: análise léxica/sintática/semântica → intermediária → otimização → código objeto.",
                                    "Identifique vantagens: abstração de hardware e simplificação de passes de compilação."
                                  ],
                                  "verification": "Escreva um parágrafo resumindo o conceito e liste 3 propósitos principais; compare com um amigo ou anote correções.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Livro 'Compilers: Principles, Techniques, and Tools' (Dragon Book) capítulo 8; vídeo Khan Academy sobre compiladores; slides de curso online (Coursera Compilers).",
                                  "tips": "Use diagramas do pipeline do compilador para visualizar o lugar das representações intermediárias.",
                                  "learningObjective": "Compreender o papel e as categorias das representações intermediárias no contexto da análise semântica.",
                                  "commonMistakes": "Confundir com código assembly final (intermediárias são mais abstratas); ignorar o foco em otimizações."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Explorar Abstract Syntax Tree (AST)",
                                  "subSteps": [
                                    "Descreva AST como árvore hierárquica representando estrutura sintática/semântica sem detalhes léxicos desnecessários.",
                                    "Exemplifique com código simples: 'a = b + c' → nó raiz '=', filhos 'a', '+', 'b', 'c'.",
                                    "Explique usos: análise semântica inicial, geração de código, walking para otimizações.",
                                    "Compare com parse tree: AST é mais compacto, ignora parênteses e regras de precedência.",
                                    "Pratique desenhando AST para expressões aritméticas e condicionais."
                                  ],
                                  "verification": "Desenhe AST para 3 expressões diferentes e verifique se captura hierarquia corretamente.",
                                  "estimatedTime": "50 minutos",
                                  "materials": "Ferramenta online como AST Explorer (astexplorer.net); exemplos do LLVM IR docs; papel e caneta para desenhos.",
                                  "tips": "Sempre rotule nós com tipos semânticos (ex: int, float) para diferenciar de parse tree.",
                                  "learningObjective": "Dominar estrutura, exemplo e aplicação de AST na análise semântica.",
                                  "commonMistakes": "Incluir tokens léxicos como espaços; confundir folhas com operadores."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar Representações Lineares: Código de Três Endereços e Quadruplos",
                                  "subSteps": [
                                    "Defina código de três endereços: instruções como 'x = y op z' ou 'x = op y' (máx 3 operandos).",
                                    "Exemplifique: 'a = b + 3*c' → t1 = 3*c; t2 = b + t1; a = t2.",
                                    "Descreva quadruplos: tuplas (op, arg1, arg2, result), mais compacto para otimizações.",
                                    "Compare: três endereços é legível; quadruplos facilitam análise de fluxo de dados.",
                                    "Discuta quando usar: após AST para linearização, ideal para otimizações locais."
                                  ],
                                  "verification": "Converta uma expressão AST simples em código de três endereços e quadruplos; cheque contagem de temporários.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Compilador online como Godbolt (godbolt.org) para ver IR; Dragon Book seção 8.5; planilha para quadruplos.",
                                  "tips": "Use temporários (t1, t2) consistentemente para evitar nomes conflitantes.",
                                  "learningObjective": "Diferenciar e gerar código de três endereços e quadruplos a partir de AST.",
                                  "commonMistakes": "Exceder 3 endereços por instrução; confundir ordem de quadruplos (op primeiro)."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Estudar Representações Gráficas e Comparar Todas",
                                  "subSteps": [
                                    "Defina grafos: Directed Acyclic Graphs (DAG) para expressões comuns ou Control Flow Graphs (CFG) para fluxo.",
                                    "Exemplifique DAG para 'a=b+c; d=b+c' compartilhando nó '+'.",
                                    "Explique usos: detecção de computações comuns, análise de dependências.",
                                    "Compare todas: AST (hierárquico, semântica); linear (sequencial, otimizações locais); grafos (relações, globais).",
                                    "Decida quando usar: AST início, linear para geração rápida, grafos para otimizações avançadas."
                                  ],
                                  "verification": "Crie tabela comparativa (prós/contras/uso) e aplique a um exemplo de código fonte.",
                                  "estimatedTime": "55 minutos",
                                  "materials": "Ferramenta Graphviz para visualizar grafos; exemplos LLVM CFG; tabela em Excel/Google Sheets.",
                                  "tips": "Desenhe grafos com setas claras para dependências para melhor compreensão.",
                                  "learningObjective": "Identificar grafos e sintetizar diferenças/contextos de uso de todas representações.",
                                  "commonMistakes": "Confundir DAG com CFG (DAG para expressões, CFG para blocos); ignorar compartilhamento em grafos."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Praticar Diferenciação e Aplicação Contextual",
                                  "subSteps": [
                                    "Analise cenários: análise semântica usa AST; geração intermediária lineariza para três endereços.",
                                    "Resolva exercícios: dado código fonte, escolha e justifique representação.",
                                    "Simule passes: AST → três endereços → otimizações em quadruplos → grafos para análise.",
                                    "Crie fluxograma de escolha: hierárquico? AST; linear? três addr; relacional? grafos.",
                                    "Teste com variações: loops (favorece CFG), expressões (DAG)."
                                  ],
                                  "verification": "Responda quiz com 5 perguntas sobre quando usar cada uma; acerte 90%+.",
                                  "estimatedTime": "40 minutos",
                                  "materials": "Exercícios de sites como LeetCode Compilers ou GeeksforGeeks; flashcards Anki para comparações.",
                                  "tips": "Associe a contextos: 'semântica profunda = AST/grafos; geração rápida = linear'.",
                                  "learningObjective": "Aplicar conhecimento para diferenciar e selecionar representações apropriadas.",
                                  "commonMistakes": "Generalizar demais (ex: sempre usar AST); ignorar trade-offs de performance/espaço."
                                }
                              ],
                              "practicalExample": "Dado código fonte 'int x = a + b * c; y = a + b * c;': 1. AST: árvore com sub-árvore compartilhada para '*'. 2. Três endereços: t1=c*b; t2=a+t1; x=t2; y=t2. 3. Quadruplos: ( *, b, c, t1 ), ( +, a, t1, x ), ( =, t2, _, y ). 4. DAG: nó único para 'a + b*c' compartilhado por x e y.",
                              "finalVerifications": [
                                "Liste e defina AST, três endereços, quadruplos e grafos corretamente.",
                                "Converta expressão simples em todas as 4 representações sem erros.",
                                "Explique com exemplo quando usar cada uma no pipeline semântico.",
                                "Identifique prós/contras de cada em tabela comparativa.",
                                "Resolva caso prático: escolha representação para otimização de loop comum.",
                                "Descreva como grafos detectam redundâncias não visíveis em lineares."
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição e exemplos (90%+ correto).",
                                "Capacidade de conversão entre representações (sem erros sintáticos).",
                                "Justificativa contextual clara e apropriada (baseada em análise semântica).",
                                "Uso correto de terminologia (ex: temporários, nós, arestas).",
                                "Profundidade em comparações (trade-offs de legibilidade vs. eficiência).",
                                "Criatividade em exemplos reais (além de aritmética básica)."
                              ],
                              "crossCurricularConnections": [
                                "Teoria dos Grafos: DAG/CFG para análise de dependências e caminhos.",
                                "Algoritmos: Walking em árvores para traversais pré/pos-ordem em AST.",
                                "Matemática Discreta: Representações lineares como notação polonesa.",
                                "Engenharia de Software: IR em ferramentas como LLVM para portabilidade.",
                                "Inteligência Artificial: Árvores de sintaxe em parsers NLP."
                              ],
                              "realWorldApplication": "Em compiladores como GCC/LLVM, AST é usado na frontend para checagem semântica; LLVM IR (similar a três endereços) permite otimizações cross-plataforma; grafos em passes como dead code elimination detectam redundâncias em apps reais como browsers (V8 JS) ou jogos (Unity shaders), reduzindo tempo de execução em 20-50%."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.6.3.1.2",
                            "name": "Descrever vantagens de representações intermediárias",
                            "description": "Explicar benefícios como portabilidade, facilitação de otimizações e independência da linguagem fonte e alvo, com exemplos de livros como Aho et al.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o Conceito Básico de Representações Intermediárias",
                                  "subSteps": [
                                    "Defina representações intermediárias como formas de código gerado após a análise semântica, antes da geração de código final.",
                                    "Identifique tipos comuns, como árvores de sintaxe abstrata (AST) estendida, código de três endereços ou grafos de fluxo de controle.",
                                    "Compare com código fonte (linguagem de alto nível) e código alvo (linguagem de máquina).",
                                    "Estude o papel no pipeline de compiladores: front-end, middle-end e back-end.",
                                    "Anote diferenças entre representações intermediárias e código assembly direto."
                                  ],
                                  "verification": "Crie um diagrama simples do pipeline de compilador destacando onde as representações intermediárias se encaixam.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Livro 'Compilers: Principles, Techniques, and Tools' de Aho et al. (capítulo sobre análise semântica)",
                                    "Diagrama de pipeline de compilador online (ex: Wikipedia)"
                                  ],
                                  "tips": [
                                    "Use analogias como 'idioma neutro' para tradução entre linguagens.",
                                    "Desenhe fluxogramas para visualizar melhor."
                                  ],
                                  "learningObjective": "Entender o posicionamento e propósito das representações intermediárias no processo de compilação.",
                                  "commonMistakes": [
                                    "Confundir com código objeto final.",
                                    "Ignorar a distinção entre front-end e back-end."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Explorar a Vantagem de Portabilidade",
                                  "subSteps": [
                                    "Explique portabilidade como a capacidade de gerar código para múltiplas arquiteturas a partir da mesma representação intermediária.",
                                    "Discuta como o front-end processa a linguagem fonte uma vez, produzindo IR portátil.",
                                    "Exemplo: Um compilador que compila C para x86 ou ARM via IR comum.",
                                    "Compare com compiladores sem IR: necessidade de back-ends separados por target.",
                                    "Liste cenários onde portabilidade economiza desenvolvimento (multi-plataforma)."
                                  ],
                                  "verification": "Escreva um parágrafo explicando como IR permite portabilidade, com um exemplo hipotético.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Exemplos de LLVM IR (documentação LLVM.org)",
                                    "Capítulo de Aho et al. sobre geração de código intermediário"
                                  ],
                                  "tips": [
                                    "Pense em containers Docker como IR para apps: portável entre hosts.",
                                    "Pesquise 'LLVM portability' para casos reais."
                                  ],
                                  "learningObjective": "Descrever como IR promove portabilidade entre diferentes alvos de máquina.",
                                  "commonMistakes": [
                                    "Confundir portabilidade de IR com portabilidade de código fonte.",
                                    "Subestimar o custo de múltiplos back-ends sem IR."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar Facilitação de Otimizações",
                                  "subSteps": [
                                    "Descreva como IR permite otimizações independentes da linguagem fonte (ex: eliminação de código morto).",
                                    "Liste otimizações comuns no middle-end: inlining, loop unrolling, constant propagation.",
                                    "Explique independência: otimizações em IR aplicam-se a qualquer linguagem fonte.",
                                    "Compare eficiência: otimizações em IR vs. diretamente em código fonte ou assembly.",
                                    "Estude exemplo de Aho et al.: otimização em código de três endereços."
                                  ],
                                  "verification": "Identifique e descreva 3 otimizações que funcionam melhor em IR, justificando por quê.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Ferramenta online de compilador como Godbolt (compiler explorer)",
                                    "Seção de otimizações em 'Dragon Book' de Aho et al."
                                  ],
                                  "tips": [
                                    "Use Compiler Explorer para ver IR gerado e otimizado de C/Python.",
                                    "Foquem em otimizações 'language-agnostic'."
                                  ],
                                  "learningObjective": "Explicar como IR facilita otimizações avançadas no compilador.",
                                  "commonMistakes": [
                                    "Achar que otimizações só ocorrem em código assembly.",
                                    "Ignorar que IR permite passes múltiplos de otimização."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Discutir Independência de Linguagem Fonte e Alvo e Exemplos",
                                  "subSteps": [
                                    "Defina independência: front-end gera IR da fonte, back-end consome IR para alvo, sem dependência direta.",
                                    "Exemplo: GCC suporta múltiplas linguagens (C, Fortran) via IR comum (RTL/GIMPLE).",
                                    "Referencie Aho et al.: vantagens em compiladores retargetable.",
                                    "Liste benefícios: reutilização de código, equipes separadas para front/back-end.",
                                    "Crie um exemplo simples: pseudocódigo fonte -> IR -> múltiplos alvos."
                                  ],
                                  "verification": "Resuma as 3 principais vantagens em uma tabela comparativa com/s em IR.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Documentação GCC internals (GIMPLE/RTL)",
                                    "Exemplos de código em Aho et al., capítulo 9"
                                  ],
                                  "tips": [
                                    "Use LLVM como caso de estudo moderno: suporta 100+ linguagens e targets.",
                                    "Crie tabelas para comparações visuais."
                                  ],
                                  "learningObjective": "Articular independência de fonte/alvo e citar exemplos literários.",
                                  "commonMistakes": [
                                    "Confundir IR com bytecode JVM (que é mais específico).",
                                    "Omitir exemplos concretos de livros."
                                  ]
                                }
                              ],
                              "practicalExample": "No compilador LLVM, usado pelo Clang (C/C++) e Swift, o LLVM IR é gerado após análise semântica. Isso permite otimizar código C para ARM (móveis) ou x86 (PCs) com o mesmo IR, exemplificando portabilidade e otimizações independentes, como visto em projetos como Rust compiler (rustc).",
                              "finalVerifications": [
                                "Liste e explique pelo menos 3 vantagens principais de IR.",
                                "Forneça um exemplo de otimização facilitada por IR.",
                                "Descreva como IR promove portabilidade entre targets.",
                                "Cite uma referência de Aho et al. relacionada.",
                                "Compare um compilador com e sem IR em termos de desenvolvimento."
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição de vantagens (portabilidade, otimizações, independência).",
                                "Uso de exemplos concretos e referências bibliográficas.",
                                "Clareza na explicação de mecanismos (ex: middle-end passes).",
                                "Capacidade de relacionar a cenários reais de compiladores.",
                                "Ausência de confusões entre IR, código fonte ou assembly."
                              ],
                              "crossCurricularConnections": [
                                "Engenharia de Software: Modularidade em ferramentas de build (ex: CMake com LLVM).",
                                "Arquitetura de Computadores: Otimizações dependentes de ISA via back-end.",
                                "Matemática: Grafos e análise de fluxo para representações IR.",
                                "Linguagens de Programação: Design de DSLs com IR compartilhado."
                              ],
                              "realWorldApplication": "Em empresas como Apple e Google, compiladores como LLVM usam IR para desenvolver apps cross-platform (iOS/Android), reduzindo tempo de engenharia em 50% ao reutilizar otimizações e suportar novos chips (ex: Apple Silicon) sem reescrever front-ends."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.6.3.1.3",
                            "name": "Construir uma AST simples a partir de código fonte",
                            "description": "Dado um trecho de código fonte válido sintaticamente, construir manualmente uma árvore de sintaxe abstrata incorporando informações semânticas como tipos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Tokenizar o Código Fonte",
                                  "subSteps": [
                                    "Leia o código fonte linha por linha e identifique os tokens básicos (palavras-chave, identificadores, operadores, literais, pontuação).",
                                    "Classifique cada token em categorias: keyword (ex: int), identifier (ex: a), operator (ex: +), number (ex: 5), etc.",
                                    "Crie uma lista sequencial de tokens, ignorando espaços e comentários.",
                                    "Anote posições ou spans de cada token para referência futura.",
                                    "Valide que não há erros léxicos óbvios, como caracteres inválidos."
                                  ],
                                  "verification": "A lista de tokens cobre todo o código fonte sem sobras ou duplicatas, e cada token está corretamente categorizado.",
                                  "estimatedTime": "20 minutes",
                                  "materials": [
                                    "Código fonte impresso ou digital",
                                    "Papel e caneta para listar tokens",
                                    "Tabela de referência léxica da linguagem"
                                  ],
                                  "tips": "Comece pela esquerda para a direita; use cores diferentes para tipos de tokens para visualização.",
                                  "learningObjective": "Entender a análise léxica como base para parsing, identificando unidades mínimas de código.",
                                  "commonMistakes": [
                                    "Confundir identificadores com keywords",
                                    "Ignorar pontuação como ; ou {}",
                                    "Não anotar literais numéricos corretamente"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Construir a Árvore Sintática Concreta (CST) Inicial",
                                  "subSteps": [
                                    "Use a gramática da linguagem para agrupar tokens em nós hierárquicos: statements, expressions, declarations.",
                                    "Identifique a estrutura principal (ex: função, bloco de código, declarações variáveis).",
                                    "Crie nós folha para tokens terminais e nós internos para regras de produção não-terminais.",
                                    "Conecte os nós pai-filho seguindo precedência de operadores e associatividade.",
                                    "Desenhe a árvore em papel ou diagrama, garantindo balanceamento correto de chaves e parênteses."
                                  ],
                                  "verification": "A CST parseia todo o código sem ambiguidades e reflete a gramática sintática exata.",
                                  "estimatedTime": "30 minutes",
                                  "materials": [
                                    "Lista de tokens do Step 1",
                                    "Papel milimetrado ou ferramenta de diagrama como Draw.io",
                                    "Gramática BNF da linguagem simples"
                                  ],
                                  "tips": "Aplique regras de precedência: * > + > =; desenhe de cima para baixo para clareza.",
                                  "learningObjective": "Dominar análise sintática recursiva descendente ou ascendente para formar estruturas hierárquicas.",
                                  "commonMistakes": [
                                    "Erros de precedência em expressões mistas",
                                    "Nós mal conectados levando a árvores desbalanceadas",
                                    "Ignorar terminais como ponto-e-vírgula"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Incorporar Análise Semântica e Inferir Tipos",
                                  "subSteps": [
                                    "Percorra a CST bottom-up para inferir tipos de expressões (ex: 2 + 3 é int).",
                                    "Anotar tipos em declarações (ex: int a recebe tipo int).",
                                    "Propague tipos para nós pais, verificando compatibilidade (ex: promoção de tipo ou erro).",
                                    "Adicione atributos semânticos como escopo ou referências cruzadas a nós relevantes.",
                                    "Marque nós com erros semânticos se houver incompatibilidades de tipo."
                                  ],
                                  "verification": "Todos os nós de expressões e declarações têm tipos anotados corretamente sem conflitos.",
                                  "estimatedTime": "25 minutes",
                                  "materials": [
                                    "CST desenhada",
                                    "Tabela de tipos da linguagem (int, float, etc.)",
                                    "Papel para anotações"
                                  ],
                                  "tips": "Use tabelas de símbolos temporárias para rastrear declarações; verifique tipos bidirecionalmente.",
                                  "learningObjective": "Aplicar análise semântica estática para enriquecer a árvore com contexto além da sintaxe.",
                                  "commonMistakes": [
                                    "Inferir tipos errados em operações mistas",
                                    "Não propagar tipos para atribuições",
                                    "Esquecer verificação de compatibilidade"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Abstrair e Finalizar a AST",
                                  "subSteps": [
                                    "Remova nós concretos desnecessários (ex: tokens léxicos, parênteses implícitos).",
                                    "Compacte sub-árvores semelhantes em nós compostos (ex: BinaryOp + com filhos).",
                                    "Incorpore anotações semânticas diretamente nos nós AST (ex: nó VarDecl com type: int).",
                                    "Verifique completude: raiz conecta todos os statements, sem folhas soltas.",
                                    "Desenhe a AST final limpa e valide contra o código original."
                                  ],
                                  "verification": "A AST é compacta, hierarquicamente correta, com todas semânticas incorporadas e sem elementos sintáticos extras.",
                                  "estimatedTime": "20 minutes",
                                  "materials": [
                                    "CST anotada do Step 3",
                                    "Ferramenta de diagrama para AST final",
                                    "Código fonte original para comparação"
                                  ],
                                  "tips": "Foque em abstração: priorize significado sobre forma textual; use labels nos nós para tipos.",
                                  "learningObjective": "Transformar CST em AST otimizada para fases posteriores de compilação.",
                                  "commonMistakes": [
                                    "Manter nós concretos desnecessários",
                                    "Perder conexões durante abstração",
                                    "Não incorporar tipos nos nós finais"
                                  ]
                                }
                              ],
                              "practicalExample": "Para o código fonte em mini-C: 'int main() { int x = 5 + 3; return x; }', tokenizar em [int, main, (, ), {, int, x, =, 5, +, 3, ;, return, x, ;, }]; construir CST com raiz FunctionDecl(main), nó Declaration(int x = BinaryOp(+, IntLit(5), IntLit(3))), anotar tipos (todos int), e AST final com nós: FuncDecl(type:int, body=[DeclVar(x:int, init=BinOp(+,int,5,3)), Return(x:int)]).",
                              "finalVerifications": [
                                "A raiz da AST representa corretamente a unidade de compilação (ex: função main).",
                                "Todos os nós de variáveis têm tipos inferidos e anotados.",
                                "Expressões binárias mostram operador, tipos dos operandos e tipo resultante.",
                                "Não há nós folha com tokens brutos; tudo é abstrato.",
                                "A árvore reconstrói semanticamente o código original sem ambiguidades.",
                                "Validações semânticas (ex: tipos compatíveis) estão marcadas ou resolvidas."
                              ],
                              "assessmentCriteria": [
                                "Precisão da hierarquia: conexões pai-filho corretas (80% peso).",
                                "Incorporação semântica: tipos e atributos corretos em todos nós relevantes.",
                                "Abstração adequada: eliminação de elementos concretos desnecessários.",
                                "Completude: cobre 100% do código fonte sem omissões.",
                                "Clareza visual: diagrama legível com labels informativos.",
                                "Ausência de erros: nenhum conflito sintático ou semântico na AST."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Estruturas de árvores e grafos direcionados acíclicos (DAGs).",
                                "Linguística: Análise sintática e semântica de linguagens formais.",
                                "Engenharia de Software: Modelagem de dados e representações intermediárias.",
                                "Algoritmos: Travessias de árvores (pré/pós-ordem) para análise."
                              ],
                              "realWorldApplication": "Em compiladores como GCC ou Clang, transpilers como Babel (JS para ES5), linters (ESLint para detecção de erros), e ferramentas de refatoração em IDEs como VS Code, onde ASTs permitem análises estáticas, otimizações e transformações de código sem executar o programa."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.6.3.2",
                        "name": "Ações Semânticas para Geração de Código",
                        "description": "Uso de ações semânticas associadas a regras de produção na análise sintática para construir código intermediário durante a análise semântica.",
                        "specificSkills": [
                          {
                            "id": "10.1.6.3.2.1",
                            "name": "Definir ações semânticas em gramáticas",
                            "description": "Especificar ações semânticas em uma gramática YACC-like que gerem código intermediário, como atribuições em três endereços, durante a redução de regras.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Fundamentos de Gramáticas YACC-like e Ações Semânticas",
                                  "subSteps": [
                                    "Estude a sintaxe básica de gramáticas YACC/Bison, focando em regras de produção e blocos de ações.",
                                    "Identifique onde as ações semânticas são inseridas: no final de cada regra de redução.",
                                    "Revise os atributos semânticos ($$, $1, $2) para acessar valores de símbolos.",
                                    "Pratique lendo exemplos simples de gramáticas com ações que imprimem valores.",
                                    "Entenda o ciclo de parsing bottom-up (shift-reduce) e quando as reduções ocorrem."
                                  ],
                                  "verification": "Explique verbalmente ou por escrito o papel das ações durante uma redução específica.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Documentação do Bison/YACC, tutorial online como 'Flex & Bison' book excerpts.",
                                  "tips": "Use diagramas de árvores de parsing para visualizar reduções.",
                                  "learningObjective": "Compreender a integração de ações semânticas no processo de parsing.",
                                  "commonMistakes": "Confundir ações com declarações de tokens ou regras léxicas."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Estudar Código Intermediário de Três Endereços (TAC)",
                                  "subSteps": [
                                    "Defina TAC: instruções como 't1 = id1 + id2' com temporários limitados.",
                                    "Aprenda operadores TAC: atribuições, binárias (+, -, *, /), unárias, condicionais.",
                                    "Estude alocação de registradores temporários (t1, t2) e endereçamento.",
                                    "Analise exemplos de TAC gerados a partir de expressões aritméticas simples.",
                                    "Pratique convertendo uma expressão como 'a = b + c * d' em TAC manualmente."
                                  ],
                                  "verification": "Gere TAC manual para 3 expressões diferentes e compare com referências.",
                                  "estimatedTime": "1 hora",
                                  "materials": "Livro 'Compilers: Principles, Techniques, and Tools' (Dragon Book) capítulo 6, exemplos online de TAC.",
                                  "tips": "Comece com expressões binárias simples antes de precedência.",
                                  "learningObjective": "Dominar a representação de código intermediário em três endereços.",
                                  "commonMistakes": "Esquecer de lidar com precedência de operadores na geração sequencial."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Definir Ações Semânticas para Regras de Produção Simples",
                                  "subSteps": [
                                    "Selecione uma regra como expr : expr '+' term { $$ = novo_temp(); emit('$$ = $1 + $3'); }",
                                    "Implemente funções auxiliares: novo_temp() para alocar temporários, emit() para output TAC.",
                                    "Adapte para múltiplos operadores: '+', '-', '*', '/' com precedência.",
                                    "Teste a ação em uma gramática mínima com Flex para lexer.",
                                    "Compile e execute para gerar TAC de uma entrada simples como '1+2*3'."
                                  ],
                                  "verification": "Execute a gramática e verifique se o TAC gerado é correto para inputs variados.",
                                  "estimatedTime": "1 hora 30 minutos",
                                  "materials": "Editor de texto, Flex/Bison instalados, terminal para compilar.",
                                  "tips": "Use printf na emit() inicialmente para debug.",
                                  "learningObjective": "Especificar ações que geram TAC durante reduções de regras.",
                                  "commonMistakes": "Não atualizar $$ corretamente, perdendo o valor semântico para regras pai."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Expandir e Integrar Ações em Gramática Completa com Verificação",
                                  "subSteps": [
                                    "Adicione regras para declarações e atribuições: stmt : ID '=' expr { emit('$1 = $$'); }",
                                    "Integre controle de fluxo básico (if, while) com labels para TAC.",
                                    "Implemente tabela de símbolos para IDs e tipos.",
                                    "Gere TAC para um programa pequeno e compare com geração manual.",
                                    "Debug erros comuns como vazamentos de temporários ou labels errados."
                                  ],
                                  "verification": "Parse um programa de 10 linhas e valide o TAC contra um validador manual.",
                                  "estimatedTime": "2 horas",
                                  "materials": "Gramática Bison expandida, debugger como gdb para execução.",
                                  "tips": "Mantenha contadores globais para temps e labels.",
                                  "learningObjective": "Construir ações semânticas escaláveis para gramáticas reais.",
                                  "commonMistakes": "Gerar TAC sem considerar escopo ou tipos de variáveis."
                                }
                              ],
                              "practicalExample": "Para a regra 'expr : expr '+' term', defina: { char *t = newtemp(); emit(t, '=', $1, '+', $3); $$ = t; } Isso gera 't1 = expr1 + term1' durante redução, propagando o temporário para cima.",
                              "finalVerifications": [
                                "O TAC gerado usa apenas temporários sequenciais sem reutilização inválida.",
                                "Precedência de operadores é respeitada no TAC final.",
                                "Atribuições finais usam variáveis reais, não temporários.",
                                "Nenhum erro de parsing ou semântico em inputs válidos.",
                                "Labels para controle de fluxo são corretos e balanceados.",
                                "Tabela de símbolos é populada corretamente."
                              ],
                              "assessmentCriteria": [
                                "Precisão das ações semânticas em gerar TAC válido.",
                                "Eficiência na alocação de temporários (sem desperdício).",
                                "Correta propagação de atributos semânticos ($$).",
                                "Tratamento de precedência e associatividade.",
                                "Robustez contra casos edge (expressões vazias, unárias).",
                                "Clareza e comentação no código das ações."
                              ],
                              "crossCurricularConnections": [
                                "Teoria da Computação: Autômatos e linguagens formais.",
                                "Programação: Gerenciamento de memória e ponteiros em C.",
                                "Engenharia de Software: Parsing em ferramentas como ANTLR ou PEG.js.",
                                "Matemática: Árvores de derivação e expressões regulares."
                              ],
                              "realWorldApplication": "Em compiladores como GCC ou Clang, ações semânticas em YACC/Bison geram IR (LLVM IR similar a TAC) para otimização e geração de código máquina, essencial em desenvolvimento de linguagens como Rust ou custom DSLs em fintech."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.6.3.2.2",
                            "name": "Implementar geração de código em analisadores sintáticos",
                            "description": "Modificar um analisador bottom-up ou top-down para incluir geração de código intermediário via ações semânticas, testando com expressões aritméticas.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar o analisador sintático base",
                                  "subSteps": [
                                    "Escolha um analisador sintático existente (bottom-up como LR ou top-down como LL) para expressões aritméticas simples.",
                                    "Compile e execute o analisador para verificar que ele parseia corretamente expressões como '2+3*4'.",
                                    "Identifique as regras de produção gramaticais relevantes (ex: E -> E + T | T).",
                                    "Documente a árvore de análise sintática gerada para uma entrada de teste.",
                                    "Instale ferramentas de depuração como gdb ou um debugger para parsers."
                                  ],
                                  "verification": "O analisador parseia corretamente expressões aritméticas sem erros semânticos e gera árvore de sintaxe.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Código fonte do parser (ex: Yacc/Bison ou ANTLR)",
                                    "Compilador C/C++ ou Java",
                                    "Editor de código como VS Code"
                                  ],
                                  "tips": "Comece com uma gramática simples sem precedência para evitar ambiguidades iniciais.",
                                  "learningObjective": "Compreender a estrutura de um parser e suas regras de produção para modificações futuras.",
                                  "commonMistakes": [
                                    "Ignorar conflitos shift-reduce em parsers bottom-up",
                                    "Não testar parsing básico antes de modificar"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar e planejar pontos de inserção de ações semânticas",
                                  "subSteps": [
                                    "Analise cada regra de produção e decida onde inserir ações semânticas (ex: na redução de E -> E + T).",
                                    "Defina o formato de código intermediário (ex: três endereços: t1 = id1 + id2).",
                                    "Crie um esquema de atributos para não-terminais (ex: E.code para código gerado).",
                                    "Esboce em papel como herdar/sintetizar atributos para geração de código.",
                                    "Defina um gerador de labels temporários (ex: t1, t2)."
                                  ],
                                  "verification": "Diagrama ou pseudocódigo mostra ações semânticas mapeadas para cada redução relevante.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Papel e caneta ou ferramenta de diagramação como Draw.io",
                                    "Documentação de Yacc/Bison para ações semânticas"
                                  ],
                                  "tips": "Use ações no final das regras para sintetizar código bottom-up.",
                                  "learningObjective": "Mapear análise sintática a ações semânticas para geração de código intermediário.",
                                  "commonMistakes": [
                                    "Colocar ações no lugar errado (shift vs reduce)",
                                    "Não considerar ordem de avaliação em expressões"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar ações semânticas para geração de código",
                                  "subSteps": [
                                    "Modifique o arquivo .y ou grammar file inserindo {} com código C/Java nas regras.",
                                    "Exemplo: $$ = $1.code || $3.code || \"tX = \" + $1 + \" + \" + $3; onde X é novo temp.",
                                    "Implemente funções auxiliares para concatenação de código e alocação de temps.",
                                    "Compile o parser modificado sem erros.",
                                    "Adicione prints ou logs para depurar código gerado durante parsing."
                                  ],
                                  "verification": "Parser compila e, ao parsear '2+3', gera código como 't1=2+3' sem crashes.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Yacc/Bison ou equivalente",
                                    "Compilador",
                                    "Exemplos de gramáticas com semântica"
                                  ],
                                  "tips": "Use strings ou listas para acumular código em atributos.",
                                  "learningObjective": "Integrar geração de código diretamente nas ações de redução sintática.",
                                  "commonMistakes": [
                                    "Erros de sintaxe no código dentro de {}",
                                    "Não inicializar atributos"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Testar e depurar com expressões aritméticas",
                                  "subSteps": [
                                    "Crie casos de teste: soma simples, multiplicação, precedência (2+3*4), parênteses ((2+3)*4).",
                                    "Execute o parser e compare código intermediário gerado com esperado manualmente.",
                                    "Use debugger para rastrear atributos durante parsing.",
                                    "Corrija bugs como ordem errada de operações ou temps duplicados.",
                                    "Meça performance com expressões maiores."
                                  ],
                                  "verification": "Todos testes produzem código intermediário correto e equivalente semanticamente.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Suite de testes em script shell ou JUnit",
                                    "Calculadora para validar saídas esperadas"
                                  ],
                                  "tips": "Teste incremental: comece com binárias, adicione unárias depois.",
                                  "learningObjective": "Validar corretude da geração de código através de testes abrangentes.",
                                  "commonMistakes": [
                                    "Não testar precedência/associatividade",
                                    "Ignorar vazamento de temps"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Refatorar e otimizar o analisador com código gerado",
                                  "subSteps": [
                                    "Remova prints de debug e adicione saída para arquivo de código intermediário.",
                                    "Otimize concatenação de strings usando buffers eficientes.",
                                    "Adicione suporte a variáveis e constantes reais.",
                                    "Documente o código modificado com comentários.",
                                    "Versione o código no Git."
                                  ],
                                  "verification": "Parser gera código limpo em arquivo, pronto para próxima fase de compilador.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Git",
                                    "Editor com suporte a linting"
                                  ],
                                  "tips": "Considere usar árvores de sintaxe em vez de strings para otimizações futuras.",
                                  "learningObjective": "Produzir um módulo de parser robusto e documentado para compiladores.",
                                  "commonMistakes": [
                                    "Código hardcoded para testes",
                                    "Falta de modularidade"
                                  ]
                                }
                              ],
                              "practicalExample": "Modifique um parser Yacc para gramática de expressões aritméticas: ao parsear ' (2 + 3) * 4 ', gere código três endereços: t1 = 2 + 3; result = t1 * 4; e imprima ou salve em 'output.txt'.",
                              "finalVerifications": [
                                "Parser compila sem warnings ou erros.",
                                "Gera código intermediário correto para 10+ expressões variadas.",
                                "Código gerado preserva precedência e associatividade.",
                                "Não há vazamentos de memória ou temps infinitos.",
                                "Saída é legível e no formato três endereços.",
                                "Testes automatizados passam 100%."
                              ],
                              "assessmentCriteria": [
                                "Precisão semântica: código gerado computa valor correto.",
                                "Eficiência: tempo de parsing < 1s para expressões médias.",
                                "Robustez: lida com erros de sintaxe graciosamente.",
                                "Clareza do código: bem comentado e modular.",
                                "Cobertura de testes: >90% das regras com casos.",
                                "Conformidade com gramática: sem ambiguidades resolvidas errado."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria de linguagens formais e autômatos.",
                                "Engenharia de Software: Design de DSLs e parsing em ferramentas como SQL.",
                                "Algoritmos: Otimização de código intermediário.",
                                "Sistemas Operacionais: Integração com assemblers.",
                                "Inteligência Artificial: Parsing em PLN para chatbots."
                              ],
                              "realWorldApplication": "Em compiladores como GCC ou Clang, ações semânticas geram código intermediário durante parsing, permitindo otimizações precoces; usado em IDEs para análise em tempo real e em ferramentas como Terraform para parsing de configs."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.6.3.2.3",
                            "name": "Gerenciar tabelas de símbolos na geração",
                            "description": "Integrar consultas e atualizações em tabelas de símbolos durante ações semânticas para alocação de temporários e verificação de tipos no código intermediário.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender e Inicializar Tabelas de Símbolos para Geração de Código",
                                  "subSteps": [
                                    "Estude a estrutura de uma tabela de símbolos típica (ex: hash table com campos como nome, tipo, escopo, endereço).",
                                    "Defina entradas para variáveis, temporários e constantes relevantes à geração de código intermediário.",
                                    "Implemente funções básicas de inicialização e limpeza da tabela para diferentes escopos.",
                                    "Crie uma pilha de tabelas para gerenciar escopos aninhados.",
                                    "Teste a inicialização com um programa simples de entrada."
                                  ],
                                  "verification": "Verifique se a tabela inicia vazia e popula corretamente com símbolos de um programa de teste sem erros de escopo.",
                                  "estimatedTime": "2 horas",
                                  "materials": "Documentação de compiladores (ex: Dragon Book), editor de código, debugger.",
                                  "tips": "Use hash tables para eficiência em buscas; comece com escopos globais.",
                                  "learningObjective": "Compreender o papel das tabelas de símbolos na ponte entre análise semântica e geração de código.",
                                  "commonMistakes": "Ignorar escopos aninhados, levando a conflitos de nomes."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Integrar Consultas na Tabela durante Ações Semânticas",
                                  "subSteps": [
                                    "Implemente função de lookup por nome e escopo na tabela.",
                                    "Durante a árvore sintática, consulte a tabela para recuperar tipos e endereços de identificadores.",
                                    "Registre temporários alocados dinamicamente em consultas para expressões.",
                                    "Trate casos de símbolo não encontrado (ex: erro semântico).",
                                    "Otimize consultas para performance em árvores grandes."
                                  ],
                                  "verification": "Execute análise semântica em um programa com variáveis; confirme que consultas retornam dados corretos via logs.",
                                  "estimatedTime": "3 horas",
                                  "materials": "Parser gerado (ex: Yacc/Bison), exemplos de árvores sintáticas.",
                                  "tips": "Cache resultados de consultas frequentes para acelerar a geração.",
                                  "learningObjective": "Dominar consultas eficientes para suportar verificações em tempo real.",
                                  "commonMistakes": "Busca em escopo errado, causando uso de variável shadowed."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Gerenciar Atualizações e Alocação de Temporários",
                                  "subSteps": [
                                    "Crie função insert/update para adicionar novos símbolos com tipo, endereço e escopo.",
                                    "Implemente alocação sequencial de registradores/temporários livres via tabela.",
                                    "Atualize entradas durante reduções sintáticas (ex: atribuições, expressões aritméticas).",
                                    "Libere temporários ao final de escopos para reutilização.",
                                    "Valide unicidade de nomes e alocações."
                                  ],
                                  "verification": "Gere código intermediário para expressões complexas; cheque se temporários são alocados sem sobreposição.",
                                  "estimatedTime": "4 horas",
                                  "materials": "Código intermediário target (ex: três endereços), simulador de registradores.",
                                  "tips": "Mantenha contador global de temporários para alocação linear simples.",
                                  "learningObjective": "Habilitar gerenciamento dinâmico de recursos durante geração.",
                                  "commonMistakes": "Não atualizar tipos após inferência, levando a código inválido."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Implementar Verificação de Tipos Usando a Tabela",
                                  "subSteps": [
                                    "Consulte tipos de operandos na tabela antes de gerar instruções.",
                                    "Aplique regras de compatibilidade de tipos (ex: promoção implícita).",
                                    "Gere código com casts se necessário e atualize tabela com novo tipo.",
                                    "Reporte erros de tipo incompatível e pare geração.",
                                    "Teste com operações mistas (int + float)."
                                  ],
                                  "verification": "Analise programa com erros de tipo; confirme detecção e código correto para casos válidos.",
                                  "estimatedTime": "3 horas",
                                  "materials": "Sistema de tipos definido, testes unitários para verificador.",
                                  "tips": "Use enums para tipos para facilitar comparações.",
                                  "learningObjective": "Garantir corretude semântica via tabela integrada.",
                                  "commonMistakes": "Ignorar promoção de tipos, gerando código assembly inválido."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Integrar, Testar e Otimizar o Gerenciamento Completo",
                                  "subSteps": [
                                    "Conecte todas as ações semânticas à tabela em um compilador mini.",
                                    "Execute testes end-to-end com programas variados (loops, funções).",
                                    "Meça performance de buscas/inserções e otimize se > O(1).",
                                    "Depure vazamentos de memória ou duplicatas via profiler.",
                                    "Documente API da tabela para reutilização."
                                  ],
                                  "verification": "Compile programa completo; valide código intermediário contra esperado manualmente.",
                                  "estimatedTime": "4 horas",
                                  "materials": "Compilador base, suite de testes, profiler (ex: Valgrind).",
                                  "tips": "Use asserts em verificações críticas durante desenvolvimento.",
                                  "learningObjective": "Construir sistema robusto e integrado para geração de código.",
                                  "commonMistakes": "Não limpar tabelas de escopo, causando memory leaks."
                                }
                              ],
                              "practicalExample": "Em um compilador para mini-linguagem, para 'a = b + c;' (b:int=5, c:float=3.14): 1) Lookup b/c → tipos int/float; 2) Alocar t1 temporário; 3) Verificar/promover b a float; 4) Gerar 't1 = b + c'; 5) Update tabela com a:float=t1.",
                              "finalVerifications": [
                                "Tabela populada corretamente com todos símbolos e temporários sem duplicatas.",
                                "Todas consultas e atualizações sem falhas em programa completo.",
                                "Tipos verificados corretamente em 100% das operações.",
                                "Temporários alocados e liberados eficientemente.",
                                "Código intermediário gerado matches análise semântica.",
                                "Sem vazamentos de memória ou erros de escopo."
                              ],
                              "assessmentCriteria": [
                                "Precisão na alocação de temporários (sem sobreposições).",
                                "Corretude de verificações de tipos (detecção de erros).",
                                "Eficiência das operações na tabela (tempo médio O(1)).",
                                "Robustez em escopos aninhados e programas complexos.",
                                "Clareza e modularidade do código implementado.",
                                "Cobertura de testes >80% para ações semânticas."
                              ],
                              "crossCurricularConnections": [
                                "Estruturas de Dados: Uso de hash tables e pilhas para escopos.",
                                "Bancos de Dados: Consultas e transações semelhantes a SQL.",
                                "Análise de Algoritmos: Otimização de lookups em grandes árvores.",
                                "Engenharia de Software: Design de APIs modulares para compiladores."
                              ],
                              "realWorldApplication": "Em compiladores como GCC ou LLVM, tabelas de símbolos gerenciam alocação de registradores em otimizações e verificam tipos em backends, essencial para gerar código nativo eficiente de linguagens como C++ ou Rust."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.6.3.3",
                        "name": "Processo de Construção Pós-Análise Semântica",
                        "description": "Geração de código intermediário após a conclusão da análise semântica completa, utilizando árvores decoradas ou tabelas anotadas.",
                        "specificSkills": [
                          {
                            "id": "10.1.6.3.3.1",
                            "name": "Percorrer árvores semânticas para gerar código",
                            "description": "Implementar um percorridor pós-ordem em uma AST decorada para emitir instruções de código intermediário, como em traversais para código de três endereços.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender Fundamentos de AST Decorada e Percorrimento Pós-Ordem",
                                  "subSteps": [
                                    "Estude a estrutura de uma Abstract Syntax Tree (AST) e como ela é decorada com informações semânticas como tipos, escopos e temporários.",
                                    "Revise o algoritmo de percorrimento pós-ordem: visitar filhos direitos e esquerdos antes do nó raiz.",
                                    "Analise exemplos de AST para expressões aritméticas simples, identificando a ordem de visita pós-ordem.",
                                    "Desenhe manualmente o percorrimento pós-ordem para uma AST de exemplo com operadores binários.",
                                    "Compare pós-ordem com pré e in-ordem para reforçar a importância na geração de código bottom-up."
                                  ],
                                  "verification": "Crie um diagrama de AST e liste a ordem de visita pós-ordem corretamente, sem erros.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Documentação de compiladores (ex: Dragon Book), editor de diagramas (Draw.io), exemplos de AST em Python/Java.",
                                  "tips": "Use cores diferentes para nós folha e internos para visualizar melhor a ordem.",
                                  "learningObjective": "Compreender como a decoração semântica na AST suporta geração de código e o papel do pós-ordem.",
                                  "commonMistakes": "Confundir ordem pós-ordem com in-ordem; ignorar decoração semântica como temporários alocados."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Definir Estruturas de Dados para AST e Código Intermediário",
                                  "subSteps": [
                                    "Defina classes ou structs para nós da AST (ex: Node, BinOpNode) com campos decorados (type, temp, scope).",
                                    "Crie uma representação para código de três endereços (TAC): instruções como 't1 = id + id2'.",
                                    "Implemente uma lista ou vetor para coletar instruções TAC geradas durante o percorrimento.",
                                    "Adicione métodos getters para acessar filhos e atributos decorados nos nós.",
                                    "Teste a criação de uma AST simples para 'a = b + c * d' com decoração básica."
                                  ],
                                  "verification": "Construa e imprima uma AST decorada válida para uma expressão, confirmando atributos semânticos.",
                                  "estimatedTime": "1 hora",
                                  "materials": "IDE (VS Code com Python/Java), referências de TAC (Three-Address Code).",
                                  "tips": "Use herança para tipos de nós (ExprNode, StmtNode) para facilitar extensibilidade.",
                                  "learningObjective": "Modelar AST decorada e TAC de forma que suporte percorrimento eficiente.",
                                  "commonMistakes": "Esquecer de inicializar temporários únicos; estruturas rígidas que não suportam polimorfismo."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar o Percorridor Pós-Ordem Recursivo",
                                  "subSteps": [
                                    "Escreva uma função recursiva traversePostOrder(Node node, List<TAC> instructions).",
                                    "No corpo: chame recursivamente no filho direito, depois esquerdo, então processe o nó atual.",
                                    "No processamento do nó: verifique tipo de nó e emita TAC apropriada usando atributos decorados.",
                                    "Para folhas (variáveis/constantes): emita TAC de carga se necessário.",
                                    "Para operadores binários: aloque novo temporário e emita 'temp = left + right'."
                                  ],
                                  "verification": "Execute em uma AST de teste e confirme que instruções TAC são emitidas na ordem pós-ordem correta.",
                                  "estimatedTime": "1 hora 30 minutos",
                                  "materials": "Código-base de AST do step 2, debugger da IDE.",
                                  "tips": "Use um contador global para temporários (t1, t2...) para evitar conflitos.",
                                  "learningObjective": "Implementar recursão pós-ordem que traverse corretamente e colete instruções.",
                                  "commonMistakes": "Inverter ordem de filhos (direito antes esquerdo); recursão infinita por falta de base case."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Integrar Geração de TAC Completa e Gerenciar Escopos/Temporários",
                                  "subSteps": [
                                    "Expanda para lidar com atribuições: 'id = temp' após percorrimento da expressão.",
                                    "Implemente alocação de temporários com tabela de símbolos para reutilização.",
                                    "Adicione suporte a escopos: passe contexto de símbolo no percorrimento.",
                                    "Gere TAC para operações unárias e condicionais básicas.",
                                    "Otimize TAC simples, como eliminar temporários desnecessários."
                                  ],
                                  "verification": "Gere TAC para programa completo como 'x = a + b * c;' e valide linearidade.",
                                  "estimatedTime": "1 hora",
                                  "materials": "Tabela de símbolos mock, exemplos de TAC de livros de compiladores.",
                                  "tips": "Imprima pilha de chamada recursiva para depurar ordem de execução.",
                                  "learningObjective": "Gerar código intermediário correto considerando semântica completa.",
                                  "commonMistakes": "Colisões de temporários; ignorar precedência ao emitir TAC fora de ordem."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Testar, Depurar e Validar a Implementação",
                                  "subSteps": [
                                    "Crie suíte de testes: expressões variadas, aninhadas, com loops simulados.",
                                    "Compare saída TAC manual vs. gerada, verificando ordem e correção.",
                                    "Use debugger para inspecionar pilha recursiva e lista de instruções.",
                                    "Meça cobertura: todos nós visitados pós-ordem?",
                                    "Refatore para performance: considere iteração não-recursiva se profundidade alta."
                                  ],
                                  "verification": "Todos testes passam com TAC idêntico ao esperado.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Framework de testes (JUnit/Pytest), validador TAC manual.",
                                  "tips": "Teste casos edge: AST vazia, nó único, profundidade alta.",
                                  "learningObjective": "Garantir robustez e correção do percorridor em cenários reais.",
                                  "commonMistakes": "Testes insuficientes para casos aninhados; não validar ordem exata."
                                }
                              ],
                              "practicalExample": "Para a expressão 'x = a + b * c': AST com nó raiz Assign(x, BinOp(+, Var(a), BinOp(*, Var(b), Var(c)))). Pós-ordem: c, b, *, a, +, x=. TAC gerado: t1 = b * c; t2 = a + t1; x = t2.",
                              "finalVerifications": [
                                "Ordem de visita é estritamente pós-ordem (folhas primeiro).",
                                "Todos temporários são únicos e corretamente alocados.",
                                "TAC emitido é linear e equivalente semânticamente à AST.",
                                "Atributos decorados (tipos, escopos) são usados corretamente.",
                                "Nenhum erro de recursão ou stack overflow em profundidades razoáveis.",
                                "Testes unitários cobrem 100% dos nós da AST."
                              ],
                              "assessmentCriteria": [
                                "Correção da ordem pós-ordem em todos testes (90% peso).",
                                "Emissão precisa de TAC para operadores binários/unários.",
                                "Gerenciamento correto de temporários e escopos.",
                                "Eficiência recursiva sem vazamentos de memória.",
                                "Robustez contra entradas inválidas ou AST malformadas.",
                                "Clareza e modularidade do código implementado."
                              ],
                              "crossCurricularConnections": [
                                "Algoritmos e Estruturas de Dados: Recursão em árvores binárias.",
                                "Análise Semântica: Uso de tabelas de símbolos e decoração.",
                                "Otimização de Compiladores: Preparação para passes de otimização em TAC.",
                                "Programação Funcional: Padrões de visitor e fold em árvores.",
                                "Engenharia de Software: Testes unitários e depuração recursiva."
                              ],
                              "realWorldApplication": "Em compiladores como LLVM ou GCC, percorrimentos pós-ordem geram IR (Intermediate Representation) para otimizações e codegen, permitindo apps eficientes como browsers (V8 JS) ou JVM, onde expressões complexas são traduzidas para assembly otimizado."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.6.3.3.2",
                            "name": "Tratar controle de fluxo no código intermediário",
                            "description": "Gerar código intermediário para estruturas condicionais e loops a partir de representações semânticas, incluindo labels e saltos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender representações semânticas de controle de fluxo",
                                  "subSteps": [
                                    "Analise a árvore de sintaxe abstrata (AST) ou representação semântica para identificar nós de controle de fluxo como if, while e for.",
                                    "Identifique condições booleanas e blocos de código associados em representações pós-análise semântica.",
                                    "Mapeie conceitos semânticos para primitivas de código intermediário: condições viram comparações com saltos condicionais.",
                                    "Estude convenções de código intermediário, como three-address code (TAC) com labels (L1, L2) e instruções goto/if-goto.",
                                    "Crie um diagrama de fluxo para um exemplo simples de if para visualizar labels e saltos."
                                  ],
                                  "verification": "Desenhe diagramas de fluxo para pelo menos 3 estruturas de controle diferentes e explique o mapeamento para labels/saltos.",
                                  "estimatedTime": "1-2 horas",
                                  "materials": [
                                    "Livro 'Compilers: Principles, Techniques, and Tools' (Dragon Book)",
                                    "Editor de código como VS Code",
                                    "Papel e caneta para diagramas"
                                  ],
                                  "tips": "Use nomes de labels sequenciais e únicos (ex: L1, L2) para evitar conflitos.",
                                  "learningObjective": "Entender como estruturas de alto nível são decompostas em blocos lineares com saltos.",
                                  "commonMistakes": [
                                    "Ignorar o escopo de variáveis nas condições",
                                    "Confundir ordem de avaliação de condições booleanas",
                                    "Não considerar fall-through em estruturas sem else"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Gerar código intermediário para estruturas condicionais",
                                  "subSteps": [
                                    "Para um if simples (if cond then stmt): Gere código da cond, adicione label inicial, if-not-goto para fim do then, código do then, label fim.",
                                    "Para if-else: Após then, adicione goto para fim do else, label do else, código do else, label fim.",
                                    "Implemente em pseudocódigo ou linguagem simples: atribua labels únicos e insira saltos condicionais.",
                                    "Teste com condições compostas (&&, ||) quebrando em saltos aninhados.",
                                    "Otimize saltos redundantes removendo gotos desnecessários."
                                  ],
                                  "verification": "Converta um if-else aninhado em TAC e simule execução passo a passo sem erros.",
                                  "estimatedTime": "2-3 horas",
                                  "materials": [
                                    "Compilador de exemplo open-source como TinyCC",
                                    "Ferramenta online de visualização de TAC",
                                    "Exemplos de código fonte simples"
                                  ],
                                  "tips": "Sempre posicione o label do else logo após o goto do then para evitar loops infinitos.",
                                  "learningObjective": "Dominar geração de labels e saltos para ramificações condicionais precisas.",
                                  "commonMistakes": [
                                    "Colocar label do else dentro do bloco then",
                                    "Esquecer goto após then em if-else",
                                    "Não lidar com condições de curto-circuito"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Gerar código intermediário para estruturas de loop",
                                  "subSteps": [
                                    "Para while (cond) stmt: Label início, código cond, if-not-goto fim, stmt, goto início, label fim.",
                                    "Para do-while: stmt primeiro, label após stmt, cond, if-goto início, label fim.",
                                    "Adapte for loops: inicialização, while (cond após init), incremento no final do corpo.",
                                    "Incorpore breaks/continues como gotos para labels específicos de fim ou início.",
                                    "Gere código para loops aninhados atribuindo labels hierarquicos (ex: L10_loop1)."
                                  ],
                                  "verification": "Gere TAC para um while com break/continue e verifique simulação executando 5 iterações corretas.",
                                  "estimatedTime": "2-3 horas",
                                  "materials": [
                                    "LLVM IR explorer online",
                                    "Pseudocódigo de compiladores em Python",
                                    "Debugger simples para TAC"
                                  ],
                                  "tips": "Defina labels para 'topo do loop' e 'saída' explicitamente para facilitar breaks/continues.",
                                  "learningObjective": "Implementar loops com controle preciso de entrada/saída via saltos incondicionais e condicionais.",
                                  "commonMistakes": [
                                    "Goto para fim em vez de topo no continue",
                                    "Loop infinito por falta de if-not-goto",
                                    "Incremento fora de posição em for loops"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Integrar e verificar controle de fluxo em código intermediário completo",
                                  "subSteps": [
                                    "Combine condicionais e loops em uma função completa, gerenciando labels globais únicos.",
                                    "Simule execução do TAC gerado com valores de teste para verificar fluxo correto.",
                                    "Aplique renumeração de labels e remoção de saltos mortos para otimização básica.",
                                    "Teste casos edge: loops vazios, condições sempre verdadeiras/falsas.",
                                    "Documente o mapeamento semântico para TAC em comentários no código."
                                  ],
                                  "verification": "Implemente um gerador de TAC para um programa com if/while aninhados e passe em 5 testes unitários.",
                                  "estimatedTime": "2-4 horas",
                                  "materials": [
                                    "Python ou C para protótipo de gerador",
                                    "Testes unitários framework como pytest",
                                    "Referência de TAC da Dragon Book"
                                  ],
                                  "tips": "Mantenha um contador global de labels para automação e evite colisões.",
                                  "learningObjective": "Construir e validar código intermediário funcional para fluxos complexos.",
                                  "commonMistakes": [
                                    "Conflito de labels entre estruturas",
                                    "Saltos apontando para labels inexistentes",
                                    "Não otimizar saltos para código limpo"
                                  ]
                                }
                              ],
                              "practicalExample": "Dado: if (x > 0) { y = 1; } else { while (y < 10) { y++; } }\nCódigo Intermediário:\nL1: if x <= 0 goto L2\ny = 1\ngoto L5\nL2: L3: if y >= 10 goto L4\ny = y + 1\ngoto L3\nL4: L5:",
                              "finalVerifications": [
                                "Gere TAC correto para if-else sem saltos errados.",
                                "Implemente while loop com execução iterativa precisa.",
                                "Lide com breaks/continues redirecionando para labels corretos.",
                                "Simule programa complexo sem loops infinitos ou skips.",
                                "Otimize TAC removendo 100% dos saltos redundantes.",
                                "Documente labels e fluxos em pelo menos 80% das estruturas."
                              ],
                              "assessmentCriteria": [
                                "Precisão dos saltos condicionais e incondicionais (sem erros lógicos).",
                                "Uso consistente e único de labels em todo o código.",
                                "Cobertura completa de estruturas (if, while, for, breaks).",
                                "Eficiência: mínimo de instruções desnecessárias pós-otimização.",
                                "Correção em simulações com dados de teste variados.",
                                "Clareza na documentação do mapeamento semântico-TAC."
                              ],
                              "crossCurricularConnections": [
                                "Matemática Discreta: Lógica booleana e grafos de fluxo de controle.",
                                "Algoritmos: Análise de complexidade em loops e condicionais.",
                                "Engenharia de Software: Design de linguagens e ferramentas de compilação.",
                                "Lógica Computacional: Tradução de predicados para instruções imperativas."
                              ],
                              "realWorldApplication": "Em compiladores como GCC e LLVM, essa técnica gera Intermediate Representation (IR) com basic blocks e branches, permitindo otimizações como eliminação de código morto e vetorização, essencial para performance em software como navegadores e jogos."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.6.3.3.3",
                            "name": "Avaliar tratamento de erros na geração",
                            "description": "Identificar e implementar estratégias para propagar erros semânticos sem interromper a geração de código intermediário parcial.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender erros semânticos e sua detecção",
                                  "subSteps": [
                                    "Estude os tipos comuns de erros semânticos (ex: incompatibilidade de tipos, variáveis não declaradas, escopo incorreto).",
                                    "Revise o processo de análise semântica e como erros são detectados durante a árvore de sintaxe.",
                                    "Analise exemplos de código fonte com erros semânticos em uma linguagem simples.",
                                    "Documente os impactos potenciais na geração de código intermediário."
                                  ],
                                  "verification": "Lista de 5 erros semânticos identificados com exemplos de código fonte.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Documentação de análise semântica",
                                    "Exemplos de código fonte com erros",
                                    "Editor de texto"
                                  ],
                                  "tips": "Foquem em erros que não impedem parsing, mas afetam semântica.",
                                  "learningObjective": "Identificar e classificar erros semânticos relevantes para geração de código.",
                                  "commonMistakes": "Confundir erros sintáticos com semânticos; ignorar erros de escopo."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Projetar estratégias de propagação de erros",
                                  "subSteps": [
                                    "Pesquise estratégias como flags de erro, valores sentinel e estruturas de dados com status.",
                                    "Defina regras para continuar geração parcial apesar de erros (ex: pular blocos inválidos).",
                                    "Crie um fluxograma do processo de geração com pontos de propagação de erros.",
                                    "Avalie trade-offs: precisão de diagnósticos vs. completude do código IR."
                                  ],
                                  "verification": "Fluxograma desenhado mostrando caminhos com e sem erros.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Papel ou ferramenta de diagramação (Draw.io)",
                                    "Artigos sobre error recovery em compiladores"
                                  ],
                                  "tips": "Priorize diagnósticos múltiplos; evite abortar prematuramente.",
                                  "learningObjective": "Desenvolver estratégias para propagar erros sem interromper geração parcial.",
                                  "commonMistakes": "Propagar erros de forma que cause crashes posteriores; subestimar complexidade de recuperação."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar tratamento de erros no gerador de código",
                                  "subSteps": [
                                    "Modifique o código do gerador para incluir checks de erros semânticos.",
                                    "Implemente propagação usando um contexto global de erros ou nós marcados na AST.",
                                    "Adicione geração condicional de IR: gere para partes válidas, skip inválidas.",
                                    "Teste unitariamente com casos de erro simples."
                                  ],
                                  "verification": "Código modificado roda sem crash e gera IR parcial para input com erros.",
                                  "estimatedTime": "90 minutos",
                                  "materials": [
                                    "Código fonte do compilador exemplo",
                                    "Ambiente de desenvolvimento (Python/Java com parser)",
                                    "Testes unitários"
                                  ],
                                  "tips": "Use logging para rastrear erros propagados.",
                                  "learningObjective": "Implementar mecanismos de propagação de erros na geração de IR.",
                                  "commonMistakes": "Interromper geração em erros isolados; não reportar todos os erros."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Avaliar e testar a implementação",
                                  "subSteps": [
                                    "Execute testes com múltiplos erros semânticos no mesmo programa.",
                                    "Verifique se IR parcial é sintaticamente válido e útil.",
                                    "Analise relatórios de erros: completude e clareza.",
                                    "Meça performance: overhead da propagação."
                                  ],
                                  "verification": "Relatório de testes com cenários cobertos e métricas.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Suite de testes",
                                    "Ferramentas de análise de IR (ex: LLVM viewer)",
                                    "Profiler básico"
                                  ],
                                  "tips": "Use casos edge: erros em loops, funções aninhadas.",
                                  "learningObjective": "Avaliar eficácia do tratamento de erros na geração contínua.",
                                  "commonMistakes": "Ignorar degradação de performance; validar apenas casos felizes."
                                }
                              ],
                              "practicalExample": "Em um compilador para MiniLang, código 'int x = \"string\"; print(x);' detecta mismatch de tipos, reporta erro, mas gera IR apenas para 'print(x)' assumindo tipo default, permitindo diagnóstico sem perda total.",
                              "finalVerifications": [
                                "Geração de IR parcial ocorre apesar de erros semânticos.",
                                "Todos os erros são reportados sem duplicatas ou omissões.",
                                "IR gerado é válido sintaticamente para partes processadas.",
                                "Não há crashes ou loops infinitos na propagação.",
                                "Diagnósticos são claros e localizados no código fonte."
                              ],
                              "assessmentCriteria": [
                                "Precisão na detecção e propagação de erros (90%+ cobertura).",
                                "Manutenção da completude parcial do IR gerado.",
                                "Clareza e utilidade dos relatórios de erro.",
                                "Eficiência: overhead <20% em performance.",
                                "Robustez contra casos edge e erros compostos."
                              ],
                              "crossCurricularConnections": [
                                "Engenharia de Software: Padrões de tratamento de exceções e recovery.",
                                "Testes e Debugging: Estratégias de fault tolerance.",
                                "Design de Sistemas: Arquiteturas tolerantes a falhas.",
                                "Inteligência Artificial: Propagação de incertezas em pipelines ML."
                              ],
                              "realWorldApplication": "Em compiladores como GCC e LLVM, erros semânticos são propagados permitindo geração de código objeto parcial para módulos válidos, facilitando depuração incremental em projetos grandes."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.6.4",
                    "name": "Geração de Código Assembly e Objeto",
                    "description": "Tradução do código intermediário para assembly e posterior montagem em código executável.",
                    "individualConcepts": [
                      {
                        "id": "10.1.6.4.1",
                        "name": "Geração de Código Assembly a partir de Código Intermediário",
                        "description": "Processo de tradução do código intermediário, como representações em três endereços ou árvores sintáticas, para instruções assembly específicas da arquitetura alvo, considerando registradores, endereçamento e otimizações locais.",
                        "specificSkills": [
                          {
                            "id": "10.1.6.4.1.1",
                            "name": "Identificar representações de código intermediário adequadas para geração de assembly",
                            "description": "Reconhecer formatos como código de três endereços, quadruplas ou árvores de expressão e mapear suas operações aritméticas, lógicas e de controle para equivalentes em assembly.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os formatos principais de código intermediário",
                                  "subSteps": [
                                    "Estude o código de três endereços (TAC): identifique sua estrutura básica (t1 = op t2 t3).",
                                    "Analise quadruplas: entenda o formato (op, arg1, arg2, result).",
                                    "Examine árvores de expressão: aprenda como representam operações hierarquicamente.",
                                    "Compare vantagens e desvantagens de cada formato para geração de assembly.",
                                    "Identifique exemplos simples de cada formato em documentação de compiladores."
                                  ],
                                  "verification": "Liste corretamente as características de pelo menos dois formatos com exemplos breves.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Livro 'Compilers: Principles, Techniques, and Tools' (Dragon Book), slides de compiladores online, exemplos de código intermediário.",
                                  "tips": "Desenhe diagramas para visualizar árvores de expressão.",
                                  "learningObjective": "Reconhecer e diferenciar formatos de código intermediário comuns.",
                                  "commonMistakes": "Confundir TAC com quadruplas sem notar a ordem dos operandos."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Mapear operações aritméticas para instruções assembly",
                                  "subSteps": [
                                    "Identifique operações aritméticas em TAC/quadruplas (add, sub, mul, div).",
                                    "Mapeie para assembly x86: ex. t1 = t2 + t3 → add reg1, reg2.",
                                    "Considere alocação de registradores temporários.",
                                    "Trate constantes e variáveis em expressões aritméticas.",
                                    "Pratique conversão de 3-5 expressões aritméticas simples."
                                  ],
                                  "verification": "Converta um exemplo de TAC aritmético para assembly equivalente sem erros.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Referência de instruções x86 (Intel manual), simulador de assembly online como NASM.",
                                  "tips": "Sempre preserve o resultado em um registrador ou memória designada.",
                                  "learningObjective": "Mapear precisamente operações aritméticas de intermediário para assembly.",
                                  "commonMistakes": "Ignorar overflow ou tipos de dados incompatíveis entre formatos."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Mapear operações lógicas e de controle de fluxo",
                                  "subSteps": [
                                    "Estude operações lógicas: AND, OR, NOT em intermediário e mapeie para test/cmp/and/or.",
                                    "Analise controle de fluxo: if-then-else como labels e jumps (jmp, je, jne).",
                                    "Identifique loops em árvores de expressão ou TAC e converta para estruturas while/do.",
                                    "Trate chamadas de função e retornos em código intermediário.",
                                    "Converta um bloco com condicionais e loops para assembly."
                                  ],
                                  "verification": "Gere código assembly funcional para um snippet com if e loop.",
                                  "estimatedTime": "75 minutos",
                                  "materials": "Exemplos de código LLVM IR, debugger GDB para testar assembly.",
                                  "tips": "Use labels descritivos como L1_loop_start para facilitar depuração.",
                                  "learningObjective": "Converter operações lógicas e controle para assembly com fluxo correto.",
                                  "commonMistakes": "Esquecer de atualizar flags de condição após comparações."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Praticar identificação e mapeamento integrado",
                                  "subSteps": [
                                    "Selecione um código intermediário misto (aritmética + lógica + controle).",
                                    "Identifique o formato e valide adequação para assembly.",
                                    "Realize mapeamento completo passo a passo.",
                                    "Teste o assembly gerado em um simulador.",
                                    "Otimize para eficiência (ex. reduzir jumps desnecessários)."
                                  ],
                                  "verification": "Produza assembly executável que corresponda semanticamente ao intermediário original.",
                                  "estimatedTime": "90 minutos",
                                  "materials": "Compilador GCC com -S flag para gerar assembly real, editor de código.",
                                  "tips": "Compare com assembly gerado por compiladores reais para validação.",
                                  "learningObjective": "Integrar identificação e mapeamento em fluxos completos.",
                                  "commonMistakes": "Não alinhar pilha ou registradores em funções."
                                }
                              ],
                              "practicalExample": "Dado TAC: t1 = a + b; if t1 > 0 goto L1; t2 = c * d; L1: print t2. Mapeie para assembly x86: mov eax, [a]; add eax, [b]; cmp eax, 0; jg L1; mov ebx, [c]; imul ebx, [d]; L1: call print; ret.",
                              "finalVerifications": [
                                "Lista corretamente formatos TAC, quadruplas e árvores com exemplos.",
                                "Mapeia 5 operações aritméticas sem erros para assembly.",
                                "Converte snippet com if/loop preservando semântica.",
                                "Gera assembly testável que produz saída idêntica ao original.",
                                "Identifica limitações de um formato para cenários específicos.",
                                "Otimiza mapeamento reduzindo instruções desnecessárias."
                              ],
                              "assessmentCriteria": [
                                "Precisão no reconhecimento de formatos (90%+ acurácia).",
                                "Corretude semântica no mapeamento (sem perda de lógica).",
                                "Eficiência do assembly gerado (mínimo de instruções).",
                                "Tratamento completo de registradores e memória.",
                                "Capacidade de debugar erros em mapeamentos falhos.",
                                "Integração de múltiplas operações em fluxos complexos."
                              ],
                              "crossCurricularConnections": [
                                "Arquitetura de Computadores: Entendimento de registradores e pipeline.",
                                "Matemática Discreta: Lógica booleana e expressões aritméticas.",
                                "Engenharia de Software: Otimização de código e depuração.",
                                "Algoritmos: Análise de complexidade em geração de código."
                              ],
                              "realWorldApplication": "Em compiladores como GCC ou LLVM, identificar e mapear código intermediário otimiza a geração de assembly para processadores reais, melhorando performance em aplicativos como navegadores web e jogos."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.6.4.1.2",
                            "name": "Mapear operações intermediárias para instruções assembly",
                            "description": "Converter operações como atribuições, saltos condicionais e chamadas de função em instruções assembly como MOV, ADD, JMP e CALL, respeitando convenções de chamadas e pilha.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Mapear Operações de Atribuição e Aritméticas Básicas",
                                  "subSteps": [
                                    "Identifique operações intermediárias como 't1 = a + b' ou 't2 = t1 * 3'",
                                    "Selecione registradores apropriados (ex: EAX para resultados temporários)",
                                    "Gere instruções: MOV para carregar operandos, ADD/SUB/MUL para operações, MOV para armazenar resultado",
                                    "Considere alocação de registradores para evitar conflitos",
                                    "Teste em um simulador para validar execução"
                                  ],
                                  "verification": "Gere assembly correto para 3 expressões aritméticas simples e execute sem erros em um assembler",
                                  "estimatedTime": "1.5 hours",
                                  "materials": [
                                    "Documentação Intel x86",
                                    "NASM assembler",
                                    "Simulador online como Godbolt"
                                  ],
                                  "tips": "Priorize registradores voláteis como EAX, EBX; use memória apenas se necessário",
                                  "learningObjective": "Dominar mapeamento de operações aritméticas para instruções MOV, ADD, SUB, MUL, DIV",
                                  "commonMistakes": [
                                    "Esquecer de carregar operandos da memória",
                                    "Sobrescrever registradores sem salvar",
                                    "Ignorar tamanhos de operandos (byte vs word)"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Mapear Saltos Condicionais e Controle de Fluxo",
                                  "subSteps": [
                                    "Identifique condições como 'if t1 > 0 goto L1' ou 'if t2 == t3 goto L2'",
                                    "Gere CMP para comparar operandos (ex: CMP eax, 0)",
                                    "Escolha jumps condicionais apropriados: JG para >, JE para ==, JNE para !=",
                                    "Defina labels (L1:) no assembly gerado",
                                    "Integre com código linear anterior/posterior"
                                  ],
                                  "verification": "Converta um bloco if simples de intermediário para assembly e verifique fluxo com debugger",
                                  "estimatedTime": "1 hour",
                                  "materials": [
                                    "Referência x86 jumps",
                                    "Debugger como GDB ou OllyDbg",
                                    "Exemplos de código intermediário"
                                  ],
                                  "tips": "Sempre use CMP antes de Jcc; evite jumps invertidos para otimização",
                                  "learningObjective": "Mapear condições intermediárias para CMP e instruções Jcc (JG, JL, JE, etc.)",
                                  "commonMistakes": [
                                    "Usar jump errado para condição (ex: JA em vez de JG)",
                                    "Esquecer label de destino",
                                    "Comparar registradores não inicializados"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Gerenciar Chamadas de Função e Convenções de Pilha",
                                  "subSteps": [
                                    "Identifique chamadas como 'call func(a, b)' em intermediário",
                                    "Siga convenções stdcall/cdecl: PUSH argumentos da direita para esquerda",
                                    "Use CALL para invocar função, ajuste pilha com ADD esp, N após retorno",
                                    "Salve registradores callee-saved (EBX, EBP) com PUSH/POP",
                                    "Gere RET na função chamada para retornar"
                                  ],
                                  "verification": "Gere assembly para uma chamada de função com 2 args e verifique pilha no debugger",
                                  "estimatedTime": "2 hours",
                                  "materials": [
                                    "Manual de convenções de chamada x86",
                                    "Exemplos C assembly no Godbolt",
                                    "Stack viewer em debugger"
                                  ],
                                  "tips": "Mantenha pilha alinhada a 16 bytes; limpe argumentos após CALL no caller",
                                  "learningObjective": "Implementar chamadas com PUSH, CALL, RET respeitando convenções de pilha",
                                  "commonMistakes": [
                                    "Ordem errada de PUSH args",
                                    "Não limpar pilha após CALL",
                                    "Sobrescrever EBP sem salvar"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Integrar Mapeamentos em um Programa Completo",
                                  "subSteps": [
                                    "Combine atribuições, condições e chamadas em um fluxo intermediário completo",
                                    "Otimize registradores e elimine redundâncias (ex: reutilize temps)",
                                    "Gere código assembly full com seções .text, .data",
                                    "Assemble e link com NASM/GCC, execute e debugue",
                                    "Compare saída com código high-level equivalente"
                                  ],
                                  "verification": "Converta um programa intermediário pequeno (10 linhas) para assembly executável sem erros",
                                  "estimatedTime": "2.5 hours",
                                  "materials": [
                                    "NASM/GCC toolchain",
                                    "Exemplos de IR como LLVM IR",
                                    "Debugger GDB"
                                  ],
                                  "tips": "Use .global main para entry point; teste com inputs variados",
                                  "learningObjective": "Sintetizar mapeamentos em código assembly funcional e otimizado",
                                  "commonMistakes": [
                                    "Misalign pilha em chamadas múltiplas",
                                    "Labels duplicados",
                                    "Falha em inicializar dados"
                                  ]
                                }
                              ],
                              "practicalExample": "Código intermediário: t1 = a + b; if (t1 > 0) call print_positive(t1); else call print_negative(t1); Assembly: MOV EAX, [a]; ADD EAX, [b]; CMP EAX, 0; JG positive; PUSH EAX; CALL print_negative; ADD ESP, 4; JMP end; positive: PUSH EAX; CALL print_positive; ADD ESP, 4; end:",
                              "finalVerifications": [
                                "Mapeia corretamente 5 operações mistas (aritmética, condicional, call) sem erros de execução",
                                "Pilha é gerenciada corretamente em chamadas (verificada via debugger)",
                                "Fluxo de controle segue labels e jumps precisamente",
                                "Registradores são preservados conforme convenções",
                                "Código assemblado executa e produz saída esperada para 3 casos de teste",
                                "Otimizações básicas aplicadas (ex: reuse de registradores)"
                              ],
                              "assessmentCriteria": [
                                "Precisão no mapeamento: 100% das ops intermediárias convertidas corretamente",
                                "Conformidade com convenções x86: pilha, registradores e calling std",
                                "Eficiência: mínimo de instruções redundantes ou spills desnecessários",
                                "Robustez: lida com edge cases como zero, overflow",
                                "Clareza: código legível com labels e comentários implícitos",
                                "Testabilidade: executa sem crashes em simulador"
                              ],
                              "crossCurricularConnections": [
                                "Arquitetura de Computadores: Entendimento de pipeline, registradores e flags",
                                "Programação de Sistemas: Assembly em kernels e drivers",
                                "Otimização de Compiladores: Técnicas de registro allocation",
                                "Engenharia de Software: Geração de código em tools como LLVM",
                                "Matemática Discreta: Lógica booleana em condições de jump"
                              ],
                              "realWorldApplication": "Em compiladores como GCC ou Clang, essa habilidade gera código assembly eficiente a partir de IR, otimizando performance em software embarcado, jogos e sistemas operacionais onde velocidade é crítica."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.6.4.1.3",
                            "name": "Gerenciar alocação inicial de registradores",
                            "description": "Aplicar estratégias simples de alocação de registradores, como alocação linear ou por grafo de interferência básico, para minimizar acessos à memória durante a geração de assembly.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender Fundamentos de Registradores e Variáveis Vivas",
                                  "subSteps": [
                                    "Definir registradores e seu papel na execução de instruções assembly.",
                                    "Explicar liveness analysis: identificar quando uma variável está 'viva'.",
                                    "Construir uma tabela de liveness para um código intermediário simples.",
                                    "Calcular intervalos de vida (live ranges) para cada variável.",
                                    "Discutir impacto de spills (movimentações para memória) na performance."
                                  ],
                                  "verification": "Criar manualmente uma análise de liveness para um trecho de código com 4 variáveis e confirmar intervalos corretos.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Exemplos de código intermediário em três endereços",
                                    "Ferramenta online de visualização de liveness (ex: live variable analyzer)",
                                    "Documentação de ISA simples como MIPS"
                                  ],
                                  "tips": [
                                    "Use diagramas de linha do tempo para visualizar live ranges.",
                                    "Comece com códigos lineares sem loops para simplicidade."
                                  ],
                                  "learningObjective": "Dominar análise de liveness para identificar candidatos à alocação em registradores.",
                                  "commonMistakes": [
                                    "Confundir uso-definição com live ranges.",
                                    "Ignorar pontos de branch ou loops na análise."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar Alocação Linear Scan",
                                  "subSteps": [
                                    "Ordenar variáveis por início de live range.",
                                    "Manter uma lista de registradores livres e alocações atuais.",
                                    "Iterar pelo código: alocar registrador livre ou spill o mais antigo.",
                                    "Atualizar live ranges ao expirar alocações.",
                                    "Gerar mapeamento variável -> registrador."
                                  ],
                                  "verification": "Aplicar linear scan a um código com 5 variáveis e 3 registradores, produzindo mapeamento sem conflitos.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Pseudocódigo de linear scan de literatura (ex: Poletto & Sarkar)",
                                    "Editor de código para simular (Python ou pseudocódigo)",
                                    "Exemplos de benchmark pequenos"
                                  ],
                                  "tips": [
                                    "Priorize spills de variáveis com live ranges mais longos.",
                                    "Teste com casos onde todos registradores estão cheios."
                                  ],
                                  "learningObjective": "Executar alocação linear scan para código simples, minimizando spills.",
                                  "commonMistakes": [
                                    "Não expirar alocações corretamente no final do live range.",
                                    "Spill prematuro de variáveis ativamente usadas."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Construir e Colorir Grafo de Interferência Básico",
                                  "subSteps": [
                                    "Construir grafo: nós são variáveis, arestas se live ranges se sobrepõem.",
                                    "Implementar detecção de interferência via análise de liveness.",
                                    "Aplicar coloração gulosa: atribuir cores (registradores) aos nós.",
                                    "Detectar e resolver conflitos adicionando spills.",
                                    "Simplificar grafo removendo nós de baixo grau."
                                  ],
                                  "verification": "Gerar grafo de interferência para o mesmo código do step 2 e colorir com 3 cores sem conflitos.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Biblioteca de grafos (ex: NetworkX em Python para protótipo)",
                                    "Ferramentas visuais como Graphviz",
                                    "Exemplos de grafos de compiladores"
                                  ],
                                  "tips": [
                                    "Ordene nós por grau decrescente para coloração gulosa eficiente.",
                                    "Visualize o grafo para depurar interferências."
                                  ],
                                  "learningObjective": "Modelar alocação como problema de coloração de grafo e resolvê-lo heuristicamente.",
                                  "commonMistakes": [
                                    "Arestas erradas no grafo (sobreposições mal calculadas).",
                                    "Coloração que ignora grau de nós adjacentes."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Comparar Estratégias e Gerar Código Assembly Otimizado",
                                  "subSteps": [
                                    "Comparar resultados de linear scan vs. grafo em performance (spills).",
                                    "Substituir variáveis por registradores no código intermediário.",
                                    "Gerar assembly final com instruções de load/store para spills.",
                                    "Mensurar acessos à memória antes/depois.",
                                    "Otimizar manualmente casos de alto spill."
                                  ],
                                  "verification": "Produzir assembly equivalente para código dado usando ambas estratégias, com contagem de spills menor ou igual.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Simulador de assembly simples (ex: RARS para MIPS)",
                                    "Templates de código intermediário para testes"
                                  ],
                                  "tips": [
                                    "Conte spills como proxy para performance.",
                                    "Escolha estratégia baseada em tamanho do código."
                                  ],
                                  "learningObjective": "Integrar alocações em pipeline de geração de assembly e avaliar trade-offs.",
                                  "commonMistakes": [
                                    "Não substituir corretamente nos pontos de spill.",
                                    "Ignorar custos de load/store em avaliações."
                                  ]
                                }
                              ],
                              "practicalExample": "Considere o código intermediário: t1 = a + b; t2 = t1 * c; d = t2 + e; f = d * g. Com 3 registradores (r1,r2,r3), aplique linear scan: aloque r1 para a/b, spill t1 para mem, etc. Para grafo: construa interferências (t1 interfere com t2,d,f), colore com r1-r3 minimizando spills, gere assembly como 'add r1, r2, r3; sw t1, mem; lw t1, mem; mul r4, r1, r5...'",
                              "finalVerifications": [
                                "Explicar com precisão quando dois nós interferem em um grafo.",
                                "Implementar linear scan em pseudocódigo para código com loops simples.",
                                "Identificar e corrigir um grafo mal colorido com spill.",
                                "Comparar número de spills entre estratégias em exemplo dado.",
                                "Gerar assembly correto sem conflitos de registrador.",
                                "Mensurar redução de acessos à memória pós-alocação."
                              ],
                              "assessmentCriteria": [
                                "Precisão na análise de liveness (sem falsos positivos/negativos).",
                                "Efetividade da alocação (mínimo spills para registradores dados).",
                                "Corretude do grafo de interferência e coloração.",
                                "Qualidade do assembly gerado (sem overwrites inválidos).",
                                "Capacidade de comparar e justificar escolha de estratégia.",
                                "Eficiência temporal da implementação (O(n) para linear scan)."
                              ],
                              "crossCurricularConnections": [
                                "Arquitetura de Computadores: Limitações reais de registradores em CPUs (ex: x86 vs. RISC).",
                                "Teoria dos Grafos: Coloração de grafos e algoritmos gulosos.",
                                "Algoritmos e Estruturas de Dados: Análise de intervalos e heaps para spills.",
                                "Otimização de Performance: Técnicas de redução de latência em software.",
                                "Engenharia de Software: Integração em pipelines de compiladores."
                              ],
                              "realWorldApplication": "Em compiladores como GCC e LLVM, essas técnicas geram código assembly eficiente para aplicativos de alto desempenho, como engines de jogos (Unity/Unreal), kernels de SO e IA (TensorFlow), reduzindo acessos à memória em até 50% e melhorando throughput em CPUs modernas."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.6.4.2",
                        "name": "Estrutura e Sintaxe do Código Assembly",
                        "description": "Compreensão da linguagem assembly, incluindo diretivas, pseudo-instruções, modos de endereçamento e gerenciamento de memória, para produzir código assembly válido e eficiente.",
                        "specificSkills": [
                          {
                            "id": "10.1.6.4.2.1",
                            "name": "Escrever instruções assembly básicas para operações aritméticas e lógicas",
                            "description": "Criar sequências de instruções como ADD, SUB, MUL, CMP e suas variantes com registradores, imediatos e memória em arquiteturas como x86 ou MIPS.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a Sintaxe Básica de Instruções Assembly x86",
                                  "subSteps": [
                                    "Estude a sintaxe geral: instrução destino, origem (ex: ADD EAX, EBX)",
                                    "Identifique operandos: registradores (EAX, EBX, ECX), imediatos (10, 0xFF), memória ([ESI + 4])",
                                    "Aprenda tamanhos de operandos: BYTE PTR, WORD PTR, DWORD PTR para clareza",
                                    "Revise modos de endereçamento: direto [endereço], indireto [reg], indexado [reg + offset]",
                                    "Pratique parseando 5 instruções de exemplo de documentação"
                                  ],
                                  "verification": "Escreva 3 instruções válidas usando cada tipo de operando e explique cada parte",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Documentação Intel x86 manuals (PDF ou online)",
                                    "Editor de texto como VS Code com extensão Assembly",
                                    "Emulador online como https://www.onlinegdb.com/online_asm_compiler"
                                  ],
                                  "tips": "Use sempre registradores de 32-bit como EAX para iniciantes; especifique PTR para memória ambígua",
                                  "learningObjective": "Formar instruções assembly sintaticamente corretas com diferentes operandos",
                                  "commonMistakes": [
                                    "Omitir colchetes em endereços de memória",
                                    "Confundir ordem destino-origem",
                                    "Ignorar prefixos de tamanho"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Dominar Operações Aritméticas Básicas (ADD, SUB, MUL, IMUL)",
                                  "subSteps": [
                                    "Aprenda ADD/SUB com registradores: ADD EAX, EBX; SUB ECX, 5",
                                    "Pratique com imediatos e memória: ADD [ESI], 10; SUB EAX, [EBX+4]",
                                    "Estude MUL/IMUL: MUL EBX (implicito EAX); IMUL EAX, EBX, 5 (três operandos)",
                                    "Implemente uma soma de array simples em 4 linhas",
                                    "Teste em emulador e observe registradores/flags (Carry, Overflow)"
                                  ],
                                  "verification": "Escreva código que some dois valores de memória e armazene em EAX, execute sem erros",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Emulador x86 como DOSBox ou onlinegdb",
                                    "Exemplos de código NASM/gas",
                                    "Calculadora binária para verificar resultados"
                                  ],
                                  "tips": "MUL usa EAX:EDX para 64-bit resultado; use IMUL para signed",
                                  "learningObjective": "Gerar código aritmético correto manipulando registradores, imediatos e memória",
                                  "commonMistakes": [
                                    "Não limpar EDX antes de MUL",
                                    "Overflow sem verificação CF/OF",
                                    "Usar MUL para signed"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar Operações Lógicas e Bitwise (AND, OR, XOR, NOT, SHL, SHR)",
                                  "subSteps": [
                                    "Estude AND/OR/XOR: AND EAX, 0xFF (máscara); OR EBX, 1 (set bit)",
                                    "Pratique NOT e shifts: NOT EAX; SHL ECX, 2 (x4); SHR EDX, 1",
                                    "Combine com memória: XOR [array], 0xAA; SHL BYTE PTR [ESI], 3",
                                    "Crie código para mascarar bits de um número e shiftar para alinhar",
                                    "Verifique resultados em debugger observando bits alterados"
                                  ],
                                  "verification": "Transforme 0x12345678 em 0x00005678 usando AND/OR/SHR, teste em emulador",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Debugger como x32dbg ou online emulator",
                                    "Tabela ASCII/hex para visualização",
                                    "Documentação bitwise Intel"
                                  ],
                                  "tips": "SHL/SHR afetam Carry; use XOR reg, reg para zeroar registrador",
                                  "learningObjective": "Aplicar operações bitwise para manipulação eficiente de dados",
                                  "commonMistakes": [
                                    "Shift por >31 (undefined)",
                                    "Confundir SHR (unsigned) com SAR (signed)",
                                    "AND com valor errado"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Usar Instruções de Comparação (CMP, TEST) e Flags",
                                  "subSteps": [
                                    "Aprenda CMP: CMP EAX, EBX (seta ZF/SF/CF sem alterar valores)",
                                    "Estude TEST: TEST EAX, 1 (verifica bit paridade)",
                                    "Pratique com variantes: CMP [mem], imm; TEST ECX, ECX (zero?)",
                                    "Escreva sequência: load valores, CMP, (flags para jumps futuros)",
                                    "Integre com aritmética: ADD, CMP resultado, 0 para sinal"
                                  ],
                                  "verification": "Escreva 4 CMP/TEST variadas e liste flags setadas para cada resultado possível",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Flags register diagram (EFLAGS)",
                                    "Emulador com step/debug",
                                    "Exemplos de condicionais assembly"
                                  ],
                                  "tips": "CMP dest, src subtrai src-dest internamente; TEST é AND sem store",
                                  "learningObjective": "Configurar flags corretamente para controle de fluxo",
                                  "commonMistakes": [
                                    "CMP com operandos invertidos",
                                    "Esquecer que CMP não altera valores",
                                    "Ignorar Zero Flag para ==0"
                                  ]
                                }
                              ],
                              "practicalExample": "Escreva um snippet assembly x86 que carrega dois números de memória (10 e 20), soma em EAX (ADD EAX, [mem2]), testa se >15 (CMP EAX, 15; TEST EAX, EAX), e aplica máscara lógica (AND EAX, 0x0F) antes de armazenar de volta. Código exemplo:\n\nmov eax, [num1]  ; eax = 10\nadd eax, [num2]  ; eax = 30\ncmp eax, 15\nand eax, 0x0F    ; eax = 0 (30 & 15)",
                              "finalVerifications": [
                                "Escreve ADD EAX, [EBX+8] sem erros sintáticos",
                                "Implementa MUL EBX com limpeza de EDX e verifica produto 64-bit",
                                "Usa SHL/SHR para multiplicar/dividir por potências de 2 corretamente",
                                "Configura CMP para detectar igualdade e lista flags (ZF=1)",
                                "Combina ADD + CMP + AND em sequência funcional testada em emulador",
                                "Identifica e corrige overflow em SUB signed"
                              ],
                              "assessmentCriteria": [
                                "100% correção sintática em todas instruções",
                                "Uso apropriado de operandos (reg/imm/mem) sem ambiguidades",
                                "Manipulação correta de flags e resultados esperados",
                                "Eficiência: evita instruções redundantes ou ineficientes",
                                "Tratamento de edge cases como zero, overflow, signed/unsigned",
                                "Comentários claros explicando cada operação"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Operações em binário e álgebra booleana",
                                "Física/Eletrônica: Equivalência com portas lógicas (AND/OR gates)",
                                "Engenharia de Software: Otimização de código em compiladores",
                                "Matemática Discreta: Teoria de números e shifts como exponenciação",
                                "Arquitetura de Computadores: Pipeline e execução de instruções"
                              ],
                              "realWorldApplication": "Em compiladores (GCC/Clang) para gerar código assembly otimizado de linguagens high-level; em sistemas embarcados (IoT/Arduino) para operações eficientes em microcontroladores com recursos limitados; em software de segurança (criptografia) para bitwise em hashes; e em jogos/performance crítica para loops vetorizados e manipulação de pixels."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.6.4.2.2",
                            "name": "Implementar controle de fluxo em assembly",
                            "description": "Gerar código para estruturas condicionais (IF-THEN-ELSE) e loops (WHILE, FOR) usando instruções de salto como JE, JNE, JMP e labels.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Dominar instruções de comparação e saltos condicionais básicos",
                                  "subSteps": [
                                    "Estude a instrução CMP e como ela define flags como ZF (zero flag) e SF (sign flag).",
                                    "Aprenda saltos condicionais: JE/JNE para igualdade, JG/JL para comparações signed.",
                                    "Escreva um snippet assembly simples para IF (ex: if A > B then increment C).",
                                    "Teste o código em um emulador, ajustando labels para saltos.",
                                    "Analise o fluxo de execução com debugger."
                                  ],
                                  "verification": "O programa executa corretamente o branch condicional sem saltos infinitos ou skips errados.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Documentação NASM/MASM",
                                    "Emulador emu8086 ou DOSBox",
                                    "Editor de texto como VS Code com extensão assembly"
                                  ],
                                  "tips": "Sempre use labels únicas e alinhe-os corretamente para evitar erros de linker.",
                                  "learningObjective": "Compreender como flags de CPU controlam decisões condicionais em assembly.",
                                  "commonMistakes": [
                                    "Confundir JE com JNE.",
                                    "Esquecer de inicializar registradores antes de CMP.",
                                    "Usar saltos incondicionais JMP em vez de condicionais."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar estruturas IF-THEN-ELSE completas",
                                  "subSteps": [
                                    "Estruture o código com label para ELSE e JMP para pular o bloco ELSE após THEN.",
                                    "Exemplo: CMP AX, BX; JE then_label; JMP else_label; then_label: ...; else_label: ...",
                                    "Inclua múltiplas condições aninhadas (if-else if).",
                                    "Compile e execute com inputs variados para testar ambos os branches.",
                                    "Otimize removendo JMP desnecessários."
                                  ],
                                  "verification": "Todos os caminhos (true/false) executam corretamente sem vazamentos de código.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Mesmos do Step 1",
                                    "Exemplos de código assembly de compiladores como GCC -S"
                                  ],
                                  "tips": "Use XOR EAX, EAX para limpar flags se houver comparações encadeadas.",
                                  "learningObjective": "Gerar código assembly equivalente a estruturas condicionais de alto nível.",
                                  "commonMistakes": [
                                    "Label do ELSE acessível sem JMP de escape do THEN.",
                                    "Erro de escopo em registradores compartilhados entre branches."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Criar loops WHILE com condições de parada",
                                  "subSteps": [
                                    "Estruture WHILE: label_loop: CMP cond; JNE exit; body; JMP label_loop; exit:",
                                    "Implemente um loop que soma enquanto contador > 0.",
                                    "Adicione corpo com operações aritméticas e atualizações de variáveis.",
                                    "Teste com debugger para verificar iterações e parada correta.",
                                    "Varie condições (ex: while != 0, while < limite)."
                                  ],
                                  "verification": "Loop itera o número exato de vezes e para na condição correta sem overflow.",
                                  "estimatedTime": "50 minutos",
                                  "materials": [
                                    "Emulador com breakpoint",
                                    "Snippets de loops de livros como 'Assembly Language for x86 Processors'"
                                  ],
                                  "tips": "Coloque CMP no topo para while(condition), no final para do-while.",
                                  "learningObjective": "Controlar iterações indefinidas baseadas em condições dinâmicas.",
                                  "commonMistakes": [
                                    "Condição invertida causando loop infinito.",
                                    "Atualização de contador fora do loop."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Implementar loops FOR com contadores e boas práticas",
                                  "subSteps": [
                                    "Simule FOR(i=0; i<N; i++): init i=0; label: CMP i,N; JGE exit; body; INC i; JMP label; exit:",
                                    "Combine com condicionais dentro do loop.",
                                    "Otimize usando LOOP instruction se disponível (para ECX).",
                                    "Teste performance e corretude com N variados.",
                                    "Refatore código anterior integrando controle de fluxo misto."
                                  ],
                                  "verification": "Resultado final matches expectativa (ex: soma correta de 1 a N).",
                                  "estimatedTime": "55 minutos",
                                  "materials": [
                                    "Documentação Intel x86",
                                    "Ferramenta de profiling como cachegrind para assembly"
                                  ],
                                  "tips": "Prefira DEC/JNZ para contadores decrescentes por eficiência de flags.",
                                  "learningObjective": "Traduzir loops contados de alto nível para assembly eficiente.",
                                  "commonMistakes": [
                                    "Off-by-one em inicialização ou comparação.",
                                    "Uso de registrador errado sem salvar/restaurar."
                                  ]
                                }
                              ],
                              "practicalExample": "Programa assembly que lê N, soma apenas números pares de 1 a N usando IF dentro de FOR: init i=0; loop: CMP i,N; JGE done; CMP i,0; JNE next; ADD sum,i; next: INC i; JMP loop; done: output sum.",
                              "finalVerifications": [
                                "Gere código assembly funcional para IF-THEN-ELSE sem erros de branch.",
                                "Implemente WHILE que itera exatamente 10 vezes com soma correta.",
                                "Crie FOR que processa array de 5 elementos com condicionais internas.",
                                "Código compila e executa em emulador sem crashes ou loops infinitos.",
                                "Debugue e corrija um snippet buggy fornecido.",
                                "Otimize código reduzindo instruções desnecessárias em 20%."
                              ],
                              "assessmentCriteria": [
                                "Precisão das flags e saltos condicionais (sem branches errados).",
                                "Estrutura de labels clara e sem ambiguidades.",
                                "Eficiência: mínimo de JMPs e uso otimizado de registradores.",
                                "Corretude em testes unitários com múltiplos inputs.",
                                "Legibilidade: comentários e indentação adequados.",
                                "Integração: combina condicionais e loops sem conflitos."
                              ],
                              "crossCurricularConnections": [
                                "Matemática Discreta: Expressões booleanas e tabelas-verdade mapeadas a flags.",
                                "Engenharia de Computação: Lógica combinacional em ALUs e control units.",
                                "Algoritmos: Análise de complexidade temporal em loops assembly.",
                                "Lógica Digital: Flip-flops e estados em máquinas de salto condicional."
                              ],
                              "realWorldApplication": "Em compiladores (ex: backend do GCC gera assembly otimizado para if/loops), sistemas embarcados (firmware Arduino/ PIC com loops eficientes para sensores), reverse engineering de binários e otimização de performance em jogos/low-level programming."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.6.4.2.3",
                            "name": "Utilizar diretivas e seções em assembly",
                            "description": "Empregar diretivas como .data, .text, .global, .align e pseudo-operações para definir dados, alinhamentos e símbolos globais em um arquivo assembly.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender e definir seções básicas em assembly (.data e .text)",
                                  "subSteps": [
                                    "Estude a diferença entre seção .data (para dados inicializados) e .text (para código executável).",
                                    "Abra um editor de texto e crie um arquivo .s vazio.",
                                    "Adicione a diretiva .data no início do arquivo.",
                                    "Adicione a diretiva .text após .data para separar código de dados.",
                                    "Leia a documentação do GNU Assembler (GAS) sobre seções."
                                  ],
                                  "verification": "Explique verbalmente ou por escrito a finalidade de cada seção e mostre o arquivo com as diretivas corretas.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Editor de texto (VS Code ou Vim)",
                                    "Documentação GAS (man as)",
                                    "Terminal com GNU Assembler instalado"
                                  ],
                                  "tips": "Use .section .data e .section .text para maior flexibilidade, mas .data e .text são atalhos comuns.",
                                  "learningObjective": "Identificar e diferenciar seções de dados e código em assembly.",
                                  "commonMistakes": [
                                    "Colocar código na .data",
                                    "Esquecer de alternar para .text antes do código"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Declarar dados e usar pseudo-operações na seção .data",
                                  "subSteps": [
                                    "Na seção .data, declare uma variável com .word 42 (exemplo de inteiro).",
                                    "Adicione strings com .ascii \"Hello\" ou .asciz \"World\\0\".",
                                    "Defina arrays com múltiplos .byte 0xFF, 0x00.",
                                    "Use .space 100 para reservar espaço não inicializado.",
                                    "Salve o arquivo como exemplo.s."
                                  ],
                                  "verification": "Liste as variáveis declaradas e seus tipos/tamanhos usando objdump -d exemplo.s.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "GNU Assembler (as)",
                                    "objdump",
                                    "Terminal"
                                  ],
                                  "tips": "Sempre termine strings com \\0 se necessário para null-terminated.",
                                  "learningObjective": "Definir e inicializar dados estáticos usando pseudo-operações.",
                                  "commonMistakes": [
                                    "Misturar dados inicializados com .space",
                                    "Esquecer alinhamento implícito"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Configurar símbolos globais (.global) e alinhamentos (.align)",
                                  "subSteps": [
                                    "Adicione .global main no topo do arquivo para exportar o símbolo principal.",
                                    "Use .align 4 antes de uma label para alinhar a 4 bytes.",
                                    "Crie uma label como minha_var: na .data e referencie-a no .text.",
                                    "Adicione .extern printf se usando funções externas.",
                                    "Teste sintaxe com as --gstabs exemplo.s -o exemplo.o."
                                  ],
                                  "verification": "Use nm exemplo.o para verificar símbolos globais e alinhamentos com objdump -h.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "GNU Assembler (as)",
                                    "nm",
                                    "objdump"
                                  ],
                                  "tips": "Coloque .global no início do arquivo para clareza.",
                                  "learningObjective": "Exportar símbolos e garantir alinhamento de memória para performance.",
                                  "commonMistakes": [
                                    ".global em labels locais",
                                    "Alinhamento inadequado causando desalinhamento de CPU"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Integrar diretivas em um programa completo e testar",
                                  "subSteps": [
                                    "Escreva um programa simples: defina msg na .data, imprima no .text usando syscall ou printf.",
                                    "Compile com as exemplo.s -o exemplo.o && ld exemplo.o -o exemplo.",
                                    "Execute ./exemplo e verifique saída.",
                                    "Inspecione com objdump -d exemplo para confirmar seções e diretivas.",
                                    "Debugue erros comuns de linkage."
                                  ],
                                  "verification": "Programa compila, linka e executa sem erros, com saída correta.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "ld (linker)",
                                    "Editor",
                                    "Terminal"
                                  ],
                                  "tips": "Use gdb para debug se falhar execução.",
                                  "learningObjective": "Montar um assembly funcional usando todas as diretivas aprendidas.",
                                  "commonMistakes": [
                                    "Falta de .global main",
                                    "Syscalls erradas para arquitetura"
                                  ]
                                }
                              ],
                              "practicalExample": "Arquivo exemplo.s:\n.global main\n.data\nmsg: .asciz \"Hello, Assembly!\\n\"\n.align 4\n.text\nmain:\n    mov $msg, %rdi\n    call printf\n    mov $0, %rax\n    ret\nCompile: as exemplo.s -o exemplo.o && ld exemplo.o -lc -dynamic-linker /lib64/ld-linux-x86-64.so.2 -o exemplo\nExecute: ./exemplo",
                              "finalVerifications": [
                                "Compilação sem erros de sintaxe usando 'as'.",
                                "Símbolos globais visíveis via 'nm arquivo.o'.",
                                "Seções corretas e alinhadas via 'objdump -h arquivo.o'.",
                                "Programa executável linka e roda sem crashes.",
                                "Dados acessíveis corretamente no código.",
                                "Uso correto de pseudo-operações verificado por inspeção."
                              ],
                              "assessmentCriteria": [
                                "Uso preciso de .data e .text para separar dados e código (100%).",
                                "Declaração correta de dados com .word/.ascii/.space (90%).",
                                "Exportação de símbolos com .global e referências (95%).",
                                "Alinhamento aplicado onde necessário com .align (85%).",
                                "Programa completo compila e executa funcionalmente (100%).",
                                "Código limpo, comentado e sem erros comuns."
                              ],
                              "crossCurricularConnections": [
                                "Arquitetura de Computadores: Entendimento de layout de memória e seções de executáveis (ELF).",
                                "Programação de Sistemas: Integração com loaders e linkers em OS.",
                                "Compiladores: Geração de código assembly no backend de compiladores.",
                                "Engenharia de Software: Otimização de performance via alinhamento.",
                                "Eletrônica/Embedded: Uso em firmware e microcontroladores."
                              ],
                              "realWorldApplication": "Essas diretivas são essenciais no desenvolvimento de sistemas operacionais (kernels Linux usam extensivamente), drivers de hardware, firmware embarcado (IoT devices), e otimização de código de alto desempenho em jogos ou simulações científicas, onde controle preciso de memória e símbolos globais é crítico para eficiência e portabilidade."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.6.4.3",
                        "name": "Montagem e Geração de Código Objeto e Executável",
                        "description": "Processo de montagem do código assembly em código objeto relocável e subsequente linkagem para formar um executável, incluindo resolução de símbolos e gerenciamento de bibliotecas.",
                        "specificSkills": [
                          {
                            "id": "10.1.6.4.3.1",
                            "name": "Executar o processo de montagem com ferramentas como NASM ou GAS",
                            "description": "Usar assemblers para converter assembly em objeto (.o), resolvendo endereços locais e gerando símbolos não resolvidos para linkagem posterior.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar o ambiente e escrever código assembly simples",
                                  "subSteps": [
                                    "Instale o assembler NASM via gerenciador de pacotes (ex: apt install nasm no Linux).",
                                    "Crie um diretório de trabalho e um arquivo .asm com código assembly básico, como uma soma de números.",
                                    "Inclua diretivas necessárias: section .data para dados, section .text para código, e global _start.",
                                    "Escreva instruções assembly simples: mov, add, syscall para saída.",
                                    "Salve o arquivo como exemplo.asm."
                                  ],
                                  "verification": "Verifique se o NASM está instalado com 'nasm --version' e se o arquivo .asm abre corretamente sem erros de sintaxe básica.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Terminal, editor de texto (VS Code ou vim), NASM instalado",
                                  "tips": "Use código minimalista para evitar complexidades iniciais; teste sintaxe com um validador online se disponível.",
                                  "learningObjective": "Configurar ambiente e criar código assembly válido para montagem.",
                                  "commonMistakes": "Esquecer de declarar seções (.data, .text); usar sintaxe incorreta para a arquitetura (ex: x86-64 vs 32-bit)."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Executar o comando de montagem com NASM",
                                  "subSteps": [
                                    "Abra o terminal no diretório do arquivo .asm.",
                                    "Execute 'nasm -f elf64 exemplo.asm -o exemplo.o' para gerar objeto em formato ELF64.",
                                    "Observe a saída do terminal por erros ou warnings.",
                                    "Confirme a geração do arquivo .o com 'ls -la exemplo.o'.",
                                    "Experimente formatos alternativos como '-f win64' para Windows."
                                  ],
                                  "verification": "Arquivo exemplo.o existe e tem tamanho >0; sem erros no terminal.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Terminal, arquivo exemplo.asm, NASM",
                                  "tips": "Use -f para especificar formato de saída compatível com o linker (ELF para Linux, COFF para Windows).",
                                  "learningObjective": "Aplicar comando NASM para converter assembly em código objeto.",
                                  "commonMistakes": "Formato de saída errado causando falha no linker posterior; caminhos absolutos não usados se necessário."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Inspecionar o arquivo objeto gerado",
                                  "subSteps": [
                                    "Instale objdump se necessário (apt install binutils).",
                                    "Execute 'objdump -d exemplo.o' para ver disassembly.",
                                    "Use 'objdump -t exemplo.o' para listar símbolos (resolvidos e não resolvidos).",
                                    "Identifique endereços locais resolvidos e símbolos globais pendentes.",
                                    "Compare com o código fonte para validar tradução."
                                  ],
                                  "verification": "Objdump mostra código assembly equivalente e lista de símbolos com 'U' para não resolvidos.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Terminal, binutils (objdump), arquivo .o",
                                  "tips": "Foque em seções .text e símbolos; use 'readelf -a exemplo.o' para mais detalhes em ELF.",
                                  "learningObjective": "Analisar código objeto para entender resolução de endereços locais.",
                                  "commonMistakes": "Ignorar warnings de alinhamento; confundir símbolos locais vs globais."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Testar linkagem básica e validar processo completo",
                                  "subSteps": [
                                    "Instale ld (geralmente com binutils).",
                                    "Crie um linker script simples ou use 'ld exemplo.o -o exemplo' (ajuste para entry point).",
                                    "Execute o binário gerado e verifique saída.",
                                    "Use 'nm exemplo.o' para confirmar símbolos não resolvidos antes do link.",
                                    "Documente diferenças entre .o e executável."
                                  ],
                                  "verification": "Executável roda sem erros de linkagem e produz saída esperada.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Terminal, ld linker, arquivo .o",
                                  "tips": "Para testes simples, use '_start' como entry e syscalls diretas; evite dependências externas.",
                                  "learningObjective": "Integrar montagem com linkagem para compreender pipeline completo.",
                                  "commonMistakes": "Não especificar entry point causando 'no start' error; misturar formatos de objeto."
                                }
                              ],
                              "practicalExample": "Crie exemplo.asm: section .data\nmsg db 'Soma: ',0\nsection .text\nglobal _start\n_start:\nmov rax, 5\nadd rax, 3\n; syscall para print (simplificado). Execute 'nasm -f elf64 exemplo.asm -o exemplo.o', então 'objdump -d exemplo.o' para ver add resolvido localmente, mas _start como símbolo global não resolvido.",
                              "finalVerifications": [
                                "Arquivo .o gerado sem erros de montagem.",
                                "Objdump confirma resolução de endereços locais (jumps relativos corretos).",
                                "Lista de símbolos mostra não resolvidos (ex: _start como U).",
                                "Linkagem básica com ld succeeds.",
                                "Executável final roda e valida lógica assembly."
                              ],
                              "assessmentCriteria": [
                                "Comando NASM correto com flags apropriadas (formato, output).",
                                "Identificação precisa de símbolos resolvidos vs não resolvidos.",
                                "Análise correta via objdump/readelf/nm.",
                                "Código assembly sintaticamente válido e funcional.",
                                "Documentação de erros comuns evitados e verificações realizadas."
                              ],
                              "crossCurricularConnections": [
                                "Arquitetura de Computadores: Entender instruções de máquina e endereçamento.",
                                "Sistemas Operacionais: Syscalls e formatação de executáveis (ELF/PE).",
                                "Programação de Sistemas: Desenvolvimento de código de baixo nível e otimização.",
                                "Engenharia de Software: Pipeline de build (compile-assemble-link)."
                              ],
                              "realWorldApplication": "Desenvolvimento de compiladores personalizados, kernels de SO, firmware embarcado e reverse engineering de binários, onde montadores como NASM/GAS são essenciais para gerar código objeto eficiente e linkável."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.6.4.3.2",
                            "name": "Compreender a linkagem estática e dinâmica",
                            "description": "Explicar como o linker resolve referências externas, combina múltiplos objetos e gera executáveis, diferenciando linkagem estática (bibliotecas .a) e dinâmica (.so ou .dll).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender o conceito básico de linkagem e o papel do linker",
                                  "subSteps": [
                                    "Estude o que são referências externas em código objeto (símbolos indefinidos).",
                                    "Leia sobre o linker (ld no GCC) e suas funções principais: resolução de símbolos e combinação de arquivos objeto.",
                                    "Analise um exemplo simples de arquivo objeto com nm para ver símbolos.",
                                    "Desenhe um diagrama do fluxo: compilador -> objeto -> linker -> executável.",
                                    "Compare linkagem em tempo de compilação vs execução."
                                  ],
                                  "verification": "Crie um diagrama do processo de linkagem e explique verbalmente o papel do linker.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Comando nm, man ld, um programa C simples compilado para objeto"
                                  ],
                                  "tips": "Use diagramas visuais para fixar o fluxo; foque em símbolos globais vs locais.",
                                  "learningObjective": "Compreender o que é linkagem e como o linker resolve dependências entre módulos.",
                                  "commonMistakes": [
                                    "Confundir linker com compilador; ignorar símbolos undefined."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Explorar a linkagem estática em detalhes",
                                  "subSteps": [
                                    "Compile um programa com bibliotecas estáticas usando gcc -static e observe arquivos .a.",
                                    "Use ar para inspecionar uma biblioteca .a e entender como objetos são arquivados.",
                                    "Execute o executável gerado e verifique com file ou ldd que não há dependências dinâmicas.",
                                    "Analise o tamanho do executável e o processo de embedding completo das libs.",
                                    "Teste relinkagem modificando um objeto e recompilando."
                                  ],
                                  "verification": "Gere um executável estático e confirme ausência de libs dinâmicas com ldd.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "GCC/Clang, libc.a ou math.a, comandos ar e nm"
                                  ],
                                  "tips": "Comece com libm.a para funções matemáticas; compare tamanhos antes/depois.",
                                  "learningObjective": "Dominar como bibliotecas estáticas (.a) são incorporadas no executável final.",
                                  "commonMistakes": [
                                    "Esquecer de instalar libs de desenvolvimento; confundir .a com .so."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explorar a linkagem dinâmica em detalhes",
                                  "subSteps": [
                                    "Compile um programa com bibliotecas dinâmicas (.so ou .dll) usando gcc padrão.",
                                    "Use ldd para listar dependências e objdump para ver símbolos relocáveis.",
                                    "Entenda o loader do SO (ld.so) e resolução em runtime (lazy vs eager).",
                                    "Teste carregamento com LD_DEBUG para visualizar o processo.",
                                    "Compare com estática: execute em ambiente sem a lib para ver falha."
                                  ],
                                  "verification": "Gere um executável dinâmico, liste dependências com ldd e explique relocação.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "GCC, libm.so, ldd, LD_DEBUG=libs"
                                  ],
                                  "tips": "Use LD_LIBRARY_PATH para simular ausências; foque em RPATH.",
                                  "learningObjective": "Compreender como bibliotecas dinâmicas (.so/.dll) são carregadas em runtime.",
                                  "commonMistakes": [
                                    "Ignorar ordem de busca de libs; confundir link-time com load-time."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Comparar linkagem estática e dinâmica e gerar executáveis",
                                  "subSteps": [
                                    "Crie um programa que usa ambas e compile nas duas formas, comparando saídas.",
                                    "Discuta prós/contras: tamanho, portabilidade, atualizações de libs.",
                                    "Gere executável híbrido (se possível) e analise com readelf.",
                                    "Simule cenários reais: estática para embedded, dinâmica para servers.",
                                    "Resuma diferenças em tabela: resolução, tamanho, dependências."
                                  ],
                                  "verification": "Explique diferenças em um relatório curto com exemplos compilados.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "readelf, tabela comparativa em Markdown ou papel"
                                  ],
                                  "tips": "Use side-by-side: compile duas versões e diff tamanhos/execução.",
                                  "learningObjective": "Diferenciar completamente estática vs dinâmica e seu impacto em executáveis.",
                                  "commonMistakes": [
                                    "Generalizar prós sem contexto; ignorar overhead de carregamento dinâmico."
                                  ]
                                }
                              ],
                              "practicalExample": "Compile um programa C que calcula factorial usando libm: `gcc -static factorial.c -lm -o fact_static` e `gcc factorial.c -lm -o fact_dynamic`. Use `ldd fact_dynamic` (vazio no estático), `file` para tipos, e execute em container sem libm para ver falha dinâmica.",
                              "finalVerifications": [
                                "Descreva o fluxo completo do linker em linkagem estática.",
                                "Liste 3 diferenças chave entre .a e .so no processo de resolução.",
                                "Explique por que executáveis estáticos são maiores mas mais portáteis.",
                                "Identifique símbolos undefined em um .o com nm.",
                                "Simule falha de carregamento dinâmico e resolva com LD_LIBRARY_PATH.",
                                "Compare tamanhos e dependências de dois executáveis equivalentes."
                              ],
                              "assessmentCriteria": [
                                "Precisão na descrição do papel do linker e resolução de símbolos (30%).",
                                "Correta diferenciação entre estática e dinâmica com exemplos (25%).",
                                "Uso correto de ferramentas como nm, ldd, ar (20%).",
                                "Análise de prós/contras contextualizada (15%).",
                                "Clareza em diagramas e explicações verbais (10%)."
                              ],
                              "crossCurricularConnections": [
                                "Sistemas Operacionais: Mecanismos de carregamento e relocação de processos.",
                                "Desenvolvimento de Software: Gerenciamento de dependências com package managers (apt, npm).",
                                "Arquitetura de Computadores: Memória virtual e compartilhamento de bibliotecas.",
                                "Segurança da Informação: Vulnerabilidades em libs dinâmicas vs isolamento estático."
                              ],
                              "realWorldApplication": "Linkagem estática é usada em firmware embarcado (IoT) para independência de SO; dinâmica em servidores web (Apache com modulos .so) para atualizações sem recompilação total e compartilhamento de memória."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.6.4.3.3",
                            "name": "Gerar e depurar código objeto executável",
                            "description": "Compilar um programa completo do intermediário ao executável usando ferramentas como gcc -S (para assembly) e ld, identificando erros comuns de relocação e símbolos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Gerar código assembly a partir de código fonte usando gcc -S",
                                  "subSteps": [
                                    "Escreva um programa C simples, como 'Hello World', em um arquivo .c",
                                    "Execute 'gcc -S nome_arquivo.c -o nome_arquivo.s' para gerar o assembly",
                                    "Analise o arquivo .s gerado para entender instruções assembly básicas",
                                    "Compile com flags adicionais como -O0 para código não otimizado e -Wall para warnings",
                                    "Verifique sintaxe e ausência de erros de compilação frontend"
                                  ],
                                  "verification": "Arquivo .s é gerado sem erros e contém instruções assembly legíveis (use cat ou editor)",
                                  "estimatedTime": "20-30 minutos",
                                  "materials": [
                                    "GCC instalado",
                                    "Editor de texto (vim/nano)",
                                    "Terminal Linux/macOS",
                                    "Programa C de exemplo"
                                  ],
                                  "tips": [
                                    "Use -fno-asynchronous-unwind-tables para simplificar o assembly",
                                    "Compare com documentação AT&T vs Intel syntax"
                                  ],
                                  "learningObjective": "Compreender a tradução de código C para assembly x86/ARM via backend do GCC",
                                  "commonMistakes": [
                                    "Esquecer flag -S (gera executável em vez de assembly)",
                                    "Ignorar warnings que indicam problemas semânticos",
                                    "Não analisar o assembly gerado"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Montar código assembly para gerar arquivo objeto (.o) usando as",
                                  "subSteps": [
                                    "Execute 'as nome_arquivo.s -o nome_arquivo.o' no terminal",
                                    "Use 'objdump -d nome_arquivo.o' para disassemblar e inspecionar o binário objeto",
                                    "Adicione flags como --64 para arquitetura x86-64 se necessário",
                                    "Verifique seções com 'readelf -S nome_arquivo.o' (texto, data, etc.)",
                                    "Teste montagem de múltiplos arquivos .s se aplicável"
                                  ],
                                  "verification": "Arquivo .o é criado e objdump mostra código assembly montado sem erros de sintaxe",
                                  "estimatedTime": "15-25 minutos",
                                  "materials": [
                                    "GNU Assembler (as) instalado",
                                    "objdump e readelf (binutils)",
                                    "Terminal"
                                  ],
                                  "tips": [
                                    "Especifique --32 ou --64 explicitamente para evitar mismatches de arquitetura",
                                    "Salve assembly com syntax Intel se preferir (as -f intel)"
                                  ],
                                  "learningObjective": "Dominar o processo de montagem de assembly para código objeto relocável",
                                  "commonMistakes": [
                                    "Syntax errors no assembly (ex: labels malformados)",
                                    "Mismatch de arquitetura (32 vs 64-bit)",
                                    "Não verificar seções com readelf"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Linkar arquivos objeto para criar executável estático usando ld",
                                  "subSteps": [
                                    "Execute 'ld nome_arquivo.o -o executavel' para link estático simples",
                                    "Para link dinâmico, use 'ld -dynamic-linker /lib64/ld-linux-x86-64.so.2 nome_arquivo.o -lc -o executavel'",
                                    "Inclua bibliotecas com -l (ex: -lc para stdlib)",
                                    "Use 'ldd executavel' para verificar dependências dinâmicas",
                                    "Gere mapfile com -M para rastrear símbolos"
                                  ],
                                  "verification": "Executável é criado, chmod +x, e ./executavel roda sem 'No such file or directory'",
                                  "estimatedTime": "25-35 minutos",
                                  "materials": [
                                    "GNU Linker (ld) instalado",
                                    "Bibliotecas padrão (libc)",
                                    "Terminal"
                                  ],
                                  "tips": [
                                    "Comece com link estático para simplicidade",
                                    "Use -verbose para logs detalhados de linkagem"
                                  ],
                                  "learningObjective": "Entender resolução de símbolos e relocação durante linkagem estática/dinâmica",
                                  "commonMistakes": [
                                    "Símbolos indefinidos (undefined reference)",
                                    "Erros de relocação (relocation truncated)",
                                    "Falta de entry point (_start)"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Depurar erros comuns de código objeto e executável",
                                  "subSteps": [
                                    "Identifique 'undefined symbol' com nm nome_arquivo.o | grep símbolo",
                                    "Corrija relocação com objdump -r e ajuste labels/endereços",
                                    "Use gdb para debug: gdb ./executavel, run, backtrace em crashes",
                                    "Verifique com 'file executavel' e 'size executavel' para tamanhos seções",
                                    "Teste cross-plataforma com qemacs ou docker para diferentes arches"
                                  ],
                                  "verification": "Todos erros são resolvidos, executável roda e produz output esperado sem crashes",
                                  "estimatedTime": "30-45 minutos",
                                  "materials": [
                                    "GDB debugger",
                                    "nm, objdump (binutils)",
                                    "Programa de teste com erros intencionais"
                                  ],
                                  "tips": [
                                    "Declare _start como entry point global",
                                    "Evite relocações absolutas em posição-independente code"
                                  ],
                                  "learningObjective": "Diagnosticar e corrigir erros de símbolos, relocação e linkagem",
                                  "commonMistakes": [
                                    "Não exportar símbolos com .global",
                                    "Usar endereços absolutos em relocável code",
                                    "Ignorar ABI mismatches"
                                  ]
                                }
                              ],
                              "practicalExample": "Programa C 'hello.c': #include <stdio.h> int main() { printf(\"Hello, World!\\n\"); return 0; }. Execute: gcc -S hello.c -o hello.s; as hello.s -o hello.o; ld hello.o -lc -dynamic-linker /lib64/ld-linux-x86-64.so.2 -o hello; ./hello (output: Hello, World!). Depure removendo .global _start para simular undefined symbol.",
                              "finalVerifications": [
                                "Gera assembly válido de C sem erros",
                                "Monta .o e verifica seções com readelf",
                                "Linka para executável funcional",
                                "Corrige undefined symbol adicionando .global",
                                "Resolve relocation error ajustando labels",
                                "Executa e debuga com GDB sem crashes"
                              ],
                              "assessmentCriteria": [
                                "Precisão nos comandos gcc -S, as e ld (sem syntax errors)",
                                "Identificação correta de erros de símbolos/relocação",
                                "Análise válida via objdump/readelf/nm",
                                "Executável roda e produz output correto",
                                "Debug eficaz com GDB para falhas",
                                "Explicação clara de cada etapa"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Representação binária e aritmética de endereços (relocação)",
                                "Engenharia de Computadores: Arquitetura ISA (x86/ARM) e pipeline",
                                "Física: Eletrônica digital e execução em hardware",
                                "Desenvolvimento de Software: Otimização e profiling de binários",
                                "Segurança da Informação: Análise de binários para reverse engineering"
                              ],
                              "realWorldApplication": "Desenvolvimento de firmware embarcado (IoT), kernels de SO (Linux modules), debugging de crashes em produção (core dumps), compilação cross-plataforma para dispositivos móveis/embedded, e auditoria de segurança em binários legados."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.6.5",
                    "name": "Otimizações em Código Intermediário",
                    "description": "Técnicas para melhorar eficiência do código intermediário antes da geração final.",
                    "individualConcepts": [
                      {
                        "id": "10.1.6.5.1",
                        "name": "Otimizações Locais",
                        "description": "Técnicas de otimização aplicadas em blocos básicos de código intermediário, sem considerar o fluxo de controle entre blocos.",
                        "specificSkills": [
                          {
                            "id": "10.1.6.5.1.1",
                            "name": "Dobradura de Constantes (Constant Folding)",
                            "description": "Identificar e avaliar expressões com constantes conhecidas no tempo de compilação para substituir por seus valores computados, reduzindo operações em tempo de execução.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o Conceito de Dobradura de Constantes",
                                  "subSteps": [
                                    "Estude a definição: substituição de expressões com constantes conhecidas por seus valores computados no tempo de compilação.",
                                    "Analise exemplos básicos como '2 + 3' tornando-se '5'.",
                                    "Diferencie de outras otimizações, como propagação de constantes.",
                                    "Revise o ciclo de compilação e onde o folding ocorre (código intermediário).",
                                    "Discuta benefícios: redução de operações em runtime."
                                  ],
                                  "verification": "Resuma em suas palavras o que é constant folding e dê um exemplo simples.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Documentação de compiladores (GCC manual)",
                                    "Vídeo introdutório sobre otimizações de compiladores"
                                  ],
                                  "tips": "Use diagramas para visualizar o antes e depois da otimização.",
                                  "learningObjective": "Entender o propósito e o momento da aplicação da dobradura de constantes.",
                                  "commonMistakes": [
                                    "Confundir com avaliação em runtime.",
                                    "Ignorar expressões com variáveis mistas."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar Expressões Elegíveis para Folding",
                                  "subSteps": [
                                    "Examine código intermediário ou assembly para constantes literais.",
                                    "Identifique operadores aritméticos, lógicos e bitwise com apenas constantes.",
                                    "Ignore expressões com variáveis ou chamadas de função.",
                                    "Pratique com expressões compostas como '(2 + 3) * 4'.",
                                    "Use ferramentas para destacar constantes automaticamente."
                                  ],
                                  "verification": "Marque todas as expressões foldingáveis em um código fornecido.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Editor de código com sintaxe highlight",
                                    "Exemplos de IR do LLVM"
                                  ],
                                  "tips": "Comece com expressões simples antes de compostas.",
                                  "learningObjective": "Reconhecer precisamente quais expressões podem ser otimizadas via folding.",
                                  "commonMistakes": [
                                    "Aplicar folding em expressões com variáveis.",
                                    "Esquecer operadores unários como -5."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Realizar a Dobradura e Substituição",
                                  "subSteps": [
                                    "Calcule o valor da expressão usando aritmética precisa (evite overflow).",
                                    "Substitua a expressão original pelo valor computado.",
                                    "Atualize o código intermediário manualmente.",
                                    "Teste com expressões lógicas como 'true && false' -> false.",
                                    "Registre o código antes e depois para comparação."
                                  ],
                                  "verification": "Transforme um trecho de código e confirme que o resultado é equivalente.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Calculadora ou interpretador Python para verificação",
                                    "Templates de código intermediário"
                                  ],
                                  "tips": "Sempre verifique overflow em inteiros grandes.",
                                  "learningObjective": "Executar corretamente o folding em expressões variadas.",
                                  "commonMistakes": [
                                    "Erros de cálculo simples.",
                                    "Não propagar mudanças em expressões aninhadas."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Avaliar o Impacto e Integrar em Otimizações",
                                  "subSteps": [
                                    "Compare o número de instruções antes e depois do folding.",
                                    "Meça redução em operações de runtime.",
                                    "Integre com outras otimizações locais como eliminação de código morto.",
                                    "Simule execução para validar equivalência semântica.",
                                    "Documente o ganho de performance em um relatório curto."
                                  ],
                                  "verification": "Gere relatório mostrando redução de instruções em pelo menos 20%.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Simulador de assembly simples",
                                    "Ferramentas como Godbolt para visualização"
                                  ],
                                  "tips": "Use contadores de instruções para quantificar benefícios.",
                                  "learningObjective": "Analisar e quantificar os ganhos da dobradura de constantes.",
                                  "commonMistakes": [
                                    "Ignorar custos de compilação.",
                                    "Alterar semântica do programa."
                                  ]
                                }
                              ],
                              "practicalExample": "Código IR inicial: add i32 5, 3; mul i32 %result, 4\nApós folding: add i32 8; mul i32 %result, 4 (5+3=8 pré-computado). Isso reduz 1 operação ADD em runtime.",
                              "finalVerifications": [
                                "Identifica corretamente 100% das expressões elegíveis em um código teste.",
                                "Executa folding sem erros aritméticos em 5 exemplos variados.",
                                "Compara antes/depois mostrando redução de instruções.",
                                "Explica benefícios em termos de performance de runtime.",
                                "Integra folding com outra otimização local.",
                                "Valida equivalência semântica manualmente."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de expressões (90%+ acerto).",
                                "Correção nos cálculos de folding (sem overflow ou erros).",
                                "Quantificação clara de ganhos (redução % de ops).",
                                "Documentação completa de passos e raciocínio.",
                                "Criatividade em exemplos compostos e aninhados.",
                                "Compreensão de limitações (ex: side-effects)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Avaliação de expressões algébricas e aritmética modular.",
                                "Programação: Otimização de código fonte e análise estática.",
                                "Engenharia de Software: Melhoria de performance em sistemas embarcados.",
                                "Lógica: Simplificação de expressões booleanas.",
                                "Física Computacional: Otimizações em simulações numéricas."
                              ],
                              "realWorldApplication": "Compiladores como GCC e LLVM usam constant folding para acelerar programas reais, reduzindo overhead em loops matemáticos de jogos, simulações científicas e apps mobile, economizando bateria e CPU."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.6.5.1.2",
                            "name": "Eliminação de Código Morto (Dead Code Elimination)",
                            "description": "Detectar e remover instruções que nunca são executadas ou cujos resultados não são utilizados, simplificando o código intermediário.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender Conceitos Fundamentais de Código Morto",
                                  "subSteps": [
                                    "Defina código morto como instruções não executáveis ou cujos resultados não são usados.",
                                    "Classifique tipos: código inalcançável (dead code) e código morto parcial (unused computations).",
                                    "Analise fluxograma de controle para identificar caminhos não percorridos.",
                                    "Estude exemplos simples em pseudocódigo ou assembly intermediário.",
                                    "Diferencie de código vivo usando análise de fluxo de dados básica."
                                  ],
                                  "verification": "Explique em suas palavras os dois tipos de código morto com um exemplo de cada.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Documentação de compiladores (ex: Dragon Book capítulo sobre otimizações)",
                                    "Editor de texto para pseudocódigo"
                                  ],
                                  "tips": "Use diagramas de fluxo para visualizar melhor o controle de execução.",
                                  "learningObjective": "Identificar e diferenciar tipos de código morto em representações de código intermediário.",
                                  "commonMistakes": "Confundir código condicional raramente executado com código morto verdadeiro."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar Detecção de Código Morto",
                                  "subSteps": [
                                    "Construa um analisador de controle de fluxo (CFG - Control Flow Graph).",
                                    "Aplique análise de alcance (reaching definitions) para marcar variáveis usadas.",
                                    "Identifique nós no CFG sem saídas ou cujas definições não alcançam usos.",
                                    "Marque instruções como 'dead' se não contribuírem para saídas do programa.",
                                    "Teste com código intermediário simples contendo ifs desnecessários."
                                  ],
                                  "verification": "Gere um relatório listando linhas de código morto detectadas em um exemplo fornecido.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Ferramenta de análise estática como LLVM ou pseudocódigo em Python",
                                    "Exemplos de IR (Intermediate Representation)"
                                  ],
                                  "tips": "Comece com grafos pequenos para depurar sua análise de fluxo.",
                                  "learningObjective": "Desenvolver algoritmo para detectar automaticamente código morto usando CFG.",
                                  "commonMistakes": "Ignorar loops ou recursão, levando a falsos positivos em detecção."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Executar Remoção de Código Morto",
                                  "subSteps": [
                                    "Traverse o CFG e remova nós marcados como dead.",
                                    "Atualize referências de controle de fluxo nos nós adjacentes.",
                                    "Propague otimizações para código circundante (ex: remover branches vazios).",
                                    "Gere o novo código intermediário simplificado.",
                                    "Valide semântica comparando entradas/saídas antes e depois."
                                  ],
                                  "verification": "Forneça código intermediário antes/depois e prove equivalência funcional.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Compilador toy como um parser de mini-linguagem",
                                    "Ferramentas de diff para código"
                                  ],
                                  "tips": "Mantenha uma cópia do original para testes de regressão.",
                                  "learningObjective": "Aplicar transformação segura de remoção de código morto preservando comportamento.",
                                  "commonMistakes": "Remover código com side-effects como I/O ou exceções."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Avaliar e Iterar Otimizações",
                                  "subSteps": [
                                    "Meça redução de tamanho/instruções executadas pós-eliminação.",
                                    "Execute múltiplas passes de eliminação até ponto fixo (sem mudanças).",
                                    "Integre com outras otimizações locais como constante folding.",
                                    "Teste em benchmarks com código realista.",
                                    "Documente limitações (ex: exceções dinâmicas)."
                                  ],
                                  "verification": "Demonstre convergência em pelo menos dois passes e métricas de melhoria.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Benchmarks de otimizações (ex: SPEC ou polybench)",
                                    "Profiler de código"
                                  ],
                                  "tips": "Use asserts para garantir que otimizações não alterem resultados.",
                                  "learningObjective": "Avaliar eficácia da eliminação de código morto em cenários iterativos.",
                                  "commonMistakes": "Parar cedo sem atingir ponto fixo, deixando código morto residual."
                                }
                              ],
                              "practicalExample": "Código intermediário inicial:\n1: x = 5\n2: if false goto 4\n3: y = x * 2  // dead code\n4: print(z)\nApós eliminação: 1: x=5\n4: print(z)  // y removido, branch morto eliminado.",
                              "finalVerifications": [
                                "Código intermediário reduzido em pelo menos 20% sem perda de funcionalidade.",
                                "Todos os caminhos de execução originais preservados ou simplificados.",
                                "Nenhuma variável morta ou instrução inalcançável permanece.",
                                "Testes unitários passam antes e depois da otimização.",
                                "Análise de fluxo confirma ausência de dead code.",
                                "Métricas de performance mostram melhoria ou neutralidade."
                              ],
                              "assessmentCriteria": [
                                "Precisão na detecção (zero falsos negativos em exemplos testados).",
                                "Corretude da remoção (equivalência semântica comprovada).",
                                "Eficiência algorítmica (tempo polinomial em tamanho do CFG).",
                                "Cobertura de casos edge como loops e exceções.",
                                "Documentação clara de passos e raciocínio.",
                                "Integração com otimizações complementares."
                              ],
                              "crossCurricularConnections": [
                                "Análise de Grafos (Matemática: teoria dos grafos para CFG).",
                                "Programação Funcional (imutabilidade facilita detecção de unused computations).",
                                "Engenharia de Software (refatoração e limpeza de código legado).",
                                "Análise de Dados (detecção de features irrelevantes em ML pipelines)."
                              ],
                              "realWorldApplication": "Em compiladores como GCC/LLVM, reduz tamanho de binários e tempo de execução em apps mobile/web; JIT compilers em V8/Node.js eliminam dead code dinamicamente para performance em servidores."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.6.5.1.3",
                            "name": "Redução de Força (Strength Reduction)",
                            "description": "Substituir operações custosas, como multiplicações por constantes, por operações mais eficientes, como adições ou shifts.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o Conceito de Redução de Força",
                                  "subSteps": [
                                    "Estude a definição: substituir operações caras (ex: multiplicação) por mais baratas (ex: shifts ou adições).",
                                    "Analise o custo em ciclos de CPU: multiplications ~10-20 ciclos vs shifts ~1 ciclo.",
                                    "Revise exemplos básicos: x * 2 = x << 1; x * 4 = x << 2.",
                                    "Entenda pré-requisitos: aritmética de ponto fixo e representação binária.",
                                    "Compare com outras otimizações locais como eliminação de código morto."
                                  ],
                                  "verification": "Resuma em suas palavras o que é redução de força e dê 2 exemplos simples.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Documentação de compiladores (GCC/LLVM)",
                                    "Artigos sobre otimizações de compiladores"
                                  ],
                                  "tips": "Foquem em constantes conhecidas em tempo de compilação.",
                                  "learningObjective": "Explicar o propósito e benefícios da redução de força em otimizações locais.",
                                  "commonMistakes": [
                                    "Confundir com redução de força em loops (é local)",
                                    "Ignorar overflow em shifts"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar Oportunidades em Código Intermediário",
                                  "subSteps": [
                                    "Examine IR (Intermediate Representation) ou assembly de alto nível por multiplicações por constantes.",
                                    "Liste padrões: *2, *3 (x<<1 + x), *5 (x<<2 + x), etc.",
                                    "Use ferramentas como Godbolt Compiler Explorer para visualizar IR.",
                                    "Identifique em loops ou expressões repetidas.",
                                    "Marque operações candidatas sem alterar o código ainda."
                                  ],
                                  "verification": "Em um trecho de código dado, liste todas as oportunidades de redução de força.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Compiler Explorer (godbolt.org)",
                                    "Exemplos de código C simples"
                                  ],
                                  "tips": "Priorize constantes pequenas (potências de 2 são ideais).",
                                  "learningObjective": "Detectar precisamente operações elegíveis para strength reduction.",
                                  "commonMistakes": [
                                    "Aplicar em multiplicações por variáveis",
                                    "Esquecer divisões por potências de 2 (shifts right)"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Aplicar Transformações de Redução de Força",
                                  "subSteps": [
                                    "Substitua x * k por equivalente: shifts + adições (ex: x*3 = (x<<1) + x).",
                                    "Gere sequências ótimas para constantes maiores usando minimal additions.",
                                    "Ajuste para signed/unsigned e verifique corretude semântica.",
                                    "Implemente em pseudocódigo ou passe IR.",
                                    "Teste com valores de entrada variados."
                                  ],
                                  "verification": "Transforme 3 expressões dadas e comprove igualdade numérica.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Papel e lápis para tabelas de multiplicação",
                                    "Calculadora ou script Python para validação"
                                  ],
                                  "tips": "Use algoritmo de 'multiplicação por adições' para otimizar.",
                                  "learningObjective": "Executar transformações corretas e eficientes manualmente.",
                                  "commonMistakes": [
                                    "Erro em carry/overflow para números negativos",
                                    "Usar mais operações que o original"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificar e Integrar a Otimização",
                                  "subSteps": [
                                    "Compare performance: conte instruções ou use benchmark simples.",
                                    "Valide semântica: execute antes/depois com test cases.",
                                    "Integre em fluxo de compilador: após análise de dependências.",
                                    "Considere interações com outras otimizações (ex: CSE).",
                                    "Documente a transformação aplicada."
                                  ],
                                  "verification": "Forneça código otimizado que passa todos os testes e é mais eficiente.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Compilador com -O3",
                                    "Ferramentas de profiling (perf)"
                                  ],
                                  "tips": "Sempre preserve precisão numérica.",
                                  "learningObjective": "Avaliar impacto e garantir corretude da otimização.",
                                  "commonMistakes": [
                                    "Quebrar corretude por assumições erradas sobre inteiros",
                                    "Otimizar prematuramente sem medição"
                                  ]
                                }
                              ],
                              "practicalExample": "Código original: for(int i=0; i<100; i++) { y = x * 10; } → Otimizado: y = (x << 3) + (x << 1); (pois 10=8+2). Reduz de 100 multiplicações para shifts+adições, ~10x mais rápido em CPUs antigas.",
                              "finalVerifications": [
                                "Explique redução de força com exemplo próprio.",
                                "Identifique e otimize 5 expressões em código IR.",
                                "Prove equivalência algébrica de uma transformação.",
                                "Meça diferença de performance em benchmark simples.",
                                "Discuta limitações (ex: floats não aplicável)."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de oportunidades (100% recall).",
                                "Corretude das transformações (sem erros semânticos).",
                                "Eficiência: número mínimo de operações pós-otimização.",
                                "Explicação clara de cada passo.",
                                "Uso de ferramentas para validação.",
                                "Consideração de casos edge (negativos, zero)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Álgebra linear e propriedades de shifts binários.",
                                "Arquitetura de Computadores: Latência de instruções ALU.",
                                "Programação: Otimização de código em linguagens de alto nível.",
                                "Engenharia de Software: Trade-offs performance vs legibilidade."
                              ],
                              "realWorldApplication": "Usado em compiladores como GCC/LLVM para otimizar firmware embarcado (IoT), jogos (loops intensivos) e kernels de SO, reduzindo consumo de energia e latência em dispositivos com CPUs limitadas."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.6.5.2",
                        "name": "Otimizações Globais",
                        "description": "Técnicas que analisam o fluxo de dados e controle em todo o programa para otimizar além de blocos individuais.",
                        "specificSkills": [
                          {
                            "id": "10.1.6.5.2.1",
                            "name": "Eliminação de Subexpressões Comuns (Common Subexpression Elimination - CSE)",
                            "description": "Identificar expressões computadas múltiplas vezes e reutilizar seus resultados armazenados em registradores temporários.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o Conceito Básico de Eliminação de Subexpressões Comuns (CSE)",
                                  "subSteps": [
                                    "Estude a definição: CSE identifica expressões idênticas computadas múltiplas vezes e as substitui por uma única computação armazenada em um registrador temporário.",
                                    "Analise exemplos simples em código intermediário, como t1 = a + b; x = t1 * c; y = t1 * d.",
                                    "Identifique os benefícios: redução de operações redundantes, melhoria na performance e menor uso de registradores.",
                                    "Diferencie CSE local (dentro de bloco básico) de global (através de blocos).",
                                    "Revise impactos em expressões com efeitos colaterais (ex: funções com side-effects)."
                                  ],
                                  "verification": "Explique em suas palavras o que é CSE e dê um exemplo simples de antes e depois.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Notas de compiladores",
                                    "Editor de texto para exemplos de código",
                                    "Vídeo introdutório sobre otimizações de compiladores"
                                  ],
                                  "tips": [
                                    "Comece com exemplos lineares antes de fluxos complexos.",
                                    "Lembre-se: CSE só aplica a expressões puras sem side-effects."
                                  ],
                                  "learningObjective": "Dominar a definição, benefícios e limitações da CSE.",
                                  "commonMistakes": [
                                    "Aplicar CSE em expressões com side-effects.",
                                    "Confundir com simplificação algébrica constante."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar Subexpressões Comuns em Código Intermediário",
                                  "subSteps": [
                                    "Represente o código em forma de três endereços (three-address code).",
                                    "Percorra o código sequencialmente marcando expressões computadas.",
                                    "Use uma tabela de símbolos para rastrear valores de registradores temporários.",
                                    "Detecte expressões idênticas comparando operandos e operadores.",
                                    "Considere o escopo: local dentro de bloco básico."
                                  ],
                                  "verification": "Marque todas as subexpressões comuns em um trecho de código fornecido.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Papel e caneta para diagramação",
                                    "Exemplos de código intermediário impressos",
                                    "Ferramenta online de simulador de compilador"
                                  ],
                                  "tips": [
                                    "Use hashing para expressões complexas em implementações reais.",
                                    "Ignore registradores diferentes com mesmo valor sem análise de fluxo."
                                  ],
                                  "learningObjective": "Habilidade para detectar manualmente subexpressões comuns.",
                                  "commonMistakes": [
                                    "Marcar expressões semelhantes mas não idênticas.",
                                    "Ignorar ordem de operandos em operações não-comutativas."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Aplicar CSE Local em Blocos Básicos",
                                  "subSteps": [
                                    "Insira um registrador temporário para a primeira ocorrência da subexpressão.",
                                    "Substitua todas as ocorrências subsequentes pelo temporário.",
                                    "Atualize a tabela de símbolos com o novo temporário.",
                                    "Verifique se não há redefinições entre as ocorrências.",
                                    "Reescreva o código otimizado e compare com o original."
                                  ],
                                  "verification": "Transforme um bloco básico com subexpressões comuns em código otimizado.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Editor de código como VS Code",
                                    "Templates de código intermediário"
                                  ],
                                  "tips": [
                                    "Sempre nomeie temporários de forma única (ex: t1, t2).",
                                    "Teste manualmente computando valores para validar."
                                  ],
                                  "learningObjective": "Executar CSE local de forma correta e eficiente.",
                                  "commonMistakes": [
                                    "Substituir em locais onde a subexpressão foi redefinida.",
                                    "Esquecer de propagar o temporário corretamente."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Estender para CSE Global com Análise de Fluxo Básica",
                                  "subSteps": [
                                    "Construa o grafo de fluxo de controle (CFG) do código intermediário.",
                                    "Realize análise de fluxo de dados para disponibilidade de expressões (available expressions).",
                                    "Propague temporários através de caminhos comuns no CFG.",
                                    "Insira computações no ponto de entrada comum (dominator).",
                                    "Valide a correção sem introduzir erros de dependência."
                                  ],
                                  "verification": "Otimize um CFG simples aplicando CSE global.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Ferramenta de desenho de grafos (Draw.io)",
                                    "Simulador de análise de fluxo online"
                                  ],
                                  "tips": [
                                    "Comece com funções sem loops para simplicidade.",
                                    "Use conjuntos de bit para análise eficiente em escala."
                                  ],
                                  "learningObjective": "Aplicar CSE em contextos globais considerando fluxo de controle.",
                                  "commonMistakes": [
                                    "Propagar temporários sem verificar dominadores.",
                                    "Ignorar merges de caminhos com valores diferentes."
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Verificar e Avaliar a Otimização CSE",
                                  "subSteps": [
                                    "Compare o código original e otimizado contando operações redundantes eliminadas.",
                                    "Simule execução com valores de teste para equivalência semântica.",
                                    "Meça redução estimada em ciclos de CPU ou registradores usados.",
                                    "Identifique casos onde CSE não aplica (loops, side-effects).",
                                    "Documente o processo para revisão."
                                  ],
                                  "verification": "Produza um relatório de otimização com métricas para um exemplo dado.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Planilha para contagem de operações",
                                    "Interpretador simples de three-address code"
                                  ],
                                  "tips": [
                                    "Use asserts para verificação automática em código.",
                                    "Considere profiling para impactos reais."
                                  ],
                                  "learningObjective": "Avaliar a efetividade e correção da CSE aplicada.",
                                  "commonMistakes": [
                                    "Declarar otimização sem verificar equivalência.",
                                    "Superestimar benefícios sem medição."
                                  ]
                                }
                              ],
                              "practicalExample": "Código original (three-address):\n1: t1 = a * b\n2: t2 = t1 + c\n3: t3 = a * b\n4: t4 = t3 - d\nOtimizado com CSE local:\n1: t1 = a * b\n2: t2 = t1 + c\n3: t5 = t1 - d  // t3 substituído por t1, t4 por t5\nResultado: Eliminou uma multiplicação redundante.",
                              "finalVerifications": [
                                "Identificar corretamente todas as subexpressões comuns em um bloco básico dado.",
                                "Aplicar CSE local sem introduzir erros semânticos.",
                                "Construir um CFG simples e detectar expressões disponíveis globalmente.",
                                "Otimizar um exemplo global produzindo código equivalente mas mais eficiente.",
                                "Explicar limitações da CSE em cenários com side-effects ou loops.",
                                "Medir e justificar a redução de operações em um caso prático."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de subexpressões (100% das comuns detectadas).",
                                "Correção semântica: código otimizado produz mesmos resultados.",
                                "Eficiência: redução mensurável de operações redundantes.",
                                "Uso adequado de temporários sem conflitos de nomes.",
                                "Consideração de escopo global com análise de fluxo básica.",
                                "Documentação clara do processo de otimização."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Simplificação algébrica e fatoração de expressões.",
                                "Programação: Otimização de código em linguagens como C++ ou assembly.",
                                "Engenharia de Software: Análise de performance e profiling.",
                                "Algoritmos: Análise de fluxo de dados e grafos direcionados.",
                                "Física Computacional: Otimização em simulações numéricas."
                              ],
                              "realWorldApplication": "Em compiladores como GCC e LLVM, CSE reduz o tempo de execução de programas reais em até 10-20% em benchmarks como SPEC, otimizando kernels computacionais intensivos como multiplicações em loops de processamento de imagens ou simulações científicas."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.6.5.2.2",
                            "name": "Propagação de Constantes (Constant Propagation)",
                            "description": "Propagar valores constantes através do fluxo de dados para simplificar expressões e habilitar outras otimizações.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os Fundamentos da Propagação de Constantes",
                                  "subSteps": [
                                    "Estude a definição: Propagação de constantes substitui variáveis com valores conhecidos em todos os caminhos por constantes literais.",
                                    "Analise a motivação: Simplifica expressões, reduz operações e habilita otimizações como eliminação de código morto.",
                                    "Identifique pré-requisitos: Conhecimento de análise de fluxo de dados forward e reaching definitions.",
                                    "Revise exemplos básicos: x = 5; y = x + 3; → y = 8.",
                                    "Discuta limitações iniciais: Não propaga em caminhos condicionais incertos."
                                  ],
                                  "verification": "Explique em suas palavras o que é propagação de constantes e dê um exemplo simples transformado.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Documentação de compiladores (LLVM ou GCC)",
                                    "Slides ou vídeo sobre otimizações locais/globais"
                                  ],
                                  "tips": "Comece com exemplos lineares sem branches para construir intuição.",
                                  "learningObjective": "Entender o propósito e benefícios da propagação de constantes em otimizações de compiladores.",
                                  "commonMistakes": [
                                    "Confundir com folding de constantes (local vs global)",
                                    "Ignorar dependências de controle de fluxo"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Modelar o Lattice de Valores Constantes",
                                  "subSteps": [
                                    "Defina o lattice: ⊤ (topo: desconhecido), constantes específicas, ⊥ (fundo: não constante).",
                                    "Aprenda operações: meet (∧) para interseção de constantes (igual → constante, diferente → ⊤).",
                                    "Estude funções de transferência: para atribuições (x = 5 → {x:5}), usos propagam valores.",
                                    "Implemente um diagrama de lattice para 2-3 variáveis.",
                                    "Pratique computação de meet em exemplos: {x:5} ∧ {x:7} = ⊤."
                                  ],
                                  "verification": "Construa e explique um lattice para um programa simples com 3 variáveis.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Papel e lápis para diagramas",
                                    "Ferramenta online de lattices (opcional)"
                                  ],
                                  "tips": "Visualize o lattice como um diagrama Hasse para melhor compreensão.",
                                  "learningObjective": "Dominar a estrutura de dados abstrata usada para representar informações de constantes.",
                                  "commonMistakes": [
                                    "Usar union em vez de interseção para meet",
                                    "Esquecer valores ⊤ e ⊥"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Definir e Resolver Equações de Fluxo de Dados",
                                  "subSteps": [
                                    "Escreva equações forward: IN[B] = ∧_{p→B} OUT[p], OUT[B] = GEN[B](IN[B]) ∧ KILL[B].",
                                    "Identifique GEN e KILL: GEN para atribuições constantes, KILL para redefinições.",
                                    "Aplique iteração até ponto fixo em um grafo de fluxo de controle (CFG) simples.",
                                    "Trate branches e merges: propagação condicional em caminhos divergentes.",
                                    "Teste manualmente em um CFG com loop e if-statement."
                                  ],
                                  "verification": "Resolva as equações para um CFG dado e liste os valores propagados por bloco.",
                                  "estimatedTime": "90 minutos",
                                  "materials": [
                                    "Exemplos de CFG em PDF ou ferramenta como LLVM IR viewer"
                                  ],
                                  "tips": "Use tabelas para rastrear IN/OUT por iteração; pare quando não mudar.",
                                  "learningObjective": "Aplicar análise de fluxo de dados iterativa para inferir constantes globais.",
                                  "commonMistakes": [
                                    "Confundir direção forward/backward",
                                    "Não iterar até convergência"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Implementar Propagação e Verificar Otimizações",
                                  "subSteps": [
                                    "Codifique um pass simples em pseudocódigo ou Python para propagar constantes.",
                                    "Substitua usos por constantes e simplifique expressões (folding secundário).",
                                    "Teste em benchmarks: compare código antes/depois em tamanho e performance.",
                                    "Analise impacto: Meça redução de instruções e habilitação de DCE (dead code elimination).",
                                    "Debug casos falhos: loops indefinidos ou ponteiros."
                                  ],
                                  "verification": "Implemente e rode o algoritmo em um exemplo, mostrando código otimizado.",
                                  "estimatedTime": "120 minutos",
                                  "materials": [
                                    "Editor de código (VS Code)",
                                    "Biblioteca Python como NetworkX para CFGs"
                                  ],
                                  "tips": "Comece com IR simples (três endereços); integre com visitor pattern.",
                                  "learningObjective": "Implementar e validar propagação de constantes em um compilador intermediário.",
                                  "commonMistakes": [
                                    "Propagar prematuramente sem fixpoint",
                                    "Não atualizar CFG após substituições"
                                  ]
                                }
                              ],
                              "practicalExample": "Programa original em IR: 1: a = 10; 2: if cond goto 4; 3: a = 20; 4: b = a + 5; Após propagação: ramo 1-4: b=15; ramo 2-3-4: b ⊤ (não simplificado). Código otimizado remove usos desnecessários e habilita DCE em a=20 se não usado.",
                              "finalVerifications": [
                                "Explique diferenças entre propagação local e global.",
                                "Resolva manualmente constantes em um CFG com loop.",
                                "Implemente um pass que propague pelo menos 80% das constantes em um teste.",
                                "Identifique quando propagação falha (ex: input dependente).",
                                "Meça speedup em um microbenchmark antes/depois.",
                                "Discuta interação com outras otimizações (ex: CSE)."
                              ],
                              "assessmentCriteria": [
                                "Precisão na modelagem do lattice (sem erros em meet operations).",
                                "Correção das equações de dataflow e convergência ao fixpoint.",
                                "Implementação funcional que produz IR otimizado idêntico ao esperado.",
                                "Cobertura de casos edge (branches, loops, undef values).",
                                "Explicação clara de limitações e extensões (ex: sparse conditional).",
                                "Eficiência: convergência em <10 iterações para CFGs médios."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria de lattices e semilattices em análise abstrata.",
                                "Programação: Análise estática e passes de otimização em linguagens funcionais.",
                                "Engenharia de Software: Refatoração automatizada e code generation.",
                                "Algoritmos: Grafos de fluxo de controle e iteração dataflow."
                              ],
                              "realWorldApplication": "Usado em compiladores como GCC (-fstrict-aliasing) e LLVM (instcombine pass) para gerar código nativo 10-30% menor e mais rápido em apps como browsers (Chrome V8) e jogos (Unity), reduzindo uso de cache e energia em dispositivos móveis."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.6.5.2.3",
                            "name": "Otimização de Loops",
                            "description": "Aplicar técnicas como fortalecimento de laços, rotação de código e unrolling para melhorar a eficiência de iterações.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender Conceitos Fundamentais de Otimização de Loops",
                                  "subSteps": [
                                    "Estude strength reduction: substituição de operações caras (ex: multiplicação) por mais baratas (ex: adição acumulada).",
                                    "Analise loop unrolling: replicação do corpo do loop para reduzir testes de condição e incrementos.",
                                    "Explore code rotation: mover código invariante do loop para fora ou reorganizar para melhor cache locality.",
                                    "Revise exemplos em código intermediário como IR de LLVM ou três endereços.",
                                    "Compare overhead de loops antes e depois das otimizações."
                                  ],
                                  "verification": "Explique cada técnica em suas próprias palavras e forneça pseudocódigo para cada uma.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Documentação LLVM IR",
                                    "Livro 'Compilers: Principles, Techniques, and Tools'",
                                    "Editor de código com suporte a IR"
                                  ],
                                  "tips": "Use diagramas de fluxo para visualizar transformações de código.",
                                  "learningObjective": "Identificar e descrever as três técnicas principais de otimização de loops.",
                                  "commonMistakes": "Confundir strength reduction com divisão de loop; ignorar dependências de dados."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar Oportunidades de Otimização em Código Intermediário",
                                  "subSteps": [
                                    "Analise um loop de exemplo: identifique multiplicações por constante dentro do loop.",
                                    "Detecte código invariante: variáveis que não mudam por iteração.",
                                    "Avalie fatores de unrolling: verifique se o loop tem número fixo de iterações ou stride constante.",
                                    "Use ferramentas como opt do LLVM para inspecionar IR antes da otimização.",
                                    "Anote potenciais ganhos: reduções em instruções ou melhorias em ILP."
                                  ],
                                  "verification": "Marque em um código IR as linhas candidatas para cada otimização e justifique.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "LLVM opt tool",
                                    "Exemplos de IR de loops comuns",
                                    "Calculadora de ciclos CPU"
                                  ],
                                  "tips": "Procure por padrões como i * k onde k é constante.",
                                  "learningObjective": "Reconhecer padrões em loops que beneficiam de otimizações globais.",
                                  "commonMistakes": "Aplicar unrolling em loops com dependências de escrita; ignorar overhead de código maior."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar Strength Reduction e Code Rotation",
                                  "subSteps": [
                                    "Aplique strength reduction: transforme i * 5 em i += 5 com inicialização.",
                                    "Mova código invariante: extraia expressões como sin(x) fora do loop.",
                                    "Implemente rotação: reorganize o loop para hoistear condições iniciais.",
                                    "Teste a transformação manualmente em um compilador de três endereços.",
                                    "Valide semântica: execute antes/depois para igualdade de resultados."
                                  ],
                                  "verification": "Gere IR otimizado e confirme ausência de operações caras no loop.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Compilador custom ou LLVM pass simples",
                                    "Benchmark tool como perf"
                                  ],
                                  "tips": "Mantenha precisão numérica; use tipos fixos quando possível.",
                                  "learningObjective": "Executar transformações de strength reduction e code rotation corretamente.",
                                  "commonMistakes": "Introduzir overflow em adições acumuladas; mover código com side-effects."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar Loop Unrolling e Avaliar Performance",
                                  "subSteps": [
                                    "Escolha fator de unrolling (ex: 4x) baseado em análise estática.",
                                    "Replique o corpo do loop e ajuste condições de saída.",
                                    "Combine com outras otimizações: aplique após strength reduction.",
                                    "Meça performance: compile para assembly e compare ciclos/instruções.",
                                    "Ajuste para cenários reais: considere cache e vetorização."
                                  ],
                                  "verification": "Benchmark mostra redução de 20-50% em tempo de execução no loop.",
                                  "estimatedTime": "2.5 horas",
                                  "materials": [
                                    "GCC/Clang com -O0 vs flags manuais",
                                    "Perf ou Valgrind",
                                    "Datasets de teste variados"
                                  ],
                                  "tips": "Teste com tamanhos de loop variados para generalidade.",
                                  "learningObjective": "Implementar unrolling e quantificar melhorias de performance.",
                                  "commonMistakes": "Unrolling excessivo levando a piora de cache; ignorar loops não-contíguos."
                                }
                              ],
                              "practicalExample": "Otimize este loop IR: for (i=0; i<N; i++) { a[i] = b[i] * 3.14; } -> Strength: pré-compute stride, unroll 4x, motion sin(3.14) out.",
                              "finalVerifications": [
                                "O código otimizado produz resultados idênticos ao original.",
                                "Número de iterações de loop reduzido em pelo menos 50%.",
                                "Instruções dentro do loop diminuídas em 30-70%.",
                                "Benchmark confirma speedup mensurável em hardware real.",
                                "Nenhuma violação de dependências de dados.",
                                "Otimização aplicada corretamente em pelo menos 3 loops diferentes."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de oportunidades (90% acerto).",
                                "Corretude semântica das transformações (testes passam).",
                                "Quantificação de ganhos com métricas (ciclos, IPC).",
                                "Explicação clara de trade-offs (tamanho código vs velocidade).",
                                "Generalização para novos loops sem orientação.",
                                "Integração com outras otimizações globais."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Análise assintótica O(n) vs iterações efetivas.",
                                "Engenharia de Software: Refatoração e profiling de performance.",
                                "Arquitetura de Computadores: Impacto em pipeline, cache e ILP.",
                                "Algoritmos: Otimização de grafos de controle de fluxo.",
                                "Física Computacional: Aceleração de simulações numéricas."
                              ],
                              "realWorldApplication": "Em compiladores como GCC/LLVM, otimiza kernels de ML (ex: convoluções em TensorFlow), jogos (loops de renderização) e bancos de dados (agregações), reduzindo tempo de execução em 20-80% em workloads intensivos."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.6.5.3",
                        "name": "Otimização Peephole",
                        "description": "Otimização por inspeção local de sequências curtas de instruções (janela de visão) para substituições por equivalentes mais eficientes.",
                        "specificSkills": [
                          {
                            "id": "10.1.6.5.3.1",
                            "name": "Implementação de Regras Peephole Básicas",
                            "description": "Definir e aplicar regras simples como remoção de instruções redundantes ou balanceamento de saltos em uma janela de código.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender Conceitos Fundamentais de Otimização Peephole",
                                  "subSteps": [
                                    "Estude a definição de otimização peephole: análise local em uma 'janela' pequena de código assembly ou intermediário.",
                                    "Aprenda exemplos clássicos: remoção de instruções NOP redundantes, eliminação de saltos para si mesmo (jump to next).",
                                    "Analise balanceamento de saltos: converter saltos curtos para curtos e longos para longos.",
                                    "Revise representação de código: use listas ou árvores para simular janelas deslizantes.",
                                    "Pratique identificando padrões manuais em snippets de código assembly simples."
                                  ],
                                  "verification": "Explique em suas palavras 3 regras peephole básicas e identifique-as em um código de exemplo fornecido.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Documentação de compiladores (GCC/LLVM peephole), exemplos de assembly (x86 ou simples RISC), editor de texto"
                                  ],
                                  "tips": "Comece com janelas pequenas (2-4 instruções) para visualizar padrões facilmente.",
                                  "learningObjective": "Dominar os princípios teóricos e exemplos iniciais de peephole para preparar implementação.",
                                  "commonMistakes": [
                                    "Confundir peephole com otimizações globais como dataflow",
                                    "Ignorar dependências entre instruções adjacentes"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Definir e Catalogar Regras Peephole Básicas",
                                  "subSteps": [
                                    "Liste 5 regras simples: ex. 'MOV A, A -> NOP', 'JMP next -> remover', 'short jmp -> short se possível'.",
                                    "Crie uma representação formal: use padrões como strings ou regex para matching.",
                                    "Defina substituições: para cada match, especifique o código de substituição.",
                                    "Priorize regras: ordem de aplicação para evitar conflitos (ex. redundâncias primeiro).",
                                    "Documente em uma tabela: padrão, substituição, benefício (ex. redução de bytes)."
                                  ],
                                  "verification": "Crie um catálogo com 5 regras válidas e valide manualmente em 3 exemplos de código.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Planilha ou Markdown para tabela de regras",
                                    "Snippets de código assembly de testes"
                                  ],
                                  "tips": "Use padrões descritivos como 'ADD R1, 0 -> NOP' para clareza.",
                                  "learningObjective": "Capacitar a criação de regras acionáveis e priorizadas para otimização local.",
                                  "commonMistakes": [
                                    "Regras muito genéricas que causam loops infinitos",
                                    "Esquecer de preservar semântica do programa"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar o Algoritmo de Aplicação de Regras em Código",
                                  "subSteps": [
                                    "Escreva uma função para escanear o código: use uma janela deslizante (tamanho 2-4 instruções).",
                                    "Implemente matching: para cada posição, teste todas as regras na janela.",
                                    "Aplique substituição: reescreva a janela se match, avance a janela.",
                                    "Adicione loop até fixpoint: repita até nenhuma mudança.",
                                    "Estruture em pseudocódigo primeiro, depois em Python ou C para simulação."
                                  ],
                                  "verification": "Execute o código em um input de teste e confirme que aplica pelo menos 3 regras corretamente.",
                                  "estimatedTime": "3 horas",
                                  "materials": [
                                    "Linguagem de programação (Python recomendado para protótipo)",
                                    "Biblioteca de parsing assembly se disponível (ex. Keystone)"
                                  ],
                                  "tips": "Implemente debug prints para visualizar matches e substituições.",
                                  "learningObjective": "Desenvolver código funcional para aplicar regras peephole de forma iterativa.",
                                  "commonMistakes": [
                                    "Janela fixa muito grande causando overhead",
                                    "Não tratar sobreposições de janelas adequadamente"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Testar, Depurar e Avaliar a Implementação",
                                  "subSteps": [
                                    "Crie casos de teste: códigos com redundâncias conhecidas e saltos desbalanceados.",
                                    "Meça métricas: contagem de instruções antes/depois, tempo de execução.",
                                    "Depure falhas: use asserts para semântica preservada (ex. simule execução).",
                                    "Otimize o otimizador: reduza passes desnecessários.",
                                    "Gere relatório: exemplos de antes/depois com estatísticas."
                                  ],
                                  "verification": "Passe em todos os testes unitários e demonstre redução de 20% em tamanho de código em exemplo médio.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Suite de testes assembly",
                                    "Ferramentas de profiling (timeit em Python)"
                                  ],
                                  "tips": "Sempre teste preservação de semântica com interpretador simples.",
                                  "learningObjective": "Garantir robustez e eficácia da otimização peephole implementada.",
                                  "commonMistakes": [
                                    "Alterar semântica (ex. remover instrução essencial)",
                                    "Ignorar performance do otimizador em códigos grandes"
                                  ]
                                }
                              ],
                              "practicalExample": "Dado código assembly: 'MOV R1, 5; ADD R1, 0; JMP label; label: NOP; MOV R2, R2'. Após peephole: 'MOV R1, 5; JMP label; label: MOV R2, R1' (removeu ADD redundante, NOP, MOV idêntico; assumindo balanceamento).",
                              "finalVerifications": [
                                "Implementa corretamente remoção de instruções redundantes como ADD 0 ou MOV reg, reg.",
                                "Balanceia saltos curtos/longos sem quebrar controle de fluxo.",
                                "Atinge fixpoint: múltiplas passadas aplicam todas regras possíveis.",
                                "Preserva semântica: saída executa igual ao input original.",
                                "Reduz tamanho do código em pelo menos 10-20% em testes padrão.",
                                "Funciona em janelas de 2-4 instruções sem erros de sobreposição."
                              ],
                              "assessmentCriteria": [
                                "Correção: Todas regras aplicadas sem alterar comportamento do programa (90% peso).",
                                "Eficiência: Redução mensurável no tamanho/ciclos do código otimizado.",
                                "Robustez: Lida com casos edge como saltos condicionais e registradores variados.",
                                "Clareza: Código bem comentado com documentação de regras.",
                                "Escalabilidade: Performance aceitável em códigos de 100+ instruções.",
                                "Cobertura: Pelo menos 5 regras básicas implementadas e testadas."
                              ],
                              "crossCurricularConnections": [
                                "Algoritmos e Estruturas de Dados: Janelas deslizantes como queues/filas.",
                                "Matemática Discreta: Autômatos finitos para matching de padrões.",
                                "Engenharia de Software: Testes unitários e refatoração em compiladores.",
                                "Análise de Algoritmos: Complexidade O(n) para passes lineares."
                              ],
                              "realWorldApplication": "Usado em compiladores como GCC e LLVM para gerar código assembly mais compacto e eficiente, reduzindo tamanho de binários em dispositivos embarcados (ex. IoT) e melhorando performance em CPUs reais."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.6.5.3.2",
                            "name": "Análise de Padrões Locais",
                            "description": "Identificar padrões ineficientes em código intermediário de três ou mais instruções e substituí-los por versões otimizadas.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender Conceitos Fundamentais de Otimização Peephole e Padrões Locais",
                                  "subSteps": [
                                    "Estude a definição de otimização peephole: análise de janelas pequenas (3+ instruções) em código intermediário.",
                                    "Identifique o escopo 'local': foco em sequências curtas sem dependências globais.",
                                    "Revise representações de código intermediário (ex: três endereços, registradores).",
                                    "Liste categorias de padrões ineficientes: redundâncias, código morto, operações nulas.",
                                    "Analise diagramas de fluxo de peephole optimization em compiladores."
                                  ],
                                  "verification": "Resuma em 3 frases os conceitos chave e liste 4 exemplos de padrões locais.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Documentação de compiladores (LLVM ou GCC peephole docs)",
                                    "Slides ou vídeo sobre geração de código intermediário"
                                  ],
                                  "tips": "Use anotações visuais para mapear janelas de 3-5 instruções.",
                                  "learningObjective": "Dominar os princípios teóricos da análise de padrões locais em peephole.",
                                  "commonMistakes": [
                                    "Confundir análise local com global (ex: loop invariants)",
                                    "Ignorar dependências de registradores entre instruções"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Memorizar e Catalogar Padrões Ineficientes Comuns",
                                  "subSteps": [
                                    "Compile uma tabela de 10 padrões ineficientes para sequências de 3+ instruções (ex: LOAD R1,x; ADD R1,0; STORE R1,y).",
                                    "Classifique padrões: redundância (load/store desnecessário), cancelamento (ADD seguido de SUB idêntico), fortalecimento (MUL por 2 em vez de ADD).",
                                    "Estude regras de substituição para cada padrão.",
                                    "Crie flashcards com 'antes' e 'depois' para cada um.",
                                    "Teste reconhecimento em 5 exemplos aleatórios."
                                  ],
                                  "verification": "Acertar 90% em um quiz de identificação de 10 padrões misturados.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Tabela de padrões peephole (ex: Dragon Book exemplos)",
                                    "Ferramenta Anki para flashcards"
                                  ],
                                  "tips": "Priorize padrões frequentes em código real, como operações com constantes zero.",
                                  "learningObjective": "Reconhecer instantaneamente padrões ineficientes em código intermediário.",
                                  "commonMistakes": [
                                    "Subestimar comprimento mínimo (menos de 3 instruções)",
                                    "Aplicar substituição sem verificar dependências de dados"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Praticar Identificação de Padrões em Trechos de Código",
                                  "subSteps": [
                                    "Selecione um trecho de código intermediário com 20+ instruções.",
                                    "Deslize uma 'janela' de 3-5 instruções ao longo do código, anotando potenciais padrões.",
                                    "Marque todos os padrões encontrados com justificativa.",
                                    "Ignore falsos positivos comparando com análise manual.",
                                    "Registre estatísticas: número de padrões por 100 instruções."
                                  ],
                                  "verification": "Identifique pelo menos 3 padrões reais em um trecho fornecido, sem falsos positivos.",
                                  "estimatedTime": "75 minutos",
                                  "materials": [
                                    "Gerador de código intermediário simples (ex: mini-compilador em Python)",
                                    "Trechos de código de exemplos de compiladores"
                                  ],
                                  "tips": "Comece com janelas fixas de 3 instruções e expanda se necessário.",
                                  "learningObjective": "Aplicar análise de padrões de forma sistemática em código realista.",
                                  "commonMistakes": [
                                    "Sobrepor janelas sem considerar ordem sequencial",
                                    "Perder padrões que se estendem além de 5 instruções"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Implementar Substituições Otimizadas e Verificar Impacto",
                                  "subSteps": [
                                    "Para cada padrão identificado, aplique a regra de substituição otimizada.",
                                    "Reescreva o trecho completo com todas as otimizações aplicadas.",
                                    "Simule execução: compare número de instruções e ciclos estimados antes/depois.",
                                    "Teste com interpretador de código intermediário para validar corretude.",
                                    "Itere: reaplique análise peephole múltiplas vezes até fixpoint."
                                  ],
                                  "verification": "O código otimizado deve reduzir instruções em 20%+ sem alterar semântica.",
                                  "estimatedTime": "90 minutos",
                                  "materials": [
                                    "Simulador de registrador (ex: script Python para execução passo-a-passo)",
                                    "Editor de texto com destaque de sintaxe para assembly intermediário"
                                  ],
                                  "tips": "Sempre verifique preservação de semântica com casos de teste edge.",
                                  "learningObjective": "Transformar detecção em otimização acionável e mensurável.",
                                  "commonMistakes": [
                                    "Alterar semântica (ex: otimizar incorretamente dependências)",
                                    "Não alcançar fixpoint (otimizações adicionais possíveis)"
                                  ]
                                }
                              ],
                              "practicalExample": "Trecho original (5 instruções): LOAD R1, x; ADD R1, 1; STORE R1, temp; LOAD R2, temp; ADD R2, 1. Padrão: store/load redundante em temp. Otimizado: LOAD R1, x; ADD R1, 1; LOAD R2, R1; ADD R2, 1. Redução: 5->4 instruções, elimina temp desnecessário.",
                              "finalVerifications": [
                                "Identificar corretamente 8/10 padrões em um trecho de 50 instruções.",
                                "Aplicar otimizações sem erros semânticos em 3 trechos independentes.",
                                "Reduzir instruções em média 25% em código teste.",
                                "Explicar raciocínio para cada substituição em relatório curto.",
                                "Alcançar fixpoint (sem mais otimizações) em 95% dos casos.",
                                "Simular execução e confirmar equivalência funcional."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de padrões (sem falsos positivos/negativos).",
                                "Corretude das substituições (preservação de semântica).",
                                "Eficiência mensurável (redução de instruções/ciclos).",
                                "Cobertura sistemática (todas janelas analisadas).",
                                "Documentação clara de mudanças e impactos.",
                                "Velocidade de análise (tempo por trecho)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Reconhecimento de padrões algébricos e simplificação de expressões.",
                                "Análise de Dados: Detecção de anomalias e padrões em sequências.",
                                "Lógica e Raciocínio: Simplificação de provas e eliminação de redundâncias.",
                                "Engenharia de Software: Refatoração de código para performance."
                              ],
                              "realWorldApplication": "Em compiladores como LLVM ou GCC, otimização peephole melhora performance de aplicativos reais (ex: reduz latência em jogos ou acelera machine learning), economizando bateria em dispositivos móveis e otimizando data centers."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.6.5.3.3",
                            "name": "Iteração Múltipla em Peephole",
                            "description": "Executar múltiplas passadas de otimização peephole até que não haja mais melhorias, maximizando a eficiência.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os Fundamentos da Otimização Peephole e Iteração Múltipla",
                                  "subSteps": [
                                    "Estude o conceito de otimização peephole: análise de padrões locais em código assembly ou intermediário.",
                                    "Aprenda regras básicas de substituição, como eliminar instruções redundantes ou combinar operações.",
                                    "Entenda por que iterações múltiplas são necessárias: uma passada pode criar novas oportunidades para otimização.",
                                    "Analise exemplos de convergência: quando o processo para (sem mudanças).",
                                    "Revise métricas de eficiência: redução de instruções, ciclos de CPU."
                                  ],
                                  "verification": "Explique em suas palavras o ciclo de iteração e liste 3 regras peephole comuns.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Documentação de compiladores (ex: LLVM peephole docs)",
                                    "Artigos sobre otimização peephole",
                                    "Exemplos de código assembly simples"
                                  ],
                                  "tips": "Comece com diagramas de fluxo para visualizar iterações.",
                                  "learningObjective": "Dominar os princípios teóricos da iteração múltipla em peephole.",
                                  "commonMistakes": [
                                    "Confundir peephole com otimizações globais",
                                    "Ignorar dependências entre instruções"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar uma Única Passada de Otimização Peephole",
                                  "subSteps": [
                                    "Escreva um scanner que identifique padrões de 2-4 instruções em um buffer de código.",
                                    "Defina um conjunto de 5-10 regras de substituição (ex: substituir 'MOV A, B; ADD A, C' por otimizado).",
                                    "Aplique as regras sequencialmente no código, substituindo padrões encontrados.",
                                    "Registre mudanças feitas para análise posterior.",
                                    "Teste em um código assembly curto com redundâncias conhecidas."
                                  ],
                                  "verification": "Execute a passada única e confirme redução de pelo menos 20% no tamanho do código.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Linguagem de programação (Python/C para protótipo)",
                                    "Editor de código",
                                    "Compilador assembly simples (ex: NASM)"
                                  ],
                                  "tips": "Use expressões regulares ou parsers para matching de padrões.",
                                  "learningObjective": "Criar um otimizador peephole funcional para uma iteração.",
                                  "commonMistakes": [
                                    "Regras que criam loops infinitos",
                                    "Não lidar com sobreposições de padrões"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Desenvolver o Loop de Iterações Múltiplas",
                                  "subSteps": [
                                    "Implemente um loop while que repita a passada até zero mudanças.",
                                    "Adicione contador de iterações e limite máximo (ex: 50) para evitar loops infinitos.",
                                    "Monitore métricas por iteração: número de substituições, tamanho do código.",
                                    "Otimize o loop para eficiência, como reiniciar scan do início após mudança.",
                                    "Integre logging para rastrear evolução do código."
                                  ],
                                  "verification": "Aplique em código com múltiplas oportunidades e confirme convergência em <10 iterações.",
                                  "estimatedTime": "3 horas",
                                  "materials": [
                                    "Código da passada única",
                                    "Ferramentas de profiling (ex: timeit em Python)",
                                    "Datasets de código assembly gerados"
                                  ],
                                  "tips": "Teste com seed aleatório para gerar códigos variados.",
                                  "learningObjective": "Construir um otimizador iterativo que maximize eficiência.",
                                  "commonMistakes": [
                                    "Não detectar estagnação corretamente",
                                    "Exceder limites sem break"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Testar, Avaliar e Refinar o Otimizador Iterativo",
                                  "subSteps": [
                                    "Gere benchmarks: 10+ códigos assembly com redundâncias variadas.",
                                    "Meça performance: iterações totais, redução de código, tempo de execução.",
                                    "Compare com baseline (sem otimização) e otimizadores existentes.",
                                    "Refine regras baseadas em falhas observadas.",
                                    "Documente casos onde iteração múltipla é essencial vs. única passada."
                                  ],
                                  "verification": "Relatório mostrando >30% melhoria média e convergência consistente.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Benchmarks assembly",
                                    "Ferramentas de medição (ex: perf)",
                                    "Compilador de referência"
                                  ],
                                  "tips": "Automatize testes com scripts.",
                                  "learningObjective": "Validar e iterar no otimizador para robustez.",
                                  "commonMistakes": [
                                    "Benchmarks não representativos",
                                    "Ignorar overhead do otimizador"
                                  ]
                                }
                              ],
                              "practicalExample": "Dado código assembly: MOV R1, 5; MOV R2, R1; ADD R2, 3; MOV R1, R2. Primeira iteração peephole detecta redundância em MOV R2, R1 e MOV R1, R2, substituindo por MOV R1, 5; ADD R1, 3. Segunda iteração confirma sem mudanças, maximizando eficiência.",
                              "finalVerifications": [
                                "O otimizador converge em todos os testes sem loops infinitos.",
                                "Redução média de código >25% em benchmarks.",
                                "Número de iterações <15 por caso.",
                                "Regras aplicadas corretamente sem introduzir erros semânticos.",
                                "Métricas logadas mostram estabilização.",
                                "Comparação com única passada destaca ganhos da iteração múltipla."
                              ],
                              "assessmentCriteria": [
                                "Precisão das substituições peephole (semântica preservada).",
                                "Eficiência do loop de iterações (tempo e convergência).",
                                "Cobertura de regras (diversidade de padrões otimizados).",
                                "Robustez em códigos variados.",
                                "Qualidade da documentação e logging.",
                                "Melhoria mensurável em eficiência."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria de grafos para modelar dependências de instruções.",
                                "Engenharia de Software: Padrões de design para scanners e loops iterativos.",
                                "Algoritmos: Análise de complexidade em otimizações locais.",
                                "Análise de Sistemas: Profiling e métricas de performance em compiladores."
                              ],
                              "realWorldApplication": "Em compiladores como GCC e LLVM, iteração múltipla em peephole reduz tamanho de binários e melhora velocidade de execução em aplicações reais, como jogos e servidores, economizando recursos em dispositivos embarcados."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      }
                    ]
                  }
                ]
              },
              {
                "id": "10.1.7",
                "name": "Meta-compiladores e Ferramentas Automáticas",
                "description": "Ferramentas e linguagens para a construção automatizada de compiladores, como geradores de parsers.",
                "totalSkills": 42,
                "atomicTopics": [
                  {
                    "id": "10.1.7.1",
                    "name": "Conceito de Meta-compilador",
                    "description": "Compiladores que compilam linguagens definidas em uma meta-linguagem semelhante à própria linguagem fonte, facilitando auto-definição e bootstrap.",
                    "individualConcepts": [
                      {
                        "id": "10.1.7.1.1.1",
                        "name": "Definição de Meta-compilador",
                        "description": "Um meta-compilador é um compilador projetado para compilar linguagens de programação definidas em uma meta-linguagem que é semelhante à própria linguagem fonte, permitindo a descrição formal da sintaxe e semântica de forma recursiva.",
                        "specificSkills": [
                          {
                            "id": "10.1.7.1.1.1.1",
                            "name": "Explicar a definição básica de meta-compilador",
                            "description": "Descrever o que é um meta-compilador, destacando que ele processa descrições de linguagens em uma meta-linguagem similar à linguagem alvo, diferenciando-o de compiladores tradicionais.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Conceitos Básicos de Compiladores Tradicionais",
                                  "subSteps": [
                                    "Leia a definição de um compilador tradicional: um programa que traduz código fonte de uma linguagem de programação para código máquina ou intermediário.",
                                    "Identifique as fases principais: análise léxica, sintática, semântica, otimização e geração de código.",
                                    "Anote exemplos de compiladores como GCC para C++ ou Javac para Java.",
                                    "Desenhe um diagrama simples do fluxo de um compilador tradicional.",
                                    "Explique em suas palavras como um compilador processa uma linguagem fixa."
                                  ],
                                  "verification": "Você pode listar e descrever as 5 fases principais de um compilador tradicional sem consultar materiais?",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Artigo ou capítulo sobre compiladores básicos (ex: Dragon Book, seção introdutória)",
                                    "Papel e caneta para diagrama"
                                  ],
                                  "tips": "Comece com exemplos familiares para fixar o conceito antes de avançar para o 'meta'.",
                                  "learningObjective": "Compreender o funcionamento padrão de compiladores para contrastar com meta-compiladores.",
                                  "commonMistakes": [
                                    "Confundir compilador com interpretador; ignorar que compiladores lidam com linguagens pré-definidas."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Introduzir o Conceito de Meta-Linguagem",
                                  "subSteps": [
                                    "Defina meta-linguagem: uma linguagem usada para descrever outras linguagens (ex: BNF para gramáticas).",
                                    "Compare com linguagem objeto (a linguagem sendo descrita) e linguagem alvo (para a qual o código é gerado).",
                                    "Estude exemplos: BNF ou EBNF como meta-linguagens para definir sintaxe.",
                                    "Crie uma gramática simples em BNF para expressões aritméticas básicas.",
                                    "Explique por que meta-linguagens são 'bootstrapped' ou auto-descritivas."
                                  ],
                                  "verification": "Escreva uma definição de meta-linguagem e um exemplo de regra BNF válida.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Documentação de BNF/EBNF online",
                                    "Editor de texto para praticar gramáticas"
                                  ],
                                  "tips": "Use meta-linguagens como 'linguagem sobre linguagens' para visualizar melhor.",
                                  "learningObjective": "Dominar a hierarquia linguística: meta-linguagem, linguagem objeto e linguagem alvo.",
                                  "commonMistakes": [
                                    "Confundir meta-linguagem com linguagem de alto nível; não diferenciar níveis linguísticos (meta vs. objeto)."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Definir e Entender o Meta-Compilador",
                                  "subSteps": [
                                    "Defina meta-compilador: um compilador que toma descrições de linguagens em meta-linguagem e gera compiladores para linguagens objeto.",
                                    "Descreva o processo: entrada é especificação em meta-linguagem similar à linguagem alvo; saída é um compilador funcional.",
                                    "Analise o auto-bootstrapping: meta-compiladores escritos em sua própria meta-linguagem.",
                                    "Estude um exemplo histórico como TMG ou LALR parsers gerados por Yacc.",
                                    "Resuma: meta-compilador gera compiladores, não código diretamente."
                                  ],
                                  "verification": "Explique em 3 frases o que um meta-compilador faz, citando entrada e saída.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Artigo sobre meta-compiladores (ex: Wikipedia ou papers de Peter Naur)",
                                    "Vídeo curto sobre Yacc/Bison"
                                  ],
                                  "tips": "Pense no meta-compilador como um 'fábrica de compiladores'.",
                                  "learningObjective": "Explicar precisamente a definição e o mecanismo de um meta-compilador.",
                                  "commonMistakes": [
                                    "Achar que meta-compilador compila código fonte normal; ignorar similaridade da meta-linguagem com a alvo."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Diferenciar Meta-Compiladores de Compiladores Tradicionais",
                                  "subSteps": [
                                    "Compare: compilador tradicional compila programas; meta-compilador compila definições de linguagens.",
                                    "Crie uma tabela de diferenças: entrada (código vs. gramática), saída (binário vs. compilador), flexibilidade.",
                                    "Discuta vantagens: automação na criação de linguagens DSL, parsers customizados.",
                                    "Identifique limitações: complexidade inicial na meta-linguagem.",
                                    "Formule uma explicação clara da distinção em contexto educacional."
                                  ],
                                  "verification": "Preencha uma tabela comparativa com pelo menos 4 diferenças chave.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Planilha ou papel para tabela comparativa",
                                    "Exemplos de ferramentas como ANTLR"
                                  ],
                                  "tips": "Use analogias: compilador tradicional é 'cozinheiro'; meta-compilador é 'máquina de fazer cozinheiros'.",
                                  "learningObjective": "Destacar diferenças fundamentais para uma definição completa.",
                                  "commonMistakes": [
                                    "Não enfatizar o foco em descrições de linguagens; superestimar simplicidade dos meta-compiladores."
                                  ]
                                }
                              ],
                              "practicalExample": "Usando Yacc (um meta-compilador), escreva uma gramática simples para uma calculadora em BNF-like: expr -> expr + term | term; isso gera um parser que compila expressões aritméticas, demonstrando como o meta-compilador processa a meta-linguagem para produzir um compilador funcional.",
                              "finalVerifications": [
                                "Pode definir meta-compilador em uma frase precisa?",
                                "Explica a similaridade da meta-linguagem com a linguagem alvo?",
                                "Lista pelo menos 3 diferenças de compiladores tradicionais?",
                                "Descreve o processo de entrada-saída corretamente?",
                                "Cita um exemplo real como Yacc ou ANTLR?",
                                "Diferencia meta-linguagem de linguagem objeto?"
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição: inclui processamento de meta-linguagem e geração de compiladores (30%)",
                                "Clareza na diferenciação de compiladores tradicionais (25%)",
                                "Uso correto de termos como meta-linguagem, linguagem alvo e objeto (20%)",
                                "Inclusão de exemplos práticos ou históricos (15%)",
                                "Completude: cobre bootstrapping e vantagens (10%)"
                              ],
                              "crossCurricularConnections": [
                                "Linguística: Gramáticas formais e notação BNF semelhantes a sintaxe natural.",
                                "Matemática: Teoria dos autômatos e linguagens formais (Chomsky hierarchy).",
                                "Engenharia de Software: Geração automática de ferramentas para DSLs.",
                                "Lógica: Bootstrapping e auto-referência em sistemas formais."
                              ],
                              "realWorldApplication": "Meta-compiladores como ANTLR e Bison são usados para criar parsers customizados em projetos de compiladores, processadores de configuração (ex: JSON parsers custom), e linguagens de domínio específico em indústrias como finanças (query languages) e jogos (scripting engines), acelerando o desenvolvimento de ferramentas linguísticas."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.7.1.1.1.2",
                            "name": "Diferenciar meta-compilador de compilador convencional",
                            "description": "Comparar meta-compiladores com compiladores padrão, enfatizando a capacidade de auto-descrição e o uso de meta-linguagens para gerar analisadores léxicos e sintáticos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o Compilador Convencional",
                                  "subSteps": [
                                    "Leia a definição de um compilador convencional: um programa que traduz código fonte de uma linguagem de programação para código máquina ou outra linguagem alvo.",
                                    "Identifique componentes principais: analisador léxico, sintático, semântico, gerador de código e otimizador.",
                                    "Estude exemplos como GCC ou Javac, que são hardcoded para linguagens específicas.",
                                    "Anote limitações: rigidez para novas linguagens, necessidade de reescrita manual para analisadores.",
                                    "Resuma em um diagrama simples do fluxo de compilação."
                                  ],
                                  "verification": "Crie um fluxograma do processo de compilação convencional e explique verbalmente seus componentes.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Capítulo 1 do 'Compilers: Principles, Techniques, and Tools' (Dragon Book)",
                                    "Artigo da Wikipedia sobre Compiladores"
                                  ],
                                  "tips": "Use analogias como 'tradutor humano fixo para um idioma específico' para fixar o conceito.",
                                  "learningObjective": "Definir e descrever os componentes e limitações de um compilador convencional.",
                                  "commonMistakes": [
                                    "Confundir compilador com interpretador",
                                    "Ignorar que é específico para uma linguagem fonte fixa"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Explorar o Conceito de Meta-Compilador",
                                  "subSteps": [
                                    "Defina meta-compilador: um compilador que gera outros compiladores, usando uma meta-linguagem para descrever a linguagem alvo.",
                                    "Entenda auto-descrição: o meta-compilador usa sua própria linguagem para se descrever.",
                                    "Aprenda sobre meta-linguagens: usadas para especificar analisadores léxicos (ex: scanners) e sintáticos (parsers).",
                                    "Estude ferramentas como Yacc ou ANTLR como exemplos de meta-compiladores.",
                                    "Compare com bootstrapping: como linguagens se compilam a si mesmas."
                                  ],
                                  "verification": "Escreva uma definição curta de meta-compilador e liste 3 características únicas.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Documentação do Yacc/Bison",
                                    "Seção sobre Meta-Compiladores no Dragon Book (Cap. 4)"
                                  ],
                                  "tips": "Pense no meta-compilador como um 'fábrica de compiladores' programável.",
                                  "learningObjective": "Explicar a auto-descrição e o papel das meta-linguagens em meta-compiladores.",
                                  "commonMistakes": [
                                    "Achar que todo compilador é meta",
                                    "Confundir meta-linguagem com linguagem de alto nível"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Comparar Meta-Compilador e Compilador Convencional",
                                  "subSteps": [
                                    "Crie uma tabela comparativa: rigidez vs. flexibilidade, hardcoded vs. gerado, tempo de desenvolvimento.",
                                    "Enfatize diferenças chave: meta-compiladores geram analisadores automaticamente via especificações.",
                                    "Discuta vantagens: reusabilidade, portabilidade para novas linguagens.",
                                    "Analise desvantagens: complexidade inicial da meta-linguagem.",
                                    "Simule uma comparação com pseudocódigo: compilador convencional vs. especificação em meta-linguagem."
                                  ],
                                  "verification": "Preencha e apresente uma tabela de comparação com pelo menos 5 diferenças.",
                                  "estimatedTime": "50 minutos",
                                  "materials": [
                                    "Ferramenta de tabela como Google Sheets ou papel",
                                    "Exemplos de gramáticas em EBNF"
                                  ],
                                  "tips": "Use setas em um diagrama para mostrar 'gera' no meta-compilador vs. 'é fixo' no convencional.",
                                  "learningObjective": "Identificar e justificar pelo menos 4 diferenças fundamentais entre os dois.",
                                  "commonMistakes": [
                                    "Subestimar a abstração do meta-compilador",
                                    "Ignorar overhead computacional"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar o Conhecimento em um Exemplo Prático",
                                  "subSteps": [
                                    "Escolha uma gramática simples (ex: expressões aritméticas) e descreva como um compilador convencional a implementaria manualmente.",
                                    "Reescreva a mesma gramática usando uma meta-linguagem como Bison para gerar o parser.",
                                    "Execute ou simule a geração do compilador.",
                                    "Compare o código gerado vs. código manual.",
                                    "Reflita sobre escalabilidade para linguagens complexas."
                                  ],
                                  "verification": "Gere um parser simples via Bison e demonstre sua funcionalidade básica.",
                                  "estimatedTime": "90 minutos",
                                  "materials": [
                                    "Instalador do Bison/Flex",
                                    "Tutorial Bison: https://www.gnu.org/software/bison/manual/"
                                  ],
                                  "tips": "Comece com uma gramática mínima para evitar sobrecarga.",
                                  "learningObjective": "Demonstrar na prática como meta-compiladores automatizam tarefas manuais.",
                                  "commonMistakes": [
                                    "Erros de sintaxe na gramática meta",
                                    "Não testar o parser gerado"
                                  ]
                                }
                              ],
                              "practicalExample": "Desenvolva um analisador sintático para uma mini-linguagem de expressões matemáticas. Com compilador convencional: escreva 200 linhas de código manual para lexer/parser. Com meta-compilador (Bison): especifique 20 linhas em gramática Yacc, gere automaticamente o parser funcional.",
                              "finalVerifications": [
                                "Explique verbalmente 3 diferenças principais sem consultar notas.",
                                "Crie uma tabela comparativa precisa em menos de 5 minutos.",
                                "Identifique se uma ferramenta como ANTLR é meta-compilador (sim).",
                                "Descreva como meta-compiladores geram analisadores léxicos/sintáticos.",
                                "Diferencie auto-descrição de bootstrapping."
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição de ambos os conceitos (90%+ acurácia).",
                                "Capacidade de listar vantagens/desvantagens com exemplos.",
                                "Uso correto de terminologia (meta-linguagem, auto-descrição).",
                                "Demonstração prática via tabela ou código gerado.",
                                "Compreensão de aplicações em analisadores automáticos.",
                                "Ausência de confusões comuns como 'todo compilador gera código'."
                              ],
                              "crossCurricularConnections": [
                                "Linguística Computacional: gramáticas formais semelhantes a Chomsky hierarchy.",
                                "Matemática Formal: autômatos e linguagens regulares/context-free.",
                                "Engenharia de Software: automação de tarefas repetitivas via DSLs.",
                                "Inteligência Artificial: parsing em PLN para processamento de linguagem natural."
                              ],
                              "realWorldApplication": "Em empresas como Google ou Meta, meta-compiladores como ANTLR aceleram o desenvolvimento de compiladores para linguagens internas ou DSLs (ex: TensorFlow graph languages), reduzindo meses de codificação manual para dias de especificação."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.7.1.1.1.3",
                            "name": "Identificar exemplos históricos de meta-compiladores",
                            "description": "Citar exemplos como TMG ou YACC adaptados, relacionando com referências bibliográficas como Aho et al. e Santos & Langlois.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o conceito básico de meta-compilador e sua relevância histórica",
                                  "subSteps": [
                                    "Leia a definição de meta-compilador como um compilador que gera outros compiladores.",
                                    "Estude o contexto histórico dos anos 1960-1970 na evolução de linguagens de programação.",
                                    "Identifique a necessidade de meta-compiladores para lidar com gramáticas complexas.",
                                    "Anote termos chave como 'gerador de analisadores sintáticos' e 'linguagem-alvo'.",
                                    "Compare meta-compiladores com compiladores tradicionais."
                                  ],
                                  "verification": "Escreva um parágrafo resumindo a definição e história em suas próprias palavras.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Livro 'Compilers: Principles, Techniques, and Tools' de Aho et al. (capítulo introdutório)",
                                    "Artigo online sobre história de compiladores",
                                    "Notebook para anotações"
                                  ],
                                  "tips": "Foquem em datas chave como 1960s para contextualizar exemplos históricos.",
                                  "learningObjective": "Entender o que diferencia meta-compiladores e sua importância histórica.",
                                  "commonMistakes": [
                                    "Confundir meta-compilador com interpretador",
                                    "Ignorar o aspecto gerador de código para linguagens específicas"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Pesquisar e identificar TMG como exemplo pioneiro",
                                  "subSteps": [
                                    "Busque informações sobre TMG (The Meta-grammar) desenvolvido por Peter Landin ou associados nos anos 1960.",
                                    "Leia sobre sua aplicação em compiladores para Algol 60 e SNOBOL.",
                                    "Anote características: usa meta-gramáticas para descrever sintaxe.",
                                    "Encontre referências primárias ou citações em textos clássicos.",
                                    "Crie um diagrama simples mostrando como TMG gera um compilador."
                                  ],
                                  "verification": "Liste 3 fatos chave sobre TMG e cite uma fonte.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Documentação histórica de TMG (disponível em arquivos online como Bell Labs)",
                                    "Livro de Aho et al. (seção sobre ferramentas históricas)",
                                    "Pesquisador web acadêmico como Google Scholar"
                                  ],
                                  "tips": "Use termos exatos como 'TMG meta-compiler' para buscas precisas.",
                                  "learningObjective": "Reconhecer TMG como um dos primeiros meta-compiladores e suas contribuições.",
                                  "commonMistakes": [
                                    "Atribuir TMG a autores errados",
                                    "Não diferenciar TMG de linguagens como Lisp"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explorar YACC e suas adaptações como exemplos evolutivos",
                                  "subSteps": [
                                    "Estude YACC (Yet Another Compiler-Compiler) criado por Stephen C. Johnson em 1975.",
                                    "Aprenda como YACC processa gramáticas LALR(1) para gerar analisadores sintáticos em C.",
                                    "Compare com BISON, sua versão GNU open-source.",
                                    "Identifique usos históricos em sistemas UNIX.",
                                    "Relacione com meta-compiladores por gerar parsers customizados."
                                  ],
                                  "verification": "Descreva o fluxo de trabalho de YACC em 4 etapas.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Manual YACC original (man pages históricas)",
                                    "Livro 'Santos & Langlois' sobre compiladores",
                                    "Exemplos de código YACC online"
                                  ],
                                  "tips": "Instale BISON localmente para testar sintaxe básica se possível.",
                                  "learningObjective": "Identificar YACC como evolução prática de meta-compiladores.",
                                  "commonMistakes": [
                                    "Confundir YACC com LEX (lexer)",
                                    "Ignorar limitações como gramáticas não-LR"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Relacionar exemplos com referências bibliográficas chave",
                                  "subSteps": [
                                    "Localize menções a TMG e YACC no 'Dragon Book' de Aho, Sethi e Ullman.",
                                    "Pesquise citações em 'Santos & Langlois' sobre ferramentas automáticas.",
                                    "Compile uma lista de 5 referências cruzadas.",
                                    "Escreva citações no formato APA ou similar.",
                                    "Discuta como essas referências validam os exemplos históricos."
                                  ],
                                  "verification": "Crie uma bibliografia com pelo menos 3 entradas citando os exemplos.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Cópias digitais de Aho et al. (2ª edição)",
                                    "Livro 'Compiladores' de Santos & Langlois",
                                    "Ferramenta de gerenciamento de referências como Zotero"
                                  ],
                                  "tips": "Verifique edições específicas para citações precisas.",
                                  "learningObjective": "Conectar exemplos históricos a fontes acadêmicas confiáveis.",
                                  "commonMistakes": [
                                    "Citar fontes secundárias sem primárias",
                                    "Erros em nomes de autores ou anos"
                                  ]
                                }
                              ],
                              "practicalExample": "Ao estudar o compilador para uma linguagem como C nos anos 70, identifique TMG usado para protótipos iniciais e YACC para o parser do UNIX PCC, citando Aho et al. página 120 para validação histórica.",
                              "finalVerifications": [
                                "Pode citar corretamente TMG, YACC e pelo menos um outro exemplo como BISON.",
                                "Explica o papel histórico de cada um em 2-3 frases.",
                                "Fornece referências bibliográficas de Aho et al. e Santos & Langlois.",
                                "Diferencia meta-compiladores de ferramentas como LEX.",
                                "Lista 2 aplicações históricas reais."
                              ],
                              "assessmentCriteria": [
                                "Precisão factual: 30% (exemplos e datas corretos)",
                                "Profundidade de referências: 25% (citações adequadas de fontes chave)",
                                "Clareza na explicação: 20% (linguagem acessível e estruturada)",
                                "Conexões históricas: 15% (contexto evolutivo)",
                                "Originalidade: 10% (análise própria, não copiadas)"
                              ],
                              "crossCurricularConnections": [
                                "História da Computação: Evolução de linguagens e ferramentas UNIX.",
                                "Engenharia de Software: Automatização de desenvolvimento de parsers.",
                                "Linguística Computacional: Gramáticas formais e meta-gramáticas.",
                                "Pesquisa Acadêmica: Citação e validação de fontes históricas."
                              ],
                              "realWorldApplication": "Em projetos modernos como desenvolvimento de linguagens DSL (Domain-Specific Languages) em ferramentas como ANTLR ou Tree-sitter, entender TMG e YACC ajuda a escolher geradores de parsers eficientes para aplicações em compiladores web ou IoT."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.7.1.1.2",
                        "name": "Meta-linguagem e Auto-definição",
                        "description": "A meta-linguagem é uma linguagem formal usada para definir a sintaxe e semântica da linguagem fonte, permitindo que o compilador seja auto-definido, ou seja, escrito na própria linguagem que compila.",
                        "specificSkills": [
                          {
                            "id": "10.1.7.1.1.2.1",
                            "name": "Descrever o papel da meta-linguagem",
                            "description": "Explicar como a meta-linguagem facilita a definição recursiva de gramáticas, integrando análise léxica e sintática de forma unificada.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender Conceitos Fundamentais de Linguagens Formais e Gramáticas",
                                  "subSteps": [
                                    "Defina o que é uma linguagem formal e dê exemplos de linguagens de programação.",
                                    "Explique a diferença entre gramática regular, livre de contexto e sensível ao contexto.",
                                    "Identifique os componentes de uma gramática: terminais, não-terminais, produções e axioma.",
                                    "Estude notação BNF (Backus-Naur Form) como exemplo inicial de meta-linguagem.",
                                    "Compare gramáticas com descrições informais de linguagens naturais."
                                  ],
                                  "verification": "Resuma em um parágrafo os quatro componentes de uma gramática e forneça um exemplo simples em BNF.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Livro 'Compilers: Principles, Techniques, and Tools' (capítulo 1-2), slides sobre teoria da computação, editor de texto para praticar BNF.",
                                  "tips": "Use diagramas de árvore de derivação para visualizar produções.",
                                  "learningObjective": "Dominar os blocos de construção de gramáticas formais como base para meta-linguagens.",
                                  "commonMistakes": "Confundir terminais com não-terminais; ignorar o papel do axioma."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Introduzir o Conceito de Meta-Linguagem e Seu Propósito",
                                  "subSteps": [
                                    "Defina meta-linguagem como uma linguagem usada para descrever outras linguagens.",
                                    "Discuta níveis de linguagem: objeto (linguagem alvo), meta-1 (descreve objeto), meta-2 (descreve meta-1).",
                                    "Explique por que meta-linguagens são necessárias: precisão, univocidade e automação.",
                                    "Compare com linguagens naturais: ambiguidades vs. formalismo matemático.",
                                    "Liste exemplos: BNF, EBNF, X ::= Y Z | a."
                                  ],
                                  "verification": "Escreva uma definição precisa de meta-linguagem e cite dois exemplos históricos (ex: ALGOL 60 report).",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Artigos sobre história de BNF (John Backus, Peter Naur), vídeo introdutório sobre meta-linguagens no YouTube.",
                                  "tips": "Pense em meta-linguagem como 'linguagem sobre linguagem' para fixar o conceito.",
                                  "learningObjective": "Entender o papel abstrato da meta-linguagem na descrição formal de sintaxe.",
                                  "commonMistakes": "Confundir meta-linguagem com linguagem de alto nível; subestimar sua abstração."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explorar Definição Recursiva de Gramáticas via Meta-Linguagem",
                                  "subSteps": [
                                    "Explique recursão em gramáticas: regras que referenciam o próprio não-terminal.",
                                    "Escreva uma gramática recursiva simples para expressões aritméticas (ex: Expr ::= Expr + Term | Term).",
                                    "Discuta como meta-linguagem permite recursão explícita sem ambiguidade.",
                                    "Analise árvores de análise para derivar strings recursivas.",
                                    "Compare com iterações não-recursivas para destacar vantagens."
                                  ],
                                  "verification": "Construa e derive uma string de uma gramática recursiva usando BNF, desenhando a árvore de derivação.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Ferramenta online de parser como JFLAP ou ANTLRworks, papel e lápis para árvores.",
                                  "tips": "Comece com recursão à esquerda e converta para à direita para evitar loops infinitos.",
                                  "learningObjective": "Aplicar meta-linguagem para modelar estruturas recursivas em gramáticas.",
                                  "commonMistakes": "Ignorar ambiguidade em recursão à esquerda; não derivar múltiplos níveis."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar Integração de Análise Léxica e Sintática Unificada",
                                  "subSteps": [
                                    "Defina análise léxica (tokens) vs. sintática (estrutura).",
                                    "Mostre como meta-linguagem unifica: gramáticas com lexer embutido (ex: regex em EBNF).",
                                    "Estude exemplos onde lexer e parser são descritos na mesma meta-linguagem.",
                                    "Discuta benefícios: consistência, geração automática de compiladores.",
                                    "Implemente um lexer/parser toy usando meta-definição."
                                  ],
                                  "verification": "Descreva verbalmente ou por escrito como uma meta-linguagem integra lexer e parser em um exemplo simples.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Documentação de ferramentas como Flex/Bison ou PEG.js, exemplos de gramáticas unificadas.",
                                  "tips": "Visualize o pipeline: fonte -> lexer -> tokens -> parser -> AST.",
                                  "learningObjective": "Compreender a unificação proporcionada pela meta-linguagem para fases de compilação.",
                                  "commonMistakes": "Separar rigidamente lexer/parser sem ver a unificação possível."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Sintetizar o Papel Geral da Meta-Linguagem",
                                  "subSteps": [
                                    "Resuma os quatro papéis principais: formalização, recursão, unificação, automação.",
                                    "Crie um diagrama conceitual ligando meta-linguagem a meta-compiladores.",
                                    "Compare com alternativas não-meta (descrições prose).",
                                    "Discuta limitações: expressividade vs. complexidade.",
                                    "Prepare uma explicação completa para apresentação."
                                  ],
                                  "verification": "Escreva um ensaio curto (200 palavras) descrevendo integralmente o papel da meta-linguagem.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Ferramenta de diagramação como Draw.io, modelo de ensaio.",
                                  "tips": "Use analogia: meta-linguagem como 'DNA' das linguagens de programação.",
                                  "learningObjective": "Articular coerentemente o papel multifacetado da meta-linguagem.",
                                  "commonMistakes": "Focar apenas em BNF sem generalizar; omitir unificação."
                                }
                              ],
                              "practicalExample": "Usando BNF como meta-linguagem para definir recursivamente a gramática de expressões aritméticas: <expr> ::= <expr> + <term> | <term>; <term> ::= <term> * <factor> | <factor>; <factor> ::= ( <expr> ) | number. Isso integra lexer (number como token) e parser recursivo, permitindo gerar um parser automático para validar '2*(3+4)'.",
                              "finalVerifications": [
                                "Pode definir meta-linguagem e citar BNF/EBNF como exemplos.",
                                "Constrói e deriva uma gramática recursiva corretamente.",
                                "Explica unificação de análise léxica e sintática com diagrama.",
                                "Identifica vantagens sobre descrições informais.",
                                "Descreve ligação com meta-compiladores.",
                                "Lista limitações reais da abordagem."
                              ],
                              "assessmentCriteria": [
                                "Precisão conceitual: definições corretas sem ambiguidades (30%).",
                                "Profundidade: cobertura de recursão e unificação (25%).",
                                "Exemplos práticos: gramáticas funcionais e derivações (20%).",
                                "Clareza de explicação: linguagem acessível e estruturada (15%).",
                                "Integração interdisciplinar: conexões com teoria da computação (10%)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: recursão e indução em gramáticas formais.",
                                "Linguística: comparação com gramáticas gerativas de Chomsky.",
                                "Engenharia de Software: automação de ferramentas de parsing.",
                                "Lógica: notação formal similar a predicados lógicos."
                              ],
                              "realWorldApplication": "Em compiladores modernos como GCC/Clang, meta-linguagens como Bison definem gramáticas recursivas unificando lexer/parser, permitindo auto-definição de linguagens (ex: C++) e ferramentas como ANTLR para DSLs em apps empresariais."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.7.1.1.2.2",
                            "name": "Compreender auto-definição em meta-compiladores",
                            "description": "Analisar como um meta-compilador permite que a linguagem fonte seja usada para implementar o próprio compilador, promovendo portabilidade e manutenção.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender Conceitos Fundamentais de Compiladores e Meta-Compiladores",
                                  "subSteps": [
                                    "Definir um compilador tradicional e sua função de tradução de linguagem fonte para linguagem objeto.",
                                    "Explicar o que é um meta-compilador: um compilador que gera compiladores usando uma meta-linguagem.",
                                    "Diferenciar níveis linguísticos: linguagem objeto (saída), linguagem fonte (entrada) e meta-linguagem (usada para definir o compilador).",
                                    "Analisar o papel da auto-definição, onde a meta-linguagem é a própria linguagem fonte.",
                                    "Estudar diagrama bootstrapping de compiladores."
                                  ],
                                  "verification": "Escrever um resumo de 200 palavras explicando os conceitos e desenhar um diagrama simples de níveis linguísticos.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Capítulo sobre compiladores do 'Compilers: Principles, Techniques, and Tools' (Dragon Book)",
                                    "Artigo 'Meta-Compilers' de Peter Naur",
                                    "Vídeo introdutório sobre bootstrapping no YouTube"
                                  ],
                                  "tips": "Use analogias como um dicionário escrito na própria língua para visualizar auto-definição.",
                                  "learningObjective": "Dominar terminologia básica e hierarquia de linguagens em meta-compiladores.",
                                  "commonMistakes": [
                                    "Confundir meta-linguagem com linguagem objeto",
                                    "Ignorar o papel do bootstrapping inicial",
                                    "Achar que todo compilador é auto-definido"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar o Mecanismo de Auto-Definição",
                                  "subSteps": [
                                    "Descrever como a linguagem fonte é usada para especificar gramática, semântica e código gerador do compilador.",
                                    "Estudar fases do meta-compilador: análise léxica, sintática e semântica definidas na própria linguagem.",
                                    "Explorar geração de código: como regras na meta-linguagem produzem o compilador final.",
                                    "Simular um ciclo de auto-definição com pseudocódigo simples.",
                                    "Comparar com compiladores não auto-definidos (ex: escritos em C para uma linguagem X)."
                                  ],
                                  "verification": "Criar um fluxograma mostrando o processo de auto-definição e explicar verbalmente para um par.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Exemplos de gramáticas em BNF de meta-linguagens",
                                    "Ferramenta online como ANTLR para simular gramáticas",
                                    "Documentação de Yacc/Bison como caso prático"
                                  ],
                                  "tips": "Comece com gramáticas simples para evitar sobrecarga cognitiva.",
                                  "learningObjective": "Compreender como a linguagem se define recursivamente via meta-compilador.",
                                  "commonMistakes": [
                                    "Omitir dependências iniciais de um compilador hospedeiro",
                                    "Confundir definição estática com execução dinâmica",
                                    "Subestimar complexidade semântica"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explorar Benefícios da Auto-Definição",
                                  "subSteps": [
                                    "Discutir portabilidade: facilidade de mover o compilador para novas plataformas alterando apenas a meta-linguagem.",
                                    "Analisar manutenção: mudanças na linguagem fonte propagam automaticamente ao compilador.",
                                    "Estudar escalabilidade: suporte a extensões modulares sem reescrever o compilador.",
                                    "Comparar métricas: tempo de desenvolvimento e custo em projetos auto-definidos vs. tradicionais.",
                                    "Identificar limitações, como dependência inicial de um compilador hospedeiro."
                                  ],
                                  "verification": "Listar 5 vantagens e 2 desvantagens com exemplos hipotéticos e justificativas.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Estudo de caso: Compilador Lisp em Lisp",
                                    "Paper 'Self-Hosting Compilers' ",
                                    "Slides sobre bootstrapping em linguagens modernas como Rust ou Go"
                                  ],
                                  "tips": "Pense em cenários reais de migração de hardware para reforçar portabilidade.",
                                  "learningObjective": "Avaliar impactos práticos da auto-definição em desenvolvimento de software.",
                                  "commonMistakes": [
                                    "Superestimar portabilidade sem considerar overhead de bootstrapping",
                                    "Ignorar custos iniciais de design da meta-linguagem"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar e Sintetizar Conhecimento",
                                  "subSteps": [
                                    "Implementar uma mini-gramática auto-definida usando uma ferramenta como JFlex ou ANTLR.",
                                    "Testar geração de um parser simples para uma linguagem fictícia.",
                                    "Analisar código gerado e modificar a definição fonte para observar mudanças.",
                                    "Documentar lições aprendidas sobre portabilidade e manutenção.",
                                    "Discutir em fórum ou grupo como isso se aplica a projetos reais."
                                  ],
                                  "verification": "Gerar e executar um compilador simples auto-definido e relatar resultados.",
                                  "estimatedTime": "2.5 horas",
                                  "materials": [
                                    "ANTLR ou Bison instalado",
                                    "Tutorial ANTLR para gramáticas",
                                    "Ambiente de desenvolvimento (VS Code com extensões)"
                                  ],
                                  "tips": "Use linguagens pequenas primeiro, como aritmética básica, para protótipo rápido.",
                                  "learningObjective": "Integrar teoria com prática para validar compreensão de auto-definição.",
                                  "commonMistakes": [
                                    "Erros de recursão infinita em definições",
                                    "Não testar em múltiplas plataformas",
                                    "Ignorar validação semântica"
                                  ]
                                }
                              ],
                              "practicalExample": "No Lisp, o compilador é escrito em Lisp usando um meta-compilador. A gramática e semântica do Lisp são definidas em Lisp, gerando um compilador que compila código Lisp em código máquina, permitindo fácil portabilidade para novas arquiteturas ao recompilar o meta-compilador.",
                              "finalVerifications": [
                                "Explicar auto-definição em termos leigos com diagrama.",
                                "Identificar 3 benefícios para portabilidade e manutenção.",
                                "Dar exemplo real de linguagem auto-definida (ex: Lisp ou Smalltalk).",
                                "Simular ciclo de bootstrapping em whiteboard.",
                                "Comparar com compilador não auto-definido.",
                                "Listar limitações e soluções."
                              ],
                              "assessmentCriteria": [
                                "Precisão conceitual (90% correto nos termos chave).",
                                "Profundidade na análise de mecanismos (cobertura de fases do compilador).",
                                "Uso de exemplos relevantes e originais.",
                                "Clareza na explicação de benefícios e limitações.",
                                "Demonstração prática via simulação ou código.",
                                "Conexões com aplicações reais."
                              ],
                              "crossCurricularConnections": [
                                "Teoria das Linguagens Formais (Matemática: autômatos e gramáticas).",
                                "Engenharia de Software (design de sistemas auto-hospedados).",
                                "Linguística Computacional (definição recursiva de sintaxe).",
                                "História da Computação (evolução de compiladores desde os anos 60)."
                              ],
                              "realWorldApplication": "Em projetos como o compilador GCC (partes auto-definidas) ou linguagens modernas como Julia, auto-definição permite manutenção eficiente e portabilidade multiplataforma, reduzindo custos em equipes de desenvolvimento distribuídas."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.7.1.1.2.3",
                            "name": "Relacionar com ferramentas automáticas",
                            "description": "Conectar o conceito de meta-linguagem com geradores de compiladores como YACC ou Bison, citando benefícios na construção automática.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Conceitos Fundamentais de Meta-linguagem",
                                  "subSteps": [
                                    "Defina meta-linguagem como uma linguagem usada para descrever outras linguagens.",
                                    "Explique auto-definição, onde uma linguagem é descrita por si mesma ou por uma meta-linguagem.",
                                    "Identifique exemplos clássicos como BNF (Backus-Naur Form) para gramáticas.",
                                    "Discuta o papel de meta-linguagens em compiladores para especificar sintaxe e semântica.",
                                    "Compare meta-linguagens com linguagens objeto."
                                  ],
                                  "verification": "Escreva um resumo de 200 palavras explicando meta-linguagem e auto-definição, com pelo menos um exemplo.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Livro de Compiladores (ex: Dragon Book), PDF sobre BNF",
                                    "Notebook para anotações"
                                  ],
                                  "tips": "Use diagramas para visualizar níveis de linguagem (linguagem objeto vs. meta-linguagem).",
                                  "learningObjective": "Compreender os conceitos básicos de meta-linguagem e sua relação com definição de linguagens.",
                                  "commonMistakes": "Confundir meta-linguagem com linguagem de programação geral; ignorar hierarquia de linguagens."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Introduzir Ferramentas YACC e Bison",
                                  "subSteps": [
                                    "Instale Bison (sucessor de YACC) no seu ambiente de desenvolvimento.",
                                    "Estude a sintaxe básica de especificações YACC/Bison: seções de declarações, regras e código C.",
                                    "Analise um exemplo simples de gramática para um mini-linguagem aritmética.",
                                    "Compile e execute o gerador para produzir um parser funcional.",
                                    "Explore opções de depuração como yydebug."
                                  ],
                                  "verification": "Gere um parser simples para expressões aritméticas usando Bison e teste com input válido/inválido.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Bison manual (online), GCC compiler",
                                    "Editor de texto/IDE como VS Code"
                                  ],
                                  "tips": "Comece com gramáticas livres de contexto simples para evitar conflitos shift-reduce.",
                                  "learningObjective": "Dominar a instalação e uso básico de YACC/Bison para geração automática de parsers.",
                                  "commonMistakes": "Esquecer de declarar tokens na seção de declarações; não lidar com precedência de operadores."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Conectar Meta-linguagem com YACC/Bison",
                                  "subSteps": [
                                    "Identifique como YACC/Bison usam uma meta-linguagem específica para definir gramáticas.",
                                    "Mapeie regras YACC para notação BNF/meta-linguagem.",
                                    "Discuta como essas ferramentas automatizam a construção de analisadores sintáticos.",
                                    "Compare manual vs. automático: tempo e propensão a erros.",
                                    "Analise um exemplo onde auto-definição é usada em specs YACC."
                                  ],
                                  "verification": "Crie um diagrama relacionando BNF, meta-linguagem e regras YACC para uma gramática dada.",
                                  "estimatedTime": "50 minutos",
                                  "materials": [
                                    "Exemplos de código YACC/Bison",
                                    "Ferramenta de diagramação como Draw.io"
                                  ],
                                  "tips": "Pense em YACC como um 'tradutor' de meta-linguagem para código C executável.",
                                  "learningObjective": "Estabelecer a conexão conceitual entre meta-linguagem e ferramentas automáticas como YACC/Bison.",
                                  "commonMistakes": "Subestimar ambiguidades gramaticais; não reconhecer YACC como meta-linguagem prática."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar Benefícios e Limitações",
                                  "subSteps": [
                                    "Liste benefícios: automação reduz tempo, consistência, escalabilidade para linguagens complexas.",
                                    "Cite exemplos reais: uso em GCC, Perl, Python parsers.",
                                    "Discuta limitações: apenas sintaxe (não semântica plena), necessidade de gramáticas LL/LR.",
                                    "Compare com alternativas modernas como ANTLR.",
                                    "Elabore um relatório curto sobre trade-offs."
                                  ],
                                  "verification": "Escreva um parágrafo citando 3 benefícios e 1 limitação, com referências reais.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Documentação GCC/Python sobre seus parsers",
                                    "Artigos sobre YACC em compiladores"
                                  ],
                                  "tips": "Pesquise cases de estudo para tornar benefícios concretos.",
                                  "learningObjective": "Avaliar criticamente os benefícios da automação via meta-linguagens em compiladores.",
                                  "commonMistakes": "Focar só em benefícios sem mencionar dependência em gramáticas determinísticas."
                                }
                              ],
                              "practicalExample": "Desenvolva um parser para uma mini-linguagem de expressões booleanas usando Bison: defina gramática em meta-linguagem (BNF-like), gere o código C automaticamente, integre com um lexer flex, e teste com expressões como 'A AND (B OR C)' para validar output semântico.",
                              "finalVerifications": [
                                "Explicar verbalmente a conexão entre meta-linguagem e YACC/Bison em 2 minutos.",
                                "Gerar e executar um parser Bison sem erros de compilação.",
                                "Identificar benefícios em um caso real como o parser do Bash.",
                                "Converter uma gramática BNF simples para YACC.",
                                "Discutir uma limitação prática com exemplo.",
                                "Criar diagrama de fluxo de geração automática."
                              ],
                              "assessmentCriteria": [
                                "Precisão conceitual: Correta ligação meta-linguagem com automação (30%).",
                                "Profundidade técnica: Uso correto de YACC/Bison com exemplo funcional (25%).",
                                "Análise de benefícios: Pelo menos 3 pontos bem fundamentados (20%).",
                                "Clareza de comunicação: Diagramas e resumos legíveis (15%).",
                                "Criatividade: Extensão para cenários reais ou melhorias (10%)."
                              ],
                              "crossCurricularConnections": [
                                "Linguística Computacional: Paralelo com gramáticas formais de Chomsky.",
                                "Engenharia de Software: Automação de código similar a DSLs e code generators.",
                                "Matemática: Teoria de autômatos e linguagens formais (pushdown automata).",
                                "Design de Sistemas: Princípios de modularidade em ferramentas de parsing."
                              ],
                              "realWorldApplication": "Em projetos como o compilador GCC ou interpretadores de linguagens como Python e Ruby, YACC/Bison aceleram o desenvolvimento de parsers robustos, reduzindo meses de codificação manual para horas, permitindo foco em otimizações semânticas e suportando evoluções linguísticas rápidas."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.7.1.1.3",
                        "name": "Processo de Bootstrap em Meta-compiladores",
                        "description": "O bootstrap é o mecanismo pelo qual um compilador inicial (escrito em outra linguagem) gera versões subsequentes de si mesmo usando o meta-compilador, alcançando auto-hospedagem.",
                        "specificSkills": [
                          {
                            "id": "10.1.7.1.1.3.1",
                            "name": "Explicar o processo de bootstrap",
                            "description": "Detalhar as etapas do bootstrap: compilador cruzado inicial, compilação da versão 1, uso dela para compilar versão 2, e verificação de estabilidade.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o Conceito de Bootstrap e Preparar o Compilador Cruzado Inicial",
                                  "subSteps": [
                                    "Estude a definição de bootstrap em meta-compiladores: processo de usar um compilador existente para construir si mesmo.",
                                    "Identifique os componentes: compilador cruzado (host para target), código fonte inicial do meta-compilador.",
                                    "Configure o ambiente: instale ferramentas de build como make, configure host e target architectures.",
                                    "Esboce um diagrama simples do fluxo: cruzado -> versão 1.",
                                    "Revise exemplos históricos como o bootstrap do Lisp ou GCC."
                                  ],
                                  "verification": "Crie um diagrama do setup inicial e explique verbalmente ou por escrito os papéis de host e target.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Documentação de compiladores cruzados",
                                    "Ferramentas como GCC cross-compiler",
                                    "Papel e caneta para diagrama"
                                  ],
                                  "tips": "Comece com arquiteturas simples como x86 para ARM para visualizar melhor.",
                                  "learningObjective": "Entender os pré-requisitos e o papel do compilador cruzado no bootstrap.",
                                  "commonMistakes": [
                                    "Confundir host com target architecture",
                                    "Ignorar dependências de bibliotecas cruzadas",
                                    "Subestimar configuração de paths"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Compilar a Versão 1 do Meta-Compilador Usando o Compilador Cruzado",
                                  "subSteps": [
                                    "Baixe ou escreva o código fonte inicial do meta-compilador (versão 1).",
                                    "Configure flags de compilação para target architecture usando o cruzado.",
                                    "Execute o build: ./configure --host=host --target=target; make.",
                                    "Teste básico: compile um programa hello world com a versão 1 gerada.",
                                    "Registre outputs, erros e tamanho do binário."
                                  ],
                                  "verification": "A versão 1 compila com sucesso um programa simples e produz código executável para target.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Código fonte do meta-compilador v1",
                                    "Compilador cruzado instalado",
                                    "Ambiente de build como Linux VM"
                                  ],
                                  "tips": "Use verbose mode (--verbose) no make para rastrear dependências.",
                                  "learningObjective": "Executar a primeira compilação e validar funcionalidade básica.",
                                  "commonMistakes": [
                                    "Flags erradas de target",
                                    "Bibliotecas ausentes no target",
                                    "Não testar output imediatamente"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Usar a Versão 1 para Compilar a Versão 2 do Meta-Compilador",
                                  "subSteps": [
                                    "Prepare o código fonte da versão 2 (com otimizações ou correções).",
                                    "Configure e compile v2 usando v1 como compilador: set CC=./v1; make.",
                                    "Compare binários v1 e v2: tamanho, performance em benchmarks simples.",
                                    "Execute testes de regressão em ambos.",
                                    "Documente diferenças observadas."
                                  ],
                                  "verification": "Versão 2 é compilada por v1 e passa nos mesmos testes que v1.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Binário da v1",
                                    "Código fonte v2",
                                    "Benchmarks simples como polybench"
                                  ],
                                  "tips": "Mantenha v1 e v2 em diretórios separados para evitar confusões.",
                                  "learningObjective": "Demonstrar auto-hospedagem inicial e iteração no bootstrap.",
                                  "commonMistakes": [
                                    "Usar compilador errado (voltar ao cruzado)",
                                    "Ignorar warnings de compilação",
                                    "Não comparar outputs"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificar Estabilidade Através de Iterações Múltiplas",
                                  "subSteps": [
                                    "Compile v2 usando v2 (self-hosting).",
                                    "Repita: use v2 para compilar v3 (cópia de v2 com mudança mínima).",
                                    "Execute ciclo completo 3-5 vezes, verificando bit-identical outputs.",
                                    "Meça convergência: performance e tamanho estabilizam?",
                                    "Analise logs para inconsistências."
                                  ],
                                  "verification": "Após 3 iterações, binários são idênticos e performance estável.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Scripts de automação para builds repetidos",
                                    "Ferramentas de diff como cmp para binários"
                                  ],
                                  "tips": "Automatize com script bash para rodar ciclos rápidos.",
                                  "learningObjective": "Validar estabilidade e confiabilidade do bootstrap completo.",
                                  "commonMistakes": [
                                    "Parar após uma iteração",
                                    "Não checar bit-exactness",
                                    "Ignorar flutuações de performance"
                                  ]
                                }
                              ],
                              "practicalExample": "No bootstrap do GCC para uma nova arquitetura ARM: 1) Use GCC x86->ARM (cruzado) para build GCC v1 para ARM. 2) Rode GCC v1 no ARM para build GCC v2. 3) Use v2 para rebuild v2 e confirme estabilidade após 3 ciclos, garantindo self-hosting.",
                              "finalVerifications": [
                                "Explicar o fluxo completo em um diagrama sem erros.",
                                "Simular bootstrap em ambiente virtualizado.",
                                "Identificar problemas comuns em cenários reais.",
                                "Comparar com bootloaders de OS (analogia).",
                                "Discutir benefícios de bootstrap em porting.",
                                "Executar um mini-bootstrap com toy compiler."
                              ],
                              "assessmentCriteria": [
                                "Precisão na sequência de etapas (100% cobertura).",
                                "Clareza em diagramas e explicações.",
                                "Validação prática com testes executados.",
                                "Análise de erros comuns e soluções.",
                                "Conexão com exemplos reais como GCC/Rust.",
                                "Documentação completa de iterações."
                              ],
                              "crossCurricularConnections": [
                                "Engenharia de Software: Ciclos de build e CI/CD.",
                                "História da Computação: Bootstrapping em linguagens como Lisp.",
                                "Sistemas Operacionais: Bootloaders e self-hosting kernels.",
                                "Matemática: Teoria de fixpoints em compiladores iterativos."
                              ],
                              "realWorldApplication": "Essencial para desenvolver compiladores para novas arquiteturas (ex: RISC-V), portar linguagens como Rust para GPUs, ou estabilizar toolchains em projetos open-source como LLVM, reduzindo dependência de compiladores externos."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.7.1.1.3.2",
                            "name": "Identificar vantagens do bootstrap",
                            "description": "Discutir benefícios como portabilidade entre plataformas, otimização iterativa e redução de dependências externas.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o Conceito Básico de Bootstrap em Meta-compiladores",
                                  "subSteps": [
                                    "Defina bootstrap como o processo de usar um compilador para compilar a si mesmo.",
                                    "Explique o ciclo: compilador inicial (escrito em outra linguagem) gera versão melhorada.",
                                    "Identifique estágios: bootstrap de nível 1 (compilador hospedeiro), nível 2 (auto-hospedado), nível 3 (otimizado).",
                                    "Compare com compiladores não-bootstrapped que dependem de ferramentas externas permanentes.",
                                    "Anote diferenças chave em um diagrama simples."
                                  ],
                                  "verification": "Crie um fluxograma do processo de bootstrap e explique verbalmente para um par.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Papel e caneta ou ferramenta de diagrama como Draw.io; leitura sobre compiladores (ex: Dragon Book capítulo relevante).",
                                  "tips": "Use analogia de 'uma impressora que imprime seu próprio manual' para fixar o conceito.",
                                  "learningObjective": "Entender o mecanismo fundamental do bootstrap como auto-hospedagem iterativa.",
                                  "commonMistakes": "Confundir bootstrap com instalação inicial; ignorar a iteração múltipla."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar a Vantagem de Portabilidade entre Plataformas",
                                  "subSteps": [
                                    "Descreva como o código-fonte do compilador é portátil, recompilado em novas plataformas.",
                                    "Exemplo: Mude de x86 para ARM sem reescrever o compilador em assembly nativo.",
                                    "Liste cenários: migração para novas arquiteturas ou SOs como Linux para Windows.",
                                    "Compare com compiladores não-portáteis que exigem ports manuais caros.",
                                    "Registre 3 exemplos reais de compiladores portáteis via bootstrap (GCC, Clang)."
                                  ],
                                  "verification": "Escreva um parágrafo explicando portabilidade e cite um exemplo histórico.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Documentação do GCC bootstrap; artigos sobre portabilidade de compiladores.",
                                  "tips": "Pense em 'o compilador se adapta ao hardware recompilando-se, não sendo reescrito'.",
                                  "learningObjective": "Identificar como bootstrap facilita suporte multiplataforma sem dependências externas.",
                                  "commonMistakes": "Achar que portabilidade é só do código compilado, não do compilador em si."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explorar Otimização Iterativa e Redução de Dependências",
                                  "subSteps": [
                                    "Explique otimização iterativa: cada versão compila a próxima com mais otimizações.",
                                    "Descreva redução de dependências: elimina necessidade de compilador externo após bootstrap inicial.",
                                    "Simule iterações: versão 1 básica -> versão 2 otimizada -> versão 3 refinada.",
                                    "Quantifique benefícios: tempo de build menor, código mais eficiente ao longo das iterações.",
                                    "Discuta trade-offs: custo inicial alto, mas ganhos cumulativos."
                                  ],
                                  "verification": "Crie uma tabela comparando compilador bootstrapped vs. não-bootstrapped em 4 métricas.",
                                  "estimatedTime": "40 minutos",
                                  "materials": "Planilha ou tabela Markdown; manuais de bootstrap de LLVM ou GCC.",
                                  "tips": "Visualize como 'um ciclo de feedback: melhor compilador gera melhor compilador'.",
                                  "learningObjective": "Dominar como bootstrap permite refinamento contínuo e independência.",
                                  "commonMistakes": "Subestimar o custo inicial; confundir com otimizações de runtime."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Sintetizar e Aplicar as Vantagens em um Caso Prático",
                                  "subSteps": [
                                    "Liste as 3 vantagens principais: portabilidade, otimização iterativa, redução de dependências.",
                                    "Crie um argumento persuasivo para usar bootstrap em um novo meta-compilador.",
                                    "Debata contra-argumentos (ex: complexidade inicial) e refute com evidências.",
                                    "Aplique a um cenário: desenvolver compilador para IoT devices multiplataforma.",
                                    "Revise e refine sua síntese em um resumo de 1 página."
                                  ],
                                  "verification": "Apresente oralmente as vantagens e responda a 3 perguntas críticas.",
                                  "estimatedTime": "35 minutos",
                                  "materials": "Editor de texto; exemplos de repositórios GitHub de compiladores bootstrapped.",
                                  "tips": "Use bullet points para clareza em debates; pratique com timer.",
                                  "learningObjective": "Integrar todas as vantagens em uma visão coesa e argumentativa.",
                                  "commonMistakes": "Listar vantagens sem exemplos concretos; ignorar limitações."
                                }
                              ],
                              "practicalExample": "No desenvolvimento do GCC (GNU Compiler Collection), o bootstrap permite compilar o GCC no Linux x86, gerar binários para ARM, e iterativamente otimizar para melhor performance em dispositivos embedded, reduzindo dependência de compiladores proprietários como o da Intel.",
                              "finalVerifications": [
                                "Liste e explique as 3 vantagens principais do bootstrap com exemplos.",
                                "Desenhe um diagrama do processo de bootstrap com 3 níveis.",
                                "Compare tempo/custo de manutenção de compilador bootstrapped vs. externo.",
                                "Identifique 2 compiladores reais que usam bootstrap (ex: GCC, Clang).",
                                "Explique verbalmente portabilidade em mudança de plataforma.",
                                "Quantifique benefício de otimização iterativa em uma iteração hipotética."
                              ],
                              "assessmentCriteria": [
                                "Precisão conceitual: definições corretas de bootstrap e vantagens (30%).",
                                "Profundidade de análise: exemplos concretos e comparações (25%).",
                                "Clareza na comunicação: diagramas, tabelas e explicações lógicas (20%).",
                                "Aplicação prática: ligação com casos reais como GCC (15%).",
                                "Completude: cobertura de todas vantagens sem omissões (10%)."
                              ],
                              "crossCurricularConnections": [
                                "Engenharia de Software: princípios de auto-hospedagem e CI/CD pipelines iterativos.",
                                "Sistemas Operacionais: portabilidade e abstração de hardware.",
                                "Matemática: otimização iterativa similar a métodos numéricos convergentes.",
                                "Gestão de Projetos: trade-offs custo-benefício em desenvolvimento de ferramentas."
                              ],
                              "realWorldApplication": "Empresas como a Red Hat usam bootstrap no GCC para suportar compilação multiplataforma em data centers (x86) e edge computing (ARM), reduzindo custos de licenças externas e acelerando atualizações de segurança via otimizações iterativas."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.7.1.1.3.3",
                            "name": "Aplicar conceito em cenários práticos",
                            "description": "Simular um exemplo simples de bootstrap usando pseudocódigo, relacionando com tratamento de erros e geração de código intermediário.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Definir uma linguagem de exemplo simples e o compilador inicial",
                                  "subSteps": [
                                    "Escolha uma linguagem mínima com operações básicas como soma e atribuição (ex: vars a=1; b=a+2).",
                                    "Descreva a gramática em pseudocódigo usando EBNF simples.",
                                    "Escreva um lexer/parser básico em pseudocódigo hospedeiro (linguagem externa).",
                                    "Implemente geração de código intermediário (IR) como uma árvore de sintaxe abstrata (AST).",
                                    "Teste parsing de um programa simples."
                                  ],
                                  "verification": "Verifique se o parser gera uma AST correta para um programa de teste sem erros.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Editor de texto, documentação de EBNF, exemplos de gramáticas de linguagens mínimas.",
                                  "tips": "Comece com no máximo 5 regras gramaticais para manter simples.",
                                  "learningObjective": "Compreender como definir uma linguagem alvo mínima para bootstrap.",
                                  "commonMistakes": "Gramáticas ambíguas; evite regras recursivas desnecessárias."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar a Fase 0: Compilador escrito na linguagem hospedeira",
                                  "subSteps": [
                                    "Codifique o lexer em pseudocódigo: tokenizar entrada em tokens (ID, NUM, OP).",
                                    "Codifique o parser recursivo descendente para construir AST.",
                                    "Adicione geração de código intermediário: traverse AST para produzir IR assembly-like.",
                                    "Inclua tratamento básico de erros: reporte sintaxe inválida com linha/coluna.",
                                    "Compile um programa de teste para IR."
                                  ],
                                  "verification": "Execute o compilador Fase 0 em um programa simples e confirme IR gerado sem crashes.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Pseudocódigo templates para lexer/parser, exemplos de AST em diagramas.",
                                  "tips": "Use funções modulares: separate tokenize(), parseExpr(), genIR().",
                                  "learningObjective": "Dominar implementação de um compilador inicial funcional.",
                                  "commonMistakes": "Ignorar precedência de operadores; teste com expressões aninhadas."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Simular Fase 1: Compilar o compilador usando si mesmo",
                                  "subSteps": [
                                    "Reescreva o código do Fase 0 na linguagem alvo (usando a gramática definida).",
                                    "Use o compilador Fase 0 para parse e gerar IR do novo compilador (Fase 1).",
                                    "Incorpore tratamento de erros avançado: recuperação de erros no parser.",
                                    "Gere código intermediário otimizado, como eliminação de dead code na AST.",
                                    "Compare IR gerado com o esperado manualmente."
                                  ],
                                  "verification": "Confirme que o IR do compilador Fase 1 é sintaticamente correto e executável.",
                                  "estimatedTime": "75 minutos",
                                  "materials": "Código do Fase 0, simulador de IR (planilha ou ferramenta online).",
                                  "tips": "Auto-documente o código fonte do compilador para facilitar parsing.",
                                  "learningObjective": "Aplicar bootstrap na prática, simulando auto-compilação.",
                                  "commonMistakes": "Ciclos infinitos em recursão; limite profundidade de parsing."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Simular Fase 2 e integrar tratamento de erros completo com verificações",
                                  "subSteps": [
                                    "Use o compilador Fase 1 para compilar uma versão Fase 2 do compilador.",
                                    "Adicione handling de erros semânticos: type checking no IR.",
                                    "Otimize geração de código intermediário: alocação de registradores básica.",
                                    "Teste o ciclo completo: compile programa -> IR -> valide erros.",
                                    "Documente diferenças entre fases e benefícios do bootstrap."
                                  ],
                                  "verification": "O compilador Fase 2 gera IR idêntico ao Fase 1 para testes, com erros reportados corretamente.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Todos códigos anteriores, checklist de erros semânticos.",
                                  "tips": "Simule execução do IR em um interpretador mental ou ferramenta simples.",
                                  "learningObjective": "Relacionar bootstrap com robustez em tratamento de erros e IR.",
                                  "commonMistakes": "Sobrecarregar parser com erros; priorize graceful degradation."
                                }
                              ],
                              "practicalExample": "Considere MiniLang: 'x=1+2; print(x);'. Fase 0 (hospedeiro): lexer tokeniza 'x','=','1','+','2',';','print','(',')',';'. Parser gera AST: Assign('x', Add(1,2)); Print('x'). IR: load r1=1; load r2=2; add r3=r1+r2; store x=r3; call print(x). Fase 1: Reescreva isso em MiniLang e compile com Fase 0, tratando erro como 'token inesperado na linha 3'.",
                              "finalVerifications": [
                                "Pseudocódigo simula todas as 3 fases do bootstrap sem inconsistências.",
                                "Tratamento de erros cobre sintaxe e semântica em pelo menos 3 cenários.",
                                "Geração de IR é consistente entre fases e otimizável.",
                                "AST e IR passam em testes de programa simples com erros injetados.",
                                "Documentação relaciona bootstrap a auto-hospedagem real.",
                                "Tempo total de simulação < 4 horas com resultados reproduzíveis."
                              ],
                              "assessmentCriteria": [
                                "Clareza e correção do pseudocódigo (30%)",
                                "Cobertura completa de tratamento de erros (25%)",
                                "Precisão na geração e otimização de IR (20%)",
                                "Simulação fiel das fases de bootstrap (15%)",
                                "Relacionamento lógico com conceitos de meta-compiladores (10%)"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Autômatos e linguagens formais (gramáticas).",
                                "Engenharia de Software: Bootstrapping em projetos de compiladores como LLVM.",
                                "Programação: Parsing e walkers em árvores (ex: Python AST module).",
                                "Lógica: Verificação de propriedades em processos auto-referenciais."
                              ],
                              "realWorldApplication": "Em compiladores reais como GCC ou Rustc, bootstrap garante portabilidade: compile em C, gere Rust, recompile em Rust otimizado, permitindo atualizações sem dependências externas e detectando bugs via fases cruzadas."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.7.2",
                    "name": "Geradores de Analisadores Léxicos",
                    "description": "Ferramentas como Lex ou Flex que geram automaticamente scanners a partir de expressões regulares.",
                    "individualConcepts": [
                      {
                        "id": "10.1.7.2.1",
                        "name": "Fundamentos de Geradores de Analisadores Léxicos",
                        "description": "Compreender o conceito de geradores de analisadores léxicos, como Lex e Flex, que automatizam a criação de scanners a partir de especificações em expressões regulares, facilitando a análise léxica em compiladores.",
                        "specificSkills": [
                          {
                            "id": "10.1.7.2.1.1",
                            "name": "Definir o propósito de ferramentas como Lex e Flex",
                            "description": "Explicar como Lex e Flex geram código C para scanners eficientes a partir de regras léxicas definidas por expressões regulares, identificando vantagens sobre implementação manual, como portabilidade e otimização automática de autômatos finitos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os Fundamentos da Análise Léxica",
                                  "subSteps": [
                                    "Estude o conceito de análise léxica como a primeira fase da compilação, que divide o código-fonte em tokens.",
                                    "Aprenda sobre scanners (ou lexers) como programas que identificam tokens usando expressões regulares.",
                                    "Revise expressões regulares e sua representação como autômatos finitos (AF).",
                                    "Identifique limitações de implementações manuais de scanners, como complexidade e propensão a erros.",
                                    "Explore exemplos simples de scanners manuais em C para contrastar com ferramentas automáticas."
                                  ],
                                  "verification": "Escreva um parágrafo resumindo o papel da análise léxica e liste 3 limitações de scanners manuais.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Documentação de compiladores (ex: Dragon Book capítulo 3), editor de texto"
                                  ],
                                  "tips": "Use diagramas de AF para visualizar expressões regulares.",
                                  "learningObjective": "Entender o contexto e problemas resolvidos por ferramentas como Lex e Flex.",
                                  "commonMistakes": "Confundir análise léxica com sintática; ignorar o papel das expressões regulares."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Explorar o Propósito Principal de Lex e Flex",
                                  "subSteps": [
                                    "Defina Lex/Flex como geradores de analisadores léxicos que automatizam a criação de scanners.",
                                    "Estude a entrada: especificações em arquivos .l (Lex) ou .ll (Flex) com regras de expressões regulares.",
                                    "Aprenda o processo: Lex/Flex convertem regras em um AF determinístico (AFD) minimizado.",
                                    "Compreenda a saída: código C/Yacc executável para scanning eficiente.",
                                    "Instale Flex e execute 'flex --help' para ver opções básicas."
                                  ],
                                  "verification": "Liste 3 propósitos principais de Lex/Flex e descreva entrada/saída em um fluxograma simples.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Instalador de Flex (Linux/Mac: apt/brew install flex), exemplos de arquivos .l online"
                                  ],
                                  "tips": "Comece com Flex, pois é mais moderno e amplamente disponível.",
                                  "learningObjective": "Definir precisamente o que Lex e Flex fazem e seus insumos/produtos.",
                                  "commonMistakes": "Achar que Lex/Flex compilam diretamente; confundir com parsers como Yacc/Bison."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar o Processo de Geração de Código",
                                  "subSteps": [
                                    "Detalhe o algoritmo: construção de AF não-determinístico (AFN), conversão para AFD, minimização.",
                                    "Examine como ações C são associadas a padrões de regex (ex: {printf(\"TOKEN\");}).",
                                    "Compile e teste um exemplo: flex exemplo.l && gcc lex.yy.c -o scanner && ./scanner.",
                                    "Observe otimizações automáticas, como tabelas de transição compactas.",
                                    "Compare o código gerado com uma implementação manual equivalente."
                                  ],
                                  "verification": "Gere e execute um scanner simples; capture saída e explique uma otimização visível no código C.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Flex instalado, terminal, arquivo de teste com entrada léxica simples"
                                  ],
                                  "tips": "Use '%option noyywrap' para simplificar testes iniciais.",
                                  "learningObjective": "Explicar o mecanismo interno de geração de scanners otimizados.",
                                  "commonMistakes": "Ignorar estados de erro ou conflitos de regras; não compilar corretamente o código gerado."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Identificar Vantagens e Aplicações",
                                  "subSteps": [
                                    "Liste vantagens: portabilidade (independente de linguagem via C gerado), otimização automática de AF.",
                                    "Compare tempo/esforço: manual vs. Lex/Flex para 50+ regras.",
                                    "Discuta manutenção: fácil atualizar regras sem reescrever código.",
                                    "Explore usos em compiladores reais (GCC, Python lexer).",
                                    "Debata desvantagens menores, como overhead inicial de tabela."
                                  ],
                                  "verification": "Crie uma tabela comparativa (manual vs. Lex/Flex) com 5 critérios, justificando cada.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Papel ou planilha para tabela, artigos sobre compiladores open-source"
                                  ],
                                  "tips": "Pesquise 'Flex vs handwritten lexer' para cases reais.",
                                  "learningObjective": "Articular vantagens claras sobre implementações manuais.",
                                  "commonMistakes": "Superestimar simplicidade manual; ignorar portabilidade cross-platform."
                                }
                              ],
                              "practicalExample": "Crie um arquivo exemplo.l: %% [a-zA-Z]+ { printf(\"IDENTIFIER: %s\\n\", yytext); } [0-9]+ { printf(\"NUMBER: %s\\n\", yytext); } . { printf(\"UNKNOWN: %s\\n\", yytext); } %% int main() { yylex(); return 0; } Compile com 'flex exemplo.l && gcc lex.yy.c -o scanner' e teste com entrada 'var123 abc;' para ver tokens identificados.",
                              "finalVerifications": [
                                "Explique em 2 frases o propósito de Lex/Flex.",
                                "Descreva o fluxo: regex -> AF -> código C.",
                                "Liste 3 vantagens sobre manual.",
                                "Execute um exemplo prático e interprete saída.",
                                "Compare tamanho/linhas de código manual vs. gerado.",
                                "Identifique uma otimização automática no código gerado."
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição de propósito (entrada/saída/processo).",
                                "Compreensão de otimizações (AFN->AFD->minimizado).",
                                "Identificação correta de vantagens (portabilidade, eficiência).",
                                "Execução bem-sucedida de exemplo prático.",
                                "Análise comparativa clara e fundamentada.",
                                "Uso correto de terminologia (scanner, token, regex)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria de Autômatos Finitos e linguagens regulares.",
                                "Linguística: Processamento de linguagem natural com padrões regex.",
                                "Engenharia de Software: Automação de tarefas repetitivas e refatoração.",
                                "Algoritmos: Otimização de estruturas de decisão (tabelas de transição)."
                              ],
                              "realWorldApplication": "Lex/Flex são usados em compiladores como GCC (lexer do C++), interpretadores Python, editores de texto (grep avançado), e ferramentas de análise de logs para parsing rápido de padrões em petabytes de dados em data centers."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.7.2.1.2",
                            "name": "Comparar Lex e Flex com implementações manuais",
                            "description": "Analisar diferenças entre scanners gerados por Lex/Flex e aqueles codificados manualmente, destacando eficiência em tempo de reconhecimento, tratamento de backtracking e geração de tabelas de transição.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender Implementações Manuais de Scanners Léxicos",
                                  "subSteps": [
                                    "Revise os conceitos básicos de analisadores léxicos manuais, incluindo estados finitos e transições.",
                                    "Implemente um scanner manual simples para tokens como números, identificadores e operadores em uma linguagem de exemplo (ex: expressões aritméticas).",
                                    "Analise o código manual para identificar loops de reconhecimento, backtracking explícito e estruturas de decisão.",
                                    "Meça o tempo de reconhecimento manualmente com um profiler simples ou cronômetro para inputs variados.",
                                    "Documente a estrutura de tabelas de transição implícitas no código manual."
                                  ],
                                  "verification": "Código manual funcionando corretamente em testes com 10+ inputs diferentes, sem erros de parsing.",
                                  "estimatedTime": "2 hours",
                                  "materials": [
                                    "Editor de código (VS Code ou similar)",
                                    "Linguagem C ou Python",
                                    "Exemplos de gramáticas léxicas simples"
                                  ],
                                  "tips": "Comece com um alfabeto pequeno para evitar complexidade inicial; use diagramas de estado para visualizar.",
                                  "learningObjective": "Dominar a construção e análise de scanners codificados à mão.",
                                  "commonMistakes": [
                                    "Ignorar casos de borda como strings vazias",
                                    "Backtracking ineficiente levando a loops infinitos",
                                    "Não normalizar o input para testes consistentes"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Estudar Lex e Flex: Geração Automática de Scanners",
                                  "subSteps": [
                                    "Instale Lex/Flex e estude a sintaxe de regras regex (ex: %{} para ações).",
                                    "Crie especificações Lex/Flex equivalentes ao scanner manual do Step 1.",
                                    "Compile e gere o scanner automático usando comandos como 'lex file.l' e 'flex file.ll'.",
                                    "Examine o código gerado: identifique a tabela de transição DFA/NFA e rotinas de reconhecimento.",
                                    "Compare a estrutura gerada com o código manual em termos de tamanho e legibilidade."
                                  ],
                                  "verification": "Scanners Lex e Flex compilados e executando corretamente os mesmos testes do Step 1.",
                                  "estimatedTime": "2.5 hours",
                                  "materials": [
                                    "Flex/Lex instalados",
                                    "Documentação oficial de Flex (manual PDF)",
                                    "Compilador C/GCC"
                                  ],
                                  "tips": "Use opções como -d para debug e visualize o grafo de automato gerado com ferramentas como graphviz.",
                                  "learningObjective": "Entender como Lex/Flex automatizam a geração de scanners eficientes.",
                                  "commonMistakes": [
                                    "Erros de sintaxe em regras regex",
                                    "Não definir yylex() corretamente",
                                    "Ignorar diretivas como %option noyywrap"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar Comparação Prática de Eficiência",
                                  "subSteps": [
                                    "Prepare um conjunto de inputs de teste padronizado (pequeno, médio, grande; com ambiguidades).",
                                    "Meça tempos de reconhecimento: execute 1000 iterações por scanner e calcule médias.",
                                    "Analise backtracking: conte rejeições de transições nos códigos manual e automático.",
                                    "Extraia e compare tabelas de transição: tamanho, densidade e cobertura de estados.",
                                    "Registre métricas em uma tabela (tempo, backtracks, tamanho da tabela)."
                                  ],
                                  "verification": "Tabela de métricas preenchida com dados empíricos de pelo menos 5 inputs variados.",
                                  "estimatedTime": "3 hours",
                                  "materials": [
                                    "Scripts de benchmark (Python para automação)",
                                    "Profiler como gprof ou time command",
                                    "Planilha para métricas (Google Sheets)"
                                  ],
                                  "tips": "Use inputs com padrões ambíguos (ex: 'if' vs identificador) para destacar backtracking.",
                                  "learningObjective": "Coletar dados quantitativos para comparação objetiva.",
                                  "commonMistakes": [
                                    "Amostras de teste não representativas",
                                    "Não isolar variáveis como otimização de compilação",
                                    "Medições enviesadas por cache"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar e Sintetizar Diferenças",
                                  "subSteps": [
                                    "Compare tempos: discuta por que automáticos são mais rápidos (DFAs determinísticos).",
                                    "Avalie backtracking: manual requer código explícito vs. automático otimizado.",
                                    "Discuta tabelas de transição: geradas automaticamente vs. hardcoded ineficientes.",
                                    "Identifique trade-offs: flexibilidade manual vs. velocidade/mantenibilidade automática.",
                                    "Escreva um relatório resumindo achados com gráficos de performance."
                                  ],
                                  "verification": "Relatório de 1-2 páginas com tabelas, gráficos e conclusões claras.",
                                  "estimatedTime": "2 hours",
                                  "materials": [
                                    "Ferramenta de gráficos (Matplotlib ou Excel)",
                                    "Templates de relatório Markdown"
                                  ],
                                  "tips": "Use métricas normalizadas (tokens/segundo) para comparações justas.",
                                  "learningObjective": "Sintetizar insights qualitativos e quantitativos das comparações.",
                                  "commonMistakes": [
                                    "Viés subjetivo sem dados",
                                    "Omitir cenários onde manual é preferível (ex: linguagens exóticas)",
                                    "Generalizações excessivas"
                                  ]
                                }
                              ],
                              "practicalExample": "Implemente um scanner para uma mini-linguagem de expressões aritméticas (tokens: +, -, *, /, números, IDs). Compare tempo para input 'a=1+2*3-4;' em manual vs Lex/Flex: manual ~5ms, Flex ~0.5ms, com zero backtracks no Flex devido a DFA.",
                              "finalVerifications": [
                                "Capacidade de gerar scanners funcionais em ambos os métodos para novas gramáticas.",
                                "Tabela de métricas mostrando superioridade automática em >80% dos casos.",
                                "Explicação correta de como Flex minimiza backtracking via subset construction.",
                                "Identificação de 3+ vantagens/desvantagens de cada abordagem.",
                                "Relatório com gráficos reproduzíveis."
                              ],
                              "assessmentCriteria": [
                                "Precisão das implementações (sem erros de parsing em testes).",
                                "Qualidade das métricas (reprodutíveis, estatisticamente válidas).",
                                "Profundidade da análise (cobertura de tempo, backtracking, tabelas).",
                                "Clareza do relatório (estruturado, com evidências).",
                                "Compreensão conceitual (explicações corretas de DFAs vs. código manual).",
                                "Criatividade nos testes (inputs ambíguos e edge cases)."
                              ],
                              "crossCurricularConnections": [
                                "Teoria dos Autômatos: Comparação com AFDs/AFNs em Linguagens Formais.",
                                "Engenharia de Software: Otimização de performance e ferramentas automáticas.",
                                "Algoritmos: Análise de complexidade em reconhecimento de padrões.",
                                "Matemática Discreta: Grafos de transição e minimização de estados."
                              ],
                              "realWorldApplication": "Em compiladores como GCC/Clang, Lex/Flex aceleram desenvolvimento de front-ends, reduzindo tempo de parsing em 10x vs. manual, essencial para linguagens como C++ com vocabulários vastos."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.7.2.1.3",
                            "name": "Instalar e configurar Lex ou Flex",
                            "description": "Demonstrar passos para instalar Flex (sucessor moderno do Lex), compilar especificações .l em executáveis e testar scanners simples com entrada de texto.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Instalar o Flex no sistema operacional",
                                  "subSteps": [
                                    "Abra o terminal ou prompt de comando.",
                                    "Atualize a lista de pacotes: no Ubuntu/Debian use 'sudo apt update'; no macOS com Homebrew 'brew update'; no Windows use WSL ou Cygwin.",
                                    "Instale o Flex: 'sudo apt install flex' (Linux), 'brew install flex' (macOS), ou baixe binários para Windows.",
                                    "Confirme a instalação executando 'flex --version'."
                                  ],
                                  "verification": "Comando 'flex --version' retorna uma versão do Flex (ex: 2.6.4 ou superior) sem erros.",
                                  "estimatedTime": "15-20 minutos",
                                  "materials": [
                                    "Terminal/Prompt de comando",
                                    "Acesso administrador (sudo ou admin)",
                                    "Conexão à internet"
                                  ],
                                  "tips": "Use gerenciadores de pacotes para evitar problemas de dependências; em Windows, prefira WSL2 para compatibilidade Unix-like.",
                                  "learningObjective": "Entender o processo de instalação de ferramentas de linha de comando em diferentes SOs.",
                                  "commonMistakes": [
                                    "Esquecer de usar sudo/admin",
                                    "Não atualizar pacotes antes",
                                    "Instalar versão errada (Lex antigo ao invés de Flex)"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Configurar o ambiente de desenvolvimento",
                                  "subSteps": [
                                    "Crie um diretório de trabalho: 'mkdir flex-project && cd flex-project'.",
                                    "Instale um editor de texto como Vim, Nano ou VS Code se necessário.",
                                    "Verifique se gcc ou outro compilador C está instalado: 'gcc --version'; instale se ausente (ex: 'sudo apt install gcc').",
                                    "Configure PATH se o flex não for reconhecido: adicione ao ~/.bashrc ou equivalente e recarregue com 'source ~/.bashrc'."
                                  ],
                                  "verification": "Comandos 'flex --version' e 'gcc --version' funcionam do diretório de trabalho sem erros de PATH.",
                                  "estimatedTime": "10-15 minutos",
                                  "materials": [
                                    "Editor de texto",
                                    "Compilador C (gcc/clang)",
                                    "Terminal"
                                  ],
                                  "tips": "Teste o ambiente com um 'echo $PATH' para confirmar inclusão de /usr/bin ou similar.",
                                  "learningObjective": "Configurar um workspace funcional para desenvolvimento de ferramentas de compiladores.",
                                  "commonMistakes": [
                                    "Não instalar gcc",
                                    "PATH não atualizado",
                                    "Diretório de trabalho com espaços no nome"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Criar e compilar uma especificação léxica simples (.l)",
                                  "subSteps": [
                                    "Crie um arquivo 'simple.l' com regras básicas: seção definitions, rules (ex: [0-9]+ { printf(\"NUMERO\"); }, %% main() { yylex(); } %% ).",
                                    "Salve o arquivo e execute 'flex simple.l' para gerar lex.yy.c.",
                                    "Compile o código gerado: 'gcc lex.yy.c -o simple_scanner'.",
                                    "Verifique se não há erros de compilação."
                                  ],
                                  "verification": "Arquivo 'lex.yy.c' gerado e executável 'simple_scanner' criado sem warnings/erros.",
                                  "estimatedTime": "20-30 minutos",
                                  "materials": [
                                    "Editor de texto",
                                    "Flex instalado",
                                    "GCC/Clang"
                                  ],
                                  "tips": "Use %% para separar seções; inclua <stdio.h> se necessário no código C.",
                                  "learningObjective": "Escrever e compilar especificações léxicas básicas para reconhecimento de tokens.",
                                  "commonMistakes": [
                                    "Falta de %% no final da seção rules",
                                    "Erros de sintaxe em regex (ex: esquecer + ou * )",
                                    "Não nomear actions corretamente"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Testar o scanner com entrada de texto",
                                  "subSteps": [
                                    "Crie um arquivo 'input.txt' com texto de teste: ex: '123 abc 456 if'.",
                                    "Execute o scanner: './simple_scanner < input.txt' e observe a saída.",
                                    "Crie casos de teste variados: input inválido, vazio, múltiplos tokens.",
                                    "Debugue se necessário editando simple.l, recompilando e retestando."
                                  ],
                                  "verification": "Scanner processa input.txt corretamente, imprimindo tokens identificados sem crash.",
                                  "estimatedTime": "15-25 minutos",
                                  "materials": [
                                    "Arquivos de input de teste",
                                    "Executável compilado"
                                  ],
                                  "tips": "Redirecione input com < para simular stdin; use printf no action para debug.",
                                  "learningObjective": "Validar o funcionamento de um analisador léxico com entradas reais.",
                                  "commonMistakes": [
                                    "Não redirecionar input corretamente",
                                    "Regex não cobrindo todos casos",
                                    "Falta de tratamento de EOF"
                                  ]
                                }
                              ],
                              "practicalExample": "Crie um scanner em 'tokens.l' que reconhece números inteiros ([0-9]+), identificadores ([a-zA-Z][a-zA-Z0-9]*), palavras-chave 'if' e 'while', e ignora espaços. Compile com 'flex tokens.l && gcc lex.yy.c -ll -o tokens'. Teste com input: 'if x=1 while y<10' e espere saída: 'IF ID= NUM=1 WHILE ID=y NUM=10'.",
                              "finalVerifications": [
                                "Flex instalado e versão exibida corretamente.",
                                "Ambiente configurado com gcc e PATH ok.",
                                "Especificação .l compila sem erros em lex.yy.c e executável.",
                                "Scanner testa com múltiplos inputs, produzindo output correto.",
                                "Nenhum crash ou comportamento indefinido em testes edge-case.",
                                "Capacidade de modificar regras e recompilar rapidamente."
                              ],
                              "assessmentCriteria": [
                                "Instalação e configuração sem intervenção manual excessiva.",
                                "Código .l sintaticamente correto e funcional.",
                                "Compilação e linkagem bem-sucedidas (incluindo -lfl se necessário).",
                                "Reconhecimento preciso de tokens em testes variados.",
                                "Debugging eficiente de erros comuns.",
                                "Documentação básica dos testes realizados."
                              ],
                              "crossCurricularConnections": [
                                "Programação em C: Integração com código gerado em C.",
                                "Teoria da Computação: Autômatos finitos e linguagens regulares.",
                                "Sistemas Operacionais: Gerenciamento de pacotes e ambiente shell.",
                                "Engenharia de Software: Ferramentas de automação e build systems.",
                                "Processamento de Linguagem Natural: Tokenização básica de texto."
                              ],
                              "realWorldApplication": "Flex é usado em compiladores como GCC e LLVM para análise léxica inicial; em ferramentas como awk, grep customizados, analisadores de logs em DevOps, editores de texto (Vim syntax highlighting) e processadores de configuração em CI/CD pipelines."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.7.2.2",
                        "name": "Especificação de Regras Léxicas com Expressões Regulares",
                        "description": "Aprender a definir padrões léxicos usando expressões regulares em ferramentas como Flex, incluindo ações associadas e precedência de regras.",
                        "specificSkills": [
                          {
                            "id": "10.1.7.2.2.1",
                            "name": "Escrever expressões regulares para tokens comuns",
                            "description": "Construir padrões para identificar tokens como identificadores, números inteiros, literais de string e operadores em linguagens de programação, usando metacaracteres como *, +, ?, | e classes de caracteres [a-z].",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender tokens comuns e fundamentos de expressões regulares",
                                  "subSteps": [
                                    "Identifique tokens comuns: identificadores (ex: var123), números inteiros (ex: 123), literais de string (ex: \"hello\"), operadores (ex: +, ==).",
                                    "Revise metacaracteres básicos: * (zero ou mais), + (um ou mais), ? (zero ou um), | (ou), . (qualquer char exceto newline).",
                                    "Estude classes de caracteres: [a-zA-Z] para letras, [0-9] para dígitos, \\w para alfanumérico.",
                                    "Pratique âncoras: ^ (início), $ (fim), \\b (limite de palavra).",
                                    "Compile uma lista de 5 exemplos de cada token de uma linguagem como Python ou C."
                                  ],
                                  "verification": "Crie um glossário pessoal com definições e 3 exemplos por token; revise sem erros.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Documentação Regex (MDN ou regex101.com)",
                                    "Lista de tokens de uma linguagem de programação (ex: Python lexer spec)"
                                  ],
                                  "tips": "Use regex101.com para testar padrões em tempo real enquanto aprende.",
                                  "learningObjective": "Compreender a estrutura de tokens léxicos e os metacaracteres essenciais para padrões regex.",
                                  "commonMistakes": [
                                    "Confundir * com + (zero vs um ou mais)",
                                    "Esquecer escapes para chars especiais como . ou *"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Construir expressões regulares para identificadores",
                                  "subSteps": [
                                    "Defina identificadores: começam com letra ou _, seguidos de letras, dígitos ou _.",
                                    "Escreva regex básica: [a-zA-Z_][a-zA-Z_0-9]*",
                                    "Teste com exemplos: matches 'var', 'loop123', '_private'; não matches '123abc', ' var'.",
                                    "Adicione case-insensitivity com flags ou [a-zA-Z].",
                                    "Refine para evitar keywords reservadas usando lookahead negativo (opcional: (?!keyword$).",
                                    "Valide 10 exemplos positivos e 5 negativos."
                                  ],
                                  "verification": "Sua regex matches todos identificadores válidos em um conjunto de 15 testes sem falsos positivos.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Regex101.com ou RegExr",
                                    "Exemplos de código fonte de Python/C"
                                  ],
                                  "tips": "Sempre teste com edge cases como identificadores longos ou com underline inicial.",
                                  "learningObjective": "Dominar a criação de regex para identificadores usando classes de caracteres e quantificadores.",
                                  "commonMistakes": [
                                    "Permitir início com dígito: [a-zA-Z0-9_]+ em vez de [a-zA-Z_][a-zA-Z0-9_]*",
                                    "Esquecer o * no final"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Desenvolver regex para números inteiros e literais de string",
                                  "subSteps": [
                                    "Para números inteiros: [0-9]+ ou mais preciso -?[0-9]+ para negativos opcionais.",
                                    "Teste: matches '123', '-456', '0'; não '12.3', 'abc'.",
                                    "Para strings: \"[^\"\\\\]*(\\\\.[^\"\\\\]*)*\" para escapar aspas internas.",
                                    "Alternativa simples: \"(.*?)\" com non-greedy.",
                                    "Teste strings com escapes: \"hello\\\"world\"",
                                    "\"he\"llo\".",
                                    "Crie e valide regex para 8 números e 8 strings variadas."
                                  ],
                                  "verification": "Regex captura corretamente números e strings em um snippet de código de 20 linhas.",
                                  "estimatedTime": "75 minutos",
                                  "materials": [
                                    "Editor com suporte a regex (VS Code)",
                                    "Snippets de código com números/strings"
                                  ],
                                  "tips": "Use non-greedy ? para strings que podem conter aspas escapadas.",
                                  "learningObjective": "Criar padrões precisos para números e strings, lidando com escapes e opcionais.",
                                  "commonMistakes": [
                                    "Regex guloso para strings: \".*\" captura múltiplas strings",
                                    "Não lidar com negativos em números"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Criar regex para operadores e testar integração completa",
                                  "subSteps": [
                                    "Liste operadores comuns: [+\\-*/=()\\[\\]{};,!&|><]",
                                    "Escreva regex: [\\+\\-*/=()\\[\\]{};,!&|\\-\\>\\=\\=]",
                                    "Escape todos chars especiais: use \\ para +, *, etc.",
                                    "Integre todos: crie um padrão lexer simples com | para priorizar (ex: identificador antes de keywords).",
                                    "Teste em código real: tokenizar um programa pequeno.",
                                    "Debug falhas usando visualizadores regex."
                                  ],
                                  "verification": "Tokenizador divide corretamente um programa de 50 linhas em tokens sem overlaps ou misses.",
                                  "estimatedTime": "90 minutos",
                                  "materials": [
                                    "Código fonte exemplo (Python hello world)",
                                    "Ferramenta online de lexer como regex101 com flavor JS/Python"
                                  ],
                                  "tips": "Ordene padrões por comprimento decrescente no | para priorizar operadores longos como == antes de =.",
                                  "learningObjective": "Integrar regex para todos tokens comuns e validar em contexto real.",
                                  "commonMistakes": [
                                    "Não escapar operadores: + matches um char em vez de operador",
                                    "Overlaps: número matching identificador"
                                  ]
                                }
                              ],
                              "practicalExample": "Escreva um lexer simples em JavaScript usando regex para tokenizar: var x = 123 + \"hello\"; Resultado: ['var', 'x', '=', '123', '+', '\"hello\"', ';'] com padrões: /[a-zA-Z_][a-zA-Z0-9_]*/g para IDs, /\\d+/g para números, /[\\+\\-*/=;()]/g para ops, /\"[^\"]*\"/g para strings.",
                              "finalVerifications": [
                                "Regex para ID matches 'abc123_' mas rejeita '123abc'.",
                                "Número regex captura '-42' e '0' corretamente.",
                                "String regex lida com \"esc\\apped\\\" corretamente.",
                                "Operadores como '==' e '!=' são distinguished de '=' e '!'.",
                                "Tokenização completa de um loop simples sem erros.",
                                "Nenhum overlap ou miss em 100 linhas de código teste."
                              ],
                              "assessmentCriteria": [
                                "Precisão: 95%+ match rate em testes padronizados.",
                                "Eficiência: Regex sem backtracking excessivo (ver perf no regex101).",
                                "Cobertura: Todos tokens comuns (ID, num, str, ops) sem exceções.",
                                "Legibilidade: Padrões comentados e modulares.",
                                "Robustez: Lida com edge cases como strings vazias ou IDs longos.",
                                "Integração: Funciona em um lexer funcional."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria de linguagens formais e autômatos finitos.",
                                "Linguística: Análise morfológica e padrões sintáticos.",
                                "Engenharia de Software: Parsing e ferramentas de desenvolvimento.",
                                "Processamento de Dados: Extração de padrões em big data (ex: grep, log analysis)."
                              ],
                              "realWorldApplication": "Desenvolvimento de compiladores (ex: geradores como Flex/Lex), editores de texto (VS Code syntax highlighting), validação de inputs em web apps (email patterns), análise de logs em DevOps, e search engines para código fonte."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.7.2.1.1"
                            ]
                          },
                          {
                            "id": "10.1.7.2.2.2",
                            "name": "Definir ações e retornar tokens",
                            "description": "Associar ações C a cada regra léxica, retornando códigos de tokens (yylval) para integração com analisadores sintáticos, e gerenciar estados de scanner com %states.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender e definir ações básicas associadas a regras léxicas",
                                  "subSteps": [
                                    "Leia a documentação do gerador léxico (ex: Flex) sobre seções de regras e ações C.",
                                    "Identifique uma regra léxica simples, como um identificador [a-zA-Z][a-zA-Z0-9]*.",
                                    "Escreva uma ação C básica que retorne um código de token constante, como return ID;.",
                                    "Compile o scanner gerado e teste com input simples para verificar reconhecimento.",
                                    "Adicione tratamento para padrões não reconhecidos usando { ECHO; }."
                                  ],
                                  "verification": "O scanner compila sem erros e imprime ou retorna o token correto para o padrão testado.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Documentação do Flex/JFlex",
                                    "Editor de texto/IDE",
                                    "Terminal para compilar e executar"
                                  ],
                                  "tips": "Sempre termine ações com ; e defina códigos de token em um header compartilhado com o parser.",
                                  "learningObjective": "Dominar a associação de ações C simples a padrões regulares para retornar tokens básicos.",
                                  "commonMistakes": [
                                    "Esquecer o ponto e vírgula no final da ação",
                                    "Não definir códigos de token como #define ID 258",
                                    "Ignorar yylineno para rastreio de erros"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar retorno de valores semânticos usando yylval",
                                  "subSteps": [
                                    "Declare yylval no header como union { int num; char* str; } yylval;.",
                                    "Para uma regra de número inteiro [0-9]+, converta yytext para int com atoi(yytext) e atribua yylval.num = atoi(yytext); return NUMBER;.",
                                    "Para strings ou IDs, use strdup(yytext) para yylval.str e retorne o token apropriado.",
                                    "Teste com input contendo números e IDs, verificando se yylval é populado corretamente no parser stub.",
                                    "Libere memória alocada em strdup para evitar leaks, usando um handler de cleanup."
                                  ],
                                  "verification": "Inspecione yylval após match via printf ou debugger; valores corretos são atribuídos e token retornado.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Header com definições de tokens e yylval",
                                    "Exemplos de código C para atoi e strdup",
                                    "Valgrind para checar memory leaks"
                                  ],
                                  "tips": "Use yytext apenas dentro da ação, pois é sobrescrito; prefira strtol para números com error checking.",
                                  "learningObjective": "Habilitar integração léxica-sintática passando dados semânticos via yylval para o parser.",
                                  "commonMistakes": [
                                    "Não inicializar yylval antes da atribuição",
                                    "Buffer overflow ao usar sprintf sem limites",
                                    "Não incluir <stdlib.h> para atoi"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Gerenciar estados de scanner com %states",
                                  "subSteps": [
                                    "Declare estados na seção de definições: %states COMMENT STRING.",
                                    "Crie regra para entrar em estado: \"/*\" { BEGIN(COMMENT); }.",
                                    "Em estado COMMENT, ignore até \"*/\": <COMMENT>\"*/\" { BEGIN(INITIAL); }.",
                                    "Aplique a estados: <STRING>\" { yylval.str = strdup(yytext); BEGIN(INITIAL); return STRING_LITERAL; }.",
                                    "Teste com input contendo comentários e strings, garantindo que scanner saia dos estados corretamente."
                                  ],
                                  "verification": "Scanner processa corretamente inputs com estados aninhados sem travar ou matching incorreto.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Exemplos de Flex com estados da documentação oficial",
                                    "Test cases com comentários e strings multiline"
                                  ],
                                  "tips": "Use <INITIAL> para regras globais; liste múltiplos estados como <COMMENT,STRING> para regras compartilhadas.",
                                  "learningObjective": "Controlar comportamento condicional do scanner para lidar com contextos especiais como comentários e strings.",
                                  "commonMistakes": [
                                    "Esquecer de sair do estado com BEGIN(INITIAL)",
                                    "Regras sem <estado> que interferem",
                                    "Estados não declarados causando erros de compilação"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Integrar ações com parser sintático e depurar",
                                  "subSteps": [
                                    "Gere o parser com Bison/Yacc incluindo yylex() do scanner.",
                                    "Adicione ações no parser que usem yylval, como $$ = yylval.num para expressões numéricas.",
                                    "Compile scanner+parser juntos e teste com input válido de uma mini-linguagem.",
                                    "Use yydebug=1 e flex -d para debug traces; identifique mismatches de tokens.",
                                    "Otimize ações removendo código desnecessário e adicionando error reporting com yyerror."
                                  ],
                                  "verification": "Sistema completo (scanner+parser) analisa input sem erros léxicos/sintáticos e constrói AST parcial.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Bison/Flex integrados",
                                    "Mini-gramática de teste",
                                    "GDB ou printf para debugging"
                                  ],
                                  "tips": "Mantenha yylex() acessível externamente; use %union no parser para yylval.",
                                  "learningObjective": "Garantir interoperabilidade total entre scanner e parser via ações e tokens.",
                                  "commonMistakes": [
                                    "Mismatch de códigos de token entre scanner e parser",
                                    "yyin não setado para input file",
                                    "Infinite loops em estados mal gerenciados"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um scanner para mini-C: regra para números '([1-9][0-9]*)' { yylval.num = atoi(yytext); return NUMBER; } e para comentários '%{ /* ... */ %}' com estados: \"/*\" { BEGIN(COMMENT); } <COMMENT>\"*/\" { BEGIN(INITIAL); } <COMMENT><<EOF>> { yyerror(\"Unclosed comment\"); }",
                              "finalVerifications": [
                                "Scanner compila e executa sem warnings ou erros de sintaxe C.",
                                "Input de teste retorna sequência correta de tokens com yylval populado (verificado via dump).",
                                "Estados são gerenciados corretamente: comentários ignorados, strings escapadas processadas.",
                                "Integração com parser: yylex() alimenta tokens válidos sem rejeições.",
                                "Sem memory leaks ou buffer overflows em Valgrind.",
                                "Debug traces mostram matching e transições de estado esperadas."
                              ],
                              "assessmentCriteria": [
                                "Ações C são sintaticamente corretas e eficientes (sem código redundante).",
                                "Uso preciso de yylval com tipos adequados e sem vazamentos de memória.",
                                "Estados declarados e transitados corretamente, cobrindo casos edge como EOF.",
                                "Tokens definidos consistentemente para integração parser-scanner.",
                                "Tratamento robusto de erros e padrões não reconhecidos.",
                                "Testes demonstram funcionalidade completa com exemplos reais."
                              ],
                              "crossCurricularConnections": [
                                "Teoria da Computação: Autômatos finitos com estados para reconhecimento léxico.",
                                "Programação em C: Manipulação de ponteiros, strings e unions em yylval.",
                                "Engenharia de Software: Modularidade em ferramentas de compiladores (Flex+Bison).",
                                "Processamento de Linguagem Natural: Tokenização similar a pré-processamento de texto.",
                                "Debugging e Testing: Uso de traces e ferramentas para validar analisadores."
                              ],
                              "realWorldApplication": "Em compiladores profissionais como GCC ou Clang, scanners gerados por Flex definem ações para retornar tokens e valores semânticos (ex: posição de símbolos na tabela), gerenciando estados para strings e comentários, permitindo análise eficiente de código fonte em larga escala para IDEs, otimizadores e interpretadores."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.7.2.2.1"
                            ]
                          },
                          {
                            "id": "10.1.7.2.2.3",
                            "name": "Gerenciar precedência e exclusões léxicas",
                            "description": "Usar regras ordenadas para resolver ambiguidades, excluir padrões com ^ e !, e otimizar com diretivas como %option noyywrap para evitar funções desnecessárias.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender e Implementar Precedência por Ordenação de Regras",
                                  "subSteps": [
                                    "Estude a documentação do Flex/Lex sobre como regras são avaliadas sequencialmente da primeira para a última.",
                                    "Crie um arquivo .l básico com regras para tokens simples (ex: números, IDs, operadores).",
                                    "Ordene as regras para que as mais específicas venham primeiro (ex: 'if' antes de IDs).",
                                    "Compile e teste com input ambíguo para observar resolução.",
                                    "Ajuste a ordem até resolver ambiguidades corretamente."
                                  ],
                                  "verification": "Execute o lexer com input ambíguo e confirme que o token mais específico é reconhecido primeiro.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Flex instalado, editor de texto (VS Code), terminal, arquivo exemplo.l",
                                  "tips": "Sempre coloque regras mais longas/específicas no topo; use {n} para comprimentos variáveis.",
                                  "learningObjective": "Explicar como a ordenação sequencial resolve precedência em analisadores léxicos.",
                                  "commonMistakes": "Colocar regras genéricas antes de específicas, causando matching prematuro."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Aplicar Exclusões Léxicas com ^ e !",
                                  "subSteps": [
                                    "Aprenda a sintaxe: ^ para negação de início de linha, ! para precedência negativa em Flex.",
                                    "Adicione regras de exclusão ao arquivo .l (ex: !\"//\".* para excluir comentários de linha).",
                                    "Use ^ em padrões como ^[ \t]* para excluir indentação inicial em certas regras.",
                                    "Teste com inputs contendo padrões excluídos e verifique se são ignorados corretamente.",
                                    "Combine com precedência: exclua antes de regras principais."
                                  ],
                                  "verification": "Input com padrões excluídos deve rejeitá-los sem matching em regras subsequentes.",
                                  "estimatedTime": "40 minutos",
                                  "materials": "Flex instalado, editor de texto, terminal, arquivo exemplo.l atualizado",
                                  "tips": "! funciona apenas em Flex; teste com yyinput para casos edge.",
                                  "learningObjective": "Implementar exclusões para refinar matching léxico sem conflitos.",
                                  "commonMistakes": "Esquecer de ancorar ^ corretamente, causando matches parciais indesejados."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Otimizar com Diretivas como %option noyywrap",
                                  "subSteps": [
                                    "Estude opções do Flex: %option noyywrap desabilita yywrap() para performance.",
                                    "Adicione %option noyywrap, nodefault, nounput ao topo do arquivo .l.",
                                    "Compile com flex -l exemplo.l para otimização máxima.",
                                    "Meça performance com inputs grandes (ex: tempo de lexing).",
                                    "Compare antes/depois para validar ganhos."
                                  ],
                                  "verification": "Código gerado não contém yywrap() e lexer roda mais rápido em benchmarks simples.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Flex instalado, terminal, script de benchmark (ex: time ./lexer < large_input.txt)",
                                  "tips": "Use %option reentrant para threads; evite noyywrap se precisar de múltiplos arquivos.",
                                  "learningObjective": "Aplicar diretivas para eliminar funções desnecessárias e otimizar o lexer.",
                                  "commonMistakes": "Não recompilar após adicionar %option, mantendo código antigo."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Integrar, Testar e Depurar Precedência e Exclusões",
                                  "subSteps": [
                                    "Crie suíte de testes com casos ambíguos, excluídos e otimizados.",
                                    "Execute flex e ./lexer < test_cases.txt | diff - expected.txt.",
                                    "Use flex -d para debug e analise yytext em ambiguidades.",
                                    "Ajuste regras baseando em falhas e reordene se necessário.",
                                    "Documente o arquivo .l com comentários explicando precedência."
                                  ],
                                  "verification": "100% de pass nos testes; sem warnings de compilação; performance otimizada.",
                                  "estimatedTime": "50 minutos",
                                  "materials": "Flex com debug (-d), arquivos de teste, diff tool",
                                  "tips": "Adicione ECHO para regras desconhecidas durante debug.",
                                  "learningObjective": "Validar holisticamente o gerenciamento de precedência e exclusões em um lexer funcional.",
                                  "commonMistakes": "Ignorar EOF ou whitespace, causando loops infinitos."
                                }
                              ],
                              "practicalExample": "Em um lexer para expressões matemáticas: regra1: \"//\".* → excluir comentário; regra2: [0-9]+ → número (depois de excluir); regra3: [a-zA-Z]+ → ID (após números); %option noyywrap. Input: 'x=1+//com' → tokens: ID,=,NUMERO,+ (comentário excluído).",
                              "finalVerifications": [
                                "Regras ordenadas corretamente resolvem ambiguidades em testes.",
                                "Padrões com ^ e ! excluem matches indesejados sem vazamentos.",
                                "%option noyywrap ausente no código gerado (grep -i yywrap lexer.c).",
                                "Performance melhorada em inputs grandes (>20% mais rápido).",
                                "Nenhum warning em flex -t exemplo.l | gcc.",
                                "Debug com -d mostra yytext correto para precedências."
                              ],
                              "assessmentCriteria": [
                                "Precisão: 100% acerto em tokens ambíguos.",
                                "Eficiência: Tempo de lexing < 1s para 10k linhas.",
                                "Robustez: Trata EOF, whitespace e edge cases.",
                                "Otimização: Ausência de funções desnecessárias como yywrap.",
                                "Documentação: Comentários explicam cada regra de precedência.",
                                "Escalabilidade: Funciona com inputs reais sem crashes."
                              ],
                              "crossCurricularConnections": [
                                "Expressões Regulares em Python/Java (re module).",
                                "Lógica Proposicional: Precedência como ordem de avaliação.",
                                "Algoritmos: Otimização de automatos finitos (NFA to DFA).",
                                "Engenharia de Software: Refatoração e testes unitários."
                              ],
                              "realWorldApplication": "Desenvolvimento de compiladores (GCC/Clang usam Flex), parsers de logs em ferramentas DevOps (ELK Stack), editores de código (VS Code syntax highlighting), e validadores de configuração (YAML/JSON parsers)."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.7.2.2.1"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "10.1.7.2.3",
                        "name": "Geração, Otimização e Integração do Scanner",
                        "description": "Explorar o processo interno de geração de autômatos finitos determinísticos (AFDs), otimizações e integração com ferramentas como Yacc/Bison para compiladores completos.",
                        "specificSkills": [
                          {
                            "id": "10.1.7.2.3.1",
                            "name": "Entender o algoritmo de geração de AFDs",
                            "description": "Descrever como Flex converte NFAs de expressões regulares em AFDs minimizados via subconjuntos de Thompson e powerset, gerando tabelas de transição para execução rápida.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Construção de NFA a partir de Expressões Regulares usando Thompson",
                                  "subSteps": [
                                    "Estude as regras básicas de Thompson para cada operador regex: literal, concatenação, união (|), kleene (*), mais (+), opcional (?)",
                                    "Implemente um parser simples para converter uma regex em grafo NFA, adicionando estados epsilon",
                                    "Desenhe manualmente um NFA para uma regex simples como 'a(b|c)*'",
                                    "Verifique a equivalência simulando transições epsilon-closure",
                                    "Teste com múltiplas regex unidas por | para padrões alternativos"
                                  ],
                                  "verification": "Desenhe o NFA resultante e simule aceitação de strings válidas/inválidas",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Papel e lápis ou ferramenta de desenho como Draw.io",
                                    "Documentação de Thompson's construction",
                                    "Exemplos de regex de compiladores"
                                  ],
                                  "tips": "Sempre compute epsilon-closures antes de transições para simular corretamente",
                                  "learningObjective": "Dominar a transformação determinística de regex em NFAs com transições epsilon",
                                  "commonMistakes": [
                                    "Esquecer epsilon-transições em loops kleene",
                                    "Não tratar corretamente estados iniciais/finais múltiplos"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Subset Construction: Conversão de NFA em DFA via Powerset",
                                  "subSteps": [
                                    "Calcule o epsilon-closure do estado inicial do NFA para formar o primeiro conjunto de estados do DFA",
                                    "Para cada conjunto atual, compute transições para cada símbolo do alfabeto, aplicando move e epsilon-closure",
                                    "Adicione novos conjuntos à fila de processamento até não haver mais estados não visitados",
                                    "Marque estados finais: aqueles que incluem pelo menos um estado final do NFA",
                                    "Otimize removendo conjuntos vazios ou inalcançáveis"
                                  ],
                                  "verification": "Construa a tabela de transição do DFA e valide com strings de teste do NFA original",
                                  "estimatedTime": "3 horas",
                                  "materials": [
                                    "Implementação em Python ou ferramenta como JFLAP",
                                    "Exemplo NFA da etapa anterior",
                                    "Alfabeto de símbolos léxicos"
                                  ],
                                  "tips": "Use bitsets ou conjuntos para representar subconjuntos eficientemente em implementações",
                                  "learningObjective": "Entender como eliminar não-determinismo criando um DFA exponencial via powerset",
                                  "commonMistakes": [
                                    "Não propagar epsilon-closures corretamente",
                                    "Perder estados durante a fila BFS"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Minimização do DFA usando Algoritmo de Hopcroft ou Partições",
                                  "subSteps": [
                                    "Particione estados iniciais em finais e não-finais",
                                    "Refine partições iterativamente: para cada par de estados em partição diferente, divida se houver transições para partições distintas",
                                    "Use refinamento com splitters para eficiência O(n log n)",
                                    "Mesclar estados equivalentes, preservando transições",
                                    "Verifique que o DFA minimizado aceita as mesmas strings"
                                  ],
                                  "verification": "Compare número de estados antes/depois e valide equivalência com testes",
                                  "estimatedTime": "2.5 horas",
                                  "materials": [
                                    "Código de minimização ou JFLAP",
                                    "DFA da etapa 2",
                                    "Teoria de Hopcroft's algorithm"
                                  ],
                                  "tips": "Implemente com tabelas de partições para evitar comparações quadráticas",
                                  "learningObjective": "Aprender a reduzir estados redundantes no DFA para otimização",
                                  "commonMistakes": [
                                    "Não dividir partições corretamente em refinamentos",
                                    "Mesclar estados não-equivalentes"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Geração de Tabelas de Transição Otimizadas para Execução Rápida",
                                  "subSteps": [
                                    "Mapeie estados minimizados para índices compactos (0 a n-1)",
                                    "Crie array 2D: linhas=estados, colunas=símbolos, valores=próximo estado",
                                    "Otimize com tabelas de faixas para símbolos ASCII (buckets por ranges)",
                                    "Gere código C ou equivalente para o scanner, integrando ações semânticas",
                                    "Teste performance com input léxico real, medindo throughput"
                                  ],
                                  "verification": "Execute o scanner gerado em um arquivo de teste e compare tokens com analisador manual",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Flex ou re2c source code como referência",
                                    "Compilador C",
                                    "Arquivos de teste léxicos"
                                  ],
                                  "tips": "Use default transitions para símbolos irrelevantes, reduzindo tamanho da tabela",
                                  "learningObjective": "Gerar estruturas de dados eficientes para lookup O(1) em tempo de execução",
                                  "commonMistakes": [
                                    "Índices incorretos em mapeamento de estados",
                                    "Não comprimir ranges de símbolos"
                                  ]
                                }
                              ],
                              "practicalExample": "Use Flex para processar regex 'int|float|if|while' em um lexer simples para uma linguagem mini-C, trace o NFA->DFA->min->tabela gerada e execute em código fonte para tokenizar 'int x = 1.0;'",
                              "finalVerifications": [
                                "Explique verbalmente o fluxo completo: regex -> NFA -> DFA -> minDFA -> tabela",
                                "Desenhe diagramas para um exemplo com 5+ estados antes/depois minimização",
                                "Implemente subset construction manualmente para uma regex NFA com 10 estados",
                                "Compare performance de execução entre NFA simulado e tabela DFA",
                                "Identifique e corrija um DFA não-minimizado com estados equivalentes",
                                "Gere e valide tabela para alfabeto estendido (letras, dígitos, símbolos)"
                              ],
                              "assessmentCriteria": [
                                "Precisão na descrição de epsilon-closures e subset construction (80%+ correto)",
                                "Correção na minimização: DFA resultante tem estados mínimos e equivalente",
                                "Eficiência da tabela gerada: lookup O(1) com otimização de ranges",
                                "Validação com testes: 100% acurácia em 20+ strings de aceitação/rejeição",
                                "Explicação clara de trade-offs: exponencial em teoria, prático em lexers",
                                "Integração conceitual com ações semânticas em scanners"
                              ],
                              "crossCurricularConnections": [
                                "Teoria da Computação: Autômatos finitos e linguagens regulares",
                                "Estruturas de Dados: Conjuntos, grafos e tabelas hash para otimizações",
                                "Algoritmos: BFS para subset, particionamento para minimização",
                                "Engenharia de Software: Geração de código em ferramentas como Flex/ANTLR",
                                "Análise de Performance: Trade-offs tempo/espaço em compiladores"
                              ],
                              "realWorldApplication": "Em compiladores como GCC/Clang, editores como VSCode (regex search), ferramentas de parsing como grep/awk, onde scanners léxicos processam milhões de linhas/segundo via tabelas DFA otimizadas para alta performance."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.7.2.1.2"
                            ]
                          },
                          {
                            "id": "10.1.7.2.3.2",
                            "name": "Otimizar scanners gerados",
                            "description": "Aplicar opções como %option perf-report para analisar performance, reentrant para threads e 8bit para caracteres estendidos, reduzindo tamanho e tempo de execução.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Gerar e Compilar Scanner Básico",
                                  "subSteps": [
                                    "Escreva um arquivo .l simples com regras léxicas básicas para tokens como números, identificadores e operadores.",
                                    "Compile o scanner usando flex comando: flex scanner.l",
                                    "Compile o código gerado com gcc: gcc lex.yy.c -o scanner",
                                    "Teste o scanner com input de amostra para garantir funcionamento básico.",
                                    "Meça tempo de execução e tamanho do executável inicial usando time e ls -lh."
                                  ],
                                  "verification": "Scanner compila sem erros e reconhece tokens corretamente em teste simples; registre métricas iniciais de tempo e tamanho.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Flex instalado, GCC, editor de texto, arquivo de teste de input com tokens variados.",
                                  "tips": "Use yywrap() para evitar warnings; comece com regras mínimas para isolar baseline.",
                                  "learningObjective": "Compreender o processo de geração padrão de scanner e estabelecer baseline de performance.",
                                  "commonMistakes": "Esquecer de linkar -lfl no gcc; regras léxicas ambíguas levando a falhas de parsing."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar Performance com %option perf-report",
                                  "subSteps": [
                                    "Adicione %option perf-report ao topo do arquivo .l.",
                                    "Recompile o scanner: flex scanner.l && gcc lex.yy.c -o scanner_perf.",
                                    "Execute o scanner com input grande e analise o relatório gerado (scanner_perf.perfreport).",
                                    "Identifique gargalos como estados mais visitados, caracteres problemáticos e transições ineficientes.",
                                    "Registre métricas quantitativas: tempo total, % de CPU em matching, tamanho do .yy.c."
                                  ],
                                  "verification": "Relatório perf-report gerado e interpretado; anote top 3 gargalos identificados.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Scanner básico do Step 1, input de teste grande (ex: 10k linhas de código fonte).",
                                  "tips": "Use input representativo do uso real para relatório preciso; ignore relatórios com input pequeno.",
                                  "learningObjective": "Aprender a usar perf-report para diagnosticar ineficiências no scanner gerado.",
                                  "commonMistakes": "Não recompilar após adicionar opção; misinterpretar relatório confundindo estados com regras."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Aplicar Opções de Otimização Específicas",
                                  "subSteps": [
                                    "Adicione %option reentrant para suporte a threads: %option reentrant no .l.",
                                    "Inclua %option 8bit para handling de caracteres estendidos eficientemente.",
                                    "Combine com outras como %option noyywrap e %option nounput para reduções adicionais.",
                                    "Recompile e gere novo executável otimizado.",
                                    "Execute com mesmo input para coletar novas métricas."
                                  ],
                                  "verification": "Scanner otimizado compila e executa sem erros; compare tamanho e tempo vs baseline.",
                                  "estimatedTime": "40 minutos",
                                  "materials": "Arquivo .l do Step 2, documentação Flex para opções.",
                                  "tips": "Teste reentrant com pthread_create se aplicável; 8bit só se input tiver chars >127.",
                                  "learningObjective": "Dominar aplicação de %option perf-report, reentrant e 8bit para otimizar scanner.",
                                  "commonMistakes": "Usar reentrant sem ajustar main() para yylex_init; ignorar compatibilidade de input."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Validar e Comparar Otimizações",
                                  "subSteps": [
                                    "Rode testes comparativos: time ./scanner vs time ./scanner_otimizado com múltiplos inputs.",
                                    "Gere novo perf-report na versão otimizada e compare com anterior.",
                                    "Meça redução em tamanho (ls -lh) e tempo de execução (% melhoria).",
                                    "Teste em cenários multi-thread se reentrant usado.",
                                    "Documente ganhos e ajustes finais necessários."
                                  ],
                                  "verification": "Relatório final mostra redução >=20% em tempo/tamanho; scanner funcional em todos testes.",
                                  "estimatedTime": "35 minutos",
                                  "materials": "Executáveis baseline e otimizado, scripts de teste automatizados.",
                                  "tips": "Use hyperfine para benchmarks precisos; rode 10+ execuções para média confiável.",
                                  "learningObjective": "Avaliar efetividade das otimizações e iterar para melhorias.",
                                  "commonMistakes": "Comparar em hardware inconsistente; overlook overhead de reentrant em single-thread."
                                }
                              ],
                              "practicalExample": "Otimize um scanner Flex para lexer de uma mini-linguagem de config (tokens: chaves, strings UTF-8, números). Baseline: 5MB yy.c, 2s em 1M linhas. Após perf-report, aplique 8bit (chars estendidos), reentrant (para parser multi-thread), reduzindo para 3MB e 1.2s.",
                              "finalVerifications": [
                                "Scanner otimizado compila e executa 20%+ mais rápido que baseline.",
                                "Tamanho do executável reduzido em pelo menos 15%.",
                                "Perf-report mostra diminuição em estados visitados e matching time.",
                                "Funciona corretamente com input multi-thread e chars 8bit.",
                                "Nenhum erro ou warning novo introduzido.",
                                "Benchmarks reproduzíveis em múltiplas runs."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de gargalos via perf-report (80% match com análise esperada).",
                                "Correta aplicação e explicação de pelo menos 3 opções de otimização.",
                                "Redução mensurável em tempo e tamanho com evidências comparativas.",
                                "Tratamento correto de edge cases (threads, chars estendidos).",
                                "Documentação clara de steps, métricas e lições aprendidas.",
                                "Código limpo, sem leaks ou crashes em testes."
                              ],
                              "crossCurricularConnections": [
                                "Programação Paralela: Uso de reentrant para threads em parsing concorrente.",
                                "Otimização de Algoritmos: Análise de AFNs e minimização de estados.",
                                "Engenharia de Software: Profiling e benchmarking de ferramentas.",
                                "Processamento de Linguagens Naturais: Handling de chars estendidos em tokenizers."
                              ],
                              "realWorldApplication": "Em compiladores como GCC/Clang (Flex para lexers), ferramentas de linting (ESLint), parsers de logs em sistemas distribuídos (ELK stack), onde scanners otimizados reduzem latência em processamento de grandes volumes de código ou dados."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.7.2.2.2"
                            ]
                          },
                          {
                            "id": "10.1.7.2.3.3",
                            "name": "Integrar scanner com parser Yacc/Bison",
                            "description": "Gerar scanner Flex compatível com Yacc, definindo yylex() e cabeçalhos compartilhados, testando análise léxica-sintática em uma mini-linguagem.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar o Scanner Flex para Compatibilidade com Yacc/Bison",
                                  "subSteps": [
                                    "Instale Flex e Bison no ambiente de desenvolvimento.",
                                    "Crie o arquivo lexer.l definindo regras de tokens compatíveis com Yacc (usando %token).",
                                    "Adicione diretivas Flex como %option noyywrap e %option yylineno para integração suave.",
                                    "Gere o scanner com 'flex -d lexer.l' para produzir lex.yy.c e lex.yy.h.",
                                    "Defina yylex() para retornar tokens simbólicos e yylval para valores semânticos."
                                  ],
                                  "verification": "Verifique se lex.yy.c compila isoladamente e yylex() está declarado corretamente em lex.yy.h.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Flex instalado",
                                    "Editor de texto (VS Code ou Vim)",
                                    "Terminal com gcc"
                                  ],
                                  "tips": "Use %left e %right em tokens para precedência futura no parser.",
                                  "learningObjective": "Entender como Flex gera um scanner que exporta yylex() para uso externo.",
                                  "commonMistakes": "Esquecer de incluir <stdio.h> ou não definir yylval union no cabeçalho compartilhado."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Definir Cabeçalhos Compartilhados e yylex() Prototype",
                                  "subSteps": [
                                    "Crie um cabeçalho compartilhado (ex: parser.h) declarando todos os tokens com %token.",
                                    "Defina a union yylval no parser.h para passar valores léxicos ao parser.",
                                    "No lexer.l, inclua parser.h e popule yylval com valores de tokens (ex: yylval.str = strdup(yytext)).",
                                    "Garanta que yylex() retorne int (token ID) e modifique yylval externamente.",
                                    "Teste yylex() manualmente com main() simples no lex.yy.c."
                                  ],
                                  "verification": "Compile e execute scanner isolado; verifique se tokens e valores são impressos corretamente.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "parser.h template",
                                    "Exemplos de mini-linguagem tokens"
                                  ],
                                  "tips": "Mantenha yylval como union para suportar múltiplos tipos (int, char*, etc.).",
                                  "learningObjective": "Dominar a interface entre scanner e parser via yylex() e yylval.",
                                  "commonMistakes": "Não declarar tokens externos no parser.y ou mismatch em nomes de tokens."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Gerar o Parser Yacc/Bison Integrado",
                                  "subSteps": [
                                    "Crie parser.y com %token de todos os tokens do lexer e regras gramaticais para mini-linguagem.",
                                    "Declare extern int yylex(); e YYSTYPE yylval; no parser.y.",
                                    "Adicione ações semânticas nas regras para usar yylval (ex: $$ = $1 + $3).",
                                    "Gere o parser com 'bison -d parser.y' produzindo parser.tab.c e parser.tab.h.",
                                    "Inclua parser.tab.h no lexer.l para sincronizar tokens."
                                  ],
                                  "verification": "Compile parser.tab.c isoladamente; verifique ausência de erros de declaração de yylex().",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Bison instalado",
                                    "Gramática simples para mini-linguagem (ex: expressões aritméticas)"
                                  ],
                                  "tips": "Use %{ %include parser.h %} no cabeçalho do parser.y para compartilhar definições.",
                                  "learningObjective": "Construir um parser que consome tokens do scanner via yylex().",
                                  "commonMistakes": "Conflitos shift/reduce por gramática ambígua; resolva com %precedence."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Configurar Build System e Compilar Integração",
                                  "subSteps": [
                                    "Crie Makefile com regras para flex, bison, e linkagem: gcc -o analizador lex.yy.c parser.tab.c.",
                                    "Compile com flags: flex lexer.l; bison -d parser.y; gcc -o prog lex.yy.c parser.tab.c -lfl.",
                                    "Adicione main() no parser.y ou arquivo separado para yyparse().",
                                    "Garanta linkagem da libfl para yywrap().",
                                    "Execute e teste com input de mini-linguagem."
                                  ],
                                  "verification": "O executável compila sem warnings e roda sem segmentation faults.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Makefile template",
                                    "gcc e libfl"
                                  ],
                                  "tips": "Use -Wall -Wextra para detectar mismatches de tipos em yylval.",
                                  "learningObjective": "Integrar scanner e parser em um binário funcional.",
                                  "commonMistakes": "Esquecer -lfl ou não usar %option noyywrap no Flex."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Testar Análise Léxica-Sintática Completa",
                                  "subSteps": [
                                    "Crie testes unitários para inputs válidos/inválidos da mini-linguagem.",
                                    "Verifique saída de yyparse(): 0 para sucesso, 1 para sintaxe errada.",
                                    "Adicione debug com yydebug=1; para rastrear chamadas yylex()/reduções.",
                                    "Teste casos edge: EOF, tokens longos, erros léxicos/sintáticos.",
                                    "Meça performance com inputs maiores."
                                  ],
                                  "verification": "Todos testes passam; parser aceita gramática válida e rejeita inválida.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Test files para mini-linguagem",
                                    "Script de testes bash"
                                  ],
                                  "tips": "Use yy_scan_string() para testes sem arquivos.",
                                  "learningObjective": "Validar integração end-to-end com testes robustos.",
                                  "commonMistakes": "Não tratar EOF corretamente (retornar 0 em yylex())."
                                }
                              ],
                              "practicalExample": "Para uma mini-linguagem de expressões aritméticas (ex: 2+3*4), o scanner tokeniza números/operações, parser.y define gramática com precedência, integra via yylex() retornando NUM=258, PLUS=259, etc., e computa resultado em árvore de sintaxe.",
                              "finalVerifications": [
                                "Scanner e parser compilam e linkam sem erros.",
                                "yylex() é chamado corretamente pelo yyparse().",
                                "Valores yylval são passados e usados em ações semânticas.",
                                "Análise completa aceita inputs válidos e reporta erros em inválidos.",
                                "Debug mostra fluxo léxico-sintático correto.",
                                "Performance é aceitável para inputs médios."
                              ],
                              "assessmentCriteria": [
                                "Compatibilidade perfeita de tokens e yylval entre Flex e Bison.",
                                "Ausência de vazamentos de memória em strdup() ou alocações.",
                                "Tratamento robusto de erros léxicos/sintáticos.",
                                "Gramática livre de conflitos shift/reduce.",
                                "Build automatizado via Makefile.",
                                "Testes cobrem 80%+ dos casos."
                              ],
                              "crossCurricularConnections": [
                                "Teoria da Computação: Autômatos finitos (Flex) e gramáticas livres de contexto (Bison).",
                                "Engenharia de Software: Ferramentas de automação de build e testes unitários.",
                                "Matemática: Precedência e associatividade em expressões.",
                                "Sistemas Operacionais: Gerenciamento de input/output e buffers.",
                                "Linguagens de Programação: Parsing em interpretadores/compiladores."
                              ],
                              "realWorldApplication": "Usado em compiladores como GCC (flex/bison para C frontend), ferramentas como SQLite parser, e projetos como LLVM para análise de código-fonte em linguagens reais."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.7.2.2.3",
                              "10.1.7.2.3.1"
                            ]
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.7.3",
                    "name": "Geradores de Analisadores Sintáticos",
                    "description": "Ferramentas como Yacc ou Bison que constroem parsers bottom-up ou top-down a partir de gramáticas livres de contexto.",
                    "individualConcepts": [
                      {
                        "id": "10.1.7.3.1",
                        "name": "Princípios Fundamentais de Geradores de Analisadores Sintáticos",
                        "description": "Conceitos básicos sobre ferramentas que automatizam a construção de analisadores sintáticos (parsers) a partir de gramáticas livres de contexto, incluindo o processo de geração de tabelas de parsing e suporte a metodologias top-down e bottom-up.",
                        "specificSkills": [
                          {
                            "id": "10.1.7.3.1.1",
                            "name": "Identificar gramáticas livres de contexto adequadas para geração automática de parsers",
                            "description": "Diferenciar gramáticas LL(k) para parsers top-down e LR(k) para bottom-up, reconhecendo ambiguidades e resolvendo precedências para viabilizar a geração automática.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Fundamentos de Gramáticas Livres de Contexto (CFLs)",
                                  "subSteps": [
                                    "Estude a definição formal de gramáticas livres de contexto e sua forma normal de Chomsky.",
                                    "Identifique as propriedades chave: não-determinismo, recursão e hierarquia de Chomsky.",
                                    "Compare CFLs com gramáticas regulares e sensíveis ao contexto.",
                                    "Analise exemplos simples de gramáticas context-free.",
                                    "Pratique convertendo gramáticas para formas normais."
                                  ],
                                  "verification": "Construa uma gramática CFL simples para expressões aritméticas e explique sua estrutura.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Livro 'Compilers: Principles, Techniques, and Tools' (Dragon Book), capítulos 4",
                                    "Ferramenta online de gramáticas como JFLAP"
                                  ],
                                  "tips": "Sempre escreva produções em notação BNF para clareza.",
                                  "learningObjective": "Compreender as bases teóricas das CFLs como pré-requisito para parsers automáticos.",
                                  "commonMistakes": [
                                    "Confundir CFLs com linguagens regulares; ignorar recursão à esquerda."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Diferenciar Gramáticas LL(k) para Parsing Top-Down",
                                  "subSteps": [
                                    "Aprenda os critérios para LL(k): sem recursão à esquerda, FIRST e FOLLOW sets.",
                                    "Calcule FIRST e FOLLOW para uma gramática dada.",
                                    "Identifique violações LL(k), como recursão à esquerda ou conflitos FIRST/FOLLOW.",
                                    "Transforme uma gramática não-LL(k) em LL(k) via left-factoring e left-recursion elimination.",
                                    "Simule um parser LL(1) manualmente em um exemplo."
                                  ],
                                  "verification": "Converta uma gramática ambígua em LL(1) e demonstre parsing sem backtracking.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Dragon Book, seção 4.4",
                                    "ANTLR ou ferramentas LL parser online"
                                  ],
                                  "tips": "Use tabelas de parsing para visualizar conflitos.",
                                  "learningObjective": "Dominar propriedades e transformações para gramáticas LL(k) viáveis em geradores top-down.",
                                  "commonMistakes": [
                                    "Não eliminar recursão à esquerda; ignorar FOLLOW sets em LL(k>1)."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explorar Gramáticas LR(k) para Parsing Bottom-Up",
                                  "subSteps": [
                                    "Estude itens LR, estados canônicos e conflitos shift/reduce e reduce/reduce.",
                                    "Construa um conjunto de itens LR(0) e LR(1) para uma gramática.",
                                    "Diferencie LR(0), SLR(1), LALR(1) e LR(1) em termos de poder e eficiência.",
                                    "Gere uma tabela de parsing LR para uma gramática simples.",
                                    "Compare LL(k) vs LR(k) em termos de classes de gramáticas suportadas."
                                  ],
                                  "verification": "Crie uma tabela LR(1) para expressões aritméticas e parse uma string válida.",
                                  "estimatedTime": "2.5 horas",
                                  "materials": [
                                    "Dragon Book, capítulos 4.5-4.7",
                                    "Yacc/Bison tutoriais",
                                    "JFLAP para LR parsing"
                                  ],
                                  "tips": "Comece com LR(0) antes de avançar para LR(1).",
                                  "learningObjective": "Entender o poder superior de LR(k) para a maioria das linguagens de programação.",
                                  "commonMistakes": [
                                    "Confundir shift/reduce com ambiguidades inerentes; subestimar lookahead."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Reconhecer e Resolver Ambiguidade e Precedências",
                                  "subSteps": [
                                    "Identifique gramáticas ambíguas via múltiplas árvores de derivação.",
                                    "Aplique regras de precedência e associatividade para desambiguar.",
                                    "Reescreva gramáticas com precedências explícitas (ex: expr -> expr op term | term).",
                                    "Teste a gramática desambiguada em parsers LL ou LR.",
                                    "Avalie se a gramática é adequada para geração automática (determinística)."
                                  ],
                                  "verification": "Desambigúe a gramática de expressões if-then-else e gere parsing correto.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Exemplos do Dragon Book, seção 4.3",
                                    "Parser generators como ANTLR ou Bison"
                                  ],
                                  "tips": "Use precedências descendentes para expressões.",
                                  "learningObjective": "Capacitar identificação e correção de problemas que impedem parsing automático.",
                                  "commonMistakes": [
                                    "Ignorar associatividade; não testar com strings dangling."
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Praticar Identificação de Gramáticas Adequadas para Geradores Automáticos",
                                  "subSteps": [
                                    "Analise gramáticas reais de linguagens (ex: mini-Pascal).",
                                    "Classifique como LL(k), LR(k) ou nem, justificando.",
                                    "Gere código de parser usando ferramentas como ANTLR (LL) ou Bison (LR).",
                                    "Teste o parser gerado com casos de borda.",
                                    "Documente limitações e trade-offs entre LL e LR."
                                  ],
                                  "verification": "Produza um parser funcional para uma gramática dada usando um gerador automático.",
                                  "estimatedTime": "3 horas",
                                  "materials": [
                                    "ANTLR IDE",
                                    "Bison/Yacc",
                                    "Amostras de gramáticas de linguagens reais"
                                  ],
                                  "tips": "Prefira LR para gramáticas complexas, LL para simples e rápidas.",
                                  "learningObjective": "Aplicar conhecimentos para selecionar e preparar gramáticas para ferramentas reais.",
                                  "commonMistakes": [
                                    "Escolher LL para gramáticas LR-only; não validar com testes extensivos."
                                  ]
                                }
                              ],
                              "practicalExample": "Dada a gramática ambígua para expressões aritméticas: E → E + E | E * E | id. Identifique ambiguidade (ex: 1+2*3), reescreva com precedências (* > +), elimine recursão à esquerda para LL(1), gere parser com ANTLR e teste com entradas como 'id + id * id'.",
                              "finalVerifications": [
                                "Explicar diferenças entre LL(k) e LR(k) com exemplos.",
                                "Classificar uma gramática dada como LL(1), LALR(1) ou determinística.",
                                "Resolver ambiguidade em uma gramática de expressões.",
                                "Gerar e testar um parser automático simples.",
                                "Identificar quando uma gramática não é adequada para automação.",
                                "Comparar eficiência de parsers top-down vs bottom-up."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de propriedades LL/LR (90%+ acurácia).",
                                "Capacidade de transformar gramáticas problemáticas (sucesso em 4/5 casos).",
                                "Geração de parsers funcionais sem erros de compilação.",
                                "Análise correta de ambiguidades e precedências.",
                                "Explicações claras e uso correto de terminologia técnica.",
                                "Eficiência nos tempos estimados e verificações completas."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria de Autômatos e Linguagens Formais (pushdown automata).",
                                "Linguística Computacional: Análise sintática de linguagens naturais.",
                                "Engenharia de Software: Desenvolvimento de ferramentas de compilação.",
                                "Algoritmos: Otimização de parsing e redução de conflitos."
                              ],
                              "realWorldApplication": "Em compiladores como GCC/Clang (usando LR), ferramentas como ANTLR para DSLs, ou Bison para parsers customizados em projetos de linguagens de script, garantindo análise sintática eficiente e sem erros em software real."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.7.3.1.2",
                            "name": "Explicar o processo de geração de tabelas de parsing",
                            "description": "Descrever como geradores constroem tabelas de ação e goto para parsers LR ou tabelas de parsing para LL, utilizando algoritmos como construção de itens LR.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender Conceitos Fundamentais de Itens LR",
                                  "subSteps": [
                                    "Defina um item LR como uma produção com um ponto marcando a posição atual (ex: A → α • β).",
                                    "Explique o closure de um conjunto de itens: adicione itens não-terminais espontâneos.",
                                    "Descreva o kernel de um conjunto: itens iniciais sem closure.",
                                    "Entenda a função GOTO(I, X): conjunto de itens movidos por símbolo X.",
                                    "Diferencie parsers LR(0), SLR(1), LALR(1) e LR(1) em termos de lookahead."
                                  ],
                                  "verification": "Crie 5 itens LR(0) para uma gramática simples e compute o closure manualmente.",
                                  "estimatedTime": "1-2 hours",
                                  "materials": [
                                    "Gramática de exemplo em papel",
                                    "Livro 'Compilers: Principles, Techniques, and Tools' (Dragon Book), Capítulo 4",
                                    "Notas de aula sobre autômatos LR"
                                  ],
                                  "tips": "Use diagramas para visualizar o ponto no item; comece com LR(0) para simplicidade.",
                                  "learningObjective": "Dominar definições e operações básicas sobre itens LR para basear a construção de tabelas.",
                                  "commonMistakes": [
                                    "Confundir closure com GOTO",
                                    "Esquecer itens espontâneos no closure",
                                    "Ignorar augmentação da gramática (S' → S)"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Construir a Coleção Canônica de Conjuntos de Itens",
                                  "subSteps": [
                                    "Augmente a gramática com S' → S.",
                                    "Inicie com I0 = closure({S' → •S}).",
                                    "Para cada conjunto I e símbolo X, compute GOTO(I, X) e adicione como novo conjunto se não existir.",
                                    "Repita até não haver novos conjuntos (estados 0 a n).",
                                    "Numere os estados sequencialmente e liste transições."
                                  ],
                                  "verification": "Construa a coleção canônica para uma gramática com 4 produções e verifique 3 transições GOTO.",
                                  "estimatedTime": "2-3 hours",
                                  "materials": [
                                    "Papel quadriculado para estados",
                                    "Ferramenta online como LR Parser Generator (ex: https://www.cs.usfca.edu/~galles/visualization/LRParser.html)",
                                    "Exemplos resolvidos do Dragon Book"
                                  ],
                                  "tips": "Mantenha uma tabela de estados visitados para evitar duplicatas; desenhe o automato como grafo.",
                                  "learningObjective": "Construir o autômato LR subjacente, essencial para tabelas de ação e goto.",
                                  "commonMistakes": [
                                    "Não propagar recursão no closure",
                                    "Perder estados por não iterar todos os símbolos",
                                    "Duplicar conjuntos idênticos"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Construir a Tabela de Ação",
                                  "subSteps": [
                                    "Para cada estado i e terminal a: se GOTO(I_i, a) = I_j, ação = shift j.",
                                    "Se item [A → α •] em I_i, para FOLLOW(A), ação = reduce por A → α.",
                                    "Se [S' → S •] em I_i, ação = accept.",
                                    "Detecte conflitos: shift-reduce ou reduce-reduce.",
                                    "Preencha células vazias com 'error'."
                                  ],
                                  "verification": "Preencha a coluna de ação para 5 estados e 4 terminais, identificando potenciais conflitos.",
                                  "estimatedTime": "2 hours",
                                  "materials": [
                                    "Planilha Excel para tabela",
                                    "Lista de FIRST/FOLLOW pré-computados",
                                    "Pseudocódigo de algoritmo SLR/LALR"
                                  ],
                                  "tips": "Compute FOLLOW sets antes; priorize shift em conflitos para LL-like, mas note para LR.",
                                  "learningObjective": "Mapear transições de terminais para ações shift, reduce ou accept.",
                                  "commonMistakes": [
                                    "Usar lookahead incorreto em LR(0)",
                                    "Aplicar reduce em todos os terminais sem FOLLOW",
                                    "Ignorar accept apenas no estado final"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Construir a Tabela de Goto e Integrar a Tabela Completa",
                                  "subSteps": [
                                    "Para cada estado i e não-terminal A: se GOTO(I_i, A) = I_j, goto[i][A] = j.",
                                    "Combine ação e goto em tabela única: ação para terminais, goto para não-terminais.",
                                    "Valide a tabela simulando parse de strings de entrada.",
                                    "Otimize para LALR(1) mesclando lookaheads se aplicável.",
                                    "Documente a tabela final com legenda."
                                  ],
                                  "verification": "Construa goto para todos não-terminais e simule parse de uma string válida.",
                                  "estimatedTime": "1-2 hours",
                                  "materials": [
                                    "Tabela completa em LaTeX ou Markdown",
                                    "Simulador de parser LR online",
                                    "Gramática de teste com ambiguidade resolvida"
                                  ],
                                  "tips": "Use cores para diferenciar shift/reduce/goto; teste com aceitação e rejeição.",
                                  "learningObjective": "Finalizar a tabela de parsing funcional para uso em um parser.",
                                  "commonMistakes": [
                                    "Confundir terminais/não-terminais nas colunas",
                                    "Omitir gotos para todos não-terminais",
                                    "Não testar a tabela com inputs"
                                  ]
                                }
                              ],
                              "practicalExample": "Para gramática aumentada: S' → S, S → A, A → a A | b. Construa I0 = closure(S' → •S) = {S'→•S, S→•A, A→•a A, A→•b}. GOTO(I0,a)=I1={A→a•A}, etc. Tabela ação: estado 0, 'a': s1; estado 1, 'b': r(A→b). Simule parse de 'ab'.",
                              "finalVerifications": [
                                "Construa coleção canônica completa para gramática com 5 produções.",
                                "Preencha tabela de ação sem conflitos para SLR(1).",
                                "Simule parsing de 3 strings (válidas/inválidas) usando a tabela.",
                                "Explique resolução de shift-reduce com lookahead.",
                                "Compare tabela LR(0) vs SLR(1) para mesma gramática.",
                                "Identifique estados finais e aceitação."
                              ],
                              "assessmentCriteria": [
                                "Precisão na computação de closures e GOTOs (sem duplicatas erradas).",
                                "Correta população de ações shift/reduce/accept sem conflitos não detectados.",
                                "Validação via simulação de parsing com pelo menos 80% de acerto.",
                                "Uso apropriado de FIRST/FOLLOW para SLR.",
                                "Clareza na documentação da tabela e explicação dos passos.",
                                "Detecção e discussão de potenciais ambiguidades."
                              ],
                              "crossCurricularConnections": [
                                "Teoria da Computação: Autômatos finitos e pushdown.",
                                "Algoritmos: Construção de grafos e busca em estados.",
                                "Engenharia de Software: Geração automática de código (Yacc/Bison).",
                                "Processamento de Linguagem Natural: Parsing em NLP.",
                                "Matemática Discreta: Conjuntos, relações e fechamentos."
                              ],
                              "realWorldApplication": "Em compiladores como GCC (usando Bison), gera parsers eficientes para linguagens como C++; ferramentas como ANTLR usam princípios similares para parsers LL/LR em apps web, IDEs e processadores de queries SQL."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.7.3.1.3",
                            "name": "Comparar parsers top-down e bottom-up gerados automaticamente",
                            "description": "Analisar vantagens e desvantagens de cada abordagem em termos de poder expressivo, eficiência e tratamento de left-recursion ou ambiguidades em gramáticas.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Fundamentos de Parsers Top-Down Gerados Automaticamente",
                                  "subSteps": [
                                    "Estude a definição e funcionamento de parsers top-down, como LL(k) e LL(*), usando ferramentas como ANTLR.",
                                    "Analise como eles constroem a árvore de parsing a partir da raiz, prevendo produções não-terminais.",
                                    "Identifique limitações iniciais, como sensibilidade a left-recursion e preferência por gramáticas LL.",
                                    "Examine exemplos de gramáticas LL válidas e como geradores automáticos lidam com ambiguidades via backtracking.",
                                    "Pratique gerando um parser simples para uma gramática LL usando uma ferramenta online ou ANTLR."
                                  ],
                                  "verification": "Gere um parser top-down para uma gramática simples e confirme que parseia corretamente sem erros de left-recursion.",
                                  "estimatedTime": "2 hours",
                                  "materials": [
                                    "Documentação ANTLR",
                                    "Tutorial LL parsers",
                                    "Editor de código com ANTLR plugin"
                                  ],
                                  "tips": "Comece com gramáticas determinísticas LL(1) para evitar complexidade inicial.",
                                  "learningObjective": "Compreender o mecanismo preditivo de parsers top-down e suas dependências em gramáticas sem left-recursion.",
                                  "commonMistakes": "Confundir backtracking com eficiência; left-recursion causa loops infinitos em LL puro."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Revisar Fundamentos de Parsers Bottom-Up Gerados Automaticamente",
                                  "subSteps": [
                                    "Estude parsers bottom-up como LR(0), SLR(1), LALR(1) e LR(1), usando ferramentas como Yacc ou Bison.",
                                    "Analise o processo shift-reduce e como constroem a árvore de parsing do fundo para cima.",
                                    "Identifique suporte a left-recursion e resolução de conflitos shift-reduce ou reduce-reduce.",
                                    "Examine como geradores automáticos constroem tabelas de parsing e lidam com ambiguidades.",
                                    "Pratique gerando um parser bottom-up para uma gramática com left-recursion usando Bison."
                                  ],
                                  "verification": "Gere um parser bottom-up para uma gramática left-recursive e verifique parsing sem conflitos.",
                                  "estimatedTime": "2 hours",
                                  "materials": [
                                    "Documentação Bison/Yacc",
                                    "Tutorial LR parsers",
                                    "Compilador Bison instalado"
                                  ],
                                  "tips": "Use flags de debug para visualizar estados LR e conflitos.",
                                  "learningObjective": "Dominar o mecanismo shift-reduce de parsers bottom-up e seu suporte a gramáticas mais poderosas.",
                                  "commonMistakes": "Ignorar conflitos em estados LR; assumir que todos LR são equivalentes em poder."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Comparar Poder Expressivo e Tratamento de Left-Recursion e Ambiguidade",
                                  "subSteps": [
                                    "Liste gramáticas que LL pode parsear vs. LR (ex: LL falha em left-recursion direta, LR suporta).",
                                    "Compare eficiência: LL preditivo O(n) mas backtracking piora; LR tabelar O(n) determinístico.",
                                    "Analise tratamento de ambiguidades: LL usa ordenação/prioridades, LR resolve via lookahead.",
                                    "Crie tabela comparativa de vantagens/desvantagens em expressividade (LR > LL) e simplicidade de gramática (LL > LR).",
                                    "Teste gramáticas ambíguas em ambas ferramentas e observe diferenças."
                                  ],
                                  "verification": "Crie uma tabela comparativa com pelo menos 5 critérios e valide com exemplos parseados.",
                                  "estimatedTime": "3 hours",
                                  "materials": [
                                    "Planilha ou Markdown para tabela",
                                    "Exemplos de gramáticas problemáticas"
                                  ],
                                  "tips": "Use gramáticas como expressões aritméticas para demonstrar diferenças.",
                                  "learningObjective": "Identificar quando usar cada abordagem baseado em propriedades da gramática.",
                                  "commonMistakes": "Superestimar LL para gramáticas reais; subestimar overhead de tabelas LR."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar Eficiência e Aplicações Práticas em Geradores Automáticos",
                                  "subSteps": [
                                    "Meça eficiência: tempo/espaço para parsing de inputs grandes em LL(*) vs. LALR(1).",
                                    "Discuta trade-offs: LL mais legível/portátil, LR mais poderoso para linguagens reais.",
                                    "Examine casos reais: ANTLR para DSLs, Bison para C/C++ compilers.",
                                    "Compare erros comuns em cada: LL backtracking lento, LR conflitos difíceis de debugar.",
                                    "Sintetize recomendação baseada em cenários (ex: LL para web parsers rápidos)."
                                  ],
                                  "verification": "Execute benchmarks simples em ambas ferramentas e documente resultados.",
                                  "estimatedTime": "2 hours",
                                  "materials": [
                                    "Scripts de teste com inputs grandes",
                                    "Ferramentas de profiling"
                                  ],
                                  "tips": "Use gramáticas de linguagens reais como JSON ou SQL subsets.",
                                  "learningObjective": "Avaliar escolhas práticas considerando performance e manutenibilidade.",
                                  "commonMistakes": "Ignorar portabilidade; focar só em teoria sem benchmarks."
                                }
                              ],
                              "practicalExample": "Compare parsers para gramática de expressões aritméticas com left-recursion (exp: E -> E + T | T). Gere com ANTLR (top-down: refatore para right-recursion) vs. Bison (bottom-up: parseia nativamente). Meça tempo de parsing em input de 1000 tokens e analise árvore gerada.",
                              "finalVerifications": [
                                "Pode listar 3 vantagens e 3 desvantagens de cada abordagem.",
                                "Gera parsers funcionais para gramáticas LL e LR usando ferramentas automáticas.",
                                "Identifica left-recursion e ambiguidades em gramáticas fornecidas.",
                                "Cria tabela comparativa precisa de expressividade e eficiência.",
                                "Explica impacto em compiladores reais com exemplos."
                              ],
                              "assessmentCriteria": [
                                "Precisão na distinção de poder expressivo (LR classe 4, LL classe 3 Chomsky).",
                                "Análise quantitativa de eficiência com evidências (benchmarks).",
                                "Tratamento correto de left-recursion e resolução de ambiguidades.",
                                "Tabela comparativa completa e bem estruturada.",
                                "Aplicação prática demonstrada via exemplos parseados.",
                                "Clareza em recomendações contextuais."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Autômatos e linguagens formais (hierarquia Chomsky).",
                                "Engenharia de Software: Design de DSLs e ferramentas de parsing.",
                                "Algoritmos: Análise de complexidade em parsing O(n).",
                                "Lógica: Resolução de conflitos como problemas de decisão."
                              ],
                              "realWorldApplication": "Em compiladores como GCC (Bison para C parser) vs. parsers web como PEG.js (top-down); escolha bottom-up para linguagens complexas como C++, top-down para configs rápidas como JSON em navegadores."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.7.3.2",
                        "name": "Ferramentas Yacc e Bison para Parsers Bottom-Up",
                        "description": "Estudo detalhado das ferramentas Yacc e Bison, que geram parsers LR(1) shift-reduce a partir de especificações de gramáticas, integrando com analisadores léxicos como Flex/Lex.",
                        "specificSkills": [
                          {
                            "id": "10.1.7.3.2.1",
                            "name": "Especificar gramáticas na sintaxe Yacc/Bison",
                            "description": "Escrever arquivos .y com declarações, regras de produção, ações semânticas e precedências para resolver conflitos em gramáticas reais de linguagens de programação.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a Estrutura Geral de um Arquivo .y",
                                  "subSteps": [
                                    "Estude as três seções principais: Declarations (entre %{ e %}), Rules e Code adicional após as regras.",
                                    "Identifique diretivas como %token, %type e %start.",
                                    "Revise a sintaxe básica de um arquivo .y mínimo usando a documentação do Bison.",
                                    "Esboce um template vazio com todas as seções comentadas.",
                                    "Compile um arquivo .y vazio com bison para verificar sintaxe básica."
                                  ],
                                  "verification": "Criar e compilar com sucesso um arquivo .y esqueleto sem erros de sintaxe.",
                                  "estimatedTime": "1 hour",
                                  "materials": [
                                    "Documentação oficial do Bison (manual)",
                                    "Editor de texto como Vim ou VS Code",
                                    "Instalação do Bison"
                                  ],
                                  "tips": "Use %{ %} para incluir código C header no início das declarações.",
                                  "learningObjective": "Dominar a organização hierárquica de um arquivo Yacc/Bison.",
                                  "commonMistakes": [
                                    "Esquecer o %{} delimitador para declarações C",
                                    "Colocar regras antes das declarações",
                                    "Ignorar a seção de código final para main()"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Declarar Tokens, Tipos e Início da Gramática",
                                  "subSteps": [
                                    "Defina tokens léxicos com %token INT ID PLUS MINUS.",
                                    "Declare tipos de não-terminais com %type <int> expr.",
                                    "Especifique o símbolo inicial com %start program.",
                                    "Inclua unions para tipos semânticos com %union { int num; }.",
                                    "Adicione headers necessários com %{ #include <stdio.h> %}.",
                                    "Teste compilação após adicionar declarações básicas."
                                  ],
                                  "verification": "Compilar o .y com declarações de tokens e tipos sem erros semânticos.",
                                  "estimatedTime": "1.5 hours",
                                  "materials": [
                                    "Exemplos de gramáticas simples do manual Bison",
                                    "Compilador GCC para ações C"
                                  ],
                                  "tips": "Use %left e %right para precedências iniciais nas declarações.",
                                  "learningObjective": "Configurar corretamente o léxico e semântico no cabeçalho.",
                                  "commonMistakes": [
                                    "Declarar token sem aspas duplas para literais",
                                    "Esquecer ponto e vírgula após %union",
                                    "Conflitos de tipo em %type"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Escrever Regras de Produção Básicas",
                                  "subSteps": [
                                    "Crie regras simples como expr: expr '+' term | term.",
                                    "Use | para alternativas na mesma não-terminal.",
                                    "Adicione recursão à esquerda ou direita para expressões.",
                                    "Inclua terminais e não-terminais corretamente.",
                                    "Valide recursão infinita evitando ciclos diretos.",
                                    "Gere o parser e teste com input manual via yyparse()."
                                  ],
                                  "verification": "Parser aceita sequências válidas de uma gramática simples sem ambiguidades.",
                                  "estimatedTime": "2 hours",
                                  "materials": [
                                    "Ferramenta Flex para lexer complementar",
                                    "Exemplos de gramáticas aritméticas"
                                  ],
                                  "tips": "Mantenha regras curtas; divida em não-terminais intermediários.",
                                  "learningObjective": "Construir gramáticas livres de contexto recursivas.",
                                  "commonMistakes": [
                                    "Recursão à esquerda sem precedência",
                                    "Falta de dois pontos após não-terminal",
                                    "Misturar terminais e não-terminais"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Implementar Ações Semânticas",
                                  "subSteps": [
                                    "Adicione { $$ = $1 + $3; } nas regras para propagar valores.",
                                    "Use $1, $2 para acessar símbolos à esquerda/direita.",
                                    "Defina main() e yyerror() na seção de código.",
                                    "Integre com lexer Flex para yylex().",
                                    "Teste com input real, imprimindo valores semânticos.",
                                    "Debug ações com printf em pontos chave."
                                  ],
                                  "verification": "Parser computa e imprime resultados corretos para expressões válidas.",
                                  "estimatedTime": "2 hours",
                                  "materials": [
                                    "Exemplo de calculadora Flex+Bison",
                                    "Debugger GDB"
                                  ],
                                  "tips": "Sempre inicialize $$ para evitar garbage values.",
                                  "learningObjective": "Integrar análise sintática com semântica básica.",
                                  "commonMistakes": [
                                    "Erro de escopo em variáveis semânticas",
                                    "Falta de ; em ações C",
                                    "Não tratar erros de tipo"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Definir Precedências e Resolver Conflitos",
                                  "subSteps": [
                                    "Declare %left '+' '-' e %right '=' para precedências.",
                                    "Analise relatório bison -v para shift/reduce ou reduce/reduce.",
                                    "Ajuste precedências e associatividades para eliminar conflitos.",
                                    "Teste gramática ambígua como if-then-else.",
                                    "Recompile e verifique relatório de conflitos zero.",
                                    "Valide com casos de teste edge como expressões aninhadas."
                                  ],
                                  "verification": "Relatório Bison mostra 0 shift/reduce conflicts; parser parse corretamente precedências.",
                                  "estimatedTime": "2.5 hours",
                                  "materials": [
                                    "Opção -v do Bison para output.verbose",
                                    "Casos de teste para gramáticas reais"
                                  ],
                                  "tips": "Coloque precedências mais baixas (menor precedência) primeiro.",
                                  "learningObjective": "Diagnosticar e resolver ambiguidades em gramáticas reais.",
                                  "commonMistakes": [
                                    "Ignorar conflitos no relatório",
                                    "Precedência errada em operadores unários",
                                    "Associatividade default left-to-right não ajustada"
                                  ]
                                }
                              ],
                              "practicalExample": "Crie uma gramática para expressões aritméticas com +, -, *, / e parênteses: declare tokens NUM '(' ')' etc., regras expr: expr '+' term | term, term: term '*' factor | factor, etc., ações $$ = $1 + $3, precedências %left '+' '-', %left '*' '/', teste com '2*(3+4)' resultando 14.",
                              "finalVerifications": [
                                "Compilar .y + .l (Flex) sem warnings ou erros.",
                                "Parser aceita inputs válidos e rejeita inválidos.",
                                "Relatório Bison .output mostra 0 conflitos.",
                                "Ações semânticas produzem saída correta para 10+ casos de teste.",
                                "Integração com main() roda sem crashes.",
                                "yyerror() reporta erros sintáticos adequadamente."
                              ],
                              "assessmentCriteria": [
                                "Gramática cobre casos reais sem ambiguidades resolvidas.",
                                "Ações semânticas corretas e eficientes.",
                                "Uso apropriado de unions e tipos.",
                                "Precedências eliminam todos conflitos reportados.",
                                "Código C limpo e modular.",
                                "Testes demonstram robustez."
                              ],
                              "crossCurricularConnections": [
                                "Teoria da Computação: Gramáticas Livres de Contexto e Autômatos Pushdown.",
                                "Linguagens Formais: Parsing LR(1) e tabelas de análise.",
                                "Engenharia de Software: Geração automática de ferramentas de compiladores.",
                                "Algoritmos: Árvores de análise sintática.",
                                "Programação: Integração com C e Flex para lexers."
                              ],
                              "realWorldApplication": "Desenvolvimento de compiladores (ex: GCC usa Bison), interpretadores de linguagens DSL, ferramentas de configuração como no kernel Linux, parsers para SQL ou JSON em bancos de dados e APIs."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.7.3.2.2",
                            "name": "Compilar e integrar parsers gerados com analisadores léxicos",
                            "description": "Gerar código C a partir de Yacc/Bison, compilar com Flex/Lex e testar parsers completos para linguagens simples, verificando integração via yylex().",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Gerar código C do parser sintático com Bison/Yacc",
                                  "subSteps": [
                                    "Escreva uma gramática Yacc simples em um arquivo .y, definindo tokens com %token e regras de produção para uma linguagem básica como expressões aritméticas.",
                                    "Adicione diretivas %left e %right para precedência de operadores.",
                                    "Execute o comando 'bison -d nome_arquivo.y' para gerar nome_arquivo.tab.c e nome_arquivo.tab.h.",
                                    "Compile e verifique se não há erros de sintaxe na gramática.",
                                    "Inspecione o código gerado em .tab.c para entender a função yyparse()."
                                  ],
                                  "verification": "Arquivos .tab.c e .tab.h são gerados sem warnings ou erros de bison.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Bison instalado",
                                    "Editor de texto (VS Code ou Vim)",
                                    "Terminal/Linux ou WSL"
                                  ],
                                  "tips": "Sempre use %start para definir o símbolo inicial; teste gramáticas mínimas primeiro para evitar conflitos.",
                                  "learningObjective": "Compreender a geração automática de parsers bottom-up LR a partir de gramáticas context-free.",
                                  "commonMistakes": [
                                    "Falta de ponto e vírgula após %token",
                                    "Conflitos shift/reduce não declarados com %left/%right",
                                    "Esquecer %% para separar definições e regras"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Configurar analisador léxico com Flex/Lex compatível",
                                  "subSteps": [
                                    "Crie um arquivo .l definindo %{} seção com declarações de tokens que combinem com o .y (ex: %{ #include \"nome.tab.h\" %}).",
                                    "Defina regras léxicas com padrões regex para tokens como NUM, PLUS, etc., retornando o token via return TOKEN_NAME.",
                                    "Implemente yylex() como a função principal que lê input e retorna tokens.",
                                    "Execute 'flex nome_arquivo.l' para gerar lex.yy.c.",
                                    "Verifique se yylex() está externamente visível e compatível com yyparse()."
                                  ],
                                  "verification": "Arquivo lex.yy.c gerado e yylex() declarada corretamente para uso em parser.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Flex instalado",
                                    "Mesmo editor e terminal do Step 1"
                                  ],
                                  "tips": "Use yyin = stdin; para input padrão; defina yylval para valores semânticos como números.",
                                  "learningObjective": "Criar lexers que forneçam tokens sequencialmente para parsers sintáticos.",
                                  "commonMistakes": [
                                    "Não incluir .tab.h no .l",
                                    "Retornar 0 em vez de EOF no fim do input",
                                    "Regex ambíguos levando a tokens errados"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Integrar lexer e parser modificando código gerado",
                                  "subSteps": [
                                    "No .tab.c gerado, certifique-se de que yyparse() chama yylex() (geralmente automático, mas verifique extern int yylex();).",
                                    "Crie um main() em um arquivo separado ou adicione ao .l/.y que chama yyparse() e verifica yyparse() == 0 para sucesso.",
                                    "Lide com ações semânticas nas regras do parser para imprimir árvore de parse ou AST simples.",
                                    "Compile parcialmente: gcc -o parser nome.tab.c lex.yy.c para testar linkagem.",
                                    "Resolva erros de linkagem adicionando -lfl para Flex se necessário."
                                  ],
                                  "verification": "Compilação parcial succeeds sem erros de símbolos indefinidos como yylex().",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "GCC ou Clang",
                                    "Arquivos .tab.c e lex.yy.c gerados"
                                  ],
                                  "tips": "Declare extern int yylex(); no .y se não auto-incluído; use yydebug=1 para debug.",
                                  "learningObjective": "Integrar componentes lexer-parser para formar um analisador sintático completo.",
                                  "commonMistakes": [
                                    "Falta de declaração de yylex() no parser",
                                    "Conflitos de nomes de funções yy*",
                                    "Não linkar biblioteca Flex (-lfl)"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Compilar e testar o parser completo com inputs",
                                  "subSteps": [
                                    "Compile o programa final: gcc -o parser_completo nome.tab.c lex.yy.c -lfl -DYYDEBUG=1.",
                                    "Crie arquivos de teste com inputs válidos (ex: '2+3*4') e inválidos.",
                                    "Execute ./parser_completo < input.txt e verifique saída (sucesso ou erro de parse).",
                                    "Use yydebug para rastrear chamadas yylex() e yyparse().",
                                    "Teste casos edge: input vazio, sintaxe inválida, múltiplas linhas."
                                  ],
                                  "verification": "Parser aceita inputs válidos (yyparse()==0) e rejeita inválidos com mensagens de erro.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Arquivos de teste .txt",
                                    "GCC com -lfl"
                                  ],
                                  "tips": "Redirecione input com < para simular real-world; adicione printf nas ações para debug semântico.",
                                  "learningObjective": "Validar integração end-to-end de lexer e parser em uma linguagem simples.",
                                  "commonMistakes": [
                                    "Inputs com espaços extras não tratados no lexer",
                                    "yyparse() retorna 1 mas sem erro claro",
                                    "Falta de -lfl causando runtime crash"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Debugar e otimizar a integração",
                                  "subSteps": [
                                    "Identifique erros comuns via bison -v para .output file com conflitos.",
                                    "Adicione handling de erros com yyerror() no .y e chame em lexer para inputs inválidos.",
                                    "Meça performance com inputs maiores e otimize regex no lexer.",
                                    "Gere AST ou eval simples nas ações semânticas para verificar.",
                                    "Documente o processo em um README com comandos exatos."
                                  ],
                                  "verification": "Parser lida com erros graciosamente e .output mostra zero conflitos.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "bison -v output",
                                    "Mais arquivos de teste complexos"
                                  ],
                                  "tips": "Use %define parse.error verbose para erros detalhados; profile com time ./parser.",
                                  "learningObjective": "Aplicar técnicas de debug e otimização em ferramentas de compiladores.",
                                  "commonMistakes": [
                                    "Ignorar warnings de bison sobre conflitos",
                                    "yyerror() não implementada",
                                    "Regex ineficientes em loops infinitos"
                                  ]
                                }
                              ],
                              "practicalExample": "Crie um parser para expressões aritméticas simples (2+3*4=(2+(3*4))). Use gramática: %start expr; expr: expr '+' term | term; term: term '*' factor | factor; factor: NUM. Lexer reconhece NUM [0-9]+, PLUS '+', MULT '*'. Teste com input '2+3*4' deve parse sem erros e imprimir árvore.",
                              "finalVerifications": [
                                "Compilação completa sem erros ou warnings críticos.",
                                "yylex() é chamado corretamente durante yyparse() (verificado via debug).",
                                "Inputs válidos retornam yyparse()==0 com saída semântica correta.",
                                "Inputs inválidos geram yyerror() e param parse.",
                                "Zero conflitos shift/reduce no .output do bison.",
                                "Parser processa inputs multi-linha e edge cases."
                              ],
                              "assessmentCriteria": [
                                "Gramática livre de ambiguidades e conflitos.",
                                "Integração perfeita: lexer fornece tokens via yylex() para parser.",
                                "Compilação e execução bem-sucedidas em múltiplos testes.",
                                "Tratamento robusto de erros com mensagens claras.",
                                "Eficiência: tempo de parse razoável para inputs médios.",
                                "Documentação de comandos e gramática completa."
                              ],
                              "crossCurricularConnections": [
                                "Teoria da Computação: Autômatos finitos (lexer) e pushdown (parser LR).",
                                "Engenharia de Software: Ferramentas de automação de build (Makefiles para Flex/Bison).",
                                "Linguagens de Programação: Parsing em intérpretes como Python ou JavaScript engines.",
                                "Matemática: Precedência de operadores e árvores de parsing.",
                                "Sistemas Operacionais: Gerenciamento de input/output em pipes e redirecionamentos."
                              ],
                              "realWorldApplication": "Desenvolvimento de compiladores/front-ends para linguagens (ex: GCC usa Bison, SQLite parser), ferramentas CLI como jq para JSON, editores de código com syntax highlighting dinâmico, e análise de logs/configs em DevOps."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.7.3.2.3",
                            "name": "Diagnosticar e resolver conflitos em parsers LR",
                            "description": "Interpretar relatórios de conflitos shift-reduce e reduce-reduce, aplicando diretivas %left, %right e %nonassoc para corrigir gramáticas ambíguas.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Configurar ambiente e gerar parser com conflito intencional",
                                  "subSteps": [
                                    "Instale Yacc ou Bison no sistema (ex: sudo apt install bison no Linux).",
                                    "Crie um arquivo .y com uma gramática ambígua, como expressões aritméticas com operadores de mesma precedência ou o problema 'dangling else'.",
                                    "Compile o parser usando 'bison -d -v gramatica.y' para gerar relatório verbose (.output).",
                                    "Examine o arquivo .output para localizar conflitos iniciais.",
                                    "Teste o parser gerado com inputs simples para confirmar comportamento ambíguo."
                                  ],
                                  "verification": "Verifique se o relatório .output lista shift-reduce ou reduce-reduce conflicts com estados específicos.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Bison/Yacc instalado, editor de texto (VS Code ou Vim), terminal.",
                                  "tips": "Use gramáticas clássicas como if-then-else para praticar rapidamente.",
                                  "learningObjective": "Configurar ambiente e reproduzir conflitos reais em parsers LR.",
                                  "commonMistakes": "Esquecer de usar -v para relatório verbose; ignorar warnings durante compilação."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Interpretar relatórios de conflitos shift-reduce e reduce-reduce",
                                  "subSteps": [
                                    "Abra o arquivo .output e localize seções 'state X' com mensagens como 'shift/reduce conflict' ou 'reduce/reduce conflict'.",
                                    "Analise o stack de estados: identifique tokens lookahead causando ambiguidade (ex: shift vs reduce em mesmo token).",
                                    "Mapeie regras de produção envolvidas nos conflitos listados.",
                                    "Classifique o tipo: shift-reduce (ação dupla para lookahead) ou reduce-reduce (duas reduções possíveis).",
                                    "Anote causas gramaticais, como falta de precedência ou ambiguidades inerentes."
                                  ],
                                  "verification": "Escreva um resumo explicando pelo menos um conflito específico do relatório, citando estado e tokens.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Arquivo .output gerado, papel ou documento para anotações.",
                                  "tips": "Foque em colunas 'action' do relatório; use diagramas de estados LR para visualização.",
                                  "learningObjective": "Diagnosticar precisamente causas de conflitos em itens LR.",
                                  "commonMistakes": "Confundir shift-reduce com reduce-reduce; ignorar contexto do lookahead."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Aplicar diretivas de precedência %left, %right e %nonassoc",
                                  "subSteps": [
                                    "Declare precedências no cabeçalho do .y: %left para associatividade esquerda (ex: + -*), %right para direita (ex: **), %nonassoc para sem associatividade.",
                                    "Atribua precedências crescentes: operadores de menor precedência primeiro.",
                                    "Recompile com bison e verifique redução de conflitos no .output.",
                                    "Ajuste declarações iterativamente se conflitos persistirem.",
                                    "Documente mudanças e impacto em cada regra ambígua."
                                  ],
                                  "verification": "O relatório .output mostra '0 shift/reduce conflicts' e '0 reduce/reduce conflicts'.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Arquivo .y editável, Bison.",
                                  "tips": "Teste precedências com expressões como 1+2*3 para validar associatividade.",
                                  "learningObjective": "Resolver ambiguidades gramaticais usando precedência e associatividade.",
                                  "commonMistakes": "Declarar precedência errada (ex: %left para exponenciação); esquecer de cobrir todos operadores."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Testar e validar o parser corrigido",
                                  "subSteps": [
                                    "Compile o parser final e gere executável (ex: bison -d gramatica.y; gcc y.tab.c).",
                                    "Crie suíte de testes com casos ambíguos resolvidos (ex: if-then-else aninhado; expressões mistas).",
                                    "Execute parser com inputs e verifique saídas sintáticas corretas.",
                                    "Analise árvore de parsing gerada para confirmar precedência aplicada.",
                                    "Registre métricas: tempo de parsing e cobertura de casos."
                                  ],
                                  "verification": "Todos testes passam sem erros de parsing; árvores refletem precedências corretas.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Executável do parser, arquivos de teste .input.",
                                  "tips": "Use valgrind para detectar vazamentos se aplicável; automatize testes com scripts.",
                                  "learningObjective": "Validar correções através de testes empíricos.",
                                  "commonMistakes": "Testar apenas casos simples; não verificar árvores de parsing."
                                }
                              ],
                              "practicalExample": "Gramática ambígua para expressões: expr : expr '+' expr | expr '*' expr | NUM; Conflito shift-reduce em '+'. Solução: %left '+' ; %left '*' ; Resultado: 1+2*3 parseado como 1+(2*3). Para dangling else: %nonassoc THEN ; %nonassoc ELSE ; Resolve preferindo else mais próximo.",
                              "finalVerifications": [
                                "Parser compila sem conflitos no relatório .output.",
                                "Casos de teste ambíguos são parseados corretamente com precedências esperadas.",
                                "Árvores de parsing geradas confirmam associatividade (esquerda/direita).",
                                "Nenhum reduce-reduce conflict persiste após %nonassoc.",
                                "Parser lida com lookaheads múltiplos sem ambiguidades.",
                                "Tempo de parsing é eficiente (<1s para inputs médios)."
                              ],
                              "assessmentCriteria": [
                                "Explicação precisa de shift-reduce vs reduce-reduce conflicts (80% acurácia).",
                                "Uso correto de %left/%right/%nonassoc para resolver pelo menos 3 conflitos (100% sucesso).",
                                "Relatório de interpretação do .output cobre estados e lookaheads chave.",
                                "Suíte de testes cobre 90% dos casos ambíguos identificados.",
                                "Documentação clara de mudanças e impactos.",
                                "Eficiência: resolução em <3 iterações de recompilação."
                              ],
                              "crossCurricularConnections": [
                                "Teoria da Computação: Autômatos e linguagens livres de contexto.",
                                "Matemática Discreta: Grafos de dependência em itens LR(1).",
                                "Engenharia de Software: Debugging e refatoração de gramáticas.",
                                "Algoritmos: Otimização de tabelas de parsing LR."
                              ],
                              "realWorldApplication": "Em compiladores como GCC/Clang (usando Bison), resolução de conflitos garante parsing determinístico de linguagens como C++ com operadores sobrecarregados; ferramentas como ANTLR/Bison em projetos de DSLs industriais evitam erros em parsers de configurações complexas."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.7.3.2.4",
                            "name": "Implementar ações semânticas em parsers gerados",
                            "description": "Adicionar código C em ações associadas a produções para construir árvores de sintaxe ou tabelas de símbolos durante a análise sintática.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Configurar ambiente Yacc/Bison e revisar gramática básica",
                                  "subSteps": [
                                    "Instalar Bison ou Yacc no sistema (ex: apt install bison no Linux).",
                                    "Criar um arquivo .y com uma gramática simples de expressões aritméticas.",
                                    "Definir as seções %{ %}, declarações, regras e código C auxiliar.",
                                    "Gerar o parser com 'bison -d arquivo.y' e compilar com gcc.",
                                    "Testar parsing básico sem ações semânticas usando yyparse()."
                                  ],
                                  "verification": "Parser compila e aceita input válido sem erros semânticos, produzindo saída de debug.",
                                  "estimatedTime": "1 hour",
                                  "materials": [
                                    "Bison/Yacc instalado",
                                    "Editor de texto (VS Code ou Vim)",
                                    "Compilador GCC",
                                    "Exemplo de gramática simples"
                                  ],
                                  "tips": "Use %debug para habilitar traces de parsing durante testes iniciais.",
                                  "learningObjective": "Compreender a estrutura de um arquivo Yacc/Bison e gerar um parser funcional básico.",
                                  "commonMistakes": [
                                    "Esquecer de incluir <stdio.h> ou headers necessários",
                                    "Conflitos shift/reduce não resolvidos na gramática",
                                    "Não declarar yylex() corretamente"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Definir estruturas de dados para AST e tabela de símbolos",
                                  "subSteps": [
                                    "Criar struct Node para nós de árvore de sintaxe (campos: tipo, valor, filhos esquerdo/direito).",
                                    "Implementar funções auxiliares: createNode(), freeNode() para alocação e liberação de memória.",
                                    "Definir struct SymbolTable com array/hashtable para entradas (nome, tipo, escopo).",
                                    "Adicionar funções insertSymbol(), lookupSymbol() com gerenciamento de escopo.",
                                    "Declarar ponteiros globais ou parâmetros para passar AST e tabela entre ações."
                                  ],
                                  "verification": "Compilar código auxiliar sem erros e testar alocação/lookup manualmente em main().",
                                  "estimatedTime": "1.5 hours",
                                  "materials": [
                                    "Referência C structs e pointers",
                                    "Exemplos de AST em compiladores open-source como TinyCC"
                                  ],
                                  "tips": "Use unions em Node para otimizar memória com diferentes tipos de nós.",
                                  "learningObjective": "Projetar e implementar estruturas de dados eficientes para representação semântica.",
                                  "commonMistakes": [
                                    "Vazamentos de memória por não usar free()",
                                    "Não inicializar ponteiros, causando segfaults",
                                    "Chaves duplicadas na tabela sem detecção de erros"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar ações semânticas nas regras de produção",
                                  "subSteps": [
                                    "Identificar produções terminais e não-terminais na gramática (ex: expr: expr '+' term).",
                                    "Adicionar { } após cada regra para código C: alocar novo nó, setar tipo/valor, linkar filhos.",
                                    "Para tabela de símbolos: inserir em produções de declaração (ex: TYPE ID { insertSymbol($2, $1); }).",
                                    "Passar valores semânticos via $$ (atributo sintetizado) e $1, $2 para símbolos laterais.",
                                    "Gerenciar escopos com push/pop scope em { e } da gramática."
                                  ],
                                  "verification": "Parser compila; inspecione AST impressa via função printTree() para input simples.",
                                  "estimatedTime": "2 hours",
                                  "materials": [
                                    "Documentação Bison: Semantic Values and Actions",
                                    "Exemplos Yacc de parsers com AST"
                                  ],
                                  "tips": "Imprima debug com printf em ações para rastrear construção da AST.",
                                  "learningObjective": "Associar ações C a produções para computar atributos semânticos durante parsing.",
                                  "commonMistakes": [
                                    "Confundir $1/$2 com $$",
                                    "Não copiar strings (use strdup())",
                                    "Ações em regras vazias causando null pointers"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Testar, depurar e otimizar o parser semântico",
                                  "subSteps": [
                                    "Criar lexer flex compatível com yylex() retornando tokens.",
                                    "Testar casos: input válido (construir AST completa), inválido (recuperar erros).",
                                    "Usar yydebug=1 e gdb para depurar vazamentos ou crashes.",
                                    "Otimizar: reduzir alocações, usar pools de memória se necessário.",
                                    "Validar: percorrer AST pós-parse para verificações semânticas básicas."
                                  ],
                                  "verification": "Parser processa 5+ inputs variados corretamente, sem leaks (valgrind) e AST precisa.",
                                  "estimatedTime": "1.5 hours",
                                  "materials": [
                                    "Flex para lexer",
                                    "Valgrind para memory leaks",
                                    "GDB debugger"
                                  ],
                                  "tips": "Escreva um test suite com múltiplos inputs e asserts na AST.",
                                  "learningObjective": "Integrar e validar ações semânticas em um parser completo.",
                                  "commonMistakes": [
                                    "Não tratar erros de parsing em ações",
                                    "Memória não liberada no final",
                                    "Recursion infinita em printTree para árvores cíclicas"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um parser para expressões aritméticas (2+3*4), a regra 'expr: expr '+' term { $$ = createNode('+', $1, $3); }' constrói nó '+' com filhos expr e term, formando AST: (+ (2) (* (3) (4))). Tabela de símbolos insere 'int x;' como {name:'x', type:'int'}.",
                              "finalVerifications": [
                                "Parser compila e executa sem warnings ou erros de runtime.",
                                "AST construída reflete corretamente a estrutura sintática do input.",
                                "Tabela de símbolos contém todas declarações com tipos/escopos corretos.",
                                "Nenhum vazamento de memória detectado por valgrind.",
                                "Tratamento de erros sintânticos previne crashes em ações.",
                                "Debug traces confirmam execução sequencial das ações."
                              ],
                              "assessmentCriteria": [
                                "Código C limpo, modular e bem comentado nas ações.",
                                "Gerenciamento correto de memória (malloc/free sem leaks).",
                                "Atributos semânticos propagados precisamente via $$ e $n.",
                                "Escalabilidade: suporta gramáticas com >20 regras.",
                                "Eficiência: tempo de parsing linear no tamanho do input.",
                                "Robustez: graceful handling de erros semânticos iniciais."
                              ],
                              "crossCurricularConnections": [
                                "Estruturas de Dados: árvores e tabelas hash para AST/symbol table.",
                                "Programação em C: ponteiros, alocação dinâmica e debugging.",
                                "Teoria da Computação: atributos sintetizados em parsing descendente/ascendente.",
                                "Engenharia de Software: testes unitários e integração lexer/parser.",
                                "Análise Estática: base para otimizadores e verificadores de código."
                              ],
                              "realWorldApplication": "Em compiladores como GCC/Clang, ações semânticas constroem ASTs para otimização; em ferramentas como ANTLR ou ferramentas de análise de logs/configs, populam tabelas de símbolos para validação semântica em sistemas reais."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.7.3.3",
                        "name": "Aplicações e Tratamento de Erros em Geradores de Parsers",
                        "description": "Uso prático de geradores em meta-compiladores, incluindo estratégias de recuperação de erros e otimização de parsers para compiladores reais.",
                        "specificSkills": [
                          {
                            "id": "10.1.7.3.3.1",
                            "name": "Implementar tratamento de erros em parsers gerados",
                            "description": "Utilizar yyerror(), yyerrok() e diretivas %error em Yacc/Bison para recuperação de erros sintáticos, fornecendo mensagens informativas e continuando a análise.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Configurar ambiente e parser básico em Yacc/Bison",
                                  "subSteps": [
                                    "Instale Bison/Yacc no sistema operacional.",
                                    "Crie um arquivo .y básico com regras gramaticais simples (ex: expressões aritméticas).",
                                    "Gere o parser com 'bison -d arquivo.y' e compile com flex se necessário.",
                                    "Teste o parser com entrada válida para confirmar funcionamento básico.",
                                    "Analise a saída padrão de erros em entradas inválidas."
                                  ],
                                  "verification": "Parser compila e processa entrada válida sem erros; entrada inválida gera erro padrão.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Bison/Yacc instalado",
                                    "Editor de texto (VS Code ou Vim)",
                                    "Terminal/Shell",
                                    "Exemplos de gramáticas simples"
                                  ],
                                  "tips": "Use '%{ %}' para seções C no .y e inclua stdio.h para printf.",
                                  "learningObjective": "Entender a estrutura básica de um parser Yacc/Bison e identificar onde erros ocorrem.",
                                  "commonMistakes": [
                                    "Esquecer de declarar 'yyparse()' externamente",
                                    "Não usar -d no bison para yy*.h",
                                    "Ignorar warnings de compilação"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar função yyerror() personalizada",
                                  "subSteps": [
                                    "Declare yyerror como 'void yyerror(char *s)' no arquivo .y.",
                                    "Implemente corpo com fprintf(stderr, \"Erro na linha %d: %s\\n\", yylineno, s);",
                                    "Adicione yylineno via '%{ int yylineno = 1; %}' e regras para incrementar.",
                                    "Teste com entrada inválida e verifique mensagem no stderr.",
                                    "Melhore mensagem com contexto do token atual via yytext."
                                  ],
                                  "verification": "Entrada inválida produz mensagem de erro informativa com linha e token.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Parser básico do Step 1",
                                    "Documentação Bison (man bison)",
                                    "Flex para lexer se integrado"
                                  ],
                                  "tips": "Use extern int yylineno; e regras como { yylineno++; return EOL; } para linhas.",
                                  "learningObjective": "Criar mensagens de erro claras e contextualizadas usando yyerror().",
                                  "commonMistakes": [
                                    "Não incluir <stdio.h>",
                                    "Esquecer de passar yylineno",
                                    "Usar printf em vez de fprintf(stderr)"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Adicionar recuperação de erros com yyerrok()",
                                  "subSteps": [
                                    "Identifique regra de erro: error : error ';' | error ')' | ... { yyerrok; }",
                                    "Adicione yyerrok; no final da regra para resetar estado de erro.",
                                    "Teste com múltiplos erros em uma linha para ver se continua parsing após ; ou ).",
                                    "Combine com yyerror para reportar e recuperar.",
                                    "Ajuste regras para cobrir tokens de sincronização comuns (;, ), EOF)."
                                  ],
                                  "verification": "Parser recupera após erro e processa o resto da entrada corretamente.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Parser com yyerror do Step 2",
                                    "Testes com entradas multi-erro",
                                    "Debugger como gdb"
                                  ],
                                  "tips": "yyerrok limpa yyerrflag; use em regras após tokens delimitadores.",
                                  "learningObjective": "Implementar recuperação sintática para continuar análise apesar de erros.",
                                  "commonMistakes": [
                                    "Colocar yyerrok antes de ações",
                                    "Não cobrir todos tokens de sincronização",
                                    "Conflitos shift/reduce em regras error"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Utilizar diretivas %error-verbose e testar integralmente",
                                  "subSteps": [
                                    "Adicione '%error-verbose' no cabeçalho .y para mensagens automáticas detalhadas.",
                                    "Gere parser com bison -v para arquivo .output e analise conflitos.",
                                    "Crie suíte de testes: válidos, 1 erro, múltiplos erros, EOF.",
                                    "Meça taxa de recuperação e refine mensagens.",
                                    "Documente limitações e integre com lexer para erros léxicos."
                                  ],
                                  "verification": "Parser lida com erros verbosos, recupera e gera relatório via .output.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Parser completo dos steps anteriores",
                                    "Scripts de teste bash",
                                    "Bison .output"
                                  ],
                                  "tips": " %error-verbose gera yyerror com estados; combine com custom yyerror.",
                                  "learningObjective": "Otimizar tratamento de erros com diretivas Bison e validação completa.",
                                  "commonMistakes": [
                                    "Ignorar .output para debug",
                                    "Testes só com 1 erro",
                                    "Conflitos não resolvidos"
                                  ]
                                }
                              ],
                              "practicalExample": "Crie um parser para expressões aritméticas (ex: 2+3* (4-1 ) ) com erro em parêntese extra. O parser deve reportar 'Erro na linha 1: syntax error' via yyerror, recuperar com ')', continuar calculando 2+3*3=11, usando yyerrok após ')' e mensagens verbose.",
                              "finalVerifications": [
                                "Parser compila e executa sem crashes em entradas inválidas.",
                                "yyerror() é invocada com linha, token e mensagem clara.",
                                "yyerrok permite recuperação e parsing parcial bem-sucedido.",
                                "%error-verbose gera diagnósticos detalhados em .output.",
                                "Taxa de detecção >90% em suíte de 20 testes multi-erro.",
                                "Integração com lexer para erros mistos."
                              ],
                              "assessmentCriteria": [
                                "Precisão das mensagens de erro (contexto, linha, token).",
                                "Eficácia da recuperação (continua parsing útil).",
                                "Robustez contra múltiplos erros consecutivos.",
                                "Conformidade com gramática sem conflitos shift/reduce.",
                                "Eficiência (tempo de parse similar a sem erros).",
                                "Documentação de limitações e testes."
                              ],
                              "crossCurricularConnections": [
                                "Engenharia de Software: Princípios de robustez e fault-tolerance.",
                                "Desenvolvimento de Software: Debugging e logging avançado.",
                                "Interação Humano-Computador: UX em mensagens de erro para desenvolvedores.",
                                "Teoria da Computação: Autômatos e recuperação em linguagens formais.",
                                "Sistemas Operacionais: Tratamento de exceções em runtime."
                              ],
                              "realWorldApplication": "Em compiladores profissionais como GCC/Clang, onde parsers lidam com código buggy de usuários, reportam erros localizados, sugerem correções e continuam análise para diagnósticos múltiplos, acelerando desenvolvimento em IDEs como VS Code ou Eclipse."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.7.3.3.2",
                            "name": "Aplicar geradores em contextos de meta-compiladores",
                            "description": "Explicar como Yacc/Bison facilitam a construção bootstrapped de compiladores, referenciando exemplos de livros como Aho et al. e Santos/Langlois.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Fundamentos de Yacc/Bison e Bootstrapping em Compiladores",
                                  "subSteps": [
                                    "Estude a sintaxe básica de Yacc/Bison, incluindo regras de gramática, ações semânticas e diretivas como %token e %start.",
                                    "Aprenda o conceito de compiladores bootstrapped: um compilador escrito em sua própria linguagem de saída, compilado iterativamente.",
                                    "Identifique como Yacc/Bison geram parsers que podem ser usados em fases front-end de meta-compiladores.",
                                    "Revise definições de meta-compiladores: compiladores que geram compiladores para outras linguagens.",
                                    "Anote exemplos iniciais de gramáticas LALR(1) usadas em contextos auto-gerativos."
                                  ],
                                  "verification": "Crie um diagrama de fluxo explicando como Yacc gera um parser para um compilador bootstrapped e liste 3 diretivas chave.",
                                  "estimatedTime": "2-3 horas",
                                  "materials": "Documentação oficial do Bison (gnu.org/software/bison), capítulo 4 do 'Dragon Book' (Aho et al.).",
                                  "tips": "Use o modo flexível do Bison (--no-lines) para depuração mais fácil em iterações bootstrapped.",
                                  "learningObjective": "Compreender como Yacc/Bison abstraem a construção de parsers para suportar auto-compilação.",
                                  "commonMistakes": "Confundir shift-reduce com parsing recursivo descendente; ignorar conflitos de reduce/reduce em gramáticas ambíguas."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar Exemplos de Livros e Casos de Bootstrapping",
                                  "subSteps": [
                                    "Leia seções relevantes do 'Compilers: Principles, Techniques, and Tools' (Aho et al.), focando em Yacc para parsers sintáticos.",
                                    "Estude exemplos de Santos/Langlois sobre geradores em meta-compiladores, notando gramáticas para linguagens de compiladores.",
                                    "Compare como Yacc facilita bootstrapping vs. parsers manuais, destacando redução de código boilerplate.",
                                    "Extraia gramáticas de exemplo dos livros e teste-as com Bison para gerar parsers simples.",
                                    "Documente vantagens: modularidade, tratamento automático de lookahead e backtracking limitado."
                                  ],
                                  "verification": "Resuma em 200 palavras como Yacc é usado em um exemplo bootstrapped do Dragon Book, citando páginas específicas.",
                                  "estimatedTime": "3-4 horas",
                                  "materials": "Livros 'Dragon Book' (Aho et al.) e obras de Santos/Langlois (PDFs ou edições digitais), Bison instalado.",
                                  "tips": "Use %expect para suprimir avisos de conflitos durante experimentos iniciais com gramáticas dos livros.",
                                  "learningObjective": "Identificar padrões de uso de Yacc/Bison em literatura acadêmica para meta-compiladores.",
                                  "commonMistakes": "Não referenciar exemplos específicos; assumir que todo parser Yacc é determinístico sem checar conflitos."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar um Parser Bootstrapped Simples com Yacc/Bison",
                                  "subSteps": [
                                    "Defina uma mini-linguagem para um compilador (ex: aritmética simples + declarações de variáveis).",
                                    "Escreva um arquivo .y com gramática que parse código fonte dessa linguagem, gerando AST.",
                                    "Compile com Bison e integre com um lexer simples (Flex) para formar front-end de meta-compilador.",
                                    "Crie um ciclo bootstrapped: use o parser gerado para compilar uma versão melhorada de si mesmo.",
                                    "Adicione ações semânticas para simular geração de código que outputa o próprio .y file."
                                  ],
                                  "verification": "Execute o pipeline e demonstre que o parser compilado processa corretamente um programa fonte que gera outro parser equivalente.",
                                  "estimatedTime": "4-6 horas",
                                  "materials": "Bison e Flex instalados, editor de texto (VS Code com extensões Yacc), mini-linguagem exemplo.",
                                  "tips": "Comece com gramática não-ambígua; use yyerror() customizado para logs claros durante bootstrapping.",
                                  "learningObjective": "Aplicar Yacc/Bison para construir um meta-compilador funcional com auto-bootstrapping.",
                                  "commonMistakes": "Esquecer de declarar precedência (%left/%right) levando a conflitos shift/reduce; não gerenciar estados globais em ações."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Otimizar, Testar Tratamento de Erros e Verificar Bootstrapping Completo",
                                  "subSteps": [
                                    "Implemente recuperação de erros em Yacc (ex: error token e yyerrok).",
                                    "Teste iterações múltiplas de bootstrapping (T-diagramas: código fonte -> compilador v1 -> v2).",
                                    "Meça estabilidade: verifique se parsers gerados em iterações subsequentes são idênticos.",
                                    "Compare performance com parsers manuais, medindo LOC e tempo de parsing.",
                                    "Documente lições aprendidas, referenciando livros para validação."
                                  ],
                                  "verification": "Gere relatório com T-diagramas de 3 iterações e teste com 5 casos de erro, mostrando recuperação bem-sucedida.",
                                  "estimatedTime": "3-5 horas",
                                  "materials": "Scripts de teste (Bash/Python), Valgrind para profiling, exemplos de livros para benchmarks.",
                                  "tips": "Use %define api.pure para reentrância em cenários multi-threaded de meta-compilação.",
                                  "learningObjective": "Garantir robustez e corretude em aplicações de Yacc/Bison para meta-compiladores bootstrapped.",
                                  "commonMistakes": "Ignorar vazamentos de memória em ações semânticas; não testar gramáticas com lookahead >1."
                                }
                              ],
                              "practicalExample": "Crie um meta-compilador para uma linguagem 'MiniC' usando Bison: o .y define gramática para MiniC, gera AST, e ações semânticas outputam código C que recompila o próprio parser, demonstrando bootstrapping completo como no capítulo 4 do Dragon Book.",
                              "finalVerifications": [
                                "Explicar verbalmente como Yacc reduz complexidade em bootstrapping com exemplo de Aho et al.",
                                "Gerar e executar 3 iterações de um compilador bootstrapped sem erros de parsing.",
                                "Identificar e resolver 2 conflitos de gramática em um .y file real.",
                                "Comparar Yacc vs. parser manual em termos de LOC e manutenibilidade.",
                                "Referenciar Santos/Langlois para um caso de erro handling em meta-parsers.",
                                "Demonstrar recuperação de erros em input inválido durante demo ao vivo."
                              ],
                              "assessmentCriteria": [
                                "Precisão na explicação de Yacc em contextos bootstrapped (80%+ acurácia em quiz).",
                                "Funcionalidade completa do exemplo implementado (passa todos testes automatizados).",
                                "Qualidade da gramática: zero conflitos reportados pelo Bison.",
                                "Documentação clara com referências bibliográficas exatas.",
                                "Eficiência: tempo de parsing < 1s para inputs médios.",
                                "Criatividade em extensão: adição de feature não-trivial (ex: otimização semântica)."
                              ],
                              "crossCurricularConnections": [
                                "Teoria da Computação: Autômatos e linguagens formais (gramáticas livres de contexto).",
                                "Engenharia de Software: Padrões de design para ferramentas geradoras (DSL).",
                                "Matemática Discreta: Teoria de grafos em árvores de parsing.",
                                "Inteligência Artificial: Parsers em PLN para processamento de linguagem natural."
                              ],
                              "realWorldApplication": "Em projetos como GCC/Clang, Yacc/Bison são usados para parsers front-end bootstrapped, permitindo evolução de linguagens como C++ sem reescrita manual; também em ferramentas como ANTLR alternatives para compiladores de domínios específicos em fintech e embedded systems."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.7.4",
                    "name": "Especificação de Gramáticas em Ferramentas Automáticas",
                    "description": "Definição formal de regras léxicas e sintáticas para geração automática de componentes de compiladores.",
                    "individualConcepts": [
                      {
                        "id": "10.1.7.4.1",
                        "name": "Especificação de Regras Léxicas",
                        "description": "Definição formal de expressões regulares e padrões de tokens para geração automática de analisadores léxicos em ferramentas como Flex ou Lex.",
                        "specificSkills": [
                          {
                            "id": "10.1.7.4.1.1",
                            "name": "Identificar componentes de uma especificação léxica",
                            "description": "Reconhecer e descrever os elementos principais de uma especificação léxica, incluindo declarações, definições de padrões com expressões regulares, regras de ação e seções de código usuário em ferramentas automáticas.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a Estrutura Geral de uma Especificação Léxica",
                                  "subSteps": [
                                    "Estude a documentação oficial de ferramentas como Lex ou Flex para entender o formato de arquivo.",
                                    "Identifique as três seções principais: seção de declarações (definições), seção de regras léxicas e seção de código usuário.",
                                    "Analise a sintaxe básica, incluindo o uso de %% para delimitar seções.",
                                    "Revise exemplos simples de especificações léxicas disponíveis online ou em livros de compiladores."
                                  ],
                                  "verification": "Desenhe um diagrama esquemático da estrutura geral de uma spec léxica e explique verbalmente ou por escrito.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Documentação do Lex/Flex (PDF ou site oficial)",
                                    "Exemplo básico de arquivo .l"
                                  ],
                                  "tips": "Sempre procure pelos delimitadores %% para separar seções claramente.",
                                  "learningObjective": "Dominar a divisão estrutural de uma especificação léxica em suas seções fundamentais.",
                                  "commonMistakes": [
                                    "Confundir a ordem das seções",
                                    "Ignorar comentários que explicam a estrutura"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar a Seção de Declarações",
                                  "subSteps": [
                                    "Localize a seção inicial antes do primeiro %% , que contém definições de macros e literais.",
                                    "Reconheça declarações como nome[ ] (padrões literais) e nome expressão (macros regex).",
                                    "Identifique diretivas como %{} para inclusão de código C e %{ para headers.",
                                    "Liste todas as declarações em um exemplo dado e explique seu propósito."
                                  ],
                                  "verification": "Extraia e liste todas as declarações de um arquivo de exemplo, justificando cada uma.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Exemplo de spec léxica com declarações ricas",
                                    "Editor de texto como VS Code"
                                  ],
                                  "tips": "Declarações começam com maiúsculas para padrões e são usadas para simplificar regras.",
                                  "learningObjective": "Reconhecer e descrever declarações, macros e diretivas na seção inicial.",
                                  "commonMistakes": [
                                    "Misturar declarações com regras léxicas",
                                    "Esquecer diretivas de inclusão como %{"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Reconhecer Definições de Padrões e Regras Léxicas",
                                  "subSteps": [
                                    "Identifique a seção entre o primeiro e segundo %%, contendo regras no formato padrão ação.",
                                    "Analise padrões compostos por expressões regulares, referenciando macros definidas anteriormente.",
                                    "Diferencie regras prioritárias (mais específicas primeiro) e regras de fallback.",
                                    "Teste mentalmente se um padrão regex corresponde a tokens esperados como IDs ou números."
                                  ],
                                  "verification": "Marque todas as regras léxicas em um spec e classifique seus padrões como regex simples ou compostos.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Exemplos de specs com regex complexas",
                                    "Ferramenta online de teste regex (regex101.com)"
                                  ],
                                  "tips": "Regras são processadas de cima para baixo; ordem importa para precedência.",
                                  "learningObjective": "Descrever padrões regex em regras léxicas e sua função na tokenização.",
                                  "commonMistakes": [
                                    "Ignorar precedência de regras",
                                    "Confundir padrões com ações"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Identificar Regras de Ação e Seção de Código Usuário",
                                  "subSteps": [
                                    "Para cada regra, localize a ação em { } após o padrão, que contém código executável (ex: yylval).",
                                    "Diferencie ações simples (return TOKEN) de ações complexas com múltiplas linhas.",
                                    "Localize a seção após o segundo %%, contendo código C arbitrário como funções auxiliares.",
                                    "Compile mentalmente como ações interagem com o código usuário."
                                  ],
                                  "verification": "Descreva o fluxo de uma regra completa: padrão → ação → impacto no código usuário.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Compilador Flex instalado ou online",
                                    "Exemplo completo de spec léxica compilável"
                                  ],
                                  "tips": "Ações definem o que acontece ao matching; código usuário é para lógica adicional.",
                                  "learningObjective": "Explicar o papel das ações e integração com código usuário.",
                                  "commonMistakes": [
                                    "Separar ação do padrão",
                                    "Subestimar o escopo do código usuário"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Analisar uma Especificação Léxica Completa",
                                  "subSteps": [
                                    "Pegue um exemplo real e rotule todas as seções e componentes.",
                                    "Simule a tokenização de uma string de entrada através das regras.",
                                    "Identifique interdependências entre declarações, regras e código.",
                                    "Documente anomalias ou extensões não padrão."
                                  ],
                                  "verification": "Crie um relatório anotado de um spec completo, destacando todos os componentes.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Exemplo real de spec para uma mini-linguagem",
                                    "Ferramenta Flex para teste"
                                  ],
                                  "tips": "Use yyin para input de teste e observe saída de tokens.",
                                  "learningObjective": "Integrar todos os componentes em uma análise holística.",
                                  "commonMistakes": [
                                    "Perder componentes em specs longas",
                                    "Não testar com input real"
                                  ]
                                }
                              ],
                              "practicalExample": "Exemplo de spec Lex para tokenizar uma linguagem simples:\n\n%{\n#include <stdio.h>\n%}\n\nDIGITO [0-9]\nNUMERO {DIGITO}+\n\n%%\n\"if\" { return IF; }\n{NUMERO} { yylval = atoi(yytext); return NUMBER; }\n[ \t\n] ;\n. { printf(\"Erro: %s\\n\", yytext); }\n\n%% \nint main() { yylex(); return 0; }\n\nAqui, %{} é declaração/header, DIGITO/NUMERO são definições, %% regras com padrões e ações, %% código usuário.",
                              "finalVerifications": [
                                "Pode delimitar corretamente as três seções principais em qualquer spec.",
                                "Lista todas as declarações e suas expansões regex.",
                                "Identifica pelo menos 80% das regras léxicas e suas ações associadas.",
                                "Explica o fluxo de tokenização de um input simples.",
                                "Diferencia código usuário de ações em regras."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de seções (100% obrigatório).",
                                "Correta descrição de pelo menos 5 padrões regex com exemplos de match.",
                                "Análise completa de ações em 3 regras diferentes.",
                                "Demonstração de compilação e teste de uma spec anotada.",
                                "Uso correto de terminologia (ex: macro, literal, ação)."
                              ],
                              "crossCurricularConnections": [
                                "Teoria da Computação: Autômatos Finitos e Expressões Regulares.",
                                "Linguagens de Programação: Uso de Regex em Python/Java para parsing.",
                                "Engenharia de Software: Desenvolvimento de Tools para DSLs.",
                                "Matemática Discreta: Linguagens Regulares e Teorema de Kleene."
                              ],
                              "realWorldApplication": "Em compiladores como GCC ou ferramentas de análise de logs (ex: ELK Stack), specs léxicas geram scanners eficientes para tokenizar código-fonte ou dados em tempo real, essenciais para IDEs, linters e processadores de linguagem natural."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.7.4.1.2",
                            "name": "Escrever expressões regulares para tokens",
                            "description": "Construir expressões regulares precisas para identificar tokens comuns como identificadores, literais numéricos, strings e operadores em linguagens de programação, considerando precedência e exclusividade.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar conceitos de tokens e fundamentos de expressões regulares",
                                  "subSteps": [
                                    "Liste os tipos comuns de tokens: identificadores, literais numéricos, strings, operadores e palavras-chave.",
                                    "Estude a sintaxe básica de regex: caracteres literais, metacaracteres (. ^ $ * + ? [] {} | ()), quantificadores e classes de caracteres.",
                                    "Entenda o conceito de 'greedy' vs 'lazy' matching e âncoras (^ $).",
                                    "Pratique com ferramentas online como regex101.com para testar padrões simples.",
                                    "Identifique como regex são usadas na análise léxica de compiladores."
                                  ],
                                  "verification": "Crie e teste 3 regex simples (ex: dígitos, letras) que matcham corretamente em exemplos de código.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Regex101.com ou RegexBuddy",
                                    "Documentação de regex em JavaScript/Python",
                                    "Exemplos de código fonte de linguagens como C ou Python"
                                  ],
                                  "tips": "Sempre escape metacaracteres com \\ quando necessário e use flags como 'i' para case-insensitive em identificadores.",
                                  "learningObjective": "Compreender os blocos de construção de regex e sua aplicação em tokens léxicos.",
                                  "commonMistakes": [
                                    "Ignorar case-sensitivity em identificadores.",
                                    "Confundir quantificadores greedy com lazy.",
                                    "Esquecer âncoras para matching exato."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Construir regex para identificadores e palavras-chave",
                                  "subSteps": [
                                    "Defina o padrão para identificadores: letra ou _ seguida de alfanuméricos ou _ (ex: [a-zA-Z_][a-zA-Z0-9_]*).",
                                    "Crie regex para palavras-chave específicas (ex: if, while) usando alternância |.",
                                    "Garanta exclusividade: identificadores não devem matchar palavras-chave (use negative lookahead se necessário).",
                                    "Teste com exemplos: var1, _private, if, whileloop (deve matchar 'whileloop' como id, não 'while').",
                                    "Ajuste para Unicode se aplicável em linguagens modernas."
                                  ],
                                  "verification": "A regex distingue corretamente identificadores de palavras-chave em 10 exemplos de código.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Editor de texto com suporte a regex (VS Code)",
                                    "Lista de palavras-chave de uma linguagem (ex: Python keywords)"
                                  ],
                                  "tips": "Ordene regras léxicas com palavras-chave primeiro para maior precedência.",
                                  "learningObjective": "Desenvolver regex precisas para tokens nominais com exclusividade.",
                                  "commonMistakes": [
                                    "Permitir início com dígito em identificadores.",
                                    "Matchar palavras-chave dentro de identificadores maiores.",
                                    "Não testar edge cases como '__init__'."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Desenvolver regex para literais numéricos e strings",
                                  "subSteps": [
                                    "Para números: inteiros ([0-9]+), floats ([0-9]+\\.[0-9]+), científicos ([0-9]+[eE][+-]?[0-9]+).",
                                    "Combine em uma regex com alternância: (0|[1-9][0-9]*)(\\.[0-9]+)?([eE][+-]?[0-9]+)?.",
                                    "Para strings: \"([^\\\"]|\\\\.)*\" ou '[^']*' considerando escapes.",
                                    "Teste exclusividade: números não matcham como identificadores, strings fecham corretamente.",
                                    "Inclua literais booleanos ou null se relevante (true|false|null)."
                                  ],
                                  "verification": "Regex matcha todos os formatos numéricos e strings em um trecho de código sem falsos positivos.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Regex tester online",
                                    "Exemplos de literais de linguagens como JavaScript ou Java"
                                  ],
                                  "tips": "Use grupos não-capturadores (?:) para clareza e evite backtracking excessivo com possessivos (*+).",
                                  "learningObjective": "Criar regex robustas para tokens literais com suporte a escapes e formatos variados.",
                                  "commonMistakes": [
                                    "Não lidar com notação científica ou decimais sem dígitos após ponto.",
                                    "Falhar em strings com aspas escapadas ou multiline.",
                                    "Matchar números dentro de identificadores."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Escrever regex para operadores e símbolos",
                                  "subSteps": [
                                    "Liste operadores comuns: aritméticos (+ - * /), relacionais (== != > <), lógicos (&& || !).",
                                    "Crie regex para cada classe, considerando comprimento variável (ex: === vs =, >>= vs >).",
                                    "Use alternância ordenada para precedência: padrões mais longos primeiro (ex: \\*= antes de \\*).",
                                    "Teste em contextos: operadores isolados vs em expressões.",
                                    "Inclua delimitadores como ; , ( ) { }."
                                  ],
                                  "verification": "Regex identifica todos os operadores corretamente em uma expressão complexa sem sobreposição.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Tabela de operadores de uma linguagem (ex: C++ operator precedence)",
                                    "Lexer generator como Flex (para inspiração)"
                                  ],
                                  "tips": "Em lexers, o longest match rule resolve precedência; simule isso testando sequencialmente.",
                                  "learningObjective": "Dominar regex para tokens simbólicos com resolução de ambiguidade por comprimento.",
                                  "commonMistakes": [
                                    "Matchar operador curto dentro de longo (ex: = em ==).",
                                    "Ignorar operadores compostos como +=.",
                                    "Confundir com delimitadores de strings."
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Integrar regex, testar precedência e refinar para exclusividade",
                                  "subSteps": [
                                    "Ordene todas as regex: palavras-chave > identificadores > números > strings > operadores.",
                                    "Crie um conjunto completo e teste em um scanner simulado (input string -> tokens).",
                                    "Use lookaheads negativos para exclusividade (ex: identificador não precedido por operador).",
                                    "Valide edge cases: comentários, whitespace, erros de sintaxe.",
                                    "Otimize performance medindo backtracking em testes grandes."
                                  ],
                                  "verification": "O conjunto de regex tokeniza corretamente um programa pequeno sem ambiguidades ou vazamentos.",
                                  "estimatedTime": "50 minutos",
                                  "materials": [
                                    "Script Python/JS para testar tokenizer",
                                    "Código fonte exemplo de 50 linhas"
                                  ],
                                  "tips": "Implemente um lexer simples em Python com re.findall ou re.finditer para validação.",
                                  "learningObjective": "Construir e validar um conjunto de regex léxicas completas e sem conflitos.",
                                  "commonMistakes": [
                                    "Ordem errada causando longest match incorreto.",
                                    "Não tratar whitespace/comments como tokens ignorados.",
                                    "Sobrecarga de performance por regex ineficientes."
                                  ]
                                }
                              ],
                              "practicalExample": "Para uma mini-linguagem: id: [a-zA-Z_][a-zA-Z0-9_]*; num: (0|[1-9]\\d*)(\\.\\d+)?([eE][+-]?\\d+)?; str: \"(\\\\.|[^\\\\\"])*\"); op: \\+\\+|\\-\\-|\\*|\\+|\\-|/|==|!=|>=|<=|>|<|&&|\\|\\||!|;|,|\\(|\\)|\\{|\\}. Teste tokenizando: x=1.23e4; if(x>0) { y=\"hello\"; }",
                              "finalVerifications": [
                                "Tokeniza corretamente um programa de 20 linhas sem erros.",
                                "Regex individuais matcham 100% dos casos positivos e 0% negativos.",
                                "Precedência respeitada: operadores longos antes de curtos.",
                                "Exclusividade mantida: nenhum token sobrepõe outro.",
                                "Performance aceitável em inputs grandes (>1000 chars).",
                                "Edge cases como escapes e Unicode tratados."
                              ],
                              "assessmentCriteria": [
                                "Precisão e completude das regex (cobertura de variantes).",
                                "Resolução correta de precedência e ambiguidade.",
                                "Eficiência (baixo backtracking, tempo de execução).",
                                "Clareza e legibilidade do código regex (comentários, grupos nomeados).",
                                "Robustez contra inputs malformados.",
                                "Documentação de testes e casos falhados resolvidos.",
                                "Integração em um lexer funcional."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria de linguagens formais e autômatos finitos (regex como AFN).",
                                "Linguística: Morfologia e tokenização de texto natural.",
                                "Engenharia de Software: Desenvolvimento de ferramentas de parsing e IDEs.",
                                "Processamento de Dados: Validação e parsing de logs ou dados estruturados.",
                                "Inteligência Artificial: Pré-processamento para NLP e matchers em ML."
                              ],
                              "realWorldApplication": "Em compiladores e interpretadores (ex: GCC, Python lexer), editores/IDES (VS Code syntax highlighting), ferramentas de validação (JSON parsers, form inputs), segurança (detecção de padrões maliciosos em logs), e automação de testes de input."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.7.4.1.3",
                            "name": "Gerar analisador léxico com ferramentas automáticas",
                            "description": "Configurar e compilar uma especificação léxica em ferramentas como Flex para produzir um analisador léxico funcional que retorne tokens para um analisador sintático.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Instalar e Configurar o Ambiente de Ferramentas Léxicas",
                                  "subSteps": [
                                    "Instale o Flex (ou equivalente como JFlex para Java) via gerenciador de pacotes (apt, brew, etc.).",
                                    "Verifique a instalação executando 'flex --version' no terminal.",
                                    "Crie um diretório de projeto e prepare um arquivo de entrada simples (.l).",
                                    "Configure um editor de texto ou IDE com suporte a sintaxe para arquivos Flex.",
                                    "Teste a compilação de um exemplo mínimo fornecido na documentação do Flex."
                                  ],
                                  "verification": "Comando 'flex --version' retorna versão válida e um lexer mínimo compila sem erros.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Flex instalado",
                                    "Terminal/Shell",
                                    "Editor de texto (VS Code, Vim)",
                                    "Documentação oficial do Flex"
                                  ],
                                  "tips": "Use um ambiente virtual ou container Docker para isolar dependências e evitar conflitos.",
                                  "learningObjective": "Configurar corretamente o ambiente para desenvolvimento de analisadores léxicos automatizados.",
                                  "commonMistakes": [
                                    "Não instalar dependências como bison se necessário",
                                    "Ignorar configurações de PATH",
                                    "Usar versão desatualizada do Flex"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Escrever a Especificação Léxica com Regras de Tokens",
                                  "subSteps": [
                                    "Defina a seção de definições (declarações de literais e macros regex).",
                                    "Escreva regras léxicas para tokens principais (ex: ID, NUMBER, KEYWORDS) usando expressões regulares.",
                                    "Inclua regras para ignorar whitespaces e comentários.",
                                    "Adicione ações C para retornar tokens (yylval e return TOKEN).",
                                    "Estruture a seção de código C com yywrap e main para testes iniciais."
                                  ],
                                  "verification": "Arquivo .l é sintaticamente válido e não gera warnings ao compilar manualmente.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Documentação Flex (man flex)",
                                    "Exemplos de gramáticas léxicas",
                                    "Referência de expressões regulares POSIX"
                                  ],
                                  "tips": "Comece com regras simples e adicione complexidade gradualmente; use %option noyywrap para simplificar.",
                                  "learningObjective": "Criar especificações léxicas precisas que capturem tokens corretamente sem ambiguidades.",
                                  "commonMistakes": [
                                    "Regras regex ambíguas levando a longest match incorreto",
                                    "Falta de tratamento para EOF",
                                    "Ações sem return de tokens apropriados"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Compilar e Gerar o Analisador Léxico Executável",
                                  "subSteps": [
                                    "Execute 'flex lexer.l' para gerar lexer.c.",
                                    "Compile lexer.c com gcc (ex: gcc -o lexer lexer.c -lfl).",
                                    "Verifique se o executável é gerado sem erros de linking.",
                                    "Adicione headers necessários (#include <stdio.h>) se ausentes.",
                                    "Teste compilação com opções de debug (-d para .dot files)."
                                  ],
                                  "verification": "Executável 'lexer' roda sem segmentation faults e processa input básico.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "GCC ou Clang",
                                    "Biblioteca libfl (Flex library)",
                                    "Terminal para compilação"
                                  ],
                                  "tips": "Use 'make' com Makefile para automatizar; linke -lfl explicitamente em alguns sistemas.",
                                  "learningObjective": "Gerar código C funcional a partir de especificações léxicas usando meta-ferramentas.",
                                  "commonMistakes": [
                                    "Esquecer de linkar libfl",
                                    "Conflitos de nomes com funções padrão",
                                    "Ignorar warnings de compilador"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Testar e Depurar o Analisador Léxico",
                                  "subSteps": [
                                    "Crie um arquivo de teste com input léxico variado (tokens válidos/inválidos).",
                                    "Execute './lexer < test.txt' e verifique saída de tokens.",
                                    "Use flex -d para gerar tabelas de transição e analisar falhas.",
                                    "Depure erros com printf em ações ou gdb.",
                                    "Itere regras até 100% de cobertura de tokens esperados."
                                  ],
                                  "verification": "Todos tokens de teste são reconhecidos e retornados corretamente sem erros.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Arquivos de teste .txt",
                                    "GDB para debug",
                                    "Ferramentas como valgrind para memory leaks"
                                  ],
                                  "tips": "Pipe input de echo ou cat para testes rápidos; compare saída com tokens esperados manualmente.",
                                  "learningObjective": "Validar e refinar analisadores léxicos para robustez em cenários reais.",
                                  "commonMistakes": [
                                    "Não testar edge cases como strings vazias ou caracteres especiais",
                                    "Ignorar infinite loops em regras",
                                    "Falta de handling para erros léxicos"
                                  ]
                                }
                              ],
                              "practicalExample": "Crie um lexer para uma mini-linguagem aritmética: reconheça tokens como ID (letras), NUMBER (dígitos), operadores (+, -, *, /), parênteses e ignore espaços/comentários. Input: 'x = 42 + y;' deve outputar tokens: ID('x'), ASSIGN, NUMBER(42), PLUS, ID('y'), SEMICOLON.",
                              "finalVerifications": [
                                "Lexer compila e executa sem crashes em inputs variados.",
                                "Regras reconhecem corretamente todos tokens definidos sem ambiguidades.",
                                "Saída de tokens pode ser consumida por um parser simples (ex: via pipe).",
                                "Tratamento adequado de erros léxicos (ex: caracteres desconhecidos).",
                                "Performance aceitável em arquivos de ~1k linhas (mede tempo de execução).",
                                "Tabelas de transição geradas (.dot) mostram estados finitos corretos."
                              ],
                              "assessmentCriteria": [
                                "Precisão das regras léxicas (sem falsos positivos/negativos).",
                                "Eficiência da compilação e execução (tempo <1s para inputs médios).",
                                "Cobertura de testes (pelo menos 10 casos variados).",
                                "Código limpo com comentários e estrutura modular.",
                                "Integração com parser mock (retorna yylval corretamente).",
                                "Documentação de regras e limitações."
                              ],
                              "crossCurricularConnections": [
                                "Teoria da Computação: Autômatos finitos e expressões regulares.",
                                "Programação em C: Manipulação de ponteiros e buffers (yytext, yyleng).",
                                "Engenharia de Software: Ferramentas de automação e pipelines de build.",
                                "Linguagens Formais: Especificação formal de linguagens regulares.",
                                "Desenvolvimento de Software: Parsers em editores/IDEs."
                              ],
                              "realWorldApplication": "Desenvolvimento de compiladores (GCC, Clang), editores de texto (Vim syntax highlighting), ferramentas de análise estática de código (linters como ESLint lexer), processadores de logs e scanners de segurança (pattern matching em firewalls)."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.7.4.2",
                        "name": "Especificação de Regras Sintáticas",
                        "description": "Definição formal de gramáticas livres de contexto utilizando notações BNF ou EBNF para geração automática de analisadores sintáticos top-down ou bottom-up em ferramentas como Yacc ou Bison.",
                        "specificSkills": [
                          {
                            "id": "10.1.7.4.2.1",
                            "name": "Definir gramáticas em notação BNF/EBNF",
                            "description": "Especificar regras de produção sintáticas em Backus-Naur Form (BNF) ou Extended BNF (EBNF), incluindo não-terminais, terminais e símbolos de início, garantindo completude para subconjuntos de linguagens.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os Conceitos Fundamentais de BNF",
                                  "subSteps": [
                                    "Estude a definição de terminais (símbolos folha, como palavras-chave ou literais) e não-terminais (variáveis que derivam em sequências).",
                                    "Aprenda a notação padrão de produção: <não-terminal> ::= expressão, onde ::= é o símbolo de definição.",
                                    "Identifique o símbolo de início (start symbol), geralmente o não-terminal raiz da gramática.",
                                    "Revise exemplos básicos de gramáticas livres de contexto (CFG) em BNF.",
                                    "Diferencie recursão esquerda, direita e mútua através de diagramas de derivação."
                                  ],
                                  "verification": "Escreva definições curtas para terminal, não-terminal e símbolo de início, com um exemplo simples cada.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Documentação W3C sobre BNF",
                                    "Tutorial online de gramáticas formais (ex: GeeksforGeeks)",
                                    "Papel e caneta para diagramas"
                                  ],
                                  "tips": "Use cores diferentes para marcar terminais (azul) e não-terminais (verde) em exemplos.",
                                  "learningObjective": "Dominar a terminologia e estrutura básica de BNF para especificar regras sintáticas.",
                                  "commonMistakes": [
                                    "Confundir terminais com não-terminais",
                                    "Omitir o símbolo ::= nas produções",
                                    "Ignorar maiúsculas/minúsculas em convenções de nomenclatura"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Explorar a Sintaxe e Extensões do EBNF",
                                  "subSteps": [
                                    "Aprenda operadores EBNF: * (zero ou mais), + (um ou mais), ? (zero ou um), () (agrupamento), | (alternativa).",
                                    "Compare produções BNF e EBNF equivalentes, convertendo uma recursão em loop EBNF.",
                                    "Pratique definindo sequências, opções e repetições usando EBNF.",
                                    "Estude precedência de operadores e como evitar ambiguidades.",
                                    "Crie uma tabela de símbolos EBNF com exemplos de cada."
                                  ],
                                  "verification": "Converta uma produção recursiva BNF simples para EBNF e vice-versa.",
                                  "estimatedTime": "50 minutos",
                                  "materials": [
                                    "Especificação ISO/IEC 14977 para EBNF",
                                    "Editor de texto para testes",
                                    "Exemplos de gramáticas JSON ou XML"
                                  ],
                                  "tips": "Sempre teste EBNF em ferramentas online como EBNF Visualizer para validar sintaxe.",
                                  "learningObjective": "Aplicar extensões EBNF para simplificar gramáticas complexas.",
                                  "commonMistakes": [
                                    "Esquecer parênteses em agrupamentos complexos",
                                    "Confundir * com + em repetições",
                                    "Não escapar caracteres especiais em terminais"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Construir Gramáticas Simples em BNF/EBNF",
                                  "subSteps": [
                                    "Defina terminais e não-terminais para uma linguagem mini, como expressões booleanas.",
                                    "Escreva 5-10 regras de produção cobrindo expressões básicas (AND, OR, NOT).",
                                    "Inclua o símbolo de início e derive 3 strings válidas manualmente.",
                                    "Teste por completude: gere todas as strings de tamanho pequeno e verifique cobertura.",
                                    "Refatore usando EBNF para reduzir o número de regras."
                                  ],
                                  "verification": "Derive pelo menos duas strings válidas e uma inválida da sua gramática.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Ferramenta online de parser como Jison ou ANTLR",
                                    "Folha de cálculo para rastrear derivações",
                                    "Exemplos de gramáticas aritméticas"
                                  ],
                                  "tips": "Comece com gramáticas ambíguas intencionalmente para aprender resolução depois.",
                                  "learningObjective": "Criar gramáticas funcionais para subconjuntos linguísticos simples.",
                                  "commonMistakes": [
                                    "Produções circulares sem base (loop infinito)",
                                    "Falta de cobertura para casos edge como strings vazias",
                                    "Inconsistência nos nomes de não-terminais"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Validar e Completar Gramáticas para Subconjuntos de Linguagens",
                                  "subSteps": [
                                    "Identifique ambiguidades usando árvores de derivação múltipla.",
                                    "Garanta completude: liste todos os constructs suportados e cubra-os nas regras.",
                                    "Defina o símbolo de início explicitamente e teste parsing de programas completos.",
                                    "Use ferramentas para gerar parser e validar contra um conjunto de testes.",
                                    "Documente limitações da gramática (ex: sem suporte a recursão aninhada)."
                                  ],
                                  "verification": "Valide a gramática com 10 strings de teste (5 válidas, 5 inválidas) usando uma ferramenta.",
                                  "estimatedTime": "75 minutos",
                                  "materials": [
                                    "ANTLR ou Bison para geração de parser",
                                    "Conjunto de testes unitários para sintaxe",
                                    "Documentação de linguagens reais como subset de C"
                                  ],
                                  "tips": "Priorize gramáticas LL(1) ou LR(1) para facilitar parsing automático.",
                                  "learningObjective": "Produzir gramáticas completas, não-ambíguas e verificáveis para sublinguagens.",
                                  "commonMistakes": [
                                    "Ambiguidades em operadores (ex: + e * sem precedência)",
                                    "Falta de símbolo de início",
                                    "Gramática incompleta que não cobre todos os casos declarados"
                                  ]
                                }
                              ],
                              "practicalExample": "Defina em EBNF a gramática para expressões aritméticas simples: expr = term {(\"+\", term)|(\"-\", term)} ; term = factor {(\"*\", factor)|(\"/\", factor)} ; factor = \"(\" expr \")\" | number ; number = digit {digit} ; digit = \"0\"|\"1\"|...|\"9\" ; Símbolo de início: expr. Teste: \"(1+2)*3\" deve parsear corretamente.",
                              "finalVerifications": [
                                "Todas as regras usam sintaxe BNF/EBNF correta sem erros léxicos.",
                                "Símbolo de início está definido e acessível de todas as produções raiz.",
                                "Não-terminais são consistentes (mesmo nome, case-sensitive).",
                                "Gramática é completa para o subconjunto especificado (todos constructs cobertos).",
                                "Nenhuma ambiguidade detectada em derivações de teste.",
                                "Parsing bem-sucedido em pelo menos 80% dos casos de teste.",
                                "Documentação inclui limitações claras."
                              ],
                              "assessmentCriteria": [
                                "Precisão na distinção entre terminais e não-terminais (90% acurácia).",
                                "Uso correto de operadores EBNF para compactação (redução >20% nas regras).",
                                "Completude: cobertura de 100% dos constructs declarados.",
                                "Ausência de ambiguidades comprovada por testes.",
                                "Eficiência: gramática parseável por ferramentas padrão (LL/LR).",
                                "Clareza na documentação e nomenclatura intuitiva."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria de Autômatos e Linguagens Formais (Chomsky Hierarchy).",
                                "Linguística: Gramáticas Gerativas e Análise Sintática.",
                                "Engenharia de Software: Design de DSLs e Ferramentas de Parsing.",
                                "Lógica: Recursão e Indução em Definições Formais.",
                                "Inteligência Artificial: Processamento de Linguagem Natural (gramáticas probabilísticas)."
                              ],
                              "realWorldApplication": "Definir gramáticas BNF/EBNF é crucial no desenvolvimento de compiladores (ex: GCC para C++), interpretadores (Python), ferramentas de validação JSON/XML (parsers em navegadores), e meta-compiladores como Yacc/Bison, permitindo automação de análise sintática em projetos de software e linguagens de domínio específico."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.7.4.2.2",
                            "name": "Resolver ambiguidades e recursão em gramáticas",
                            "description": "Identificar e corrigir ambiguidades, recursão à esquerda e conflitos shift-reduce em gramáticas sintáticas para torná-las adequadas para parsing LL ou LR.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender Conceitos Fundamentais de Ambiguidades, Recursão e Conflitos",
                                  "subSteps": [
                                    "Estude definições: ambiguidade (duas árvores de derivação para mesma string), recursão esquerda (não-terminal à esquerda em produção), shift-reduce e reduce-reduce conflicts.",
                                    "Analise exemplos clássicos: gramática de expressões aritméticas para ambiguidade (E → E + E | E * E | id).",
                                    "Revise requisitos para LL(k) e LR(k): sem recursão esquerda para LL, sem conflitos para LR.",
                                    "Pratique identificando recursão direta e indireta em produções.",
                                    "Memorize técnicas iniciais: fatoração à esquerda para ambiguidades triviais."
                                  ],
                                  "verification": "Liste 3 exemplos de cada problema com explicações corretas em um documento.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Livro de Compiladores (ex: Aho, Sethi, Ullman Dragon Book)",
                                    "Notas de aula sobre gramáticas formais",
                                    "Editor de texto para anotar exemplos"
                                  ],
                                  "tips": "Use diagramas de árvores de derivação para visualizar ambiguidades.",
                                  "learningObjective": "Dominar definições e exemplos básicos para reconhecimento imediato de problemas.",
                                  "commonMistakes": [
                                    "Confundir ambiguidade com não-determinismo",
                                    "Ignorar recursão indireta",
                                    "Não distinguir shift-reduce de reduce-reduce"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar Problemas em uma Gramática Dada",
                                  "subSteps": [
                                    "Pegue uma gramática exemplo e gere o FIRST e FOLLOW sets.",
                                    "Desenhe árvores de derivação para strings ambíguas e identifique múltiplas parses.",
                                    "Simule o parser LL(1) ou LR(0)/SLR(1): marque estados com conflitos shift-reduce.",
                                    "Verifique recursão esquerda: reescreva produções e detecte ciclos à esquerda.",
                                    "Documente todos os problemas encontrados em uma tabela (problema, localização, impacto)."
                                  ],
                                  "verification": "Crie um relatório com análise completa de uma gramática de 5-10 produções, destacando todos os issues.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Ferramenta online como JFLAP ou papel para autômatos",
                                    "Calculadora FIRST/FOLLOW (script Python simples ou tabela manual)",
                                    "Exemplos de gramáticas de sites como GeeksforGeeks"
                                  ],
                                  "tips": "Comece com gramáticas pequenas para construir confiança antes de complexas.",
                                  "learningObjective": "Desenvolver habilidade de diagnóstico sistemático de gramáticas problemáticas.",
                                  "commonMistakes": [
                                    "Erros em FIRST/FOLLOW devido a ε-produções",
                                    "Não testar strings que revelam ambiguidades",
                                    "Confundir conflitos em itens LR"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Aplicar Técnicas de Resolução de Ambiguidades e Recursão",
                                  "subSteps": [
                                    "Para ambiguidades: priorize operadores com precedência (regras separadas para + e *), ou desambiguação por regras específicas.",
                                    "Elimine recursão esquerda: substitua A → A α | β por A → β A' e A' → α A' | ε.",
                                    "Para recursão indireta: substitua não-terminais e aplique recursão direta.",
                                    "Teste a gramática modificada gerando parses únicos para strings anteriores.",
                                    "Ajuste para LL(1): garanta FIRST sets disjuntos após fatoração."
                                  ],
                                  "verification": "Transforme a gramática original em uma versão resolvida e prove ausência de ambiguidades com exemplos.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Yacc/Bison ou ANTLR para teste rápido",
                                    "Folha de exercícios com gramáticas quebradas",
                                    "Referência: Algoritmo de eliminação de recursão esquerda"
                                  ],
                                  "tips": "Sempre re-compute FIRST/FOLLOW após mudanças para validar.",
                                  "learningObjective": "Executar transformações precisas para eliminar problemas específicos.",
                                  "commonMistakes": [
                                    "Introduzir novas ambiguidades durante refactor",
                                    "Esquecer de propagar mudanças em FOLLOW sets",
                                    "Não tratar recursão mútua"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Resolver Conflitos Shift-Reduce e Validar para Parsing LL/LR",
                                  "subSteps": [
                                    "Construa a tabela de parsing SLR(1) ou LALR(1) e identifique conflitos.",
                                    "Resolva shift-reduce: ajuste precedência/assocatividade ou reescreva regras.",
                                    "Para LL: confirme LL(1) com tabela sem conflitos (predict sets disjuntos).",
                                    "Teste com parser generator: compile e parse strings sem erros.",
                                    "Otimize: minimize não-terminais e produções sem introduzir issues."
                                  ],
                                  "verification": "Gere tabela de parsing sem conflitos e parse 5 strings de teste com sucesso.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Bison/Yacc instalado",
                                    "Exemplos de gramáticas reais (SQL subset, JSON)",
                                    "Debuggers de parser como yydebug"
                                  ],
                                  "tips": "Use %left/%right/%nonassoc em Yacc para precedência fácil.",
                                  "learningObjective": "Garantir gramática parser-friendly com validação prática.",
                                  "commonMistakes": [
                                    "Resolver um conflito criando outro",
                                    "Ignorar dangling else (shift-reduce clássico)",
                                    "Não testar com input ambíguo resolvido"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Verificar e Documentar a Gramática Final",
                                  "subSteps": [
                                    "Execute testes exaustivos: linguagem gerada, ausência de ambiguidades.",
                                    "Compare parse trees antes/depois para consistência semântica.",
                                    "Documente mudanças: diff das gramáticas, razões e impactos.",
                                    "Avalie eficiência: número de estados na tabela LR.",
                                    "Prepare para uso: exporte para ferramenta de parsing."
                                  ],
                                  "verification": "Produza relatório final com gramática limpa, testes passados e métricas.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Parser generator tool",
                                    "Suite de testes (10+ strings)",
                                    "Template de relatório"
                                  ],
                                  "tips": "Automatize testes com scripts para regressão.",
                                  "learningObjective": "Consolidar processo completo com documentação profissional.",
                                  "commonMistakes": [
                                    "Não validar semântica após sintaxe",
                                    "Omitir casos edge como ε ou unit productions",
                                    "Documentação incompleta"
                                  ]
                                }
                              ],
                              "practicalExample": "Gramática ambígua inicial: E → E + E | E * E | id. String 'id + id * id' tem duas parses. Resolução: Introduza E → T E' , E' → + T E' | ε, T → F T', T' → * F T' | ε, F → id. Agora parse único respeita precedência (* > +), sem recursão esquerda, LL(1) compatível.",
                              "finalVerifications": [
                                "Nenhuma string tem múltiplas árvores de derivação (sem ambiguidade).",
                                "Ausência de recursão esquerda direta/indireta em todas produções.",
                                "Tabela de parsing LL(1) ou LR(1) sem conflitos shift/reduce-reduce.",
                                "FIRST e FOLLOW sets corretos e disjuntos onde necessário.",
                                "Parser gerado aceita todas strings de teste sem erros.",
                                "Parse trees consistentes com semântica pretendida (ex: precedência)."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de todos os problemas (100% detectados).",
                                "Corretude das transformações (gramática final válida e equivalente).",
                                "Eficiência da solução (mínimas produções, sem conflitos).",
                                "Qualidade da documentação (clara, com exemplos e justificativas).",
                                "Testes abrangentes (cobertura de casos normais/edge).",
                                "Tempo de execução do parser otimizado (baixo número de estados)."
                              ],
                              "crossCurricularConnections": [
                                "Linguística Computacional: Análise sintática em PLN.",
                                "Teoria dos Grafos: Estados LR como autômatos finitos.",
                                "Matemática Discreta: Conjuntos FIRST/FOLLOW e álgebra booleana.",
                                "Engenharia de Software: Design de DSLs e parsers customizados.",
                                "Inteligência Artificial: Parsing em processamento de linguagem natural."
                              ],
                              "realWorldApplication": "Em compiladores de linguagens como C/Python (usando Bison para gramáticas LR), ferramentas como ANTLR para DSLs em IDEs, ou parsers JSON/XML em navegadores/servers, garantindo parsing eficiente e sem erros em apps reais."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.7.4.2.3",
                            "name": "Gerar analisador sintático com ferramentas automáticas",
                            "description": "Utilizar ferramentas como Bison ou Yacc para processar uma gramática sintática, gerar tabelas de parsing LR(1) ou LALR(1) e integrar com lexer para análise completa.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Configurar o ambiente de desenvolvimento com Bison",
                                  "subSteps": [
                                    "Instale o Bison via gerenciador de pacotes (apt install bison no Linux, brew install bison no macOS).",
                                    "Verifique a instalação executando 'bison --version'.",
                                    "Instale Flex para o lexer (apt install flex) e GCC para compilação.",
                                    "Crie um diretório de projeto e prepare arquivos skeleton: calc.y para gramática e calc.l para lexer.",
                                    "Configure opções básicas no Bison com %define api.pure full para parser reentrante."
                                  ],
                                  "verification": "Executar 'bison --version' e 'flex --version' sem erros, e criar estrutura de arquivos vazios.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Terminal/Linux/macOS",
                                    "Bison, Flex, GCC instalados",
                                    "Editor de texto (VS Code ou Vim)"
                                  ],
                                  "tips": "Use Bison em vez de Yacc puro para suporte a Unicode e opções modernas; teste instalação em ambiente virtual.",
                                  "learningObjective": "Preparar ferramentas automáticas para geração de parsers sintáticos LR(1)/LALR(1).",
                                  "commonMistakes": [
                                    "Esquecer de instalar Flex para integração lexer",
                                    "Usar caminhos absolutos incorretos no Makefile",
                                    "Ignorar dependências como m4 no Windows via Cygwin"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Especificar a gramática sintática em formato Bison",
                                  "subSteps": [
                                    "Defina a seção de declarações com %token para tokens do lexer (ex: NUMBER, PLUS, TIMES).",
                                    "Escreva regras de produção para não-terminais como expr: expr PLUS term | term.",
                                    "Adicione precedências com %left PLUS para resolver ambiguidades.",
                                    "Inclua ações semânticas básicas como { $$ = $1 + $3; } para construir árvore de sintaxe.",
                                    "Valide a gramática com bison -v calc.y para gerar relatório de conflitos."
                                  ],
                                  "verification": "Arquivo .y compila sem erros de sintaxe bison e relatório .output mostra zero conflitos shift-reduce.",
                                  "estimatedTime": "1 hora e 30 minutos",
                                  "materials": [
                                    "Arquivo calc.y",
                                    "Documentação Bison (manual online)",
                                    "Lexer simples de exemplo"
                                  ],
                                  "tips": "Comece com gramática simples e adicione recursão esquerda-indireta gradualmente; use %expect para suprimir conflitos conhecidos.",
                                  "learningObjective": "Definir gramáticas livres de contexto em notação BNF-like para parsing bottom-up.",
                                  "commonMistakes": [
                                    "Esquecer ponto e vírgula após ações",
                                    "Não definir todos os tokens compartilhados com lexer",
                                    "Ignorar associatividade em operadores binários"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Gerar tabelas de parsing e compilar o parser",
                                  "subSteps": [
                                    "Execute 'bison -d -o calc.tab.c calc.y' para gerar calc.tab.c e calc.tab.h.",
                                    "Compile o parser com 'gcc -o calc calc.tab.c calc.lex.c -lfl'.",
                                    "Analise o arquivo calc.output para tabelas LR(1)/LALR(1) e estados de parsing.",
                                    "Adicione directivas %define lr.type LALR para otimização se necessário.",
                                    "Teste compilação standalone com main() que chama yyparse()."
                                  ],
                                  "verification": "Executável 'calc' compila sem warnings e roda sem segment faults em input vazio.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Arquivos gerados: calc.tab.c, calc.tab.h, calc.lex.c",
                                    "GCC compiler",
                                    "Makefile opcional"
                                  ],
                                  "tips": "Use -Wall no GCC para detectar warnings precoces; inspecione .output para entender shifts e reduces.",
                                  "learningObjective": "Compreender geração automática de tabelas de parsing e integração com código C.",
                                  "commonMistakes": [
                                    "Não incluir -lfl para biblioteca Flex",
                                    "Esquecer -d para headers compartilhados",
                                    "Conflitos não resolvidos levando a parser ambiguo"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Integrar parser com lexer e realizar análise completa",
                                  "subSteps": [
                                    "No lexer (calc.l), declare yyparse extern e retorne tokens via yylex().",
                                    "Implemente yylex() para reconhecer números, operadores e retornar IDs de token.",
                                    "Adicione função main() com yyparse() e input de arquivo/terminal via yyin.",
                                    "Teste com inputs válidos/inválidos: '1+2*3' deve parsear sem erros.",
                                    "Implemente ações para imprimir árvore de sintaxe ou AST simples."
                                  ],
                                  "verification": "Executar './calc' com input '1+2*3' produz saída correta da árvore sem erros de parsing.",
                                  "estimatedTime": "1 hora e 15 minutos",
                                  "materials": [
                                    "Flex para lexer",
                                    "Inputs de teste (.input files)",
                                    "Valgrind para memory leaks opcionais"
                                  ],
                                  "tips": "Use extern int yylineno; no lexer para relatar erros com linha; sincronize tokens entre .l e .y.",
                                  "learningObjective": "Integrar gerador de tokens (lexer) com parser para análise sintática front-end completa.",
                                  "commonMistakes": [
                                    "Tokens não matching entre lexer e parser",
                                    "yyin não setado para stdin",
                                    "Stack overflow em recursão infinita sem %left"
                                  ]
                                }
                              ],
                              "practicalExample": "Crie um parser para expressões aritméticas simples (ex: 2+3*4-1). Defina gramática com expr, term, factor; lexer reconhece números e ops. Gere parser que constrói e imprime AST: ((2+(3*4))-1). Teste com input inválido como '2++3' para erro de sintaxe.",
                              "finalVerifications": [
                                "Parser compila e executa sem crashes em inputs variados.",
                                "Relatório .output mostra zero conflitos shift-reduce.",
                                "Análise completa de '1+2*3' gera AST correta respeitando precedência (* > +).",
                                "Lexer e parser sincronizados: tokens corretos passados sem perda.",
                                "Erros de sintaxe reportados com posição aproximada.",
                                "Tabelas LR(1)/LALR(1) geradas e analisáveis no .output."
                              ],
                              "assessmentCriteria": [
                                "Gramática livre de ambiguidades com precedências definidas.",
                                "Integração lexer-parser sem erros de token mismatch.",
                                "Ações semânticas produzem saída verificável (AST ou valor).",
                                "Eficiência: parsing em O(n) para gramáticas determinísticas.",
                                "Tratamento de erros: yyerror() customizado.",
                                "Documentação inline nos arquivos .y e .l."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria de Autômatos e Linguagens Formais (gramáticas tipo 2, pushdown automata).",
                                "Linguística Computacional: Parsing de linguagem natural com ferramentas similares (Stanford Parser).",
                                "Engenharia de Software: Geração automática de código (model-driven development).",
                                "Inteligência Artificial: Parsers em PLN para análise de sentenças."
                              ],
                              "realWorldApplication": "Desenvolvimento de compiladores (GCC usa Bison para C/C++), interpretadores (Python usa ferramentas similares), ferramentas de query (SQL parsers em bancos como PostgreSQL), e análise de configs (parsers em ferramentas DevOps como Ansible)."
                            },
                            "estimatedTime": "2.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.7.4.2.4",
                            "name": "Integrar especificações léxica e sintática",
                            "description": "Combinar especificações léxica e sintática em um fluxo de ferramentas automáticas, definindo interfaces como yylex() e yylval para geração de compiladores modulares.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar e Preparar Especificações Léxica e Sintática Separadas",
                                  "subSteps": [
                                    "Analise o arquivo de especificação léxica (ex: lexer.l) e identifique regras de tokens principais.",
                                    "Revise o arquivo de gramática sintática (ex: parser.y) e regras de produção.",
                                    "Liste todos os tokens declarados na seção de definições do parser.y.",
                                    "Verifique consistência de nomes de tokens entre lexer e parser.",
                                    "Documente valores semânticos associados a tokens (yylval)."
                                  ],
                                  "verification": "Confirme que todos os tokens do lexer correspondem aos esperados no parser.y sem discrepâncias.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Flex/Lex instalado",
                                    "Bison/Yacc instalado",
                                    "Arquivos lexer.l e parser.y de exemplo simples"
                                  ],
                                  "tips": "Use comentários detalhados em ambos os arquivos para mapear tokens.",
                                  "learningObjective": "Entender a independência inicial das especificações antes da integração.",
                                  "commonMistakes": [
                                    "Ignorar case-sensitivity em nomes de tokens",
                                    "Esquecer de declarar tokens no parser.y",
                                    "Não alinhar valores semânticos"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Definir a Interface entre Lexer e Parser (yylex() e yylval)",
                                  "subSteps": [
                                    "Declare a union yylval no parser.y para tipos semânticos de tokens.",
                                    "No lexer.l, implemente yylex() retornando token IDs e populando yylval.",
                                    "Adicione %union no parser.y e associe tipos a tokens com %token.",
                                    "Inclua cabeçalhos necessários como 'y.tab.h' no lexer.",
                                    "Defina ações semânticas no lexer para atribuir valores a yylval (ex: yylval.str = strdup(yytext);)."
                                  ],
                                  "verification": "Compile lexer.l isoladamente e verifique se yylex() é gerado sem erros de símbolo indefinido.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Editor de texto/IDE",
                                    "Documentação Flex/Bison",
                                    "Exemplo de union yylval"
                                  ],
                                  "tips": "Sempre use extern int yylineno; para rastrear linhas em erros.",
                                  "learningObjective": "Dominar a comunicação de dados semânticos via yylval entre lexer e parser.",
                                  "commonMistakes": [
                                    "Não incluir y.tab.h no lexer",
                                    "Mismatch de tipos na union yylval",
                                    "Vazamentos de memória em strdup sem free"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Integrar e Gerar o Fluxo Automático Completo",
                                  "subSteps": [
                                    "Compile o parser.y primeiro: bison -d parser.y para gerar y.tab.h e y.tab.c.",
                                    "Compile o lexer.l: flex lexer.l para gerar lex.yy.c.",
                                    "Crie um main.c que chame yyparse() e inclua y.tab.h.",
                                    "Compile tudo junto: gcc y.tab.c lex.yy.c main.c -o compilador.",
                                    "Execute e forneça input de teste para verificar parsing completo."
                                  ],
                                  "verification": "O executável roda sem erros de linkage e parseia input válido corretamente.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "GCC ou Clang",
                                    "Arquivos integrados lexer.l, parser.y, main.c",
                                    "Inputs de teste"
                                  ],
                                  "tips": "Use -lfl para bibliotecas Flex se necessário no link.",
                                  "learningObjective": "Executar o pipeline completo de geração de compilador modular.",
                                  "commonMistakes": [
                                    "Ordem errada de compilação (parser antes do lexer)",
                                    "Falta de -d no bison",
                                    "Não definir yyparse() extern"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Testar, Depurar e Modularizar a Integração",
                                  "subSteps": [
                                    "Crie casos de teste: inputs válidos, inválidos léxicos e sintáticos.",
                                    "Use yyerror() e fprintf para logs de erros detalhados.",
                                    "Modularize separando em bibliotecas ou arquivos múltiplos.",
                                    "Adicione suporte a múltiplos módulos reutilizando a interface.",
                                    "Meça performance e otimize regras ambíguas com precedência."
                                  ],
                                  "verification": "Todos os testes passam e erros são reportados corretamente com linha/coluna.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Scripts de teste",
                                    "Valgrind para leaks",
                                    "Exemplos de gramáticas maiores"
                                  ],
                                  "tips": "Defina %left/%right para resolver shift-reduce conflicts.",
                                  "learningObjective": "Garantir robustez e escalabilidade na integração para compiladores reais.",
                                  "commonMistakes": [
                                    "Não tratar EOF adequadamente",
                                    "Ignorar warnings de bison",
                                    "Acoplamento excessivo entre módulos"
                                  ]
                                }
                              ],
                              "practicalExample": "Crie um mini-compilador para expressões aritméticas: lexer reconhece números e operadores (+,-,*,/), parser gera árvore sintática via yylval apontando para nós. Input: '2+3*4' → saída: árvore AST correta.",
                              "finalVerifications": [
                                "Lexer e parser compilam e linkam sem erros.",
                                "yylex() popula yylval corretamente para tokens semânticos.",
                                "Parser aceita gramáticas LL(1)/LR(1) sem conflicts.",
                                "Erros léxicos/sintáticos são reportados com posição exata.",
                                "Integração suporta extensão modular (novos tokens sem quebrar parser)."
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição de interface (yylex/yylval): 25%",
                                "Sucesso na compilação e execução do fluxo integrado: 30%",
                                "Qualidade de testes e depuração: 20%",
                                "Modularidade e extensibilidade demonstrada: 15%",
                                "Documentação de erros comuns evitados: 10%"
                              ],
                              "crossCurricularConnections": [
                                "Engenharia de Software: Design de interfaces modulares.",
                                "Linguagens de Programação: Gerenciamento de unions e ponteiros.",
                                "Matemática Discreta: Autômatos finitos e gramáticas formais.",
                                "Análise de Sistemas: Otimização de parsers para performance."
                              ],
                              "realWorldApplication": "Usado em compiladores como GCC (com Flex/Bison), ferramentas como ANTLR para linguagens reais (Java, Python), e análise de código em IDEs para autocompletar e detecção de erros."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.7.5",
                    "name": "Vantagens e Aplicações de Ferramentas Automáticas",
                    "description": "Benefícios como redução de erros, portabilidade e aceleração no desenvolvimento de compiladores personalizados.",
                    "individualConcepts": [
                      {
                        "id": "10.1.7.5.1",
                        "name": "Redução de Erros com Ferramentas Automáticas",
                        "description": "Exploração dos benefícios das ferramentas automáticas na minimização de erros humanos durante a construção de compiladores, garantindo analisadores léxicos e sintáticos mais confiáveis.",
                        "specificSkills": [
                          {
                            "id": "10.1.7.5.1.1",
                            "name": "Identificar erros comuns evitados por geradores automáticos",
                            "description": "Reconhecer falhas típicas em implementações manuais de analisadores léxicos e sintáticos, como ambiguidades em expressões regulares ou conflitos em gramáticas, e como ferramentas como LEX e YACC as eliminam automaticamente.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Identificar erros comuns em analisadores léxicos manuais",
                                  "subSteps": [
                                    "Estude o conceito de analisador léxico (lexer) manual: função de tokenizar código-fonte em tokens.",
                                    "Analise ambiguidades em expressões regulares manuais, como sobreposição de padrões (ex: 'if' vs 'iff').",
                                    "Examine erros de priorização de tokens, como ignorar espaços ou falhar em longest match.",
                                    "Revise exemplos de código manual propenso a bugs, como loops infinitos em matching falho.",
                                    "Liste 5 erros típicos: ambiguidades, falta de handling de whitespace, erros de estado."
                                  ],
                                  "verification": "Crie uma tabela comparando 3 exemplos de regex manuais com seus erros identificados.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Documentação de regex básicas, exemplos de código C/Python para lexers manuais.",
                                  "tips": "Use ferramentas como regex101.com para testar padrões manualmente antes de codificar.",
                                  "learningObjective": "Reconhecer falhas específicas em implementações manuais de lexers.",
                                  "commonMistakes": "Confundir lexer com parser; ignorar casos edge como comentários aninhados."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar erros comuns em analisadores sintáticos manuais",
                                  "subSteps": [
                                    "Entenda parsers manuais recursivos descendentes e erros como left-recursion em gramáticas.",
                                    "Analise conflitos shift-reduce ou reduce-reduce em parsers bottom-up manuais.",
                                    "Estude ambiguidades gramaticais, como dangling else ou expressões aritméticas sem precedência.",
                                    "Examine falhas em handling de erros de sintaxe, como recovery inadequado.",
                                    "Compile uma lista de 5 conflitos comuns em gramáticas LL(1) ou LR(1) manuais."
                                  ],
                                  "verification": "Desenhe um diagrama de parsing tree para uma gramática ambígua e destaque o conflito.",
                                  "estimatedTime": "50 minutos",
                                  "materials": "Livros como 'Compilers: Principles, Techniques, and Tools' (Dragon Book), papel e lápis para árvores.",
                                  "tips": "Comece com gramáticas simples como expressões aritméticas para visualizar ambiguidades.",
                                  "learningObjective": "Diagnosticar problemas inerentes a parsers implementados à mão.",
                                  "commonMistakes": "Assumir gramáticas livres de ambiguidades sem teste; negligenciar associatividade."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explorar como LEX elimina erros léxicos automaticamente",
                                  "subSteps": [
                                    "Instale e configure LEX (Flex) e gere um lexer simples de um arquivo .l.",
                                    "Estude regras LEX: longest match automático, priorização por ordem, handling de whitespace.",
                                    "Compare output de LEX vs manual: observe resolução de ambiguidades sem código extra.",
                                    "Teste casos edge: identifique como LEX gerencia estados e rejeita inválidos automaticamente.",
                                    "Gere tokens para uma mini-linguagem e verifique ausência de bugs manuais comuns."
                                  ],
                                  "verification": "Execute um lexer LEX gerado e liste 3 ambiguidades manuais que foram resolvidas.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Flex/LEX instalado, exemplos de arquivos .l, terminal para compilar com gcc.",
                                  "tips": "Use %option yylineno para tracking de linhas, facilitando debug.",
                                  "learningObjective": "Compreender mecanismos automáticos de LEX para robustez léxica.",
                                  "commonMistakes": "Esquecer de definir yylex(); não linkar com main corretamente."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Explorar como YACC elimina erros sintáticos automaticamente",
                                  "subSteps": [
                                    "Instale YACC (Bison) e crie um parser simples de um arquivo .y.",
                                    "Analise gramáticas YACC: resolução automática de shift-reduce via precedência e associatividade.",
                                    "Estude conflitos reportados e como %left/%right os resolvem sem reescrita manual.",
                                    "Compare parser YACC vs manual: observe error recovery e tabelas LR geradas.",
                                    "Implemente uma gramática com dangling else e veja resolução automática."
                                  ],
                                  "verification": "Gere parser YACC sem warnings de conflitos e parse uma entrada ambígua com sucesso.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Bison/YACC instalado, exemplos de gramáticas .y, compilador C.",
                                  "tips": "Use %expect 1 para suprimir warnings conhecidos; teste com yyerror para recovery.",
                                  "learningObjective": "Dominar vantagens de YACC em gerar parsers livres de conflitos comuns.",
                                  "commonMistakes": "Definir precedências incorretas; ignorar relatório de conflitos no output."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Comparar implementações manuais vs automáticas e sintetizar vantagens",
                                  "subSteps": [
                                    "Implemente um lexer+parser manual simples e introduza deliberadamente erros comuns.",
                                    "Gere equivalente com LEX/YACC e compare tempo, bugs e robustez.",
                                    "Documente métricas: linhas de código, casos de teste passados, tempo de desenvolvimento.",
                                    "Identifique padrões: como automação reduz ambiguidades e conflitos em 80-90%.",
                                    "Crie um relatório resumindo 5 erros evitados especificamente por ferramentas."
                                  ],
                                  "verification": "Produza um relatório de 1 página com tabelas comparativas e evidências.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Código das steps anteriores, editor de texto para relatório.",
                                  "tips": "Use diff tools para destacar diferenças no código gerado vs manual.",
                                  "learningObjective": "Sintetizar como geradores automáticos superam limitações humanas.",
                                  "commonMistakes": "Focar só em sucesso, ignorar performance ou escalabilidade."
                                }
                              ],
                              "practicalExample": "Implemente manualmente um lexer para identificar tokens em 'if (x > 0) { print(x); }', falhando em longest match para 'if' vs 'iff'. Gere o mesmo com LEX, que automaticamente prioriza 'iff' e tokeniza corretamente sem ambiguidades.",
                              "finalVerifications": [
                                "Liste 5 erros léxicos manuais e explique como LEX os evita.",
                                "Descreva 3 conflitos sintáticos e demonstre resolução YACC.",
                                "Gere e execute um lexer/parser LEX/YACC sem warnings.",
                                "Compare código manual (50+ linhas) vs gerado (10 regras).",
                                "Parse uma entrada inválida e verifique recovery automático.",
                                "Explique dangling else e sua resolução automática."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de pelo menos 8 erros comuns (manual vs auto).",
                                "Correta geração e execução de LEX/YACC sem erros de compilação.",
                                "Relatório comparativo claro com evidências empíricas.",
                                "Demonstração de compreensão de mecanismos internos (longest match, precedência).",
                                "Uso correto de terminologia (shift-reduce, LR(1), etc.).",
                                "Criatividade em exemplos práticos e conexões reais."
                              ],
                              "crossCurricularConnections": [
                                "Engenharia de Software: Melhores práticas em geração de código automatizado.",
                                "Linguística Computacional: Análise de gramáticas formais e ambiguidades naturais.",
                                "Matemática Discreta: Teoria de autômatos finitos e linguagens regulares.",
                                "Desenvolvimento de Software: Integração em pipelines CI/CD para compiladores."
                              ],
                              "realWorldApplication": "Em empresas como Google ou Microsoft, ferramentas como LEX/YACC (ou sucessores como ANTLR) são usadas para desenvolver parsers de linguagens como C++, JavaScript e SQL, reduzindo bugs em compiladores e interpretadores, economizando meses de desenvolvimento manual e garantindo robustez em produção."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.7.5.1.2",
                            "name": "Avaliar a correção gerada por ferramentas automáticas",
                            "description": "Analisar como as ferramentas automáticas produzem código otimizado e livre de bugs para fases de análise léxica e sintática, comparando com implementações manuais baseadas em metodologias top-down e bottom-up.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o funcionamento das ferramentas automáticas para análise léxica e sintática",
                                  "subSteps": [
                                    "Estudar a documentação do Flex (lexer) e Bison (parser), focando em análise léxica e sintática.",
                                    "Identificar como as ferramentas geram código otimizado a partir de especificações regulares e gramáticas livres de contexto.",
                                    "Revisar metodologias top-down (LL) e bottom-up (LR) e como as ferramentas as implementam automaticamente.",
                                    "Analisar exemplos de entrada para as ferramentas e o código C gerado.",
                                    "Comparar superficialmente com implementações manuais para notar otimizações iniciais."
                                  ],
                                  "verification": "Resumir em um documento as diferenças chave entre Flex/Bison e implementações manuais, com pelo menos 5 pontos.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Documentação oficial Flex/Bison, exemplos de gramáticas simples, editor de texto.",
                                  "tips": "Comece com tutoriais interativos online para visualização de autômatos gerados.",
                                  "learningObjective": "Entender como ferramentas automáticas traduzem especificações em analisadores eficientes e corretos.",
                                  "commonMistakes": "Confundir análise léxica com sintática; ignorar suporte a LL vs LR nas ferramentas."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Gerar e testar analisadores automáticos",
                                  "subSteps": [
                                    "Definir regras regulares para lexer em um arquivo .l (Flex) para uma mini-linguagem.",
                                    "Especificar gramática em arquivo .y (Bison) para parser bottom-up ou top-down.",
                                    "Compilar os arquivos gerados (flex arquivo.l; bison arquivo.y; gcc lexer.c parser.c).",
                                    "Testar com casos de entrada variados, incluindo válidos, inválidos e ambíguos.",
                                    "Depurar erros de compilação ou runtime usando logs de saída das ferramentas."
                                  ],
                                  "verification": "Executar testes com 10 casos e registrar taxa de acerto (deve ser 100% para casos simples).",
                                  "estimatedTime": "1 hora",
                                  "materials": "Flex, Bison instalados, compilador GCC, conjunto de testes para gramática simples.",
                                  "tips": "Use flags como -d no Bison para debug de estados e conflitos.",
                                  "learningObjective": "Produzir analisadores funcionais livres de bugs comuns via automação.",
                                  "commonMistakes": "Esquecer de tratar EOF ou caracteres especiais nas regras léxicas."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar analisadores manuais para comparação",
                                  "subSteps": [
                                    "Codificar lexer manual recursivo-descente (top-down) em C para a mesma mini-linguagem.",
                                    "Implementar parser manual bottom-up (shift-reduce) ou top-down preditivo.",
                                    "Adicionar otimizações manuais, como tabelas de transição, e testar com os mesmos casos.",
                                    "Medir tempo de execução e tamanho do código gerado manualmente vs automático.",
                                    "Documentar bugs encontrados na implementação manual e tempo gasto."
                                  ],
                                  "verification": "Compilar e testar manuais com os mesmos 10 casos, comparando saídas com automáticos.",
                                  "estimatedTime": "1 hora e 30 minutos",
                                  "materials": "Editor de código (VS Code), GCC, mesma gramática de testes.",
                                  "tips": "Reutilize código boilerplate para I/O para focar na lógica de análise.",
                                  "learningObjective": "Identificar complexidades e erros propensos em implementações manuais.",
                                  "commonMistakes": "Não tratar precedência em parsers top-down; loops infinitos em recursão."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Comparar correção, otimização e avaliar vantagens",
                                  "subSteps": [
                                    "Executar testes extensivos (100+ casos) em ambas versões e registrar falhas.",
                                    "Analisar código gerado: contar linhas, complexidade ciclomática e otimizações (ex: tabelas DFA).",
                                    "Comparar tempo de análise e uso de memória entre auto e manual.",
                                    "Identificar cenários onde ferramentas reduzem erros (ex: conflitos LR detectados automaticamente).",
                                    "Concluir relatório com métricas quantitativas e qualitativas de correção."
                                  ],
                                  "verification": "Produzir relatório de 1 página com tabelas comparativas e conclusões sobre superioridade automática.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Ferramentas de profiling (time, valgrind), planilha para métricas.",
                                  "tips": "Use diff para comparar saídas de testes entre versões.",
                                  "learningObjective": "Avaliar quantitativamente como ferramentas minimizam bugs e otimizam.",
                                  "commonMistakes": "Ignorar overhead de inicialização nas ferramentas; superestimar simplicidade manual."
                                }
                              ],
                              "practicalExample": "Para uma mini-linguagem de expressões aritméticas (ex: '2+3*4'), use Flex para lexer que tokeniza números/operações, Bison para parser LR(1) que constrói AST. Compare com lexer manual em switch-case e parser recursivo-descente, testando precedência e erros como '2++3'. Ferramentas geram código sem ambiguidades detectadas automaticamente.",
                              "finalVerifications": [
                                "Analisador automático compila sem warnings e passa todos testes.",
                                "Implementação manual tem pelo menos 2 bugs identificados que ferramenta evitou.",
                                "Relatório compara corretude com métricas (ex: 0% falhas auto vs 20% manual).",
                                "Explicação clara de como ferramentas otimizam tabelas de transição.",
                                "Identificação de 3 vantagens em correção para análises léxica/sintática.",
                                "Testes com gramáticas ambíguas resolvidas automaticamente."
                              ],
                              "assessmentCriteria": [
                                "Precisão na detecção de erros em ambas implementações (90%+ cobertura de testes).",
                                "Análise quantitativa de otimização (tempo/memória < manual em 50%).",
                                "Relatório estruturado com comparações claras e evidências.",
                                "Compreensão demonstrada de top-down vs bottom-up via exemplos.",
                                "Identificação de erros comuns manuais evitados por ferramentas.",
                                "Aplicação correta de flags/debug das ferramentas."
                              ],
                              "crossCurricularConnections": [
                                "Teoria da Computação: Autômatos finitos e gramáticas formais.",
                                "Engenharia de Software: Geração automática de código e testes unitários.",
                                "Matemática: Teoria de grafos em tabelas de parsing.",
                                "Análise de Algoritmos: Complexidade de O(n) em analisadores lineares."
                              ],
                              "realWorldApplication": "Em compiladores como GCC/Clang, ferramentas como Flex/Bison reduzem erros em lexers/parsers de linguagens reais (C++, Java), acelerando desenvolvimento e garantindo robustez em IDEs e ferramentas de linting."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.7.5.1.3",
                            "name": "Aplicar tratamento de erros automatizado",
                            "description": "Demonstrar o uso de ferramentas para incorporar mecanismos robustos de detecção e recuperação de erros sintáticos e semânticos, reduzindo falhas em compiladores personalizados.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Identificar e classificar erros sintáticos e semânticos em compiladores",
                                  "subSteps": [
                                    "Analise a gramática da linguagem alvo para mapear erros sintáticos comuns, como tokens inválidos ou estruturas malformadas.",
                                    "Estude erros semânticos, incluindo tipos incompatíveis e escopo indefinido, usando exemplos de código fonte com falhas.",
                                    "Crie um catálogo de erros esperados com mensagens descritivas e códigos de erro padronizados.",
                                    "Revise literatura sobre estratégias de recuperação em ferramentas como ANTLR ou Bison.",
                                    "Documente padrões de erro observados em testes iniciais de parsing."
                                  ],
                                  "verification": "Catálogo completo de erros com pelo menos 10 exemplos sintáticos e 10 semânticos, validado por revisão manual.",
                                  "estimatedTime": "4 horas",
                                  "materials": [
                                    "Documentação de ANTLR/Bison",
                                    "Editor de código (VS Code)",
                                    "Exemplos de gramáticas defeituosas"
                                  ],
                                  "tips": "Priorize erros frequentes em linguagens reais como C ou Python para relevância.",
                                  "learningObjective": "Compreender a natureza e impacto de erros em compiladores personalizados.",
                                  "commonMistakes": [
                                    "Confundir erros sintáticos com semânticos",
                                    "Ignorar recuperação em vez de apenas detecção"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Configurar ferramenta automática para detecção de erros",
                                  "subSteps": [
                                    "Instale e configure uma ferramenta como ANTLR4 com error listeners personalizados.",
                                    "Defina regras de gramática com ações de erro (ex: @header para listeners).",
                                    "Implemente detecção automática de erros sintáticos via BaseErrorListener.",
                                    "Adicione suporte para erros semânticos usando walkers ou visitors personalizados.",
                                    "Teste detecção com inputs malformados e verifique logs de erros gerados."
                                  ],
                                  "verification": "Ferramenta gera logs precisos para 100% dos erros do catálogo sem falhas no parsing básico.",
                                  "estimatedTime": "6 horas",
                                  "materials": [
                                    "ANTLR4 JAR",
                                    "Java/Python runtime",
                                    "Gramática base do compilador personalizado"
                                  ],
                                  "tips": "Use o modo 'recoverFromMismatchedToken' no ANTLR para detecção não-intrusiva.",
                                  "learningObjective": "Dominar configuração de ferramentas para detecção automatizada de erros.",
                                  "commonMistakes": [
                                    "Configurar listeners incorretamente levando a stack overflows",
                                    "Não diferenciar níveis de erro (warning vs error)"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar mecanismos de recuperação automatizados",
                                  "subSteps": [
                                    "Desenvolva estratégias de recuperação sintática, como sincronização por token de lookahead.",
                                    "Crie handlers para recuperação semântica, inserindo valores default ou propondo correções.",
                                    "Integre recuperação em fases múltiplas do compilador (lexer, parser, semantic analyzer).",
                                    "Adicione relatórios de erro amigáveis com sugestões de correção (ex: 'Esperado ; após declaração').",
                                    "Otimize para performance, evitando loops infinitos em recuperação."
                                  ],
                                  "verification": "Compilador continua processamento após erro, compilando código válido restante com >80% de sucesso.",
                                  "estimatedTime": "8 horas",
                                  "materials": [
                                    "Código fonte do compilador personalizado",
                                    "Ferramentas de profiling (JProfiler)",
                                    "Testes unitários com erro injection"
                                  ],
                                  "tips": "Use árvores de parsing parciais para preservar contexto durante recuperação.",
                                  "learningObjective": "Aplicar técnicas robustas de recuperação para minimizar falhas totais.",
                                  "commonMistakes": [
                                    "Recuperação agressiva que mascara erros reais",
                                    "Ignorar impacto na performance"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Testar, integrar e validar redução de falhas",
                                  "subSteps": [
                                    "Crie suíte de testes com 50+ casos de erro variados e meça taxa de crash antes/depois.",
                                    "Integre o tratamento no pipeline completo do meta-compilador.",
                                    "Meça métricas: tempo de compilação, taxa de recuperação, precisão de diagnósticos.",
                                    "Realize testes de estresse com inputs massivos e malformados.",
                                    "Refatore baseado em feedback e documente o módulo de erros."
                                  ],
                                  "verification": "Redução de falhas >70% em benchmarks, com relatórios gerados corretamente.",
                                  "estimatedTime": "5 horas",
                                  "materials": [
                                    "Framework de testes (JUnit/Pytest)",
                                    "Benchmark scripts",
                                    "Logs de compilação"
                                  ],
                                  "tips": "Automatize testes com scripts de fuzzing para cobertura ampla.",
                                  "learningObjective": "Avaliar efetividade do tratamento automatizado em cenários reais.",
                                  "commonMistakes": [
                                    "Testes insuficientes em bordas",
                                    "Não medir impacto na usabilidade"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um compilador personalizado para uma mini-linguagem aritmética, use ANTLR para detectar 'x = 1 +;' (erro sintático) recuperando com skip até ';' e sugerindo inserção, e 'int a = \"string\";' (semântico) reportando mismatch de tipo com default para string vazia, permitindo compilação parcial.",
                              "finalVerifications": [
                                "Compilador não crasha em 95% dos casos com erros injetados.",
                                "Mensagens de erro incluem linha, coluna e sugestão de correção.",
                                "Recuperação preserva >80% do código válido.",
                                "Tempo de compilação aumenta <20% com tratamento ativado.",
                                "Logs distinguem sintático/semântico com códigos únicos.",
                                "Testes de regressão passam integralmente."
                              ],
                              "assessmentCriteria": [
                                "Cobertura de detecção: 90%+ dos erros catalogados.",
                                "Taxa de recuperação bem-sucedida: 85%+ sem perda de contexto.",
                                "Qualidade de diagnósticos: Mensagens claras e acionáveis (nota 4/5).",
                                "Performance: Overhead <15% em benchmarks.",
                                "Robustez: Zero crashes em 100 testes fuzzados.",
                                "Documentação: Guia completo de uso e customização."
                              ],
                              "crossCurricularConnections": [
                                "Engenharia de Software: Práticas de resiliência e fault-tolerance.",
                                "Matemática: Teoria de autômatos e linguagens formais para parsing.",
                                "Design de UX: Interfaces de erro intuitivas em IDEs.",
                                "Segurança da Informação: Prevenção de exploits via input malicioso."
                              ],
                              "realWorldApplication": "Em compiladores como GCC/Clang ou transpilers como Babel, tratamento automatizado permite diagnósticos precisos em IDEs (VS Code, IntelliJ), reduzindo tempo de debug em projetos grandes e melhorando experiência do desenvolvedor em cenários de produção."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.7.5.2",
                        "name": "Portabilidade das Ferramentas Automáticas",
                        "description": "Benefícios da independência de plataforma e linguagem nas ferramentas automáticas, facilitando a adaptação de compiladores para diferentes ambientes de execução.",
                        "specificSkills": [
                          {
                            "id": "10.1.7.5.2.1",
                            "name": "Explicar portabilidade em analisadores gerados",
                            "description": "Descrever como ferramentas como LEX e YACC geram código portável para múltiplas linguagens de programação e arquiteturas, independentemente de detalhes de implementação manual.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender Conceitos Fundamentais de Portabilidade em Analisadores",
                                  "subSteps": [
                                    "Defina portabilidade como a capacidade de código ser executado em diferentes plataformas sem modificações significativas.",
                                    "Explique a diferença entre portabilidade de código fonte e binário no contexto de analisadores léxicos e sintáticos.",
                                    "Identifique desafios de implementação manual, como dependências de APIs específicas de SO ou arquiteturas.",
                                    "Discuta por que ferramentas automáticas como LEX e YACC resolvem isso gerando código em linguagens padrão como C.",
                                    "Revise exemplos históricos de analisadores não-portáveis vs. portáveis."
                                  ],
                                  "verification": "Escreva um parágrafo resumindo portabilidade e liste 3 desafios manuais resolvidos por LEX/YACC.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Documentação oficial do FLEX (LEX moderno): https://github.com/westes/flex",
                                    "Capítulo sobre portabilidade em 'Compilers: Principles, Techniques, and Tools' (Dragon Book)"
                                  ],
                                  "tips": "Use analogias como 'blocos de Lego' para código portável que se encaixa em qualquer arquitetura.",
                                  "learningObjective": "Compreender o conceito de portabilidade e suas implicações em analisadores gerados automaticamente.",
                                  "commonMistakes": "Confundir portabilidade com performance; focar apenas em linguagens de programação, ignorando arquiteturas."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Explorar o Funcionamento de LEX e YACC",
                                  "subSteps": [
                                    "Instale FLEX (LEX) e BISON (YACC) em sua máquina local.",
                                    "Escreva um exemplo simples de especificação LEX para um lexer que reconhece tokens numéricos.",
                                    "Compile e execute o lexer gerado em C, observando o código fonte produzido.",
                                    "Repita com YACC para um parser simples, analisando o .c gerado.",
                                    "Compare o código gerado com uma implementação manual equivalente."
                                  ],
                                  "verification": "Gere e compile um lexer LEX simples; confirme que roda sem erros em pelo menos duas plataformas (ex: Linux/Windows via WSL).",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "FLEX manual: https://westes.github.io/flex/manual/",
                                    "BISON manual: https://www.gnu.org/software/bison/manual/",
                                    "Ambiente de desenvolvimento com GCC/Clang"
                                  ],
                                  "tips": "Use opções como 'flex -l' para código mais legível e debugue com 'yydebug' em YACC.",
                                  "learningObjective": "Dominar o processo de geração de código por LEX/YACC e inspecionar sua estrutura portável.",
                                  "commonMistakes": "Ignorar flags de portabilidade como '-p' no FLEX; não testar em múltiplas plataformas."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar Mecanismos de Portabilidade no Código Gerado",
                                  "subSteps": [
                                    "Examine o código C gerado: identifique uso de stdio.h, stdlib.h e abstrações como yyinput() em vez de fread direto.",
                                    "Explique como LEX/YACC evitam dependências de hardware usando tabelas de transição FSM portáveis.",
                                    "Discuta suporte multiplataforma via pré-processador (#ifdef) para variações mínimas.",
                                    "Compare com código manual que usa ponteiros de máquina ou chamadas de SO específicas.",
                                    "Teste o analisador gerado em emuladores ou VMs de diferentes arquiteturas (ex: x86 vs ARM)."
                                  ],
                                  "verification": "Anote 5 mecanismos específicos de portabilidade no código gerado e demonstre compilação cruzada com 'make' em targets diferentes.",
                                  "estimatedTime": "75 minutos",
                                  "materials": [
                                    "Exemplos de código LEX/YACC portáveis: https://epaperpress.com/lexandyacc/",
                                    "Docker para testes multiplataforma: imagem ubuntu e alpine"
                                  ],
                                  "tips": "Use 'objdump' ou 'nm' para inspecionar binários gerados e confirmar ausência de símbolos não-portáveis.",
                                  "learningObjective": "Identificar e explicar técnicas específicas que garantem portabilidade no código gerado.",
                                  "commonMistakes": "Atribuir portabilidade apenas ao C, ignorando otimizações FSM e abstrações de I/O."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar e Verificar Portabilidade em Cenários Reais",
                                  "subSteps": [
                                    "Adapte o exemplo LEX/YACC para uma mini-linguagem (ex: calculadora simples).",
                                    "Compile e execute em 3 plataformas diferentes (Linux, Windows, macOS).",
                                    "Meça tempo de build e tamanho do binário, comparando com manual.",
                                    "Documente qualquer ajuste mínimo necessário e explique por quê.",
                                    "Crie um relatório resumindo vantagens de portabilidade."
                                  ],
                                  "verification": "Execute testes unitários idênticos nas plataformas; todos passam sem mudanças no código fonte.",
                                  "estimatedTime": "90 minutos",
                                  "materials": [
                                    "GitHub repo com exemplos portáveis: clone e modifique",
                                    "Cross-compilers como mingw para Windows em Linux"
                                  ],
                                  "tips": "Automatize testes com Makefile que suporte múltiplos targets para eficiência.",
                                  "learningObjective": "Demonstrar portabilidade prática e sintetizar conhecimentos em uma explicação coesa.",
                                  "commonMistakes": "Testar apenas em plataformas similares; superestimar portabilidade sem verificação binária."
                                }
                              ],
                              "practicalExample": "Crie um lexer LEX para tokens de uma linguagem SQL simples (SELECT, FROM, WHERE). Gere o código C, compile em Linux (GCC) e Windows (MinGW), execute com input SQL idêntico e confirme saída de tokens igual em ambas, sem alterar o .l source.",
                              "finalVerifications": [
                                "Explica corretamente 3 mecanismos de portabilidade (ex: FSM tabelas, I/O abstrato, C ANSI).",
                                "Demonstra compilação e execução bem-sucedida em 2+ plataformas diferentes.",
                                "Lista 2 vantagens sobre implementação manual com exemplos concretos.",
                                "Identifica cenários onde portabilidade falha e soluções (ex: endianness).",
                                "Resume o processo em diagrama ou fluxograma claro.",
                                "Responde perguntas sobre LEX/YACC vs. ANTLR em portabilidade."
                              ],
                              "assessmentCriteria": [
                                "Precisão técnica: Conceitos corretos sem erros factuais (30%).",
                                "Profundidade: Detalhes sobre código gerado e mecanismos (25%).",
                                "Prática: Evidências de testes multiplataforma (20%).",
                                "Clareza: Explicação estruturada e acessível (15%).",
                                "Originalidade: Exemplos personalizados, não copiados (10%)."
                              ],
                              "crossCurricularConnections": [
                                "Engenharia de Software: Abstração e geração de código reutilizável.",
                                "Sistemas Operacionais: Independência de APIs de baixo nível.",
                                "Programação: Uso de linguagens intermediárias portáveis como C.",
                                "Matemática: Teoria de autômatos finitos (FSM) em LEX."
                              ],
                              "realWorldApplication": "Compiladores como GCC e Clang usam YACC/BISON para parsers portáveis, permitindo builds em qualquer arquitetura (x86, ARM, RISC-V) sem reescrita, acelerando desenvolvimento de linguagens como Rust e Go em ecossistemas heterogêneos como cloud computing."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.7.5.2.2",
                            "name": "Adaptar ferramentas para novas plataformas",
                            "description": "Demonstrar a modificação mínima de especificações para portar compiladores personalizados para diferentes sistemas operacionais ou máquinas, usando tabelas de símbolos organizadas automaticamente.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Analisar a Plataforma Alvo e Identificar Diferenças",
                                  "subSteps": [
                                    "Estude a documentação do sistema operacional ou máquina alvo (ex: arquitetura, chamadas de sistema, convenções de ABI).",
                                    "Compare com a plataforma atual usando ferramentas como diff em especificações de hardware/software.",
                                    "Liste diferenças críticas: endianness, tamanho de ponteiros, bibliotecas nativas.",
                                    "Crie um mapa de mapeamento de recursos (ex: syscalls Linux vs Windows).",
                                    "Priorize impactos em compiladores: gerenciador de memória, I/O, símbolos."
                                  ],
                                  "verification": "Mapa de diferenças documentado e validado contra specs oficiais das plataformas.",
                                  "estimatedTime": "4-6 horas",
                                  "materials": "Documentação oficial (man pages, MSDN), ferramentas de análise (objdump, readelf), editor de texto.",
                                  "tips": "Use diagramas UML para visualizar diferenças arquiteturais.",
                                  "learningObjective": "Compreender variações entre plataformas para minimizar mudanças.",
                                  "commonMistakes": "Ignorar diferenças sutis como alinhamento de dados ou convenções de chamada."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Modificar Minimamente as Especificações do Compilador",
                                  "subSteps": [
                                    "Identifique seções parametrizáveis nas specs (ex: configurações condicionais baseadas em OS).",
                                    "Ajuste apenas macros ou flags específicas (ex: #ifdef TARGET_OS).",
                                    "Atualize geradores de código para suportar novas instruções ou registradores.",
                                    "Mantenha 90%+ do código inalterado, focando em abstrações.",
                                    "Compile specs modificadas e verifique sintaxe."
                                  ],
                                  "verification": "Especificações compilam sem erros e geram código para a nova plataforma.",
                                  "estimatedTime": "6-8 horas",
                                  "materials": "Código fonte do meta-compilador, compilador nativo da plataforma atual, debugger.",
                                  "tips": "Use version control (Git) para branchar mudanças mínimas e comparar diffs.",
                                  "learningObjective": "Aplicar princípios de portabilidade com edições cirúrgicas.",
                                  "commonMistakes": "Sobre-generalizar mudanças, quebrando compatibilidade com plataformas originais."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Atualizar Tabelas de Símbolos Organizadas Automaticamente",
                                  "subSteps": [
                                    "Gere tabelas de símbolos via scripts automáticos para a nova plataforma.",
                                    "Mapeie símbolos existentes para equivalentes (ex: pthread para WinThreads).",
                                    "Integre tabelas no meta-compilador usando loaders dinâmicos.",
                                    "Teste resolução de símbolos em runtime com ferramentas como nm ou ldd.",
                                    "Automatize geração com Makefiles parametrizados."
                                  ],
                                  "verification": "Tabelas carregam corretamente e resolvem 100% dos símbolos necessários.",
                                  "estimatedTime": "5-7 horas",
                                  "materials": "Scripts de geração de tabelas, ferramentas de símbolos (nm, objdump), ambiente de build cross-compile.",
                                  "tips": "Priorize tabelas lazy-loaded para eficiência em portabilidade.",
                                  "learningObjective": "Dominar automação de gerenciamento de símbolos cross-platform.",
                                  "commonMistakes": "Esquecer símbolos de bibliotecas dinâmicas, causando link-time errors."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Testar e Verificar Portabilidade Completa",
                                  "subSteps": [
                                    "Compile um programa de teste simples na nova plataforma.",
                                    "Execute testes unitários cobrindo parsing, otimização e codegen.",
                                    "Meça performance e compare com baseline original.",
                                    "Corrija issues iterativamente, mantendo mudanças mínimas.",
                                    "Gere relatório de cobertura de portabilidade."
                                  ],
                                  "verification": "Programa de teste compila, executa e produz saída idêntica em ambas plataformas.",
                                  "estimatedTime": "8-10 horas",
                                  "materials": "Suite de testes, VM ou container da nova plataforma (Docker), profiler.",
                                  "tips": "Use cross-compilation para acelerar iterações sem trocar de máquina.",
                                  "learningObjective": "Validar portabilidade end-to-end com métricas quantitativas.",
                                  "commonMistakes": "Testar apenas casos felizes, ignorando edge cases como overflow ou interrupções."
                                }
                              ],
                              "practicalExample": "Portar um compilador custom de uma mini-linguagem (ex: subset de C) de Linux x86_64 para Windows x64: ajustar specs para WinAPI syscalls, mapear pthread para Windows threads nas tabelas de símbolos, e testar compilando um 'Hello World' que roda em ambos.",
                              "finalVerifications": [
                                "Compilador gera executáveis nativos na nova plataforma sem erros de link.",
                                "Tabelas de símbolos resolvem todos os símbolos cross-platform automaticamente.",
                                "Testes de regressão passam em 100% nas duas plataformas.",
                                "Modificações totais <10% do código fonte original.",
                                "Performance dentro de 5% da baseline original.",
                                "Documentação de portabilidade atualizada."
                              ],
                              "assessmentCriteria": [
                                "Grau de minimalismo nas modificações (medido por linhas alteradas).",
                                "Precisão e completude das tabelas de símbolos geradas.",
                                "Robustez dos testes end-to-end em cenários reais.",
                                "Eficiência da automação no processo de portagem.",
                                "Qualidade da documentação e reprodutibilidade.",
                                "Manutenibilidade do código pós-portagem."
                              ],
                              "crossCurricularConnections": [
                                "Engenharia de Software: Princípios de design modular e refatoração.",
                                "Sistemas Operacionais: Compreensão de ABIs e chamadas de sistema.",
                                "Programação de Sistemas: Gerenciamento de memória e linking dinâmico.",
                                "Desenvolvimento de Software: Ferramentas de build e CI/CD cross-platform."
                              ],
                              "realWorldApplication": "Em projetos como LLVM/Clang ou GCC, onde portar compiladores para novas arquiteturas (ex: ARM para IoT) permite desenvolvimento cross-platform em empresas como Google ou Microsoft, reduzindo custos de manutenção em 70% via especificações parametrizáveis."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.7.5.3",
                        "name": "Aceleração no Desenvolvimento e Aplicações Práticas",
                        "description": "Vantagens na rapidez de prototipagem e aplicações reais de ferramentas automáticas na construção de compiladores para linguagens específicas.",
                        "specificSkills": [
                          {
                            "id": "10.1.7.5.3.1",
                            "name": "Comparar tempo de desenvolvimento manual vs. automático",
                            "description": "Quantificar a aceleração proporcionada por meta-compiladores e ferramentas automáticas na geração de código intermediário e objeto, versus codificação manual de análises léxica e sintática.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender o Processo de Desenvolvimento Manual de Análise Léxica e Sintática",
                                  "subSteps": [
                                    "Pesquise e descreva os componentes de um analisador léxico manual (lexer): leitura de caracteres, identificação de tokens e gerenciamento de estados.",
                                    "Explique o parser sintático manual: construção de árvores de sintaxe usando tabelas de parsing ou algoritmos recursivos descendentes.",
                                    "Identifique tarefas repetitivas como tratamento de erros, otimizações e suporte a novas gramáticas.",
                                    "Estime tempos médios baseados em literatura: 100-500 horas para um lexer/parser básico de uma linguagem simples.",
                                    "Documente fluxogramas para lexer e parser manual."
                                  ],
                                  "verification": "Criar um fluxograma e relatório resumindo os processos manuais com estimativas de tempo citadas de fontes confiáveis.",
                                  "estimatedTime": "2-3 horas",
                                  "materials": "Documentação de compiladores (Dragon Book), artigos sobre Lex/Yacc, papel ou ferramenta de fluxograma (Draw.io).",
                                  "tips": "Foquem em exemplos simples como expressões aritméticas para evitar sobrecarga.",
                                  "learningObjective": "Compreender as etapas e complexidades envolvidas na codificação manual de análises léxica e sintática.",
                                  "commonMistakes": "Subestimar o tempo para tratamento de erros ou ambiguidades gramaticais."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Explorar Ferramentas Automáticas como Lex e Yacc/Bison",
                                  "subSteps": [
                                    "Instale e configure Lex (ou Flex) e Yacc (ou Bison).",
                                    "Estude a sintaxe: definições de regras léxicas em Lex e gramáticas em Yacc.",
                                    "Analise como essas ferramentas geram código C automaticamente para lexer e parser.",
                                    "Compare o código gerado vs. manual: observe a redução em linhas de código e lógica boilerplate.",
                                    "Estime acelerações típicas: 10-50x mais rápido na prototipagem inicial."
                                  ],
                                  "verification": "Gerar um lexer/parser trivial com Lex/Yacc e comparar o código fonte gerado com uma versão manual equivalente.",
                                  "estimatedTime": "2-4 horas",
                                  "materials": "Flex/Bison instalados, tutoriais oficiais, exemplos de código open-source (ex: SQLite parser).",
                                  "tips": "Use flags de debug como -d em Bison para visualizar estados do parser.",
                                  "learningObjective": "Dominar o uso básico de meta-compiladores para geração automática de analisadores.",
                                  "commonMistakes": "Ignorar conflitos de shift/reduce sem usar ferramentas de resolução."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar e Medir Tempo de Desenvolvimento Manual",
                                  "subSteps": [
                                    "Escolha uma gramática simples (ex: expressões aritméticas com +, -, *, /, parênteses).",
                                    "Codifique o lexer manual em C/Python: funções para next_token().",
                                    "Implemente parser recursivo descendente manual.",
                                    "Registre tempo total gasto (use cronômetro ou logs).",
                                    "Teste com casos de entrada variados e meça tempo de codificação iterativa para correções."
                                  ],
                                  "verification": "Código funcional manual com logs de tempo total (ex: 10+ horas) e testes passando.",
                                  "estimatedTime": "8-15 horas (inclui debugging)",
                                  "materials": "Editor de código (VS Code), compilador C/Python, conjunto de testes unitários.",
                                  "tips": "Divida em sessões para medir fadiga e iterações reais.",
                                  "learningObjective": "Experienciar e quantificar o esforço real de desenvolvimento manual.",
                                  "commonMistakes": "Não registrar tempo de debugging, que pode dobrar o total."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Implementar e Medir Tempo de Desenvolvimento Automático",
                                  "subSteps": [
                                    "Defina a mesma gramática em arquivos .l (Lex) e .y (Yacc).",
                                    "Compile com flex/bison para gerar lexer/parser.",
                                    "Integre ao main() e teste com os mesmos casos.",
                                    "Registre tempo total gasto (tipicamente 1-2 horas).",
                                    "Meça tempo de execução do código gerado vs. manual para completude."
                                  ],
                                  "verification": "Código automático funcional com logs de tempo (ex: <2 horas) e performance comparável.",
                                  "estimatedTime": "1-3 horas",
                                  "materials": "Flex/Bison, mesmos testes do step 3.",
                                  "tips": "Reutilize testes do manual para validação rápida.",
                                  "learningObjective": "Quantificar a aceleração prática das ferramentas automáticas.",
                                  "commonMistakes": "Subestimar tempo inicial de aprendizado da sintaxe das ferramentas."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Comparar e Quantificar Acelerações",
                                  "subSteps": [
                                    "Calcule ratios: tempo_manual / tempo_auto (ex: 10x).",
                                    "Analise ganhos em manutenção: mudanças gramaticais em minutos vs. horas.",
                                    "Crie gráficos/tabelas comparando linhas de código, tempo de dev e bugs.",
                                    "Discuta escalabilidade para linguagens maiores (ex: 100x em projetos reais).",
                                    "Escreva relatório com conclusões quantitativas."
                                  ],
                                  "verification": "Relatório com tabelas/gráficos mostrando aceleração ≥5x e análise qualitativa.",
                                  "estimatedTime": "2-3 horas",
                                  "materials": "Planilhas (Excel/Google Sheets), ferramentas de plotagem (Matplotlib).",
                                  "tips": "Inclua métricas como LOC (lines of code) para robustez.",
                                  "learningObjective": "Sintetizar dados para demonstrar vantagens quantitativas das ferramentas automáticas.",
                                  "commonMistakes": "Comparar apenas protótipos iniciais, ignorando manutenção de longo prazo."
                                }
                              ],
                              "practicalExample": "Desenvolva um lexer/parser para expressões aritméticas simples (2+3*(4-1)). Manualmente: ~12 horas para funcionalidade básica. Com Flex/Bison: ~1.5 horas. Resultado: aceleração de 8x, com parser gerado 5x menor em LOC.",
                              "finalVerifications": [
                                "Relatório com tempos medidos mostrando aceleração ≥5x.",
                                "Códigos manual e automático funcionando nos mesmos testes.",
                                "Tabelas/gráficos comparando tempo, LOC e bugs.",
                                "Análise de cenários de manutenção (ex: adicionar operador %).",
                                "Discussão de limitações (ex: otimizações manuais não suportadas).",
                                "Referências a casos reais (ex: LLVM TableGen)."
                              ],
                              "assessmentCriteria": [
                                "Precisão das medições de tempo (logs detalhados).",
                                "Funcionalidade equivalente entre manual e automático.",
                                "Quantificação clara de aceleração (ratios numéricos).",
                                "Análise qualitativa de vantagens/desvantagens.",
                                "Qualidade visual dos gráficos/tabelas.",
                                "Profundidade da discussão de escalabilidade."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Análise de complexidade temporal (O(n) vs. geração automática).",
                                "Economia: Análise custo-benefício em desenvolvimento de software.",
                                "Engenharia de Software: Princípios de automação e DRY (Don't Repeat Yourself).",
                                "Gestão de Projetos: Estimativa de esforço em cronogramas Agile.",
                                "Física/Química: Similares parsers em simuladores científicos (ex: gramáticas para fórmulas)."
                              ],
                              "realWorldApplication": "Em compiladores como GCC/Clang, ferramentas como Bison aceleram desenvolvimento de front-ends para novas linguagens (ex: Rust parser), reduzindo meses para semanas e permitindo foco em otimizações backend."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.7.5.3.2",
                            "name": "Desenvolver compilador personalizado acelerado",
                            "description": "Construir um compilador simples para uma linguagem mini usando ferramentas automáticas, destacando a redução no ciclo de desenvolvimento para análise semântica e geração de código.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Definir especificações e gramática da linguagem mini",
                                  "subSteps": [
                                    "Escolha uma linguagem mini simples, como MiniCalc com suporte a variáveis, expressões aritméticas, atribuições e print.",
                                    "Defina a sintaxe usando notação BNF ou EBNF, incluindo regras para precedência de operadores.",
                                    "Escreva a gramática inicial em formato ANTLR (.g4), cobrindo lexer e parser rules.",
                                    "Valide a gramática manualmente com exemplos de programas válidos e inválidos.",
                                    "Refine para eliminar ambiguidades e left-recursion."
                                  ],
                                  "verification": "Gramática compila sem erros no ANTLR e parseia exemplos de teste corretamente.",
                                  "estimatedTime": "2-3 horas",
                                  "materials": [
                                    "ANTLR4 documentation",
                                    "Editor de texto como VS Code com ANTLR extension",
                                    "Exemplos de gramáticas online"
                                  ],
                                  "tips": "Comece com o mínimo viável (expressões aritméticas) e adicione features iterativamente.",
                                  "learningObjective": "Compreender como especificar formalmente uma linguagem de programação simples.",
                                  "commonMistakes": [
                                    "Ignorar precedência de operadores",
                                    "Criar gramáticas ambíguas",
                                    "Esquecer tokens whitespace e comentários"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Configurar e gerar lexer/parser com ANTLR",
                                  "subSteps": [
                                    "Instale ANTLR4 (via Maven/Gradle ou jar standalone).",
                                    "Gere o código Java do lexer/parser executando 'antlr4 MiniCalc.g4'.",
                                    "Crie uma classe de teste básica para parsear strings e ASTs.",
                                    "Implemente visitor/walker para percorrer a árvore de sintaxe.",
                                    "Teste parsing de programas completos e capture erros sintáticos."
                                  ],
                                  "verification": "Lexer/parser gerado compila e parseia programas sem erros sintáticos, produzindo AST correto.",
                                  "estimatedTime": "3-4 horas",
                                  "materials": [
                                    "ANTLR4 JAR",
                                    "JDK 11+",
                                    "IDE como IntelliJ com ANTLR plugin"
                                  ],
                                  "tips": "Use o ANTLR TestRig (grun) para debugging visual da árvore de parse.",
                                  "learningObjective": "Dominar geração automática de componentes front-end de compiladores.",
                                  "commonMistakes": [
                                    "Não configurar corretamente o classpath ANTLR",
                                    "Ignorar erros de left-recursion",
                                    "Esquecer de tratar EOF"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar análise semântica acelerada",
                                  "subSteps": [
                                    "Crie uma tabela de símbolos (Symbol Table) para escopo e tipos.",
                                    "Implemente visitor para checagem de tipos em expressões e declarações.",
                                    "Adicione detecção de variáveis não declaradas e conflitos de escopo.",
                                    "Otimize com herança de contexto para passes únicos.",
                                    "Teste com casos de erro semântico e valide saídas."
                                  ],
                                  "verification": "Análise detecta e reporta erros semânticos corretamente em testes unitários.",
                                  "estimatedTime": "4-5 horas",
                                  "materials": [
                                    "Bibliotecas Java para maps/hashtables",
                                    "JUnit para testes"
                                  ],
                                  "tips": "Use ANTLR's ParseTreeVisitor para passes bottom-up eficientes.",
                                  "learningObjective": "Aplicar ferramentas para acelerar implementação de análise semântica.",
                                  "commonMistakes": [
                                    "Não gerenciar escopos aninhados",
                                    "Permitir shadowing de variáveis sem aviso",
                                    "Checagens ineficientes O(n^2)"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Desenvolver geração de código e integração",
                                  "subSteps": [
                                    "Defina target: bytecode para stack machine simples ou JVM.",
                                    "Implemente visitor para gerar código intermediário (IR) ou direto.",
                                    "Adicione otimizações básicas como constant folding.",
                                    "Integre todos os componentes em um pipeline: parse -> semântica -> codegen.",
                                    "Gere executável e rode em VM simples."
                                  ],
                                  "verification": "Código gerado executa e produz saídas corretas para programas de teste.",
                                  "estimatedTime": "4-5 horas",
                                  "materials": [
                                    "JVM ou ASM library para bytecode",
                                    "Script de VM simples em Java"
                                  ],
                                  "tips": "Mantenha codegen modular para fácil extensão a novos targets.",
                                  "learningObjective": "Construir back-end acelerado com foco em redução de ciclos de dev.",
                                  "commonMistakes": [
                                    "Erros de stack overflow na VM",
                                    "Geração de código sem alinhamento de tipos",
                                    "Falta de handling de runtime errors"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Testar, otimizar e documentar aceleração",
                                  "subSteps": [
                                    "Crie suite de testes: 20+ programas válidos/inválidos.",
                                    "Meça tempo de desenvolvimento vs. manual (ex: log de horas).",
                                    "Otimize gramática e passes para performance.",
                                    "Documente o processo, destacando ganhos de ferramentas.",
                                    "Profile e benchmark o compilador resultante."
                                  ],
                                  "verification": "Compilador passa 100% dos testes; relatório mostra redução >50% no tempo.",
                                  "estimatedTime": "2-3 horas",
                                  "materials": [
                                    "JUnit/Pytest",
                                    "Profiler como VisualVM"
                                  ],
                                  "tips": "Automatize testes com scripts para CI/CD simulado.",
                                  "learningObjective": "Avaliar impacto quantitativo de ferramentas automáticas.",
                                  "commonMistakes": [
                                    "Testes insuficientes para edge cases",
                                    "Não medir baselines manuais",
                                    "Ignorar performance de runtime"
                                  ]
                                }
                              ],
                              "practicalExample": "Construa um compilador para MiniCalc: suporta 'var x = 5 + 3 * 2; print(x);'. Use ANTLR para lexer/parser (reduz de 20h para 2h), análise semântica com symbol table (detecta 'x = \"str\";' como erro), gera bytecode para stack VM que executa e imprime 11 corretamente.",
                              "finalVerifications": [
                                "Compilador parseia e compila programas válidos sem crashes.",
                                "Detecta e reporta erros sintáticos e semânticos precisamente.",
                                "Código gerado executa com resultados corretos em VM.",
                                "Tempo total de dev < 20h, vs. 100h+ manual.",
                                "AST e symbol table são gerados e dumpáveis para inspeção.",
                                "Otimizações básicas aplicadas (ex: constant folding)."
                              ],
                              "assessmentCriteria": [
                                "Gramática cobre 100% dos casos de teste sem ambiguidades (30%).",
                                "Análise semântica precisa e eficiente (25%).",
                                "Geração de código correta e otimizada (20%).",
                                "Integração completa e testes passing (15%).",
                                "Documentação de aceleração com métricas (10%)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria de linguagens formais e autômatos.",
                                "Engenharia de Software: Automação e DevOps em toolchains.",
                                "Inteligência Artificial: Parsers em processamento de linguagem natural.",
                                "Sistemas Operacionais: Geração de código para máquinas virtuais."
                              ],
                              "realWorldApplication": "Empresas como Google e Meta usam ANTLR para DSLs internas (ex: GraphQL parsers, config languages), reduzindo ciclos de desenvolvimento de meses para semanas, permitindo iterações rápidas em produtos como Angular e React."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.7.5.3.3",
                            "name": "Identificar aplicações em projetos reais",
                            "description": "Relacionar ferramentas automáticas a casos práticos, como compiladores para DSLs (Domain-Specific Languages), citando referências bibliográficas como Aho et al. e Santos & Langlois.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Conceitos Fundamentais de Ferramentas Automáticas e DSLs",
                                  "subSteps": [
                                    "Defina ferramentas automáticas como geradores de compiladores (ex: YACC, ANTLR) e explique seu papel em meta-compiladores.",
                                    "Descreva Domain-Specific Languages (DSLs) e dê exemplos como SQL ou HTML.",
                                    "Liste vantagens das ferramentas automáticas, como aceleração no desenvolvimento de parsers e lexers.",
                                    "Identifique componentes chave: lexer, parser, árvore de sintaxe abstrata (AST).",
                                    "Compare manual vs. automático na construção de compiladores."
                                  ],
                                  "verification": "Crie um mapa mental resumindo conceitos e componentes; revise se cobre definições, exemplos e vantagens.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Livro 'Compilers: Principles, Techniques, and Tools' de Aho et al. (capítulos iniciais), notas de aula sobre compiladores.",
                                  "tips": "Use diagramas visuais para diferenciar lexer e parser.",
                                  "learningObjective": "Compreender os fundamentos teóricos para contextualizar aplicações práticas.",
                                  "commonMistakes": "Confundir DSLs com linguagens gerais; ignorar o foco em automação."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Estudar Referências Bibliográficas Relevantes",
                                  "subSteps": [
                                    "Leia trechos selecionados de Aho et al. sobre ferramentas como YACC e LEX.",
                                    "Analise o paper ou capítulos de Santos & Langlois sobre meta-compiladores e DSLs.",
                                    "Extraia citações específicas sobre aplicações práticas em projetos reais.",
                                    "Anote exemplos citados, como compiladores para linguagens de configuração ou embedded.",
                                    "Compare as visões dos autores sobre aceleração no desenvolvimento."
                                  ],
                                  "verification": "Compile uma lista de 5 citações chave com resumos; verifique alinhamento com aplicações reais.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "PDFs ou livros de Aho et al. e Santos & Langlois, ferramenta de anotações como Notion ou Zotero.",
                                  "tips": "Busque seções sobre 'case studies' ou 'applications' nos índices.",
                                  "learningObjective": "Dominar evidências acadêmicas para embasar identificação de aplicações.",
                                  "commonMistakes": "Ler superficialmente sem extrair exemplos concretos; não citar fontes corretamente."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Pesquisar e Analisar Projetos Reais",
                                  "subSteps": [
                                    "Busque repositórios GitHub usando termos como 'ANTLR DSL compiler' ou 'YACC domain-specific'.",
                                    "Selecione 3 projetos reais (ex: compilador para DSL de gráficos, configuração de jogos).",
                                    "Analise o código-fonte: identifique uso de ferramentas automáticas e resultados (ex: tempo de desenvolvimento reduzido).",
                                    "Mapeie como a ferramenta acelerou o projeto (ex: parser gerado em horas vs. semanas).",
                                    "Documente métricas de sucesso, como tamanho do código ou performance."
                                  ],
                                  "verification": "Crie uma tabela comparativa de 3 projetos com colunas: ferramenta usada, DSL, benefícios observados.",
                                  "estimatedTime": "90 minutos",
                                  "materials": "GitHub, Google Scholar, ferramentas como ANTLRworks ou Bison manual.",
                                  "tips": "Filtre por estrelas/recentes para relevância; leia READMEs primeiro.",
                                  "learningObjective": "Identificar padrões de aplicação em cenários reais.",
                                  "commonMistakes": "Escolher projetos irrelevantes; focar só em teoria sem código real."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Relacionar Ferramentas a Aplicações e Sintetizar",
                                  "subSteps": [
                                    "Conecte referências bibliográficas aos projetos encontrados (ex: Aho et al. aplicado em DSL de config).",
                                    "Crie um diagrama mostrando fluxo: ferramenta -> DSL -> projeto real.",
                                    "Liste 3-5 aplicações práticas identificadas (ex: IoT, jogos, finanças).",
                                    "Avalie limitações e quando usar ferramentas automáticas.",
                                    "Redija um parágrafo síntese relacionando tudo."
                                  ],
                                  "verification": "Apresente diagrama e síntese para revisão; confirme se inclui referências e exemplos concretos.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Ferramentas de diagramação como Draw.io, editor de texto.",
                                  "tips": "Use setas no diagrama para mostrar aceleração (ex: tempo economizado).",
                                  "learningObjective": "Sintetizar conhecimento para identificar aplicações de forma independente.",
                                  "commonMistakes": "Não integrar referências aos projetos; generalizar demais sem especificidade."
                                }
                              ],
                              "practicalExample": "No projeto Terraform (DSL para infraestrutura como código), ferramentas como ANTLR geram o parser automaticamente, reduzindo meses de desenvolvimento manual para dias, permitindo deploy rápido em cloud como AWS.",
                              "finalVerifications": [
                                "Lista de pelo menos 3 projetos reais com ferramentas automáticas identificadas.",
                                "Citações corretas de Aho et al. e Santos & Langlois ligadas a exemplos.",
                                "Diagrama ou tabela mostrando relações ferramenta-DSL-projeto.",
                                "Métricas de aceleração comprovadas (ex: tempo reduzido).",
                                "Síntese escrita de 200 palavras relacionando teoria e prática.",
                                "Identificação de 2 limitações reais."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de ferramentas automáticas em projetos (90% acerto).",
                                "Profundidade de análise: substeps detalhados e evidências concretas.",
                                "Integração bibliográfica: uso relevante de Aho et al. e Santos & Langlois.",
                                "Criatividade em conexões: exemplos além dos óbvios.",
                                "Clareza na documentação: diagramas e sínteses legíveis.",
                                "Completude: todos elementos da expansão cobertos."
                              ],
                              "crossCurricularConnections": [
                                "Engenharia de Software: automação em ciclos de desenvolvimento ágil.",
                                "Linguagens de Programação: design de DSLs para abstrações de domínio.",
                                "Sistemas Embarcados: compiladores para linguagens de hardware description (ex: VHDL).",
                                "Gestão de Projetos: ROI de ferramentas automáticas em prazos.",
                                "Pesquisa Acadêmica: análise de papers para validação prática."
                              ],
                              "realWorldApplication": "Em empresas como Google (usando DSLs com geradores para Kubernetes configs) ou startups de IoT, essas ferramentas aceleram prototipagem, reduzindo custos de desenvolvimento em 50-70% e permitindo foco em features de negócio."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      }
                    ]
                  }
                ]
              }
            ],
            "totalSkills": 334
          }
        ],
        "totalSkills": 334
      }
    ]
  }
}