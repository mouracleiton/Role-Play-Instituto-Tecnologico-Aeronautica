{
  "formatVersion": "1.0",
  "exportDate": "2025-12-04T16:38:36.740Z",
  "appVersion": "1.0.0",
  "curriculumData": {
    "metadata": {
      "baseOn": "Catálogo dos Cursos de Graduação 2025 - PS-76",
      "lastUpdated": "2025-12-04",
      "totalAtomicSkills": 326
    },
    "areas": [
      {
        "id": "10",
        "name": "Engenharia de Controle e Automação",
        "description": "Área dedicada ao estudo avançado de sistemas de controle, incluindo técnicas clássicas e robustas para sistemas lineares.",
        "disciplines": [
          {
            "id": "10.1",
            "name": "PS-76 - 76 - Controle Avançado de Sistemas Monovariáveis",
            "description": "Conceitos e revisão de projeto clássico de sistemas de controle lineares escalares: estabilidade, desempenho e técnicas clássicas de projeto. Modelos de incertezas, a forma padrão e robustez de sistemas de controle LIT. Técnicas avançadas de projeto de sistemas de controle LIT escalares: formatação de malha; a parametrização de controladores estabilizadores, o projeto H∞ e a μ-síntese. Métodos algorítmicos: projeto por otimização de parâmetros. Introdução aos sistemas multivariáveis. Bibliografia: SKOGESTAD, S.; POSTLETHWAITE, I. Multivariable feedback control: analysis and design, 2. ed. [S.l.]: Wiley, 2005. GU, D.-W.; PETKOV, P. HR.; KONSTANTINOV, M. M. Robust control design with MATLAB. 2. ed. [S.l.]: Springer-Verlag, 2014. ZHOU, K.; DOYLE, J.C. Essentials of robust control. Upper Saddle River, Hall, 1998. 6.4.4 Departamento de Projetos (IEM-P)",
            "mainTopics": [
              {
                "id": "10.1.1",
                "name": "Revisão de Projeto Clássico de Sistemas de Controle Lineares Escalares",
                "description": "Conceitos fundamentais de estabilidade, desempenho e técnicas clássicas de projeto para sistemas LIT escalares.",
                "totalSkills": 48,
                "atomicTopics": [
                  {
                    "id": "10.1.1.1",
                    "name": "Estabilidade de Sistemas LIT Escalares",
                    "description": "Critérios e métodos para análise de estabilidade em sistemas lineares invariantes no tempo escalares, como Routh-Hurwitz e Nyquist.",
                    "individualConcepts": [
                      {
                        "id": "10.1.1.1.1",
                        "name": "Conceitos Fundamentais de Estabilidade em Sistemas LIT Escalares",
                        "description": "Definições e propriedades básicas de estabilidade para sistemas lineares invariantes no tempo (LIT) escalares, incluindo estabilidade BIBO, assintótica e localização de polos no plano complexo.",
                        "specificSkills": [
                          {
                            "id": "10.1.1.1.1.1",
                            "name": "Definir tipos de estabilidade em sistemas LIT escalares",
                            "description": "Explicar e diferenciar estabilidade BIBO (Bounded-Input Bounded-Output), estabilidade assintótica e estabilidade interna, relacionando-as à localização dos polos do polinômio característico no semiplano esquerdo do plano s.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar fundamentos de sistemas LIT escalares e polinômio característico",
                                  "subSteps": [
                                    "Explicar o que é um sistema Linear Invariante no Tempo (LIT) escalar.",
                                    "Definir função de transferência e polinômio característico como denominador da FT.",
                                    "Introduzir o plano s (plano complexo) e semiplano esquerdo (Re(s) < 0).",
                                    "Identificar polos como raízes do polinômio característico.",
                                    "Discutir importância dos polos para o comportamento dinâmico."
                                  ],
                                  "verification": "Desenhar o plano s e marcar polos de uma FT exemplo, identificando semiplano esquerdo.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Apostila de Controle Linear, papel e caneta, software MATLAB ou Python (Control Systems Library)",
                                  "tips": "Sempre normalize a FT para polinômio monico no denominador para facilitar cálculo de raízes.",
                                  "learningObjective": "Compreender a representação no domínio s e o papel dos polos na dinâmica do sistema.",
                                  "commonMistakes": "Confundir polos (raízes do denominador) com zeros (raízes do numerador); ignorar multiplicidade de polos."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Definir e caracterizar estabilidade BIBO (Bounded-Input Bounded-Output)",
                                  "subSteps": [
                                    "Definir estabilidade BIBO: toda entrada limitada produz saída limitada.",
                                    "Estabelecer critério para LIT próprios: todos polos com parte real negativa (Re(p) < 0).",
                                    "Analisar impulso unitário e resposta em malha aberta.",
                                    "Verificar com exemplo: FT = 1/(s+2) (estável) vs 1/(s-1) (instável).",
                                    "Simular resposta a degrau unitário."
                                  ],
                                  "verification": "Simular em software e confirmar que saída permanece limitada para entrada degrau.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "MATLAB/Simulink ou Octave, exemplos de FTs estáveis/instáveis",
                                  "tips": "Use função step() ou impulse() no MATLAB para visualização rápida.",
                                  "learningObjective": "Diferenciar estabilidade externa baseada em entradas/saídas.",
                                  "commonMistakes": "Aplicar critério BIBO a sistemas impróprios sem cuidado; confundir com estabilidade de Lyapunov."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explorar estabilidade assintótica",
                                  "subSteps": [
                                    "Definir estabilidade assintótica: resposta livre tende a zero quando t → ∞.",
                                    "Relacionar com polos: todos estritamente no semiplano esquerdo.",
                                    "Comparar com BIBO em LIT escalares (equivalentes para sistemas próprios mínimos).",
                                    "Analisar casos com polos no eixo imaginário (marginalmente estável).",
                                    "Exemplo: oscilador harmônico (polos em ±jω)."
                                  ],
                                  "verification": "Plotar resposta livre e confirmar convergência a zero.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Gráficos de resposta temporal, calculadora de raízes polinomiais",
                                  "tips": "Foquem na parte real: Re(p) < 0 garante decaimento exponencial.",
                                  "learningObjective": "Entender estabilidade da resposta natural.",
                                  "commonMistakes": "Confundir assintótica com BIBO em sistemas não mínimos; ignorar polos múltiplos."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Compreender estabilidade interna",
                                  "subSteps": [
                                    "Definir estabilidade interna: todos modos internos (estados) assintoticamente estáveis.",
                                    "Relacionar com representação de estado: autovalores da matriz A com Re(λ) < 0.",
                                    "Diferenciar de BIBO: interna é mais forte, detecta cancelamentos patológicos.",
                                    "Exemplo: sistema com cancelamento polo-zero instável (BIBO ok, interna não).",
                                    "Converter FT para espaço de estado e verificar autovalores."
                                  ],
                                  "verification": "Converter FT para estado e listar autovalores, confirmando Re(λ) < 0.",
                                  "estimatedTime": "35 minutos",
                                  "materials": "MATLAB (ss() e eig()), tabela de realizações canônicas",
                                  "tips": "Use forma controlável ou observável para verificação.",
                                  "learningObjective": "Identificar estabilidade além da FT mínima.",
                                  "commonMistakes": "Assumir BIBO implica interna sem checar realizações; confundir com detectabilidade."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Diferenciar tipos de estabilidade e sintetizar critérios",
                                  "subSteps": [
                                    "Tabela comparativa: BIBO (saída limitada), assintótica (resposta livre →0), interna (modos →0).",
                                    "Critério unificado: polos no semiplano esquerdo para mínima realização.",
                                    "Casos especiais: polos no eixo jω (estável BIBO mas não assintótico).",
                                    "Exercício: classificar 3 FTs diferentes.",
                                    "Resumir relações e hierarquia (interna ⇒ assintótica ⇒ BIBO em certos casos)."
                                  ],
                                  "verification": "Classificar corretamente 3 exemplos e justificar com localização de polos.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Planilha de exercícios, simulador online de controle",
                                  "tips": "Sempre plote polos no plano s para visualização intuitiva.",
                                  "learningObjective": "Sintetizar e diferenciar os três tipos relacionando aos polos.",
                                  "commonMistakes": "Generalizar equivalências sem especificar 'próprio e mínimo'; ignorar sistemas desacoplados."
                                }
                              ],
                              "practicalExample": "Considere um controlador de temperatura de um forno com FT G(s) = 10 / (s^2 + 3s + 2). Calcule polos (s=-1, s=-2, ambos Re<0): estável BIBO, assintótica e interna. Simule degrau: saída converge sem overshoot excessivo. Agora, altere para s^2 + s - 2 (polos -2 e +1): instável, saída diverge.",
                              "finalVerifications": [
                                "Definir precisamente BIBO, assintótica e interna sem erros.",
                                "Localizar polos de uma FT dada e classificar estabilidade.",
                                "Explicar por que polos no semiplano esquerdo garantem estabilidade.",
                                "Identificar contraexemplo onde BIBO ok mas interna não.",
                                "Simular e interpretar gráficos de resposta temporal.",
                                "Diferenciar estabilidade marginal (polos em jω)."
                              ],
                              "assessmentCriteria": [
                                "Precisão nas definições (100% correto).",
                                "Correta localização e interpretação de polos (Re(p)<0).",
                                "Uso adequado de exemplos e simulações.",
                                "Diferenciação clara entre os três tipos.",
                                "Capacidade de síntese em tabela comparativa.",
                                "Ausência de confusões comuns (ex: BIBO vs interna).",
                                "Profundidade na relação com plano s."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Análise complexa e raízes de polinômios.",
                                "Física: Sistemas dinâmicos e equações diferenciais lineares.",
                                "Computação: Simulação numérica com MATLAB/Python (bibliotecas control).",
                                "Engenharia Elétrica: Projeto de filtros e amplificadores.",
                                "Matemática Aplicada: Critérios de Routh-Hurwitz."
                              ],
                              "realWorldApplication": "Em aviões, estabilidade interna garante que modos não observáveis (ex: flexão de asas) não destemibilizem o sistema, mesmo se BIBO parecer ok; em controle de processos industriais como reatores químicos, polos no semiplano esquerdo previnem oscilações perigosas em temperatura/pressão."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.1.1.2",
                            "name": "Analisar localização de polos para estabilidade",
                            "description": "Dado um polinômio característico, determinar a estabilidade do sistema plotando os polos no plano complexo e verificando se todos estão no semiplano esquerdo (Re(s) < 0).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Identificar o polinômio característico do sistema",
                                  "subSteps": [
                                    "Revise a função de transferência ou equação diferencial do sistema para localizar o denominador.",
                                    "Escreva o polinômio característico como P(s) = 0, onde P(s) é o denominador da função de transferência.",
                                    "Confirme o grau do polinômio e os coeficientes principais.",
                                    "Verifique se o polinômio está na forma monômia padrão (coeficiente líder = 1).",
                                    "Anote o polinômio em uma equação clara."
                                  ],
                                  "verification": "O polinômio está corretamente extraído e escrito na forma P(s) = a_n s^n + ... + a_0 = 0.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Função de transferência do sistema",
                                    "Papel e lápis ou software como MATLAB/SymPy"
                                  ],
                                  "tips": "Sempre normalize o polinômio dividindo pelo coeficiente líder para simplificar cálculos.",
                                  "learningObjective": "Compreender como extrair o polinômio característico de representações de sistemas LIT.",
                                  "commonMistakes": [
                                    "Confundir numerador com denominador",
                                    "Esquecer de igualar a zero",
                                    "Não normalizar coeficientes"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Calcular as raízes do polinômio (localizar os polos)",
                                  "subSteps": [
                                    "Para polinômios de baixa ordem (1º ou 2º), resolva analiticamente usando fórmula quadrática.",
                                    "Para ordens superiores, use métodos numéricos ou fatoração (ex: teste de raízes racionais).",
                                    "Utilize ferramentas computacionais como roots() no MATLAB ou solve() no Python/SymPy.",
                                    "Liste todas as raízes complexas no formato a + bi.",
                                    "Verifique a exatidão somando/verificar multiplicidade das raízes."
                                  ],
                                  "verification": "Todas as raízes foram calculadas corretamente e listadas com partes real e imaginária.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Calculadora gráfica",
                                    "Software de álgebra simbólica (MATLAB, Python com NumPy/SciPy)"
                                  ],
                                  "tips": "Comece testando raízes racionais possíveis (±fatores de a0/fatores de an) para fatorar.",
                                  "learningObjective": "Dominar o cálculo preciso de polos a partir do polinômio característico.",
                                  "commonMistakes": [
                                    "Erros aritméticos na fórmula quadrática",
                                    "Ignorar raízes complexas conjugadas",
                                    "Não considerar multiplicidade"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Plotar os polos no plano complexo",
                                  "subSteps": [
                                    "Desenhe os eixos: horizontal para parte real (Re(s)), vertical para parte imaginária (Im(s)).",
                                    "Marque cada polo como 'x' no ponto (Re, Im).",
                                    "Identifique o eixo imaginário (Re=0) e o semiplano esquerdo (Re<0).",
                                    "Use escala apropriada para visualizar todos os polos claramente.",
                                    "Rotule os polos e adicione uma legenda."
                                  ],
                                  "verification": "Gráfico contém todos os polos plotados corretamente com eixos rotulados.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Papel milimetrado",
                                    "Software de plotagem (MATLAB plot, Python Matplotlib, ou Desmos)"
                                  ],
                                  "tips": "Amplie a escala se polos estiverem próximos da origem para melhor visualização.",
                                  "learningObjective": "Visualizar geometricamente os polos no plano s para análise qualitativa.",
                                  "commonMistakes": [
                                    "Confundir eixos real/imaginário",
                                    "Plotar magnitude em vez de partes real/imaginária",
                                    "Esquecer polos múltiplos"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar localização e determinar estabilidade",
                                  "subSteps": [
                                    "Examine a parte real de cada polo: verifique se todos têm Re(s) < 0.",
                                    "Identifique polos no semiplano direito (Re>0: instável), imaginário puro (Re=0: marginalmente estável) ou esquerdo.",
                                    "Considere polos múltiplos: se qualquer no semiplano direito ou na origem com multiplicidade >1, instável.",
                                    "Conclua: Estável se todos Re<0; caso contrário, especifique o tipo de instabilidade.",
                                    "Documente a conclusão com justificativa."
                                  ],
                                  "verification": "Conclusão de estabilidade justificada pela localização de todos os polos.",
                                  "estimatedTime": "10 minutos",
                                  "materials": [
                                    "Gráfico do plano complexo gerado no step 3"
                                  ],
                                  "tips": "Lembre: estabilidade assintótica requer todos polos estritamente no semiplano esquerdo.",
                                  "learningObjective": "Aplicar o critério de Routh-Hurwitz qualitativo via localização de polos.",
                                  "commonMistakes": [
                                    "Considerar Re=0 como estável",
                                    "Ignorar polos com multiplicidade",
                                    "Confundir estabilidade com convergência"
                                  ]
                                }
                              ],
                              "practicalExample": "Para o polinômio P(s) = s^2 + 3s + 2 = 0, raízes s=-1, s=-2 (ambos Re<0). Plote em (-1,0) e (-2,0). Conclusão: sistema estável. Exemplo instável: s^2 - s + 1 =0, raízes com Re>0.",
                              "finalVerifications": [
                                "Pode extrair corretamente o polinômio de uma função de transferência dada.",
                                "Calcula raízes com precisão para polinômios até ordem 4.",
                                "Plota polos corretamente e identifica semiplanos.",
                                "Conclui estabilidade corretamente em 90% dos casos testados.",
                                "Explica o impacto de um polo no semiplano direito.",
                                "Diferencia estabilidade assintótica de marginal."
                              ],
                              "assessmentCriteria": [
                                "Precisão no cálculo de raízes (erro <1%).",
                                "Correção no plot (todas posições exatas).",
                                "Justificativa clara da conclusão de estabilidade.",
                                "Uso adequado de ferramentas computacionais.",
                                "Identificação de casos especiais (polos imaginários, múltiplos).",
                                "Clareza na documentação e comunicação."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Álgebra linear e resolução de equações polinomiais.",
                                "Física: Dinâmica de sistemas oscilatórios e amortecimento.",
                                "Informática: Programação numérica para análise de raízes (MATLAB/Python).",
                                "Engenharia Elétrica: Projeto de filtros e compensadores.",
                                "Estatística: Análise de convergência em processos estocásticos."
                              ],
                              "realWorldApplication": "Em controle de drones, analisar polos garante que o sistema retorne à posição desejada sem oscilações divergentes; em automação industrial, previne falhas catastróficas em motores e robôs."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.1.1.3",
                            "name": "Relacionar margens de estabilidade com polos",
                            "description": "Calcular e interpretar margens de ganho e fase a partir da posição dos polos dominantes, explicando como eles afetam a robustez à estabilidade.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Conceitos de Polos e Estabilidade em Sistemas LIT",
                                  "subSteps": [
                                    "Defina polos como raízes do denominador da função de transferência.",
                                    "Explique a relação entre localização no plano s e estabilidade (semiplano esquerdo para estabilidade).",
                                    "Identifique polos dominantes como aqueles mais próximos do eixo imaginário.",
                                    "Desenhe o plano s para um sistema de exemplo com polos reais e complexos.",
                                    "Discuta o impacto da distância real (σ) e frequência imaginária (ω) na resposta transitória."
                                  ],
                                  "verification": "Desenhar corretamente o plano s com polos marcados e classificar estabilidade para 3 sistemas dados.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Livro 'Engenharia de Controle Moderno' de Ogata",
                                    "Papel quadriculado ou software como MATLAB para plano s",
                                    "Funções de transferência de exemplo"
                                  ],
                                  "tips": "Sempre normalize polos complexos em pares conjugados para sistemas reais.",
                                  "learningObjective": "Compreender como a posição dos polos determina a estabilidade básica do sistema.",
                                  "commonMistakes": [
                                    "Confundir polos com zeros",
                                    "Ignorar que polos no semiplano direito causam instabilidade",
                                    "Não identificar corretamente polos dominantes"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Compreender Definições de Margens de Ganho e Fase",
                                  "subSteps": [
                                    "Defina margem de ganho (GM) como a quantidade de ganho extra até |G(jω)|=1 em ω onde arg(G(jω))=-180°.",
                                    "Defina margem de fase (PM) como 180° + arg(G(jω)) em ω onde |G(jω)|=1.",
                                    "Interprete margens altas como maior robustez à variações de ganho/fase.",
                                    "Revise diagramas de Bode para visualizar pontos críticos.",
                                    "Calcule GM e PM manualmente para um sistema simples de primeira ordem."
                                  ],
                                  "verification": "Calcular GM e PM para um sistema RC de baixa passa usando diagrama de Bode desenhado à mão.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Software MATLAB ou Python (control library)",
                                    "Tabelas de Bode para polos/zeros",
                                    "Calculadora científica"
                                  ],
                                  "tips": "Use aproximações assintóticas nos diagramas de Bode para agilizar cálculos iniciais.",
                                  "learningObjective": "Dominar as definições e interpretação qualitativa das margens de estabilidade.",
                                  "commonMistakes": [
                                    "Confundir frequência de ganho com frequência de fase",
                                    "Esquecer o sinal negativo na fase para GM",
                                    "Interpretar margens negativas como estáveis"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar Impacto dos Polos no Comportamento em Frequência",
                                  "subSteps": [
                                    "Explique como polos reais negativos causam decaimento de -20 dB/década na magnitude.",
                                    "Descreva o efeito de polos complexos conjugados: pico de ressonância e atraso de fase.",
                                    "Relacione a parte real σ com a largura da transição de fase e ω com a frequência de pico.",
                                    "Simule diagramas de Bode para sistemas com polos variando σ e ω.",
                                    "Compare sistemas com polos próximos vs distantes do eixo jω."
                                  ],
                                  "verification": "Gerar e analisar diagramas de Bode para dois sistemas com polos diferentes, identificando mudanças nas margens.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "MATLAB/Simulink ou Octave",
                                    "Tutoriais online de Bode plots",
                                    "Planilhas Excel para cálculos manuais"
                                  ],
                                  "tips": "Foque em polos dominantes; polos rápidos afetam pouco as margens.",
                                  "learningObjective": "Entender qualitativamente como polos moldam as curvas de Bode afetando margens.",
                                  "commonMistakes": [
                                    "Subestimar o atraso de fase de polos não-dominantes",
                                    "Ignorar contribuições de múltiplos polos",
                                    "Confundir magnitude com fase"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Calcular Margens de Estabilidade a partir de Polos Dominantes",
                                  "subSteps": [
                                    "Use aproximação para sistemas de segunda ordem: PM ≈ 100ζ graus, onde ζ = -σ / ω_n e ω_n = √(σ² + ω²).",
                                    "Estime GM ≈ 1 / (2ζ) para fator de amortecimento ζ.",
                                    "Aplique fórmula para polos dominantes em sistemas de ordem superior.",
                                    "Valide cálculos com simulação numérica de Bode.",
                                    "Ajuste para sistemas com zeros ou polos adicionais."
                                  ],
                                  "verification": "Calcular PM e GM aproximadas para um sistema com polos -1 ± j3 e comparar com simulação exata (erro <10%).",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "MATLAB script para tf, bode, margin",
                                    "Fórmulas anotadas de aproximações",
                                    "Exemplos resolvidos de livros"
                                  ],
                                  "tips": "Para precisão, use apenas se polos dominantes contribuem >80% da resposta.",
                                  "learningObjective": "Realizar cálculos quantitativos de margens baseados em posições de polos.",
                                  "commonMistakes": [
                                    "Usar ζ incorreto (esquecer sinal negativo em σ)",
                                    "Aplicar aproximações a sistemas de alta ordem sem validação",
                                    "Não converter ω_n corretamente"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Interpretar Robustez à Estabilidade e Aplicações",
                                  "subSteps": [
                                    "Explique que margens altas (>6dB GM, >45° PM) implicam polos mais à esquerda (maior |σ|).",
                                    "Discuta sensibilidade a perturbações: polos próximos do eixo reduzem robustez.",
                                    "Analise trade-offs: polos reais vs complexos para diferentes margens.",
                                    "Resolva problema de design: reposicione polos para atingir PM=60°.",
                                    "Documente conclusões em relatório curto."
                                  ],
                                  "verification": "Explicar verbalmente ou por escrito como dobrar PM afeta posição dos polos.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Casos de estudo de controle (e.g., inversor pendular)",
                                    "Ferramenta de root locus no MATLAB"
                                  ],
                                  "tips": "Pense em robustez como 'espaço de manobra' antes da instabilidade.",
                                  "learningObjective": "Interpretar como margens refletem robustez via polos e guiar designs.",
                                  "commonMistakes": [
                                    "Assumir que GM alta implica PM alta",
                                    "Ignorar efeitos não-lineares em interpretações",
                                    "Superestimar robustez de margens marginais"
                                  ]
                                }
                              ],
                              "practicalExample": "Para um sistema de segunda ordem com polos em -0.5 ± j2 (ζ≈0.24, ω_n≈2.06), PM≈24° e GM≈2 (4dB). Simule em MATLAB: sys=tf([1],[1 1 4.25]); [Gm,Pm,Wcg,Wcp]=margin(sys). Reposicione para -2 ± j2 para PM≈76° e GM≈9, demonstrando maior robustez.",
                              "finalVerifications": [
                                "Calcular corretamente PM e GM aproximadas de polos dominantes com erro <15%.",
                                "Desenhar e interpretar diagrama de Bode destacando impacto de polos.",
                                "Explicar qualitativamente como aumentar |σ| melhora margens.",
                                "Validar cálculos com simulação numérica.",
                                "Identificar polos dominantes em sistema de 3ª ordem.",
                                "Relacionar margens a overshoot e tempo de estabilização."
                              ],
                              "assessmentCriteria": [
                                "Precisão nos cálculos de margens (>90% acurácia nas aproximações).",
                                "Correta identificação e análise de polos dominantes.",
                                "Interpretação clara da robustez (qualitativa e quantitativa).",
                                "Uso adequado de ferramentas de simulação com validação.",
                                "Capacidade de aplicar em problemas de design simples.",
                                "Documentação completa com gráficos e explicações.",
                                "Evitar erros comuns em 100% dos exercícios."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Análise de números complexos e equações características.",
                                "Física: Dinâmica de osciladores amortecidos e ressonância.",
                                "Programação: Simulações em MATLAB/Python para análise de sistemas.",
                                "Eletrônica: Projeto de filtros analógicos com polos especificados."
                              ],
                              "realWorldApplication": "Em controle de drones, relacionar polos do controlador PID com margens garante estabilidade robusta contra variações de vento, evitando oscilações ou crashes; engenheiros ajustam polos para PM>50° em flight controllers como PX4."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.1.1.2",
                        "name": "Critério de Routh-Hurwitz",
                        "description": "Método algébrico para avaliar a estabilidade de sistemas LIT escalares sem calcular as raízes explicitamente, baseado na construção de uma tabela especial e contagem de mudanças de sinal.",
                        "specificSkills": [
                          {
                            "id": "10.1.1.1.2.1",
                            "name": "Construir a tabela de Routh para um polinômio",
                            "description": "Dado o polinômio característico de uma função de transferência, montar a tabela de Routh seguindo as regras de cálculo das linhas sucessivas e identificar elementos auxiliares.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar o polinômio característico e listar coeficientes",
                                  "subSteps": [
                                    "Identifique o polinômio dado no denominador da função de transferência.",
                                    "Escreva-o na forma padrão descendente: a_n s^n + a_{n-1} s^{n-1} + ... + a_0.",
                                    "Liste todos os coeficientes a_n, a_{n-1}, ..., a_0, incluindo zeros se necessário.",
                                    "Determine o grau n do polinômio.",
                                    "Verifique se todos os coeficientes estão corretos, sem erros de sinal ou transcrição."
                                  ],
                                  "verification": "Coeficientes listados em ordem correta e grau n identificado precisamente.",
                                  "estimatedTime": "10 minutos",
                                  "materials": [
                                    "Papel quadriculado",
                                    "Caneta",
                                    "Exemplo de polinômio impresso"
                                  ],
                                  "tips": "Preencha lacunas com coeficientes zero para polinômios incompletos.",
                                  "learningObjective": "Organizar dados iniciais do polinômio de forma precisa para construção da tabela.",
                                  "commonMistakes": [
                                    "Inverter ordem dos coeficientes",
                                    "Esquecer termos de coeficiente zero",
                                    "Erros de sinal nos coeficientes"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Construir as duas primeiras linhas da tabela de Routh",
                                  "subSteps": [
                                    "Crie a linha s^n com os coeficientes dos termos ímpares: a_n, a_{n-2}, a_{n-4}, ...",
                                    "Crie a linha s^{n-1} com os coeficientes dos termos pares: a_{n-1}, a_{n-3}, a_{n-5}, ...",
                                    "Alinhe as linhas em colunas: primeira coluna (s^n e s^{n-1}), segunda coluna, etc.",
                                    "Certifique-se de que o número de elementos em cada linha seja consistente (preencha com zero se necessário).",
                                    "Rotule as linhas com as potências de s correspondentes."
                                  ],
                                  "verification": "Primeiras duas linhas montadas corretamente, alinhadas e rotuladas.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Papel quadriculado",
                                    "Régua para alinhamento",
                                    "Calculadora para contagem"
                                  ],
                                  "tips": "Comece sempre pela primeira coluna; ímpares na primeira linha, pares na segunda.",
                                  "learningObjective": "Montar a estrutura inicial da tabela seguindo a convenção padrão de Routh.",
                                  "commonMistakes": [
                                    "Confundir ímpares com pares",
                                    "Desalinhar colunas",
                                    "Esquecer preenchimento com zero"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular linhas subsequentes usando a regra de Routh",
                                  "subSteps": [
                                    "Para a terceira linha (s^{n-2}), calcule o primeiro elemento: - (det| b11 b12 ; b21 b22 |) / b21, onde b são elementos das linhas anteriores.",
                                    "Continue para os elementos subsequentes da linha usando a mesma fórmula de determinante para cada par de colunas.",
                                    "Repita o processo para linhas seguintes até alcançar a linha s^0.",
                                    "Arredonde ou mantenha precisão decimal adequada em cálculos.",
                                    "Verifique aritmeticamente cada elemento calculado."
                                  ],
                                  "verification": "Todas as linhas calculadas até s^0 sem erros aritméticos evidentes.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Calculadora científica",
                                    "Papel para cálculos intermediários"
                                  ],
                                  "tips": "Use a fórmula: elemento = -1 / (primeiro da linha anterior) * det da matriz 2x2.",
                                  "learningObjective": "Aplicar corretamente a recursão matemática para gerar linhas da tabela.",
                                  "commonMistakes": [
                                    "Erro no sinal negativo",
                                    "Dividir pelo elemento errado",
                                    "Mau cálculo de determinantes"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Identificar e tratar elementos auxiliares (casos especiais)",
                                  "subSteps": [
                                    "Verifique se uma linha inteira é zero: substitua por derivada da linha anterior.",
                                    "Se o primeiro elemento de uma linha for zero: substitua por ε pequeno e limite ε→0.",
                                    "Aplique o procedimento auxiliar para linhas zero: derive polinômio auxiliar da linha anterior.",
                                    "Recalcule linhas afetadas após correção.",
                                    "Documente o caso especial aplicado e verifique continuidade da tabela."
                                  ],
                                  "verification": "Casos especiais tratados corretamente, com tabela completa e consistente.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Calculadora",
                                    "Tabela de referência de casos Routh"
                                  ],
                                  "tips": "Para linha zero, derive em relação a uma variável λ e tome coeficientes.",
                                  "learningObjective": "Gerenciar exceções na construção da tabela para polinômios problemáticos.",
                                  "commonMistakes": [
                                    "Ignorar casos especiais",
                                    "Derivada incorreta",
                                    "Não recacular linhas subsequentes"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Finalizar e validar a tabela de Routh",
                                  "subSteps": [
                                    "Complete a tabela até a linha s^0.",
                                    "Conte o número de mudanças de sinal na primeira coluna.",
                                    "Verifique se o último elemento é igual ao coeficiente constante a_0.",
                                    "Confira todos os cálculos cruzando com software se disponível.",
                                    "Anote observações sobre estabilidade preliminar."
                                  ],
                                  "verification": "Tabela final completa, com último elemento = a_0 e sem inconsistências.",
                                  "estimatedTime": "10 minutos",
                                  "materials": [
                                    "Software MATLAB/Python opcional para verificação"
                                  ],
                                  "tips": "O elemento final deve coincidir com a_0 se não houver rearranjos.",
                                  "learningObjective": "Validar a integridade da tabela construída.",
                                  "commonMistakes": [
                                    "Parar prematuramente",
                                    "Ignorar verificação do último elemento",
                                    "Erros acumulados não detectados"
                                  ]
                                }
                              ],
                              "practicalExample": "Para o polinômio s^3 + 3s^2 + 2s + 1: Linha s^3: 1, 2; s^2: 3, 1; s^1: (3*2-1*1)/3 = 5/3, 0; s^0: 1. Sem casos especiais, primeira coluna: 1,3,5/3,1 (sem mudanças de sinal, estável).",
                              "finalVerifications": [
                                "Primeira coluna sem elementos zero não tratados.",
                                "Último elemento da tabela igual a a_0.",
                                "Número de colunas consistente em todas as linhas.",
                                "Cálculos aritméticos exatos ou precisos (erro < 0.01).",
                                "Casos especiais documentados e resolvidos.",
                                "Mudanças de sinal contadas corretamente na primeira coluna."
                              ],
                              "assessmentCriteria": [
                                "Precisão na listagem de coeficientes (100% correto).",
                                "Correta aplicação da fórmula recursiva em todas as linhas.",
                                "Tratamento adequado de casos especiais quando aplicável.",
                                "Verificação final completa e consistente.",
                                "Clareza na apresentação da tabela (alinhamento, rótulos).",
                                "Tempo de execução dentro do estimado."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Álgebra polinomial e determinantes.",
                                "Programação: Implementação do algoritmo Routh em Python ou MATLAB.",
                                "Física: Análise de estabilidade em sistemas dinâmicos oscilatórios.",
                                "Engenharia de Software: Verificação automatizada de controladores."
                              ],
                              "realWorldApplication": "Na engenharia de controle, a tabela de Routh é usada para verificar rapidamente a estabilidade de controladores em drones, robôs industriais e sistemas automotivos, evitando simulações computacionais caras e identificando polos no semiplano direito sem calcular raízes."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.1.1.1.1"
                            ]
                          },
                          {
                            "id": "10.1.1.1.2.2",
                            "name": "Interpretar a tabela de Routh para estabilidade",
                            "description": "Analisar a primeira coluna da tabela de Routh para contar mudanças de sinal e determinar o número de polos no semiplano direito, concluindo sobre a estabilidade do sistema.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Verificar a completude e precisão da tabela de Routh",
                                  "subSteps": [
                                    "Confirme que a tabela foi construída com todos os coeficientes do polinômio característico na primeira e segunda linhas.",
                                    "Verifique a ausência de linhas inteiramente zero ou entradas indefinidas, resolvendo casos especiais se necessário (ex: multiplicar por s^k).",
                                    "Realize uma checagem aritmética rápida das entradas subsequentes para garantir precisão.",
                                    "Certifique-se de que a tabela está completa até a linha final com um único elemento.",
                                    "Anote qualquer irregularidade para análise posterior."
                                  ],
                                  "verification": "A tabela está livre de erros aritméticos e casos especiais resolvidos corretamente, confirmada por recálculo manual de uma linha.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Folha com tabela de Routh",
                                    "Calculadora científica",
                                    "Referência ao critério de Routh-Hurwitz"
                                  ],
                                  "tips": "Comece sempre pela linha inicial e desça linha por linha para evitar erros cumulativos.",
                                  "learningObjective": "Assegurar que a base da interpretação é confiável, evitando conclusões erradas por falhas na construção.",
                                  "commonMistakes": [
                                    "Ignorar linhas zero sem aplicar o método auxiliar",
                                    "Erros de sinal ao calcular determinants",
                                    "Parar a tabela prematuramente"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar e extrair a primeira coluna da tabela",
                                  "subSteps": [
                                    "Localize a coluna extrema esquerda da tabela de Routh.",
                                    "Liste sequencialmente todos os elementos dessa coluna, do topo à base.",
                                    "Registre os valores exatos, incluindo sinais e zeros.",
                                    "Ignore elementos nulos para contagem de sinais, mas anote sua posição.",
                                    "Transcreva a lista em um papel separado para análise visual clara."
                                  ],
                                  "verification": "Lista da primeira coluna corresponde exatamente aos valores da tabela original.",
                                  "estimatedTime": "10 minutos",
                                  "materials": [
                                    "Tabela de Routh",
                                    "Papel para transcrição",
                                    "Lápis e borracha"
                                  ],
                                  "tips": "Use negrito ou sublinhe para destacar sinais positivos (+) e negativos (-).",
                                  "learningObjective": "Dominar a extração precisa da coluna crítica para análise de estabilidade.",
                                  "commonMistakes": [
                                    "Confundir colunas adjacentes",
                                    "Omitir elementos finais da lista",
                                    "Ignorar zeros na transcrição"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Detectar e contar mudanças de sinal na primeira coluna",
                                  "subSteps": [
                                    "Examine os sinais consecutivos da lista da primeira coluna de cima para baixo.",
                                    "Identifique cada transição de + para - ou de - para + como uma mudança de sinal.",
                                    "Conte o número total de tais transições, pulando zeros (trate zero como sem sinal para contagem).",
                                    "Marque cada mudança com uma seta ou número no papel.",
                                    "Registre o número final de mudanças de sinal."
                                  ],
                                  "verification": "Número de mudanças de sinal contado corretamente, validado por revisão dupla.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Lista da primeira coluna",
                                    "Marcadores coloridos para sinais"
                                  ],
                                  "tips": "Leia em voz alta os sinais sequenciais para detectar padrões auditivamente.",
                                  "learningObjective": "Aplicar o princípio fundamental do critério de Routh para quantificar instabilidades potenciais.",
                                  "commonMistakes": [
                                    "Contar zeros como mudanças",
                                    "Perder transições em sequências longas",
                                    "Confundir direção da contagem"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Interpretar o número de mudanças e concluir sobre estabilidade",
                                  "subSteps": [
                                    "Relacione o número de mudanças de sinal ao número de polos no semiplano direito (RHP).",
                                    "Conclua: 0 mudanças = sistema estável; >0 = instável com N polos RHP; linha zero indica polos imaginários puros.",
                                    "Escreva uma declaração clara de estabilidade (ex: 'Estável' ou 'Instável com 2 polos RHP').",
                                    "Discuta implicações para o sistema de controle.",
                                    "Compare com outros métodos (ex: Raízes) se disponível para validação."
                                  ],
                                  "verification": "Conclusão de estabilidade alinhada com o número de mudanças de sinal e teoria.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Lista com contagem",
                                    "Tabela original",
                                    "Software de polos (opcional como MATLAB)"
                                  ],
                                  "tips": "Lembre: estabilidade requer todos os polos no semiplano esquerdo (sem RHP).",
                                  "learningObjective": "Traduzir análise quantitativa em julgamento qualitativo de estabilidade do sistema.",
                                  "commonMistakes": [
                                    "Interpretar 0 mudanças como instável",
                                    "Confundir polos RHP com semiplano esquerdo",
                                    "Ignorar casos especiais como oscilações"
                                  ]
                                }
                              ],
                              "practicalExample": "Para o polinômio característico s^3 + s^2 + 2s + 3 = 0, a tabela de Routh tem primeira coluna: 1, 1, -0.5, 3. Sinais: +, +, -, +. Mudanças de sinal: duas (de + para - na linha 3, e de - para + na linha 4). Conclusão: 2 polos no semiplano direito → sistema instável.",
                              "finalVerifications": [
                                "Lista correta da primeira coluna extraída sem erros.",
                                "Mudanças de sinal contadas precisamente para exemplos dados.",
                                "Conclusão de estabilidade (estável/instável) justificada corretamente.",
                                "Casos especiais (linhas zero) identificados e tratados.",
                                "Interpretação consistente com número de polos RHP.",
                                "Validação cruzada com gráfico de raízes ou outro método."
                              ],
                              "assessmentCriteria": [
                                "Precisão na extração e listagem da primeira coluna (20%).",
                                "Correta detecção e contagem de mudanças de sinal (30%).",
                                "Interpretação lógica e conclusão de estabilidade (25%).",
                                "Tratamento de casos especiais e verificações (15%).",
                                "Clareza na documentação e justificativa (10%)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Análise de polinômios e contagem de raízes.",
                                "Física: Dinâmica de sistemas lineares e oscilações.",
                                "Informática: Implementação em MATLAB/Simulink para simulações.",
                                "Engenharia Mecânica: Análise de estabilidade em vibrações.",
                                "Estatística: Análise de incertezas em coeficientes de sistemas reais."
                              ],
                              "realWorldApplication": "Em engenharia aeroespacial, interpretar a tabela de Routh garante a estabilidade de sistemas de controle de voo em aviões, evitando oscilações perigosas que poderiam levar a falhas catastróficas, como visto em controladores PID para estabilização de drones ou mísseis."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.1.1.2.1"
                            ]
                          },
                          {
                            "id": "10.1.1.1.2.3",
                            "name": "Tratar casos especiais na tabela de Routh",
                            "description": "Resolver situações de linha zero ou toda zero na tabela utilizando polinômios auxiliares e derivadas, mantendo a análise de estabilidade intacta.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Identificar casos especiais na tabela de Routh",
                                  "subSteps": [
                                    "Construa a tabela de Routh inicial a partir do polinômio característico.",
                                    "Examine cada linha da tabela sequencialmente de cima para baixo.",
                                    "Identifique se uma linha inteira é zero ou se o primeiro elemento de uma linha é zero.",
                                    "Registre o tipo de caso especial encontrado (linha toda zero ou primeiro elemento zero)."
                                  ],
                                  "verification": "Confirme que todas as linhas até o ponto problemático foram calculadas corretamente e anote o tipo de irregularidade.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Papel quadriculado, calculadora científica, tabela de Routh em branco.",
                                  "tips": "Sempre verifique os cálculos aritméticos duas vezes antes de declarar um caso especial.",
                                  "learningObjective": "Reconhecer precisamente os dois tipos principais de casos especiais na tabela de Routh.",
                                  "commonMistakes": "Confundir erro de cálculo aritmético com caso especial; ignorar linhas anteriores."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Tratar o caso de linha toda zero",
                                  "subSteps": [
                                    "Forme o polinômio auxiliar usando os coeficientes da linha imediatamente superior à linha zero.",
                                    "Calcule a derivada do polinômio auxiliar em relação a s.",
                                    "Substitua os coeficientes da derivada na linha zero, ajustando o sinal se necessário (negativo para ordem par).",
                                    "Preencha a linha seguinte usando as regras padrão de Routh."
                                  ],
                                  "verification": "A linha zero agora tem valores não-zero derivados corretamente; prossiga para linhas subsequentes sem zeros.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Papel para derivadas, calculadora para simplificação polinomial.",
                                  "tips": "Lembre-se: o polinômio auxiliar tem grau igual ao da linha superior; grau diminui na derivada.",
                                  "learningObjective": "Aplicar o polinômio auxiliar e sua derivada para resolver linhas toda zero.",
                                  "commonMistakes": "Esquecer de inverter o sinal para derivadas de ordem par; formar polinômio errado."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Tratar o caso de primeiro elemento zero (com outros elementos não-zero)",
                                  "subSteps": [
                                    "Substitua o zero inicial por um parâmetro ε pequeno e positivo.",
                                    "Complete a tabela de Routh usando ε nos cálculos subsequentes.",
                                    "Analise o sinal dos elementos na primeira coluna à medida que ε tende a zero.",
                                    "Conclua a contagem de mudanças de sinal após limitar ε → 0."
                                  ],
                                  "verification": "A tabela completa mostra mudanças de sinal consistentes independentemente do pequeno ε.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Calculadora simbólica ou software como MATLAB para limites.",
                                  "tips": "Use ε = 0.001 para cálculos numéricos práticos; foque apenas na primeira coluna.",
                                  "learningObjective": "Resolver zeros isolados na primeira coluna sem alterar a estabilidade.",
                                  "commonMistakes": "Alterar outros elementos da linha; ignorar o limite ε → 0."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Completar a tabela e analisar estabilidade",
                                  "subSteps": [
                                    "Preencha todas as linhas restantes usando as regras padrão de Routh.",
                                    "Conte o número de mudanças de sinal na primeira coluna.",
                                    "Determine o número de polos no semiplano direito (igual ao número de mudanças).",
                                    "Verifique se o sistema é estável (zero mudanças de sinal)."
                                  ],
                                  "verification": "Tabela completa sem irregularidades; número de instabilidades correto.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Tabela final impressa ou digital para revisão.",
                                  "tips": "Recapitule a tabela inteira para consistência antes de concluir.",
                                  "learningObjective": "Integrar correções e extrair análise de estabilidade precisa.",
                                  "commonMistakes": "Perder mudanças de sinal após correções; não verificar linhas finais."
                                }
                              ],
                              "practicalExample": "Para o polinômio s^4 + 2s^3 + 3s^2 + 4s + 1 = 0, a terceira linha resulta toda zero. Forme auxiliar da segunda linha: 2s^3 + 3s^2 + 4s + 1, derivada: 6s^2 + 6s + 4. Substitua na terceira linha: 6, 6, 4 (ajustado). Complete tabela: 1 mudança de sinal → 1 polo instável.",
                              "finalVerifications": [
                                "Tabela de Routh completa sem linhas zero pendentes.",
                                "Coeficientes do polinômio auxiliar e derivada calculados corretamente.",
                                "Número de mudanças de sinal na primeira coluna determinado.",
                                "Conclusão de estabilidade (estável/instável) justificada.",
                                "Exemplo prático resolvido com resultado consistente.",
                                "Todos os passos documentados com cálculos mostrados."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de casos especiais (100% correto).",
                                "Correta formação e derivação do polinômio auxiliar.",
                                "Manejo adequado de ε para zeros na primeira coluna.",
                                "Contagem precisa de mudanças de sinal e análise de estabilidade.",
                                "Clareza na documentação de subpassos e verificações.",
                                "Eficiência temporal dentro dos estimados."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Cálculo de derivadas e manipulação polinomial.",
                                "Programação: Implementação algorítmica em MATLAB/Python para automação Routh.",
                                "Física: Modelagem de sistemas dinâmicos lineares (osciladores).",
                                "Engenharia Elétrica: Análise de estabilidade em circuitos de feedback."
                              ],
                              "realWorldApplication": "Em controle de drones, tratar casos especiais garante detecção precisa de instabilidades em atuadores, evitando crashes; usado em projetos de automação industrial para estabilizar linhas de produção."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.1.1.2.1"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "10.1.1.1.3",
                        "name": "Critério de Nyquist",
                        "description": "Método gráfico no domínio da frequência para análise de estabilidade de sistemas LIT escalares, utilizando o diagrama de Nyquist da função de malha aberta e contagem de encirclements do ponto crítico (-1, j0).",
                        "specificSkills": [
                          {
                            "id": "10.1.1.1.3.1",
                            "name": "Construir o diagrama de Nyquist",
                            "description": "Plotar o diagrama de Nyquist para a função de transferência de malha aberta G(s)H(s), considerando o contorno do semiplano direito e indentando polos/jzeros no eixo imaginário.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Analisar a função de transferência de malha aberta G(s)H(s)",
                                  "subSteps": [
                                    "Escreva explicitamente G(s)H(s) na forma racional.",
                                    "Fatore o numerador e denominador para identificar zeros e polos.",
                                    "Localize polos e zeros no plano complexo, destacando aqueles no eixo imaginário.",
                                    "Conte o número de polos instáveis (no semiplano direito, P).",
                                    "Avalie o comportamento assintótico: limite para ω→0 e ω→∞."
                                  ],
                                  "verification": "Lista completa e correta de polos, zeros e P anotada em um esboço inicial.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Função G(s)H(s) fornecida",
                                    "Papel quadriculado",
                                    "Calculadora ou software simbólico como SymPy/MATLAB"
                                  ],
                                  "tips": [
                                    "Expresse G(s)H(s) em termos de fatores (s+p) para facilitar cálculos manuais.",
                                    "Anote magnitudes e fases iniciais para referência rápida."
                                  ],
                                  "learningObjective": "Identificar todas as singularidades e comportamentos limites da função de loop aberto.",
                                  "commonMistakes": [
                                    "Esquecer o termo H(s) se for não-trivial.",
                                    "Confundir zeros com polos.",
                                    "Ignorar polos de ordem superior."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Plotar a curva de Nyquist para frequências positivas (ω de 0 a ∞)",
                                  "subSteps": [
                                    "Substitua s = jω em G(jω)H(jω) para obter Re(ω) + jIm(ω).",
                                    "Calcule pontos chave: ω=0+, ω→∞, frequências de pico de magnitude e fase.",
                                    "Plote pelo menos 10-15 pontos equidistantes em escala logarítmica de ω.",
                                    "Conecte os pontos com curvas suaves, indicando setas de direção crescente ω.",
                                    "Rotule magnitude |G(jω)H(jω)| e fase ∠G(jω)H(jω) em pontos críticos."
                                  ],
                                  "verification": "Gráfico paramétrico com eixos Re e Im corretamente plotado e rotulado para ω ≥ 0.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Tabela de valores de ω calculados",
                                    "Software de plotagem (MATLAB nyquist() ou Python control.nyquist_plot)",
                                    "Papel polar ou cartesiano ampliado"
                                  ],
                                  "tips": [
                                    "Use escala log para ω para capturar dinâmicas em baixas e altas frequências.",
                                    "Verifique simetria: para sistemas reais, Im(ω) é ímpar."
                                  ],
                                  "learningObjective": "Construir a imagem conforme do semiplano superior sob G(s)H(s).",
                                  "commonMistakes": [
                                    "Plotar em escala linear de ω, perdendo detalhes.",
                                    "Esquecer setas de direção.",
                                    "Erro de sinal na fase."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Completar a curva para frequências negativas (ω de -∞ a 0)",
                                  "subSteps": [
                                    "Aplique a propriedade de simetria: para ω < 0, G(jω)H(jω) é o complexo conjugado de ω > 0.",
                                    "Plote o espelho da curva positiva sobre o eixo real.",
                                    "Conecte ω=0- a ω=0+ se houver polo em s=0.",
                                    "Indique setas de direção decrescente |ω|.",
                                    "Verifique continuidade no ponto ω=0."
                                  ],
                                  "verification": "Curva simétrica completa, fechando no ponto DC (ω=0).",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Curva de ω > 0 já plotada",
                                    "Régua para simetria"
                                  ],
                                  "tips": [
                                    "Copie a curva positiva e reflita verticalmente para eficiência.",
                                    "Para sistemas não mínimos de fase, confirme com cálculos."
                                  ],
                                  "learningObjective": "Entender a simetria hermitiana de funções de transferência reais.",
                                  "commonMistakes": [
                                    "Refletir incorretamente (horizontal em vez de vertical).",
                                    "Ignorar indentação em ω=0."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Fechar o contorno com arco infinito e indentar singularidades no eixo jω",
                                  "subSteps": [
                                    "Adicione semicírculo de raio ∞ no semiplano direito (RHP): mapeia para origem se #polos > #zeros no RHP.",
                                    "Para polos no eixo jω, insira indentação semicircular pequena (ε→0) no RHP.",
                                    "Para zeros no eixo jω, indentação no LHP (mas foco em polos para Nyquist).",
                                    "Mapeie a indentação: para polo simples em jω0, arco de -90° a +90° centrado na origem.",
                                    "Conecte todas as partes formando contorno fechado D."
                                  ],
                                  "verification": "Contorno fechado completo, incluindo arco ∞ e indentções, sem quebras.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Diagrama parcial",
                                    "Referência teórica de mapeamento de indentação"
                                  ],
                                  "tips": [
                                    "Arco de indentação polo: G(s) ~ 1/(s - jω0), arg varia π/2.",
                                    "Use setas para mostrar orientação anti-horária."
                                  ],
                                  "learningObjective": "Construir o contorno D que evita singularidades e encerra o RHP.",
                                  "commonMistakes": [
                                    "Indentação no lado errado (LHP para polos).",
                                    "Esquecer arco ∞.",
                                    "Direção horária errada."
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Finalizar e validar o diagrama de Nyquist",
                                  "subSteps": [
                                    "Rotule todos os elementos: curvas, indentções, arco ∞, pontos críticos (-1,0).",
                                    "Conte encirclamentos N do ponto crítico (-1/jK, 0).",
                                    "Verifique critério: Z = P + N (zeros no RHP).",
                                    "Compare com plot gerado por software para validação.",
                                    "Anote conclusões sobre estabilidade."
                                  ],
                                  "verification": "Diagrama rotulado com contagem de N e análise de estabilidade.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Software de verificação (MATLAB/Python)",
                                    "Folha de verificação"
                                  ],
                                  "tips": [
                                    "Ponto crítico é (-1/K, 0) para ganho K; assuma K=1 se não especificado.",
                                    "N positivo para anti-horário."
                                  ],
                                  "learningObjective": "Aplicar o critério de Nyquist para análise de estabilidade.",
                                  "commonMistakes": [
                                    "Contar encirclamentos errados.",
                                    "Confundir N com P."
                                  ]
                                }
                              ],
                              "practicalExample": "Para G(s)H(s) = 1 / (s(s+1)), polos em 0 e -1. Curva ω>0 inicia em ∞∠-90° (ω=0+), assinta a 0∠-180° (ω→∞). Simetria reflete para ω<0. Indentação em s=0: semicírculo unitário de -90° a +90°. Arco ∞ mapeia a 0. N=0, P=0 → estável.",
                              "finalVerifications": [
                                "Curva ω>0 corretamente assintótica e com pontos chave precisos.",
                                "Simetria perfeita para ω<0.",
                                "Indentação em polos jω com arco de 90° no RHP.",
                                "Arco ∞ mapeado corretamente (raio →0 se deg(den) > deg(num)).",
                                "Contorno fecha anti-horário sem singularidades internas.",
                                "Ponto (-1,0) encirclamentos contados corretamente."
                              ],
                              "assessmentCriteria": [
                                "Precisão numérica nos cálculos de Re/Im (erro <5%).",
                                "Correta representação de indentções e arco ∞.",
                                "Rotulação completa e legível.",
                                "Aplicação correta do critério de Nyquist (Z=P+N).",
                                "Validação cruzada com software.",
                                "Explicação clara da construção em relatório."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Mapeamento conforme e análise de funções complexas.",
                                "Programação: Implementação numérica em MATLAB (nyquist()) ou Python (control library).",
                                "Física: Análise de estabilidade em osciladores e servomecanismos.",
                                "Engenharia de Software: Automação de plots para design iterativo de controladores."
                              ],
                              "realWorldApplication": "Em controle de aviões (estabilidade de autopilot), robótica (loops de posição) e processos industriais (reguladores PID), o diagrama de Nyquist permite verificar estabilidade robusta sem simulações demoradas em tempo real, ajustando ganhos para evitar oscilações catastróficas."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.1.1.1.2"
                            ]
                          },
                          {
                            "id": "10.1.1.1.3.2",
                            "name": "Aplicar o critério de Nyquist para estabilidade",
                            "description": "Contar o número de encirclements (N) do ponto (-1, j0) no diagrama de Nyquist e relacionar com o número de polos instáveis de malha aberta (P) para calcular Z = P + N, verificando se Z=0 para estabilidade.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Identificar a função de malha aberta e determinar o número de polos instáveis (P)",
                                  "subSteps": [
                                    "Escreva a função de transferência de malha aberta G(s)H(s).",
                                    "Localize todos os polos de G(s)H(s) resolvendo o denominador igual a zero.",
                                    "Classifique os polos como instáveis (parte real positiva) e conte P.",
                                    "Verifique se há polos no semiplano direito (Re(s) > 0).",
                                    "Anote P e liste os polos instáveis."
                                  ],
                                  "verification": "Confirme que P está corretamente contado comparando com análise de Routh-Hurwitz ou raiz locus.",
                                  "estimatedTime": "15-20 minutos",
                                  "materials": [
                                    "Função de transferência G(s)H(s)",
                                    "Tabela de polos",
                                    "Software como MATLAB para polos (opcional)"
                                  ],
                                  "tips": "Comece sempre pela expansão do denominador para fatorar facilmente.",
                                  "learningObjective": "Dominar a identificação precisa de polos instáveis na função de malha aberta.",
                                  "commonMistakes": [
                                    "Confundir polos de malha aberta com zeros",
                                    "Ignorar polos de ordem múltipla",
                                    "Contar polos no eixo imaginário como instáveis"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Construir o diagrama de Nyquist para G(jω)",
                                  "subSteps": [
                                    "Substitua s = jω na função G(s)H(s) para obter G(jω) = Re + jIm.",
                                    "Calcule magnitude |G(jω)| e fase arg(G(jω)) para ω de 0 a ∞.",
                                    "Plote o contorno no plano complexo: parte real vs. imaginária.",
                                    "Complete o diagrama para ω negativo espelhando (se sistema real).",
                                    "Marque o ponto crítico (-1, j0) no diagrama."
                                  ],
                                  "verification": "Verifique se o diagrama passa corretamente por ω=0 e ω=∞, e é simétrico.",
                                  "estimatedTime": "30-45 minutos",
                                  "materials": [
                                    "Papel milimetrado ou software (MATLAB nyquist() ou Python control library)",
                                    "Tabela de valores ω",
                                    "Calculadora científica"
                                  ],
                                  "tips": "Use ω logarítmico para cobrir faixas amplas eficientemente.",
                                  "learningObjective": "Construir com precisão o diagrama de Nyquist a partir de G(jω).",
                                  "commonMistakes": [
                                    "Esquecer o espelhamento para ω<0",
                                    "Erro em cálculos trigonométricos de fase",
                                    "Não indentificar indentação em polos/jzeros no eixo jω"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Contar o número de encirclements (N) do ponto crítico (-1, j0)",
                                  "subSteps": [
                                    "Trace o contorno de Nyquist no sentido horário com ω crescente.",
                                    "Observe rotações completas (360°) ao redor de (-1, j0).",
                                    "Conte N positivo para anti-horário, negativo para horário.",
                                    "Use a regra: cada loop completo ao redor conta como ±1.",
                                    "Confirme com zoom ou cálculo de mudança de argumento."
                                  ],
                                  "verification": "Simule ou trace manualmente e compare contagem com software.",
                                  "estimatedTime": "20-30 minutos",
                                  "materials": [
                                    "Diagrama de Nyquist plotado",
                                    "Régua e compasso para medir rotações"
                                  ],
                                  "tips": "Amplie a região perto de (-1,0) para contagem precisa.",
                                  "learningObjective": "Analisar visualmente e contar encirclements corretamente.",
                                  "commonMistakes": [
                                    "Confundir direção de rotação",
                                    "Contar apenas loops grandes ignorando pequenos",
                                    "Não considerar indentação em ω=∞"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar a fórmula Z = P + N e concluir sobre estabilidade",
                                  "subSteps": [
                                    "Some Z = P (do step 1) + N (do step 3).",
                                    "Verifique se Z = 0: se sim, sistema estável; senão, instável.",
                                    "Interprete: Z é número de zeros de malha fechada no semiplano direito.",
                                    "Documente a conclusão com justificativa.",
                                    "Teste com variação de ganho K se aplicável."
                                  ],
                                  "verification": "Compare com simulação de resposta ao degrau ou lugar das raízes.",
                                  "estimatedTime": "10-15 minutos",
                                  "materials": [
                                    "Resultados dos steps anteriores",
                                    "Folha de cálculos"
                                  ],
                                  "tips": "Lembre: convenção padrão é N positivo para anti-horário.",
                                  "learningObjective": "Aplicar corretamente o teorema de Nyquist para julgar estabilidade.",
                                  "commonMistakes": [
                                    "Inverter sinal de N",
                                    "Esquecer P em sistemas com polos instáveis",
                                    "Concluir estabilidade sem Z=0"
                                  ]
                                }
                              ],
                              "practicalExample": "Para G(s)H(s) = 10 / (s(s+1)(s+10)), polos em 0, -1, -10 (P=0). Diagrama de Nyquist não cerca (-1,0) (N=0), Z=0 → estável. Se K=100, cerca uma vez anti-horário (N=1), Z=1 → instável.",
                              "finalVerifications": [
                                "Construir Nyquist corretamente para um sistema dado.",
                                "Identificar P=1 para G(s)=1/(s-1).",
                                "Contar N=-2 em um diagrama fornecido.",
                                "Concluir estabilidade corretamente para 3 exemplos variados.",
                                "Explicar por que Z≠0 implica instabilidade.",
                                "Aplicar a sistemas com polos instáveis abertos estáveis."
                              ],
                              "assessmentCriteria": [
                                "Precisão na contagem de P e N (100% correto).",
                                "Diagrama de Nyquist completo e rotulado.",
                                "Cálculo correto de Z e conclusão lógica.",
                                "Identificação de erros comuns evitados.",
                                "Explicação clara da aplicação do critério.",
                                "Tempo de execução dentro do estimado."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Análise de funções complexas e teorema do argumento.",
                                "Física: Dinâmica de sistemas oscilatórios e estabilidade.",
                                "Programação: Simulação numérica com MATLAB/Python (biblioteca control).",
                                "Eletrônica: Análise de filtros e amplificadores de realimentação.",
                                "Engenharia Mecânica: Controle de vibrações em estruturas."
                              ],
                              "realWorldApplication": "Em controle de drones, aplica-se Nyquist para garantir que o controlador de atitude não cause oscilações instáveis durante voo, evitando crashes; ou em usinas termelétricas para estabilizar turbinas geradoras."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.1.1.3.1"
                            ]
                          },
                          {
                            "id": "10.1.1.1.3.3",
                            "name": "Analisar estabilidade com Nyquist para sistemas com integradores",
                            "description": "Aplicar o critério de Nyquist em sistemas com polos em s=0 ou no eixo imaginário, calculando margens de estabilidade e interpretando o comportamento em baixas frequências.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Critério de Nyquist Padrão e Identificar Impacto de Integradores",
                                  "subSteps": [
                                    "Recordar o critério de Nyquist: número de encirclements N = Z - P, onde Z são zeros instáveis da função de malha aberta e P são polos instáveis.",
                                    "Identificar que integradores adicionam polos em s=0, localizados na origem do plano s.",
                                    "Explicar que polos em s=0 requerem modificação do contour de Nyquist com uma indentação semicircular de raio ε→0 à direita da origem.",
                                    "Analisar o comportamento da função de transferência G(jω) quando ω→0: para integrador puro, |G(jω)|→∞ e arg(G(jω))→-90°.",
                                    "Estudar o mapeamento da indentação semicircular: para polo simples em s=0, resulta em arco de -90° a +90° no plano G(s)."
                                  ],
                                  "verification": "Desenhar manualmente o contour modificado no plano s e descrever seu mapeamento qualitativo no plano Nyquist.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Livro-texto de Controle (ex: Ogata ou Franklin)",
                                    "Folha de papel quadriculado",
                                    "Software MATLAB ou Python (Control Systems Toolbox)"
                                  ],
                                  "tips": "Sempre verifique o número de polos em s=0 (tipo do sistema) para prever o ângulo da indentação.",
                                  "learningObjective": "Compreender as modificações necessárias no contour de Nyquist devido a integradores e seu impacto no diagrama.",
                                  "commonMistakes": [
                                    "Esquecer de contar polos em s=0 como instáveis para P",
                                    "Não indentar o contour corretamente",
                                    "Ignorar fase em baixas frequências"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Construir e Plotar o Diagrama de Nyquist para Sistemas com Integradores",
                                  "subSteps": [
                                    "Escrever a função de transferência de malha aberta G(s)H(s) e identificar polos/polos em s=0 ou eixo imaginário.",
                                    "Definir o contour D: eixo jω de -j∞ a +j∞ com indentação semicircular em s=0 e semicírculo infinito.",
                                    "Calcular G(jω) para ω de 0+ a ∞, focando em assíntotas: para integrador, Nyquist inicia em ∞ no eixo negativo imaginário.",
                                    "Plotar numericamente usando software: gerar ω logspace, calcular real/imag de G(jω), plotar diagrama.",
                                    "Adicionar mapeamento da indentação: arco de 270° no sentido horário para polo simples em origem."
                                  ],
                                  "verification": "Gerar e inspecionar o plot de Nyquist, confirmando que a curva parte de |G|→∞ em fase -90°.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "MATLAB/Simulink ou Python (biblioteca control)",
                                    "Exemplos de funções de transferência com integrador"
                                  ],
                                  "tips": "Use escala log-log para ω para capturar melhor baixas frequências; zoom no comportamento perto da origem.",
                                  "learningObjective": "Dominar a construção precisa do diagrama de Nyquist, incluindo partes modificadas por integradores.",
                                  "commonMistakes": [
                                    "Plotar sem considerar ω→0 adequadamente",
                                    "Confundir direção do arco da indentação",
                                    "Omitir semicírculo em |s|→∞"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar Encirclements e Determinar Estabilidade",
                                  "subSteps": [
                                    "Localizar o ponto crítico (-1,0) no diagrama de Nyquist.",
                                    "Contar encirclements N do ponto -1+j0 pela curva Nyquist (sentido anti-horário positivo).",
                                    "Calcular Z = N + P, onde P inclui polos em s=0 como instáveis temporariamente.",
                                    "Interpretar: se Z=0, sistema estável; analisar interseções com eixo real para estabilidade relativa.",
                                    "Verificar comportamento em baixas frequências: curva deve evitar -1 sem encirclements indesejados."
                                  ],
                                  "verification": "Para um exemplo dado, calcular N e concluir corretamente sobre estabilidade absoluta.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Diagrama de Nyquist plotado",
                                    "Tabela de contorno de valores de G(jω)"
                                  ],
                                  "tips": "Use seta direcional na curva para contar encirclements corretamente; pratique com casos limítrofes.",
                                  "learningObjective": "Aplicar o critério de Nyquist para julgar estabilidade em sistemas com integradores.",
                                  "commonMistakes": [
                                    "Contar encirclements no sentido errado",
                                    "Não ajustar P para polos em origem",
                                    "Ignorar múltiplos integradores (arco maior)"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Calcular Margens de Estabilidade e Interpretar Comportamento",
                                  "subSteps": [
                                    "Identificar frequência de ganho ω_g onde |G(jω_g)|=1 e calcular margem de fase PM = 180° + arg(G(jω_g)).",
                                    "Encontrar frequência de fase ω_p onde arg(G(jω_p))=-180° e margem de ganho GM = 1/|G(jω_p)| (em dB).",
                                    "Analisar baixa frequência: para integradores, GM tipicamente infinita se não oscila.",
                                    "Interpretar: PM > 45° e GM > 6dB indicam boa estabilidade relativa.",
                                    "Simular resposta temporal para validar análise Nyquist."
                                  ],
                                  "verification": "Calcular GM e PM numericamente e compará-los com simulação de step response.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Software de simulação (MATLAB bode/nyquist/step)",
                                    "Calculadora ou script Python"
                                  ],
                                  "tips": "Margens conservadoras são preferíveis em prática; cheque robustez com variações de ganho.",
                                  "learningObjective": "Quantificar estabilidade via margens e correlacionar com comportamento dinâmico.",
                                  "commonMistakes": [
                                    "Confundir ω_g e ω_p",
                                    "Calcular GM sem converter para dB",
                                    "Interpretar margens sem contexto de integrador"
                                  ]
                                }
                              ],
                              "practicalExample": "Considere G(s) = 10 / (s (s+1)(s+10)). Plote Nyquist: curva inicia em ∞ em -j∞, faz arco de indentação, cruza eixo real. Conte N=0, P=1 (polo s=0), Z=1? Não: ajuste contour direito, N=0 → estável. Calcule PM≈60°, GM≈8dB. Simule step: overshoot moderado confirma.",
                              "finalVerifications": [
                                "Pode modificar manualmente contour para 2 integradores?",
                                "Analisa corretamente Nyquist de G(s)=K/(s^2 (s+1))?",
                                "Calcula margens sem software?",
                                "Explica por que integradores afetam baixa frequência?",
                                "Valida estabilidade com root locus?",
                                "Identifica instabilidade se K aumenta?"
                              ],
                              "assessmentCriteria": [
                                "Precisão no plot de Nyquist (comportamento ω→0 correto)",
                                "Contagem correta de encirclements N",
                                "Cálculo exato de GM e PM (erro <5%)",
                                "Interpretação coerente de estabilidade",
                                "Correlação com simulações temporais/frequenciais",
                                "Tratamento adequado de múltiplos integradores"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Análise complexa e contornos (Teorema de Argumento)",
                                "Física: Dinâmica de sistemas com rampas/integradores (ex: velocidade constante)",
                                "Programação: Simulações numéricas com NumPy/SciPy",
                                "Eletrônica: Filtros analógicos com capacitores (integradores op-amp)"
                              ],
                              "realWorldApplication": "Em controladores de drones para estabilização de atitude (integrador elimina erro steady-state em posição), análise Nyquist garante que perturbações em baixa frequência não desestabilizem o voo, evitando crashes em manobras lentas."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.1.1.3.2"
                            ]
                          },
                          {
                            "id": "10.1.1.1.3.4",
                            "name": "Comparar Nyquist com Routh-Hurwitz",
                            "description": "Comparar os dois critérios em exemplos numéricos, destacando vantagens do Nyquist para análise de robustez e do Routh para verificação rápida algébrica.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Fundamentos dos Critérios de Routh-Hurwitz e Nyquist",
                                  "subSteps": [
                                    "Estudar o critério de Routh-Hurwitz: construção da tabela Routh e interpretação de mudanças de sinal para contagem de polos instáveis.",
                                    "Estudar o critério de Nyquist: construção do diagrama de Nyquist para G(s)H(s), análise de encirclamentos do ponto -1+j0.",
                                    "Identificar limitações: Routh requer polinômio de característica; Nyquist lida com sistemas não mínimos de fase.",
                                    "Listar condições de estabilidade para sistemas LIT escalares usando ambos.",
                                    "Comparar algebricamente: Routh é tabular, Nyquist é gráfico."
                                  ],
                                  "verification": "Elaborar um quadro comparativo escrito com definições, passos e limitações de cada critério.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Livro-texto de Controle (ex: Ogata, Franklin)",
                                    "Folhas de papel ou software de notas (OneNote)"
                                  ],
                                  "tips": "Desenhe diagramas simples para Nyquist desde o início para visualização intuitiva.",
                                  "learningObjective": "Compreender as bases teóricas e diferenças conceituais entre os dois critérios de estabilidade.",
                                  "commonMistakes": [
                                    "Confundir número de mudanças de sinal com número total de polos",
                                    "Esquecer que Nyquist conta encirclamentos no sentido horário"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Aplicar Routh-Hurwitz a um Exemplo Numérico Simples",
                                  "subSteps": [
                                    "Escolher função de transferência de laço aberto: G(s) = 10 / (s(s+1)(s+5)).",
                                    "Derivar equação característica do laço fechado: 1 + G(s) = 0.",
                                    "Construir tabela Routh e contar mudanças de sinal.",
                                    "Interpretar resultados: número de polos no semiplano direito.",
                                    "Calcular ganho crítico K para marginalidade."
                                  ],
                                  "verification": "Verificar se a tabela Routh está correta e conclui estabilidade corretamente; comparar com raízes exatas via MATLAB.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Calculadora ou MATLAB/Simulink",
                                    "Papel quadriculado"
                                  ],
                                  "tips": "Caso haja linha zero na tabela Routh, use método de substituição ε → 0 imediatamente.",
                                  "learningObjective": "Dominar aplicação prática do Routh-Hurwitz em sistemas de terceira ordem.",
                                  "commonMistakes": [
                                    "Erro na expansão do denominador",
                                    "Ignorar casos especiais como fileira inteira zero"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Aplicar Critério de Nyquist ao Mesmo Exemplo",
                                  "subSteps": [
                                    "Plotar diagrama de Nyquist para G(jω) de ω=0 a ∞.",
                                    "Identificar interseções com eixo real e imaginar parte para ω negativo.",
                                    "Contar encirclamentos do ponto crítico (-1,0).",
                                    "Determinar estabilidade e ganho de fase/margem.",
                                    "Analisar sensibilidade a variações de parâmetros."
                                  ],
                                  "verification": "Plotar gráfico manual ou via software e confirmar número de encirclamentos igual a polos instáveis abertos.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "MATLAB ou Python (control library)",
                                    "Gráficos impressos ou software de plotagem"
                                  ],
                                  "tips": "Comece plotando magnitude e fase separadamente para facilitar.",
                                  "learningObjective": "Executar análise gráfica de Nyquist e interpretar robustez.",
                                  "commonMistakes": [
                                    "Plotar apenas ω>0 sem espelhar",
                                    "Contar encirclamentos no sentido anti-horário"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Comparar Resultados e Destacar Vantagens/Desvantagens",
                                  "subSteps": [
                                    "Tabular resultados de ambos métodos para o exemplo.",
                                    "Discutir vantagens: Routh rápido e algébrico para verificação; Nyquist revela robustez e margens.",
                                    "Testar variação: alterar parâmetro (ex: +10% em polo) e reanalisar.",
                                    "Concluir quando usar cada: Routh para preliminar, Nyquist para design.",
                                    "Documentar em relatório curto."
                                  ],
                                  "verification": "Explicar verbalmente ou por escrito por que Nyquist é superior para robustez em 3 cenários.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Planilha Excel para tabela comparativa",
                                    "Relatório template"
                                  ],
                                  "tips": "Use cores para destacar diferenças em tabelas.",
                                  "learningObjective": "Sintetizar comparação quantitativa e qualitativa, enfatizando contextos de uso.",
                                  "commonMistakes": [
                                    "Ignorar que Routh não dá margens",
                                    "Generalizar sem exemplos numéricos"
                                  ]
                                }
                              ],
                              "practicalExample": "Sistema de posição de motor DC com G(s) = 10 / (s(s+1)(s+5)) em realimentação unitária. Routh confirma estabilidade (sem mudanças de sinal). Nyquist mostra margem de ganho 2.5 e fase 45°, revelando robustez a ±20% variação em ganho sem perda de estabilidade; Routh falha em quantificar isso rapidamente.",
                              "finalVerifications": [
                                "Construir tabela Routh correta para exemplo dado.",
                                "Plotar diagrama Nyquist preciso com encirclamentos corretos.",
                                "Listar 3 vantagens do Nyquist sobre Routh em robustez.",
                                "Explicar 2 cenários onde Routh é preferível.",
                                "Aplicar ambos a novo sistema e comparar resultados.",
                                "Identificar margens de estabilidade via Nyquist."
                              ],
                              "assessmentCriteria": [
                                "Precisão na construção de tabela Routh (sem erros algébricos).",
                                "Correção no plot de Nyquist e contagem de encirclamentos.",
                                "Profundidade na comparação de vantagens/desvantagens com exemplos numéricos.",
                                "Clareza na explicação de robustez vs. verificação rápida.",
                                "Capacidade de aplicar a variações paramétricas.",
                                "Qualidade do quadro comparativo e conclusões."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Análise de polinômios e funções complexas.",
                                "Programação: Simulação em MATLAB/Python para plots automáticos.",
                                "Física: Modelagem dinâmica de sistemas mecânicos/elétricos.",
                                "Estatística: Análise de sensibilidade e Monte Carlo para robustez."
                              ],
                              "realWorldApplication": "No design de controladores para drones ou aviões, Nyquist avalia robustez a incertezas de modelo (ex: variação de massa), enquanto Routh faz triagem rápida em protótipos iniciais, otimizando tempo em ciclos de engenharia aeroespacial."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.1.1.2.2",
                              "10.1.1.1.3.2"
                            ]
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.1.2",
                    "name": "Especificações de Desempenho",
                    "description": "Medidas quantitativas de desempenho, incluindo resposta transitória (sobressinal, tempo de subida) e erro em regime permanente.",
                    "individualConcepts": [
                      {
                        "id": "10.1.1.2.1.1",
                        "name": "Especificações de Resposta Transitória",
                        "description": "Medidas quantitativas que caracterizam o comportamento dinâmico inicial de sistemas de controle lineares escalares, incluindo sobressinal (Mp), tempo de subida (tr), tempo de pico (tp) e tempo de acomodação (ta), analisadas a partir da resposta ao degrau unitário.",
                        "specificSkills": [
                          {
                            "id": "10.1.1.2.1.1.1",
                            "name": "Calcular o sobressinal percentual (Mp)",
                            "description": "Dado o gráfico ou a função de resposta ao degrau de um sistema de segunda ordem, calcular o sobressinal máximo percentual (Mp = (ymax - yfinal)/yfinal * 100%) e relacioná-lo com o fator de amortecimento ζ.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a resposta ao degrau unitário de sistemas de segunda ordem",
                                  "subSteps": [
                                    "Revise a forma padrão da função de transferência de segunda ordem: G(s) = ω_n² / (s² + 2ζω_n s + ω_n²)",
                                    "Identifique os elementos chave da resposta transitória: tempo de subida, sobressinal (overshoot), tempo de estabilização e oscilações",
                                    "Analise um gráfico de resposta ao degrau típico, destacando ymax (pico máximo) e yfinal (valor final de regime permanente)",
                                    "Estude a relação qualitativa: quanto menor ζ, maior o sobressinal Mp",
                                    "Memorize a fórmula teórica: Mp = e^(-πζ / √(1-ζ²)) * 100%"
                                  ],
                                  "verification": "Desenhe ou descreva um gráfico de resposta ao degrau com ymax e yfinal anotados corretamente",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Gráficos de respostas ao degrau de sistemas subamortecidos",
                                    "Tabela de valores de Mp vs ζ"
                                  ],
                                  "tips": "Visualize o gráfico: o sobressinal é o 'pico' acima do valor final",
                                  "learningObjective": "Entender os conceitos fundamentais de resposta transitória e sua relação com ζ",
                                  "commonMistakes": [
                                    "Confundir ymax com o primeiro pico em vez do máximo absoluto",
                                    "Ignorar que yfinal é tipicamente 1 para degrau unitário"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar ymax e yfinal do gráfico ou função de resposta",
                                  "subSteps": [
                                    "Examine o gráfico da resposta y(t) ao degrau unitário",
                                    "Localize yfinal: valor assintótico para t → ∞ (geralmente 1 para ganho DC=1)",
                                    "Meça ou estime ymax: valor máximo absoluto de y(t) no primeiro pico",
                                    "Se dada a função analítica y(t) = 1 - (e^(-ζω_n t)/√(1-ζ²)) sen(ω_d t + φ), derive o tempo do pico tp = π / ω_d",
                                    "Calcule ymax usando y(tp) se função analítica estiver disponível"
                                  ],
                                  "verification": "Anote valores numéricos de ymax e yfinal com precisão de 0.01",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Gráfico fornecido ou simulador como MATLAB/Simulink",
                                    "Função y(t) exemplo"
                                  ],
                                  "tips": "Use régua ou cursor no gráfico para precisão; confirme yfinal lendo eixo y em t grande",
                                  "learningObjective": "Extrair com precisão os valores chave da resposta transitória",
                                  "commonMistakes": [
                                    "Escolher pico secundário como ymax",
                                    "Assumir yfinal=0 incorretamente"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular o sobressinal percentual Mp",
                                  "subSteps": [
                                    "Aplique a fórmula: Mp = ((ymax - yfinal) / yfinal) * 100%",
                                    "Subtraia: ymax - yfinal",
                                    "Divida pelo yfinal",
                                    "Multiplique por 100 para percentual",
                                    "Arredonde para 2 casas decimais e adicione unidade %"
                                  ],
                                  "verification": "Compare resultado com valor teórico conhecido para o gráfico",
                                  "estimatedTime": "10 minutos",
                                  "materials": [
                                    "Calculadora ou software como Python/MATLAB",
                                    "Folha de cálculo"
                                  ],
                                  "tips": "Verifique unidades: sempre percentual; yfinal ≠ 0",
                                  "learningObjective": "Executar o cálculo numérico de Mp de forma precisa e rápida",
                                  "commonMistakes": [
                                    "Esquecer de dividir por yfinal",
                                    "Não multiplicar por 100",
                                    "Usar valores absolutos errados"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Relacionar Mp com o fator de amortecimento ζ",
                                  "subSteps": [
                                    "Use a fórmula: Mp/100 = e^(-πζ / √(1-ζ²))",
                                    "Aplique log natural: ln(Mp/100) = -πζ / √(1-ζ²)",
                                    "Resolva iterativamente para ζ (use tabela ou solver numérico)",
                                    "Valide: para Mp=0%, ζ≥1; Mp=16%, ζ≈0.5",
                                    "Interprete: Mp alto indica ζ baixo e oscilações indesejadas"
                                  ],
                                  "verification": "Calcule ζ e confirme que Mp calculado da fórmula teórica bate com o gráfico",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Tabela Mp vs ζ",
                                    "Solver numérico ou app (ex: Excel Goal Seek)"
                                  ],
                                  "tips": "Comece com ζ=0.5 para Mp≈16%; ajuste iterativamente",
                                  "learningObjective": "Conectar Mp empiricamente medido com parâmetro físico ζ",
                                  "commonMistakes": [
                                    "Confundir fórmula de Mp com tempo de estabilização",
                                    "Resolver para ζ>1 em sistemas oscilantes"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um gráfico de resposta ao degrau unitário, ymax=1.25 no primeiro pico e yfinal=1.0. Calcule Mp = ((1.25-1.0)/1.0)*100% = 25%. Usando a fórmula, ζ ≈ 0.4, indicando sistema pouco amortecido com risco de oscilações sustentadas.",
                              "finalVerifications": [
                                "Calcule Mp corretamente para 3 gráficos diferentes",
                                "Estime ζ a partir de Mp com erro <5%",
                                "Explique verbalmente a relação Mp-ζ",
                                "Identifique ymax e yfinal em gráfico novo sem erros",
                                "Compare Mp calculado vs teórico com precisão",
                                "Aplique em função analítica y(t)"
                              ],
                              "assessmentCriteria": [
                                "Precisão no cálculo de Mp (±1%)",
                                "Correta identificação de ymax e yfinal",
                                "Uso adequado da fórmula teórica para ζ",
                                "Interpretação qualitativa coerente",
                                "Eficiência no tempo de execução",
                                "Ausência de erros comuns listados"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Equações diferenciais e funções exponenciais/trigonômétricas",
                                "Física: Dinâmica de sistemas massa-mola-amortecedor",
                                "Engenharia Mecânica: Análise de vibrações",
                                "Programação: Simulação numérica em Python/MATLAB",
                                "Estatística: Análise de incertezas em medições de picos"
                              ],
                              "realWorldApplication": "Em controle de velocidade de motores DC, Mp alto causa overspeed perigoso; designers ajustam ζ via ganho proporcional para Mp<10%, garantindo estabilidade em robótica industrial e veículos autônomos."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.2.1.1.2",
                            "name": "Determinar o tempo de subida (tr)",
                            "description": "Calcular o tempo de subida tr para sistemas de segunda ordem subamortecidos, utilizando a fórmula aproximada tr ≈ (π - β)/ωn, onde β = acos(ζ), e interpretá-lo em termos de especificações de desempenho.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Identificar e validar parâmetros do sistema de segunda ordem subamortecido",
                                  "subSteps": [
                                    "Confirmar que o sistema é de segunda ordem e subamortecido (ζ < 1)",
                                    "Localizar ou extrair o fator de amortecimento ζ da equação característica ou gráfico de resposta",
                                    "Identificar a frequência natural não amortecida ωn em rad/s",
                                    "Verificar unidades e precisão dos valores obtidos",
                                    "Documentar os valores em uma tabela para referência"
                                  ],
                                  "verification": "Lista de parâmetros (ζ e ωn) com ζ < 1 confirmada e unidades corretas",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Equação característica do sistema",
                                    "Gráfico de resposta ao degrau",
                                    "Calculadora ou software como MATLAB"
                                  ],
                                  "tips": [
                                    "Sempre converta ωn para rad/s se estiver em Hz",
                                    "Use ζ exato para evitar erros de arredondamento precoce"
                                  ],
                                  "learningObjective": "Reconhecer e extrair com precisão os parâmetros essenciais ζ e ωn de um sistema subamortecido",
                                  "commonMistakes": [
                                    "Confundir ζ com o overshoot percentual",
                                    "Usar frequência amortecida ωd em vez de ωn",
                                    "Ignorar verificação de subamortecimento"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Calcular o ângulo β utilizando β = acos(ζ)",
                                  "subSteps": [
                                    "Inserir o valor de ζ na função arco-cosseno (acos)",
                                    "Calcular β em radianos usando calculadora ou software",
                                    "Verificar se β está entre 0 e π/2 (típico para 0 < ζ < 1)",
                                    "Arredondar β para 3-4 casas decimais",
                                    "Anotar o resultado com justificativa da função usada"
                                  ],
                                  "verification": "Valor de β calculado e validado numericamente (ex: para ζ=0.5, β≈1.047 rad)",
                                  "estimatedTime": "10 minutos",
                                  "materials": [
                                    "Calculadora científica",
                                    "Tabela de valores trigonométricos",
                                    "Software como Python ou MATLAB"
                                  ],
                                  "tips": [
                                    "Use radianos, não graus; acos retorna radianos por padrão em ferramentas matemáticas",
                                    "Teste com ζ conhecido: acos(0)=π/2"
                                  ],
                                  "learningObjective": "Aplicar corretamente a função arco-cosseno para obter β a partir de ζ",
                                  "commonMistakes": [
                                    "Usar cos em vez de acos",
                                    "Converter para graus inadvertidamente",
                                    "Arredondar ζ prematuramente"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular o tempo de subida tr ≈ (π - β) / ωn",
                                  "subSteps": [
                                    "Calcular π - β numericamente",
                                    "Dividir o resultado por ωn",
                                    "Arredondar tr para 3 casas decimais",
                                    "Comparar com simulação ou fórmula exata se disponível",
                                    "Registrar a fórmula completa com valores substituidos"
                                  ],
                                  "verification": "Valor de tr calculado coincide com verificação manual ou simulada",
                                  "estimatedTime": "10 minutos",
                                  "materials": [
                                    "Calculadora",
                                    "Folha de cálculo",
                                    "Simulador de sistemas dinâmicos como Simulink"
                                  ],
                                  "tips": [
                                    "Mantenha π como 3.1416 para precisão",
                                    "Verifique sinal: tr deve ser positivo e pequeno para ζ baixo"
                                  ],
                                  "learningObjective": "Executar o cálculo aproximado de tr com precisão numérica",
                                  "commonMistakes": [
                                    "Esquecer de subtrair β de π",
                                    "Dividir por ωd em vez de ωn",
                                    "Inverter operador"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Interpretar tr em termos de especificações de desempenho",
                                  "subSteps": [
                                    "Relacionar tr com velocidade de resposta: tr pequeno indica resposta rápida",
                                    "Comparar tr com outras especificações (tp, ts, overshoot)",
                                    "Avaliar impacto em aplicações: tr < 0.5 s para sistemas rápidos",
                                    "Discutir trade-offs com ζ (aumento de ζ diminui tr mas aumenta amortecimento)",
                                    "Documentar interpretação em relatório com gráfico"
                                  ],
                                  "verification": "Interpretação escrita coerente com valor calculado e contexto do sistema",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Gráficos de resposta transitória",
                                    "Tabela de especificações de desempenho",
                                    "Exemplos de sistemas reais"
                                  ],
                                  "tips": [
                                    "Use gráfico para visualizar: tr é tempo de 10% a 90% do valor final",
                                    "Considere requisitos do projeto (ex: tr < 1s)"
                                  ],
                                  "learningObjective": "Interpretar tr como métrica chave de desempenho transitório",
                                  "commonMistakes": [
                                    "Confundir tr com tempo de pico tp",
                                    "Ignorar dependência em ωn",
                                    "Interpretar qualitativamente sem números"
                                  ]
                                }
                              ],
                              "practicalExample": "Considere um sistema de controle de posição de motor com ζ = 0.5 e ωn = 10 rad/s. Calcule β = acos(0.5) = 1.0472 rad. Então tr ≈ (3.1416 - 1.0472)/10 = 0.2094 s. Isso significa que o sistema atinge 90% do valor final em cerca de 0.21 s, adequado para aplicações como robótica leve.",
                              "finalVerifications": [
                                "Parâmetros ζ e ωn corretamente identificados e validados",
                                "β calculado com precisão (erro < 0.01 rad)",
                                "tr numérico exato conforme fórmula aproximada",
                                "Interpretação inclui relação com resposta rápida e trade-offs",
                                "Gráfico ou simulação confirma tr visualmente",
                                "Relatório completo com todos os passos documentados"
                              ],
                              "assessmentCriteria": [
                                "Precisão numérica nos cálculos (>99% de acurácia)",
                                "Compreensão conceitual de subamortecimento e fórmula",
                                "Qualidade da interpretação em contexto de desempenho",
                                "Uso correto de ferramentas e verificações",
                                "Identificação de erros comuns e avoidance",
                                "Clareza na documentação e substeps executados"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Funções trigonométricas inversas e aproximações",
                                "Física: Dinâmica de osciladores amortecidos",
                                "Engenharia Elétrica: Análise de respostas em circuitos RLC",
                                "Programação: Implementação em Python/MATLAB para simulações",
                                "Estatística: Análise de variância em parâmetros estimados"
                              ],
                              "realWorldApplication": "Em controladores de drones ou veículos autônomos, calcular tr garante manobras ágeis sem oscilações excessivas, otimizando PID para tempos de resposta abaixo de 0.2s em estabilização de altitude."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.2.1.1.3",
                            "name": "Calcular o tempo de acomodação (ta)",
                            "description": "Aplicar as fórmulas para tempo de acomodação ta (ao 2% ou 5%) em sistemas de segunda ordem: ta ≈ 4/ζωn (2%) ou 3/ζωn (5%), e avaliar o impacto nos requisitos de desempenho transitório.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os conceitos fundamentais de tempo de acomodação e parâmetros do sistema",
                                  "subSteps": [
                                    "Defina o tempo de acomodação (ta) como o tempo necessário para que a resposta transitória do sistema permaneça dentro de 2% ou 5% do valor final.",
                                    "Revise o fator de amortecimento (ζ), que determina o tipo de resposta (subamortecido, crítico ou superamortecido).",
                                    "Explique a frequência natural não amortecida (ωn), raiz quadrada da constante de rigidez dividida pela massa em sistemas mecânicos equivalentes.",
                                    "Memorize as fórmulas aproximadas: ta(2%) ≈ 4 / (ζ ωn) e ta(5%) ≈ 3 / (ζ ωn) para sistemas de segunda ordem subamortecidos.",
                                    "Discuta a validade das aproximações para ζ > 0.3."
                                  ],
                                  "verification": "Explique os conceitos e fórmulas em um resumo escrito de 100 palavras, sem erros conceituais.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Livro-texto de controle linear",
                                    "Notas de aula sobre sistemas de segunda ordem",
                                    "Gráficos de respostas transitórias"
                                  ],
                                  "tips": "Visualize gráficos de resposta unitária para associar ta visualmente à 'cauda' da curva.",
                                  "learningObjective": "Dominar a teoria por trás de ta, ζ e ωn em sistemas de segunda ordem.",
                                  "commonMistakes": [
                                    "Confundir ta com tempo de estabilização total (que ignora overshoot), usar fórmulas para sistemas superamortecidos."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar e extrair os parâmetros ζ e ωn de um sistema dado",
                                  "subSteps": [
                                    "Analise a função de transferência do sistema de segunda ordem: G(s) = ωn² / (s² + 2ζωn s + ωn²).",
                                    "Extraia ωn da raiz quadrada do termo constante do denominador.",
                                    "Calcule ζ como metade do coeficiente de s dividido por ωn.",
                                    "Verifique se o sistema é subamortecido (ζ < 1) para aplicar as fórmulas de ta.",
                                    "Se os parâmetros não forem diretos, use simulação ou polos para estimá-los."
                                  ],
                                  "verification": "Liste ζ e ωn corretos para um sistema exemplo, com justificativa da extração.",
                                  "estimatedTime": "10 minutos",
                                  "materials": [
                                    "Função de transferência exemplo",
                                    "Calculadora ou software como MATLAB/Simulink"
                                  ],
                                  "tips": "Padronize a forma canônica do denominador antes de extrair parâmetros.",
                                  "learningObjective": "Extrair com precisão os parâmetros necessários de descrições de sistemas.",
                                  "commonMistakes": [
                                    "Erro na normalização da função de transferência, confundir ωn com ωd (frequência amortecida)."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Aplicar as fórmulas para calcular ta(2%) e ta(5%)",
                                  "subSteps": [
                                    "Selecione a fórmula baseada no critério: 4/(ζ ωn) para 2% ou 3/(ζ ωn) para 5%.",
                                    "Calcule o produto ζ ωn (frequência de corte aproximada).",
                                    "Divida o numerador pela frequência de corte para obter ta.",
                                    "Repita para ambos os critérios e compare os valores.",
                                    "Arredonde para 2 casas decimais e inclua unidades (geralmente segundos)."
                                  ],
                                  "verification": "Apresente cálculos numéricos exatos para ζ e ωn dados, conferindo com calculadora.",
                                  "estimatedTime": "10 minutos",
                                  "materials": [
                                    "Calculadora científica",
                                    "Papel para cálculos manuais",
                                    "Planilha Excel para verificação"
                                  ],
                                  "tips": "Use σ = ζ ωn como abreviação para simplificar: ta ≈ 4/σ ou 3/σ.",
                                  "learningObjective": "Executar cálculos precisos de ta usando as aproximações padrão.",
                                  "commonMistakes": [
                                    "Usar divisão errada (ex: ζωn no numerador), esquecer unidades ou arredondamento precoce."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Avaliar o impacto de ta nos requisitos de desempenho transitório",
                                  "subSteps": [
                                    "Compare ta calculado com requisitos especificados (ex: ta < 2s).",
                                    "Analise como ta afeta outros índices: ta maior implica resposta mais lenta, mas possivelmente menos overshoot.",
                                    "Discuta trade-offs com Mp (overshoot) e tp (tempo de pico), via relações com ζ.",
                                    "Sugira ajustes no controlador (ex: aumentar ωn para reduzir ta).",
                                    "Simule a resposta para validar a aproximação."
                                  ],
                                  "verification": "Escreva um parágrafo avaliando se ta atende requisitos e propondo melhorias.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Software de simulação (MATLAB/Simulink)",
                                    "Tabela de requisitos de desempenho"
                                  ],
                                  "tips": "Gráfico de resposta transitória confirma se ta aproximado é preciso dentro de 10%.",
                                  "learningObjective": "Interpretar ta no contexto de especificações globais de desempenho.",
                                  "commonMistakes": [
                                    "Ignorar dependência de ta em ζ (pensar que só ωn importa), não considerar não-linearidades reais."
                                  ]
                                }
                              ],
                              "practicalExample": "Considere um sistema de segunda ordem com ζ = 0.5 e ωn = 10 rad/s. Calcule ta(2%) ≈ 4 / (0.5 * 10) = 0.8 s e ta(5%) ≈ 3 / (0.5 * 10) = 0.6 s. Simule em MATLAB: step(tf(100,[1 10 100])) e meça ta graficamente para validar (deve coincidir aproximadamente).",
                              "finalVerifications": [
                                "Cálculos de ta(2%) e ta(5%) exatos para sistema exemplo.",
                                "Identificação correta de ζ e ωn da função de transferência.",
                                "Avaliação escrita do impacto de ta nos requisitos (ex: atende ta < 1s?).",
                                "Simulação confirma ta dentro de 10% da aproximação.",
                                "Explicação clara de trade-offs com outros índices transitórios.",
                                "Sugestão válida de ajuste para melhorar ta."
                              ],
                              "assessmentCriteria": [
                                "Precisão matemática nos cálculos (±1% de erro).",
                                "Correta aplicação das fórmulas baseadas no critério (2% vs 5%).",
                                "Interpretação qualitativa e quantitativa do impacto de ta.",
                                "Uso adequado de ferramentas (simulação valida teoria).",
                                "Identificação de erros comuns e prevenção demonstrada.",
                                "Clareza na documentação de passos e resultados."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Álgebra linear e aproximações assintóticas de funções exponenciais.",
                                "Física: Dinâmica de osciladores amortecidos e equações diferenciais.",
                                "Programação: Simulação numérica em MATLAB/Python para validação.",
                                "Estatística: Análise de tolerâncias e intervalos de confiança em medições transitórias."
                              ],
                              "realWorldApplication": "Em controladores de drones, ta determina quão rápido o estabilizador de atitude responde a perturbações de vento, garantindo voo estável sem oscilações; valores altos de ta podem causar perda de controle em manobras rápidas."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.1.2.1.2",
                        "name": "Especificações de Erro em Regime Permanente",
                        "description": "Análise do erro estacionário e_ss para entradas de referência escalão, rampa e parabólica em sistemas de controle lineares invariantes no tempo (LIT) escalares, relacionando-o com o tipo do sistema e os ganhos de erro estático (Kv, Ka, etc.).",
                        "specificSkills": [
                          {
                            "id": "10.1.1.2.1.2.1",
                            "name": "Calcular erro para entrada escalão",
                            "description": "Determinar o erro em regime permanente e_ss para entrada escalão unitário em sistemas de controle em malha fechada, utilizando e_ss = 1/(1 + Kp) para sistemas tipo 0 e e_ss = 0 para tipos 1 ou superior.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os Conceitos Fundamentais de Entrada Escalão e Erro em Regime Permanente",
                                  "subSteps": [
                                    "Defina entrada escalão unitário: r(t) = 1 para t ≥ 0, com transformada R(s) = 1/s.",
                                    "Explique erro em regime permanente: e_ss = lim_{t→∞} [r(t) - y(t)].",
                                    "Descreva o diagrama de sistema em malha fechada com feedback unitário: Y(s) = [G(s)/(1 + G(s))] R(s).",
                                    "Introduza o ganho de posição estático Kp = lim_{s→0} G(s), onde G(s) é a função de transferência em malha aberta.",
                                    "Relacione e_ss com o teorema do valor final: e_ss = lim_{s→0} s E(s), com E(s) = R(s) / (1 + G(s))."
                                  ],
                                  "verification": "Escreva um resumo de 100 palavras explicando os conceitos em suas próprias palavras e desenhe o diagrama de malha fechada.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Diagrama de bloco de malha fechada",
                                    "Notas sobre transformada de Laplace",
                                    "Teorema do valor final"
                                  ],
                                  "tips": "Visualize o escalão como um 'degrau' instantâneo; foque no comportamento assintótico após transientes.",
                                  "learningObjective": "Dominar os termos chave e a relação matemática entre entrada, saída e erro em regime permanente.",
                                  "commonMistakes": [
                                    "Confundir entrada escalão com rampa",
                                    "Ignorar o feedback unitário",
                                    "Esquecer que Kp é limite em s=0"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Classificar o Tipo do Sistema de Controle",
                                  "subSteps": [
                                    "Analise a função de transferência em malha aberta G(s) e identifique polos em s=0 (integradores).",
                                    "Classifique: Tipo 0 (sem polos em 0, Kp finito), Tipo 1 (um polo em 0, Kp=∞), Tipo ≥2 (mais integradores).",
                                    "Calcule Kp = lim_{s→0} G(s) para sistemas tipo 0.",
                                    "Verifique que para tipo ≥1, Kp diverge para infinito devido ao polo em zero.",
                                    "Pratique com 2 exemplos simples: um tipo 0 e um tipo 1."
                                  ],
                                  "verification": "Classifique corretamente 3 funções G(s) dadas e compute Kp onde aplicável.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Lista de funções de transferência exemplo",
                                    "Calculadora ou software simbólico como SymPy"
                                  ],
                                  "tips": "Conte os fatores '1/s' no denominador de G(s) para determinar o tipo rapidamente.",
                                  "learningObjective": "Identificar o tipo do sistema e calcular o ganho de posição estático com precisão.",
                                  "commonMistakes": [
                                    "Contar zeros em vez de polos",
                                    "Calcular Kp para s→∞ em vez de s→0",
                                    "Confundir malha aberta com fechada"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Aplicar as Fórmulas de Erro Steady-State para Entrada Escalão",
                                  "subSteps": [
                                    "Para sistemas tipo 0: derive e aplique e_ss = 1 / (1 + Kp).",
                                    "Para sistemas tipo ≥1: justifique e_ss = 0, pois Kp → ∞.",
                                    "Use o teorema do valor final: e_ss = lim_{s→0} s (1/s) / (1 + G(s)) = 1 / (1 + Kp).",
                                    "Resolva um exemplo numérico: G(s) = 5/(s+2), tipo 0, Kp=5/2=2.5, e_ss=1/3.5≈0.286.",
                                    "Compare resultados para tipo 0 vs. tipo 1 em um mesmo sistema modificado."
                                  ],
                                  "verification": "Derive a fórmula geral e calcule e_ss para 2 sistemas distintos, mostrando passos matemáticos.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Papel e lápis para derivações",
                                    "Tabela de tipos de sistemas"
                                  ],
                                  "tips": "Lembre-se: adicionar integrador (1/s) eleva o tipo e zera o erro para escalão.",
                                  "learningObjective": "Aplicar corretamente as fórmulas específicas baseadas no tipo do sistema.",
                                  "commonMistakes": [
                                    "Usar fórmula de rampa para escalão",
                                    "Inverter Kp no denominador",
                                    "Não simplificar lim_{s→0} adequadamente"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificar e Interpretar Resultados com Exemplos Práticos",
                                  "subSteps": [
                                    "Simule ou esboce resposta temporal para validar e_ss (offset constante para tipo 0, zero para tipo ≥1).",
                                    "Calcule e_ss para G(s)=10/(s(s+1)) (tipo 1: e_ss=0) e G(s)=10/(s+1) (tipo 0: Kp=10, e_ss=1/11≈0.091).",
                                    "Interprete: erro indica necessidade de compensação (ex: integrador para eliminar offset).",
                                    "Resolva um problema completo: dado G(s), encontre tipo, Kp, e_ss.",
                                    "Discuta limitações: assume linearidade e estabilidade."
                                  ],
                                  "verification": "Resolva um problema completo de ponta a ponta e explique a interpretação física do e_ss.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Gráficos de resposta ao degrau",
                                    "Software de simulação opcional (MATLAB/Python)"
                                  ],
                                  "tips": "Sempre verifique estabilidade primeiro; erro só faz sentido em sistemas estáveis.",
                                  "learningObjective": "Integrar cálculo, verificação e interpretação para aplicação real.",
                                  "commonMistakes": [
                                    "Assumir e_ss=0 sem checar tipo",
                                    "Ignorar unidades ou escala da entrada",
                                    "Confundir erro estático com tempo de acomodação"
                                  ]
                                }
                              ],
                              "practicalExample": "Para um sistema de controle de posição com G(s) = 20 / (s + 2) (tipo 0): Kp = 20/2 = 10, e_ss = 1/(1+10) = 0.0909 (9% de erro para entrada unitária). Adicionando integrador, G(s) = 20 / (s(s + 2)) (tipo 1): Kp = ∞, e_ss = 0 (rastreamento perfeito em steady-state).",
                              "finalVerifications": [
                                "Classificação correta do tipo do sistema baseada em polos em s=0.",
                                "Cálculo preciso de Kp = lim_{s→0} G(s) para tipo 0.",
                                "Aplicação exata da fórmula e_ss = 1/(1 + Kp) ou 0 conforme o tipo.",
                                "Uso correto do teorema do valor final na derivação.",
                                "Interpretação física: offset zero apenas para tipos ≥1.",
                                "Verificação numérica em pelo menos 2 exemplos independentes."
                              ],
                              "assessmentCriteria": [
                                "Precisão matemática 100% nos cálculos de Kp e e_ss.",
                                "Correta identificação do tipo do sistema em todos os casos.",
                                "Explicação clara da derivação usando teorema do valor final.",
                                "Interpretação adequada das implicações para projeto de controle.",
                                "Resolução independente de problemas sem erros comuns.",
                                "Demonstração de compreensão conceitual via exemplos práticos."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Limites de Laplace e análise assintótica de funções de transferência.",
                                "Física: Modelagem dinâmica de sistemas massa-mola para analogia com tipos.",
                                "Engenharia Elétrica: Projeto de amplificadores operacionais integradores.",
                                "Programação: Simulação de respostas em Python (control library) ou MATLAB.",
                                "Estatística: Análise de erro em medições experimentais de steady-state."
                              ],
                              "realWorldApplication": "Em controladores PID para temperatura em fornos industriais (tipo 0 tem offset, adicionar I elimina para precisão); posicionamento de braços robóticos (tipo 1 garante chegada exata à posição desejada sem erro permanente); drones estabilizando altitude."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.2.1.2.2",
                            "name": "Calcular erro para entrada rampa",
                            "description": "Computar e_ss = 1/Kv para entrada rampa unitária em sistemas tipo 1 (Kv = lim sG(s) quando s→0), e analisar como zero para tipos superiores e infinito para tipo 0.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Fundamentos de Erro em Regime Permanente e Tipos de Sistemas",
                                  "subSteps": [
                                    "Defina erro em regime permanente (e_ss) como o erro limite quando t→∞ para entradas específicas.",
                                    "Revise a classificação de sistemas por tipo: número de polos no origem (integradores).",
                                    "Memorize a tabela padrão: para rampa unitária (r(t)=t u(t)), e_ss = 1/Kv para tipo 1; ∞ para tipo 0; 0 para tipo >1.",
                                    "Entenda a transformada de Laplace da rampa unitária: R(s)=1/s².",
                                    "Pratique identificando o tipo de um sistema dado pela função de transferência G(s)."
                                  ],
                                  "verification": "Liste corretamente a tabela de e_ss para rampa em diferentes tipos de sistemas sem consultar notas.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Função de transferência de exemplo",
                                    "Tabela de erros estacionários (impressa ou digital)",
                                    "Papel e calculadora"
                                  ],
                                  "tips": "Sempre conte o número de polos em s=0 para determinar o tipo do sistema.",
                                  "learningObjective": "Compreender os conceitos básicos de erro estacionário e classificação de sistemas por tipo.",
                                  "commonMistakes": [
                                    "Confundir tipo do sistema com ordem total",
                                    "Esquecer que rampa unitária tem inclinação 1"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Entender e Calcular a Constante de Velocidade de Erro Kv",
                                  "subSteps": [
                                    "Defina Kv = lim_{s→0} s G(s), onde G(s) é a função de malha aberta.",
                                    "Identifique sistemas tipo 1: pelo menos um integrador (polo em s=0).",
                                    "Para G(s) = K / (s (s+a)), compute lim_{s→0} s * K / (s (s+a)) = K/a.",
                                    "Pratique com 2-3 funções de transferência diferentes, calculando Kv manualmente.",
                                    "Verifique se para tipo 0, lim não existe ou é finito sem o 's', levando a e_ss=∞."
                                  ],
                                  "verification": "Calcule Kv para G(s)=10/(s(s+2)) e obtenha Kv=5 corretamente.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Calculadora simbólica ou papel",
                                    "Exemplos de G(s) de livros de controle",
                                    "Software como MATLAB para plotar limites"
                                  ],
                                  "tips": "Multiplique por s antes de tomar lim s→0 para evitar divisão por zero.",
                                  "learningObjective": "Calcular com precisão a constante Kv para sistemas tipo 1.",
                                  "commonMistakes": [
                                    "Esquecer o fator 's' na definição de Kv",
                                    "Usar G(s) em malha fechada em vez de aberta"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Computar o Erro Estacionário e_ss para Entrada Rampa Unitária",
                                  "subSteps": [
                                    "Aplique a fórmula e_ss = 1 / Kv para sistemas tipo 1.",
                                    "Para o exemplo G(s)=10/(s(s+2)), Kv=5, então e_ss=0.2.",
                                    "Simule numericamente em software para confirmar (resposta em regime).",
                                    "Registre e_ss para tipo 1, e discuta qualitativamente ∞ (tipo 0) e 0 (tipo ≥2).",
                                    "Compare com step input para reforçar diferenças."
                                  ],
                                  "verification": "Para um sistema dado, compute e_ss e explique por que é finito apenas para tipo 1.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "MATLAB ou Python (control library)",
                                    "Gráficos de simulação de rampa"
                                  ],
                                  "tips": "Sempre normalize a rampa para unitária (inclinação=1) para usar a fórmula padrão.",
                                  "learningObjective": "Aplicar a fórmula de e_ss e validar via simulação.",
                                  "commonMistakes": [
                                    "Usar 1/Kp em vez de 1/Kv",
                                    "Ignorar unidade da rampa"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar Comportamento para Diferentes Tipos de Sistemas e Verificar",
                                  "subSteps": [
                                    "Para tipo 0: mostre que e_ss→∞ pois sem integrador, sistema não segue rampa.",
                                    "Para tipo 2+: e_ss=0 pois sobra integradores para anular erro de rampa.",
                                    "Crie um quadro comparativo: tipo, Kv, e_ss para rampa.",
                                    "Teste com simulações: tipo 0 diverge, tipo 1 constante, tipo 2 zero.",
                                    "Resuma quando especificar Kv para atender e_ss desejado."
                                  ],
                                  "verification": "Explique e demonstre com gráfico por que e_ss=0 para tipo 2.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Software de simulação (Simulink ou Python)",
                                    "Exemplos de sistemas tipo 0,1,2"
                                  ],
                                  "tips": "Pense fisicamente: integradores acumulam velocidade para seguir rampa.",
                                  "learningObjective": "Analisar qualitativamente e quantitativamente e_ss por tipo de sistema.",
                                  "commonMistakes": [
                                    "Confundir Kv com Ka (aceleração para parábola)",
                                    "Achar que tipo 0 tem e_ss finito"
                                  ]
                                }
                              ],
                              "practicalExample": "Considere um servomotor com G(s) = 20 / (s (s + 5)). Para rampa unitária r(t) = t u(t), calcule Kv = lim_{s→0} s G(s) = 20/5 = 4. Assim, e_ss = 1/4 = 0.25. Simule em MATLAB: step response para rampa mostra erro constante de 0.25 após transiente.",
                              "finalVerifications": [
                                "Calcula Kv corretamente para qualquer G(s) tipo 1 dado.",
                                "Determina e_ss = 1/Kv e explica para entrada rampa unitária.",
                                "Identifica corretamente e_ss = ∞ para tipo 0 e 0 para tipo >1.",
                                "Valida resultado via simulação simples.",
                                "Explica o impacto físico do erro em aplicações reais.",
                                "Cria tabela comparativa de e_ss por tipo e entrada."
                              ],
                              "assessmentCriteria": [
                                "Precisão no cálculo de Kv (100% correto em 3 exemplos).",
                                "Correta aplicação de e_ss = 1/Kv apenas para tipo 1.",
                                "Análise qualitativa completa para todos os tipos.",
                                "Uso adequado de ferramentas de simulação para verificação.",
                                "Clareza na explicação de limitações e casos especiais.",
                                "Capacidade de relacionar a especificações de desempenho."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Cálculo de limites e transformadas de Laplace.",
                                "Física: Dinâmica de sistemas com integradores (ex: posição/velocidade).",
                                "Programação: Simulação em MATLAB/Python (bibliotecas control/systems).",
                                "Engenharia Mecânica: Controle de velocidade em atuadores.",
                                "Estatística: Análise de erros em medições de sensores."
                              ],
                              "realWorldApplication": "Em robótica industrial, calcular e_ss para rampa garante que braços robóticos sigam trajetórias lineares de velocidade constante sem desvio permanente, essencial para soldagem ou pintura precisa; especificar Kv alto reduz erro em linhas de montagem automatizadas."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.2.1.2.3",
                            "name": "Calcular erro para entrada parabólica",
                            "description": "Avaliar e_ss = 1/Ka para entrada parabólica unitária (aceleração 2t), onde Ka = lim s²G(s) s→0, identificando comportamento para diferentes tipos de sistemas de controle.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a entrada parabólica unitária e conceitos de erro em regime permanente",
                                  "subSteps": [
                                    "Defina entrada parabólica unitária como r(t) = t²/2 para t ≥ 0, com aceleração constante unitária de 1.",
                                    "Explique erro em regime permanente (e_ss) como lim_{t→∞} [r(t) - y(t)].",
                                    "Revise tipos de sistemas: Tipo 0 (sem integrador), Tipo 1 (um integrador), Tipo 2 (dois integradores).",
                                    "Identifique que para entrada parabólica, e_ss é finito apenas em sistemas Tipo 2 ou superior.",
                                    "Discuta Ka como ganho de aceleração constante: Ka = lim_{s→0} s² G(s), onde G(s) é a função de transferência em malha aberta."
                                  ],
                                  "verification": "Resuma em suas palavras o que é entrada parabólica e quando e_ss é finito, com exemplos de tipos de sistemas.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Folha de papel ou caderno",
                                    "Tabela de tipos de sistemas e erros steady-state"
                                  ],
                                  "tips": "Use diagramas de bloco para visualizar feedback unity e G(s).",
                                  "learningObjective": "Entender fundamentos teóricos da entrada parabólica e relação com tipo de sistema.",
                                  "commonMistakes": [
                                    "Confundir entrada parabólica com rampa (t)",
                                    "Ignorar que e_ss=∞ para Tipo <2"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Derivar a fórmula do erro steady-state para entrada parabólica",
                                  "subSteps": [
                                    "Aplique teorema do valor final: E(s) = lim_{s→0} s E(s) = lim_{s→0} s R(s) / (1 + G(s)).",
                                    "Para R(s) = 1/s³ (Laplace de t²/2), simplifique para e_ss = lim_{s→0} 1 / (s G(s)).",
                                    "Mostre que e_ss = 1 / lim_{s→0} s² G(s) = 1/Ka para sistemas Tipo 2.",
                                    "Confirme: para Tipo 0/1, Ka=0 → e_ss=∞; para Tipo ≥2, Ka finito.",
                                    "Escreva equações explicitamente para um sistema genérico."
                                  ],
                                  "verification": "Derive e_ss a partir de E(s) e R(s), chegando a e_ss=1/Ka.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Calculadora científica",
                                    "Tabela de transformadas de Laplace"
                                  ],
                                  "tips": "Lembre-se: para unity feedback, T(s)=G(s)/(1+G(s)), mas foque em malha aberta G(s).",
                                  "learningObjective": "Derivar matematicamente a fórmula e_ss=1/Ka.",
                                  "commonMistakes": [
                                    "Usar fórmula errada de R(s) (ex: 1/s² para rampa)",
                                    "Esquecer lim s→0 em Ka"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular Ka para sistemas de controle específicos",
                                  "subSteps": [
                                    "Dado G(s), identifique polos em s=0 para determinar tipo.",
                                    "Exemplo Tipo 1: G(s)=10/(s(s+1)); compute lim s² G(s)=0 → Ka=0.",
                                    "Exemplo Tipo 2: G(s)=20/(s²(s+2)); compute lim s² G(s)=20/2=10 → Ka=10.",
                                    "Exemplo Tipo 3: G(s)=K/s³ → Ka=∞ → e_ss=0.",
                                    "Calcule para pelo menos dois sistemas fornecidos ou inventados."
                                  ],
                                  "verification": "Calcule Ka para 2-3 exemplos e liste e_ss correspondente.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Software simbólico como MATLAB/SymPy ou papel"
                                  ],
                                  "tips": "Fatore G(s) para ver ordem de s no denominador.",
                                  "learningObjective": "Aplicar limite para calcular Ka em funções de transferência reais.",
                                  "commonMistakes": [
                                    "Calcular lim s G(s) em vez de s² G(s)",
                                    "Confundir G(s) com T(s)"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar e interpretar resultados para diferentes tipos de sistemas",
                                  "subSteps": [
                                    "Para cada exemplo, compute e_ss e classifique: finito, infinito ou zero.",
                                    "Discuta implicações: sistemas Tipo 2 seguem aceleração constante com erro finito.",
                                    "Compare com entradas degrau/rampa para padrões de erro.",
                                    "Simule resposta em software se possível (step response para r(t)=t²/2).",
                                    "Conclua identificando quando usar sistemas Tipo 2+."
                                  ],
                                  "verification": "Tabela resumindo tipo, Ka, e_ss e interpretação para 3 exemplos.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "MATLAB/Simulink ou Python (control library)",
                                    "Gráficos de resposta temporal"
                                  ],
                                  "tips": "Use plot para visualizar y(t) aproximando r(t) - e_ss.",
                                  "learningObjective": "Interpretar cálculos no contexto de desempenho de controle.",
                                  "commonMistakes": [
                                    "Achar e_ss finito para Tipo 1",
                                    "Ignorar unidade da entrada parabólica"
                                  ]
                                }
                              ],
                              "practicalExample": "Para G(s) = 50 / (s² (s + 5)), Tipo 2: Ka = lim_{s→0} s² * 50 / (s² (s+5)) = 50/5 = 10. Assim, e_ss = 1/10 = 0.1 para r(t)=t²/2. Simule em MATLAB: entrada parabólica mostra y(t) → t²/2 - 0.1 assintoticamente.",
                              "finalVerifications": [
                                "Ka calculado corretamente via lim s² G(s) s→0.",
                                "e_ss = 1/Ka derivado e aplicado.",
                                "Tipo do sistema identificado pelo número de integradores.",
                                "e_ss=∞ corretamente para Tipo <2.",
                                "Exemplo prático simulado ou plotado.",
                                "Interpretação coerente com especificações de desempenho."
                              ],
                              "assessmentCriteria": [
                                "Precisão matemática nos limites e derivações (80%).",
                                "Correta classificação por tipo de sistema (15%).",
                                "Clareza na interpretação e exemplos (5%).",
                                "Uso adequado de ferramentas/simulações.",
                                "Identificação de erros comuns evitados.",
                                "Completude da tabela de análise."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Transformadas de Laplace, limites e análise assintótica.",
                                "Física: Cinemática (movimento uniformemente acelerado, parabólicas em projéteis).",
                                "Programação: Simulação numérica em Python/MATLAB (bibliotecas control, scipy).",
                                "Engenharia Mecânica: Controle de trajetórias em robótica.",
                                "Estatística: Análise de erro e variância em regime permanente."
                              ],
                              "realWorldApplication": "Em drones ou robôs, calcular e_ss para entrada parabólica garante rastreamento preciso de trajetórias aceleradas (ex: manobras de evasão), otimizando Ka no projeto para minimizar erro em aplicações como veículos autônomos ou sistemas de apontamento de antenas."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.1.3",
                    "name": "Locus das Raízes",
                    "description": "Técnica gráfica para síntese de controladores via colocação de polos do sistema em malha fechada.",
                    "individualConcepts": [
                      {
                        "id": "10.1.1.3.1",
                        "name": "Princípios Fundamentais do Locus das Raízes",
                        "description": "Conceitos básicos do método do locus das raízes, incluindo a equação característica do sistema em malha fechada e o papel do parâmetro de ganho K na localização das raízes.",
                        "specificSkills": [
                          {
                            "id": "10.1.1.3.1.1",
                            "name": "Entender a equação característica em malha fechada",
                            "description": "Derivar e interpretar a equação 1 + K G(s)H(s) = 0 para sistemas de laço unitário, identificando como as raízes variam com K de 0 a infinito.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o conceito de sistema em malha fechada e equação característica",
                                  "subSteps": [
                                    "Revise a estrutura básica de um sistema de controle em malha fechada com realimentação unitária.",
                                    "Identifique os componentes: planta G(s), controlador K e realimentação H(s).",
                                    "Explique o que é a equação característica: a equação que define os polos do sistema fechado.",
                                    "Diferencie entre malha aberta e fechada em termos de estabilidade.",
                                    "Desenhe um diagrama de blocos simples para um sistema unitário."
                                  ],
                                  "verification": "Desenhe corretamente o diagrama de blocos e defina a equação característica em palavras.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Diagrama de blocos em papel ou software como MATLAB/Simulink",
                                    "Livro-texto de controle (capítulo de revisão)"
                                  ],
                                  "tips": "Comece sempre pelo sinal de entrada e saída para evitar confusão nos loops.",
                                  "learningObjective": "Entender a topologia e o papel da equação característica em sistemas fechados.",
                                  "commonMistakes": [
                                    "Confundir G(s) com H(s)",
                                    "Ignorar o sinal de realimentação negativa"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Derivar a equação característica 1 + K G(s) H(s) = 0",
                                  "subSteps": [
                                    "Escreva a função de transferência em malha fechada: T(s) = K G(s) / (1 + K G(s) H(s)).",
                                    "Identifique o denominador como a equação característica: 1 + K G(s) H(s) = 0.",
                                    "Para laço unitário (H(s)=1), simplifique para 1 + K G(s) = 0.",
                                    "Substitua em um exemplo simples: G(s) = 1/s(s+1), derive o polinômio.",
                                    "Verifique a derivação expandindo o denominador."
                                  ],
                                  "verification": "Derive corretamente a equação para um G(s) dado e resolva para polos com K=1.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Caderno para derivações",
                                    "Calculadora simbólica ou MATLAB para expansão"
                                  ],
                                  "tips": "Use o método de sinal de fluxo ou superposição para validar a função de transferência.",
                                  "learningObjective": "Dominar a derivação analítica da equação característica.",
                                  "commonMistakes": [
                                    "Esquecer o sinal + no loop negativo",
                                    "Não normalizar para laço unitário"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Interpretar a equação para sistemas de laço unitário",
                                  "subSteps": [
                                    "Explique que 1 + K G(s) = 0 implica -1/K = G(s), base do locus das raízes.",
                                    "Identifique como K afeta os polos: raízes de 1 + K G(s) = 0.",
                                    "Para K=0, polos são os de G(s) (malha aberta).",
                                    "Para K→∞, polos tendem aos zeros de G(s) ou infinito.",
                                    "Plote qualitativamente a mudança de polos para um G(s) de segunda ordem."
                                  ],
                                  "verification": "Descreva verbalmente ou esboce como polos movem de K=0 a ∞.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Gráfico em papel milimetrado",
                                    "Software como rlocus no MATLAB"
                                  ],
                                  "tips": "Pense em K como 'ganho' que 'puxa' polos em direção aos zeros.",
                                  "learningObjective": "Interpretar o significado físico e matemático da equação.",
                                  "commonMistakes": [
                                    "Confundir polos de malha aberta com fechada",
                                    "Ignorar assimptotes para K→∞"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar variação das raízes com K de 0 a infinito",
                                  "subSteps": [
                                    "Calcule polos para valores discretos de K: 0, 1, 10, 100.",
                                    "Observe trajetórias: partem de polos abertos, vão a zeros ou ∞.",
                                    "Identifique condições de estabilidade (parte real negativa).",
                                    "Use regra de Routh para validar estabilidade vs K.",
                                    "Esboce o locus das raízes manualmente."
                                  ],
                                  "verification": "Plote ou liste polos para 5 valores de K e identifique faixa estável.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "MATLAB ou Python (control library)",
                                    "Tabela de Routh"
                                  ],
                                  "tips": "Comece com sistemas simples de 2ª ordem para intuição.",
                                  "learningObjective": "Prever comportamento dinâmico via variação de raízes com K.",
                                  "commonMistakes": [
                                    "Não considerar ângulos de partida/chegada",
                                    "Calcular errado para K→∞"
                                  ]
                                }
                              ],
                              "practicalExample": "Considere G(s) = 1/(s(s+2)). Derive 1 + K G(s) = 0 → s² + 2s + K = 0. Para K=0, polos em 0 e -2. Para K=4, polos em -1±j√3. Para K→∞, polos vão a ∞ em ângulos de 90° e 270°. Plote o locus e observe estabilidade para K>0.",
                              "finalVerifications": [
                                "Deriva corretamente 1 + K G(s)H(s)=0 para qualquer G(s),H(s) dados.",
                                "Identifica polos em K=0 e K→∞.",
                                "Esboça qualitativamente o locus das raízes.",
                                "Explica impacto de K na estabilidade.",
                                "Aplica em exemplo numérico com cálculo de polos.",
                                "Usa software para validar locus."
                              ],
                              "assessmentCriteria": [
                                "Precisão na derivação (100% correta).",
                                "Correta identificação de limites K=0 e ∞ (pontos exatos).",
                                "Descrição clara de trajetórias de raízes.",
                                "Análise de estabilidade via localização de polos.",
                                "Uso correto de ferramentas como Routh ou rlocus.",
                                "Exemplo prático resolvido sem erros."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Análise de polinômios e raízes complexas.",
                                "Física: Dinâmica de sistemas massa-mola-amortecedor.",
                                "Engenharia Elétrica: Projeto de amplificadores com realimentação.",
                                "Computação: Simulação numérica em MATLAB/Python.",
                                "Matemática Aplicada: Teoria de perturbação para ganhos altos."
                              ],
                              "realWorldApplication": "Em controle de velocidade de motores DC, a equação 1 + K/(s(Js+B)) = 0 determina como o ganho K estabiliza o sistema, evitando oscilações em drones ou robôs industriais, onde K é ajustado para resposta rápida sem overshoot."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.3.1.2",
                            "name": "Identificar polos e zeros do laço aberto",
                            "description": "Localizar polos e zeros da função de transferência em laço aberto G(s)H(s) no plano complexo e compreender seu impacto inicial no locus.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os conceitos fundamentais de polos e zeros",
                                  "subSteps": [
                                    "Defina polos como as raízes do denominador da função de transferência G(s)H(s), onde a resposta tende ao infinito.",
                                    "Defina zeros como as raízes do numerador de G(s)H(s), onde a resposta é anulada.",
                                    "Explique a diferença entre polos/zeros no plano s complexo: eixo real (σ) e imaginário (jω).",
                                    "Discuta a importância no contexto de laço aberto para análise de estabilidade inicial.",
                                    "Revise propriedades: polos determinam modos dominantes; zeros modificam a resposta."
                                  ],
                                  "verification": "Resuma em suas palavras os conceitos e dê um exemplo simples de G(s)H(s) com polos e zeros identificados.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Livro de controle (ex: Ogata), quadro branco ou papel para anotações"
                                  ],
                                  "tips": "Use analogias: polos como 'polos magnéticos' atraindo trajetórias, zeros como 'repulsores'.",
                                  "learningObjective": "Dominar definições e papéis de polos e zeros em funções de transferência de laço aberto.",
                                  "commonMistakes": "Confundir polos com zeros; ignorar multiplicidade de raízes."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Extrair e calcular polos e zeros de G(s)H(s)",
                                  "subSteps": [
                                    "Escreva a função de transferência G(s)H(s) em forma racional: N(s)/D(s).",
                                    "Encontre zeros resolvendo N(s) = 0 (raízes do numerador).",
                                    "Encontre polos resolvendo D(s) = 0 (raízes do denominador).",
                                    "Anote multiplicidades e forme canônica se necessário.",
                                    "Verifique simplificações cancelando fatores comuns (com cuidado para laço aberto)."
                                  ],
                                  "verification": "Liste polos e zeros para uma G(s)H(s) dada, mostrando equações resolvidas.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Calculadora simbólica (MATLAB/SymPy), papel para fatoração polinomial"
                                  ],
                                  "tips": "Fatore polinômios por tentativa-erro ou fórmula quadrática para baixos graus.",
                                  "learningObjective": "Calcular precisamente polos e zeros a partir de funções de transferência.",
                                  "commonMistakes": "Esquecer multiplicidade; cancelar fatores sem notar efeitos em root locus."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Plotar polos e zeros no plano complexo",
                                  "subSteps": [
                                    "Desenhe os eixos: horizontal (parte real, σ), vertical (parte imaginária, jω).",
                                    "Marque polos com 'X' (geralmente esquerdo para estabilidade).",
                                    "Marque zeros com 'O' (podem estar em qualquer lugar).",
                                    "Indique multiplicidades com números ou símbolos múltiplos.",
                                    "Escalone o gráfico adequadamente para visualização clara."
                                  ],
                                  "verification": "Desenhe o plano s com polos/zeros corretamente rotulados para um exemplo.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Software de plotagem (MATLAB rlocus, ou papel grafado), régua"
                                  ],
                                  "tips": "Use escala logarítmica mental para raízes distantes; pratique com eixos simétricos.",
                                  "learningObjective": "Representar visualmente polos e zeros no plano complexo.",
                                  "commonMistakes": "Trocar eixos real/imaginário; plotar magnitude em vez de posição."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar impacto inicial no locus das raízes",
                                  "subSteps": [
                                    "Lembre regras do root locus: inicia em polos abertos (K=0), termina em zeros ou infinito.",
                                    "Identifique ramos: número de ramos = número de polos.",
                                    "Note assimetrias por zeros finitos.",
                                    "Preveja comportamentos: polos reais → locus real; complexos → simétricos.",
                                    "Discuta estabilidade inicial baseada em localização (esquerda/direita do plano)."
                                  ],
                                  "verification": "Descreva qualitativamente o root locus inicial partindo dos polos/zeros plotados.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Exemplos de root locus de livros, MATLAB para validação"
                                  ],
                                  "tips": "Comece com casos simples (1 polo, 1 zero) para intuição.",
                                  "learningObjective": "Compreender como polos/zeros moldam o root locus.",
                                  "commonMistakes": "Ignorar simetria conjugada; confundir laço aberto com fechado."
                                }
                              ],
                              "practicalExample": "Para G(s)H(s) = (s+2) / [s (s+1) (s^2 + 4s + 5)], zeros: s=-2; polos: s=0, s=-1, s=-2±j1. No plano s: X em 0, -1, -2±j1; O em -2. Locus inicia em polos, um ramo para zero em -2, outros para infinito.",
                              "finalVerifications": [
                                "Calcula corretamente polos e zeros de G(s)H(s) dada.",
                                "Plota com precisão no plano complexo, incluindo multiplicidades.",
                                "Descreve verbalmente o impacto no root locus inicial.",
                                "Identifica erros comuns em exemplos fornecidos.",
                                "Aplica a um novo exemplo sem auxílio.",
                                "Explica relação com estabilidade em laço aberto."
                              ],
                              "assessmentCriteria": [
                                "Precisão no cálculo de raízes (100% correto).",
                                "Qualidade da plotagem (rótulos claros, escalas adequadas).",
                                "Profundidade da análise de impacto no locus (qualitativa e regras citadas).",
                                "Uso correto de terminologia técnica.",
                                "Capacidade de generalizar para funções complexas.",
                                "Tempo de execução eficiente sem erros graves."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Resolução de equações polinomiais e números complexos.",
                                "Física: Dinâmica de sistemas lineares e estabilidade oscilatória.",
                                "Programação: Uso de MATLAB/Python para rlocus e plotagem.",
                                "Eletrônica: Análise de filtros e amplificadores com polos/zeros."
                              ],
                              "realWorldApplication": "Em projetos de controladores PID para drones, identificar polos/zeros de laço aberto garante estabilidade inicial do root locus, evitando oscilações em voo autônomo ou falhas em sistemas industriais como motores de robôs."
                            },
                            "estimatedTime": "0.5 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.3.1.3",
                            "name": "Determinar o número e comportamento dos ramos do locus",
                            "description": "Calcular o número de ramos do locus como o número de polos finitos e descrever o comportamento assintótico para K → ∞.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Identificar polos e zeros finitos da função de transferência de malha aberta",
                                  "subSteps": [
                                    "Escreva a função de transferência G(s)H(s) do sistema de malha aberta.",
                                    "Calcule os polos resolvendo o denominador G(s)H(s) = 0.",
                                    "Calcule os zeros resolvendo o numerador G(s)H(s) = 0.",
                                    "Liste apenas os polos e zeros finitos (exclua polos ou zeros no infinito).",
                                    "Anote o número total de polos finitos (n_p)."
                                  ],
                                  "verification": "Verifique se a lista de polos e zeros coincide com cálculos algébricos ou plotagem no plano s.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Função de transferência G(s)H(s)",
                                    "Papel e calculadora",
                                    "Software como MATLAB ou Python (control library)"
                                  ],
                                  "tips": "Use fatoração para simplificar polinômios de alta ordem.",
                                  "learningObjective": "Compreender a representação no plano complexo dos polos e zeros.",
                                  "commonMistakes": "Confundir polos de malha aberta com malha fechada; incluir polos no infinito."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Determinar o número de ramos do locus das raízes",
                                  "subSteps": [
                                    "Lembre que o número de ramos é igual ao número de polos finitos (n_p).",
                                    "Confirme que ramos = n_p, independentemente do número de zeros.",
                                    "Desenhe setas nos polos iniciais para indicar direção dos ramos.",
                                    "Note que ramos em excesso vão para o infinito.",
                                    "Registre: Número de ramos = n_p."
                                  ],
                                  "verification": "O número declarado iguala exatamente o número de polos finitos contados.",
                                  "estimatedTime": "10 minutos",
                                  "materials": [
                                    "Lista de polos do Step 1",
                                    "Papel para esboço do plano s"
                                  ],
                                  "tips": "Ramos partem dos polos; memorize: ramos = polos finitos.",
                                  "learningObjective": "Associar o número de trajetórias do locus ao ordem do sistema.",
                                  "commonMistakes": "Contar zeros em vez de polos; esquecer polos múltiplos."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Descrever o comportamento dos ramos para K → 0",
                                  "subSteps": [
                                    "Para K=0, as raízes estão nos polos de G(s)H(s).",
                                    "Descreva: Ramos iniciam nos polos finitos.",
                                    "Se houver zeros, ramos terminam neles para K finito; excesso vai ao infinito.",
                                    "Esboce posições iniciais no plano s.",
                                    "Confirme estabilidade inicial baseada em polos."
                                  ],
                                  "verification": "Posições para K=0 coincidem com polos plotados.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Esboço do plano s do Step 2",
                                    "Gráficos de root locus software"
                                  ],
                                  "tips": "K=0 significa laço aberto; raízes = polos abertos.",
                                  "learningObjective": "Entender configuração inicial do locus.",
                                  "commonMistakes": "Confundir com comportamento em K=∞; ignorar multiplicidade de polos."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Descrever o comportamento assintótico para K → ∞",
                                  "subSteps": [
                                    "Calcule o número de assíntotas: n_a = n_p - n_z (ramos ao infinito).",
                                    "Ângulos das assíntotas: φ_k = (2k+1)π / n_a, k=0,1,...,n_a-1.",
                                    "Centro das assíntotas: σ_a = (∑ polos - ∑ zeros)/n_a.",
                                    "Descreva: Ramos seguem assíntotas para |s| → ∞.",
                                    "Esboce assíntotas no plano s."
                                  ],
                                  "verification": "Ângulos e centro calculados corretamente; coincidem com root locus plotado.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Lista de polos/zeros",
                                    "Calculadora para somas e ângulos",
                                    "Software de plotagem"
                                  ],
                                  "tips": "Use convenção de ângulos em graus ou radianos consistentemente.",
                                  "learningObjective": "Dominar regras assintóticas para predizer estabilidade em ganho alto.",
                                  "commonMistakes": "Erro no sinal dos ângulos; esquecer subtrair zeros no centro."
                                }
                              ],
                              "practicalExample": "Para G(s)H(s) = K / (s(s+1)(s+2)), polos em 0, -1, -2 (n_p=3, n_z=0). Ramos: 3. Para K→0: em polos. Para K→∞: 3 assíntotas em 60°, 180°, 300°; centro σ_a = (-3)/3 = -1.",
                              "finalVerifications": [
                                "Número de ramos igual ao número de polos finitos.",
                                "Comportamento K→0 descrito como partindo dos polos.",
                                "Assíntotas calculadas com ângulos e centro corretos.",
                                "Esboço do locus consistente com regras.",
                                "Predição de estabilidade para K alto válida.",
                                "Verificação via software (ex: rlocus em MATLAB) coincide."
                              ],
                              "assessmentCriteria": [
                                "Precisão no cálculo de n_p e n_a.",
                                "Correção dos ângulos e centro assintótico.",
                                "Descrição clara do comportamento em K=0 e K=∞.",
                                "Esboço qualitativo preciso do locus.",
                                "Identificação correta de excesso de polos.",
                                "Aplicação consistente das regras Evans."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Análise de funções racionais e plano complexo.",
                                "Física: Dinâmica linear de sistemas massa-mola-amortecedor.",
                                "Informática: Simulação numérica em MATLAB/Python.",
                                "Engenharia Elétrica: Projeto de compensadores de fase."
                              ],
                              "realWorldApplication": "Em projetos de controladores para drones ou robôs, prediz estabilidade em ganhos altos sem simulações completas, otimizando tempo em indústrias automotivas e aeroespaciais."
                            },
                            "estimatedTime": "0.5 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.1.3.2",
                        "name": "Regras de Construção do Diagrama de Locus das Raízes",
                        "description": "Regras gráficas padrão para esboçar o locus das raízes, incluindo assimptotas, ângulos de partida/chegada e cruzamentos com o eixo real.",
                        "specificSkills": [
                          {
                            "id": "10.1.1.3.2.1",
                            "name": "Aplicar regra das assimptotas",
                            "description": "Calcular centros, ângulos e número de assimptotas dos ramos do locus para K → ∞, usando fórmulas para sistemas com excesso de polos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Identificar o número de assíntotas baseado no excesso de polos",
                                  "subSteps": [
                                    "Analise a função de transferência G(s)H(s) para contar o número total de polos finitos (n) e zeros finitos (m).",
                                    "Calcule o excesso de polos σ = n - m.",
                                    "Confirme que σ > 0, indicando assíntotas para K → ∞.",
                                    "Anote σ como o número de assíntotas.",
                                    "Ignore polos ou zeros no infinito para esta contagem inicial."
                                  ],
                                  "verification": "Verifique se σ é um inteiro positivo e corresponde à diferença n - m listada.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Função de transferência G(s)H(s), papel ou software como MATLAB para fatoração.",
                                  "tips": "Liste polos e zeros em uma tabela para visualização rápida.",
                                  "learningObjective": "Compreender como o excesso de polos determina o comportamento assintótico do locus.",
                                  "commonMistakes": "Contar polos no infinito ou incluir zeros espúrios."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Calcular o centro das assíntotas (σ_a)",
                                  "subSteps": [
                                    "Some as partes reais de todos os polos finitos.",
                                    "Some as partes reais de todos os zeros finitos.",
                                    "Subtraia a soma dos zeros da soma dos polos: soma_polos - soma_zeros.",
                                    "Divida pelo excesso de polos: σ_a = (soma_polos - soma_zeros) / σ.",
                                    "Expresse σ_a como um número real."
                                  ],
                                  "verification": "Confirme que σ_a é um valor real e marque-o no eixo real do plano s.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Lista de polos e zeros, calculadora ou Python/MATLAB para somas precisas.",
                                  "tips": "Use números complexos apenas pelas partes reais; ignore partes imaginárias.",
                                  "learningObjective": "Dominar a fórmula do centro das assíntotas para alinhamento dos ramos.",
                                  "commonMistakes": "Incluir partes imaginárias na soma ou dividir incorretamente por σ."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Determinar os ângulos das assíntotas (φ_a)",
                                  "subSteps": [
                                    "Para cada q = 0, 1, ..., σ-1, calcule φ_a(q) = [(2q + 1) * 180°] / σ.",
                                    "Converta graus para radianos se necessário para plotagem.",
                                    "Liste todos os ângulos em ordem crescente.",
                                    "Meça os ângulos a partir do eixo positivo real, no sentido anti-horário para positivos.",
                                    "Verifique simetria em relação ao eixo real."
                                  ],
                                  "verification": "Os ângulos devem somar múltiplos de 360° e serem simétricos.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Tabela de q valores, calculadora de ângulos.",
                                  "tips": "Use fórmula em radianos: φ_a = (2q + 1)π / σ para consistência com software.",
                                  "learningObjective": "Aplicar a fórmula de ângulos para direcionar os ramos do locus ao infinito.",
                                  "commonMistakes": "Usar 360° em vez de 180° ou esquecer o +1 em (2q + 1)."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar e visualizar as assíntotas no diagrama de locus",
                                  "subSteps": [
                                    "Desenhe linhas retas a partir de σ_a nos ângulos φ_a calculados.",
                                    "Estenda as linhas ao infinito no plano s.",
                                    "Associe ramos do locus às assíntotas com base na ordem de partida.",
                                    "Simule ou plote o locus para validar o alinhamento com K grande.",
                                    "Anotar como os ramos se aproximam das assíntotas para K → ∞."
                                  ],
                                  "verification": "Ramos do locus devem convergir para as assíntotas em simulações numéricas.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Software de plotagem como MATLAB rlocus() ou Python control library.",
                                  "tips": "Comece com K=1000 para visualizar aproximação rápida.",
                                  "learningObjective": "Integrar cálculos de assíntotas na construção completa do diagrama de locus.",
                                  "commonMistakes": "Desenhar assíntotas curvadas em vez de retas ou ângulos errados."
                                }
                              ],
                              "practicalExample": "Para G(s)H(s) = K / [s(s+1)(s+2)], polos em 0, -1, -2 (n=3), zeros m=0, σ=3. Centro σ_a = (0-1-2)/3 = -1. Ângulos: q=0: 60°, q=1: 180°, q=2: 300°. Assíntotas saem de s=-1 nestes ângulos.",
                              "finalVerifications": [
                                "Número de assíntotas equals σ = n - m.",
                                "Centro σ_a calculado corretamente com somas reais.",
                                "Ângulos φ_a distribuídos uniformemente em 360°.",
                                "Assíntotas simétricas ao eixo real.",
                                "Simulação confirma convergência de ramos para K → ∞.",
                                "Nenhuma assíntota paralela ao eixo imaginário se σ par."
                              ],
                              "assessmentCriteria": [
                                "Precisão no cálculo de σ (exato match com n-m).",
                                "Correção na soma para σ_a (erro < 0.01).",
                                "Ângulos exatos em graus ou radianos (erro < 1°).",
                                "Desenho correto de linhas retas do centro.",
                                "Explicação clara da aproximação para K grande.",
                                "Validação via simulação ou sketch manual."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Análise de números complexos e geometria polar.",
                                "Física: Dinâmica de sistemas com comportamentos assintóticos.",
                                "Programação: Implementação em MATLAB/Python para rlocus.",
                                "Engenharia Elétrica: Estabilidade em filtros e osciladores."
                              ],
                              "realWorldApplication": "Em projetos de controladores PID para drones ou robôs, as assíntotas do locus das raízes guiam o tuning de ganhos K para garantir estabilidade e resposta rápida sem oscilações excessivas em altas velocidades."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.3.2.2",
                            "name": "Calcular ângulos de partida e chegada",
                            "description": "Determinar ângulos de partida em polos complexos e chegada em zeros usando a soma de ângulos de vetores de outros polos e zeros.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Identificar polos e zeros complexos no diagrama",
                                  "subSteps": [
                                    "Escreva a função de transferência em forma padrão G(s)H(s) = K * N(s)/D(s)",
                                    "Encontre todos os polos (raízes de D(s)=0) e zeros (raízes de N(s)=0)",
                                    "Marque polos (X) e zeros (O) no plano complexo, destacando polos/zeros complexos conjugados",
                                    "Confirme simetria em relação ao eixo real para pares conjugados",
                                    "Liste coordenadas exatas de cada polo e zero complexo alvo"
                                  ],
                                  "verification": "Diagrama de polos e zeros completo e simétrico, com pelo menos um polo/zero complexo identificado",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Função de transferência dada, papel milimetrado ou software como MATLAB/Python (control library)",
                                  "tips": "Use escala adequada no plano complexo para precisão angular",
                                  "learningObjective": "Localizar precisamente polos e zeros para cálculos angulares subsequentes",
                                  "commonMistakes": "Confundir polos com zeros ou ignorar pares conjugados"
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Calcular ângulos de partida de um polo complexo",
                                  "subSteps": [
                                    "Desenhe vetores do polo alvo para todos os zeros",
                                    "Meça o ângulo de cada vetor zero-polo (use atan2 para precisão)",
                                    "Desenhe vetores do polo alvo para todos os outros polos e meça seus ângulos",
                                    "Some os ângulos dos vetores zeros (φ_z) e subtraia a soma dos ângulos outros polos (φ_p)",
                                    "Aplique fórmula: φ_partida = 180° + Σφ_z - Σφ_p (para o polo superior; ajuste 360°-φ para inferior)"
                                  ],
                                  "verification": "Ângulo calculado em graus, com soma verificada e diagrama com setas angulares desenhado",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Régua, transportador ou função atan2 em calculadora/software",
                                  "tips": "Meça ângulos contra eixo real positivo; some módulo 360° se necessário",
                                  "learningObjective": "Dominar a regra de contribuição angular para partida de locus",
                                  "commonMistakes": "Esquecer o 180° ou inverter somas de polos/zeros"
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular ângulos de chegada em um zero complexo",
                                  "subSteps": [
                                    "Desenhe vetores do zero alvo para todos os polos",
                                    "Meça ângulos de cada vetor polo-zero",
                                    "Desenhe vetores do zero alvo para todos os outros zeros e meça ângulos",
                                    "Some ângulos polos (φ_p) e subtraia soma outros zeros (φ_z)",
                                    "Aplique fórmula: φ_chegada = Σφ_p - Σφ_z + 180° (ajuste para conjugado inferior)"
                                  ],
                                  "verification": "Ângulo de chegada calculado e consistente com direção do locus no diagrama",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Mesmo do step anterior, incluindo plot do locus parcial",
                                  "tips": "Verifique se ângulo de chegada é oposto ao de partida em casos simétricos",
                                  "learningObjective": "Aplicar simetricamente a regra para zeros complexos",
                                  "commonMistakes": "Usar fórmula errada (partida vs chegada) ou ignorar sinal do 180°"
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Validar e integrar ângulos no diagrama completo de locus",
                                  "subSteps": [
                                    "Desenhe setas iniciais de partida dos polos e finais de chegada nos zeros",
                                    "Verifique continuidade e simetria do locus proposto",
                                    "Use software para simular locus e comparar ângulos iniciais/finais",
                                    "Calcule para múltiplos polos/zeros se aplicável e anote discrepâncias",
                                    "Documente todos os ângulos em tabela com justificativa"
                                  ],
                                  "verification": "Diagrama de locus com ângulos marcados e simulação numérica coincidente (±5°)",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Software de controle (MATLAB rlocus ou Python control.rlocus)",
                                  "tips": "Simule com K pequeno para partida e K grande para chegada",
                                  "learningObjective": "Integrar cálculos em um diagrama coerente e validado",
                                  "commonMistakes": "Não verificar simetria ou inconsistências angulares"
                                }
                              ],
                              "practicalExample": "Para G(s) = K / [s(s+2)(s^2 + 2s + 2)], polos em 0, -2, -1±j. Para polo -1+j: vetores de zeros (nenhum)=0°, de outros polos: de 0 (~135°), de -2 (~158°). φ_partida = 180° + 0 - (135+158) = 180 - 293 = -113° ou 247°.",
                              "finalVerifications": [
                                "Ângulos de partida/chegada somam corretamente com contribuições vetoriais",
                                "Diagrama simétrico em relação ao eixo real",
                                "Simulação numérica confirma direção inicial/final do locus",
                                "Tabela de ângulos documentada com medidas exatas",
                                "Nenhuma violação de regras de ângulo total (180° k)",
                                "Consistência com outras regras de locus (ex: assimptotas)"
                              ],
                              "assessmentCriteria": [
                                "Precisão dos ângulos calculados (±2° de erro máximo)",
                                "Correta aplicação da fórmula de partida/chegada",
                                "Qualidade do diagrama com vetores e medidas visíveis",
                                "Validação via simulação ou cálculo alternativo",
                                "Explicação clara de cada soma angular",
                                "Identificação correta de erros comuns evitados"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Argumento de números complexos e funções trigonométricas",
                                "Física: Decomposição vetorial e diagramas de fase",
                                "Programação: Implementação de rlocus em Python/MATLAB",
                                "Geometria: Medição de ângulos em plano cartesiano"
                              ],
                              "realWorldApplication": "Em projeto de controladores PID para motores ou robôs, determinar ângulos de locus garante estabilidade inicial, evitando oscilações em sistemas como drones ou linhas de produção automáticas."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.3.2.3",
                            "name": "Encontrar pontos de cruzamento com o eixo real",
                            "description": "Usar o teste de Routh-Hurwitz ou a condição de argumento 180° para localizar interseções do locus com o eixo imaginário.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar a equação característica do sistema",
                                  "subSteps": [
                                    "Escrever a função de transferência em malha aberta G(s)H(s).",
                                    "Formular a equação característica 1 + K G(s)H(s) = 0.",
                                    "Expandir o polinômio em potências decrescentes de s.",
                                    "Identificar os coeficientes do polinômio P(s) = 0.",
                                    "Verificar o grau do polinômio e normalizar se necessário."
                                  ],
                                  "verification": "A equação característica está corretamente expandida e os coeficientes foram verificados por substituição de valores simples.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Função de transferência do sistema",
                                    "Papel e calculadora",
                                    "Software como MATLAB ou Python (opcional)"
                                  ],
                                  "tips": "Sempre inclua o ganho K explicitamente e normalize o polinômio para coeficiente líder = 1.",
                                  "learningObjective": "Formular com precisão a equação característica para análise de estabilidade via root locus.",
                                  "commonMistakes": [
                                    "Esquecer o termo K na equação",
                                    "Erros de sinal na expansão polinomial",
                                    "Não normalizar o polinômio"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Aplicar o Critério de Routh-Hurwitz para identificar cruzamentos",
                                  "subSteps": [
                                    "Construir o array de Routh a partir dos coeficientes de P(s).",
                                    "Identificar a linha com todos zeros ou elemento zero na primeira coluna.",
                                    "Formar o polinômio auxiliar da linha anterior e derivá-lo.",
                                    "Substituir no array e continuar até encontrar as condições para raízes puramente imaginárias.",
                                    "Resolver as equações resultantes para valores de K e ω (frequência de cruzamento)."
                                  ],
                                  "verification": "O array de Routh está completo sem erros aritméticos e produz valores reais positivos para K e ω.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Array de Routh em planilha ou papel",
                                    "Calculadora para divisões",
                                    "Tabela de exemplo resolvida"
                                  ],
                                  "tips": "Use epsilon (ε pequeno) para linhas quase zero em vez de auxiliar para prática inicial.",
                                  "learningObjective": "Utilizar Routh-Hurwitz para determinar ganhos críticos e frequências de oscilação.",
                                  "commonMistakes": [
                                    "Erro no cálculo da derivada auxiliar",
                                    "Inversão de sinais nas substituições",
                                    "Ignorar raízes múltiplas"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Aplicar a condição de argumento de 180° para confirmação",
                                  "subSteps": [
                                    "Substituir s = jω na equação característica P(jω) = 0.",
                                    "Separar P(jω) em partes real e imaginária: Re(P) + j Im(P) = 0.",
                                    "Montar o sistema de duas equações: Re(P) = 0 e Im(P) = 0.",
                                    "Resolver numericamente ou analiticamente para ω e K.",
                                    "Verificar se os ângulos de cada polo/zero somam 180° + 360°k."
                                  ],
                                  "verification": "As soluções de ω e K coincidem com as obtidas pelo método de Routh dentro de tolerância de 1%.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Equação característica",
                                    "Software simbólico como SymPy ou MATLAB",
                                    "Gráfica de fase manual"
                                  ],
                                  "tips": "Comece com aproximações gráficas do root locus para estimar ω antes do cálculo exato.",
                                  "learningObjective": "Aplicar a condição de fase para localizar interseções independentes do método de Routh.",
                                  "commonMistakes": [
                                    "Confundir parte real com imaginária",
                                    "Esquecer o fator K na magnitude",
                                    "Não verificar múltiplas soluções para ω"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificar resultados e interpretar os pontos de cruzamento",
                                  "subSteps": [
                                    "Comparar resultados dos dois métodos (Routh e 180°).",
                                    "Plotar os pontos (jω e -jω) no plano s e sobrepor ao root locus aproximado.",
                                    "Calcular o ganho K crítico correspondente.",
                                    "Analisar implicações para estabilidade (margem de ganho).",
                                    "Simular o sistema no MATLAB para confirmação visual."
                                  ],
                                  "verification": "Simulação mostra oscilação marginal no K crítico identificado.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Software de simulação (MATLAB/Simulink)",
                                    "Plano s-plot manual",
                                    "Dados dos passos anteriores"
                                  ],
                                  "tips": "Sempre valide com simulação numérica para detectar erros analíticos.",
                                  "learningObjective": "Interpretar os cruzamentos como limites de estabilidade e validar múltiplos métodos.",
                                  "commonMistakes": [
                                    "Interpretar erroneamente o sinal de ω",
                                    "Não considerar simetria do locus",
                                    "Ignorar efeitos de atrasos"
                                  ]
                                }
                              ],
                              "practicalExample": "Considere G(s)H(s) = K / (s(s+1)(s+2)). Equação característica: s^3 + 3s^2 + 2s + K = 0. Pelo Routh: array leva a ω = sqrt(2 - K/2) ≈ 1 (para K≈2), confirmado pela condição 180° resolvendo tan(ω) equações, obtendo ω≈1.0 e K≈2. Pontos: s= ±j1. Simule em MATLAB: rlocus(sys) mostra cruzamento exato.",
                              "finalVerifications": [
                                "Constrói array de Routh sem erros para polinômio de 3ª ordem.",
                                "Resolve corretamente sistema real/imaginário para ω e K.",
                                "Identifica ganho crítico com precisão de 5%.",
                                "Valida com plot de root locus em software.",
                                "Explica implicações para estabilidade do sistema.",
                                "Compara resultados de ambos métodos com concordância."
                              ],
                              "assessmentCriteria": [
                                "Precisão matemática nos cálculos (sem erros aritméticos).",
                                "Correta aplicação de ambos métodos (Routh e 180°).",
                                "Validação cruzada e simulação incluída.",
                                "Interpretação física dos resultados (estabilidade).",
                                "Clareza na documentação dos passos.",
                                "Eficiência temporal (dentro de 75 minutos totais)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Resolução de equações transcendentais e arrays tabulares.",
                                "Física: Análise de oscilações harmônicas e estabilidade dinâmica.",
                                "Informática: Programação numérica em MATLAB/Python para simulações.",
                                "Engenharia Mecânica: Controle de vibrações em estruturas.",
                                "Estatística: Análise de sensibilidade de parâmetros."
                              ],
                              "realWorldApplication": "Em projetos de controladores para drones ou robôs industriais, esses pontos definem o ganho máximo K antes de oscilações instáveis, evitando falhas catastróficas em linhas de produção ou voos autônomos."
                            },
                            "estimatedTime": "0.5 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.3.2.4",
                            "name": "Esboçar o locus completo manualmente",
                            "description": "Combinar todas as regras para desenhar o diagrama de locus das raízes de um sistema escalar dado.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar dados fundamentais do sistema",
                                  "subSteps": [
                                    "Identifique todos os polos e zeros da função de transferência em malha aberta G(s)H(s).",
                                    "Calcule o número de assíntotas: n_a = número de polos - número de zeros finitos.",
                                    "Determine o ângulo das assíntotas: φ_a = (2q+1) * 180° / n_a, para q = 0,1,...,n_a-1.",
                                    "Calcule o centroide das assíntotas: σ_a = (∑ polos reais - ∑ zeros reais) / n_a.",
                                    "Marque os polos (×) e zeros (○) no plano complexo."
                                  ],
                                  "verification": "Verifique se polos, zeros, n_a, φ_a e σ_a estão corretamente calculados e plotados.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel milimetrado ou software de desenho como GeoGebra",
                                    "Função de transferência G(s)H(s)",
                                    "Calculadora ou MATLAB para cálculos iniciais"
                                  ],
                                  "tips": "Use notação padrão: polos como ×, zeros como ○. Sempre confira o número de polos e zeros.",
                                  "learningObjective": "Dominar identificação de elementos básicos e parâmetros assintóticos do locus.",
                                  "commonMistakes": [
                                    "Confundir polos com zeros",
                                    "Erro no cálculo do centroide (esquecer sinal negativo para zeros)",
                                    "Ignorar polos/zeros complexos conjugados"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Aplicar regras de simetria e direções iniciais",
                                  "subSteps": [
                                    "Desenhe o eixo real e aplique simetria: locus é simétrico em relação ao eixo real.",
                                    "Calcule ângulos de partida dos polos: use fórmula com contribuições de outros polos/zeros.",
                                    "Calcule ângulos de chegada nos zeros: similar à partida, mas invertido.",
                                    "Para polos/zeros no eixo real, locus segue o eixo real entre eles.",
                                    "Marque direções iniciais de partida dos polos."
                                  ],
                                  "verification": "Confira simetria e ângulos de partida/chegada com cálculos numéricos (ex: φ_part = 180° + ∑φ_zeros - ∑φ_polos).",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Régua e compasso para ângulos",
                                    "Tabela de funções trigonométricas",
                                    "Planilha Excel para cálculos angulares"
                                  ],
                                  "tips": "Ângulos em graus; use vetor unitário para visualização. Para pares conjugados, ângulo de um determina o outro.",
                                  "learningObjective": "Entender e aplicar regras de simetria e direções de trajetória inicial.",
                                  "commonMistakes": [
                                    "Esquecer simetria para conjugados",
                                    "Erro de sinal nos ângulos de partida (deve ser 180° para real positivo)",
                                    "Não considerar ordem de polos/zeros próximos"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Localizar pontos críticos: breakaway, breakin e cruzamentos",
                                  "subSteps": [
                                    "Encontre pontos de breakaway/breakin resolvendo dK/ds = 0 ao longo do eixo real.",
                                    "Calcule K para pontos no eixo real: K = produto de distâncias aos polos / zeros.",
                                    "Determine cruzamentos com eixo imaginário: resolva equação característica para s = jω.",
                                    "Use regra 180°: locus onde soma de ângulos de G(s)H(s) = ±180°(2k+1).",
                                    "Marque esses pontos no diagrama."
                                  ],
                                  "verification": "Valide pontos resolvendo numericamente dK/ds=0 e verificando sinal de K.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Software simbólico como SymPy ou MATLAB para derivadas",
                                    "Gráfica para resolver polinômios",
                                    "Papel para esboços preliminares"
                                  ],
                                  "tips": "Breakaway onde múltiplas raízes se separam; teste pontos próximos para confirmar.",
                                  "learningObjective": "Identificar e calcular pontos de ramificação e instabilidade.",
                                  "commonMistakes": [
                                    "Não diferenciar breakaway (K crescente) de breakin",
                                    "Erro em K para eixo real (potências erradas)",
                                    "Ignorar múltiplas soluções para dK/ds=0"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Desenhar assíntotas e completar o locus",
                                  "subSteps": [
                                    "Desenhe linhas assintóticas a partir do centroide com ângulos φ_a.",
                                    "Conecte trajetórias: de polos para zeros ou assíntotas, respeitando regras.",
                                    "Reforce com regra da magnitude: |G(s)H(s)| = 1/K para pontos no locus.",
                                    "Esboce curvas suaves passando por pontos críticos.",
                                    "Rotule ganho K em pontos chave (ex: K=0 nos polos)."
                                  ],
                                  "verification": "O locus deve satisfazer condição de argumento (180°) e magnitude em 3-5 pontos aleatórios.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Transferidor para assíntotas",
                                    "Curvas suaves com lápis flexível ou software",
                                    "Tabela de valores de K"
                                  ],
                                  "tips": "Assíntotas guiam para K→∞; desenhe levemente e ajuste iterativamente.",
                                  "learningObjective": "Finalizar diagrama completo integrando todas regras.",
                                  "commonMistakes": [
                                    "Assíntotas erradas (centroide fora)",
                                    "Trajetórias não respeitando partida/chegada",
                                    "Esquecer ramificações para ∞"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Revisar e anotar o diagrama completo",
                                  "subSteps": [
                                    "Verifique continuidade e fechamento das trajetórias.",
                                    "Anotar regiões de estabilidade (lado esquerdo do eixo imaginário).",
                                    "Indique valores de K críticos (marginal, instável).",
                                    "Compare com simulação rápida em software.",
                                    "Adicione legenda: polos, zeros, assíntotas, pontos chave."
                                  ],
                                  "verification": "Diagrama deve coincidir 90% com root locus plotado em MATLAB/Octave.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Software de controle (MATLAB rlocus)",
                                    "Lápis de cor para anotações"
                                  ],
                                  "tips": "Use cores: azul para locus estável, vermelho para instável.",
                                  "learningObjective": "Garantir precisão e comunicabilidade do esboço manual.",
                                  "commonMistakes": [
                                    "Não indicar K em pontos",
                                    "Regiões de estabilidade invertidas",
                                    "Falta de legenda"
                                  ]
                                }
                              ],
                              "practicalExample": "Para G(s)H(s) = K / [s(s+1)(s+2)], polos em 0, -1, -2; sem zeros. n_a=3, centroide=-1, assíntotas 60°,180°,300°. Breakaway em ~ -0.42. Locus inicia em polos, breakaway no eixo real, cruza imaginário em ±j√2, segue assíntotas.",
                              "finalVerifications": [
                                "Locus inicia em todos os polos para K=0 e termina em zeros ou ∞.",
                                "Simetria perfeita em relação ao eixo real.",
                                "Pontos de breakaway/breakin corretamente localizados e validados por dK/ds=0.",
                                "Assíntotas emanam do centroide correto com ângulos precisos.",
                                "Condição de argumento satisfeita em pontos amostrados.",
                                "Regiões de estabilidade claramente indicadas."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de polos/zeros e parâmetros assintóticos (20%).",
                                "Correção de ângulos de partida/chegada e simetria (25%).",
                                "Localização exata de pontos críticos (breakaway, cruzamentos) (25%).",
                                "Qualidade do esboço das trajetórias e assíntotas (20%).",
                                "Anotações completas, legenda e análise de estabilidade (10%)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Análise complexa, polinômios e derivadas (dK/ds=0).",
                                "Física: Dinâmica de sistemas oscilatórios e estabilidade.",
                                "Programação: Implementação numérica de root locus em Python/MATLAB.",
                                "Engenharia Elétrica: Projeto de compensadores e análise de Bode."
                              ],
                              "realWorldApplication": "Em projetos de controladores PID para drones ou robôs, o esboço manual rápido permite selecionar ganhos K para estabilidade sem simulações computacionais demoradas, otimizando desempenho em tempo real."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.1.3.3",
                        "name": "Síntese de Controladores via Locus das Raízes",
                        "description": "Utilização do diagrama de locus para projetar controladores proporcionais ou compensados, visando colocação de polos em malha fechada para atender especificações de desempenho.",
                        "specificSkills": [
                          {
                            "id": "10.1.1.3.3.1",
                            "name": "Selecionar ganho K para polos desejados",
                            "description": "Dado um polo desejado no locus, calcular o valor de K usando a magnitude da função de transferência em laço aberto.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Identificar e representar a função de transferência em laço aberto G(s)H(s)",
                                  "subSteps": [
                                    "Analise o diagrama de blocos do sistema de controle para extrair G(s) e H(s).",
                                    "Escreva a função de transferência em laço aberto no formato polinomial: G(s)H(s) = K_num / (s^p (s+z1)...(s+zn)).",
                                    "Normalize a função se necessário, garantindo que o ganho DC seja 1 ou explicitado.",
                                    "Desenhe o plano s complexo e marque os polos e zeros conhecidos.",
                                    "Confirme a ordem do sistema e o número de polos/zeros."
                                  ],
                                  "verification": "Verifique se G(s)H(s) está corretamente escrita e seus polos/zeros coincidem com o diagrama de blocos.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Diagrama de blocos do sistema, papel quadriculado, calculadora científica",
                                  "tips": "Sempre comece pelo laço aberto; ignore o controlador inicialmente se for síntese via locus.",
                                  "learningObjective": "Compreender a estrutura da função de transferência em laço aberto para análise de locus das raízes.",
                                  "commonMistakes": "Confundir laço aberto com fechado; esquecer fatores de ganho constantes."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Selecionar o polo desejado s_d e validar sua posição no locus das raízes",
                                  "subSteps": [
                                    "Defina os requisitos de desempenho (ex: tempo de acomodação, overshoot) para escolher s_d.",
                                    "Calcule o ângulo de G(s_d)H(s_d) e verifique se é 180° + 360°k (regra de ângulo do locus).",
                                    "Use ferramentas gráficas (sketch do locus) para confirmar que s_d intersecta o traçado.",
                                    "Ajuste s_d se necessário para satisfazer a condição de fase.",
                                    "Anote a posição complexa de s_d (parte real e imaginária)."
                                  ],
                                  "verification": "O ângulo de G(s_d)H(s_d) deve ser odd multiple de 180°; confirme numericamente.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Software de cálculo simbólico (MATLAB/SymPy) ou calculadora complexa, régua e compasso para sketch",
                                  "tips": "Comece com polos dominantes próximos ao eixo imaginário para boa estabilidade.",
                                  "learningObjective": "Validar se um ponto no plano s pertence ao locus das raízes usando a regra de fase.",
                                  "commonMistakes": "Ignorar a condição de ângulo; escolher s_d fora do locus sem verificação."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular a magnitude |G(s_d)H(s_d)|",
                                  "subSteps": [
                                    "Substitua s = s_d na função G(s)H(s).",
                                    "Calcule cada termo (polos e zeros) como números complexos: distância de s_d a cada polo/zero.",
                                    "Some os ângulos vetoriais para confirmar fase (opcional, mas recomendado).",
                                    "Compute o produto das magnitudes: |G(s_d)H(s_d)| = produto(|zeros|) / produto(|polos|).",
                                    "Arredonde para precisão de 3 casas decimais."
                                  ],
                                  "verification": "Compare com cálculo manual vetorial: magnitudes de vetores de s_d aos polos/zeros.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Calculadora gráfica (TI-89 ou similar), MATLAB para plot de vetores",
                                  "tips": "Visualize vetores no plano s: magnitude é produto de comprimentos de vetores zero-polo.",
                                  "learningObjective": "Aplicar a regra de magnitude para pontos no locus das raízes.",
                                  "commonMistakes": "Usar módulo quadrado em vez de módulo; esquecer normalização de ganho."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Determinar o ganho K e realizar verificações finais",
                                  "subSteps": [
                                    "Calcule K = 1 / |G(s_d)H(s_d)|.",
                                    "Simule o sistema fechado com K para confirmar polos em s_d.",
                                    "Verifique margens de ganho e fase aproximadas.",
                                    "Analise estabilidade (todos polos no semiplano esquerdo).",
                                    "Documente o valor de K e posição dos polos."
                                  ],
                                  "verification": "Simulação mostra polos exatamente em s_d; resposta no tempo atende specs.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Software de simulação (MATLAB/Simulink), tabela de especificações de desempenho",
                                  "tips": "Use rlocus() no MATLAB para validar graficamente.",
                                  "learningObjective": "Sintetizar o ganho K para posicionamento preciso de polos desejados.",
                                  "commonMistakes": "Inverter a fórmula (K = |G| em vez de 1/|G|); não verificar outros polos."
                                }
                              ],
                              "practicalExample": "Para G(s)H(s) = 1 / (s(s+2)), polo desejado s_d = -1 + j. Vetores: de s_d a 0: | -1+j | = √2; a -2: |1+j| = √2. |G(s_d)| = 1/(√2 * √2) = 1/2. Assim, K = 1 / (1/2) = 2. Simule e confirme polo em -1 ± j.",
                              "finalVerifications": [
                                "Ângulo de G(s_d)H(s_d) é 180° + 360°k.",
                                "|G(s_d)H(s_d)| calculada corretamente via vetores.",
                                "K = 1 / |G(s_d)H(s_d)| exato.",
                                "Simulação confirma polos em s_d.",
                                "Sistema estável com todos polos no semiplano esquerdo.",
                                "Resposta atende especificações de desempenho iniciais."
                              ],
                              "assessmentCriteria": [
                                "Precisão no cálculo de magnitude (erro < 5%).",
                                "Correta aplicação da regra de ângulo para validação do polo.",
                                "Fórmula de K aplicada sem inversão.",
                                "Verificação via simulação ou sketch do locus.",
                                "Documentação clara com valores numéricos.",
                                "Análise de estabilidade incluída."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Cálculo de magnitudes e argumentos de números complexos.",
                                "Física: Modelagem dinâmica de sistemas massa-mola-amortecedor.",
                                "Informática: Programação em MATLAB para root locus e simulações.",
                                "Engenharia Mecânica: Controle de vibrações em estruturas."
                              ],
                              "realWorldApplication": "No controle de velocidade de motores DC em robótica industrial, onde o ganho K é ajustado para posicionar polos que garantam resposta rápida sem oscilações excessivas, otimizando precisão em linhas de montagem automáticas."
                            },
                            "estimatedTime": "0.5 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.3.3.2",
                            "name": "Projetar compensadores de avanço e atraso",
                            "description": "Modificar o locus adicionando zeros e polos compensadores para reposicionar os polos em malha fechada conforme especificações de estabilidade e desempenho.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Análise do Sistema Não Compensado",
                                  "subSteps": [
                                    "Obtenha a função de transferência da planta G(s) e as especificações de desempenho (ex: fator de amortecimento ζ, frequência natural ω_n).",
                                    "Plote o locus das raízes da malha aberta G(s)H(s) usando ferramentas como MATLAB rlocus().",
                                    "Identifique os polos e zeros atuais e avalie a posição dos polos em malha fechada sem compensação.",
                                    "Determine o ganho K necessário para posicionar os polos próximos às especificações desejadas.",
                                    "Calcule margens de fase e ganho iniciais para baseline."
                                  ],
                                  "verification": "Locus plotado corretamente com polos fechados identificados e discrepâncias às specs documentadas.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "MATLAB ou Octave com Control Systems Toolbox",
                                    "Função de transferência G(s)",
                                    "Especificações de projeto"
                                  ],
                                  "tips": "Use rlocus(G) para visualização interativa; anote ângulos de partida/chegada para insights.",
                                  "learningObjective": "Compreender o comportamento do locus das raízes sem compensação e identificar necessidades de correção.",
                                  "commonMistakes": [
                                    "Esquecer de incluir o ganho K no plot",
                                    "Ignorar regras de construção do locus (ângulos de 180°)",
                                    "Não normalizar G(s) adequadamente"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Definição da Localização Desejada de Polos e Estratégia de Compensação",
                                  "subSteps": [
                                    "Selecione os polos desejados no plano s com base nas specs (ex: σ = -ζω_n, ω_d = ω_n√(1-ζ²)).",
                                    "Decida entre compensador de avanço (para melhorar resposta transitória) ou atraso (para estabilidade estática).",
                                    "Calcule o ângulo de fase defasagem φ necessário no ponto desejado: φ = 180° + ∠G(s_d)H(s_d).",
                                    "Determine a magnitude |G(s_d)H(s_d)| para o ganho compensado.",
                                    "Esboce graficamente a contribuição do compensador no diagrama de fase."
                                  ],
                                  "verification": "Polos desejados plotados no locus e ângulo φ calculado com erro <5°.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Papel milimetrado ou software de plot (MATLAB sgrid())",
                                    "Calculadora ou script para ângulos"
                                  ],
                                  "tips": "Use a condição de ângulo para avanço (>0) e magnitude para posicionamento exato.",
                                  "learningObjective": "Mapear especificações de desempenho para posições de polos desejadas e quantificar necessidades de fase.",
                                  "commonMistakes": [
                                    "Confundir avanço (positivo φ) com atraso (negativo)",
                                    "Não considerar o ramo dominante do locus",
                                    "Erro em cálculo de ∠G(s_d)"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Síntese do Compensador de Avanço ou Atraso",
                                  "subSteps": [
                                    "Para avanço: Escolha zero z próximo ao polo desejado (z = s_d * 0.1-0.2), polo p = 10z para alta frequência.",
                                    "Para atraso: Coloque zero e polo próximos à origem (z próximo a 1/τ, p = z/10) para atenuação de ganho baixo freq.",
                                    "Forme D(s) = K (s+z)/(s+p), ajuste K para |D(s_d)G(s_d)|=1.",
                                    "Plote o novo locus com rlocus(G*D) e verifique se polos passam pelo s_d.",
                                    "Ajuste iterativamente z/p até satisfação das specs."
                                  ],
                                  "verification": "Novo locus passa pelo polo desejado com ganho K_correto e fase melhorada.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "MATLAB rlocus() e rlocfind()",
                                    "Templates de compensadores"
                                  ],
                                  "tips": "Para avanço, maximize separação z-p para ganho de fase; para atraso, minimize para steady-state.",
                                  "learningObjective": "Construir e otimizar D(s) para reposicionar polos via adição de zero/polo.",
                                  "commonMistakes": [
                                    "Escolher p muito próximo de z (pouca fase)",
                                    "Não recalcular K após adição",
                                    "Ignorar efeitos em outros ramos do locus"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Validação, Simulação e Ajustes Finais",
                                  "subSteps": [
                                    "Simule a resposta em malha fechada step() ou lsim() para verificar overshoot, tempo de assentamento.",
                                    "Calcule novas margens de fase/ganho com margin() e compare com specs.",
                                    "Analise sensibilidade variando parâmetros e ajuste D(s) se necessário.",
                                    "Implemente em diagrama de blocos e gere código para hardware se aplicável.",
                                    "Documente o design final com plots e equações."
                                  ],
                                  "verification": "Respostas simuladas atendem specs (±10%) e documentação completa.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Simulink para simulação não-linear",
                                    "Relatório template"
                                  ],
                                  "tips": "Sempre valide com Bode plot para robustez além do locus.",
                                  "learningObjective": "Validar o compensador holisticamente e iterar para robustez.",
                                  "commonMistakes": [
                                    "Apenas verificar locus sem simular tempo",
                                    "Esquecer não-linearidades",
                                    "Não documentar iterações"
                                  ]
                                }
                              ],
                              "practicalExample": "Para um motor DC com G(s) = 1/(s(s+1)), specs: ζ=0.5, ω_n=2 rad/s. Polo desejado s_d ≈ -1 + j1.73. Adicione avanço D(s)=K(s+0.5)/(s+5), ajuste K=8. Novo locus passa por s_d, overshoot <20%.",
                              "finalVerifications": [
                                "Polos dominantes em malha fechada coincidem com specs (±10%).",
                                "Margem de fase >45° e ganho >6dB.",
                                "Resposta ao degrau: overshoot <25%, assentamento <4/ω_n.",
                                "Locus modificado atrai polos corretamente sem instabilidades.",
                                "Ganho DC ajustado para erro steady-state <5%.",
                                "Simulação confirma estabilidade em faixa de parâmetros."
                              ],
                              "assessmentCriteria": [
                                "Precisão no cálculo de φ e K (erro <5%).",
                                "Escolha ótima de z/p (fase máxima com mínimo ordem).",
                                "Validação completa com plots e simulações.",
                                "Explicação clara de trade-offs avanço vs. atraso.",
                                "Robustez demonstrada via sensibilidade.",
                                "Documentação profissional com equações e figuras."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Análise complexa (polos/zeros), geometria no plano s.",
                                "Física: Dinâmica de sistemas de segunda ordem, estabilidade.",
                                "Programação: Scripts MATLAB para automação de design.",
                                "Eletrônica: Implementação analógica/digital de compensadores.",
                                "Gestão de Projetos: Iteração e trade-offs em specs."
                              ],
                              "realWorldApplication": "Em servomecanismos de robótica, onde compensadores de avanço melhoram precisão de rastreamento em braços robóticos; atraso em reguladores de tensão para estabilidade sem oscilações em fontes de alimentação de aviões."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.3.3.3",
                            "name": "Avaliar robustez e sensibilidade",
                            "description": "Analisar o locus para avaliar margens de estabilidade e impacto de variações paramétricas no posicionamento dos polos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar o modelo nominal e plotar o locus das raízes básico",
                                  "subSteps": [
                                    "Obtenha a função de transferência em malha aberta do sistema de controle (G(s)H(s)).",
                                    "Use software como MATLAB ou Python (biblioteca control) para plotar o locus das raízes nominal.",
                                    "Identifique os polos e zeros iniciais e o comportamento do locus com variação de ganho K.",
                                    "Marque pontos críticos como cruzamentos do eixo imaginário e asymptotes.",
                                    "Anote as margens de estabilidade nominais (ganho de fase, margem de ganho)."
                                  ],
                                  "verification": "Verifique se o gráfico do locus é plotado corretamente e coincide com cálculos manuais para K=1.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "MATLAB/Octave/Python com biblioteca control, função de transferência do sistema",
                                  "tips": "Sempre normalize o ganho para K=1 inicialmente para evitar escalas erradas.",
                                  "learningObjective": "Compreender o comportamento dinâmico do sistema nominal via locus das raízes.",
                                  "commonMistakes": "Esquecer de incluir o controlador no loop de malha aberta; plotar locus fechado por engano."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar parâmetros sensíveis e modelar variações paramétricas",
                                  "subSteps": [
                                    "Liste parâmetros da planta ou controlador sujeitos a variações (ex: ganho da planta Kp ±20%, tempo constante τ ±10%).",
                                    "Defina faixas realistas de variação baseadas em tolerâncias de fabricação ou especificações.",
                                    "Crie funções de transferência perturbadas para cada parâmetro (ex: G_pert(s) = G(s) * (1 + δ)).",
                                    "Calcule numericamente o impacto inicial em polos dominantes para uma variação única.",
                                    "Documente as perturbações em uma tabela para rastreamento."
                                  ],
                                  "verification": "Confirme que as perturbações alteram a função de transferência corretamente comparando respostas em malha fechada.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Planilha ou tabela em software, funções de transferência simbólicas (SymPy ou MATLAB Symbolic)",
                                  "tips": "Priorize parâmetros que afetam polos reais ou de baixa frequência primeiro.",
                                  "learningObjective": "Selecionar e modelar perturbações paramétricas relevantes para análise de sensibilidade.",
                                  "commonMistakes": "Escolher variações muito pequenas (ex: 1%) que mascaram efeitos; ignorar acoplamentos entre parâmetros."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Plotar loci das raízes para casos perturbados e comparar",
                                  "subSteps": [
                                    "Gere plots de locus para cada variação paramétrica usando loops em software.",
                                    "Sobreponha os loci nominais e perturbados no mesmo gráfico para visualização.",
                                    "Meça deslocamentos nos polos dominantes (distância euclidiana no plano complexo).",
                                    "Identifique mudanças em margens: variação na frequência de cruzamento e ângulo de fase.",
                                    "Registre valores numéricos de polos para +δ e -δ em uma tabela comparativa."
                                  ],
                                  "verification": "Os loci perturbados devem divergir visivelmente do nominal em regiões críticas.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Software de plotagem (MATLAB rlocus(), Python control.root_locus()), gráficos sobrepostos",
                                  "tips": "Use cores diferentes e legendas claras; amplie regiões de interesse com zoom.",
                                  "learningObjective": "Visualizar e quantificar impactos de perturbações no posicionamento dos polos.",
                                  "commonMistakes": "Não normalizar ganhos perturbados; confundir locus com diagrama de Bode."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar margens de estabilidade e quantificar sensibilidade",
                                  "subSteps": [
                                    "Calcule margens de ganho e fase para cada caso perturbado usando margin() ou similar.",
                                    "Compute índices de sensibilidade: ∂p/∂θ onde p é polo, θ é parâmetro (aproximação finita).",
                                    "Avalie robustez: verifique se polos permanecem no semiplano esquerdo para todas variações.",
                                    "Determine o pior caso (maior deslocamento ou menor margem) e proponha limites aceitáveis.",
                                    "Gere relatório com métricas: variação máxima de damping ratio (ζ) e frequência natural (ωn)."
                                  ],
                                  "verification": "Todas margens > 6dB (ganho) e 45° (fase) no pior caso, ou conforme specs.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Funções de análise de estabilidade (MATLAB margin(), stepinfo()), calculadora numérica",
                                  "tips": "Use derivadas numéricas para sensibilidade: (p(θ+Δ) - p(θ-Δ))/(2Δ).",
                                  "learningObjective": "Quantificar robustez via margens e sensibilidade paramétrica.",
                                  "commonMistakes": "Ignorar polos não-dominantes; calcular sensibilidade só para ganho K."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Concluir avaliação e propor melhorias",
                                  "subSteps": [
                                    "Sintetize achados: robustez alta/ baixa baseada em thresholds (ex: deslocamento polo <10%).",
                                    "Identifique parâmetros mais sensíveis e sugira compensações (ex: ganho adaptativo).",
                                    "Simule respostas temporais para casos críticos para validar análise.",
                                    "Documente recomendações para redesign do controlador.",
                                    "Compare com métodos alternativos como μ-síntese para contexto."
                                  ],
                                  "verification": "Relatório inclui gráficos, tabelas e conclusões acionáveis com evidências.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Ferramentas de simulação (step response), template de relatório",
                                  "tips": "Sempre valide com simulação temporal, não só locus.",
                                  "learningObjective": "Integrar análise para decisões de design robusto.",
                                  "commonMistakes": "Concluir robustez sem simulação de tempo; omitir trade-offs custo-benefício."
                                }
                              ],
                              "practicalExample": "Para um sistema de controle de posição de um braço robótico com G(s) = 1/(s(s+1)), varie o atrito viscoso b de 1±0.2. Plote loci, observe que para b=0.8, polos cruzam imaginário em K=2.5 (nominal K=4 estável), reduzindo margem de ganho em 30%.",
                              "finalVerifications": [
                                "Loci perturbados plotados e sobrepostos corretamente.",
                                "Margens de estabilidade calculadas para todos casos.",
                                "Deslocamentos de polos quantificados (<10% aceitável).",
                                "Índices de sensibilidade computados para parâmetros chave.",
                                "Conclusão sobre robustez com evidências simuladas.",
                                "Recomendações para mitigação de sensibilidade."
                              ],
                              "assessmentCriteria": [
                                "Precisão nos plots de locus (comparação visual/numerical).",
                                "Correta modelagem de perturbações paramétricas.",
                                "Cálculo exato de margens e sensibilidades.",
                                "Análise qualitativa e quantitativa integrada.",
                                "Clareza no relatório com gráficos e tabelas.",
                                "Validação via simulação temporal."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Análise de funções complexas e derivadas parciais.",
                                "Programação: Scripts de automação em MATLAB/Python para análise paramétrica.",
                                "Física: Modelagem dinâmica de sistemas mecânicos/elétricos.",
                                "Estatística: Análise de Monte Carlo para variações estocásticas."
                              ],
                              "realWorldApplication": "Em controle de drones, avaliar sensibilidade a variações de massa (carga útil) garante estabilidade em voo apesar de mudanças; evita oscilações em aviões comerciais com turbulência variando aerodinâmica."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.1.4",
                    "name": "Diagramas de Bode",
                    "description": "Análise e projeto de controladores no domínio da frequência usando gráficos de magnitude e fase.",
                    "individualConcepts": [
                      {
                        "id": "10.1.1.4.1",
                        "name": "Construção de Diagramas de Bode",
                        "description": "Processo de geração dos gráficos de magnitude e fase de funções de transferência no domínio da frequência, incluindo aproximações assintóticas.",
                        "specificSkills": [
                          {
                            "id": "10.1.1.4.1.1",
                            "name": "Calcular magnitude e fase para fatores elementares",
                            "description": "Determinar as contribuições de polos, zeros e ganho constante nos gráficos de Bode, incluindo curvas assintóticas de baixa e alta frequência.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Identificar e caracterizar fatores elementares em funções de transferência",
                                  "subSteps": [
                                    "Liste os fatores elementares comuns: ganho constante K, zero (τz s + 1), polo 1/(τp s + 1).",
                                    "Expresse a função de transferência G(s) = K * ∏ (zeros) / ∏ (pólos).",
                                    "Converta para frequência jω: G(jω) = |G(jω)| e^{jφ}.",
                                    "Identifique cantos de frequência: ωc = 1/τ para zeros e pólos.",
                                    "Anote valores de K, τz e τp para um exemplo simples."
                                  ],
                                  "verification": "Crie uma tabela resumindo os fatores e suas frequências de canto para uma G(s) dada.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Função de transferência exemplo",
                                    "Papel e caneta",
                                    "Calculadora"
                                  ],
                                  "tips": "Sempre normalize os fatores para a forma padrão (τ s + 1) para facilitar cálculos.",
                                  "learningObjective": "Compreender a decomposição de G(s) em fatores elementares e suas propriedades em frequência.",
                                  "commonMistakes": [
                                    "Confundir zeros com pólos",
                                    "Esquecer o ganho K",
                                    "Não converter s para jω"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Calcular contribuição de magnitude em dB para baixa e alta frequências",
                                  "subSteps": [
                                    "Para ganho K: mag = 20 log|K| (constante em todas as frequências).",
                                    "Para zero (τz jω + 1): baixa freq (ω << 1/τz) mag ≈ 0 dB; alta freq (ω >> 1/τz) mag ≈ 20 log(τz ω).",
                                    "Para polo 1/(τp jω + 1): baixa freq mag ≈ 0 dB; alta freq mag ≈ -20 log(τp ω).",
                                    "Desenhe assintóticas: reta 0 dB até ωc, depois inclinação +20 dB/década para zero, -20 para polo.",
                                    "Some contribuições: mag total = soma das mags individuais em dB."
                                  ],
                                  "verification": "Plote manualmente as assintóticas de magnitude para G(s) = K / (τ s + 1) em papel log-log.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Papel log-log",
                                    "Calculadora para log10",
                                    "Exemplos de G(s)"
                                  ],
                                  "tips": "Use escala logarítmica para ω; lembre que dB = 20 log10(|G|).",
                                  "learningObjective": "Dominar as aproximações assintóticas de magnitude para fatores elementares.",
                                  "commonMistakes": [
                                    "Usar 10 log em vez de 20 log para magnitude",
                                    "Inverter inclinações de zero (+20) e polo (-20)",
                                    "Esquecer soma em dB"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular contribuição de fase para fatores elementares",
                                  "subSteps": [
                                    "Para ganho K: φ = 0° se K>0, 180° se K<0 (constante).",
                                    "Para zero: φ = atan(τz ω), de 0° (baixa freq) a +90° (alta freq).",
                                    "Para polo: φ = -atan(τp ω), de 0° a -90°.",
                                    "Ponto médio em ωc: +45° para zero, -45° para polo.",
                                    "Some fases totais: φ total = soma das fases individuais."
                                  ],
                                  "verification": "Calcule φ em 3 pontos (baixa, ωc, alta) para cada fator e some para G(s).",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Calculadora com atan",
                                    "Tabela de valores de ω",
                                    "Gráfico semilog para fase"
                                  ],
                                  "tips": "Fase em graus; use calculadora para atan(ω τ) em radianos convertidos.",
                                  "learningObjective": "Aplicar fórmulas exatas e assintóticas de fase para decomposição.",
                                  "commonMistakes": [
                                    "Confundir sinal de fase (zero positivo, polo negativo)",
                                    "Somar em dB em vez de graus",
                                    "Esquecer ganho negativo"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Combinar magnitude e fase em curvas assintóticas completas",
                                  "subSteps": [
                                    "Some todas as contribuições de mag e fase para G(s) completa.",
                                    "Desenhe diagrama de Bode assintótico: mag em log-log, fase em semilog.",
                                    "Identifique mudanças de inclinação em cada ωc: +20 dB/dec por zero, -20 por polo.",
                                    "Verifique continuidade em baixas/altas frequências: mag inicial 20 log K, fase 0° ou 180°.",
                                    "Compare com curvas exatas (opcional via software)."
                                  ],
                                  "verification": "Construa diagrama completo para G(s) = 10 (s+1)/(s+10) e anote valores chave.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Papel milimetrado log",
                                    "Software como MATLAB/Octave (opcional)",
                                    "Exemplos complexos"
                                  ],
                                  "tips": "Ordene ωc crescentes para desenhar inclinações sequenciais.",
                                  "learningObjective": "Integrar todas contribuições em um diagrama de Bode assintótico preciso.",
                                  "commonMistakes": [
                                    "Não ajustar inclinação cumulativa após múltiplos fatores",
                                    "Ignorar fase em baixas frequências",
                                    "Erro em escala log"
                                  ]
                                }
                              ],
                              "practicalExample": "Para G(s) = 5 (s/2 + 1) / (s/10 + 1): Ganho K=5 (14 dB), zero ωz=2 rad/s (+20 dB/dec após), polo ωp=10 rad/s (-20 dB/dec após). Fase: zero +atan(ω/2), polo -atan(ω/10). Desenhe assintóticas: mag inicia 14 dB, +20 até 2, plana até 10, -20 após; fase inicia 0°, +45°@2, -45°@10, converge a 0°.",
                              "finalVerifications": [
                                "Calcule mag e fase exatas em ω=1, ωc's e ω=100, comparando com assintóticas (erro <3 dB, <10°).",
                                "Identifique corretamente todas ωc e mudanças de inclinação.",
                                "Some contribuições para G(s) com 2 zeros + 1 polo sem erros aritméticos.",
                                "Desenhe diagrama assintótico legível com labels.",
                                "Explique verbalmente o impacto de adicionar um polo extra."
                              ],
                              "assessmentCriteria": [
                                "Precisão nas fórmulas de mag/fase (>95% correto).",
                                "Correção das assintóticas (inclinações e intercepts exatos).",
                                "Capacidade de decompor G(s) complexa em elementares.",
                                "Qualidade do diagrama desenhado (escalas, labels).",
                                "Identificação de erros comuns e correções.",
                                "Tempo de execução eficiente (<90 min total)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Logaritmos, números complexos e funções trigonométricas (atan).",
                                "Física: Análise de sistemas dinâmicos e resposta em frequência.",
                                "Programação: Simulação de Bode plots em Python/MATLAB (bode() function).",
                                "Eletrônica: Filtros analógicos (RC, RLC) e suas respostas Bode."
                              ],
                              "realWorldApplication": "Em controle de motores DC, calcular Bode de G(s) = K/(s(τs+1)) para sintonizar PID, prevendo estabilidade (fase margem) e ganho em frequências de operação, evitando oscilações em robótica industrial."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.4.1.2",
                            "name": "Desenhar diagramas assintóticos",
                            "description": "Construir as aproximações em linha reta (assíntotas) para magnitude e fase de sistemas com polos reais, complexos e zeros.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Identificar polos, zeros e fatores da função de transferência",
                                  "subSteps": [
                                    "Escreva a função de transferência G(s) no formato polinomial.",
                                    "Fatore o numerador e denominador para identificar zeros (raízes do numerador) e polos (raízes do denominador).",
                                    "Classifique polos e zeros como reais simples, reais múltiplos, pares complexos conjugados ou no infinito.",
                                    "Liste as frequências de canto (ω_c = |polo ou zero|) em rad/s.",
                                    "Anote o ganho em baixa frequência (K)."
                                  ],
                                  "verification": "Lista completa de polos, zeros e frequências de canto anotada corretamente sem erros de fatoração.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Função de transferência exemplo",
                                    "Papel e lápis",
                                    "Calculadora científica"
                                  ],
                                  "tips": "Sempre normalize G(s) para que o coeficiente de s^0 no denominador seja 1. Use fatoração por agrupamento para polos complexos.",
                                  "learningObjective": "Compreender e extrair precisamente os elementos constitutivos do diagrama de Bode a partir de G(s).",
                                  "commonMistakes": [
                                    "Esquecer polos ou zeros no infinito.",
                                    "Confundir polos (denominador) com zeros (numerador).",
                                    "Não converter frequências para logarítmica (rad/s)."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Construir o diagrama assintótico de magnitude",
                                  "subSteps": [
                                    "Desenhe o eixo log-log com frequência ω (rad/s) em abscissa e magnitude 20log|G(jω)| (dB) em ordenada.",
                                    "Inicie com a assíntota de baixa frequência: reta horizontal em 20log|K|.",
                                    "Para cada zero real simples: +20 dB/década a partir de ω_z; múltiplo: +20n dB/década.",
                                    "Para cada polo real simples: -20 dB/década a partir de ω_p; múltiplo: -20n dB/década.",
                                    "Para pares complexos: aproxime como dois polos reais na frequência de canto |p|.",
                                    "Some as contribuições vetorialmente nas mudanças de inclinação."
                                  ],
                                  "verification": "Gráfico de magnitude com inclinações corretas e frequências de canto marcadas.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Papel semilogarítmico (log-log)",
                                    "Régua e lápis",
                                    "Tabela de fatores de inclinação"
                                  ],
                                  "tips": "Lembre-se: zeros sobem a magnitude, polos descem. Use escala log10 para ω.",
                                  "learningObjective": "Dominar a construção gráfica das assíntotas de magnitude para diferentes tipos de polos e zeros.",
                                  "commonMistakes": [
                                    "Inverter sinal de inclinação (polo como +20).",
                                    "Não acumular inclinações após múltiplas quebras.",
                                    "Esquecer ganho DC em baixa frequência."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Construir o diagrama assintótico de fase",
                                  "subSteps": [
                                    "Desenhe o eixo semi-log com ω (rad/s) em abscissa e fase arg[G(jω)] (graus) em ordenada.",
                                    "Inicie com fase em baixa frequência: 0° para K>0, 180° para K<0.",
                                    "Para zero real simples: inicia +90° uma década antes de ω_z, -90° uma década após (transição +180° total).",
                                    "Para polo real simples: inicia -90° uma década antes de ω_p, +90° uma década após (transição -180° total).",
                                    "Para pares complexos: transição abrupta de ±90° centrada em ω_p.",
                                    "Some as fases de todos os fatores."
                                  ],
                                  "verification": "Gráfico de fase com transições corretas e soma total de fases em altas frequências.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel semilogarítmico (log-lin)",
                                    "Transferidor ou software de plotagem",
                                    "Tabela de aproximações de fase"
                                  ],
                                  "tips": "A fase muda suavemente; use aproximações lineares para assíntotas. Verifique soma final: (Z - P)*90°.",
                                  "learningObjective": "Construir com precisão as assíntotas de fase considerando contribuições individuais.",
                                  "commonMistakes": [
                                    "Confundir direção da transição (polo sobe fase).",
                                    "Não considerar o sinal de K para fase inicial.",
                                    "Ignorar simetria para pares complexos."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificar, refinar e documentar o diagrama completo",
                                  "subSteps": [
                                    "Compare magnitude e fase em pontos críticos (baixa/alta ω, cantos).",
                                    "Adicione curvas reais aproximadas (±3dB em magnitude, ±45°/década em fase).",
                                    "Calcule margens de ganho e fase qualitativamente.",
                                    "Anote legendas: polos/zeros, inclinações e frequências.",
                                    "Valide com software (MATLAB bode plot) se disponível.",
                                    "Documente suposições e limitações."
                                  ],
                                  "verification": "Diagrama completo rotulado, com verificação numérica em pelo menos 3 pontos coincidente.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Software MATLAB ou Python (Control Systems Toolbox)",
                                    "Diagrama preliminar"
                                  ],
                                  "tips": "Sempre valide com plot numérico para confirmar assíntotas.",
                                  "learningObjective": "Garantir precisão e usabilidade prática do diagrama de Bode assintótico.",
                                  "commonMistakes": [
                                    "Não rotular mudanças de inclinação.",
                                    "Esquecer correções reais perto das cantos.",
                                    "Ignorar inconsistências entre magnitude e fase."
                                  ]
                                }
                              ],
                              "practicalExample": "Para G(s) = 10 / (s (s+1)(s^2 + 2s + 100)), identifique polos em 0, -1, -1±j9.9; zeros nenhum. Magnitude: inicia 20dB, -20dB/dec a ω=1, -40dB/dec a ω=10; fase: 0° baixa, -90°@1, -180°@10.",
                              "finalVerifications": [
                                "Inclinações de magnitude corretas para todos polos/zeros.",
                                "Transições de fase somam corretamente (ex: -90° por polo simples).",
                                "Frequências de canto marcadas em log escala.",
                                "Gráficos alinhados em baixa/alta frequência.",
                                "Validação numérica coincide com assíntotas em ±10%.",
                                "Documentação completa com legendas."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de polos/zeros (100% correto).",
                                "Inclinações e transições exatas (±5% erro).",
                                "Qualidade gráfica: escalas log corretas, legível.",
                                "Tratamento adequado de polos complexos.",
                                "Verificação com exemplo numérico.",
                                "Explicação clara de cada mudança."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Análise de funções racionais e logaritmos decimais.",
                                "Física: Dinâmica de sistemas lineares e resposta em frequência.",
                                "Informática: Programação de simulações em MATLAB/Python para validação.",
                                "Engenharia Elétrica: Projeto de filtros e compensadores.",
                                "Estatística: Análise de incertezas em aproximações assintóticas."
                              ],
                              "realWorldApplication": "Em controle de motores elétricos ou drones, os diagramas assintóticos de Bode permitem análise rápida de estabilidade e tuning de controladores PID sem simulações computacionais pesadas, otimizando desempenho em tempo real."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.4.1.3",
                            "name": "Corrigir assíntotas com curvas reais",
                            "description": "Aplicar correções de 3 dB para polos/zeros reais e calcular desvios para polos/zeros complexos próximos à frequência angular.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar o diagrama assintótico básico e identificar pontos de correção",
                                  "subSteps": [
                                    "Plote o diagrama de magnitude e fase assintótico da função de transferência G(s).",
                                    "Identifique todos os polos e zeros reais e complexos conjugados.",
                                    "Marque as frequências angulares de corte (ω_c) para cada polo/zero.",
                                    "Anote as posições exatas onde correções são necessárias: ±3 dB para polos/zeros reais na frequência de corte, e desvios para complexos próximos.",
                                    "Verifique se o gráfico assintótico está correto antes de prosseguir."
                                  ],
                                  "verification": "Confirme que todos os pontos de corte estão marcados corretamente e o assintótico segue as inclinações padrão (±20 dB/década por polo/zero).",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Função de transferência G(s), papel milimetrado ou software como MATLAB/Python (control library), calculadora.",
                                  "tips": "Use escala log-log para magnitude e log-linear para fase para precisão visual.",
                                  "learningObjective": "Entender a base assintótica para preparar correções precisas.",
                                  "commonMistakes": "Esquecer de considerar multiplicidade de polos/zeros ou inverter sinais de fase."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Aplicar correções de 3 dB para polos e zeros reais",
                                  "subSteps": [
                                    "Para cada polo real em ω_p, subtraia 3 dB na magnitude em ω = ω_p (ou adicione para zero).",
                                    "Ajuste a curva suavemente: comece a partir de 0.1 ω_p subindo/descendo para -3/+3 dB em ω_p, e retorne ao assintótico em 10 ω_p.",
                                    "Para zeros reais, inverta o sinal: +3 dB em ω_z.",
                                    "Atualize o diagrama de fase: -45°/2 para polo em ω_p, +45°/2 para zero.",
                                    "Repita para múltiplos polos/zeros reais."
                                  ],
                                  "verification": "Meça a magnitude em ω_p: deve ser exatamente ±3 dB do assintótico; fase deve transitar suavemente.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Gráfico assintótico plotado, régua para medições em dB, tabela de fatores de correção.",
                                  "tips": "Lembre-se: correção é sempre no sentido de suavizar a quebra abrupta do assintótico.",
                                  "learningObjective": "Dominar a regra empírica de 3 dB para aproximar a resposta real de polos/zeros reais.",
                                  "commonMistakes": "Aplicar correção errada no sinal (polo sobe em vez de descer) ou esquecer a fase."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular e aplicar desvios para polos/zeros complexos próximos à frequência angular",
                                  "subSteps": [
                                    "Identifique pares complexos onde |ω - ω_n| < 0.5 ω_n (próximos).",
                                    "Calcule o desvio de magnitude: ΔM ≈ 20 log10(1 / sqrt(1 - (ω/ω_n)^2)) para polos, ajustando para zeros.",
                                    "Para fase, use φ ≈ -atan(2ζ (ω/ω_n) / (1 - (ω/ω_n)^2)) onde ζ é o fator de amortecimento.",
                                    "Aplique o desvio máximo próximo a ω_n e suavize nas curvas.",
                                    "Some desvios de múltiplos pares complexos."
                                  ],
                                  "verification": "Compare com simulação numérica (ex: bode(G) no MATLAB): erro < 2 dB na região crítica.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Fórmulas de desvio derivadas, software de simulação (MATLAB/SciPy), calculadora científica.",
                                  "tips": "Para ζ baixo (<0.1), ressonância causa pico pronunciado; priorize ω ≈ ω_n.",
                                  "learningObjective": "Calcular desvios quantitativos para melhorar precisão em sistemas ressonantes.",
                                  "commonMistakes": "Ignorar conjugados ou usar aproximações lineares longe de ω_n."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Integrar correções, finalizar e validar o diagrama de Bode corrigido",
                                  "subSteps": [
                                    "Combine todas as correções: some efeitos de reais e complexos em cada ω.",
                                    "Desenhe curvas suaves conectando pontos corrigidos ao assintótico distante.",
                                    "Verifique continuidade e monotonicidade nas curvas de magnitude e fase.",
                                    "Compare com plot exato via software para ajustes finais.",
                                    "Anote margens de ganho/fase estimadas."
                                  ],
                                  "verification": "O diagrama corrigido deve coincidir com 90% da curva real em frequências de interesse.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Gráficos parciais, software de plotagem, lápis de cor para distinção.",
                                  "tips": "Use curvas Bézier suaves para melhor estética e precisão visual.",
                                  "learningObjective": "Sintetizar correções em um diagrama completo e validado.",
                                  "commonMistakes": "Sobrecorrigir regiões distantes ou ignorar interações entre múltiplas correções."
                                }
                              ],
                              "practicalExample": "Para G(s) = 10 / (s (s+1) (s^2 + 0.5s + 4)): aplique -3 dB no polo real ω=1 rad/s; para o par complexo ω_n=2 rad/s (ζ=0.125), calcule pico de +6 dB em ω≈2 e fase -90° extra. Resultado: magnitude real mostra ressonância corrigida vs. assintótico quebrado.",
                              "finalVerifications": [
                                "Correções de ±3 dB aplicadas exatamente nas frequências de polos/zeros reais.",
                                "Desvios para complexos calculados com erro <1 dB vs. simulação.",
                                "Curvas suaves sem quebras abruptas ou descontinuidades.",
                                "Fase transita corretamente (±45°/2 por polo/zero real, desvios para complexos).",
                                "Margens de estabilidade estimadas coincidem com análise exata.",
                                "Gráfico completo cobre 3 décadas além da banda de interesse."
                              ],
                              "assessmentCriteria": [
                                "Precisão das correções de 3 dB: 100% nos pontos exatos.",
                                "Qualidade dos desvios complexos: erro médio <2 dB na região ressonante.",
                                "Suavidade e conectividade das curvas: visualmente indistinguível de simulação.",
                                "Correta inclusão de fase: desvios <5° de erro.",
                                "Eficiência: tempo total <80 minutos com validação.",
                                "Documentação: anotações claras de cálculos e justificativas."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Logaritmos e funções complexas para cálculos de magnitude/fase.",
                                "Física: Dinâmica de sistemas oscilatórios e ressonância em circuitos/mecânica.",
                                "Programação: Implementar Bode plots em Python (control/matplotlib) para validação.",
                                "Estatística: Análise de erro entre aproximações e simulações reais."
                              ],
                              "realWorldApplication": "Em controle de drones, corrigir diagramas de Bode de motores permite prever estabilidade e ajustar ganhos para evitar oscilações; em áudio, filtra equalizadores usam isso para compensar picos ressonantes em alto-falantes."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.1.4.2",
                        "name": "Interpretação de Diagramas de Bode",
                        "description": "Leitura e análise qualitativa e quantitativa dos gráficos para caracterizar o comportamento dinâmico do sistema.",
                        "specificSkills": [
                          {
                            "id": "10.1.1.4.2.1",
                            "name": "Identificar frequências de ressonância e atenuação",
                            "description": "Localizar picos de magnitude e calcular fator de amortecimento a partir do gráfico de magnitude.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a estrutura do diagrama de Bode de magnitude para sistemas de segunda ordem",
                                  "subSteps": [
                                    "Revise a forma padrão da função de transferência de um sistema de segunda ordem: G(s) = ω_n² / (s² + 2ζω_n s + ω_n²).",
                                    "Identifique componentes do diagrama de Bode: eixo x (frequência logarítmica em rad/s), eixo y (magnitude em dB).",
                                    "Reconheça o comportamento típico: rampa baixa frequência, pico em ressonância para ζ < 0.707, atenuação em altas frequências.",
                                    "Estude a relação entre magnitude máxima M_p e ζ: M_p ≈ 1/(2ζ√(1-ζ²)) para ζ < 1/√2.",
                                    "Anote a frequência de ressonância ω_r ≈ ω_n √(1 - 2ζ²)."
                                  ],
                                  "verification": "Explique verbalmente ou por escrito as relações entre ζ, ω_r e o pico de magnitude.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Função de transferência exemplo, tabela de valores típicos de ζ e M_p, software de plotagem como MATLAB ou Python (Matplotlib).",
                                  "tips": "Use log-log para visualizar melhor o comportamento assintótico.",
                                  "learningObjective": "Entender como o fator de amortecimento afeta o gráfico de magnitude.",
                                  "commonMistakes": "Confundir magnitude em dB com valor linear; esquecer conversão dB para linear (20 log10(M))."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Localizar o pico de magnitude e identificar a frequência de ressonância",
                                  "subSteps": [
                                    "Plote ou abra o diagrama de Bode de magnitude fornecido.",
                                    "Examine o gráfico visualmente para encontrar o ponto de magnitude máxima (pico).",
                                    "Leia o valor da frequência ω no eixo x correspondente ao pico (ω_r).",
                                    "Marque o pico e ω_r com precisão, usando zoom ou régua se digital.",
                                    "Confirme se há um pico distinto (sistema subamortecido, ζ < 0.707)."
                                  ],
                                  "verification": "Anote ω_r e M_p(dB) com erro visual <1% da escala.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Gráfico de Bode impresso ou digital, régua ou cursor de software.",
                                  "tips": "Picos sutis podem ser interpolados entre pontos de dados.",
                                  "learningObjective": "Precisamente localizar ω_r no gráfico.",
                                  "commonMistakes": "Ler frequência errada devido a escala logarítmica; confundir com cruzamento de -3dB."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular o fator de amortecimento a partir do pico de magnitude",
                                  "subSteps": [
                                    "Converta M_p(dB) para magnitude linear: M_p = 10^(M_p(dB)/20).",
                                    "Aplique a fórmula aproximada: ζ ≈ 1 / √(4 M_p² - 1) para M_p próximo de 1.",
                                    "Ou use iteração numérica para resolver M_p = 1/(2ζ√(1-ζ²)).",
                                    "Calcule ζ com pelo menos 3 casas decimais.",
                                    "Valide com ω_r se ω_n conhecido: ζ ≈ √((1 - (ω_r/ω_n)²)/2)."
                                  ],
                                  "verification": "Compare ζ calculado com valor teórico conhecido (erro <5%).",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Calculadora científica, planilha Excel ou script Python para equações.",
                                  "tips": "Para ζ baixo, aproximação M_p ≈ 1/(2ζ) é útil.",
                                  "learningObjective": "Dominar cálculo de ζ do gráfico experimental.",
                                  "commonMistakes": "Esquecer conversão dB-linear; usar fórmula errada para sistemas de ordem superior."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificar consistência e interpretar frequências de ressonância e atenuação",
                                  "subSteps": [
                                    "Compare ω_r com frequência de corte ou natural esperada.",
                                    "Avalie atenuação: declive pós-pico deve ser -40 dB/década para segunda ordem.",
                                    "Interprete: alto pico indica baixa atenuação (subamortecido).",
                                    "Simule variação de ζ e compare gráficos.",
                                    "Documente relatório com valores e implicações."
                                  ],
                                  "verification": "Gráfico simulado com ζ calculado reproduz pico original.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Software de simulação (MATLAB Control Toolbox ou Octave).",
                                  "tips": "Sempre verifique unidades: rad/s vs Hz.",
                                  "learningObjective": "Interpretar resultados em contexto de estabilidade.",
                                  "commonMistakes": "Ignorar efeitos de ordem superior que mascaram o pico."
                                }
                              ],
                              "practicalExample": "Considere um sistema com diagrama de Bode de magnitude mostrando pico de 12 dB em ω = 4 rad/s. Converta 12 dB para M_p = 10^(12/20) ≈ 4. Converta para ζ usando 4 ≈ 1/(2ζ√(1-ζ²)), resolvendo ζ ≈ 0.3. Verifique: sistema subamortecido com ressonância em 4 rad/s.",
                              "finalVerifications": [
                                "ω_r identificada corretamente com precisão de 0.1 rad/s.",
                                "M_p convertida e lida com erro <0.5 dB.",
                                "ζ calculado com precisão de 0.01.",
                                "Interpretação correta do regime (subamortecido/criticamente amortecido).",
                                "Consistência verificada com simulação.",
                                "Relatório documenta todos os valores."
                              ],
                              "assessmentCriteria": [
                                "Precisão na localização do pico (erro <2% em ω_r).",
                                "Correção matemática no cálculo de ζ (erro <5%).",
                                "Uso adequado de conversões dB-linear.",
                                "Interpretação qualitativa precisa do comportamento.",
                                "Verificação com simulação ou teoria.",
                                "Clareza na documentação e gráficos anotados."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Resolução de equações transcendentais e análise gráfica.",
                                "Física: Oscilações amortecidas e ressonância mecânica.",
                                "Processamento de Sinais: Análise em domínio de frequência.",
                                "Engenharia Mecânica: Controle de vibrações em estruturas."
                              ],
                              "realWorldApplication": "Em automação industrial, como controle de servomotores em robótica, identificar ressonância evita oscilações destrutivas; calcular atenuação guia ajuste de ganhos PID para estabilidade em linhas de produção."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.4.2.2",
                            "name": "Avaliar largura de banda e tempo de subida",
                            "description": "Estimar a frequência de corte (-3 dB) e relacioná-la com especificações temporais como tempo de subida e constante de tempo.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os Conceitos Fundamentais de Largura de Banda e Especificações Temporais",
                                  "subSteps": [
                                    "Defina largura de banda (BW) como a frequência de corte ω_c onde o ganho em magnitude cai para -3 dB (70,7% do ganho DC).",
                                    "Explique tempo de subida (t_r) como o tempo para o sinal sair de 10% a 90% do valor final em resposta a um degrau.",
                                    "Descreva a constante de tempo (τ) como o tempo para atingir 63,2% do valor final em sistemas de primeira ordem.",
                                    "Memorize as aproximações: ω_c ≈ 0.35 / t_r para sistemas de segunda ordem dominantes e ω_c ≈ 1 / τ para primeira ordem.",
                                    "Discuta limitações das aproximações em sistemas de ordem superior."
                                  ],
                                  "verification": "Resuma verbalmente ou por escrito as definições e fórmulas principais sem consultar notas.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Folha de papel e caneta",
                                    "Tabela de fórmulas de controle (impressa ou digital)"
                                  ],
                                  "tips": "Use analogias como 'largura de banda é a velocidade máxima do sistema' para fixar conceitos.",
                                  "learningObjective": "Dominar definições e relações aproximadas entre domínio de frequência e tempo.",
                                  "commonMistakes": [
                                    "Confundir -3 dB com corte total (0 dB)",
                                    "Ignorar que aproximações são para sistemas específicos",
                                    "Misturar unidades (rad/s vs Hz)"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar a Largura de Banda em um Diagrama de Bode",
                                  "subSteps": [
                                    "Localize o eixo de magnitude em dB e frequência em rad/s ou Hz no diagrama de Bode.",
                                    "Trace a curva de magnitude até encontrar o ponto onde ela cruza -3 dB a partir do ganho de baixa frequência.",
                                    "Anote a frequência correspondente como ω_c; interpole se necessário entre pontos de plotagem.",
                                    "Confirme se é o ponto de -3 dB inferior ou superior em sistemas com picos de ressonância.",
                                    "Registre o valor exato ou aproximado da largura de banda."
                                  ],
                                  "verification": "Marque ω_c em um diagrama de Bode exemplo e compare com valor conhecido.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Diagrama de Bode de exemplo impresso ou em software como MATLAB/Python",
                                    "Régua e calculadora"
                                  ],
                                  "tips": "Aumente a escala do gráfico mentalmente para precisão em leituras visuais.",
                                  "learningObjective": "Extrair com precisão a frequência de corte de diagramas de Bode reais.",
                                  "commonMistakes": [
                                    "Ler o ponto errado (ex: pico de ressonância)",
                                    "Confundir magnitude com fase",
                                    "Esquecer conversão Hz para rad/s (ω = 2πf)"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Relacionar Largura de Banda com Especificações Temporais",
                                  "subSteps": [
                                    "Aplique a fórmula t_r ≈ 0.35 / ω_c para estimar tempo de subida.",
                                    "Calcule constante de tempo τ ≈ 1 / ω_c para sistemas de primeira ordem.",
                                    "Considere fatores de correção para sistemas de segunda ordem: t_r ≈ 1.8 / ω_n se damping conhecido.",
                                    "Compare estimativas com simulações ou dados conhecidos para validar.",
                                    "Ajuste para unidades consistentes (ex: converter ω_c de rad/s)."
                                  ],
                                  "verification": "Calcule t_r e τ para um ω_c dado e verifique contra tabela de referência.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Calculadora",
                                    "Planilha Excel ou Python para cálculos",
                                    "Exemplos de sistemas com specs conhecidas"
                                  ],
                                  "tips": "Sempre verifique unidades: rad/s para ω_c implica segundos para t_r.",
                                  "learningObjective": "Converter especificações de frequência em temporais usando aproximações padrão.",
                                  "commonMistakes": [
                                    "Usar fórmulas erradas (ex: 2.2/tr ao invés de 0.35)",
                                    "Não considerar ordem do sistema",
                                    "Erros aritméticos em divisões"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Interpretar e Validar as Estimativas no Contexto do Sistema",
                                  "subSteps": [
                                    "Avalie se a BW atende requisitos do sistema (ex: t_r < 0.1s para controle rápido).",
                                    "Analise impactos de picos ou notches no diagrama na precisão da estimativa.",
                                    "Simule resposta temporal básica usando software para confirmação.",
                                    "Documente suposições feitas (ex: ordem do sistema, damping).",
                                    "Discuta trade-offs: BW maior implica resposta mais rápida mas possível instabilidade."
                                  ],
                                  "verification": "Gere relatório curto com cálculos, estimativas e validação.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Software de simulação (MATLAB Simulink ou Python Control Systems Library)",
                                    "Diagrama de Bode do exemplo"
                                  ],
                                  "tips": "Priorize validação numérica sobre visual para confiança.",
                                  "learningObjective": "Interpretar resultados no contexto de design de controle.",
                                  "commonMistakes": [
                                    "Ignorar efeitos de fase ou estabilidade",
                                    "Superestimar precisão das aproximações",
                                    "Não documentar limitações"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um diagrama de Bode de um controlador PI para um motor DC, a magnitude cruza -3 dB em ω_c = 20 rad/s. Estime t_r ≈ 0.35 / 20 = 0.0175 s (17.5 ms), ideal para aplicações de rastreamento rápido como robótica.",
                              "finalVerifications": [
                                "Identifica corretamente ω_c em qualquer diagrama de Bode fornecido.",
                                "Calcula t_r e τ com erro < 10% usando aproximações.",
                                "Explica limitações das fórmulas em diferentes ordens de sistema.",
                                "Valida estimativas com simulação simples.",
                                "Relaciona BW a performance real do sistema.",
                                "Documenta cálculos de forma clara e organizada."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de ω_c (±5% erro visual).",
                                "Correção nas fórmulas e cálculos aritméticos.",
                                "Profundidade na interpretação de trade-offs.",
                                "Qualidade da validação com exemplos/simulações.",
                                "Clareza na documentação e comunicação.",
                                "Consideração de contextos reais e limitações."
                              ],
                              "crossCurricularConnections": [
                                "Eletrônica: Largura de banda em amplificadores operacionais e filtros.",
                                "Processamento de Sinais: Relações tempo-frequência em FFT e filtros digitais.",
                                "Física: Dinâmica de osciladores harmônicos e amortecimento.",
                                "Matemática: Transformada de Laplace e análise assintótica.",
                                "Informática: Simulações em Python/MATLAB para controle numérico."
                              ],
                              "realWorldApplication": "Em projetos de drones ou veículos autônomos, avaliar BW garante que o controlador responda rápido o suficiente para manobras evasivas, evitando crashes ao relacionar diagrama de Bode com tempo de subida requerido (<50ms)."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.4.2.3",
                            "name": "Analisar rejeição de ruído e distúrbios",
                            "description": "Interpretar atenuação em altas frequências para ruído e em baixas frequências para distúrbios.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar conceitos de ruído, distúrbios e representação em Diagramas de Bode",
                                  "subSteps": [
                                    "Defina ruído como perturbações de alta frequência (ex: sensor noise) e distúrbios como de baixa frequência (ex: load changes).",
                                    "Explique como o diagrama de Bode de laço fechado mostra a transferência de ruído (T_nw = S * G_n) e distúrbios (T_dw = S * G_d).",
                                    "Identifique as curvas de magnitude relevantes: atenuação em altas frequências para ruído (roll-off) e baixas para distúrbios.",
                                    "Desenhe um diagrama de Bode genérico marcando regiões de alta (ω > ω_c) e baixa frequência (ω < ω_c).",
                                    "Calcule ganho em dB para exemplos simples: 20*log10(|T(jω)|)."
                                  ],
                                  "verification": "Crie um resumo de 1 página explicando diferenças entre ruído e distúrbios com sketch de Bode plot.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Livro de controle (ex: Ogata), software MATLAB/Simulink ou Python (control library), papel e caneta.",
                                  "tips": "Use log-log scale mentalmente: inclinação -20dB/dec indica atenuação efetiva.",
                                  "learningObjective": "Compreender fundamentos teóricos para interpretação precisa.",
                                  "commonMistakes": "Confundir ruído (HF) com distúrbios (LF); ignorar função sensibilidade S(s)."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar rejeição de ruído em altas frequências",
                                  "subSteps": [
                                    "Localize a banda de alta frequência (ω > 10*ω_c, onde ω_c é crossover frequency).",
                                    "Meça a atenuação em dB: ideal > -40dB para boa rejeição.",
                                    "Avalie inclinação da curva de magnitude: -40dB/dec ou mais indica bom roll-off.",
                                    "Compare com ruído típico (ex: 1kHz+ para sensores).",
                                    "Calcule fator de atenuação: |T_nw(jω)| < 0.01 para ruído rejeitado."
                                  ],
                                  "verification": "Anote valores de atenuação em 3 pontos HF e justifique se rejeição é adequada.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Diagrama de Bode exemplo (gerado em MATLAB), calculadora, régua para medir plot.",
                                  "tips": "Foque no asymptote: cada polo adiciona -20dB/dec.",
                                  "learningObjective": "Interpretar quantitativamente rejeição de ruído via atenuação HF.",
                                  "commonMistakes": "Medir em frequência errada (não acima de ω_c); ignorar picos de ressonância."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar rejeição de distúrbios em baixas frequências",
                                  "subSteps": [
                                    "Identifique banda LF (ω < 0.1*ω_c).",
                                    "Verifique atenuação: ganho baixo em dB (ex: < -20dB) indica boa rejeição.",
                                    "Analise integradores: tipo 1 sistema dá -20dB/dec em LF para distúrbios.",
                                    "Calcule steady-state error para step disturbance: lim ω->0 |S(jω)|.",
                                    "Compare com specs: rejeição > 20dB em 0.1Hz para load disturbances."
                                  ],
                                  "verification": "Registre atenuação LF em 3 pontos e estime rejeição qualitativa (boa/ruim).",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Mesmo diagrama de Bode, software para plotar S(s), notas de specs.",
                                  "tips": "Lembre: |S(jω)| ≈ 1/|L(jω)| em LF, onde L é loop gain.",
                                  "learningObjective": "Avaliar desempenho contra distúrbios via análise LF.",
                                  "commonMistakes": "Confundir com tracking (referência); não considerar tipo do sistema."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Interpretar resultados globais e validar análise",
                                  "subSteps": [
                                    "Sintetize: resuma rejeição ruído (HF) vs. distúrbios (LF).",
                                    "Compare com requisitos: ex: ruído <1%, distúrbio rejection >90%.",
                                    "Simule resposta temporal para validar (ruído injetado HF, distúrbio LF).",
                                    "Identifique trade-offs: alto ganho LF piora ruído HF.",
                                    "Proponha melhorias: adicionar filtro notch ou integrador."
                                  ],
                                  "verification": "Gere relatório com conclusões, simulação e recomendações.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "MATLAB/Simulink para simulação, diagrama original.",
                                  "tips": "Use bw = bandwidth para delimitar regiões.",
                                  "learningObjective": "Integrar análises para julgamento holístico de desempenho.",
                                  "commonMistakes": "Isolar análises sem trade-offs; pular validação temporal."
                                }
                              ],
                              "practicalExample": "Em um sistema de controle de velocidade de motor DC com controlador PI, o diagrama de Bode mostra roll-off de -40dB/dec acima de 100Hz (boa rejeição de ruído sensor) e atenuação de -30dB abaixo de 1Hz (eficaz contra variações de carga). Simule injetando ruído branco HF e step disturbance LF para ver overshoot mínimo.",
                              "finalVerifications": [
                                "Identifica corretamente regiões HF e LF no Bode plot.",
                                "Calcula atenuação em dB com precisão <5% erro.",
                                "Explica impacto em resposta temporal via simulação.",
                                "Compara com specs padrão (ex: PM=45°, GM=6dB).",
                                "Propõe pelo menos 2 melhorias baseadas na análise.",
                                "Distingue rejeição ruído vs. distúrbios sem confusão."
                              ],
                              "assessmentCriteria": [
                                "Precisão na medição de atenuação (90%+ acerto).",
                                "Profundidade de substeps executados (todos 3-5 por step).",
                                "Qualidade da interpretação trade-offs (holística).",
                                "Validação via simulação (gráficos coerentes).",
                                "Clareza no relatório (estruturado, sem erros conceituais).",
                                "Criatividade em aplicações reais/conexões."
                              ],
                              "crossCurricularConnections": [
                                "Processamento de Sinais: Filtros notch para ruído específico.",
                                "Eletrônica: Análise de amplificadores com feedback.",
                                "Física: Dinâmica de sistemas vibratórios (ressonâncias).",
                                "Matemática: Transformadas de Fourier/Laplace para freq domain."
                              ],
                              "realWorldApplication": "Em drones autônomos, analisar Bode para rejeitar ruído de vibração HF dos motores e distúrbios LF de vento, garantindo estabilidade de voo; ou em linhas de produção industriais para compensar variações de carga em servomotores."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.1.4.3",
                        "name": "Análise de Estabilidade com Diagramas de Bode",
                        "description": "Uso dos diagramas para determinar margens de estabilidade e critérios de Nyquist simplificados.",
                        "specificSkills": [
                          {
                            "id": "10.1.1.4.3.1",
                            "name": "Calcular margem de ganho e fase",
                            "description": "Identificar frequências de cruzamento de ganho (ω_cg) e fase (ω_cp), e computar as margens respectivas para avaliar estabilidade relativa.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar e Plotar o Diagrama de Bode da Função de Malha Aberta",
                                  "subSteps": [
                                    "Obtenha a função de transferência de malha aberta G(s)H(s) do sistema.",
                                    "Substitua s = jω para obter G(jω)H(jω) em domínio de frequência.",
                                    "Calcule a magnitude |G(jω)H(jω)| em dB: 20 log10(|G(jω)H(jω)|).",
                                    "Calcule a fase ∠G(jω)H(jω) em graus.",
                                    "Plote magnitude (dB) vs. log10(ω) e fase (graus) vs. log10(ω)."
                                  ],
                                  "verification": "Verifique se os gráficos de magnitude e fase estão corretamente escalados, com magnitude cruzando 0 dB e fase variando adequadamente.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Função de transferência G(s)H(s)",
                                    "Software como MATLAB (bode()), Python (control library) ou papel gráfico"
                                  ],
                                  "tips": "Use escala logarítmica para ω de 0.1 a 10 rad/s inicialmente para visualizar bem.",
                                  "learningObjective": "Dominar a construção do diagrama de Bode para análise em frequência.",
                                  "commonMistakes": "Esquecer o fator H(s) em sistemas com realimentação não unitária; plotar sem escala log."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar a Frequência de Cruzamento de Ganho (ω_cg)",
                                  "subSteps": [
                                    "Localize no gráfico de magnitude o ponto onde |G(jω)H(jω)| = 0 dB (ganho unitário).",
                                    "Leia o valor de ω correspondente nesse cruzamento; essa é ω_cg.",
                                    "Marque ω_cg no eixo log ω.",
                                    "Confirme interpolando se necessário entre pontos discretos.",
                                    "Anote o valor exato de ω_cg em rad/s."
                                  ],
                                  "verification": "ω_cg é precisamente onde magnitude = 0 dB; teste substituindo em G(jω_cg) para ganho ≈1.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Diagrama de Bode plotado",
                                    "Ferramenta de zoom no software ou régua no papel"
                                  ],
                                  "tips": "Se o gráfico for assintótico, refine com cálculo numérico para precisão.",
                                  "learningObjective": "Identificar com precisão a frequência onde o ganho é unitário.",
                                  "commonMistakes": "Confundir com frequência de ressonância ou pico de magnitude."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Identificar a Frequência de Cruzamento de Fase (ω_cp)",
                                  "subSteps": [
                                    "No gráfico de fase, localize onde ∠G(jω)H(jω) = -180°.",
                                    "Leia o valor de ω nesse ponto; essa é ω_cp.",
                                    "Marque ω_cp no eixo log ω do gráfico de fase.",
                                    "Use interpolação linear em log ω se o cruzamento não for exato.",
                                    "Anote ω_cp em rad/s e leia a magnitude correspondente nesse ω."
                                  ],
                                  "verification": "Substitua ω_cp em G(jω_cp) e confirme fase ≈ -180° ±1°.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Diagrama de Bode",
                                    "Calculadora ou software para avaliação numérica"
                                  ],
                                  "tips": "Fase é contínua; envolva -360° se necessário para o ramo principal.",
                                  "learningObjective": "Reconhecer a frequência crítica de fase para estabilidade.",
                                  "commonMistakes": "Ignorar desvios de -180° por atrasos ou usar magnitude em vez de fase."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Calcular as Margens de Ganho e Fase",
                                  "subSteps": [
                                    "Para margem de ganho (GM): Em ω_cp, GM = 1 / |G(jω_cp)H(jω_cp)| ou em dB: GM_dB = -|G(jω_cp)H(jω_cp)|_dB.",
                                    "Para margem de fase (PM): Em ω_cg, PM = 180° + ∠G(jω_cg)H(jω_cg).",
                                    "Calcule numericamente usando valores exatos de G(jω).",
                                    "Expresse GM em dB e PM em graus.",
                                    "Compare ω_cg e ω_cp: idealmente ω_cg < ω_cp para estabilidade."
                                  ],
                                  "verification": "GM > 0 dB e PM > 0° indicam estabilidade; valide com fórmula de Nyquist.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Valores de ω_cg e ω_cp",
                                    "Calculadora científica ou MATLAB evalfr()"
                                  ],
                                  "tips": "GM em dB é positiva para estabilidade; PM mínima recomendada é 45°-60°.",
                                  "learningObjective": "Computar quantitativamente as margens de estabilidade.",
                                  "commonMistakes": "Inverter fórmulas: GM usa magnitude em ω_cp, PM usa fase em ω_cg."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Avaliar Estabilidade Relativa Baseada nas Margens",
                                  "subSteps": [
                                    "Interprete GM: >6 dB bom, <0 dB instável.",
                                    "Interprete PM: >45° bom, <0° instável.",
                                    "Calcule razão ω_cg / ω_cp para robustez.",
                                    "Registre conclusão: estável se GM>0 e PM>0.",
                                    "Sugira compensações se margens baixas (ex: adelantar fase)."
                                  ],
                                  "verification": "Conclusão alinhada com critérios padrão; simule step response para confirmação.",
                                  "estimatedTime": "10 minutos",
                                  "materials": [
                                    "Valores calculados de GM e PM",
                                    "Tabela de critérios de estabilidade"
                                  ],
                                  "tips": "Margens altas indicam maior robustez a variações de ganho/planta.",
                                  "learningObjective": "Avaliar e interpretar margens para design de controle.",
                                  "commonMistakes": "Considerar estável só por uma margem positiva, ignorando a outra."
                                }
                              ],
                              "practicalExample": "Para G(s) = 10 / (s(s+1)(s+10)), plote Bode: ω_cg ≈ 3.16 rad/s (fase≈-135°), ω_cp≈10 rad/s (mag≈-20 dB). GM=20 dB, PM=45°. Estável com boas margens.",
                              "finalVerifications": [
                                "ω_cg identificada corretamente onde mag=0 dB.",
                                "ω_cp onde fase=-180°.",
                                "GM calculada como -mag_dB(ω_cp) >0 dB.",
                                "PM=180° + fase(ω_cg) >0°.",
                                "Conclusão de estabilidade coerente.",
                                "Valores numéricos precisos (±5%)."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de frequências (±10% erro máximo).",
                                "Cálculo correto de fórmulas de GM e PM (sem inversão).",
                                "Interpretação qualitativa e quantitativa adequada.",
                                "Uso correto de ferramentas e gráficos.",
                                "Documentação clara de passos e valores.",
                                "Sugestões de melhoria se margens marginais."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Análise complexa e logaritmos para dB.",
                                "Física: Dinâmica de sistemas e oscilações.",
                                "Programação: Simulação numérica em MATLAB/Python.",
                                "Estatística: Análise de robustez e variância."
                              ],
                              "realWorldApplication": "Em controle de drones, calcular margens assegura estabilidade contra ventos variáveis; em automação industrial, previne oscilações em linhas de produção."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.4.3.2",
                            "name": "Aplicar critério de estabilidade de Bode",
                            "description": "Verificar se a fase em ω_cg é maior que -180° e se o ganho em ω_cp é menor que 0 dB para sistemas mínimos de fase.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar o diagrama de Bode do sistema de controle",
                                  "subSteps": [
                                    "Escrever a função de transferência G(s) do sistema em malha aberta.",
                                    "Substituir s = jω para obter G(jω) e calcular magnitude |G(jω)| em dB e fase arg(G(jω)) em graus.",
                                    "Plotar os diagramas de magnitude e fase em escala logarítmica para ω usando software ou gráfico manual.",
                                    "Identificar as assíntotas e pontos de corte para sistemas mínimos de fase.",
                                    "Verificar se o sistema é mínimo de fase (sem zeros no semiplano direito)."
                                  ],
                                  "verification": "Diagrama de Bode completo plotado com magnitude cruzando 0 dB e fase visível em torno de -180°.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Função de transferência G(s), software como MATLAB/Simulink ou Python (control library), papel milimetrado e calculadora.",
                                  "tips": "Use comandos como bodeplot() no MATLAB para plots precisos; foque em frequências decádicas.",
                                  "learningObjective": "Dominar a construção precisa do diagrama de Bode para análise de estabilidade.",
                                  "commonMistakes": "Esquecer de converter para dB (20*log10(|G|)); plotar em escala linear em vez de log."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar a frequência de cruzamento de ganho (ω_cg) e verificar margem de fase",
                                  "subSteps": [
                                    "Localizar ω_cg onde o diagrama de magnitude cruza 0 dB (ganho unitário).",
                                    "Ler o valor da fase φ(ω_cg) diretamente do diagrama de Bode nesse ponto.",
                                    "Calcular a margem de fase: PM = 180° + φ(ω_cg).",
                                    "Verificar se φ(ω_cg) > -180° (equivalente a PM > 0°).",
                                    "Anotar o valor exato de PM para sistemas próximos da instabilidade."
                                  ],
                                  "verification": "ω_cg identificada corretamente e PM calculada com φ(ω_cg) > -180° confirmada.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Diagrama de Bode plotado, régua ou cursor no software para leitura precisa.",
                                  "tips": "Use interpolação linear no gráfico se ω_cg não for exata; amplie o gráfico para precisão.",
                                  "learningObjective": "Aplicar o critério de margem de fase para avaliar estabilidade relativa.",
                                  "commonMistakes": "Confundir ω_cg com ω_cp; ler fase errada devido a escala comprimida."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Identificar a frequência de cruzamento de fase (ω_cp) e verificar margem de ganho",
                                  "subSteps": [
                                    "Localizar ω_cp onde o diagrama de fase cruza -180° (descendo).",
                                    "Ler o valor da magnitude |G(jω_cp)| em dB diretamente do diagrama nesse ponto.",
                                    "Calcular a margem de ganho: GM = 1 / |G(jω_cp)| ou -|G(jω_cp)| em dB.",
                                    "Verificar se |G(jω_cp)| < 0 dB (equivalente a GM > 1 ou > 0 dB).",
                                    "Confirmar que ω_cp > ω_cg para maior robustez (boa prática)."
                                  ],
                                  "verification": "ω_cp identificada e |G(jω_cp)| < 0 dB confirmada no diagrama.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Diagrama de Bode, software para zoom e medição precisa.",
                                  "tips": "Para fases que oscilam, use o primeiro cruzamento de -180°; anote tanto PM quanto GM.",
                                  "learningObjective": "Aplicar o critério de margem de ganho para confirmar estabilidade absoluta.",
                                  "commonMistakes": "Usar cruzamento ascendente de fase; confundir dB com valor linear."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Interpretar resultados e concluir sobre estabilidade do sistema",
                                  "subSteps": [
                                    "Reunir PM > 0° e GM > 0 dB para sistemas mínimos de fase.",
                                    "Declarar o sistema estável se ambas condições atendidas.",
                                    "Se uma falhar, identificar qual (fase ou ganho) e sugerir ajustes como aumentar ganho K.",
                                    "Documentar valores numéricos de ω_cg, ω_cp, PM e GM.",
                                    "Verificar estabilidade com simulação de resposta ao degrau se possível."
                                  ],
                                  "verification": "Conclusão escrita: 'Sistema estável' ou 'instável' com justificativa baseada nos critérios.",
                                  "estimatedTime": "10 minutos",
                                  "materials": "Folha de relatório, software de simulação (opcional).",
                                  "tips": "Lembre: válido apenas para sistemas mínimos de fase; mencione limitações.",
                                  "learningObjective": "Integrar ambos critérios para julgamento final de estabilidade.",
                                  "commonMistakes": "Ignorar condição de sistema mínimo de fase; concluir estabilidade sem ambas margens."
                                }
                              ],
                              "practicalExample": "Para G(s) = 5 / (s(s+1)(0.5s+1)), plote Bode: ω_cg ≈ 1.8 rad/s com φ ≈ -140° (> -180°), ω_cp ≈ 3.5 rad/s com |G| ≈ -8 dB (< 0 dB). Conclusão: sistema estável.",
                              "finalVerifications": [
                                "ω_cg corretamente identificada onde magnitude = 0 dB.",
                                "Fase em ω_cg > -180° confirmada numericamente.",
                                "ω_cp corretamente identificada onde fase = -180°.",
                                "Ganho em ω_cp < 0 dB medido com precisão.",
                                "Conclusão de estabilidade coerente com critérios para sistema mínimo de fase.",
                                "Valores de PM e GM calculados e documentados."
                              ],
                              "assessmentCriteria": [
                                "Precisão na construção do diagrama de Bode (assíntotas e pontos exatos).",
                                "Correta identificação e leitura de ω_cg e ω_cp (±5% de erro tolerado).",
                                "Aplicação rigorosa dos critérios (> -180° e < 0 dB).",
                                "Interpretação lógica sem contradições.",
                                "Documentação clara com valores numéricos e justificativas.",
                                "Consideração explícita de sistemas mínimos de fase."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Análise de funções complexas e logaritmos decimais.",
                                "Física: Dinâmica de sistemas oscilatórios e amortecimento.",
                                "Programação: Uso de bibliotecas como control em Python ou Bode em MATLAB.",
                                "Eletrônica: Projeto de filtros analógicos e compensadores de fase."
                              ],
                              "realWorldApplication": "Em automação industrial, verifica estabilidade de controladores PID em motores DC ou braços robóticos, evitando oscilações destrutivas em linhas de produção ou veículos autônomos."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.4.3.3",
                            "name": "Analisar estabilidade robusta",
                            "description": "Incorporar incertezas multiplicativas e avaliar margens com base em desvios nos diagramas de Bode.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Diagramas de Bode e Margens de Estabilidade Nominal",
                                  "subSteps": [
                                    "Relembrar a construção de diagramas de Bode para função de malha aberta G(s).",
                                    "Identificar frequência de cruzamento de ganho (ω_cg) e fase (ω_cp).",
                                    "Calcular margens de ganho (GM) e fase (PM) para o caso nominal.",
                                    "Plotar diagramas de magnitude e fase usando software como MATLAB.",
                                    "Verificar estabilidade nominal (GM > 0 dB, PM > 0°)."
                                  ],
                                  "verification": "Diagramas de Bode nominais plotados corretamente com GM e PM calculadas e estáveis.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Software de análise (MATLAB/Simulink ou Python com control library), função de transferência nominal G(s).",
                                  "tips": "Use escalas logarítmicas para precisão em frequências amplas.",
                                  "learningObjective": "Compreender as bases para análise de estabilidade em diagramas de Bode.",
                                  "commonMistakes": "Confundir malha aberta com fechada; ignorar unidades em dB e graus."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Modelar Incertezas Multiplicativas",
                                  "subSteps": [
                                    "Definir incerteza multiplicativa como Δ(s) onde G_pert(s) = G(s)(1 + Δ(s)).",
                                    "Escolher modelo de incerteza (ex: Δ(jω) = w(ω) * δ, com |δ| ≤ 1).",
                                    "Plotar o diagrama de Bode da função de peso w(s) que envelope as incertezas.",
                                    "Determinar desvios máximos esperados (ex: ±20% em ganho em certas frequências).",
                                    "Validar modelo comparando com dados experimentais ou especificações."
                                  ],
                                  "verification": "Função de peso w(s) plotada e desvios quantificados corretamente.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Função de transferência G(s), dados de incerteza (tabelas ou curvas), software de plotagem.",
                                  "tips": "Use funções de peso de 1º ou 2º ordem para simplicidade inicial.",
                                  "learningObjective": "Modelar incertezas reais como perturbações multiplicativas.",
                                  "commonMistakes": "Subestimar incertezas em baixas frequências; usar modelo aditivo em vez de multiplicativo."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Incorporar Desvios nos Diagramas de Bode",
                                  "subSteps": [
                                    "Desenhar envelope de incerteza: magnitude G(jω) ± |w(jω)| em dB.",
                                    "Plotar diagrama de Bode perturbado: superior para pior caso de ganho, inferior para fase.",
                                    "Identificar frequências críticas onde envelope cruza 0 dB ou -180°.",
                                    "Calcular margens robustas: GM_rob = GM_nominal - max_desvio_ganho; similar para PM.",
                                    "Verificar interseções do envelope com margens nominais."
                                  ],
                                  "verification": "Envelopes de Bode plotados com margens robustas calculadas numericamente.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Gráficos de Bode nominais e w(s), calculadora ou script para envelopes.",
                                  "tips": "Automatize com loop em frequências log-espacadas para precisão.",
                                  "learningObjective": "Visualizar impactos de incertezas nos diagramas de Bode.",
                                  "commonMistakes": "Plotar desvios absolutos em vez de relativos; ignorar fase na incerteza."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Avaliar e Interpretar Estabilidade Robusta",
                                  "subSteps": [
                                    "Comparar GM_rob > 6 dB e PM_rob > 30° para robustez aceitável.",
                                    "Analisar sensibilidade: quanto pior caso viola estabilidade?",
                                    "Simular respostas no tempo para casos perturbados.",
                                    "Documentar conclusões: sistema robusto ou requer redesenho.",
                                    "Propor melhorias como aumento de crossover ou notches."
                                  ],
                                  "verification": "Relatório com margens robustas, simulações e recomendações gerado.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Simulador (Simulink), relatórios de margens anteriores.",
                                  "tips": "Sempre valide com simulação temporal, não só frequência.",
                                  "learningObjective": "Interpretar resultados para decisões de design robusto.",
                                  "commonMistakes": "Aceitar margens nominais sem checar robustas; negligenciar simulações."
                                }
                              ],
                              "practicalExample": "Para um controlador PI em um motor DC com planta G(s) = 1/(s(s+1)) e incerteza multiplicativa w(s) = 0.2 para |ω| < 10 rad/s, plote Bode nominal, adicione envelope ±6 dB, verifique se GM_rob > 6 dB após tuning do PI.",
                              "finalVerifications": [
                                "Margens robustas calculadas corretamente para pior caso.",
                                "Envelopes de incerteza não violam estabilidade (sem encirclement).",
                                "Simulações temporais confirmam robustez para ±20% variação.",
                                "Relatório inclui gráficos de Bode com desvios destacados.",
                                "Recomendações para melhoria se GM_rob < 6 dB.",
                                "Modelo de incerteza validado contra specs reais."
                              ],
                              "assessmentCriteria": [
                                "Precisão nos cálculos de envelopes e margens (±1% erro).",
                                "Qualidade dos gráficos de Bode (legendas, escalas corretas).",
                                "Interpretação correta de robustez (verbal e quantitativa).",
                                "Uso adequado de ferramentas de software sem erros.",
                                "Identificação de erros comuns e como evitá-los.",
                                "Conexão com contexto real do sistema."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Análise de funções complexas e desigualdades (μ-síntese básica).",
                                "Probabilidade: Modelagem estocástica de incertezas como distribuições.",
                                "Física: Dinâmica de sistemas reais com ruído e variações paramétricas.",
                                "Programação: Scripts em MATLAB/Python para automação de análise."
                              ],
                              "realWorldApplication": "Em drones autônomos, analisar robustez de controladores de atitude contra variações de massa/bateria, garantindo estabilidade em ventos variáveis sem crashes."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.1.4.4",
                        "name": "Projeto de Controladores via Diagramas de Bode",
                        "description": "Síntese de compensadores para atender especificações de desempenho e estabilidade no domínio da frequência.",
                        "specificSkills": [
                          {
                            "id": "10.1.1.4.4.1",
                            "name": "Projetar compensador de avanço",
                            "description": "Aumentar margem de fase movendo o ponto de cruzamento de ganho para frequências mais altas com zero e polo adicionais.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Analisar o diagrama de Bode do sistema não compensado",
                                  "subSteps": [
                                    "Plote o diagrama de Bode de magnitude e fase do laço aberto G(s)H(s).",
                                    "Identifique a frequência de cruzamento de ganho atual (ω_gc) onde |G(jω)H(jω)| = 1.",
                                    "Meça a margem de fase atual (PM) em ω_gc.",
                                    "Registre a frequência desejada para o novo ω_gc' (geralmente 3-10 vezes maior para avanço).",
                                    "Anote as especificações desejadas: PM_target (ex: 45-60°)."
                                  ],
                                  "verification": "Confirme que ω_gc, PM atual e ω_gc' estão corretamente identificados e plotados.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Software de simulação (MATLAB/Simulink ou Python com control library)",
                                    "Diagrama de Bode do sistema dado"
                                  ],
                                  "tips": "Use escala logarítmica para precisão; zoom na região de ω_gc para medição exata.",
                                  "learningObjective": "Compreender o comportamento frequência do sistema original e identificar déficits de estabilidade.",
                                  "commonMistakes": [
                                    "Confundir ω_gc com ω_pc (cruzamento de fase)",
                                    "Ignorar contribuições de fase de polos/zeros existentes"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Determinar a fase máxima necessária e localização",
                                  "subSteps": [
                                    "Calcule φ_req = PM_target - PM_atual - 5° a 12° (margem de segurança para contribuição do compensador).",
                                    "Escolha ω_m (frequência de máximo avanço de fase) como ω_gc' / 10 ou próxima de ω_gc'.",
                                    "Use a fórmula sin(φ_max) = (α - 1)/(α + 1), onde α = ω_p / ω_z > 1.",
                                    "Resolva para α ≈ (1 + sin(φ_max))/(1 - sin(φ_max)).",
                                    "Verifique que φ_max contribua adequadamente sem exceder 60-70°."
                                  ],
                                  "verification": "Calcule φ_max e α numericamente e confira com tabela ou gráfico padrão de compensadores de avanço.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Calculadora ou software simbólico (MATLAB syms)",
                                    "Tabelas de compensadores de fase"
                                  ],
                                  "tips": "Adicione 10° extra para compensar a queda de magnitude no compensador.",
                                  "learningObjective": "Calcular quantitativamente os requisitos de avanço de fase para estabilidade desejada.",
                                  "commonMistakes": [
                                    "Esquecer margem de segurança (5-12°)",
                                    "Usar φ_req diretamente sem correção"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Projetar localizações do zero e polo do compensador",
                                  "subSteps": [
                                    "Defina o zero ω_z = ω_m / √α.",
                                    "Defina o polo ω_p = ω_m * √α.",
                                    "Calcule o ganho em DC do compensador K_c = √α para manter magnitude neutra em baixas frequências.",
                                    "Esboce o diagrama de Bode do compensador C(s) = K_c (s/ω_z + 1)/(s/ω_p + 1).",
                                    "Confirme que o avanço máximo ocorre em ω_m."
                                  ],
                                  "verification": "Plote Bode do compensador isolado e confirme φ_max em ω_m e atenuação em altas frequências.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Software de plotagem de Bode",
                                    "Papel para esboços manuais"
                                  ],
                                  "tips": "Escolha α entre 5-20 para φ_max de 40-60°; evite α muito alto para ruído.",
                                  "learningObjective": "Posicionar zero e polo para maximizar avanço de fase na frequência alvo.",
                                  "commonMistakes": [
                                    "Inverter zero e polo (zero deve ser em frequência mais baixa)",
                                    "Esquecer normalização K_c"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Integrar compensador e ajustar ganho final",
                                  "subSteps": [
                                    "Multiplique diagramas de Bode: novo G_comp(jω) = C(jω) G(jω) H(jω).",
                                    "Meça nova ω_gc' onde magnitude cruzou 0 dB.",
                                    "Ajuste ganho DC K_total para que |G_comp(jω_gc')| = 0 dB.",
                                    "Verifique PM em ω_gc' e GM em ω_pc.",
                                    "Itere se necessário ajustando ω_m ou α."
                                  ],
                                  "verification": "Novo diagrama de Bode mostra PM ≥ PM_target e ω_gc' deslocada para mais alta.",
                                  "estimatedTime": "50 minutos",
                                  "materials": [
                                    "Ferramentas de simulação com multiplicação de transfer functions"
                                  ],
                                  "tips": "Use loop de feedback para automação em software; esboce à mão primeiro.",
                                  "learningObjective": "Combinar compensador com planta e otimizar ganho para especificações.",
                                  "commonMistakes": [
                                    "Não reajustar ganho após adição (magnitude do compensador afeta ω_gc)",
                                    "Ignorar overshoot em magnitude"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Validar e refinar o projeto",
                                  "subSteps": [
                                    "Simule resposta temporal ao degrau para verificar overshoot, tempo de estabilização.",
                                    "Analise sensibilidade a variações de parâmetros.",
                                    "Compare métricas: PM, GM, ω_bw antes/depois.",
                                    "Documente equações finais do controlador C(s).",
                                    "Teste robustez com ±20% variação em ganho da planta."
                                  ],
                                  "verification": "Simulações mostram melhoria em PM sem perda excessiva de GM ou ruído.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Simulador de sistemas dinâmicos (Simulink ou Python odeint)"
                                  ],
                                  "tips": "Sempre valide em domínio tempo; Bode não captura tudo.",
                                  "learningObjective": "Garantir que o compensador atenda especificações em múltiplos domínios.",
                                  "commonMistakes": [
                                    "Focar só em Bode ignorando tempo",
                                    "Não testar robustez"
                                  ]
                                }
                              ],
                              "practicalExample": "Para G(s) = 10 / (s(s+1)(s+10)), PM atual=20° em ω_gc=1.5 rad/s. Deseja PM=50°. Calcule φ_max≈45°, α≈8, ω_m=5 rad/s, ω_z=1.8, ω_p=14 rad/s. Novo C(s)=2.8(s+1.8)/(s+14). Resultado: ω_gc'=5 rad/s, PM=52°.",
                              "finalVerifications": [
                                "Capacidade de calcular α e φ_max com erro <5%.",
                                "Diagrama de Bode compensado atinge PM_target com ω_gc deslocada >3x.",
                                "Resposta ao degrau tem overshoot <20% e settling time reduzida.",
                                "Identificação correta de zero/polo no Bode do compensador.",
                                "Ajuste de ganho garante |G_comp(jω_gc')|=0dB.",
                                "Análise de robustez passa em variações ±20%."
                              ],
                              "assessmentCriteria": [
                                "Precisão nos cálculos de ω_z, ω_p e α (erro <10%).",
                                "Qualidade dos diagramas de Bode plotados (legíveis, escalas corretas).",
                                "Melhoria quantificável em PM e ω_gc (≥30° e ≥3x).",
                                "Validação em tempo discreto com métricas explícitas.",
                                "Documentação clara com equações e justificativas.",
                                "Criatividade em iterações para otimização."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Análise complexa e funções logarítmicas para Bode.",
                                "Programação: Implementação em Python/MATLAB para automação de plots.",
                                "Física: Modelagem dinâmica de sistemas mecânicos/elétricos.",
                                "Eletrônica: Realização analógica do compensador com amplificadores operacionais.",
                                "Estatística: Análise de sensibilidade e Monte Carlo para robustez."
                              ],
                              "realWorldApplication": "Em servo-motores de robótica industrial, compensadores de avanço aumentam largura de banda para rastreamento rápido de trajetórias, melhorando precisão em linhas de montagem automotiva sem oscilações excessivas."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.4.4.2",
                            "name": "Projetar compensador de atraso",
                            "description": "Melhorar estabilidade em baixas frequências sem alterar muito a largura de banda, usando polo e zero próximos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Analisar o sistema não compensado e definir requisitos",
                                  "subSteps": [
                                    "Obtenha a função de transferência do laço aberto G(s).",
                                    "Plote os diagramas de Bode de magnitude e fase usando MATLAB, Python (control library) ou Octave.",
                                    "Identifique problemas: margem de fase (PM) baixa em baixas frequências e erro em regime permanente alto.",
                                    "Defina requisitos: PM desejada (>45°), largura de banda similar, redução de erro steady-state.",
                                    "Selecione a frequência de compensação ω_c (1 década abaixo da frequência de cruzamento atual)."
                                  ],
                                  "verification": "Diagramas de Bode plotados com frequência de compensação anotada e requisitos documentados.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Software de simulação (MATLAB/Simulink, Python com control/matplotlib)",
                                    "Função de transferência G(s) do sistema exemplo"
                                  ],
                                  "tips": "Escolha ω_c onde a magnitude está cerca de 10-20 dB acima do desejado para permitir atenuação pelo compensador.",
                                  "learningObjective": "Compreender as limitações do sistema original e quantificar melhorias necessárias para estabilidade em baixas frequências.",
                                  "commonMistakes": [
                                    "Escolher ω_c muito próxima da largura de banda, alterando-a significativamente",
                                    "Ignorar o ganho DC e erro steady-state"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Determinar o fator de compensação α e frequência de compensação",
                                  "subSteps": [
                                    "Calcule o ganho necessário K para atender erro steady-state (ex: K = 1/erro_desejado para tipo 0).",
                                    "Encontre a nova frequência de cruzamento ω_gc desejada para PM alvo.",
                                    "Meça a magnitude |G(jω_c)| na ω_c escolhida; defina atenuação necessária como 10 log10(α) = |G(jω_gc)| - 0 dB.",
                                    "Escolha α tipicamente 5-20 para fase lag <12° e polo/zero próximos.",
                                    "Verifique contribuição de fase φ_max ≈ -atan((α-1)/(2√α)) para garantir mínima perturbação na PM."
                                  ],
                                  "verification": "Valor de α calculado e justificado, com magnitude em ω_c anotada nos diagramas.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Diagramas de Bode do passo 1",
                                    "Calculadora ou software simbólico (SymPy)"
                                  ],
                                  "tips": "Use α=10 como partida; ajuste para polo e zero próximos (razão 4-10).",
                                  "learningObjective": "Calcular parâmetros que atenuam ganho em ω_gc sem degradar estabilidade.",
                                  "commonMistakes": [
                                    "Confundir lag com lead (lag tem polo mais baixo que zero)",
                                    "Escolher α muito grande, reduzindo largura de banda"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Projetar o compensador de atraso G_c(s)",
                                  "subSteps": [
                                    "Defina zero em ω_z = ω_c / √α.",
                                    "Defina polo em ω_p = ω_z / α.",
                                    "Forme G_c(s) = K_c * (s/ω_z + 1) / (s/ω_p + 1), com K_c para normalizar ganho DC=1.",
                                    "Ajuste K total = K * K_c para nova ω_gc.",
                                    "Plote Bode de G_c(s) isolado para confirmar atenuação em ω_c e fase lag máxima."
                                  ],
                                  "verification": "Função G_c(s) explícita com polo, zero e K calculados; Bode de G_c plotado.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Software de simulação",
                                    "Folha de cálculos ou notebook Jupyter"
                                  ],
                                  "tips": "Garanta ω_p e ω_z próximos à ω_c mas abaixo para não afetar alta frequência.",
                                  "learningObjective": "Construir o transfer function do compensador com polo e zero otimizados.",
                                  "commonMistakes": [
                                    "Inverter posições de polo e zero",
                                    "Esquecer normalização de K_c"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificar e validar o sistema compensado",
                                  "subSteps": [
                                    "Multiplique G_comp(s) = K * G_c(s) * G(s) e plote novos diagramas de Bode.",
                                    "Meça novas PM, GM, ω_gc e compare com original.",
                                    "Simule resposta ao degrau para erro steady-state e overshoot.",
                                    "Ajuste iterativamente α ou ω_c se necessário (PM <45° ou BW alterada >20%).",
                                    "Documente melhorias: estabilidade em baixas freq mantida, BW similar."
                                  ],
                                  "verification": "Diagramas finais mostram PM melhorada, erro reduzido e BW estável; simulação de step response.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Software de simulação com step response",
                                    "Templates de relatório"
                                  ],
                                  "tips": "Use zoom nos Bode para precisão em baixas frequências.",
                                  "learningObjective": "Avaliar eficácia do compensador via análise quantitativa e simulação.",
                                  "commonMistakes": [
                                    "Não simular tempo real (foco só em freq)",
                                    "Aceitar PM marginal sem iteração"
                                  ]
                                }
                              ],
                              "practicalExample": "Para um servo-motor de posição com G(s) = 100 / (s(s+10)), original PM=20°, erro steady-state=0.1. Após lag com α=10, ω_c=1 rad/s: novo PM=50°, erro=0.01, BW~5 rad/s similar.",
                              "finalVerifications": [
                                "Margem de fase aumentou para pelo menos 45° sem perda >5°.",
                                "Margem de ganho >6 dB.",
                                "Erro steady-state reduzido por fator 1/α.",
                                "Largura de banda alterada <20%.",
                                "Fase lag máxima <12° na nova ω_gc.",
                                "Resposta ao degrau: overshoot <20%, tempo de estabilização similar."
                              ],
                              "assessmentCriteria": [
                                "Correta seleção de ω_c 1 década abaixo de ω_gc.",
                                "Cálculo preciso de α baseado em magnitude medida.",
                                "Posições de zero e polo com razão α exata.",
                                "Plots de Bode antes/depois com anotações claras.",
                                "Explicação qualitativa da melhoria em baixas frequências.",
                                "Simulação validando todos os requisitos."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Análise de funções complexas e logarítmica (Bode).",
                                "Eletrônica: Implementação em amplificadores operacionais (circuitos RC).",
                                "Programação: Scripts em Python/MATLAB para automação de design.",
                                "Física: Modelagem dinâmica de sistemas mecânicos/elétricos."
                              ],
                              "realWorldApplication": "Em controladores de velocidade de motores DC para veículos autônomos, onde se melhora precisão em baixas velocidades (estabilidade) sem reduzir aceleração máxima (largura de banda), evitando oscilações em manobras lentas."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.4.4.3",
                            "name": "Sintonizar controladores PID",
                            "description": "Ajustar ganhos proporcionais, integral e derivativo para moldar as curvas de magnitude e fase às especificações desejadas.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Análise Inicial do Diagrama de Bode do Sistema sem Controlador",
                                  "subSteps": [
                                    "Obtenha ou derive a função de transferência do processo (planta).",
                                    "Plote os diagramas de magnitude e fase de Bode do laço aberto sem PID.",
                                    "Identifique a frequência de crossover atual, margens de ganho e fase, e erros em regime permanente.",
                                    "Defina as especificações desejadas: frequência de crossover (ω_c), margem de fase (φ_m > 45°), sobressinal (<20%).",
                                    "Anote pontos críticos como polos, zeros e cantos."
                                  ],
                                  "verification": "Diagramas de Bode plotados corretamente com legendas e anotações das especificações.",
                                  "estimatedTime": "1-2 horas",
                                  "materials": [
                                    "Software MATLAB/Simulink ou Python (control library)",
                                    "Função de transferência da planta",
                                    "Papel milimetrado para esboços manuais"
                                  ],
                                  "tips": "Use log-log para magnitude e log-linear para fase; verifique simetria em baixas frequências.",
                                  "learningObjective": "Compreender o comportamento dinâmico do sistema aberto para guiar o design do PID.",
                                  "commonMistakes": [
                                    "Ignorar o erro em regime permanente tipo 1 ou 0.",
                                    "Confundir magnitude com fase.",
                                    "Não linearizar escalas logarítmicas."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Ajuste do Ganho Proporcional (Kp)",
                                  "subSteps": [
                                    "Escolha a nova frequência de crossover desejada (ω_c) baseada nas especificações de velocidade de resposta.",
                                    "Calcule Kp para que a magnitude cruze 0 dB em ω_c: Kp = 1 / |G(jω_c)|.",
                                    "Plote o novo Bode com Kp e verifique a margem de fase inicial.",
                                    "Ajuste iterativamente se necessário para aproximar φ_m.",
                                    "Registre o valor de Kp e o impacto nas curvas."
                                  ],
                                  "verification": "Magnitude cruza 0 dB em ω_c desejada com Kp aplicado.",
                                  "estimatedTime": "45 minutos - 1 hora",
                                  "materials": [
                                    "Software de plotagem de Bode",
                                    "Calculadora ou script para |G(jω)|"
                                  ],
                                  "tips": "Comece com ω_c 1/10 da frequência de ressonância para estabilidade.",
                                  "learningObjective": "Dominar o controle da velocidade via ganho proporcional sem exceder instabilidades.",
                                  "commonMistakes": [
                                    "Escolher ω_c muito alta causando oscilações.",
                                    "Esquecer de converter para dB (20 log10(Kp)).",
                                    "Não verificar fase em ω_c."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Introdução e Ajuste do Termo Integral (Ki)",
                                  "subSteps": [
                                    "Adicione o zero integral em baixa frequência: Ki = Kp / Ti, onde Ti é o tempo integral.",
                                    "Coloque o zero em ~0.1 ω_c para corrigir erro steady-state sem afetar muito a fase em ω_c.",
                                    "Replot o Bode e verifique eliminação do erro em DC (magnitude -> ∞ em ω=0).",
                                    "Ajuste Ki para manter ω_c estável e φ_m >45°.",
                                    "Simule resposta ao degrau para confirmar ausência de erro permanente."
                                  ],
                                  "verification": "Erro steady-state zero para entradas degrau; fase não degradada em ω_c.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Simulink ou Python para simulação temporal",
                                    "Diagramas de Bode atualizados"
                                  ],
                                  "tips": "Zero integral muito baixo pode reduzir margem de fase; teste com simulação.",
                                  "learningObjective": "Eliminar erros em regime permanente mantendo estabilidade dinâmica.",
                                  "commonMistakes": [
                                    "Colocar zero integral muito próximo de ω_c.",
                                    "Ignorar saturação do integrador em simulações.",
                                    "Confundir Ki com Kd."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Introdução e Ajuste do Termo Derivativo (Kd)",
                                  "subSteps": [
                                    "Adicione o zero derivativo: Kd = Kp * Td, com Td ~ 0.1-0.25 / ω_c para boost de fase.",
                                    "Posicione para adicionar +10-20° de fase em ω_c, melhorando φ_m.",
                                    "Replot Bode completo do PID + planta e verifique margens finais.",
                                    "Aplique filtro derivativo (1 + s Td)/(1 + s Td/N) com N=10 para ruído.",
                                    "Simule respostas a degrau e rampa para validar sobressinal e settling time."
                                  ],
                                  "verification": "Margem de fase >45°, ganho >6dB; resposta temporal sem overshoot excessivo.",
                                  "estimatedTime": "1-1.5 horas",
                                  "materials": [
                                    "Ferramentas de simulação completa (laço fechado)",
                                    "Dados de ruído simulados"
                                  ],
                                  "tips": "Derivativo amplifica ruído: sempre filtre; itere com simulações.",
                                  "learningObjective": "Melhorar robustez e amortecimento via ação preditiva derivativa.",
                                  "commonMistakes": [
                                    "Zero derivativo muito alto causando picos de fase.",
                                    "Não filtrar derivativo levando a instabilidade numérica.",
                                    "Exagerar Kd reduzindo velocidade."
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Verificação Final e Otimização",
                                  "subSteps": [
                                    "Compare métricas finais: ω_c, φ_m, GM, tempo de acomodação, overshoot.",
                                    "Teste robustez variando parâmetros da planta (±20%).",
                                    "Otimize trade-offs iterando Kp, Ki, Kd se specs não atendidas.",
                                    "Documente valores finais e razões.",
                                    "Implemente em hardware/simulador real para validação."
                                  ],
                                  "verification": "Todas specs atendidas em simulações nominais e robustas.",
                                  "estimatedTime": "30-45 minutos",
                                  "materials": [
                                    "Scripts de análise de robustez",
                                    "Relatório template"
                                  ],
                                  "tips": "Use otimização automática como PID Tuner no MATLAB para benchmark.",
                                  "learningObjective": "Garantir controle robusto e documentar processo de design.",
                                  "commonMistakes": [
                                    "Não testar robustez.",
                                    "Aceitar specs marginais.",
                                    "Omitir documentação."
                                  ]
                                }
                              ],
                              "practicalExample": "Sintonize um PID para controlar a posição de um braço robótico com planta G(s) = 1/(s(s+1)), especificando ω_c=2 rad/s, φ_m=60°, overshoot<10%. Ajuste Kp para crossover, Ki para erro zero, Kd para fase extra, simulando em MATLAB.",
                              "finalVerifications": [
                                "Diagrama de Bode do laço aberto com PID atinge ω_c desejada em 0dB.",
                                "Margem de fase ≥45° e margem de ganho ≥6dB.",
                                "Resposta ao degrau: overshoot <20%, settling time <4/ω_c.",
                                "Erro steady-state zero para entradas degrau.",
                                "Robustez mantida com variação de 20% nos parâmetros da planta.",
                                "Fase boostada pelo derivativo sem picos excessivos."
                              ],
                              "assessmentCriteria": [
                                "Precisão no cálculo de Kp, Ki, Kd (±10% do ótimo).",
                                "Diagramas de Bode corretos com anotações claras.",
                                "Respostas temporais simuladas atendem specs em pelo menos 90%.",
                                "Explicação coerente dos trade-offs entre ganhos.",
                                "Identificação correta de erros comuns e correções.",
                                "Documentação completa com valores e justificativas."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Análise de frequência via transformada de Fourier/Laplace.",
                                "Física: Modelagem dinâmica de sistemas massa-mola-amortecedor.",
                                "Programação: Implementação de PID em Python (control/scipy) ou MATLAB.",
                                "Eletrônica: Realização analógica/digital de PID em microcontroladores.",
                                "Estatística: Análise de robustez e Monte Carlo para incertezas."
                              ],
                              "realWorldApplication": "Controle de velocidade em motores de veículos autônomos, estabilização de drones contra ventos, regulação de temperatura em reatores químicos industriais, garantindo precisão e estabilidade em processos de manufatura automatizada."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.1.5",
                    "name": "Critério de Nyquist",
                    "description": "Método para avaliação de estabilidade e margens de ganho e fase em sistemas de controle escalares.",
                    "individualConcepts": [
                      {
                        "id": "10.1.1.5.1",
                        "name": "Diagrama de Nyquist",
                        "description": "Representação gráfica da função de malha aberta no plano complexo para análise de frequência em sistemas de controle lineares invariantes no tempo (LIT) escalares.",
                        "specificSkills": [
                          {
                            "id": "10.1.1.5.1.1",
                            "name": "Construir o diagrama de Nyquist",
                            "description": "Dado a função de transferência de malha aberta G(s), plotar o diagrama de Nyquist no plano complexo variando a frequência ω de 0 a ∞, incluindo o contorno semicircular para pólos no semiplano imaginário.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Análise Preliminar da Função de Transferência G(s)",
                                  "subSteps": [
                                    "Identificar e listar todos os pólos e zeros de G(s) fatorizando o numerador e denominador.",
                                    "Verificar a presença de pólos no eixo imaginário puro (jω axis).",
                                    "Calcular os limites lim_{ω→0+} G(jω) e lim_{ω→∞} G(jω).",
                                    "Determinar o número de pólos de ordem superior para assíntotas em alta frequência.",
                                    "Selecionar intervalos logarítmicos de ω (ex: 0.1, 1, 10, 100) para amostragem inicial."
                                  ],
                                  "verification": "Lista completa de pólos, zeros, limites calculados e confirmados por substituição numérica simples.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Função G(s) dada, calculadora gráfica, software simbólico (MATLAB Symbolic ou SymPy), papel quadriculado.",
                                  "tips": "Fatore G(s) completamente para identificar simetrias e simplificações.",
                                  "learningObjective": "Compreender a topologia de G(s) para prever o comportamento do diagrama.",
                                  "commonMistakes": "Ignorar pólos de ordem múltipla ou confundir zeros com pólos."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Cálculo das Componentes Real e Imaginária de G(jω)",
                                  "subSteps": [
                                    "Substituir s = jω em G(s) para obter G(jω) = Re(ω) + j Im(ω).",
                                    "Simplificar algebraicamente as expressões de Re(G(jω)) e Im(G(jω)).",
                                    "Computar valores numéricos para pelo menos 15 valores de ω em escala log (de 10^{-2} a 10^{2}).",
                                    "Construir tabela com colunas: ω, |G(jω)|, arg(G(jω)), Re, Im.",
                                    "Verificar simetria: Im(G(jω)) = -Im(G(-jω)) e simetria ao eixo real."
                                  ],
                                  "verification": "Tabela com valores precisos (erro <1%) e gráfico preliminar de magnitude/fase vs log(ω).",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Planilha Excel ou Python (numpy/control), calculadora, tabela logarítmica.",
                                  "tips": "Use ω log-espaciado para capturar transições rápidas.",
                                  "learningObjective": "Dominar o cálculo da resposta em frequência no domínio complexo.",
                                  "commonMistakes": "Erros aritméticos em racionalização ou esquecimento de termos pares/ímpares."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Construção da Curva Principal do Diagrama de Nyquist",
                                  "subSteps": [
                                    "Plotar os pontos (Re(ω), Im(ω)) no plano complexo, marcando ω.",
                                    "Conectar pontos com curvas suaves, indicando direção crescente de ω com setas.",
                                    "Identificar e marcar pontos críticos: interseção com eixo real, real= -1, fase= -180°.",
                                    "Desenhar assíntotas para ω→∞ baseadas no tipo de sistema (ex: círculos para tipo 0).",
                                    "Refletir a curva simetricamente abaixo do eixo real para o contorno completo D."
                                  ],
                                  "verification": "Curva plotada manualmente ou via software, com pelo menos 10 pontos visíveis e setas corretas.",
                                  "estimatedTime": "40 minutos",
                                  "materials": "Papel milimetrado ou software de plot (MATLAB nyquist(), Python control.nyquist_plot()), régua, compasso.",
                                  "tips": "Comece pelos limites e preencha o meio para evitar distorções.",
                                  "learningObjective": "Visualizar a trajetória de G(jω) no plano complexo.",
                                  "commonMistakes": "Direção errada das setas ou falta de simetria."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Inclusão do Contorno Semicircular e Verificação Final",
                                  "subSteps": [
                                    "Para cada pólo em jω_k, desenhar semicírculo indentação ε→0 à direita no plano s.",
                                    "Mapear via G(s): para pólo simples, resulta em arco semicircular |G|→∞, sentido horário.",
                                    "Integrar o contorno ao diagrama principal, fechando o D-contorno.",
                                    "Verificar número de encirclements N do ponto -1/j0.",
                                    "Confirmar conformidade com teorema de Nyquist: Z = P + N."
                                  ],
                                  "verification": "Diagrama completo com contornos, legenda e anotação de N, P, Z.",
                                  "estimatedTime": "35 minutos",
                                  "materials": "Software de simulação (MATLAB contour, Python), transparência para sobrepor.",
                                  "tips": "Lembre: indentação à direita evita pólos; arco em G é grande e horário para pólo simples.",
                                  "learningObjective": "Aplicar corretamente o teorema de Nyquist com indentação.",
                                  "commonMistakes": "Sentido errado do arco ou esquecimento de múltiplos pólos."
                                }
                              ],
                              "practicalExample": "Para G(s) = 1 / [s (s + 1)], pólo em s=0. Calcule G(jω) = 1/[jω (jω +1)] = [-ω / (ω^2 + ω^4 +1) ] + j [ -1/(ω^2 + ω^4 +1) wait, simplify: Re = -ω^2 / (ω^4 + ω^2 +1)? Standard: inicia em -j∞ (ω=0+), vai para 0 along negative imag, cruza real em -0.5. Indent semicircle at 0 maps to large semicircle clockwise from -j∞ to +j∞.",
                              "finalVerifications": [
                                "Curva inicia e termina corretamente nos limites ω=0+ e ∞.",
                                "Simetria perfeita em relação ao eixo real.",
                                "Setas indicam aumento de ω corretamente.",
                                "Contorno semicircular incluído com direção e raio corretos.",
                                "Ponto crítico -1 marcado e encirclements contados.",
                                "Diagrama fecha o contorno D sem lacunas."
                              ],
                              "assessmentCriteria": [
                                "Precisão numérica dos pontos calculados (erro <2%).",
                                "Correção e suavidade da curva plotada.",
                                "Tratamento preciso do contorno semicircular.",
                                "Identificação correta de pontos chave (ganho, fase margins).",
                                "Aplicação válida do critério de Nyquist (N=Z-P).",
                                "Clareza das anotações e legenda."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Análise de funções complexas e teorema do argumento.",
                                "Programação: Implementação numérica com Bode/Nyquist plots em MATLAB/Python.",
                                "Física: Dinâmica de sistemas lineares invariantes no tempo.",
                                "Engenharia de Software: Validação de modelos de simulação."
                              ],
                              "realWorldApplication": "Análise de estabilidade em controladores de voo de aeronaves, reguladores de velocidade em motores elétricos industriais e sistemas de controle de processos químicos, previnendo oscilações instáveis em plantas reais."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.5.1.2",
                            "name": "Interpretar o contorno de Nyquist",
                            "description": "Analisar o trajeto da imagem de G(jω) no plano complexo, identificando travessias do eixo real e imaginário para determinar pontos críticos de estabilidade.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o conceito de contorno de Nyquist",
                                  "subSteps": [
                                    "Revise a função de transferência G(s) do sistema de controle.",
                                    "Entenda que o contorno de Nyquist é a imagem de G(jω) para ω de -∞ a +∞ no plano complexo.",
                                    "Identifique o semicírculo de raio infinito para ω → ±∞.",
                                    "Estude o papel das travessias do eixo real negativo (-1,0) na estabilidade.",
                                    "Diferencie contorno principal (ω: 0 a +∞) e completo (incluindo ω negativo por conjugação)."
                                  ],
                                  "verification": "Explique verbalmente ou por escrito o que representa o contorno de Nyquist e seu propósito na análise de estabilidade.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Função de transferência exemplo",
                                    "Papel e lápis",
                                    "Livro de controle ou notas de aula"
                                  ],
                                  "tips": "Visualize o plano complexo com eixos real (Re) e imaginário (Im); foque em G(jω) como um caminho curvo.",
                                  "learningObjective": "Dominar os fundamentos teóricos do diagrama de Nyquist e seu contorno.",
                                  "commonMistakes": [
                                    "Confundir G(jω) com o polo em s=jω",
                                    "Ignorar o semicírculo de Nyquist para polos em jω",
                                    "Esquecer que ω negativo é o espelho do positivo"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Construir o diagrama de Nyquist para G(jω)",
                                  "subSteps": [
                                    "Calcule G(jω) = Re + jIm para vários valores de ω (ex: 0.1, 1, 10).",
                                    "Plote os pontos no plano complexo e conecte-os suavemente.",
                                    "Inclua o comportamento assintótico para ω → 0 e ω → ∞.",
                                    "Adicione setas indicando direção crescente de ω.",
                                    "Verifique simetria: parte para ω < 0 é conjugada da ω > 0."
                                  ],
                                  "verification": "Desenhe o diagrama completo e rotule pelo menos 5 pontos chave com valores de ω.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Calculadora ou software como MATLAB/Python (control library)",
                                    "Papel milimetrado ou ferramenta de plotagem online"
                                  ],
                                  "tips": "Use tabela de valores de ω logarítmico para cobrir faixas amplas; plotar magnitude e fase separadamente ajuda.",
                                  "learningObjective": "Capacitar a geração precisa do trajeto de G(jω) no plano complexo.",
                                  "commonMistakes": [
                                    "Erros de cálculo em Re/Im (use fórmula: G(jω) = num(jω)/den(jω))",
                                    "Não indicar direção do contorno",
                                    "Ignorar indentação em polos/jzeros no imaginário"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Identificar travessias do eixo real e imaginário",
                                  "subSteps": [
                                    "Examine o trajeto quanto a cruzamentos do eixo real negativo (passagem pelo ponto crítico -1).",
                                    "Registre frequências ω onde Im[G(jω)] = 0 e Re[G(jω)] < 0.",
                                    "Identifique interseções com eixo imaginário (Re=0).",
                                    "Conte o número de travessias e direção (sentido horário ou anti-horário).",
                                    "Marque pontos de magnitude |G(jω)| = 1 para margem de ganho."
                                  ],
                                  "verification": "Liste todas as travessias com ω correspondente e indique se são críticas para estabilidade.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Diagrama plotado do step anterior",
                                    "Régua e compasso para medições precisas"
                                  ],
                                  "tips": "Resolva Im[G(jω)]=0 analiticamente para encontrar ω exatas; amplie a região perto de -1.",
                                  "learningObjective": "Desenvolver habilidade em detectar features críticas no contorno.",
                                  "commonMistakes": [
                                    "Confundir travessia com tangência",
                                    "Não considerar direção da travessia",
                                    "Esquecer travessias múltiplas em sistemas de alta ordem"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar o critério de Nyquist para determinar estabilidade",
                                  "subSteps": [
                                    "Conte o número de encirclements (N) do ponto -1+j0 pelo contorno completo.",
                                    "Lembre: Z = P + N, onde Z=pole zero direito (RHP), P=pole RHP de G(s).",
                                    "Se Z=0, sistema estável (loop aberto → fechado).",
                                    "Analise pontos críticos: frequência de fase-margem e ganho-margem.",
                                    "Conclua sobre estabilidade relativa e robustez."
                                  ],
                                  "verification": "Forneça conclusão de estabilidade com justificativa baseada em N, P e Z.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Diagrama completo com marcações",
                                    "Tabela de polos de G(s)"
                                  ],
                                  "tips": "Encirclement é contorno fechado ao redor de -1; sentido anti-horário é positivo.",
                                  "learningObjective": "Interpretar o contorno para decisões de estabilidade e projeto.",
                                  "commonMistakes": [
                                    "Errar contagem de encirclements (use regra da mão direita)",
                                    "Confundir P com Z",
                                    "Aplicar critério sem contorno completo"
                                  ]
                                }
                              ],
                              "practicalExample": "Para G(s) = K / (s(s+1)(s+10)), plote Nyquist: contorno cruza eixo real em -0.5 (ω≈1.4), sem encirclement de -1 para K=1 → estável. Aumente K até travessia em -1 (margem de ganho).",
                              "finalVerifications": [
                                "Pode plotar Nyquist corretamente para G(s) dado?",
                                "Identifica todas travessias do eixo real negativo?",
                                "Conta encirclements de -1 com precisão?",
                                "Aplica Z = P + N corretamente?",
                                "Calcula margens de ganho e fase a partir do diagrama?",
                                "Explica impacto de K no contorno?"
                              ],
                              "assessmentCriteria": [
                                "Precisão no traçado do contorno (pontos corretos e direção)",
                                "Correta identificação de travessias e frequências",
                                "Contagem exata de encirclements e aplicação do critério",
                                "Análise de margens de estabilidade",
                                "Clareza na explicação escrita ou verbal",
                                "Uso adequado de ferramentas e verificações"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Análise de funções complexas e contornos no plano complexo",
                                "Física: Dinâmica de sistemas lineares e oscilações",
                                "Informática: Programação em MATLAB/Python para plotagem automática",
                                "Engenharia Elétrica: Análise de frequência em circuitos",
                                "Estatística: Análise de robustez e variância em parâmetros"
                              ],
                              "realWorldApplication": "Em automação industrial, interpretar Nyquist garante estabilidade de controladores PID em motores, evitando oscilações destrutivas em linhas de produção ou estabilização de drones e aeronaves."
                            },
                            "estimatedTime": "0.5 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.5.1.3",
                            "name": "Tratar indentação em pólos de malha aberta",
                            "description": "Aplicar indentação semicircular infinitesimal ao redor de pólos no eixo imaginário jω para completar o contorno de Nyquist conforme o teorema do argumento.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Identificar pólos de malha aberta no eixo imaginário jω",
                                  "subSteps": [
                                    "Calcule os pólos da função de malha aberta G(s)H(s) resolvendo G(s)H(s) = 0.",
                                    "Verifique se algum polo está exatamente no eixo imaginário (parte real = 0).",
                                    "Liste as frequências ω onde os pólos ocorrem (ex: s = jω_p).",
                                    "Confirme multiplicidade do polo (simples ou múltiplo).",
                                    "Documente posições exatas para referência posterior."
                                  ],
                                  "verification": "Lista de pólos com Im(s) ≠ 0 e Re(s) = 0 confirmada por cálculo ou software.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Função de transferência G(s)H(s), calculadora simbólica (MATLAB/SymPy), papel para anotações.",
                                  "tips": "Use fatoração para encontrar raízes imaginárias puras rapidamente.",
                                  "learningObjective": "Reconhecer pólos jω que invalidam o contorno padrão de Nyquist.",
                                  "commonMistakes": "Confundir zeros com pólos ou ignorar pólos de ordem superior."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Compreender a necessidade da indentação pelo teorema do argumento",
                                  "subSteps": [
                                    "Revise o teorema do argumento: Δarg(G(jω)) = 2π(N - P), onde P são pólos no contorno.",
                                    "Explique por que pólos no contorno tornam o teorema inválido (singularidades).",
                                    "Defina indentação semicircular infinitesimal de raio ε → 0 à direita do polo.",
                                    "Justifique direção: à direita para manter sentido anti-horário do contorno.",
                                    "Discuta limite ε → 0 para contribuição assintótica."
                                  ],
                                  "verification": "Explicação escrita justificando indentação e direção com referência ao teorema.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Texto sobre teorema do argumento, diagrama esquemático do contorno Nyquist.",
                                  "tips": "Desenhe o contorno original vs. indentado para visualização.",
                                  "learningObjective": "Aplicar teorema do argumento para validar modificação do contorno.",
                                  "commonMistakes": "Escolher indentação à esquerda, violando convenção padrão."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Construir e parametrizar a indentação semicircular",
                                  "subSteps": [
                                    "Defina o arco: s(φ) = jω_p + ε e^{j(π/2 - φ)}, φ de 0 a π (direita).",
                                    "Escolha ε pequeno (ex: 10^{-3} para simulação).",
                                    "Plote o contorno modificado: eixo jω indentado ao redor de ω_p.",
                                    "Integre ao semicírculo infinito D (se aplicável).",
                                    "Verifique fechamento do contorno total."
                                  ],
                                  "verification": "Diagrama desenhado ou plotado mostrando indentação semicircular à direita.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Software de plotagem (MATLAB nyquist(), Python control.matlab), régua e compasso para esboço manual.",
                                  "tips": "Use ε = 0.001 para visualização numérica sem perda de precisão.",
                                  "learningObjective": "Parametrizar geometricamente a deformação do contorno.",
                                  "commonMistakes": "Usar arco completo em vez de semicircular ou ângulo errado (π em vez de π/2)."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar o mapeamento da indentação no plano G(s)",
                                  "subSteps": [
                                    "Calcule G(s(φ)) para s no arco indentado.",
                                    "Analise assintótica: próximo a polo simples, |G(s)| → ∞, arg(G(s)) gira -π.",
                                    "Para polo de ordem m, rotação de -mπ.",
                                    "Plote a imagem do arco: semicírculo grande no plano G(s) em sentido horário.",
                                    "Integre ao diagrama Nyquist completo."
                                  ],
                                  "verification": "Gráfico do mapeamento mostrando semicírculo de raio ∞ girando -π (ou -mπ).",
                                  "estimatedTime": "30 minutos",
                                  "materials": "MATLAB/Python para nyquist com indentação customizada, calculadora para limite.",
                                  "tips": "Use expansão de Laurent: G(s) ≈ c/(s - p)^m perto do polo.",
                                  "learningObjective": "Prever contribuição angular da indentação para critério de Nyquist.",
                                  "commonMistakes": "Ignorar multiplicidade do polo, errando rotação angular."
                                }
                              ],
                              "practicalExample": "Para G(s) = 1/(s(s+1)), polo em s=0. Indente eixo jω com ε=0.01 à direita de ω=0. Mapeamento: semicírculo |G|→∞ de arg=-π/2 a π/2 em sentido horário. Diagrama Nyquist completo mostra encirclement correto para estabilidade.",
                              "finalVerifications": [
                                "Pólos jω identificados corretamente com multiplicidades.",
                                "Indentação semicircular desenhada à direita com raio ε→0.",
                                "Mapeamento assintótico mostra rotação -mπ no plano G(s).",
                                "Contorno total fecha sem singularidades.",
                                "Critério de Nyquist aplicado consistentemente com indentação.",
                                "Gráficos numéricos/teóricos coincidem."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de pólos jω (100% corretos).",
                                "Correta parametrização e direção da indentação.",
                                "Análise assintótica da contribuição angular exata.",
                                "Integração coerente ao diagrama Nyquist completo.",
                                "Visualizações claras e rotuladas.",
                                "Explicação teórica alinhada ao teorema do argumento."
                              ],
                              "crossCurricularConnections": [
                                "Análise de funções complexas (expansão de Laurent, resíduos).",
                                "Geometria analítica (arcos circulares no plano complexo).",
                                "Programação numérica (simulação de contornos em MATLAB/Python).",
                                "Física (osciladores harmônicos com pólos jω)."
                              ],
                              "realWorldApplication": "Em controle de motores DC com integrador (polo em s=0), indentação assegura análise de estabilidade Nyquist para evitar oscilações sustentadas em laços de velocidade."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.1.5.1.2",
                        "name": "Critério de Estabilidade de Nyquist",
                        "description": "Critério gráfico baseado no teorema do argumento para determinar a estabilidade de sistemas de laço fechado a partir do diagrama de Nyquist da função de malha aberta.",
                        "specificSkills": [
                          {
                            "id": "10.1.1.5.1.2.1",
                            "name": "Calcular o número de encirclamentos N",
                            "description": "Contar o número líquido de encirclamentos em sentido anti-horário do ponto crítico (-1,0) pelo contorno de Nyquist, usando N = P - Z onde P são pólos instáveis de malha aberta e Z de malha fechada.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Identificar pólos instáveis da malha aberta (P)",
                                  "subSteps": [
                                    "Obtenha a função de transferência de malha aberta G(s)H(s).",
                                    "Encontre todos os pólos resolvendo o denominador igual a zero.",
                                    "Classifique os pólos com parte real positiva (RHP) como instáveis e conte P."
                                  ],
                                  "verification": "Lista de pólos instáveis anotada corretamente, com P quantificado.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Função de transferência G(s)H(s), papel e lápis ou software como MATLAB/SymPy.",
                                  "tips": "Use o teste de Routh-Hurwitz para auxiliar na identificação rápida de pólos instáveis.",
                                  "learningObjective": "Identificar e quantificar pólos instáveis de G(s)H(s) para uso no critério de Nyquist.",
                                  "commonMistakes": "Confundir pólos de malha aberta com zeros ou ignorar pólos no semiplano direito (Re(s)>0)."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Construir e plotar o diagrama de Nyquist",
                                  "subSteps": [
                                    "Defina o contorno de Nyquist: eixo imaginário jω de -j∞ a +j∞, com semicírculo à direita para indentar pólos/zeros no eixo imaginário.",
                                    "Calcule G(jω)H(jω) para ω de 0 a ∞ e plote no plano complexo (parte real vs. imaginária).",
                                    "Complete com o semicírculo de grande raio (ω→∞) e partes indentadas se necessário.",
                                    "Marque o ponto crítico (-1, 0)."
                                  ],
                                  "verification": "Diagrama completo plotado, com curvas para ω>0 e ω<0 simétricas, e ponto (-1,0) destacado.",
                                  "estimatedTime": "40 minutos",
                                  "materials": "Software de plotagem (MATLAB nyquist(), Python control.nyquist_plot()), régua e papel milimetrado.",
                                  "tips": "Comece com frequências chave: ω=0, ω→∞, e pontos de fase/magnitud críticas para esboço manual.",
                                  "learningObjective": "Construir o contorno de Nyquist completo e preciso para análise de estabilidade.",
                                  "commonMistakes": "Esquecer a simetria para ω negativo ou não indentar corretamente pólos no eixo jω."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Contar encirclamentos líquidos N do ponto crítico",
                                  "subSteps": [
                                    "Visualize o contorno de Nyquist e o ponto (-1+j0).",
                                    "Siga o contorno no sentido anti-horário (aumentando ω).",
                                    "Conte +1 para cada encirclamento completo anti-horário, -1 para horário; some para N líquido.",
                                    "Confirme direção: anti-horário é positivo."
                                  ],
                                  "verification": "Número N anotado com justificativa de contagem (ex: 2 anti-horários líquidos).",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Diagrama de Nyquist plotado, lupa ou zoom no software para curvas próximas a (-1,0).",
                                  "tips": "Use a regra da mão direita: polegar na direção do contorno, dedos curvam sentido do encirclamento.",
                                  "learningObjective": "Contar precisamente o número líquido de encirclamentos N em sentido anti-horário.",
                                  "commonMistakes": "Contar apenas magnitude sem direção ou confundir sentido horário/anti-horário."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Calcular Z e verificar estabilidade usando N = P - Z",
                                  "subSteps": [
                                    "Use a fórmula Z = P - N para número de pólos instáveis de malha fechada.",
                                    "Interprete: se Z=0, sistema estável; Z>0 indica instabilidade.",
                                    "Documente o resultado final de N, P e Z."
                                  ],
                                  "verification": "Cálculo de Z correto e conclusão de estabilidade explicitada.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Valores de P e N obtidos, calculadora.",
                                  "tips": "Lembre: N positivo para anti-horário; verifique unidades e consistência.",
                                  "learningObjective": "Aplicar N = P - Z para determinar estabilidade de malha fechada.",
                                  "commonMistakes": "Inverter a fórmula (usar Z = N - P) ou ignorar sinal de N."
                                }
                              ],
                              "practicalExample": "Para G(s)H(s) = 10 / (s(s+1)(s+2)), determine P=0 (todos pólos LHP). Plote Nyquist: para K=10, o diagrama encirra (-1,0) duas vezes no sentido horário (N=-2). Assim Z = 0 - (-2) = 2 (instável).",
                              "finalVerifications": [
                                "Diagrama de Nyquist plotado com precisão e simetria correta.",
                                "Pólos instáveis P identificados e quantificados corretamente.",
                                "Contagem de N líquida anti-horária exata, com justificativa visual.",
                                "Cálculo Z = P - N realizado sem erros aritméticos.",
                                "Conclusão de estabilidade coerente com o critério de Nyquist.",
                                "Documentação completa incluindo direção dos encirclamentos."
                              ],
                              "assessmentCriteria": [
                                "Precisão na construção do diagrama de Nyquist (90% das curvas corretas).",
                                "Correta identificação de P e contagem de N (erro zero).",
                                "Entendimento conceitual da direção anti-horária e fórmula N=P-Z.",
                                "Qualidade da análise visual de encirclamentos próximos ao ponto crítico.",
                                "Capacidade de relacionar N à estabilidade do sistema.",
                                "Clareza na documentação e verificações intermediárias."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Análise de funções complexas e contornos no plano complexo.",
                                "Física: Modelagem dinâmica de sistemas lineares e estabilidade oscilatória.",
                                "Informática: Programação de simulações numéricas em MATLAB/Python para plotagem.",
                                "Engenharia Elétrica: Análise de frequência em circuitos e filtros."
                              ],
                              "realWorldApplication": "Em controle de drones ou aviões, calcular N no Nyquist garante estabilidade do piloto automático, evitando oscilações destrutivas durante manobras; usado em indústrias aeroespacial e automotiva para compensadores PID robustos."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.1.5.1.1"
                            ]
                          },
                          {
                            "id": "10.1.1.5.1.2.2",
                            "name": "Aplicar o critério para estabilidade",
                            "description": "Verificar se N = -P para garantir ausência de zeros instáveis no semiplano direito (Z=0), confirmando estabilidade absoluta do sistema de malha fechada.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Identificar e contar os polos instáveis da função de malha aberta (P)",
                                  "subSteps": [
                                    "Obtenha a função de transferência de malha aberta G(s)H(s).",
                                    "Encontre todos os polos resolvendo o denominador igual a zero.",
                                    "Determine o parte real de cada polo: conte P como o número de polos com Re(polo) > 0.",
                                    "Liste os polos instáveis explicitamente.",
                                    "Confirme que não há polos no eixo imaginário (jω) para simplificação."
                                  ],
                                  "verification": "Lista completa de polos com indicação clara de quantos têm Re > 0, resultando em valor exato de P.",
                                  "estimatedTime": "10 minutos",
                                  "materials": "Função de transferência G(s)H(s), calculadora simbólica ou software como MATLAB/SymPy.",
                                  "tips": "Use fatoração parcial ou ferramentas computacionais para raízes precisas.",
                                  "learningObjective": "Compreender como polos no semiplano direito afetam a estabilidade em malha aberta.",
                                  "commonMistakes": "Confundir polos com zeros; ignorar multiplicidades de polos."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Construir o diagrama de Nyquist da função de malha aberta",
                                  "subSteps": [
                                    "Calcule G(jω)H(jω) para ω de 0 a ∞ (e -∞ a 0 se necessário).",
                                    "Plote a parte real vs. imaginária em um gráfico polar ou cartesiano.",
                                    "Inclua indentação semicircular ao redor de polos em jω se aplicável.",
                                    "Marque o ponto crítico (-1, 0) no diagrama.",
                                    "Verifique simetria especular sobre o eixo real para ω > 0."
                                  ],
                                  "verification": "Diagrama completo plotado corretamente, passando pelo ponto (1,0) em ω=0 e comportando-se corretamente em ω→∞.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Software de plotagem (MATLAB, Python com control/matplotlib), papel milimetrado.",
                                  "tips": "Comece com frequências logarítmicas para capturar dinâmica.",
                                  "learningObjective": "Dominar a construção do locus de Nyquist para análise de frequência.",
                                  "commonMistakes": "Esquecer a curva para ω negativa; plotar incorretamente a magnitude/fase."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Contar o número de encirclements N do ponto crítico (-1,0)",
                                  "subSteps": [
                                    "Examine o diagrama: conte voltas anti-horárias (N positivo) ou horárias (N negativo) ao redor de (-1,0).",
                                    "Use a regra: uma volta completa anti-horária = +1; horária = -1.",
                                    "Considere indentação em polos jω como meio-encirclement.",
                                    "Anote o valor neto de N.",
                                    "Desenhe setas de direção no diagrama para visualização."
                                  ],
                                  "verification": "Valor numérico de N justificado com contagem explícita e setas no diagrama.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Diagrama de Nyquist impresso ou digital, régua para medir distâncias próximas.",
                                  "tips": "Amplie a região ao redor de -1 para contagens precisas.",
                                  "learningObjective": "Aplicar contagem de encirclements para determinar mudanças na estabilidade.",
                                  "commonMistakes": "Contar apenas voltas completas parciais; confundir direção de rotação."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar o critério de Nyquist e concluir sobre estabilidade",
                                  "subSteps": [
                                    "Calcule Z = P + N, onde Z é o número de zeros instáveis em malha fechada.",
                                    "Verifique se N = -P (equivalente a Z = 0).",
                                    "Se N = -P, conclua estabilidade absoluta; caso contrário, instável.",
                                    "Documente a conclusão com justificativa.",
                                    "Discuta implicações para o projeto do controlador."
                                  ],
                                  "verification": "Equação N = -P resolvida corretamente com conclusão explícita de estabilidade.",
                                  "estimatedTime": "10 minutos",
                                  "materials": "Valores de P e N anotados, relatório escrito.",
                                  "tips": "Lembre-se: N é anti-horário positivo.",
                                  "learningObjective": "Integrar P e N para avaliação final de estabilidade de malha fechada.",
                                  "commonMistakes": "Inverter sinal de N; esquecer que Z deve ser zero para estabilidade."
                                }
                              ],
                              "practicalExample": "Para G(s)H(s) = K / (s(s+1)(s+2)) com K=6, P=0 (todos polos no SPE). Plote Nyquist: mostra 2 encirclements anti-horários (N=2). Como N ≠ -P=0, o sistema é instável. Ajuste K para N=0 e estabilize.",
                              "finalVerifications": [
                                "P contado corretamente dos polos de G(s)H(s).",
                                "Diagrama de Nyquist preciso e completo.",
                                "N contado com direção correta.",
                                "Verificação N = -P realizada.",
                                "Conclusão de estabilidade justificada.",
                                "Ausência de zeros instáveis confirmada (Z=0)."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de P (100% dos polos corretos).",
                                "Qualidade do diagrama de Nyquist (escala, rótulos, simetria).",
                                "Correção na contagem de N (direção e total).",
                                "Aplicação lógica do critério N=-P.",
                                "Conclusão coerente com análise.",
                                "Documentação clara e organizada."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Análise de funções complexas e contorno no plano complexo.",
                                "Programação: Simulação numérica com Python/MATLAB para plotar Nyquist.",
                                "Física: Dinâmica de sistemas mecânicos/elétricos representados por G(s).",
                                "Estatística: Análise de robustez via margens de estabilidade."
                              ],
                              "realWorldApplication": "Em controle de drones, verificar estabilidade de malha fechada para evitar oscilações perigosas durante voo autônomo, garantindo que ajustes no controlador mantenham N=-P para operação segura."
                            },
                            "estimatedTime": "0.5 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.1.5.1.2.1"
                            ]
                          },
                          {
                            "id": "10.1.1.5.1.2.3",
                            "name": "Analisar estabilidade relativa",
                            "description": "Avaliar mudanças na estabilidade ao variar parâmetros como ganho K, observando como o diagrama de Nyquist se move em relação ao ponto (-1/K, 0).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar o Critério de Estabilidade de Nyquist e o Ponto Crítico",
                                  "subSteps": [
                                    "Relembre a definição do diagrama de Nyquist para a função de malha aberta G(s).",
                                    "Identifique o ponto crítico (-1/K, 0) no plano complexo e sua relação com o ganho K.",
                                    "Desenhe manualmente o contorno do plano D para sistemas de tipo 0 e tipo 1.",
                                    "Explique verbalmente como o número de encirclements do ponto crítico determina a estabilidade.",
                                    "Pratique com um exemplo fixo de G(s) = 1/s(s+1) para K=1."
                                  ],
                                  "verification": "Desenhe corretamente o diagrama de Nyquist e localize o ponto (-1,0) sem erros.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e lápis",
                                    "Software MATLAB ou Python (control library)"
                                  ],
                                  "tips": "Sempre normalize o eixo real dividindo por K para visualizar movimentos.",
                                  "learningObjective": "Compreender o fundamento do critério de Nyquist e o impacto do ponto crítico.",
                                  "commonMistakes": [
                                    "Confundir ponto crítico com (-1,0) fixo em vez de (-1/K,0)",
                                    "Ignorar indentação no polo em s=0"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar o Efeito do Ganho K no Diagrama de Nyquist",
                                  "subSteps": [
                                    "Escolha uma função de transferência G(s) estável, ex: G(s) = 1/(s(s+1)(s+2)).",
                                    "Plote o diagrama de Nyquist para K=1 usando software.",
                                    "Aumente K para 2, 5 e 10, re-plotando cada vez e observando a escala.",
                                    "Note como o diagrama se expande radialmente a partir da origem com aumento de K.",
                                    "Registre as distâncias do diagrama ao ponto (-1/K,0) para cada K."
                                  ],
                                  "verification": "Plots mostram expansão correta e distâncias medidas com precisão <5%.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "MATLAB/Simulink ou Python com matplotlib/control",
                                    "Função de transferência exemplo"
                                  ],
                                  "tips": "Use comando nyquist(K*G(s)) para eficiência; foque em frequências baixas e altas.",
                                  "learningObjective": "Visualizar como variações em K movem o diagrama em relação ao ponto móvel.",
                                  "commonMistakes": [
                                    "Plotar sem multiplicar por K",
                                    "Esquecer que o ponto crítico se move para esquerda com K maior"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Avaliar Mudanças na Estabilidade Relativa",
                                  "subSteps": [
                                    "Para cada K, conte o número de encirclements (N) em sentido horário do ponto (-1/K,0).",
                                    "Calcule Z = P + N, onde P é número de polos instáveis de G(s)H(s) (geralmente 0).",
                                    "Classifique: Z=0 → estável; Z>0 → instável.",
                                    "Identifique o valor crítico de K onde o diagrama passa pelo ponto crítico (margem de ganho).",
                                    "Teste K acima e abaixo do crítico, confirmando transição de estabilidade."
                                  ],
                                  "verification": "Tabela com K, N, Z e status de estabilidade correta para 5 valores de K.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Folha de cálculo ou tabela no software",
                                    "Plots anteriores"
                                  ],
                                  "tips": "Amplie a região próxima ao ponto crítico para precisão no encirclement.",
                                  "learningObjective": "Aplicar o critério para determinar faixas de estabilidade em função de K.",
                                  "commonMistakes": [
                                    "Contar encirclements anti-horário como positivo",
                                    "Não considerar o ponto móvel corretamente"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Interpretar Margens de Estabilidade e Concluir Análise",
                                  "subSteps": [
                                    "Meça a distância mínima do diagrama ao ponto crítico para K nominal (margem de fase/ganho).",
                                    "Determine o intervalo de K para estabilidade absoluta (sem encirclement).",
                                    "Discuta estabilidade relativa: robustez a variações de K.",
                                    "Simule resposta no tempo para K estável e instável para validar.",
                                    "Escreva um relatório resumido com conclusões."
                                  ],
                                  "verification": "Relatório identifica corretamente faixa de K estável e margens com simulações validadas.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Software de simulação (step response)",
                                    "Templates de relatório"
                                  ],
                                  "tips": "Use bodeplot para margens complementares; valide Nyquist com root locus.",
                                  "learningObjective": "Integrar análise gráfica com métricas quantitativas de estabilidade relativa.",
                                  "commonMistakes": [
                                    "Confundir estabilidade absoluta com relativa",
                                    "Ignorar efeitos de fase em altas frequências"
                                  ]
                                }
                              ],
                              "practicalExample": "Considere o sistema G(s) = 10 / (s(s+1)(s+10)). Para K=1, o diagrama de Nyquist não encercula (-1,0), estável. Aumentando K=2, aproxima-se mas não encarcela; em K=3, passa pelo ponto e torna instável. Observar o movimento radial e o ponto se movendo para -0.33j0 ilustra perda de estabilidade relativa.",
                              "finalVerifications": [
                                "Pode plotar Nyquist para 3 valores de K e localizar corretamente (-1/K,0).",
                                "Identifica faixa de K para estabilidade (ex: 0 < K < 2.5).",
                                "Conta encirclements corretamente para casos estável/instável.",
                                "Calcula margens de ganho a partir do diagrama.",
                                "Valida análise com simulação de resposta ao degrau.",
                                "Explica verbalmente o movimento relativo do diagrama."
                              ],
                              "assessmentCriteria": [
                                "Precisão nos plots de Nyquist (sem erros de escala ou fase).",
                                "Correta identificação de encirclements e cálculo de Z.",
                                "Análise quantitativa de margens e faixa de K.",
                                "Validação cruzada com simulações no tempo.",
                                "Relatório claro com conclusões sobre estabilidade relativa.",
                                "Demonstração de compreensão conceitual sem erros comuns."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Análise de funções complexas e contornos no plano de Nyquist.",
                                "Física: Dinâmica de sistemas oscilatórios e amortecimento variável.",
                                "Programação: Uso de bibliotecas como control.matlab em Python/MATLAB para automação.",
                                "Estatística: Análise de robustez e variabilidade paramétrica."
                              ],
                              "realWorldApplication": "Em controle de drones, variar K ajusta agressividade do piloto automático; análise de Nyquist previne instabilidade ao mudar ganho para diferentes cargas/pesos, evitando oscilações ou quedas, como em sistemas de estabilização de UAVs da DJI."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.1.5.1.1"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "10.1.1.5.1.3",
                        "name": "Margens de Ganho e Fase",
                        "description": "Medidas quantitativas de robustez derivadas do diagrama de Nyquist, indicando quanto o sistema tolera variações em ganho e fase antes de perder estabilidade.",
                        "specificSkills": [
                          {
                            "id": "10.1.1.5.1.3.1",
                            "name": "Determinar a margem de ganho (GM)",
                            "description": "Medir a distância do ponto de travessia do eixo imaginário até (-1,0) no eixo real; GM = 1 / |G(jω_g)| onde ω_g é a frequência de fase -180°.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar o Diagrama de Nyquist da Função de Loop Aberto",
                                  "subSteps": [
                                    "Obtenha a função de transferência de loop aberto G(s).",
                                    "Plote o diagrama de Nyquist G(jω) variando ω de 0 a ∞, incluindo o semicírculo de Nyquist para pólos no semiplano direito se aplicável.",
                                    "Identifique visualmente os pontos onde a fase arg(G(jω)) atinge -180°.",
                                    "Marque o eixo real e imaginário claramente, destacando o ponto crítico (-1, 0).",
                                    "Use software como MATLAB (nyquist(G)) ou Python (control.nyquist_plot) para precisão."
                                  ],
                                  "verification": "Confirme que o diagrama mostra a curva polar completa e que a fase em diferentes ω está anotada.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Função de transferência G(s), software de controle (MATLAB/Python), papel gráfico.",
                                  "tips": "Sempre inclua frequências logarítmicas para melhor resolução em baixas e altas frequências.",
                                  "learningObjective": "Entender a construção do diagrama de Nyquist como base para análise de estabilidade.",
                                  "commonMistakes": "Esquecer o contorno de Nyquist para sistemas com integradores ou pólos instáveis."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar a Frequência de Fase Crossover ω_g",
                                  "subSteps": [
                                    "Varra o diagrama de Nyquist ao longo da curva para encontrar onde ela cruza o eixo imaginário negativo (fase = -180° ou ±540° etc.).",
                                    "Leia ou calcule a frequência ω correspondente nesse ponto de travessia.",
                                    "Confirme computacionalmente: resolva arg(G(jω)) = -π + 2kπ para k inteiro.",
                                    "Anote ω_g precisamente, geralmente em rad/s.",
                                    "Se múltiplos cruzamentos, selecione o de menor magnitude para análise conservadora."
                                  ],
                                  "verification": "Verifique se em ω_g, a parte imaginária de G(jω_g) é zero e real é negativo.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Diagrama de Nyquist plotado, calculadora ou script para fase.",
                                  "tips": "Use zoom no software para precisão em cruzamentos próximos ao eixo.",
                                  "learningObjective": "Localizar com precisão a frequência onde a fase atinge -180°.",
                                  "commonMistakes": "Confundir com frequência de ganho crossover (onde magnitude=1)."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Determinar a Magnitude |G(jω_g)| no Ponto Crítico",
                                  "subSteps": [
                                    "No ponto de travessia do eixo imaginário em ω_g, meça a distância da origem até esse ponto no plano complexo.",
                                    "Calcule |G(jω_g)| = sqrt{Re(G(jω_g))^2 + Im(G(jω_g))^2}, mas como Im=0, |G| = |Re|.",
                                    "Anote o valor da parte real negativa, ex: se em -0.4, então |G| = 0.4.",
                                    "Valide com fórmula analítica: substitua s=jω_g em G(s) e compute módulo.",
                                    "Compare medição gráfica com cálculo numérico para consistência."
                                  ],
                                  "verification": "A magnitude deve ser menor que 1 para GM >1; confira unidades.",
                                  "estimatedTime": "10 minutos",
                                  "materials": "Régua ou ferramenta de medição no software, função G(s).",
                                  "tips": "Em plots digitais, use data cursor para coordenadas exatas.",
                                  "learningObjective": "Calcular magnitude em frequência específica usando gráfico e análise.",
                                  "commonMistakes": "Usar distância até (-1,0) em vez de até origem."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Calcular e Interpretar a Margem de Ganho GM",
                                  "subSteps": [
                                    "Compute GM = 1 / |G(jω_g)|.",
                                    "Graficamente: GM é a distância do ponto G(jω_g) até (-1,0) dividida pela distância de G(jω_g) à origem (mas fórmula direta é preferida).",
                                    "Interprete: GM > 1 indica ganho extra antes de instabilidade; GM < 0 instável.",
                                    "Registre em dB: 20*log10(GM) para contexto de Bode.",
                                    "Documente se GM é adequado (tipicamente >6dB ou 2x)."
                                  ],
                                  "verification": "Simule aumento de ganho por 1/GM e confirme que passa por -1+j0.",
                                  "estimatedTime": "10 minutos",
                                  "materials": "Calculadora, diagrama anotado.",
                                  "tips": "Sempre expresse GM em valor absoluto e dB para relatórios.",
                                  "learningObjective": "Aplicar fórmula de GM e relacionar com estabilidade via Nyquist.",
                                  "commonMistakes": "Esquecer o módulo (usar parte real diretamente) ou inverter a fórmula."
                                }
                              ],
                              "practicalExample": "Para G(s) = 10 / (s(s+1)(s+5)), o diagrama de Nyquist cruza o eixo real negativo em ω_g ≈ 1.8 rad/s no ponto -0.25 + j0. Assim, |G(jω_g)| = 0.25, GM = 1/0.25 = 4 (12 dB), indicando que o ganho pode ser multiplicado por 4 antes da instabilidade.",
                              "finalVerifications": [
                                "ω_g identificada corretamente com fase exata de -180°.",
                                "|G(jω_g)| calculada com precisão <5% de erro gráfico.",
                                "GM >0 e interpretado quanto à estabilidade.",
                                "Distância gráfica até (-1,0) confirma 1/|G|.",
                                "Validação numérica com software coincide.",
                                "Unidades consistentes (rad/s, sem unidade para GM)."
                              ],
                              "assessmentCriteria": [
                                "Precisão na localização de ω_g (erro <10%).",
                                "Correção no cálculo de magnitude e GM.",
                                "Interpretação qualitativa da estabilidade.",
                                "Uso adequado de ferramentas gráficas/numéricas.",
                                "Documentação clara com anotações.",
                                "Identificação de erros comuns evitados."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Análise de funções complexas e módulo/argumento.",
                                "Física: Modelagem dinâmica de sistemas lineares.",
                                "Programação: Simulações em MATLAB/Python com bibliotecas control/systems.",
                                "Estatística: Análise de robustez e variância em frequências."
                              ],
                              "realWorldApplication": "Em projetos de controladores para drones, onde GM assegura estabilidade de atitude apesar de variações de carga, evitando oscilações destrutivas em voo autônomo."
                            },
                            "estimatedTime": "0.5 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.1.5.1.1"
                            ]
                          },
                          {
                            "id": "10.1.1.5.1.3.2",
                            "name": "Determinar a margem de fase (PM)",
                            "description": "Calcular o ângulo de fase em excesso na frequência de ganho unitário ω_c onde |G(jω_c)|=1; PM = 180° + ∠G(jω_c).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar a Função de Transferência e Diagrama de Bode",
                                  "subSteps": [
                                    "Escreva a função de transferência G(s) no formato padrão.",
                                    "Converta G(s) para G(jω) substituindo s = jω.",
                                    "Calcule ou plote o diagrama de Bode de magnitude |G(jω)| em dB e fase ∠G(jω) em graus.",
                                    "Identifique as frequências de corte dos polos e zeros para aproximar o gráfico.",
                                    "Verifique a magnitude em baixas e altas frequências para validar o gráfico."
                                  ],
                                  "verification": "Confirme que o diagrama de Bode está plotado corretamente comparando com valores assintóticos conhecidos.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Função de transferência G(s), papel milimetrado ou software (MATLAB/Simulink/Python com control library), calculadora científica.",
                                  "tips": "Use aproximações assintóticas para esboçar rapidamente antes de calcular pontos exatos.",
                                  "learningObjective": "Compreender a representação frequência da função de transferência para análise de estabilidade.",
                                  "commonMistakes": "Esquecer de converter para dB na magnitude ou inverter o sinal da fase."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar a Frequência de Cruzamento de Ganho ω_c",
                                  "subSteps": [
                                    "Localize no diagrama de Bode de magnitude o ponto onde |G(jω)| = 1 (0 dB).",
                                    "Se manual, resolva |G(jω)| = 1 iterativamente testando valores de ω.",
                                    "Use interpolação linear no gráfico para maior precisão se necessário.",
                                    "Registre o valor exato de ω_c em rad/s.",
                                    "Confirme interpolando pontos próximos para precisão."
                                  ],
                                  "verification": "Verifique se |G(jω_c)| ≈ 0 dB com cálculo numérico direto.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Diagrama de Bode plotado, calculadora ou software para avaliação numérica.",
                                  "tips": "Comece com uma estimativa grosseira do gráfico assintótico e refine.",
                                  "learningObjective": "Dominar a localização precisa da frequência onde o ganho é unitário.",
                                  "commonMistakes": "Confundir ω_c com frequência de ressonância ou pico de magnitude."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular a Fase na Frequência ω_c",
                                  "subSteps": [
                                    "No diagrama de fase, leia o valor de ∠G(jω_c) no ponto correspondente a ω_c.",
                                    "Calcule analiticamente ∠G(jω) = arg(G(jω)) somando contribuições de cada polo/zero.",
                                    "Use a fórmula tan⁻¹ para cada termo e some os ângulos.",
                                    "Converta para graus se necessário.",
                                    "Valide com cálculo numérico em software."
                                  ],
                                  "verification": "Compare o valor lido do gráfico com cálculo exato; diferença < 2° é aceitável.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Diagrama de Bode de fase, calculadora com funções trigonométricas.",
                                  "tips": "Lembre-se que fase de zero é +tan⁻¹, polo é -tan⁻¹.",
                                  "learningObjective": "Calcular com precisão o ângulo de fase em frequência específica.",
                                  "commonMistakes": "Esquecer o sinal negativo para polos ou não somar todos os termos."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Computar e Interpretar a Margem de Fase PM",
                                  "subSteps": [
                                    "Aplique a fórmula PM = 180° + ∠G(jω_c).",
                                    "Registre o valor numérico da PM em graus.",
                                    "Interprete: PM > 45° indica boa estabilidade relativa; < 0° instável.",
                                    "Compare com margem de ganho se disponível para análise completa.",
                                    "Documente o resultado com gráfico marcado."
                                  ],
                                  "verification": "Confirme que PM está correto recalculando ∠G(jω_c) + 180°.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Valor de ∠G(jω_c), papel para anotações.",
                                  "tips": "Sempre adicione 180° independentemente do sinal da fase.",
                                  "learningObjective": "Aplicar a fórmula de PM e avaliar estabilidade do sistema.",
                                  "commonMistakes": "Subtrair em vez de somar 180° ou confundir com margem de ganho."
                                }
                              ],
                              "practicalExample": "Para G(s) = 10 / (s(s+1)(s+10)), plote Bode: ω_c ≈ 2.3 rad/s onde |G(jω_c)|=1, ∠G(j2.3) ≈ -135°, logo PM = 180° - 135° = 45°. Use MATLAB: bodeplot(G), [mag,phase,w] = bode(G); encontre w onde mag=1.",
                              "finalVerifications": [
                                "ω_c identificada corretamente com |G(jω_c)| = 1 (erro <1%).",
                                "∠G(jω_c) calculado com precisão (erro <2°).",
                                "PM = 180° + ∠G(jω_c) exato.",
                                "Interpretação correta da estabilidade baseada em PM.",
                                "Gráfico de Bode marcado com ω_c e fase.",
                                "Cálculo validado por método alternativo (software/manual)."
                              ],
                              "assessmentCriteria": [
                                "Precisão na localização de ω_c (obrigatório 100%).",
                                "Correção no cálculo de fase (erro máximo 3°).",
                                "Aplicação exata da fórmula PM.",
                                "Interpretação qualitativa adequada (estável/marginal/instável).",
                                "Documentação clara com gráficos e valores numéricos.",
                                "Eficiência no uso de ferramentas (tempo dentro do estimado)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Análise complexa e funções trigonométricas.",
                                "Física: Dinâmica de sistemas oscilatórios e estabilidade.",
                                "Programação: Simulação numérica com MATLAB/Python (biblioteca control).",
                                "Eletrônica: Análise de filtros e amplificadores em frequência."
                              ],
                              "realWorldApplication": "Em controle de drones, PM garante estabilidade contra perturbações de vento; em automação industrial, assegura resposta robusta de motores sem oscilações excessivas."
                            },
                            "estimatedTime": "0.5 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.1.5.1.1"
                            ]
                          },
                          {
                            "id": "10.1.1.5.1.3.3",
                            "name": "Interpretar margens para robustez",
                            "description": "Avaliar se GM > 6 dB e PM > 45° para bom desempenho, relacionando com tolerância a incertezas em ganho e fase em sistemas LIT escalares.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar definições de Margem de Ganho (GM) e Margem de Fase (PM)",
                                  "subSteps": [
                                    "Defina Margem de Ganho (GM) como a quantidade de ganho que pode ser aumentado antes da instabilidade (em dB, no ponto de fase -180° no diagrama de Nyquist).",
                                    "Defina Margem de Fase (PM) como a diferença entre -180° e a fase no ponto de ganho unitário (frequência de cruzamento de ganho).",
                                    "Explique o contexto em sistemas LIT escalares: GM e PM indicam distância da função de malha aberta à instabilidade.",
                                    "Discuta valores típicos: GM > 6 dB e PM > 45° para bom desempenho e robustez.",
                                    "Relacione com diagrama de Bode: GM na frequência onde fase = -180°, PM na ω_gc onde |G(jω)|=1."
                                  ],
                                  "verification": "Resuma definições em um parágrafo e identifique frequências chave em um diagrama exemplo.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Diagrama de Bode/Nyquist exemplo, calculadora ou MATLAB/Simulink para plotar respostas.",
                                  "tips": "Use convenções padrão: GM positiva em dB, PM positiva em graus.",
                                  "learningObjective": "Compreender conceitualmente GM e PM como medidas de estabilidade relativa.",
                                  "commonMistakes": "Confundir GM com PM ou ignorar unidades (dB vs graus)."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Extrair valores de GM e PM de diagramas de frequência",
                                  "subSteps": [
                                    "Identifique a frequência de fase cruzamento (ω_pc) onde arg(G(jω)) = -180° e leia |G(jω_pc)| em dB para GM = -|G(jω_pc)|.",
                                    "Identifique a frequência de ganho cruzamento (ω_gc) onde |G(jω_gc)| = 0 dB e leia arg(G(jω_gc)) para PM = 180° + arg(G(jω_gc)).",
                                    "Plote ou analise diagrama de Bode para um sistema dado (ex: G(s) = K/(s(s+1))).",
                                    "Calcule numericamente usando ferramentas como MATLAB (margin() ou bode()).",
                                    "Registre valores exatos e frequências associadas."
                                  ],
                                  "verification": "Anote GM e PM com suas frequências; compare com simulação.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Software MATLAB/Python (control toolbox), papel quadriculado para plot manual.",
                                  "tips": "Verifique linear vs log scale nos diagramas para evitar erros de leitura.",
                                  "learningObjective": "Extrair quantitativamente GM e PM de representações gráficas.",
                                  "commonMistakes": "Ler magnitude errada no eixo log ou fase no ponto errado."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Avaliar critérios GM > 6 dB e PM > 45° para desempenho",
                                  "subSteps": [
                                    "Compare GM obtido com 6 dB: se >6 dB, sistema tolera aumento de ganho sem instabilidade.",
                                    "Compare PM obtido com 45°: se >45°, bom amortecimento e resposta transitória suave.",
                                    "Classifique o sistema: 'Bom' se ambos critérios atendidos; 'Marginal' se um falha; 'Ruim' se ambos.",
                                    "Analise trade-offs: alto GM pode implicar baixo PM e vice-versa.",
                                    "Simule step response para validar: overshoot <25% para PM>45°."
                                  ],
                                  "verification": "Crie tabela de comparação e classifique o sistema com justificativa.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Simulador (MATLAB step()), tabela de critérios impressa.",
                                  "tips": "Lembre: GM=6dB ≈ fator 2 em ganho, PM=45° ≈ ζ=0.4 (amortecimento razoável).",
                                  "learningObjective": "Aplicar thresholds padrão para julgar qualidade do controle.",
                                  "commonMistakes": "Ignorar que critérios são mínimos; superestimar estabilidade com valores borderline."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Interpretar margens em termos de robustez a incertezas",
                                  "subSteps": [
                                    "Relacione GM com tolerância a variação de ganho: ΔK/K < 1/(10^(GM/20)) para estabilidade.",
                                    "Relacione PM com tolerância a variação de fase: Δφ < PM para manter estabilidade.",
                                    "Considere incertezas em LIT escalares: variações paramétricas afetam ganho/fase.",
                                    "Quantifique: GM=10dB permite ~30% variação em ganho; PM=60° permite delays < PM/ω_gc.",
                                    "Discuta robustez: margens altas = maior tolerância a modelagem erros ou perturbações."
                                  ],
                                  "verification": "Calcule tolerâncias percentuais para um caso e explique impacto em robustez.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Fórmulas de robustez anotadas, exemplo numérico com variações simuladas.",
                                  "tips": "Use aproximações: GM(dB) ≈ 20*log10(1/|G(jω_pc)|).",
                                  "learningObjective": "Conectar margens quantitativamente à robustez prática.",
                                  "commonMistakes": "Confundir tolerância absoluta com relativa ou ignorar dependência em frequência."
                                }
                              ],
                              "practicalExample": "Para um controlador PI em um motor DC com G(s)=1/(s(0.1s+1)), após tuning: GM=8.5 dB (ω_pc=10 rad/s), PM=52° (ω_gc=5 rad/s). Isso permite ±25% variação em ganho do motor e delay de fase até 0.3s sem perda de estabilidade, garantindo robustez em fabricação com tolerâncias.",
                              "finalVerifications": [
                                "Explicar verbalmente como GM>6 dB tolera incertezas de ganho.",
                                "Identificar PM e ω_gc corretamente em um diagrama Bode fornecido.",
                                "Calcular tolerância de ganho a partir de GM=9 dB.",
                                "Classificar robustez de um sistema com GM=4 dB, PM=60°.",
                                "Simular variação de ±10% ganho e confirmar estabilidade.",
                                "Relacionar PM baixa com overshoot alto na resposta ao degrau."
                              ],
                              "assessmentCriteria": [
                                "Precisão na extração de GM/PM (±0.5 dB/grau).",
                                "Correta aplicação de critérios (>6 dB, >45°).",
                                "Quantificação exata de tolerâncias (fórmulas corretas).",
                                "Interpretação qualitativa/quantitativa de robustez.",
                                "Uso adequado de ferramentas/simulações sem erros.",
                                "Clareza em relatórios ou explicações."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Análise complexa e funções de transferência.",
                                "Física: Dinâmica de sistemas mecânicos/elétricos.",
                                "Estatística: Modelagem de incertezas e variância paramétrica.",
                                "Informática: Programação em MATLAB para análise de controle."
                              ],
                              "realWorldApplication": "Em automação industrial, como controle de temperatura em reatores químicos, margens altas garantem operação estável apesar de variações em sensores ou atuadores desgastados, evitando falhas custosas e melhorando segurança."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.1.5.1.3.1",
                              "10.1.1.5.1.3.2"
                            ]
                          },
                          {
                            "id": "10.1.1.5.1.3.4",
                            "name": "Usar MATLAB para plotar e extrair margens",
                            "description": "Implementar nyquist(G) e margin(G) no MATLAB para visualizar diagrama e obter GM, PM e frequências automaticamente, validando cálculos manuais.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Configurar o ambiente MATLAB e definir a função de transferência G(s)",
                                  "subSteps": [
                                    "Abrir o MATLAB e limpar o workspace com 'clear all; clc;'",
                                    "Definir o numerador e denominador da função de transferência, ex: num = 1; den = conv([1 0],[1 1]); den = conv(den,[1 2]);",
                                    "Criar o objeto de sistema de transferência com G = tf(num, den);",
                                    "Verificar a função com pole(G) e zero(G) para confirmar pólos e zeros esperados"
                                  ],
                                  "verification": "Executar G e visualizar a resposta no Command Window sem erros; plotar step(G) para confirmação visual",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "MATLAB R2020a ou superior",
                                    "Função de transferência exemplo: G(s) = 1 / (s(s+1)(s+2))"
                                  ],
                                  "tips": "Sempre use tf() para sistemas contínuos; normalize coeficientes para evitar erros numéricos",
                                  "learningObjective": "Modelar corretamente uma função de transferência linear no MATLAB",
                                  "commonMistakes": [
                                    "Esquecer conv() para multiplicar polinômios",
                                    "Definir den sem [1 ...] leading coefficient 1",
                                    "Confundir tf com zpk"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Plotar o diagrama de Nyquist usando nyquist(G)",
                                  "subSteps": [
                                    "Executar nyquist(G) no Command Window",
                                    "Adicionar grid e labels com grid on; xlabel('Real'); ylabel('Imaginário'); title('Diagrama de Nyquist');",
                                    "Ajustar eixos se necessário com axis([-2 2 -2 2]) para foco na região crítica",
                                    "Analisar visualmente o ponto de passagem pelo eixo imaginário e real negativo"
                                  ],
                                  "verification": "Diagrama plota corretamente com curva assintótica e passagem pelo eixo crítico visível",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Função G definida do Step 1",
                                    "Documentação MATLAB nyquist"
                                  ],
                                  "tips": "Use nyquist(G, w) para frequências específicas se a plotagem for lenta",
                                  "learningObjective": "Visualizar o critério de Nyquist graficamente no MATLAB",
                                  "commonMistakes": [
                                    "Não adicionar grid, dificultando leitura",
                                    "Esquecer de plotar em frequência log para visão completa",
                                    "Ignorar direção da curva (sentido horário/antihorário)"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Extrair margens de ganho e fase com margin(G)",
                                  "subSteps": [
                                    "Executar [Gm, Pm, Wcg, Wcp] = margin(G); no Command Window",
                                    "Exibir valores com fprintf('GM = %.2f, PM = %.2f rad/s, Wcg = %.2f rad/s, Wcp = %.2f rad/s\\n', Gm, Pm*180/pi, Wcg, Wcp);",
                                    "Plotar margens no diagrama de Bode com margin(G) para confirmação gráfica"
                                  ],
                                  "verification": "Valores numéricos exibidos corretamente e coincidem com interseções visuais no Nyquist",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Função G do Step 1",
                                    "Calculadora para converter PM para graus"
                                  ],
                                  "tips": "PM é retornada em graus; use bode(G) para contexto de frequências",
                                  "learningObjective": "Obter automaticamente GM, PM e frequências de cruzamento no MATLAB",
                                  "commonMistakes": [
                                    "Confundir Wcg (ganho) com Wcp (fase)",
                                    "Não converter PM para graus para interpretação",
                                    "Ignorar se Gm ou Pm são Inf (sistema instável)"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Validar resultados MATLAB com cálculos manuais",
                                  "subSteps": [
                                    "Calcular manualmente Wcp: frequência onde fase = -180° via bode plot ou approx",
                                    "Calcular PM = 180° + fase(Wcp); GM = 1 / |G(j Wcg)| onde Wcg é ganho=0dB",
                                    "Comparar valores: diff < 5% indica validação; anotar discrepâncias",
                                    "Interpretar: GM>1 e PM>30° sugere boa estabilidade relativa"
                                  ],
                                  "verification": "Tabela comparativa manual vs MATLAB com concordância >95%; interpretação escrita",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Papel e calculadora ou SymPy/MATLAB symbolic",
                                    "bode(G) plot para medidas manuais"
                                  ],
                                  "tips": "Use rlocus(G) para contexto de estabilidade; valide com stepinfo(G)",
                                  "learningObjective": "Correlacionar análise gráfica/automática com teoria clássica de controle",
                                  "commonMistakes": [
                                    "Erro em approx de fase manual (use tabela de fase)",
                                    "Confundir GM em dB vs linear (use 20log10(GM))",
                                    "Não considerar delays ou não-linearidades"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Documentar e salvar resultados para relatório",
                                  "subSteps": [
                                    "Salvar figura Nyquist com saveas(gcf, 'nyquist_margins.fig')",
                                    "Exportar dados margin para workspace e salvar .mat",
                                    "Criar script completo .m com comentários e rodar para reprodutibilidade",
                                    "Gerar relatório curto: valores, plots e validação em Word/PDF"
                                  ],
                                  "verification": "Script .m executa do zero produzindo mesmos resultados; arquivo salvo acessível",
                                  "estimatedTime": "10 minutos",
                                  "materials": [
                                    "Editor MATLAB para script",
                                    "Visualizador PDF"
                                  ],
                                  "tips": "Use publish('script.m') para HTML automático com plots",
                                  "learningObjective": "Organizar workflow reprodutível em MATLAB para análises de controle",
                                  "commonMistakes": [
                                    "Não comentar código, perdendo rastreabilidade",
                                    "Salvar figs sem resolução alta (use print -dpng)"
                                  ]
                                }
                              ],
                              "practicalExample": "Para G(s) = 1 / (s(s+1)(s+2)), execute nyquist(G) e margin(G). Esperado: GM ≈ 9.5 (19dB), PM ≈ 52°, Wcg ≈ 1.3 rad/s, Wcp ≈ 1.8 rad/s. Valide manualmente encontrando Wcp onde arg(G(jw))=-180° e |G(j Wcg)|=1.",
                              "finalVerifications": [
                                "Diagrama de Nyquist plota corretamente com grid e labels",
                                "Valores GM, PM, Wcg, Wcp extraídos e exibidos numericamente",
                                "Comparação manual-MATLAB mostra concordância <5% erro",
                                "Interpretação correta: sistema estável se encirclement=0 e margens positivas",
                                "Script completo salvo e reproduz resultados identicamente"
                              ],
                              "assessmentCriteria": [
                                "Precisão dos valores extraídos (erro <1%)",
                                "Qualidade visual dos plots (legendas, grid, eixos adequados)",
                                "Correção da validação manual vs automática",
                                "Profundidade da interpretação de estabilidade",
                                "Reprodutibilidade do script MATLAB fornecido"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Análise de funções complexas e integrais de contorno",
                                "Programação: Scripting em MATLAB e manipulação de objetos tf/ss",
                                "Física: Dinâmica de sistemas lineares e resposta em frequência",
                                "Estatística: Análise de sensibilidade de margens a parâmetros",
                                "Engenharia de Software: Boas práticas de documentação de código"
                              ],
                              "realWorldApplication": "Em projetos de controladores para drones ou robótica industrial, usar nyquist/margin no MATLAB valida estabilidade de loops de feedback antes de implementação física, evitando oscilações ou instabilidades em plantas reais como motores DC ou servos."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.1.5.1.1"
                            ]
                          }
                        ]
                      }
                    ]
                  }
                ]
              },
              {
                "id": "10.1.2",
                "name": "Modelos de Incertezas e Robustez em Sistemas LIT",
                "description": "Apresentação de modelos de incertezas, forma padrão e análise de robustez em sistemas de controle lineares invariantes no tempo.",
                "totalSkills": 46,
                "atomicTopics": [
                  {
                    "id": "10.1.2.1",
                    "name": "Modelos de Incertezas em Sistemas LIT",
                    "description": "Classificação e representação de incertezas aditivas, multiplicativas e normais em plantas lineares invariantes no tempo.",
                    "individualConcepts": [
                      {
                        "id": "76.1.1.1",
                        "name": "Incertezas Aditivas em Sistemas LIT",
                        "description": "Classificação e representação matemática de incertezas aditivas, que se somam diretamente à saída ou entrada da planta linear invariante no tempo (LIT), afetando a dinâmica do sistema sem alterar sua estrutura nominal.",
                        "specificSkills": [
                          {
                            "id": "76.1.1.1.1",
                            "name": "Identificar incertezas aditivas em plantas LIT",
                            "description": "Reconhecer e classificar perturbações ou variações paramétricas que se manifestam como termos aditivos na equação diferencial ou função de transferência da planta LIT, diferenciando-as de outros tipos de incertezas.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar fundamentos de plantas LIT e suas representações matemáticas",
                                  "subSteps": [
                                    "Estudar equações diferenciais lineares com coeficientes constantes (EDCs LIT).",
                                    "Aprender a derivar funções de transferência usando transformada de Laplace.",
                                    "Identificar componentes: entrada u(t), saída y(t) e possíveis perturbações d(t).",
                                    "Representar o sistema em diagrama de blocos padrão.",
                                    "Normalizar equações para coeficiente líder unitário."
                                  ],
                                  "verification": "Converter corretamente uma EDC LIT em função de transferência e diagrama de blocos.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Livro-texto de Controle Linear (ex: Ogata)",
                                    "MATLAB ou Python (SymPy para Laplace)",
                                    "Folhas de exercícios de EDCs"
                                  ],
                                  "tips": "Sempre verifique a causalidade e estabilidade inicial do sistema LIT.",
                                  "learningObjective": "Dominar as representações padrão de plantas LIT para identificar inserções de incertezas.",
                                  "commonMistakes": [
                                    "Ignorar condições iniciais nulas",
                                    "Confundir derivadas com integrais na Laplace",
                                    "Não linearizar sistemas não-LIT"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Compreender os tipos principais de incertezas em sistemas LIT",
                                  "subSteps": [
                                    "Classificar incertezas: aditivas, multiplicativas, não-paramétricas e não-estruturadas.",
                                    "Estudar incertezas paramétricas (variações em coeficientes) vs. não-paramétricas (ruídos).",
                                    "Analisar como incertezas afetam EDCs e funções de transferência.",
                                    "Diferenciar perturbações na entrada, saída e estado interno.",
                                    "Revisar exemplos gráficos de normas de incertezas (H-infinito)."
                                  ],
                                  "verification": "Listar e exemplificar 3 tipos de incertezas com suas manifestações matemáticas.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Apostilas de Controle Robusto",
                                    "Vídeos Khan Academy sobre Laplace",
                                    "Software Simulink para simulações"
                                  ],
                                  "tips": "Use diagramas de blocos para visualizar onde a incerteza 'entra' no sistema.",
                                  "learningObjective": "Discernir categorias de incertezas para contextualizar as aditivas.",
                                  "commonMistakes": [
                                    "Confundir aditiva com multiplicativa",
                                    "Ignorar o domínio de frequência",
                                    "Subestimar incertezas não-estruturadas"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar características específicas das incertezas aditivas",
                                  "subSteps": [
                                    "Identificar termos aditivos em EDCs: ex. ÿ + aẏ + by = u + δ(t).",
                                    "Observar na função de transferência: G(s) = G_n(s) + Δ(s), onde Δ é aditiva.",
                                    "Estudar manifestações: perturbações na saída ou aditivas em loops de realimentação.",
                                    "Calcular impacto: |y(jω)| ≈ |G_n(jω)u(jω) + Δ(jω)u(jω)|.",
                                    "Diferenciar de multiplicativas: G(s) = [1 + Δ(s)]G_n(s)."
                                  ],
                                  "verification": "Reescrever uma equação com incerteza aditiva e isolá-la corretamente.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Calculadora simbólica (Wolfram Alpha)",
                                    "Exercícios resolvidos de robustez",
                                    "Gráficos de Bode em MATLAB"
                                  ],
                                  "tips": "Procure termos independentes da saída nominal nas equações.",
                                  "learningObjective": "Reconhecer padrões matemáticos exclusivos de incertezas aditivas.",
                                  "commonMistakes": [
                                    "Interpretar variações paramétricas como aditivas",
                                    "Confundir δ na entrada com saída",
                                    "Não considerar frequência"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Praticar identificação e classificação em exemplos reais",
                                  "subSteps": [
                                    "Resolver 5 exercícios: identificar aditivas em EDCs e G(s) dadas.",
                                    "Simular sistemas com e sem incerteza aditiva no Simulink.",
                                    "Classificar: aditiva vs. outros tipos em plantas industriais.",
                                    "Diferenciar em diagramas: Δ em soma vs. multiplicação.",
                                    "Documentar casos: perturbação de sensor (aditiva na saída)."
                                  ],
                                  "verification": "Classificar corretamente 4/5 exemplos mistos de incertezas.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Banco de exercícios online (ex: Control Tutorials)",
                                    "MATLAB/Simulink licença educacional",
                                    "Planilha de classificação"
                                  ],
                                  "tips": "Teste adicionando/removendo o termo e observe a saída nominal.",
                                  "learningObjective": "Aplicar conhecimento para detectar incertezas aditivas autonomamente.",
                                  "commonMistakes": [
                                    "Classificar ruído multiplicativo como aditivo",
                                    "Ignorar escala da perturbação",
                                    "Não validar via simulação"
                                  ]
                                }
                              ],
                              "practicalExample": "Considere a planta de um motor DC modelada por ÿ + 2ẏ + y = 1.5u + δ(t), onde δ(t) representa variação paramétrica no torque de carga (incerteza aditiva). Na função de transferência: G(s) = 1.5/(s²+2s+1) + Δ(s). Identifique δ como aditiva pois soma diretamente à entrada efetiva, diferentemente de uma multiplicativa que escalaria o ganho nominal.",
                              "finalVerifications": [
                                "Explicar matematicamente como uma incerteza aditiva aparece em G(s).",
                                "Diferenciar aditiva de multiplicativa em um diagrama de blocos.",
                                "Identificar em uma EDC real: qual termo é aditivo?",
                                "Simular e plotar resposta com δ aditiva vs. sem.",
                                "Classificar 3 exemplos industriais corretamente.",
                                "Calcular norma da incerteza aditiva em frequência."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação matemática (90% correto).",
                                "Capacidade de diferenciação de tipos (sem confusões).",
                                "Uso correto de ferramentas de simulação.",
                                "Explicações claras e concisas.",
                                "Aplicação em exemplos não vistos (generalização).",
                                "Análise de impacto na robustez do sistema."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Transformadas de Laplace e equações diferenciais lineares.",
                                "Probabilidade e Estatística: Modelagem de ruídos e perturbações estocásticas.",
                                "Física: Dinâmica de sistemas mecânicos e elétricos com forças externas.",
                                "Informática: Simulação numérica em MATLAB/Python para validação.",
                                "Engenharia Elétrica: Sensores e atuadores com ruídos aditivos."
                              ],
                              "realWorldApplication": "Em controle de aviões não-tripulados (drones), ventos laterais atuam como incertezas aditivas na equação de dinâmica lateral, exigindo identificadores para sintetizar controladores robustos H-infinito que garantam estabilidade apesar de perturbações externas variáveis."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "76.1.1.1.2",
                            "name": "Representar incertezas aditivas na forma padrão",
                            "description": "Modelar incertezas aditivas utilizando a estrutura padrão de robustez, como Δ_add em série ou paralelo com a planta nominal G(s), e expressá-las em termos de funções de transferência ou espaço de estados.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender Conceitos Fundamentais de Incertezas Aditivas",
                                  "subSteps": [
                                    "Defina incerteza aditiva como uma perturbação que se soma diretamente à saída da planta nominal G(s).",
                                    "Diferencie incertezas aditivas de multiplicativas, destacando que aditivas afetam a saída independentemente da entrada.",
                                    "Estude exemplos simples, como ruído de sensor adicionado à medição real.",
                                    "Revise a estrutura padrão de robustez: planta nominal G(s) com Δ_add.",
                                    "Identifique contextos onde incertezas aditivas são comuns, como perturbações externas."
                                  ],
                                  "verification": "Explique verbalmente ou por escrito a diferença entre incertezas aditivas e multiplicativas, com um diagrama simples.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Livro de controle avançado (ex: Zhou, Doyle - Robust and Optimal Control), papel e caneta para diagramas, software MATLAB/Simulink"
                                  ],
                                  "tips": "Use diagramas de bloco para visualizar; comece com exemplos intuitivos como ruído em um termômetro.",
                                  "learningObjective": "Dominar a definição e o papel das incertezas aditivas em sistemas LIT.",
                                  "commonMistakes": [
                                    "Confundir aditiva com multiplicativa",
                                    "Ignorar o impacto na saída vs. ganho",
                                    "Não considerar perturbações externas"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Representar Incerteza Aditiva em Série com a Planta Nominal",
                                  "subSteps": [
                                    "Desenhe o diagrama de bloco: entrada u → G(s) → y_nominal + Δ_add → y_real.",
                                    "Derive a função de transferência total: T(s) = G(s) + Δ_add(s).",
                                    "Especifique Δ_add(s) como uma função de transferência com norma bounded, ex: ||Δ_add||_∞ < 1.",
                                    "Simule numericamente em MATLAB um exemplo com G(s) = 1/(s+1) e Δ_add(s) = 0.1.",
                                    "Analise o impacto na resposta em malha aberta."
                                  ],
                                  "verification": "Gere e plote a resposta em frequência do sistema com e sem Δ_add, confirmando adição na saída.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "MATLAB ou Octave, exemplos de funções de transferência prontas"
                                  ],
                                  "tips": "Sempre normalize Δ_add para facilitar análise de robustez; use bode plot para visualização.",
                                  "learningObjective": "Construir e analisar o modelo de incerteza aditiva em configuração série.",
                                  "commonMistakes": [
                                    "Colocar Δ_add antes de G(s)",
                                    "Esquecer de somar saídas",
                                    "Não boundar a norma de Δ_add"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Representar Incerteza Aditiva em Paralelo com a Planta Nominal",
                                  "subSteps": [
                                    "Desenhe o diagrama: u → G(s) → y_nominal; paralelo: Δ_add → y_add; soma → y_real.",
                                    "Derive T(s) = [G(s) + Δ_add(s)] / [1 + algo se em malha fechada, mas foque aberta].",
                                    "Compare série vs. paralelo: paralelo afeta diretamente como perturbação de entrada.",
                                    "Implemente simulação em Simulink com G(s) = 1/s(s+1) e Δ_add randômico bounded.",
                                    "Calcule ganho máximo de Δ_add para estabilidade."
                                  ],
                                  "verification": "Crie um script MATLAB que plote respostas e confirme que y_real = y_nominal + Δ_add * u.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Simulink, scripts MATLAB de exemplo para sistemas LIT"
                                  ],
                                  "tips": "Pense em paralelo como 'ruído de entrada'; teste com step response.",
                                  "learningObjective": "Modelar incertezas aditivas em configuração paralela e diferenciá-la da série.",
                                  "commonMistakes": [
                                    "Confundir soma de saídas com produto",
                                    "Aplicar norma errada",
                                    "Ignorar dependência da entrada"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Expressar Modelos em Funções de Transferência e Espaço de Estados",
                                  "subSteps": [
                                    "Converta diagrama série para função de transferência: Y(s) = G(s)U(s) + Δ(s)W(s), onde W é perturbação.",
                                    "Para espaço de estados: defina ẋ = Ax + Bu + Δ_add v; y = Cx + Du + e, com Δ_add em matriz.",
                                    "Realize transformação: encontre A_Δ, B_Δ para representação mínima.",
                                    "Simule em espaço de estados usando ss() no MATLAB para ambos casos.",
                                    "Verifique equivalência via simulação de trajetórias."
                                  ],
                                  "verification": "Compare simulações em TF e SS, com erro < 1e-6 em respostas.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "MATLAB Control System Toolbox, notas sobre realizações de estado-espaco"
                                  ],
                                  "tips": "Use tf2ss() e ss2tf() para validação; foque em minimalidade.",
                                  "learningObjective": "Converter representações de incerteza aditiva entre domínios de frequência e tempo.",
                                  "commonMistakes": [
                                    "Erros em dimensões de matrizes",
                                    "Não preservar observabilidade/controlabilidade",
                                    "Ignorar feedthrough"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Integrar e Validar a Representação Completa",
                                  "subSteps": [
                                    "Combine série/paralelo em um modelo unificado com múltiplas Δ_add.",
                                    "Aplique teste de robustez básico: compute μ ou ||T||_∞.",
                                    "Gere relatório com diagramas, equações e simulações.",
                                    "Teste sensibilidade variando parâmetros de Δ_add.",
                                    "Discuta limitações e extensões para não-LIT."
                                  ],
                                  "verification": "Produza um modelo completo que passe em simulação de estabilidade com Δ_add variando.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "MATLAB Robust Control Toolbox (opcional), LaTeX para relatório"
                                  ],
                                  "tips": "Documente tudo; use versionamento em scripts.",
                                  "learningObjective": "Sintetizar representações completas de incertezas aditivas.",
                                  "commonMistakes": [
                                    "Sobrecarregar modelo com muitas Δ",
                                    "Não validar numericamente",
                                    "Esquecer bounds"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um sistema de controle de nível de tanque, a planta nominal G(s) = 1/(10s+1) modela a dinâmica. Incerteza aditiva Δ_add(s) = 0.05/(s/10+1) representa ruído de sensor ou vazamento. Represente em série: y = G u + Δ_add w, simule step response com w=step, e verifique robustez via bode plot.",
                              "finalVerifications": [
                                "Diagrama de bloco correto para série e paralelo.",
                                "Funções de transferência derivadas sem erros algébricos.",
                                "Simulações em MATLAB mostram adição correta na saída.",
                                "Representação em espaço de estados é mínima e equivalente.",
                                "Norma de Δ_add bounded e impacto quantificado.",
                                "Relatório resume modelo com equações e plots."
                              ],
                              "assessmentCriteria": [
                                "Precisão conceitual: definições corretas (30%)",
                                "Correção matemática: derivações e diagramas (25%)",
                                "Implementação prática: simulações funcionais (20%)",
                                "Análise de robustez: bounds e impactos (15%)",
                                "Clareza e documentação: relatórios legíveis (10%)"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Álgebra linear para espaço de estados e normas.",
                                "Probabilidade: Modelagem estocástica de perturbações como ruído gaussiano.",
                                "Física: Dinâmica de sistemas reais com perturbações externas.",
                                "Computação: Programação numérica em MATLAB para simulações."
                              ],
                              "realWorldApplication": "Em automação industrial, como controle de motores em robótica, onde Δ_add modela variações de carga ou ruído, permitindo design de controladores robustos H∞ que mantêm performance apesar de incertezas, evitando falhas em linhas de produção."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "76.1.1.1.3",
                            "name": "Analisar impacto de incertezas aditivas na estabilidade",
                            "description": "Avaliar como incertezas aditivas afetam a estabilidade do laço de controle fechado utilizando critérios como Nyquist ou pequenos ganhos, com exemplos numéricos em plantas LIT escalares.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender incertezas aditivas em sistemas LIT",
                                  "subSteps": [
                                    "Defina incertezas aditivas como perturbações Δ(s) somadas à planta nominal P(s), resultando em P_Δ(s) = P(s) + Δ(s).",
                                    "Revise a estrutura de laço fechado com controlador C(s) e planta perturbada.",
                                    "Estude limites típicos para ||Δ(s)||_∞ em sistemas LIT escalares.",
                                    "Analise como Δ(s) afeta a função de laço aberto L(s) = C(s)P(s).",
                                    "Discuta estabilidade nominal vs. robusta."
                                  ],
                                  "verification": "Explique verbalmente ou por escrito a diferença entre incerteza aditiva e multiplicativa, com diagrama do laço fechado.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Livro de controle avançado (ex: Zhou, Doyle), MATLAB/Simulink para diagramas"
                                  ],
                                  "tips": "Use diagramas de bloco para visualizar adição de Δ(s); foque em representação em frequência.",
                                  "learningObjective": "Identificar e modelar incertezas aditivas em plantas LIT escalares.",
                                  "commonMistakes": [
                                    "Confundir aditiva com multiplicativa",
                                    "Ignorar norma ∞ para limites de incerteza"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Aplicar critério de Nyquist para estabilidade com incertezas",
                                  "subSteps": [
                                    "Lembre o teorema de Nyquist: número de encirclements de -1 para estabilidade.",
                                    "Analise diagrama de Nyquist de L(jω) = C(jω)P(jω) e região crítica expandida por Δ.",
                                    "Determine margem de estabilidade: distância mínima de L(jω) a -1 deve exceder sup||Δ(jω)||.",
                                    "Calcule ganho de sensibilidade S(jω) = 1/(1 + L(jω)) e relacione com robustez.",
                                    "Verifique condição: ||T(jω) Δ(jω)||_∞ < 1 para estabilidade robusta, onde T é função de complemento."
                                  ],
                                  "verification": "Desenhe Nyquist de L(jω) e marque região de incerteza; confirme se evita -1.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Software MATLAB para plot Nyquist (nyquist() e sigma()), exemplos de Zhou ch.10"
                                  ],
                                  "tips": "Plote |T(jω)| e compare com envelope de incerteza; use log scale para ω.",
                                  "learningObjective": "Avaliar estabilidade robusta via Nyquist considerando incertezas aditivas.",
                                  "commonMistakes": [
                                    "Esquecer de analisar toda faixa de frequência",
                                    "Confundir T(s) com S(s)"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Utilizar critério de pequenos ganhos para análise de robustez",
                                  "subSteps": [
                                    "Defina teorema de pequenos ganhos: sistema estável se ||Δ M||_∞ < 1, onde M é função multiplicativa.",
                                    "Para incertezas aditivas, derive M(s) = P(s)/(1 + C(s)P(s)) ≈ P(s) para baixos ganhos.",
                                    "Calcule norma H∞ de M(jω) e compare com ||Δ||_∞.",
                                    "Implemente em MATLAB: sys = tf(...); norm = hinfnorm(sys).",
                                    "Interprete: se norma < 1/||Δ||_∞, estável."
                                  ],
                                  "verification": "Compute ||M||_∞ para controlador PID em planta nominal e verifique contra Δ_max.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "MATLAB Robust Control Toolbox (hinfnorm, usample), notas de aula sobre μ-síntese"
                                  ],
                                  "tips": "Aproxime para plantas de primeiro ordem; valide com simulações de passo.",
                                  "learningObjective": "Aplicar pequenos ganhos para quantificar impacto de incertezas aditivas na estabilidade.",
                                  "commonMistakes": [
                                    "Usar norma L2 em vez de H∞",
                                    "Negligenciar fase em pequenos ganhos"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Realizar análise numérica com exemplo prático",
                                  "subSteps": [
                                    "Escolha planta LIT escalar: P(s) = 1/(s+1), C(s) = 1 (laço unitário).",
                                    "Defina Δ(s) = 0.2/(s+0.5), ||Δ||_∞ ≈ 0.3.",
                                    "Plote Nyquist de L(jω) e verifique encirclements com Δ.",
                                    "Calcule ||T Δ||_∞ e confirme estabilidade; perturbe e reanalise.",
                                    "Simule respostas ao degrau para nominal e perturbado."
                                  ],
                                  "verification": "Gere relatório com plots Nyquist, normas H∞ e simulações; estabilidade preservada?",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "MATLAB script completo para o exemplo, simulador Simulink"
                                  ],
                                  "tips": "Salve scripts reutilizáveis; teste com Δ maior para instabilidade.",
                                  "learningObjective": "Executar análise numérica completa de impacto de incertezas aditivas.",
                                  "commonMistakes": [
                                    "Escolha planta instável nominal",
                                    "Ignorar simulações temporais"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um controlador de velocidade de motor DC, P(s) = K/(Js + B), incerteza aditiva Δ(s) modela variação de atrito B ±20%. Usando Nyquist, verifique se laço com PID permanece estável: compute ||T Δ||_∞ <1, simulando respostas com B nominal e perturbado.",
                              "finalVerifications": [
                                "Explicar verbalmente como incertezas aditivas expandem região crítica no plano Nyquist.",
                                "Calcular corretamente ||M||_∞ para um sistema dado e concluir sobre robustez.",
                                "Identificar instabilidade em simulação quando ||Δ||_∞ excede limite.",
                                "Plotar Nyquist com envelope de incerteza sem erros.",
                                "Relacionar margens de ganho/fase com robustez aditiva.",
                                "Discutir limitações do critério de pequenos ganhos."
                              ],
                              "assessmentCriteria": [
                                "Precisão nos cálculos de normas H∞ (erro <5%).",
                                "Interpretação correta de plots Nyquist e estabilidade robusta.",
                                "Qualidade das simulações numéricas e análise de resultados.",
                                "Cobertura completa de subpassos em relatórios.",
                                "Identificação precisa de erros comuns e soluções.",
                                "Conexões claras entre teoria e exemplo prático."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Análise complexa e normas em espaços de Hardy (H∞).",
                                "Probabilidade: Modelagem estocástica de incertezas como ruído aditivo.",
                                "Engenharia Mecânica: Controle de vibrações com perturbações paramétricas.",
                                "Processos Industriais: Robustez em PLCs para plantas químicas.",
                                "Física: Dinâmica linear com forças perturbadoras aditivas."
                              ],
                              "realWorldApplication": "Em aviões autônomos (drones), incertezas aditivas no modelo aerodinâmico devido a vento; análise Nyquist garante estabilidade do piloto automático, evitando oscilações ou perda de controle em voo real."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "76.1.1.2",
                        "name": "Incertezas Multiplicativas em Sistemas LIT",
                        "description": "Classificação e representação de incertezas multiplicativas, que modulam a planta nominal por um fator perturbador, representando variações paramétricas ou não modeladas multiplicativas em sistemas LIT.",
                        "specificSkills": [
                          {
                            "id": "76.1.1.2.1",
                            "name": "Classificar incertezas multiplicativas em plantas LIT",
                            "description": "Diferenciar incertezas multiplicativas de entrada (ΔI) e de saída (ΔO), identificando cenários reais como variações de ganho ou atrasos não modelados em funções de transferência LIT.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar fundamentos de plantas LIT e incertezas",
                                  "subSteps": [
                                    "Estude a definição de sistemas Lineares Invariantes no Tempo (LIT) e funções de transferência de plantas.",
                                    "Identifique fontes comuns de incertezas em modelagem: parâmetros nominais vs. reais.",
                                    "Revise representação nominal de plantas P(s) e introduza noção de incerteza relativa.",
                                    "Analise exemplos simples de funções de transferência de primeira e segunda ordem.",
                                    "Discuta impacto de incertezas na estabilidade e desempenho de laços de controle."
                                  ],
                                  "verification": "Explique verbalmente ou por escrito a diferença entre modelo nominal e real de uma planta LIT.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Livro de controle LIT (ex: Ogata)",
                                    "Software MATLAB/Simulink",
                                    "Notas de aula sobre funções de transferência"
                                  ],
                                  "tips": "Comece com plantas simples para fixar conceitos antes de complexidades.",
                                  "learningObjective": "Compreender o papel das incertezas em sistemas LIT e sua representação básica.",
                                  "commonMistakes": [
                                    "Confundir incertezas aditivas com multiplicativas",
                                    "Ignorar a invariância no tempo em exemplos"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Entender representação de incertezas multiplicativas",
                                  "subSteps": [
                                    "Defina incerteza multiplicativa como perturbação relativa: P(s) = P₀(s) (1 + Δ(s)).",
                                    "Estude a norma da incerteza Δ(s), tipicamente |Δ(jω)| ≤ 1 para robustez.",
                                    "Represente graficamente em diagrama de Bode o envelope de incerteza.",
                                    "Compare com incertezas aditivas: Δ_add(s) vs. multiplicativas.",
                                    "Simule em software uma planta com incerteza multiplicativa genérica."
                                  ],
                                  "verification": "Desenhe o diagrama de bloco de uma planta com incerteza multiplicativa e calcule ganho relativo em ω específica.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "MATLAB para simulações Bode",
                                    "Folhas de papel para diagramas",
                                    "Tutorial de robustez em controle"
                                  ],
                                  "tips": "Use log-log para visualizar envelopes de incerteza claramente.",
                                  "learningObjective": "Dominar a modelagem matemática de incertezas multiplicativas em plantas LIT.",
                                  "commonMistakes": [
                                    "Usar soma em vez de produto para perturbações relativas",
                                    "Esquecer a dependência em frequência"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Diferenciar incertezas multiplicativas de entrada (ΔI) e saída (ΔO)",
                                  "subSteps": [
                                    "Defina ΔI: perturbação no sinal de entrada, P_eff = P₀ (1 + ΔI), ex: variação de atuador.",
                                    "Defina ΔO: perturbação no sinal de saída, P_eff = (1 + ΔO) P₀, ex: sensor impreciso.",
                                    "Compare impactos em diagramas de laço fechado: posição relativa à planta.",
                                    "Derive equações para respostas em frequência com cada tipo.",
                                    "Simule ambos em um exemplo unificado, como um servomotor."
                                  ],
                                  "verification": "Classifique ΔI vs. ΔO em 3 diagramas de bloco fornecidos e justifique.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Simulink para modelagem de laços",
                                    "Exemplos de plantas industriais",
                                    "Calculadora simbólica (ex: SymPy)"
                                  ],
                                  "tips": "Lembre: ΔI afeta antes da dinâmica da planta, ΔO depois.",
                                  "learningObjective": "Distinguir precisamente ΔI e ΔO e suas representações.",
                                  "commonMistakes": [
                                    "Inverter a posição de ΔI e ΔO no diagrama",
                                    "Confundir com incertezas paramétricas fixas"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Identificar e classificar cenários reais",
                                  "subSteps": [
                                    "Liste cenários: variação de ganho (ΔI), atraso não modelado (aprox. ΔO alta freq.).",
                                    "Analise planta real: motor DC com variação K (ganho) como ΔI.",
                                    "Classifique 5 cenários comuns: desgaste mecânico, temperatura afetando parâmetros.",
                                    "Aplique em função de transferência: ajuste Δ para matching modelo real.",
                                    "Valide com simulação: compare step response nominal vs. incerto."
                                  ],
                                  "verification": "Classifique corretamente 4 cenários reais como ΔI ou ΔO com justificativa.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Dados experimentais de plantas",
                                    "MATLAB System Identification Toolbox",
                                    "Artigos sobre robustez"
                                  ],
                                  "tips": "Atrasos são tipicamente ΔO em altas frequências devido a phase lag.",
                                  "learningObjective": "Aplicar classificação em contextos práticos de engenharia.",
                                  "commonMistakes": [
                                    "Classificar variação de ganho como aditiva",
                                    "Ignorar efeitos dinâmicos em atrasos"
                                  ]
                                }
                              ],
                              "practicalExample": "Considere uma planta de posição de motor DC com P₀(s) = K/(s(Js+B)). Variação de 20% no ganho K devido a bateria fraca é modelada como ΔI (input): P(s) = P₀(s)(1 + 0.2 e^{jφ}). Simule em Simulink o step response nominal vs. incerto e observe overshoot alterado.",
                              "finalVerifications": [
                                "Classificar corretamente ΔI vs. ΔO em 5 diagramas de bloco.",
                                "Derivar P_eff para cenários dados.",
                                "Plotar envelope de Bode para incerteza especificada.",
                                "Identificar 3 cenários reais como multiplicativos.",
                                "Simular e comparar respostas com/atraso não modelado.",
                                "Explicar impacto na margem de robustez."
                              ],
                              "assessmentCriteria": [
                                "Precisão na diferenciação ΔI/ΔO (90%+ acerto).",
                                "Correção matemática das representações (sem erros algébricos).",
                                "Qualidade de simulações e plots (legíveis e precisos).",
                                "Justificativas lógicas para classificações reais.",
                                "Compreensão de impactos em controle (estabilidade/desempenho).",
                                "Criatividade em exemplos adicionais."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Análise complexa e funções de transferência.",
                                "Física: Dinâmica de sistemas mecânicos/elétricos.",
                                "Probabilidade: Modelagem estocástica de incertezas.",
                                "Informática: Simulação numérica em MATLAB/Python.",
                                "Engenharia de Processos: Robustez em indústrias."
                              ],
                              "realWorldApplication": "Em automação industrial, como controle de velocidade de rolos em siderúrgicas, variações de ganho por desgaste (ΔI) são classificadas para projetar controladores robustos H∞, garantindo operação segura apesar de incertezas."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "76.1.1.2.2",
                            "name": "Modelar incertezas multiplicativas matematicamente",
                            "description": "Construir representações como G(s)(I + W_I(s)Δ_I(s)) para incertezas de entrada ou (I + Δ_O(s)W_O(s))G(s) para saída, utilizando pesos W para normalização em análise de robustez.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender incertezas multiplicativas em sistemas LIT",
                                  "subSteps": [
                                    "Definir incerteza multiplicativa como uma perturbação relativa que multiplica a saída ou entrada do sistema nominal G(s).",
                                    "Comparar com incertezas aditivas, destacando que multiplicativas são proporcionais ao sinal.",
                                    "Estudar exemplos iniciais, como variação de ganho em amplificadores ou parâmetros em plantas industriais.",
                                    "Visualizar graficamente o diagrama de bloco para incerteza na entrada e saída.",
                                    "Explicar o papel das matrizes Δ(s) com norma ≤1."
                                  ],
                                  "verification": "Explicar verbalmente ou por escrito a diferença entre incertezas multiplicativas e aditivas, com um diagrama simples.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Livro de Controle Robusto (ex: Zhou, Doyle)",
                                    "Software MATLAB/Simulink ou Python (biblioteca control)",
                                    "Notas de aula sobre sistemas LIT"
                                  ],
                                  "tips": "Use diagramas de bloco para visualizar; comece com sistemas SISO antes de MIMO.",
                                  "learningObjective": "Dominar os fundamentos conceituais de incertezas multiplicativas e sua representação em sistemas lineares invariantes no tempo.",
                                  "commonMistakes": [
                                    "Confundir com incertezas aditivas",
                                    "Ignorar a proporcionalidade relativa",
                                    "Esquecer que Δ(s) é normada"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Modelar incertezas multiplicativas na entrada",
                                  "subSteps": [
                                    "Partir do sistema nominal G(s) e inserir perturbação Δ_I(s) após a entrada.",
                                    "Derivar a estrutura G(s)(I + W_I(s)Δ_I(s)), onde W_I(s) normaliza a incerteza.",
                                    "Escolher W_I(s) baseado na magnitude máxima esperada de Δ_I(s).",
                                    "Implementar em diagrama de bloco e função de transferência.",
                                    "Simular um caso simples com Δ_I(s) constante."
                                  ],
                                  "verification": "Construir e simular o diagrama no MATLAB/Python, confirmando que a saída varia proporcionalmente à entrada nominal.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "MATLAB com toolbox Control System",
                                    "Python com libraries control e matplotlib",
                                    "Papel e lápis para derivações"
                                  ],
                                  "tips": "Verifique unidades e consistência dimensional em W_I(s); teste com ||Δ_I||_∞ =1.",
                                  "learningObjective": "Construir matematicamente o modelo de incerteza multiplicativa na entrada com normalização.",
                                  "commonMistakes": [
                                    "Colocar Δ_I antes de W_I",
                                    "Usar soma em vez de multiplicação",
                                    "Escolher W_I incorreto"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Modelar incertezas multiplicativas na saída",
                                  "subSteps": [
                                    "Inserir perturbação Δ_O(s) antes da saída do sistema nominal.",
                                    "Derivar (I + Δ_O(s)W_O(s))G(s), explicando a ordem da multiplicação.",
                                    "Selecionar W_O(s) para capturar o envelope de incerteza na saída.",
                                    "Comparar estruturas de entrada e saída via diagramas.",
                                    "Simular resposta em frequência para validar."
                                  ],
                                  "verification": "Gerar gráficos de Bode para nominal e com incerteza, mostrando variação relativa.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "MATLAB/Simulink",
                                    "Python (control, numpy)",
                                    "Templates de scripts para análise de robustez"
                                  ],
                                  "tips": "Lembre-se: incerteza de saída afeta medições; use nyquist para visualização.",
                                  "learningObjective": "Dominar a representação de incertezas na saída e sua diferença com a de entrada.",
                                  "commonMistakes": [
                                    "Inverter ordem Δ_O e W_O",
                                    "Confundir entrada/saída",
                                    "Não normalizar corretamente"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Integrar pesos de normalização e validar o modelo completo",
                                  "subSteps": [
                                    "Combinar modelos de entrada e saída em um framework unificado.",
                                    "Ajustar pesos W_I e W_O com base em dados experimentais ou bounds conhecidos.",
                                    "Verificar condições de robustez iniciais (ex: ||Δ|| ≤1 implica estabilidade).",
                                    "Implementar simulação completa com variação de parâmetros.",
                                    "Documentar o modelo final com equações e plots."
                                  ],
                                  "verification": "Produzir relatório com derivações, simulações e confirmação de que o modelo captura ±20% de variação.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Software de simulação",
                                    "Dados de planta real (ex: motor DC)",
                                    "Referências H∞ control"
                                  ],
                                  "tips": "Use mu-toolbox no MATLAB para checar; itere pesos até encaixar dados.",
                                  "learningObjective": "Construir e validar modelos completos de incerteza para análise de robustez.",
                                  "commonMistakes": [
                                    "Pesos muito amplos ou estreitos",
                                    "Ignorar fase em W(s)",
                                    "Não validar com simulação"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um servo-motor DC com função de transferência nominal G(s) = 1/(s(s+1)), há variação de 20% no ganho de entrada devido a temperatura. Modele como G(s)(I + 0.2 Δ_I(s)), com Δ_I(s)=1 (pior caso), e simule a resposta ao degrau mostrando oscilação extra.",
                              "finalVerifications": [
                                "Derivação correta das fórmulas para entrada e saída.",
                                "Seleção adequada de W_I(s) e W_O(s) baseada em bounds.",
                                "Simulações mostram variação relativa esperada.",
                                "Diagramas de bloco precisos e legíveis.",
                                "Explicação clara do papel na análise de robustez.",
                                "Validação com pelo menos um exemplo numérico."
                              ],
                              "assessmentCriteria": [
                                "Precisão matemática nas derivações (100% corretas).",
                                "Adequação dos pesos de normalização (erro <10%).",
                                "Qualidade das simulações e visualizações.",
                                "Compreensão conceitual demonstrada em explicações.",
                                "Identificação de erros comuns e avoidance.",
                                "Integração coerente de entrada e saída."
                              ],
                              "crossCurricularConnections": [
                                "Probabilidade e Estatística: Modelagem de Δ(s) como processos estocásticos normados.",
                                "Análise de Sistemas Dinâmicos: Diagrama de blocos e funções de transferência.",
                                "Otimização: Seleção de pesos via minimização de erro H∞.",
                                "Programação Numérica: Simulações em MATLAB/Python.",
                                "Física Aplicada: Modelagem de plantas reais com variações paramétricas."
                              ],
                              "realWorldApplication": "Na indústria aeroespacial, modela variações em coeficientes aerodinâmicos de asas (incertezas multiplicativas na saída) para projetar controladores robustos em flight control systems, garantindo estabilidade apesar de turbulências ou desgaste."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "76.1.1.2.3",
                            "name": "Verificar robustez frente a incertezas multiplicativas",
                            "description": "Aplicar o teorema de pequenos ganhos para verificar estabilidade robusta de sistemas LIT com incertezas multiplicativas norm-bounded, plotando diagramas de Bode com pesos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Modelar o sistema nominal e definir incertezas multiplicativas",
                                  "subSteps": [
                                    "Identifique a função de transferência nominal G(s) do sistema LIT.",
                                    "Defina o modelo de incerteza multiplicativa: G(s) = G0(s) (I + W(s) Δ(s)), onde ||Δ||_∞ ≤ 1.",
                                    "Especifique o peso W(s) que delimita a incerteza norm-bounded.",
                                    "Verifique se o sistema é bem-posto e estável nominalmente.",
                                    "Documente as equações em formato LaTeX ou simbólico."
                                  ],
                                  "verification": "Confirme que o modelo matemático está corretamente escrito e G0(s) é estável.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Função de transferência do sistema",
                                    "Software de controle (MATLAB/Simulink ou Python Control Systems Library)",
                                    "Papel e lápis para esboços"
                                  ],
                                  "tips": "Comece com um sistema de ordem baixa para validação inicial.",
                                  "learningObjective": "Compreender a representação de incertezas multiplicativas em sistemas LIT.",
                                  "commonMistakes": [
                                    "Confundir incerteza aditiva com multiplicativa",
                                    "Esquecer de normalizar ||Δ||_∞ ≤ 1",
                                    "Não verificar estabilidade nominal"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Derivar a função de transferência para análise de robustez",
                                  "subSteps": [
                                    "Calcule a função de sensibilidade complementar T(s) = G(s) K(s) / (1 + G(s) K(s)) para loop unitário feedback.",
                                    "Forme a função de robustez M(s) = T(s) W(s), conforme teorema de pequenos ganhos.",
                                    "Confirme que a condição de robustez é ||M(jω)||_∞ < 1 para todo ω.",
                                    "Implemente a derivação simbólica ou numérica.",
                                    "Valide com valores DC e de alta frequência."
                                  ],
                                  "verification": "Verifique analiticamente ou numericamente que M(s) está corretamente derivada.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "MATLAB com toolbox Control System",
                                    "Documentação do teorema de pequenos ganhos",
                                    "Calculadora simbólica (SymPy)"
                                  ],
                                  "tips": "Use feedback() no MATLAB para T(s); multiplique por W(s) depois.",
                                  "learningObjective": "Aplicar o teorema de pequenos ganhos para estabilidade robusta.",
                                  "commonMistakes": [
                                    "Usar sensibilidade S(s) em vez de T(s)",
                                    "Esquecer o peso W(s) na multiplicação",
                                    "Ignorar norma H-infinito"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Plotar diagramas de Bode com pesos e analisar margens",
                                  "subSteps": [
                                    "Gere diagramas de Bode para G0(jω), W(jω), e M(jω) = T(jω) W(jω).",
                                    "Plote magnitude e fase em escalas logarítmicas adequadas.",
                                    "Identifique o ganho máximo de ||M||_∞ e compare com 1 (0 dB).",
                                    "Adicione anotações para picos e cruzamentos.",
                                    "Exporte os plots com legendas claras."
                                  ],
                                  "verification": "Os plots mostram ||M||_∞ < 1 se todas as curvas de magnitude de M ficam abaixo de 0 dB.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "MATLAB bode() ou Python bode_plot()",
                                    "Templates de plotting padronizados"
                                  ],
                                  "tips": "Use grid e zoom em regiões críticas de frequência.",
                                  "learningObjective": "Interpretar diagramas de Bode para análise de robustez.",
                                  "commonMistakes": [
                                    "Plotar apenas magnitude sem fase",
                                    "Escala errada (linear em vez de log)",
                                    "Não incluir W(s) no plot"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificar e concluir sobre a robustez do sistema",
                                  "subSteps": [
                                    "Calcule numericamente ||M||_∞ usando norm() ou max() sobre frequências.",
                                    "Se ||M||_∞ < 1, conclua estabilidade robusta; caso contrário, sugira ajustes em W(s) ou controlador.",
                                    "Teste sensibilidade variando Δ(s) em simulações.",
                                    "Gere relatório com plots e métricas.",
                                    "Discuta implicações para design."
                                  ],
                                  "verification": "Relatório confirma ||M||_∞ < 1 com evidência numérica e gráfica.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Script de simulação completo",
                                    "Relatório template"
                                  ],
                                  "tips": "Use linspace para grid de frequências denso em norm H-infinito.",
                                  "learningObjective": "Concluir análise de robustez e propor melhorias.",
                                  "commonMistakes": [
                                    "Aceitar ||M||_∞ ≈1 como robusto",
                                    "Não testar com Δ real",
                                    "Ignorar wrap-around em fase"
                                  ]
                                }
                              ],
                              "practicalExample": "Considere um sistema de controle de velocidade de motor DC com G0(s) = 1/(s+1), controlador proporcional K=2, e incerteza multiplicativa W(s)=0.2 para variações de 20% no ganho. Derive M(s)=T(s)W(s), plote Bode e verifique ||M||_∞ ≈0.15 <1, confirmando robustez.",
                              "finalVerifications": [
                                "||M(jω)||_∞ < 1 calculado numericamente.",
                                "Diagramas de Bode mostram magnitude de M abaixo de 0 dB em todas as frequências.",
                                "Sistema nominal é estável.",
                                "Peso W(s) captura adequadamente as incertezas esperadas.",
                                "Simulação com Δ(s)=1 não destrói estabilidade.",
                                "Relatório inclui todos os plots e equações."
                              ],
                              "assessmentCriteria": [
                                "Precisão na derivação de M(s) (100% correta).",
                                "Qualidade e legibilidade dos diagramas de Bode (anotações completas).",
                                "Correta aplicação do teorema de pequenos ganhos.",
                                "Análise quantitativa de ||M||_∞ com erro <5%.",
                                "Identificação de erros comuns evitados.",
                                "Relatório claro e estruturado."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Análise de funções complexas e normas H-infinito.",
                                "Programação: Uso de bibliotecas numéricas (MATLAB/Python) para análise de sistemas.",
                                "Física: Modelagem de dinâmicas reais com perturbações.",
                                "Estatística: Modelagem de incertezas probabilísticas via normas.",
                                "Design de Engenharia: Integração em ciclos de controle robusto."
                              ],
                              "realWorldApplication": "Em aviões não tripulados (drones), verifica-se robustez de controladores de atitude frente a variações aerodinâmicas (incertezas multiplicativas), garantindo estabilidade em ventos variáveis via small gain theorem e Bode plots."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "76.1.1.2.4",
                            "name": "Simular efeitos de incertezas multiplicativas",
                            "description": "Implementar simulações em MATLAB para plantas LIT com incertezas multiplicativas, analisando respostas no tempo e frequência sob variações extremas.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Definir e implementar o modelo nominal da planta LIT em MATLAB",
                                  "subSteps": [
                                    "Identifique a função de transferência nominal da planta LIT a partir do contexto do problema (ex: P0(s) = 1/(s^2 + 2s + 1))",
                                    "Abra o MATLAB e use a toolbox Control System para criar o modelo com a função tf(num, den)",
                                    "Valide o modelo plotando a resposta ao degrau (step(P0)) e o diagrama de Bode (bode(P0))",
                                    "Salve o modelo em uma variável workspace para reutilização",
                                    "Documente os parâmetros do modelo com comentários no script"
                                  ],
                                  "verification": "A resposta ao degrau e Bode do modelo nominal correspondem às expectativas teóricas sem erros de simulação",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "MATLAB com Control System Toolbox",
                                    "Documentação de funções tf, step, bode"
                                  ],
                                  "tips": "Sempre normalize os coeficientes da função de transferência para evitar problemas numéricos",
                                  "learningObjective": "Construir e validar modelos LIT precisos em MATLAB",
                                  "commonMistakes": [
                                    "Esquecer de especificar o tempo de simulação no step()",
                                    "Confundir numerador e denominador em tf()"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Modelar incertezas multiplicativas no sistema",
                                  "subSteps": [
                                    "Defina a estrutura de incerteza multiplicativa: P(s) = P0(s) * (1 + w(s) * Δ(s)), onde ||Δ||∞ ≤ 1",
                                    "Crie o peso w(s) representando a magnitude da incerteza (ex: w(s) = 0.2 para 20% de variação)",
                                    "Gere matrizes Δ aleatórias com norma infinita ≤1 usando funções randn e normalização",
                                    "Implemente uma função para calcular P_pert(s) = P0(s) * (1 + w(s)*Δ(s))",
                                    "Teste com um Δ fixo extremo (ex: Δ=1) e plote Bode de P_pert vs P0"
                                  ],
                                  "verification": "Gráficos de Bode mostram desvios corretos entre P0 e P_pert para Δ=1",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "MATLAB scripts personalizados",
                                    "Funções norm, randn para geração de Δ"
                                  ],
                                  "tips": "Use loop para gerar múltiplas Δ e visualizar ensemble de modelos",
                                  "learningObjective": "Representar matematicamente e implementar incertezas multiplicativas",
                                  "commonMistakes": [
                                    "Não normalizar Δ para ||Δ||∞=1",
                                    "Multiplicar incorretamente P0 e perturbação"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar simulações com variações extremas",
                                  "subSteps": [
                                    "Configure um loop Monte Carlo para gerar 100-500 realizações de Δ extremas",
                                    "Simule respostas no tempo: step e impulse para cada P_pert em conjunto com entrada de referência",
                                    "Inclua variações extremas fixas (ex: Δ max em baixas e altas frequências)",
                                    "Armazene respostas em arrays para análise estatística (média, desvios, envelopes)",
                                    "Plote ensembles de respostas no tempo com limites de confiança"
                                  ],
                                  "verification": "Simulações rodam sem crashes e envelopes capturam 95% das trajetórias",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Scripts MATLAB com loops for/parfor",
                                    "Funções step, lsim para simulação"
                                  ],
                                  "tips": "Use parfor para acelerar simulações com muitas realizações",
                                  "learningObjective": "Executar simulações probabilísticas de incertezas extremas",
                                  "commonMistakes": [
                                    "Tempo de simulação insuficiente para transientes",
                                    "Não seedar rand para reprodutibilidade"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar respostas no tempo e frequência sob incertezas",
                                  "subSteps": [
                                    "Gere diagramas de Bode para ensemble de P_pert e compare com P0",
                                    "Calcule métricas: overshoot médio/max, tempo de estabilização, margens de ganho/fase",
                                    "Plote respostas no tempo com bandas de incerteza (média ± 2 desvios)",
                                    "Identifique frequências críticas onde incertezas amplificam desvios",
                                    "Gere relatório com figuras e conclusões sobre robustez"
                                  ],
                                  "verification": "Análises mostram impactos claros das incertezas (ex: pior overshoot +50%)",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Funções bodeplot, stepinfo, boundplot no MATLAB"
                                  ],
                                  "tips": "Use usaplot para upper/lower bounds em ensembles",
                                  "learningObjective": "Interpretar e quantificar efeitos de incertezas em domínios tempo/frequência",
                                  "commonMistakes": [
                                    "Ignorar wrap-around em Bode para fases",
                                    "Escalas inadequadas em plots de ensemble"
                                  ]
                                }
                              ],
                              "practicalExample": "Simule uma planta de posicionamento de braço robótico P0(s)=100/(s(s+10)) com incerteza multiplicativa w(s)=0.3|s|/100+1. Aplique step de referência e analise como variações extremas em Δ causam overshoot excessivo (>30%) e oscilações persistentes em respostas no tempo, além de redução de 2dB na margem de ganho em Bode.",
                              "finalVerifications": [
                                "Todas as simulações rodam sem erros numéricos ou crashes no MATLAB",
                                "Envelopes de resposta no tempo capturam efeitos de incertezas extremas visivelmente",
                                "Diagramas de Bode mostram desvios corretos em magnitude e fase para Δ=±1",
                                "Métricas quantitativas (overshoot, settling time) variam conforme esperado com incertezas",
                                "Script é reprodutível com seed fixo e comentários completos",
                                "Relatório final resume impactos na robustez do sistema"
                              ],
                              "assessmentCriteria": [
                                "Precisão na modelagem de P0 e P_pert (correspondência com teoria >95%)",
                                "Adequação do número de Monte Carlo (convergência de estatísticas evidentes)",
                                "Qualidade dos plots (legendas, escalas, clareza de ensembles)",
                                "Correção das análises tempo/frequência (identificação de piores casos)",
                                "Documentação do código (comentários, modularidade)",
                                "Interpretação física dos resultados de robustez"
                              ],
                              "crossCurricularConnections": [
                                "Probabilidade e Estatística: Geração e análise de ensembles Monte Carlo",
                                "Programação Numérica: Otimização de loops e vetoração em MATLAB",
                                "Análise de Sinais e Sistemas: Interpretação de respostas em tempo/frequência",
                                "Matemática Aplicada: Normas infinitas e funções de peso",
                                "Engenharia de Software: Scripts modulares e reprodutíveis"
                              ],
                              "realWorldApplication": "Em controle de drones ou aviões, simulações de incertezas multiplicativas em aerodinâmica (devido a variações de vento ou danos) garantem que controladores robustos mantenham estabilidade sob condições extremas, evitando falhas catastróficas."
                            },
                            "estimatedTime": "2.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "76.1.1.3",
                        "name": "Incertezas Normais (Norm-Bounded) em Sistemas LIT",
                        "description": "Representação de incertezas gerais limitadas por normas, como ||Δ||∞ < 1, abrangendo aditivas e multiplicativas em uma estrutura unificada para análise de robustez em plantas LIT escalares.",
                        "specificSkills": [
                          {
                            "id": "76.1.1.3.1",
                            "name": "Definir e classificar incertezas norm-bounded",
                            "description": "Explicar incertezas normais como blocos Δ com norma infinita unitária, classificando-as em contextos aditivos ou multiplicativos para plantas LIT.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender Conceitos Básicos de Incertezas em Sistemas LIT",
                                  "subSteps": [
                                    "Revise definições de sistemas Linear Time-Invariant (LIT) e suas representações em espaço de estados ou funções de transferência.",
                                    "Identifique fontes comuns de incertezas em sistemas reais, como variações de parâmetros ou perturbações externas.",
                                    "Diferencie incertezas estruturadas (norm-bounded) de não-estruturadas.",
                                    "Estude normas em espaços de sinais, focando na norma infinita (sup norm).",
                                    "Explore o conceito de estabilidade robusta em presença de incertezas."
                                  ],
                                  "verification": "Resuma em um parágrafo as diferenças entre sistemas nominais e com incertezas norm-bounded.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Livro 'Feedback Control of Dynamic Systems' (Franklin), notas de aula sobre LIT, calculadora simbólica (MATLAB ou Wolfram Alpha).",
                                  "tips": "Use diagramas de blocos para visualizar incertezas como adições ou multiplicações no loop de controle.",
                                  "learningObjective": "Compreender o papel das incertezas em sistemas LIT e introduzir normas como medida de magnitude.",
                                  "commonMistakes": "Confundir norma infinita com norma 2; assumir que todas as incertezas são probabilísticas."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Definir Incertezas Norm-Bounded Formalmente",
                                  "subSteps": [
                                    "Defina incerteza norm-bounded como um operador Δ tal que ||Δ||_∞ ≤ 1.",
                                    "Explique a norma infinita: ||Δ||_∞ = sup_{||w||_2=1} ||Δ(w)||_2.",
                                    "Represente o sistema perturbado como G(Δ) = (I - G Δ)^{-1} G, assumindo bem-posedness.",
                                    "Derive condições para ||Δ||_∞ ≤ 1 implicar estabilidade.",
                                    "Pratique cálculo de normas para matrizes e operadores simples."
                                  ],
                                  "verification": "Calcule ||Δ||_∞ para um exemplo de matriz 2x2 e confirme se é unitária.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "MATLAB/Simulink para simulações de normas, paper 'Robust Control' de Doyle.",
                                  "tips": "Lembre-se: norma infinita unitária significa ganho máximo de 1 em qualquer frequência.",
                                  "learningObjective": "Dominar a definição matemática de blocos Δ norm-bounded com norma infinita unitária.",
                                  "commonMistakes": "Esquecer que Δ é dinâmico (pode ser um sistema LIT); confundir com norma L1."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Classificar Incertezas em Contextos Aditivos e Multiplicativos",
                                  "subSteps": [
                                    "Defina incerteza aditiva: P(s) = P0(s) + Δ(s), com ||Δ||_∞ ≤ 1.",
                                    "Defina incerteza multiplicativa: P(s) = P0(s) (I + Δ(s)), com ||Δ||_∞ ≤ w(s), normalizada.",
                                    "Compare impactos na análise de robustez: aditiva afeta diretamente a saída, multiplicativa afeta o ganho.",
                                    "Construa diagramas padrão para cada tipo em plantas LIT.",
                                    "Analise um exemplo numérico para cada classificação."
                                  ],
                                  "verification": "Desenhe e explique diagramas para um sistema de segundo ordem com ambas as incertezas.",
                                  "estimatedTime": "50 minutos",
                                  "materials": "Software de controle (MATLAB Control System Toolbox), exemplos de plantas LIT (e.g., inversor de pêndulo).",
                                  "tips": "Multiplicativa é comum para variações de ganho; aditiva para ruído de modelo.",
                                  "learningObjective": "Classificar corretamente incertezas norm-bounded em aditivas ou multiplicativas para plantas LIT.",
                                  "commonMistakes": "Ignorar o peso w(s) na multiplicativa; tratar aditiva como escalar em vez de operador."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar e Verificar em Sistemas LIT",
                                  "subSteps": [
                                    "Integre o modelo de incerteza em um loop de controle fechado.",
                                    "Use o teste de estabilidade: sistema estável se ||T||_∞ < 1/||Δ||_∞.",
                                    "Simule respostas em frequência com incertezas.",
                                    "Classifique uma planta real (e.g., motor DC) com incertezas.",
                                    "Documente o processo em um relatório curto."
                                  ],
                                  "verification": "Simule e mostre que o sistema permanece estável para ||Δ||_∞ = 1.",
                                  "estimatedTime": "75 minutos",
                                  "materials": "MATLAB/Simulink, banco de dados de plantas LIT (SysID Toolbox).",
                                  "tips": "Sempre normalize incertezas para ||Δ||_∞ ≤ 1 para simplificar análise.",
                                  "learningObjective": "Aplicar definições e classificações em contextos práticos de plantas LIT.",
                                  "commonMistakes": "Não verificar bem-posedness; superestimar robustez sem simulação."
                                }
                              ],
                              "practicalExample": "Em um sistema de controle de posição de um motor DC (planta LIT com função de transferência P0(s) = 1/(s(s+1))), modele variação de atrito como incerteza aditiva Δ(s) com ||Δ||_∞ ≤ 0.1, e variação de ganho como multiplicativa (I + W(s)Δ(s)). Simule o laço com controlador PI e verifique robustez via margens ou μ-síntese.",
                              "finalVerifications": [
                                "Defina corretamente Δ com ||Δ||_∞ ≤ 1 e dê exemplo de cálculo.",
                                "Classifique aditiva vs multiplicativa com diagramas precisos.",
                                "Explique impacto em estabilidade de LIT.",
                                "Simule um sistema com incertezas e mostre estabilidade.",
                                "Diferencie de outros modelos (e.g., paramétrica).",
                                "Discuta limitações de norm-bounded."
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição matemática (norma infinita unitária).",
                                "Correta classificação aditiva/multiplicativa com exemplos.",
                                "Uso apropriado de diagramas e simulações.",
                                "Compreensão de implicações para robustez.",
                                "Identificação de erros comuns e como evitá-los.",
                                "Clareza na explicação e aplicação prática."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria de normas em espaços de Banach e análise funcional.",
                                "Probabilidade: Relação com incertezas estocásticas (ruído vs bounded).",
                                "Física: Modelagem de sistemas dinâmicos reais com perturbações.",
                                "Computação: Algoritmos numéricos para cálculo de normas (SVD em MATLAB)."
                              ],
                              "realWorldApplication": "Em controle de voo de aeronaves, incertezas norm-bounded modelam variações aerodinâmicas (multiplicativas) e turbulências (aditivas), permitindo design de controladores robustos H-infinito que garantem estabilidade apesar de imprecisões de modelo."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "76.1.1.3.2",
                            "name": "Estruturar o problema padrão de robustez com normas",
                            "description": "Montar o diagrama padrão M-Δ com incertezas norm-bounded, onde M é a função de transferência do sistema interconectado, para sistemas LIT monovariáveis.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os conceitos fundamentais de incertezas norm-bounded e o framework M-Δ",
                                  "subSteps": [
                                    "Defina incertezas norm-bounded: blocos Δ com ||Δ||_∞ ≤ 1 ou norma induzida limitada.",
                                    "Explique o teorema small-gain: estabilidade se ||M|| < 1 para norma adequada.",
                                    "Identifique M como a função de transferência da interconexão do sistema nominal.",
                                    "Diferencie normas relevantes: H∞ para robustez de desempenho, μ para estrutura.",
                                    "Revise representação de incertezas aditivas, multiplicativas e inversas em LTI monovariáveis."
                                  ],
                                  "verification": "Resuma em um parágrafo os conceitos chave e desenhe um diagrama esquemático genérico M-Δ.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Livro de controle robusto (ex: Zhou 'Robust and Optimal Control'), notas de aula, calculadora simbólica.",
                                  "tips": "Use analogias como 'Δ é um filtro incerto com ganho máximo 1' para fixar ideias.",
                                  "learningObjective": "Dominar a terminologia e teoremas base para estruturar problemas de robustez.",
                                  "commonMistakes": "Confundir norma H∞ (pico de ganho) com norma L1 (ganho em tempo integral)."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Modelar o sistema LTI monovariável e identificar incertezas norm-bounded",
                                  "subSteps": [
                                    "Obtenha o modelo nominal G(s) do sistema LTI monovariável.",
                                    "Identifique fontes de incerteza: parâmetros, não-linearidades aproximadas como Δ.",
                                    "Normalice incertezas: represente como Δ com ||Δ|| ≤ 1, escalando com pesos W.",
                                    "Escolha tipo de incerteza: aditiva (G = G0 + WΔ), multiplicativa (G = G0(1 + WΔ)).",
                                    "Construa o diagrama de blocos inicial com entradas w e saídas z para incertezas."
                                  ],
                                  "verification": "Desenhe o diagrama do sistema com Δ isolado e verifique normalização com simulação unitária.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "MATLAB/Simulink para modelagem, papel milimetrado para diagramas.",
                                  "tips": "Sempre normalize Δ para ||Δ||≤1 para padronização; teste com Δ=1.",
                                  "learningObjective": "Capacitar modelagem precisa de incertezas em sistemas reais como norm-bounded.",
                                  "commonMistakes": "Esquecer de ponderar incertezas, levando a ||Δ|| >1 inválido."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Construir a interconexão padrão M-Δ",
                                  "subSteps": [
                                    "Puxe sinais de incerteza: defina entradas z e saídas w no diagrama.",
                                    "Elimine loops internos para obter M de w para z: M = Fl(P, K) ou similar.",
                                    "Monte o diagrama M-Δ em feedback unitário: z = M w, w = Δ z.",
                                    "Verifique dimensionalidade: para monovariável, M e Δ escalares em frequência.",
                                    "Represente em domínio de frequência: M(jω) para análise."
                                  ],
                                  "verification": "Implemente em MATLAB o diagrama e plote singular values de M(jω).",
                                  "estimatedTime": "50 minutos",
                                  "materials": "Software MATLAB com Control Toolbox, exemplos de Zhou cap. 9.",
                                  "tips": "Use função 'lft' no MATLAB para interconexões lineares fracionárias.",
                                  "learningObjective": "Habilitar montagem correta do diagrama padrão para análise de robustez.",
                                  "commonMistakes": "Invertar sinais de feedback em w = Δ z, causando instabilidade espúria."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Formular a condição de robustez usando normas",
                                  "subSteps": [
                                    "Defina norma para robustez: ||M||_∞ < 1 garante estabilidade robusta.",
                                    "Calcule ||M||_∞ via singular values máximas: sup_ω σ̄(M(jω)).",
                                    "Inclua desempenho: estenda para γ-otimização com ||Tzw||_∞ < γ.",
                                    "Analise frequência crítica onde σ̄(M) >1 indica violação.",
                                    "Documente o problema: 'Estabilidade se ||M||_∞ <1 para Δ norm-bounded'."
                                  ],
                                  "verification": "Compute ||M||_∞ numericamente e confirme <1 para caso nominal.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "MATLAB hinfnorm() ou sigma(), relatórios de simulação.",
                                  "tips": "Plote σ̄(M(jω)) vs ω em log-log para visualizar picos.",
                                  "learningObjective": "Aplicar normas para quantificar e verificar robustez estrutural.",
                                  "commonMistakes": "Usar norma errada: H2 para robustez (é para ruído, não pior-caso)."
                                }
                              ],
                              "practicalExample": "Considere um sistema de posição de motor DC monovariável G(s) = 1/(s(s+1)) com incerteza multiplicativa de 20% no ganho: Δ tal que G = G0 (1 + 0.2 Δ), ||Δ||∞ ≤1. Construa M(s) = [G0 K; K G0 0.2 G0 K] para controlador K(s)=1 (feedback unitário), compute ||M||∞ ≈0.85 <1, confirmando robustez.",
                              "finalVerifications": [
                                "Diagrama M-Δ desenhado corretamente com sinais w e z.",
                                "Incertezas normalizadas: ||Δ||∞ ≤1 testado.",
                                "||M||∞ calculado e <1 para estabilidade robusta.",
                                "Análise em frequência mostra margem de robustez.",
                                "Documentação inclui modelo nominal, Δ e condição de robustez.",
                                "Simulação com Δ=1 no pior caso mantém estabilidade."
                              ],
                              "assessmentCriteria": [
                                "Precisão na modelagem de incertezas (normalização correta: 30%).",
                                "Correção do diagrama M-Δ e interconexão (25%).",
                                "Cálculo exato de norma ||M||∞ e interpretação (20%).",
                                "Análise de frequência e margens (15%).",
                                "Clareza na documentação e verificações (10%)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria de operadores e normas em espaços de Hardy.",
                                "Programação: Implementação em MATLAB/Simulink para análise numérica.",
                                "Física: Modelagem de sistemas dinâmicos reais com perturbações.",
                                "Otimização: Preparação para síntese H∞/μ.",
                                "Estatística: Relação com bounds probabilísticos em incertezas."
                              ],
                              "realWorldApplication": "Em automação industrial, estrutura problemas de robustez para controladores PID em plantas químicas com variações paramétricas (ex: tempo morto variável), garantindo estabilidade apesar de incertezas norm-bounded em reatores ou fornos, evitando downtime em fábricas."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "76.1.1.3.3",
                            "name": "Calcular margens de robustez normais",
                            "description": "Computar a norma H∞ de M para determinar a robustez máxima frente a incertezas norm-bounded, utilizando ferramentas como MATLAB Robust Control Toolbox.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Fundamentos Teóricos da Norma H∞ e Incertezas Norm-Bounded",
                                  "subSteps": [
                                    "Estude a definição de norma H∞ para sistemas LIT: supremo sobre ω da norma singular máxima de G(jω).",
                                    "Compreenda incertezas norm-bounded: Δ com ||Δ||₂ ≤ 1, e o sistema perturbado P = (I - MΔ)^(-1)M.",
                                    "Revise o teorema de robustez: estabilidade garantida se ||M||_∞ < 1.",
                                    "Analise exemplos simples de matrizes de incerteza e impacto na robustez.",
                                    "Derive a relação entre margem de robustez μ e norma H∞."
                                  ],
                                  "verification": "Resuma em um parágrafo os conceitos chave e resolva um exercício teórico simples de norma H∞.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Livro de controle robusto (e.g., Zhou et al.), notas de aula, calculadora simbólica como SymPy.",
                                  "tips": "Use diagramas de blocos para visualizar o loop de incerteza.",
                                  "learningObjective": "Compreender a base matemática da norma H∞ e sua relação com robustez.",
                                  "commonMistakes": "Confundir norma H∞ com norma H₂; ignorar a estrutura das incertezas."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Preparar o Modelo do Sistema no MATLAB",
                                  "subSteps": [
                                    "Defina o sistema nominal G(s) usando tf() ou ss() no MATLAB.",
                                    "Construa a matriz M(s) do sistema generalizado para o problema de robustez estruturada.",
                                    "Modele as incertezas Δ como blocos norm-bounded usando ureal() ou uss().",
                                    "Monte o sistema interconectado com connect() ou feedback().",
                                    "Verifique a estabilidade nominal com pole() ou step().",
                                    "Plote respostas em frequência com bode() para inspeção inicial."
                                  ],
                                  "verification": "Execute o script e confirme que M(s) está corretamente definido sem erros de sintaxe ou singularidades.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "MATLAB com Robust Control Toolbox instalado, script template para sistemas LIT.",
                                  "tips": "Salve checkpoints intermediários com save() para depuração fácil.",
                                  "learningObjective": "Modelar sistemas com incertezas no ambiente MATLAB.",
                                  "commonMistakes": "Esquecer de linearizar modelos não-lineares; usar unidades erradas em tf()."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Computar a Norma H∞ e Margens de Robustez",
                                  "subSteps": [
                                    "Use norm(M, 'inf') ou hinfnorm(M) para calcular ||M||_∞.",
                                    "Aplique mu-analysis com mussv(M, 'analysis') para margens estruturadas se aplicável.",
                                    "Gere upper e lower bounds com sel() ou mu() para incertezas complexas.",
                                    "Interprete: se ||M||_∞ < 1, robustez garantida; margem = 1 / ||M||_∞.",
                                    "Plote singular values com sigma(M) para visualização.",
                                    "Ajuste o controlador K(s) iterativamente para minimizar ||M||_∞."
                                  ],
                                  "verification": "Obtenha um valor numérico de ||M||_∞ e confirme convergência do algoritmo.",
                                  "estimatedTime": "75 minutos",
                                  "materials": "Robust Control Toolbox (funções norm, hinfnorm, mussv), exemplos do help toolbox.",
                                  "tips": "Use robustopts para tolerâncias numéricas em casos il-condicionados.",
                                  "learningObjective": "Aplicar ferramentas computacionais para análise H∞.",
                                  "commonMistakes": "Não especificar frequência de interesse; ignorar warnings de condição numérica."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar e Validar Resultados",
                                  "subSteps": [
                                    "Compare margens com simulações de Monte Carlo para Δ aleatórias.",
                                    "Avalie sensibilidade com usim() ou lsim() em cenários perturbados.",
                                    "Gere relatório com valores de ||M||_∞, margens e plots.",
                                    "Teste trade-offs entre performance e robustez ajustando pesos.",
                                    "Documente limitações do modelo e sugestões de melhoria."
                                  ],
                                  "verification": "Simule 100 realizações e confirme estabilidade em todas com margem >1.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Scripts de simulação Monte Carlo, toolbox Uncertainty Modeling.",
                                  "tips": "Use parfor() para acelerar simulações paralelas.",
                                  "learningObjective": "Interpretar e validar margens de robustez computadas.",
                                  "commonMistakes": "Sobreestimar robustez sem validação simulada; negligenciar incertezas não-modeladas."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Aplicar em um Caso Prático e Sintetizar Aprendizado",
                                  "subSteps": [
                                    "Aplique a um sistema real como controle de posição de um braço robótico.",
                                    "Otimize o controlador com hinfsyn() para atender specs de robustez.",
                                    "Compare com métodos clássicos (e.g., PID) em termos de margem.",
                                    "Escreva um resumo com lições aprendidas e código reutilizável.",
                                    "Compartilhe resultados em um relatório ou notebook Jupyter."
                                  ],
                                  "verification": "Demonstre melhoria na margem H∞ pós-otimização em simulação.",
                                  "estimatedTime": "90 minutos",
                                  "materials": "Dados de planta real ou modelo Simulink, hinfsyn() documentation.",
                                  "tips": "Comece com um modelo baixo-ordem para prototipagem rápida.",
                                  "learningObjective": "Integrar análise H∞ em design de controladores robustos.",
                                  "commonMistakes": "Violar specs de performance na busca por robustez excessiva."
                                }
                              ],
                              "practicalExample": "Considere um sistema de controle de velocidade de um DC motor com incertezas paramétricas norm-bounded em ganho e tempo morto. Construa M(s) incorporando Δ_k (ganho) e Δ_t (atraso). Calcule ||M||_∞ = 0.75, implicando margem de robustez de 1.33. Simule perturbações e confirme ausência de instabilidade.",
                              "finalVerifications": [
                                "Computa corretamente ||M||_∞ <1 para um sistema dado.",
                                "Interpreta margem como 1/||M||_∞ e explica implicações.",
                                "Gera plots de singular values consistentes com resultados numéricos.",
                                "Valida via simulação Monte Carlo sem violações de estabilidade.",
                                "Ajusta controlador para melhorar robustez sem degradar performance.",
                                "Documenta limitações numéricas e sugestões de refinamento."
                              ],
                              "assessmentCriteria": [
                                "Precisão na modelagem de M(s) e incertezas (90%+ sem erros).",
                                "Convergência e exatidão da norma H∞ computada (erro <1%).",
                                "Qualidade da interpretação e análise de margens.",
                                "Robustez da validação simulada (100% estabilidade em testes).",
                                "Clareza e completude do relatório com plots e código.",
                                "Criatividade em aplicações e trade-offs identificados."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Álgebra linear (normas matriciais, valores singulares).",
                                "Programação: MATLAB scripting e otimização numérica.",
                                "Física: Dinâmica de sistemas com perturbações reais.",
                                "Engenharia de Software: Validação e testes automatizados.",
                                "Estatística: Análise de sensibilidade e Monte Carlo."
                              ],
                              "realWorldApplication": "Em aviação, calcular margens H∞ garante estabilidade de autômatos de voo frente a variações aerodinâmicas norm-bounded, prevenindo falhas catastróficas em condições turbulentas ou com desgaste de componentes."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.2.2",
                    "name": "Forma Padrão de Robustez",
                    "description": "Representação generalizada do sistema interconectado com bloco nominal M e bloco de incerteza Δ.",
                    "individualConcepts": [
                      {
                        "id": "10.1.2.2.1.1",
                        "name": "Definição da Forma Padrão de Robustez",
                        "description": "Representação generalizada de sistemas LIT com incertezas como uma interconexão entre o bloco nominal M, que descreve o sistema principal, e o bloco de incerteza Δ, permitindo análise de estabilidade e desempenho robusto.",
                        "specificSkills": [
                          {
                            "id": "10.1.2.2.1.1.1",
                            "name": "Identificar a estrutura da forma padrão M-Δ",
                            "description": "Reconhecer e diagramar a interconexão padrão onde as saídas de incerteza do bloco M alimentam as entradas do bloco Δ e vice-versa, destacando entradas externas w, saídas de erro z e sinais de controle u/y.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Conceitos Básicos de Modelagem de Incertezas em Sistemas LIT",
                                  "subSteps": [
                                    "Estude a definição de sistemas lineares invariantes no tempo (LIT) e sua representação em diagrama de blocos.",
                                    "Identifique o que representa o 'sistema nominal' em controle robusto.",
                                    "Revise exemplos de fontes de incerteza, como variações paramétricas ou não modeladas.",
                                    "Anote diferenças entre perturbações externas e incertezas internas.",
                                    "Pratique desenhando um diagrama simples de laço fechado sem incertezas."
                                  ],
                                  "verification": "Resuma em 3 frases os conceitos chave e desenhe um diagrama básico de laço fechado.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Livro-texto de Controle Avançado (ex: Zhou, Doyle, Glover)",
                                    "Papel e lápis ou software de diagramação como Draw.io"
                                  ],
                                  "tips": "Use setas direcionais claras para sinais de entrada/saída em diagramas iniciais.",
                                  "learningObjective": "Compreender os fundamentos que precedem a forma M-Δ.",
                                  "commonMistakes": "Confundir perturbações externas com incertezas estruturais; sempre diferencie w (externo) de Δ (interno)."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Descrever e Representar o Bloco M (Sistema Nominal Interconectado)",
                                  "subSteps": [
                                    "Defina o bloco M como a interconexão do sistema nominal com controlador e planta.",
                                    "Identifique as entradas e saídas do bloco M: entradas [w; u], saídas [z; y].",
                                    "Desenhe o diagrama interno de M, incluindo laço de realimentação u → y.",
                                    "Calcule ou liste exemplos de transfer functions de M para entradas w → z e u → y.",
                                    "Verifique estabilidade nominal de M assumindo Δ=0."
                                  ],
                                  "verification": "Desenhe o diagrama de M com rótulos corretos para entradas/saídas e explique o fluxo de sinais.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Software MATLAB/Simulink para simulação básica",
                                    "Folhas de anotações"
                                  ],
                                  "tips": "Lembre-se: M captura tudo exceto incertezas; foque em robustez via norma H-infinito.",
                                  "learningObjective": "Dominar a estrutura e função do bloco M na forma padrão.",
                                  "commonMistakes": "Esquecer a realimentação interna em M; sempre inclua u e y conectados."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Descrever e Representar o Bloco Δ (Bloco de Incertezas)",
                                  "subSteps": [
                                    "Defina Δ como bloco normado representando todas incertezas (Δ ∈ RH_infty, ||Δ||_∞ <1 para robustez).",
                                    "Identifique entradas e saídas de Δ: entradas [z], saídas [w].",
                                    "Discuta tipos de Δ: paramétrico, dinâmico, ou coprime factor uncertainty.",
                                    "Desenhe Δ como um bloco único ou paralelo para múltiplas incertezas.",
                                    "Explique o feedback bidirecional: z alimenta Δ, w retroalimenta M."
                                  ],
                                  "verification": "Crie um diagrama isolado de Δ com setas para z → Δ → w e anote condições de normamento.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Referências: Skogestad & Postlethwaite 'Multivariable Feedback Control'",
                                    "Ferramenta de desenho digital"
                                  ],
                                  "tips": "Pense em Δ como 'caixa preta' de incertezas; não detalhe internamente ainda.",
                                  "learningObjective": "Entender o papel e representação do bloco de incertezas Δ.",
                                  "commonMistakes": "Confundir direção das conexões; z é saída de M para entrada de Δ, w é saída de Δ para entrada de M."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Montar e Diagramar a Interconexão Completa M-Δ",
                                  "subSteps": [
                                    "Conecte M e Δ: saídas z de M → entradas de Δ; saídas w de Δ → entradas de M.",
                                    "Rotule todos os sinais: entradas externas w, saídas de erro z, controle u, medida y.",
                                    "Desenhe o diagrama final da forma padrão M-Δ com feedback fechado geral.",
                                    "Verifique o critério de robustez: sistema estável se ||M||_∞ < 1/||Δ||_∞.",
                                    "Simule um caso simples para validar a estrutura."
                                  ],
                                  "verification": "Produza um diagrama completo rotulado e explique o loop de incerteza bidirecional.",
                                  "estimatedTime": "50 minutos",
                                  "materials": [
                                    "MATLAB para plotar diagrama ou LaTeX/TikZ para diagramas profissionais",
                                    "Exemplos de artigos IEEE sobre robustez"
                                  ],
                                  "tips": "Use convenções padrão: M no centro, Δ abaixo, setas cruzadas para interconexão.",
                                  "learningObjective": "Identificar e diagramar precisamente a estrutura M-Δ completa.",
                                  "commonMistakes": "Invertar setas de conexão; sempre z → Δ → w forma o loop de incerteza."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Validar e Testar o Reconhecimento da Estrutura",
                                  "subSteps": [
                                    "Analise um diagrama dado e identifique M-Δ nele.",
                                    "Modifique um sistema simples adicionando Δ e re-diagramando.",
                                    "Discuta implicações para síntese de controladores robustos.",
                                    "Compare com outras formas (ex: coprime factorization).",
                                    "Resolva um exercício: dado G e K, construa M-Δ."
                                  ],
                                  "verification": "Resolva 2 problemas de identificação de estrutura e autoavalie acurácia.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Exercícios de problemas resolvidos de controle robusto",
                                    "Simulador online como Control Toolbox"
                                  ],
                                  "tips": "Pratique com variações para fixar o padrão visual.",
                                  "learningObjective": "Aplicar o reconhecimento da forma M-Δ em contextos variados.",
                                  "commonMistakes": "Ignorar sinais u/y; eles são essenciais para o laço de controle dentro de M."
                                }
                              ],
                              "practicalExample": "Em um controlador PID para um motor DC com incerteza no ganho da planta (20% variação), M inclui planta nominal + PID + realimentação, com z como sinal de performance (tracking error), w como perturbação de carga. Δ modela a incerteza aditiva na planta. Diagramar mostra z → Δ → w, garantindo robustez se ||M||_∞ <1.",
                              "finalVerifications": [
                                "Desenhar corretamente o diagrama M-Δ com todas conexões bidirecionais.",
                                "Rotular precisamente w (entrada externa), z (saída de erro), u (controle), y (medida).",
                                "Explicar o loop de incerteza: saídas de M alimentam Δ e vice-versa.",
                                "Identificar M como sistema nominal interconectado.",
                                "Verificar condição de robustez ||M||_∞ ||Δ||_∞ <1.",
                                "Diferenciar entradas/saídas de M e Δ sem erros."
                              ],
                              "assessmentCriteria": [
                                "Precisão do diagrama (100% das conexões corretas): 30%",
                                "Correta identificação e rotulação de sinais (w,z,u,y): 25%",
                                "Explicação clara da interconexão bidirecional: 20%",
                                "Compreensão conceitual de M (nominal) vs Δ (incerteza): 15%",
                                "Aplicação do critério de robustez: 10%"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Análise de normas H-infinito e singular values.",
                                "Física: Modelagem dinâmica de sistemas reais com perturbações.",
                                "Programação: Simulação em MATLAB/Simulink de loops M-Δ.",
                                "Engenharia de Software: Verificação formal de propriedades robustas."
                              ],
                              "realWorldApplication": "No design de flight control systems para aviões (ex: Boeing 787), a forma M-Δ modela incertezas aerodinâmicas (Δ) no modelo nominal (M), garantindo estabilidade robusta apesar de variações de vento ou danos estruturais, evitando catástrofes via síntese H-infinito."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.2.1.1.2",
                            "name": "Explicar o propósito da forma padrão em análise de robustez",
                            "description": "Descrever como a forma padrão unifica diferentes tipos de incertezas (parâmetros, não-lineares, não-modeladas) para aplicação de critérios como o teorema de pequena ganho e μ-análise.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender o Conceito Fundamental de Robustez em Sistemas de Controle",
                                  "subSteps": [
                                    "Defina robustez como a capacidade de um sistema de manter desempenho estável apesar de perturbações e incertezas.",
                                    "Identifique os principais componentes de um laço de controle fechado: planta nominal, controlador e bloco de incerteza.",
                                    "Revise representações gráficas básicas de sistemas LIT (Linear Invariante no Tempo).",
                                    "Discuta por que a análise de robustez é crucial em aplicações reais.",
                                    "Esboce um diagrama de bloco simples de um sistema com incerteza."
                                  ],
                                  "verification": "Crie um diagrama de bloco rotulando componentes de robustez e explique verbalmente sua importância.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Livro-texto de Controle Avançado (ex: Zhou, Doyle), papel e caneta para diagramas, software MATLAB/Simulink para visualização.",
                                  "tips": "Comece com exemplos cotidianos como controle de velocidade de um carro para tornar abstrato concreto.",
                                  "learningObjective": "Compreender a base conceitual de robustez e sua relevância em sistemas LIT.",
                                  "commonMistakes": "Confundir robustez com estabilidade nominal; ignorar que robustez inclui desempenho, não só estabilidade."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Classificar e Exemplificar Tipos de Incertezas",
                                  "subSteps": [
                                    "Liste e defina incertezas paramétricas (variações em parâmetros da planta).",
                                    "Descreva incertezas não-lineares (efeitos não-lineares não modelados).",
                                    "Explique incertezas não-modeladas (distúrbios externos ou dinâmica ignorada).",
                                    "Compare essas incertezas com exemplos numéricos simples.",
                                    "Discuta limitações de tratá-las separadamente na análise."
                                  ],
                                  "verification": "Forneça exemplos de cada tipo de incerteza em um sistema real e justifique por que unificação é necessária.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Artigos sobre modelos de incerteza (ex: Skogestad), planilhas Excel para simulações paramétricas.",
                                  "tips": "Use tabelas para categorizar incertezas, facilitando visualização.",
                                  "learningObjective": "Identificar e diferenciar tipos de incertezas comuns em sistemas de controle.",
                                  "commonMistakes": "Subestimar incertezas não-modeladas como 'ruído'; tratar todas como paramétricas."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Descrever a Forma Padrão e Seu Papel Unificador",
                                  "subSteps": [
                                    "Apresente a estrutura da forma padrão: Δ conectada em paralelo ou feedback com o sistema nominal M.",
                                    "Explique como Δ encapsula todas as incertezas (paramétricas, não-lineares, não-modeladas) de forma normada.",
                                    "Derive matematicamente a interconexão: z = M11 w + M12 Δ w, etc.",
                                    "Mostre como isso permite análise uniforme independentemente do tipo de Δ.",
                                    "Ilustre com um diagrama da forma padrão."
                                  ],
                                  "verification": "Desenhe a forma padrão para um sistema dado e rotule entradas/saídas de incerteza.",
                                  "estimatedTime": "75 minutos",
                                  "materials": "MATLAB Robust Control Toolbox, tutoriais online sobre forma padrão (ex: MIT OCW Controle Avançado).",
                                  "tips": "Lembre-se: a norma de Δ < 1 garante robustez; foque na unificação.",
                                  "learningObjective": "Explicar como a forma padrão unifica incertezas para análise padronizada.",
                                  "commonMistakes": "Confundir M com a planta nominal; ignorar normalização das incertezas."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar Critérios de Robustez na Forma Padrão",
                                  "subSteps": [
                                    "Introduza o Teorema de Pequeno Ganho: ||M||_∞ < 1/||Δ||_∞ implica estabilidade.",
                                    "Descreva a μ-análise para incertezas estruturadas: μ(M) < 1 garante robustez.",
                                    "Compare pequeno ganho (não-estruturado) vs. μ (estruturado).",
                                    "Simule um exemplo simples computando normas.",
                                    "Discuta limitações e extensões (ex: robustez de desempenho)."
                                  ],
                                  "verification": "Aplique pequeno ganho ou μ a um sistema na forma padrão e interprete resultados.",
                                  "estimatedTime": "90 minutos",
                                  "materials": "Software MATLAB com mucalc, exemplos de código de robustez.",
                                  "tips": "Pratique com funções prontas como norm() e musyn() para ganhar confiança.",
                                  "learningObjective": "Demonstrar como a forma padrão habilita critérios como pequeno ganho e μ-análise.",
                                  "commonMistakes": "Aplicar μ sem estrutura; confundir estabilidade com desempenho robusto."
                                }
                              ],
                              "practicalExample": "Considere um controlador PID para um forno industrial. A planta tem incertezas paramétricas (variação de ganho térmico ±20%), não-lineares (saturação do aquecedor) e não-modeladas (variações ambientais). Reformule em forma padrão com Δ normada, aplique μ-análise para verificar se ||μ(M)||_∞ <1, garantindo temperatura estável apesar de variações.",
                              "finalVerifications": [
                                "Explicar verbalmente o propósito da forma padrão em 1 minuto.",
                                "Desenhar corretamente a interconexão da forma padrão.",
                                "Identificar todos os tipos de incertezas em um exemplo dado.",
                                "Aplicar teorema de pequeno ganho a um sistema simples.",
                                "Discutir diferenças entre pequeno ganho e μ-análise.",
                                "Interpretar resultados de uma simulação de robustez."
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição e unificação de incertezas (30%).",
                                "Correta representação gráfica da forma padrão (25%).",
                                "Aplicação correta de critérios de robustez (20%).",
                                "Uso de exemplos práticos e interpretações (15%).",
                                "Clareza e estrutura na explicação (10%)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Análise de normas (H∞, μ) e álgebra linear.",
                                "Programação: Simulações em MATLAB/Python para robustez.",
                                "Física: Modelagem de sistemas dinâmicos reais com incertezas.",
                                "Estatística: Tratamento de variações paramétricas e Monte Carlo."
                              ],
                              "realWorldApplication": "Na indústria aeroespacial, a forma padrão é usada para certificar controladores de voo robustos a incertezas como variações aerodinâmicas, permitindo análise unificada via μ-tools para cumprir normas FAA."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.2.1.1.3",
                            "name": "Converter um sistema LIT com incertezas para a forma padrão",
                            "description": "Dado um diagrama de malha fechada com perturbações e incertezas aditivas/multiplicativas, reestruturar o sistema para obter as matrizes de transferência M e Δ.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Analisar o diagrama de malha fechada original",
                                  "subSteps": [
                                    "Identifique todos os blocos do sistema, incluindo controladores, plantas nominais e perturbações.",
                                    "Marque as entradas (referência r, perturbações d) e saídas (y).",
                                    "Anote as incertezas aditivas (ex: w_a) e multiplicativas (ex: Δ_p na planta).",
                                    "Desenhe uma cópia exata do diagrama para trabalhar.",
                                    "Liste as equações de transferência de cada bloco principal."
                                  ],
                                  "verification": "Verifique se o diagrama copiado é idêntico ao original e se todas as entradas/saídas estão corretamente identificadas.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Papel e caneta ou software de diagramação (ex: Draw.io, MATLAB Simulink); diagrama original.",
                                  "tips": "Use cores diferentes para nominal (azul) e incertezas (vermelho) para facilitar a visualização.",
                                  "learningObjective": "Compreender a estrutura completa do sistema LIT com incertezas.",
                                  "commonMistakes": "Ignorar perturbações em laços internos ou confundir aditivas com multiplicativas."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar e isolar as incertezas (Δ)",
                                  "subSteps": [
                                    "Colete todas as incertezas aditivas e multiplicativas em um bloco Δ único.",
                                    "Para incertezas multiplicativas, multiplique pelo bloco nominal correspondente (ex: P_nominal * Δ_p).",
                                    "Para aditivas, posicione diretamente como perturbações (ex: w_a).",
                                    "Crie pontos de injeção e extração para conectar Δ ao resto do sistema.",
                                    "Defina as entradas e saídas do bloco Δ com base nas perturbações identificadas."
                                  ],
                                  "verification": "Confirme que todas as incertezas originais foram movidas para Δ sem perda de informação.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Diagrama copiado do Step 1; calculadora ou MATLAB para equações simbólicas.",
                                  "tips": "Lembre-se: Δ é norma-bounded, então preserve a estrutura para análise de robustez.",
                                  "learningObjective": "Extrair e consolidar incertezas em um bloco normado Δ.",
                                  "commonMistakes": "Esquecer de normalizar incertezas ou inverter a ordem multiplicativa."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Construir a matriz de transferência nominal M",
                                  "subSteps": [
                                    "Remova todas as incertezas do diagrama, deixando apenas os blocos nominais.",
                                    "Calcule as funções de transferência de M entre as entradas de Δ e saídas para Δ.",
                                    "Use sinais de bloco ou algebrismo de malha para obter M (ex: M = [M11 M12; M21 M22]).",
                                    "Conecte as entradas/saídas de M aos pontos de injeção/extração de Δ.",
                                    "Simplifique expressões algébricas se possível."
                                  ],
                                  "verification": "Simule ou calcule manualmente se L ≈ M Δ para entradas unitárias em Δ.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Software simbólico (MATLAB Symbolic Toolbox ou Mathematica); papel quadriculado.",
                                  "tips": "Mantenha M estável e mínima fase para análise posterior de robustez.",
                                  "learningObjective": "Derivar a matriz M nominal do sistema reestruturado.",
                                  "commonMistakes": "Erro em sinais de cálculo de laço ou omissão de caminhos cruzados."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Validar a forma padrão L = M Δ",
                                  "subSteps": [
                                    "Reconstrua o diagrama completo com M e Δ interconectados.",
                                    "Compare a resposta do sistema original vs. novo para uma entrada de teste.",
                                    "Verifique dimensionalidade: entradas/saídas de M e Δ compatíveis.",
                                    "Calcule o índice estrutural de McMillan para confirmar equivalência.",
                                    "Documente as matrizes M e Δ finais."
                                  ],
                                  "verification": "As respostas dinâmicas coincidem para r=1, d=0 e perturbações unitárias.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "MATLAB/Simulink para simulação; diagrama final.",
                                  "tips": "Use step response ou Bode plot para validação rápida.",
                                  "learningObjective": "Confirmar a transformação para a forma padrão de robustez.",
                                  "commonMistakes": "Não validar numericamente, levando a erros silenciosos."
                                }
                              ],
                              "practicalExample": "Considere um sistema de posição de motor DC com planta P(s) = (1 + Δ_p(s))/s, controlador C(s) = 10, perturbação aditiva w_a(s). Copie diagrama, isole Δ = diag(Δ_p, w_a), derive M(s) com entradas [e_p; e_a] e saídas [y_p; y_a], obtendo M = [[P_n C / (1+P_n C), P_n / (1+P_n C)]; [C / (1+P_n C), 1 / (1+P_n C)]] onde P_n=1/s.",
                              "finalVerifications": [
                                "Diagrama reestruturado reproduz exatamente o comportamento original.",
                                "Bloco Δ contém todas as incertezas aditivas e multiplicativas.",
                                "Matriz M é calculada corretamente com dimensões compatíveis.",
                                "Simulação numérica confirma L = M Δ.",
                                "Documentação inclui equações explícitas de M e Δ.",
                                "Estrutura permite análise de robustez (ex: norma H-infinito)."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de incertezas (100% capturadas).",
                                "Correção algébrica das funções de M (erro <1%).",
                                "Validação por simulação (coincidência >95% em respostas transitórias).",
                                "Clareza no diagrama final e documentação.",
                                "Eficiência: tempo total <90 minutos para exemplo padrão.",
                                "Capacidade de generalizar para sistemas MIMO."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Álgebra linear (matrizes de transferência) e análise de sistemas lineares.",
                                "Programação: Simulação em MATLAB/Simulink para validação.",
                                "Física: Modelagem dinâmica de sistemas reais com ruído.",
                                "Estatística: Tratamento de incertezas estocásticas em Δ."
                              ],
                              "realWorldApplication": "Em controle de robôs industriais, onde incertezas na planta (variações de carga) e perturbações (vibrações) são comuns; a forma padrão permite síntese de controladores robustos via μ-síntese, garantindo estabilidade apesar de variações de até 50% nos parâmetros."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.2.2.1.2",
                        "name": "Bloco Nominal M",
                        "description": "Matriz de transferência 2x2 ou generalizada do sistema nominal, incluindo planta, controlador e pesos de desempenho, com portas de incerteza definidas por entradas δ e saídas Δ.",
                        "specificSkills": [
                          {
                            "id": "10.1.2.2.1.2.1",
                            "name": "Construir o bloco M a partir de um sistema de controle escalar",
                            "description": "Calcular as partições M11, M12, M21 e M22 utilizando funções de transferência da planta P, controlador K e pesos Wp, We, Wt para injeção de incertezas.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Definir e representar os componentes do sistema de controle",
                                  "subSteps": [
                                    "Identifique as funções de transferência: planta P(s), controlador K(s), pesos Wp(s), We(s) e Wt(s).",
                                    "Desenhe o diagrama de blocos básico do laço de feedback unitário com P e K.",
                                    "Inclua os pesos nos pontos apropriados: Wp no erro de tracking/performance, We no sinal de controle u, Wt na entrada da incerteza multiplicativa.",
                                    "Marque as entradas exógenas w (distúrbios, referências) e saídas ponderadas z (erros ponderados, esforço).",
                                    "Defina o ponto de injeção da incerteza Δ (ex: multiplicativa na saída da planta)."
                                  ],
                                  "verification": "Diagrama completo com todos os blocos rotulados e setas de sinal corretas; compare com diagramas padrão de robustez.",
                                  "estimatedTime": "25 minutes",
                                  "materials": [
                                    "Papel e lápis para diagrama",
                                    "Software de edição de diagramas (Draw.io ou similar)",
                                    "Referência teórica (livro de controle robusto)"
                                  ],
                                  "tips": "Use convenções padrão de sinalização (setas para direções de sinal) para evitar confusão em manipulações algébricas.",
                                  "learningObjective": "Compreender a estrutura do sistema de controle escalar com pesos para análise de robustez.",
                                  "commonMistakes": [
                                    "Esquecer de normalizar a incerteza com Wt",
                                    "Confundir entradas w com saídas z",
                                    "Desenhar laço de feedback invertido"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Derivar as funções de sensibilidade básicas",
                                  "subSteps": [
                                    "Calcule a função de sensibilidade S(s) = 1 / (1 + P(s)K(s)).",
                                    "Calcule a função complementar T(s) = P(s)K(s) S(s).",
                                    "Calcule a sensibilidade de controle KS(s) = K(s) S(s).",
                                    "Verifique as propriedades algébricas: S + T = 1.",
                                    "Expresse os sinais chave: erro e(s), controle u(s) em termos de entradas w."
                                  ],
                                  "verification": "Verificar se S(s) + T(s) = 1 para o exemplo simples; plotar magnitude se possível.",
                                  "estimatedTime": "30 minutes",
                                  "materials": [
                                    "Calculadora simbólica (MATLAB Symbolic ou SymPy)",
                                    "Folha de cálculos",
                                    "Control System Toolbox (opcional)"
                                  ],
                                  "tips": "Mantenha todas as expressões em termos de P, K para facilitar substituições posteriores.",
                                  "learningObjective": "Dominar as funções de sensibilidade essenciais para montagem do bloco M.",
                                  "commonMistakes": [
                                    "Erro no denominador comum (1 + PK)",
                                    "Confundir T com loop gain PK",
                                    "Não simplificar frações racionais"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular as partições M11, M12, M21 e M22",
                                  "subSteps": [
                                    "Derive M11: transferências de w para z sem Δ (ex: M11 = [Wp S; We KS]).",
                                    "Derive M12: transferências de entrada de Δ para z (ex: M12 = [Wp T Wt; We T Wt]).",
                                    "Derive M21: transferências de w para saída de Δ (geralmente 0 em estruturas padrão).",
                                    "Derive M22: transferência de entrada de Δ para saída de Δ (geralmente 0 para estabilidade).",
                                    "Simplifique expressões algébricas e substitua funções de sensibilidade."
                                  ],
                                  "verification": "Comparar fórmulas derivadas com equações padrão de robustez; calcular numericamente em s=jω para ω=1.",
                                  "estimatedTime": "45 minutes",
                                  "materials": [
                                    "Software simbólico (SymPy/MATLAB)",
                                    "Tabela de fórmulas de referência",
                                    "Planilha para cálculos numéricos"
                                  ],
                                  "tips": "Use fatoração comum como S ou T para reduzir complexidade; verifique limites em baixas e altas frequências.",
                                  "learningObjective": "Aplicar manipulação de diagramas de blocos para obter partições do bloco M.",
                                  "commonMistakes": [
                                    "Inverter M12 e M11",
                                    "Esquecer multiplicação por Wt em M12",
                                    "Não considerar estrutura exata de incerteza"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Montar o bloco M e validar a construção",
                                  "subSteps": [
                                    "Assemble a matriz M = [M11 M12; M21 M22] com as funções calculadas.",
                                    "Verifique consistência: M22 = 0 e M21 = 0 em estruturas nominais.",
                                    "Calcule a norma infinita ||M||∞ ou valores singulares para o exemplo.",
                                    "Simule em software para confirmar (ex: step response com incerteza).",
                                    "Documente o processo em relatório curto."
                                  ],
                                  "verification": "||M||∞ < 1 para o exemplo garante robustez; gráficos de Bode coincidem com esperado.",
                                  "estimatedTime": "35 minutes",
                                  "materials": [
                                    "MATLAB/Simulink ou Python Control",
                                    "Gráficos de Bode prontos"
                                  ],
                                  "tips": "Para scalar, ||M||∞ = max |mij(jω)|; foque em picos de frequência.",
                                  "learningObjective": "Integrar partições em bloco M e avaliar robustez.",
                                  "commonMistakes": [
                                    "Montagem errada da matriz (linhas/colunas trocadas)",
                                    "Ignorar polo/zero cancelamentos",
                                    "Não validar com simulação"
                                  ]
                                }
                              ],
                              "practicalExample": "Considere P(s) = 1/(s+1), K(s) = 1, Wp(s)=1, We(s)=1, Wt(s)=0.1. Então S(s)=(s+1)/(s+2), T(s)=1/(s+2). M11 = [1*(s+1)/(s+2); 1*1/(s+2)], M12 = [1/(s+2)*0.1; 1/(s+2)*0.1], M21=0, M22=0. Verifique ||M||∞ ≈ 0.55 <1, garantindo robustez.",
                              "finalVerifications": [
                                "Todas partições Mij expressas corretamente em termos de P, K, Wp, We, Wt.",
                                "Propriedades algébricas satisfeitos (S + T =1, M22=0).",
                                "Cálculos numéricos em ω=1 rad/s coincidem (±5% erro).",
                                "Diagrama de blocos idêntico ao padrão de robustez escalar.",
                                "Simulação confirma estabilidade com Δ=0.9 Wt.",
                                "||M||∞ calculado e interpretado corretamente."
                              ],
                              "assessmentCriteria": [
                                "Precisão das derivações algébricas (90% correto).",
                                "Clareza e organização do diagrama e cálculos.",
                                "Correta identificação de funções de sensibilidade.",
                                "Validação numérica/simulada completa.",
                                "Interpretação de robustez (||M||∞ <1).",
                                "Documentação com fórmulas finais destacadas."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Transformada de Laplace e manipulação de frações racionais.",
                                "Programação: Implementação em MATLAB/Python para análise de frequência.",
                                "Física: Modelagem dinâmica de plantas com incertezas paramétricas.",
                                "Otimização: Minimização de normas H-infinito para design ótimo."
                              ],
                              "realWorldApplication": "Em indústrias químicas, projetar controladores para reatores com variações de temperatura (incertezas em P), garantindo performance estável via análise de M em software como MATLAB Robust Control Toolbox, evitando falhas em plantas de produção."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.2.1.2.2",
                            "name": "Analisar o impacto das partições de M na robustez",
                            "description": "Interpretar como ||M12|| e ||M21|| afetam a sensibilidade a incertezas, relacionando com condições de estabilidade robusta via norma H∞.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a estrutura da matriz M e suas partições na forma padrão de robustez",
                                  "subSteps": [
                                    "Revise a forma padrão do bloco de robustez: M = [M11 M12; M21 M22].",
                                    "Identifique as partições: M12 (de entradas nominais para saídas de incerteza), M21 (de saídas nominais para entradas de incerteza).",
                                    "Estude o diagrama de blocos associado, destacando fluxos de sinal entre planta nominal e blocos Δ.",
                                    "Defina normas relevantes: ||M12||∞ e ||M21||∞ como medidas de ganho.",
                                    "Anote as dimensões típicas de cada partição em sistemas LIT."
                                  ],
                                  "verification": "Desenhe o diagrama de blocos de M e rotule corretamente todas as partições, confirmando com referência teórica.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Livro de Doyle et al. 'Feedback Control Theory' (cap. robustez)",
                                    "Artigo sobre μ-síntese",
                                    "Software MATLAB para visualização de blocos"
                                  ],
                                  "tips": [
                                    "Use diagramas visuais para fixar a estrutura; evite memorizar fórmulas sem contexto gráfico.",
                                    "Compare com LFT (Linear Fractional Transformation) para reforço."
                                  ],
                                  "learningObjective": "Dominar a decomposição matricial de M e seu significado físico em loops de incerteza.",
                                  "commonMistakes": [
                                    "Confundir M12 com M21 (direções erradas do sinal)",
                                    "Ignorar normas induzidas vs. espectrais",
                                    "Esquecer o papel de Δ na equação de interconexão"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar o impacto de ||M12|| na sensibilidade a perturbações de entrada",
                                  "subSteps": [
                                    "Calcule ||M12||∞ usando funções de transferência de M12(s).",
                                    "Interprete: ||M12||∞ < 1/||Δ|| garante estabilidade para perturbações Δ.",
                                    "Simule variações em entradas nominais e observe saídas de incerteza.",
                                    "Relacione com ganho de pior caso: sup norm de M12 mede amplificação máxima.",
                                    "Compare com análise small-gain theorem."
                                  ],
                                  "verification": "Compute ||M12||∞ para um sistema modelo e verifique se <1 implica robustez simulada.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "MATLAB/Simulink para computar normas H∞",
                                    "Exemplos de Skogestad 'Multivariable Feedback Control'",
                                    "Notebook para cálculos manuais"
                                  ],
                                  "tips": [
                                    "Use hinfnorm() no MATLAB para automação; valide com plots de Bode.",
                                    "Pense em termos de 'ganho de loop aberto' para intuição."
                                  ],
                                  "learningObjective": "Quantificar como M12 afeta a propagação de perturbações externas para incertezas.",
                                  "commonMistakes": [
                                    "Usar norma L2 em vez de H∞ para sistemas dinâmicos",
                                    "Negligenciar fase em análise de ganho",
                                    "Confundir com sensibilidade S = (I+GK)^-1"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar o impacto de ||M21|| na sensibilidade a incertezas paramétricas",
                                  "subSteps": [
                                    "Calcule ||M21||∞ e interprete como medida de sensibilidade da planta a Δ.",
                                    "Estude: grandes ||M21|| indicam alta dependência de parâmetros incertos.",
                                    "Simule loops com Δ escalar/multiplicativo e observe estabilidade.",
                                    "Relacione com condição robusta: ||M21||∞ * ||Δ||∞ <1.",
                                    "Discuta trade-offs: reduzir M21 pode degradar performance nominal."
                                  ],
                                  "verification": "Gere plots de ||M21(jω)|| e explique picos como pontos frágeis de robustez.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Simulink com toolbox Robust Control",
                                    "Referência Zhou 'Robust and Optimal Control'",
                                    "Planilha Excel para tracking de normas"
                                  ],
                                  "tips": [
                                    "Foque em frequências de crossover para insights práticos.",
                                    "Use weightings WΔ para normalizar incertezas."
                                  ],
                                  "learningObjective": "Entender como M21 captura vulnerabilidades a variações paramétricas.",
                                  "commonMistakes": [
                                    "Interpretar ||M21|| como performance em vez de robustez",
                                    "Omitir normalização de Δ",
                                    "Ignorar efeitos dinâmicos de Δ não-estático"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Integrar análises para condições de estabilidade robusta via norma H∞",
                                  "subSteps": [
                                    "Combine: robustez se max(||M12||∞ * ||Δ_out||, ||M21||∞ * ||Δ_in||) <1.",
                                    "Verifique structured singular value μ se múltiplas Δ.",
                                    "Aplique teorema small-gain estendido para LFT.",
                                    "Otimize via design de controladores para minimizar normas críticas.",
                                    "Avalie trade-offs com performance (via M11, M22)."
                                  ],
                                  "verification": "Para um caso teste, prove estabilidade robusta afirmando condições numéricas satisfeitas.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "MATLAB Robust Control Toolbox (mu toolbox)",
                                    "Casos de estudo em robustez aeroespacial",
                                    "Paper sobre H∞ loop shaping"
                                  ],
                                  "tips": [
                                    "Sempre cheque γ = ||M||∞ <1 como bound conservador.",
                                    "Itere simulações com Monte Carlo para validação."
                                  ],
                                  "learningObjective": "Sintetizar impactos de partições em critérios globais de robustez H∞.",
                                  "commonMistakes": [
                                    "Aplicar small-gain sem verificar comutatividade",
                                    "Confundir μ com H∞ para estruturas Δ complexas",
                                    "Subestimar conservadorismo sem μ-analysis"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um sistema de controle de posição de drone com incertezas aerodinâmicas (Δ multiplicativo na planta), compute ||M12||∞ para sensibilidade a ruídos de vento (entradas) e ||M21||∞ para variações de massa. Se ||M12||∞=0.6 e ||Δ||=1.2, robustez falha; redesign controlador para reduzir abaixo de 0.8.",
                              "finalVerifications": [
                                "Explicar verbalmente o fluxo de sinal via M12 vs. M21.",
                                "Calcular corretamente ||Mij||∞ para sistema dado.",
                                "Identificar qual partição domina em cenário específico.",
                                "Aplicar small-gain para prever estabilidade.",
                                "Discutir limitações da análise H∞.",
                                "Simular contraexemplo onde norma alta causa instabilidade."
                              ],
                              "assessmentCriteria": [
                                "Precisão em cálculos de normas H∞ (erro <5%).",
                                "Interpretação física correta dos impactos (sem confusão de partições).",
                                "Uso adequado de teoremas (small-gain, μ bounds).",
                                "Identificação de trade-offs robustez/performance.",
                                "Qualidade de simulações e plots explicativos.",
                                "Capacidade de generalizar para sistemas multivariáveis."
                              ],
                              "crossCurricularConnections": [
                                "Álgebra Linear: Decomposição matricial e normas induzidas.",
                                "Análise de Sistemas Dinâmicos: Funções de transferência e estabilidade.",
                                "Otimização: Minimização H∞ via LMIs ou loop shaping.",
                                "Probabilidade: Modelagem estocástica de incertezas Δ.",
                                "Física Aplicada: Dinâmica de veículos com perturbações reais."
                              ],
                              "realWorldApplication": "No controle de aviões comerciais (e.g., Boeing 787), análise de M12/M21 garante robustez a turbulências (Δ externas) e variações de carga (Δ paramétricas), evitando oscilações catastróficas e certificando FAA."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.2.1.2.3",
                            "name": "Implementar M em MATLAB para simulação",
                            "description": "Usar funções como 'lft' ou 'augw' do Robust Control Toolbox para gerar o bloco M a partir de modelos existentes.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Configurar ambiente MATLAB e definir modelos básicos",
                                  "subSteps": [
                                    "Inicie o MATLAB e verifique se o Robust Control Toolbox está instalado executando 'ver robustcontrol'.",
                                    "Defina o modelo nominal da planta G(s) usando tf ou ss, por exemplo, G = tf([1 2],[1 3 2]).",
                                    "Crie pesos de incerteza Δ (ex: WΔ = tf(0.1,[1 0.1])) e pesos de performance Wp (ex: Wp = tf(1,[1 10])).",
                                    "Defina perturbações ou ruídos se aplicável, como Wd para distúrbios.",
                                    "Salve os modelos em variáveis workspace para uso posterior."
                                  ],
                                  "verification": "Execute 'whos' no Command Window para confirmar que G, WΔ, Wp etc. estão definidos e são objetos sys (tf/ss).",
                                  "estimatedTime": "20 minutos",
                                  "materials": "MATLAB instalado, Robust Control Toolbox, documentação oficial do toolbox (help lft, help augw)",
                                  "tips": "Use 'pack' para otimizar modelos sys e reduzir tamanho computacional.",
                                  "learningObjective": "Entender e preparar os componentes básicos necessários para a estrutura de robustez.",
                                  "commonMistakes": "Esquecer de converter modelos para ss se necessário (tf para ss via ss(tf)); definir pesos com polos instáveis."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Construir a planta generalizada P usando augw",
                                  "subSteps": [
                                    "Estruture os sinais: entradas [referência, distúrbio, controle, incerteza] e saídas [erro, saída planta, controle, incerteza medida].",
                                    "Use augw(P, Wp, 'p', Wu, 'u', positions) para adicionar pesos de performance e controle, onde P inicial é G.",
                                    "Exemplo: P = augw(G, Wp, [], Wu, WΔ); ajuste posições conforme diagrama de blocos.",
                                    "Verifique a estrutura de P com 'size(P)' para confirmar dimensões de entradas/saídas.",
                                    "Plotar singular values iniciais com sigma(P) para inspeção visual."
                                  ],
                                  "verification": "size(P) retorna dimensões corretas (ex: 4 entradas, 4 saídas para estrutura padrão) e sigma(P) plota sem erros.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Modelos do Step 1, função augw (help augw), diagramas de blocos de robustez impressos",
                                  "tips": "Sempre especifique posições exatas de entradas/saídas para evitar mismatch.",
                                  "learningObjective": "Dominar a função augw para criar plantas generalizadas com pesos.",
                                  "commonMistakes": "Ordem errada de argumentos em augw; não balancear sinais (use balreal(P))."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Gerar o bloco M usando lft para interconexão",
                                  "subSteps": [
                                    "Defina o bloco de incertezas Δ como blkdiag para múltiplas (ex: Delta = blkdiag(WΔ, outros)).",
                                    "Compute M = lft(P, Delta) para conectar Δ na planta P.",
                                    "Alternativa: use sysic para estruturas mais complexas se lft não bastar.",
                                    "Verifique estabilidade de M com pole(M) ou isstable(M).",
                                    "Analise normas com norm(M, inf) ou mu(M) se mu-toolbox disponível."
                                  ],
                                  "verification": "M é um objeto sys válido, isstable(M) retorna true, e size(M) matches expectativas (sem Δ ports).",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Planta P do Step 2, função lft (help lft), Robust Control Toolbox",
                                  "tips": "Use minreal(M) para reduzir ordem após lft e melhorar performance.",
                                  "learningObjective": "Aplicar lft para extrair o bloco M da interconexão P-Δ.",
                                  "commonMistakes": "Conectar Δ nas portas erradas; ignorar singularidades (verifique det)."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Simular e validar o bloco M",
                                  "subSteps": [
                                    "Gere sinais de entrada como step, impulse ou randn para simulação.",
                                    "Execute simulação com lsim(M, u, t) ou step(M).",
                                    "Plote respostas com stepinfo(M) ou bode(M) para análise de robustez.",
                                    "Compare sigma(M(jw)) <1 para todos ω para verificar robustez.",
                                    "Salve resultados em figura ou workspace para relatório."
                                  ],
                                  "verification": "Plots mostram ||M||_∞ <1 ou sigma max <1, sem instabilidades na simulação.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Bloco M do Step 3, funções plot (bode, sigma, step), tempo de simulação t=linspace(0,10,1000)",
                                  "tips": "Use griddata para análise de sigma em frequências logspaced.",
                                  "learningObjective": "Simular M e interpretar resultados para robustez.",
                                  "commonMistakes": "Escala errada no plot (use logscale); simular sem checar estabilidade."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Analisar robustez e documentar",
                                  "subSteps": [
                                    "Calcule mu(M) ou H∞ norm com hinfnorm(M).",
                                    "Teste com variações paramétricas em G (ex: ±20% ganho).",
                                    "Gere relatório com publish ou diary.",
                                    "Arquive código em .m script com comentários.",
                                    "Compartilhe via MATLAB Drive se colaborativo."
                                  ],
                                  "verification": "Relatório confirma ||M||_∞ <1 e estabilidade sob variações.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Resultados anteriores, hinfnorm, publish",
                                  "tips": "Automatize com loops para uncertainty sweeps.",
                                  "learningObjective": "Interpretar simulações de M para decisões de design.",
                                  "commonMistakes": "Sobrepor pesos inadequados; ignorar fase em bode plots."
                                }
                              ],
                              "practicalExample": "Para um controlador de posição de motor DC com incerteza de 20% no ganho, defina G(s)=100/(s(s+1)), WΔ=0.2/(1+0.1s), Wp=1/(s+0.1), Wu=0.1. Construa P=augw(G,Wp,[],Wu,WΔ), M=lft(P,WΔ), simule step(M) e verifique sigma(M)<1 para robustez contra variações.",
                              "finalVerifications": [
                                "M gerado é estável (isstable(M)==true).",
                                "Dimensões de P e M corretas (sem portas Δ em M).",
                                "Simulações step/bode executam sem erros e plots coerentes.",
                                "||M||_∞ <1 confirmado via hinfnorm(M).",
                                "Código .m roda end-to-end sem warnings.",
                                "Análise resiste a ±20% variação paramétrica."
                              ],
                              "assessmentCriteria": [
                                "Precisão na construção de P com augw (estrutura de sinais correta).",
                                "Correta aplicação de lft para M (conexão Δ exata).",
                                "Qualidade das simulações e plots (legíveis, analisados).",
                                "Interpretação de robustez (sigma<1, normas).",
                                "Documentação completa (comentários, relatório).",
                                "Eficiência computacional (modelos reduzidos)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática Linear: Valores singulares e normas H∞.",
                                "Programação: Scripting MATLAB, vetores tempo/freq.",
                                "Física/Engenharia: Modelagem dinâmica LIT de sistemas reais.",
                                "Estatística: Análise de Monte Carlo para uncertainties."
                              ],
                              "realWorldApplication": "Em controle de aeronaves (ex: estabilização de flaps com incertezas aerodinâmicas), onde M simula robustez contra variações de vento, garantindo estabilidade sem redesign do controlador."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.2.2.1.3",
                        "name": "Bloco de Incerteza Δ",
                        "description": "Bloco estruturado representando todas as incertezas normalizadas, com norma ||Δ||∞ ≤ 1 garantindo estabilidade robusta quando ||M||∞ < 1/||Δ||.",
                        "specificSkills": [
                          {
                            "id": "10.1.2.2.1.3.1",
                            "name": "Modelar incertezas comuns como blocos Δ",
                            "description": "Representar incertezas aditivas, multiplicativas na entrada/saída e incertezas de fase como blocos Δii com normas unitárias, usando pesos de incerteza.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender os tipos fundamentais de incertezas em sistemas LIT",
                                  "subSteps": [
                                    "Revise incertezas aditivas (ex.: ruído na medição)",
                                    "Identifique incertezas multiplicativas na entrada/saída (ex.: ganho variável)",
                                    "Estude incertezas de fase (ex.: atrasos ou variações dinâmicas)",
                                    "Analise exemplos de sistemas monovariáveis com essas incertezas",
                                    "Compare com modelos nominais sem incerteza"
                                  ],
                                  "verification": "Liste os três tipos de incertezas com um exemplo cada em um diagrama simples",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Livro de Controle Avançado (cap. Robustez)",
                                    "Slides de aula sobre LIT",
                                    "Papel e caneta para diagramas"
                                  ],
                                  "tips": [
                                    "Use analogias reais como ruído em sensores para fixar conceitos",
                                    "Desenhe diagramas de bloco iniciais"
                                  ],
                                  "learningObjective": "Classificar e exemplificar incertezas comuns em sistemas lineares invariantes no tempo (LIT)",
                                  "commonMistakes": [
                                    "Confundir aditiva com multiplicativa",
                                    "Ignorar o impacto na fase"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Representar incertezas aditivas e multiplicativas como blocos Δ",
                                  "subSteps": [
                                    "Desenhe o diagrama de bloco nominal do sistema",
                                    "Insira bloco Δ_add para incerteza aditiva na saída ou entrada",
                                    "Posicione Δ_mult na entrada/saída com estrutura multiplicativa (1 + Δ)",
                                    "Defina a norma unitária ||Δ|| ≤ 1 para cada bloco",
                                    "Teste com um sistema simples como um amplificador"
                                  ],
                                  "verification": "Construa e rotule um diagrama de bloco com Δ_add e Δ_mult corretos",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Software MATLAB/Simulink",
                                    "Templates de diagramas de bloco",
                                    "Exemplos resolvidos de robustez"
                                  ],
                                  "tips": [
                                    "Sempre normalize Δ para ||Δ||∞ ≤ 1",
                                    "Verifique conexões no diagrama"
                                  ],
                                  "learningObjective": "Construir representações bloco-diagrama para incertezas aditivas/multiplicativas",
                                  "commonMistakes": [
                                    "Posicionar Δ incorretamente no loop",
                                    "Esquecer a estrutura (1 + Δ)"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Modelar incertezas de fase como blocos Δ com normas unitárias",
                                  "subSteps": [
                                    "Identifique incertezas de fase em elementos dinâmicos (ex.: atraso)",
                                    "Represente como Δ_phase no caminho de fase do sistema",
                                    "Aplique norma unitária H∞ ou similar para Δ_phase",
                                    "Integre com blocos anteriores em um diagrama unificado",
                                    "Simule resposta em frequência para validar"
                                  ],
                                  "verification": "Simule e plote Bode com/sem Δ_phase mostrando variação",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "MATLAB Control System Toolbox",
                                    "Ferramenta de plotagem de Bode online"
                                  ],
                                  "tips": [
                                    "Foco em perturbações de fase em sistemas de alto ganho",
                                    "Use tf() para modelos simples"
                                  ],
                                  "learningObjective": "Incorporar incertezas de fase em blocos Δ normalizados",
                                  "commonMistakes": [
                                    "Usar norma errada (L1 em vez de ∞)",
                                    "Subestimar impacto em estabilidade"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar pesos de incerteza e validar a forma padrão de robustez",
                                  "subSteps": [
                                    "Defina pesos W_Δ para cada bloco (ex.: W_add para aditiva)",
                                    "Conecte pesos: Peso * Δ * Peso^{-1} para normalização",
                                    "Verifique se ||Δ_ii|| ≤ 1 em todos os casos",
                                    "Construa o diagrama completo de incertezas interconectadas",
                                    "Analise estabilidade com μ-síntese básica"
                                  ],
                                  "verification": "Gere diagrama final com pesos e confirme normas unitárias",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Documentação μ-toolbox MATLAB",
                                    "Exercícios de robustez resolvidos"
                                  ],
                                  "tips": [
                                    "Escolha pesos baseados em dados experimentais reais",
                                    "Teste estabilidade com loopshaping"
                                  ],
                                  "learningObjective": "Finalizar modelagem com pesos para análise de robustez",
                                  "commonMistakes": [
                                    "Pesos mal calibrados levando a ||Δ|| >1",
                                    "Ignorar interconexões Δ_ii"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um sistema de controle de posição de um motor DC, modele ruído aditivo no sensor como Δ_add na saída, variação de ganho do atuador como Δ_mult na entrada, e atraso de fase como Δ_phase, usando pesos W para normalizar e analisar robustez contra variações de carga.",
                              "finalVerifications": [
                                "Diagrama de bloco completo com todos Δii corretamente posicionados",
                                "Confirmação de normas unitárias para cada Δ",
                                "Simulação mostrando estabilidade com incertezas",
                                "Pesos de incerteza justificados com bounds reais",
                                "Análise qualitativa de robustez no diagrama"
                              ],
                              "assessmentCriteria": [
                                "Precisão na representação de tipos de incerteza (aditiva/multiplicativa/fase)",
                                "Correta aplicação de normas unitárias e pesos",
                                "Clareza e legibilidade do diagrama de blocos",
                                "Validação via simulação ou análise",
                                "Identificação de erros comuns evitados"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria de normas (H∞) e análise funcional",
                                "Física: Dinâmica de sistemas reais com ruído e atrasos",
                                "Informática: Simulação em MATLAB/Simulink",
                                "Estatística: Modelagem de incertezas probabilísticas"
                              ],
                              "realWorldApplication": "Projeto de controladores robustos para drones, onde variações de vento (aditiva), eficiência de motores (multiplicativa) e atrasos de comunicação (fase) são modeladas como Δ para garantir estabilidade em voo autônomo."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.2.1.3.2",
                            "name": "Verificar a condição de robustez ||M(jω)|| < 1/||Δ(jω)||",
                            "description": "Aplicar o teorema de pequena ganho para estabilidade robusta e calcular o valor de μ para estruturas de Δ não escalares.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Fundamentos do Teorema de Pequena Ganho e Forma Padrão de Robustez",
                                  "subSteps": [
                                    "Estude o teorema de pequena ganho: lembre que um sistema fechado é estável se ||Δ|| * ||M|| < 1 para todas as frequências ω.",
                                    "Identifique a estrutura da forma padrão: sistema M-Δ onde Δ representa incertezas normalizadas.",
                                    "Diferencie Δ escalar de não escalar: para não escalar, introduza o valor singular estruturado μ(Δ).",
                                    "Revise normas relevantes: norma H∞ para ||M(jω)||∞ e norma espectral para ||Δ(jω)||.",
                                    "Pratique com diagramas de bloco para visualizar o loop M-Δ."
                                  ],
                                  "verification": "Explique verbalmente ou por escrito o teorema e desenhe o diagrama da forma padrão corretamente.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Livro de controle avançado (e.g., Zhou, Doyle, Glover)",
                                    "Notas de aula sobre robustez",
                                    "Software MATLAB/Simulink para visualização"
                                  ],
                                  "tips": "Sempre normalize Δ para ||Δ|| ≤ 1 para simplificar a análise.",
                                  "learningObjective": "Compreender a base teórica do teorema de pequena ganho aplicado à robustez.",
                                  "commonMistakes": [
                                    "Confundir norma H∞ com norma espectral",
                                    "Ignorar a dependência em ω",
                                    "Esquecer normalização de Δ"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Modelar o Bloco de Incerteza Δ para Casos Não Escalares",
                                  "subSteps": [
                                    "Defina a estrutura de Δ: bloco diagonal ou full com dimensões conhecidas (e.g., Δ = blkdiag(Δ1, Δ2)).",
                                    "Calcule ||Δ(jω)||: use valor singular máximo σ_max(Δ(jω)) para cada frequência.",
                                    "Para Δ não escalar, introduza μ(Δ) = 1 / min{β : det(I - β M Δ) ≠ 0}, mas foque em interpretação.",
                                    "Gere ou use um modelo de incerteza real (e.g., variação paramétrica convertida para Δ).",
                                    "Valide o modelo plotando ||Δ(jω)|| vs. ω."
                                  ],
                                  "verification": "Produza um gráfico de ||Δ(jω)|| que mostre variação com ω e explique picos.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "MATLAB Robust Control Toolbox",
                                    "Exemplos de incertezas de Skogestad ou Doyle",
                                    "Papel e lápis para esboços"
                                  ],
                                  "tips": "Use mu-toolbox no MATLAB para Δ estruturados; teste com Δ simples primeiro.",
                                  "learningObjective": "Modelar corretamente blocos de incerteza escalares e não escalares.",
                                  "commonMistakes": [
                                    "Usar norma errada para Δ (e.g., norma 2 em vez de ∞)",
                                    "Não considerar estrutura block-diagonal",
                                    "Normalizar incorretamente"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular a Norma de M(jω) e Verificar a Condição de Robustez",
                                  "subSteps": [
                                    "Construa a matriz de transferência M(s) a partir do sistema nominal e pesos de incerteza.",
                                    "Compute ||M(jω)|| usando sigma plot no MATLAB: σ_max(M(jω)) para cada ω.",
                                    "Verifique a condição: plote ||M(jω)|| e 1/||Δ(jω)||; cheque se ||M(jω)|| < 1/||Δ(jω)|| ∀ω.",
                                    "Identifique frequências críticas onde a condição é mais apertada.",
                                    "Calcule margem de robustez: min_ω [1/||Δ(jω)|| / ||M(jω)|| ]."
                                  ],
                                  "verification": "Gere plots de Bode ou singular values mostrando a condição satisfeita em todo o espectro.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "MATLAB com Robust Control Toolbox (sel, sigma, mu comandos)",
                                    "Sistema exemplo em .mat",
                                    "Calculadora para valores manuais"
                                  ],
                                  "tips": "Use logspace para ω denso; amplie plots em regiões de crossover.",
                                  "learningObjective": "Aplicar cálculo de normas e verificar numericamente a condição de robustez.",
                                  "commonMistakes": [
                                    "Plotar apenas ganho em vez de σ_max",
                                    "Esquecer de avaliar em todo ω",
                                    "Confundir M com o sistema nominal"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Calcular μ para Δ Não Escalares e Interpretar Estabilidade Robusta",
                                  "subSteps": [
                                    "Defina μ(Δ) = max{σ_bar(Δ) : Δ pertence estrutura, ||Δ||=1} usando mu toolbox.",
                                    "Compute μ(M(jω)) e verifique se μ(M(jω)) < 1/||Δ|| para robustez.",
                                    "Interprete: se max_ω μ(M(jω)) < 1, sistema é robustamente estável.",
                                    "Compare com small-gain: μ oferece bound mais apertado para estruturas.",
                                    "Documente conclusões em relatório com plots e valores numéricos."
                                  ],
                                  "verification": "Relatório com cálculo de max μ e afirmação correta de estabilidade robusta.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Mu-Toolbox para MATLAB",
                                    "Documentos de referência (e.g., Packwood notes)",
                                    "Template de relatório LaTeX"
                                  ],
                                  "tips": "Para Δ complexos, use mussv comando; valide com small-gain conservador.",
                                  "learningObjective": "Calcular e interpretar μ para análise de robustez avançada.",
                                  "commonMistakes": [
                                    "Usar svd em vez de μ para estruturas",
                                    "Ignorar upper/lower bounds de μ",
                                    "Concluir estabilidade sem checar max_ω"
                                  ]
                                }
                              ],
                              "practicalExample": "Considere um controlador PID para um motor DC com incerteza de 20% no ganho K. Modele Δ como escalar |Δ(jω)| = 0.2. Construa M(s) = [W_e * P * C; I W_u * C], compute ||M(jω)||∞ < 5 para robustez (1/0.2=5). Para não escalar, adicione Δ_param e Δ_perf block-diagonal, calcule μ(M) <1.",
                              "finalVerifications": [
                                "Plots de σ_max(M(jω)) e 1/||Δ(jω)|| mostram interseção ausente.",
                                "Valor máximo de μ(M(jω)) <1 calculado corretamente.",
                                "Explicação escrita liga teorema small-gain à condição.",
                                "Identificação precisa de incertezas no modelo.",
                                "Conclusão de estabilidade robusta justificada numericamente.",
                                "Margem de robustez quantificada (e.g., >1.2)."
                              ],
                              "assessmentCriteria": [
                                "Precisão nos cálculos de normas (erro <1%).",
                                "Correta modelagem de Δ estruturado.",
                                "Interpretação qualitativa e quantitativa da robustez.",
                                "Uso adequado de ferramentas computacionais.",
                                "Clareza em plots e relatório.",
                                "Identificação de trade-offs (e.g., performance vs. robustez)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Análise de valores singulares e funções de transferência complexas.",
                                "Programação: Implementação numérica em MATLAB/Python (controle libraries).",
                                "Física: Modelagem de dinâmicas reais com incertezas (e.g., aerodinâmica).",
                                "Estatística: Análise de sensibilidade e Monte Carlo para validação.",
                                "Engenharia de Software: Documentação de análises de robustez em projetos."
                              ],
                              "realWorldApplication": "Em controle de flight de aviões (e.g., F-16), verifica se controladores permanecem estáveis apesar de variações aerodinâmicas modeladas por Δ; usado pela NASA e Boeing para certificação de safety."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.2.1.3.3",
                            "name": "Simular loops M-Δ em ferramentas computacionais",
                            "description": "Utilizar comandos como 'musyn' ou 'lftdata' no MATLAB para interconectar M e Δ e analisar estabilidade robusta via singular values.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar o ambiente MATLAB e definir o sistema nominal e incerteza Δ",
                                  "subSteps": [
                                    "Instale e carregue o Robust Control Toolbox no MATLAB com o comando 'robustcontrol'.",
                                    "Defina o sistema nominal P(s) usando tf ou ss, por exemplo, um sistema massa-mola: P(s) = 1/(s^2 + s + 1).",
                                    "Modele a incerteza Δ como um bloco norm-bounded, ex: Delta = ultidyn('Delta',1,'Bound',0.2).",
                                    "Estruture o sistema generalizado com incertezas usando uncertain models.",
                                    "Salve os modelos em variáveis workspace para uso posterior."
                                  ],
                                  "verification": "Execute 'get(Delta)' para confirmar propriedades da incerteza e 'bode(P)' para visualizar o sistema nominal.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "MATLAB R2020b+, Robust Control Toolbox, documentação MATLAB para uncertain models.",
                                  "tips": "Use 'ufrd' para dados frequenciais se necessário; sempre verifique unidades de frequência.",
                                  "learningObjective": "Compreender modelagem de sistemas incertos no MATLAB.",
                                  "commonMistakes": "Esquecer de carregar toolbox causando erros de comando; definir Delta sem bound superior."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Construir a interconnection M usando comandos como lftdata",
                                  "subSteps": [
                                    "Estruture o sistema em forma LFT: [M, Delta_info] = lftdata(P, Delta_pos).",
                                    "Use 'lft(P, Delta)' para formar a interconnection linear fractional transformation.",
                                    "Incorpore o controlador K se aplicável: M = lft(P, K).",
                                    "Verifique dimensões de entrada/saída com 'size(M)'.",
                                    "Gere uma instância nominal com 'usample(M,1)'."
                                  ],
                                  "verification": "Confirme que M é um uss (uncertain state-space) model com 'class(M)' e sem erros de dimensão.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Documentação lftdata e lft no help MATLAB; exemplos do Robust Control Toolbox demo.",
                                  "tips": "lftdata extrai M e info de um LFT existente; use para decompor sistemas complexos.",
                                  "learningObjective": "Dominar construção de loops M-Δ via LFTs.",
                                  "commonMistakes": "Mismatch nas dimensões de Δ e ports de M; não usar 'nominal(M)' para análise inicial."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Simular o loop M-Δ interconnection",
                                  "subSteps": [
                                    "Forme o loop fechado: Loop = feedback(M,1) ou lft(M,eye(size(Delta))).",
                                    "Gere respostas em frequência: w = logspace(-2,2,1000); [re,w] = sigma(M,w).",
                                    "Simule instâncias aleatórias: M_rand = usample(M,50); sigma(M_rand,w).",
                                    "Plote singular values: sigma(M,'r-',w); grid on.",
                                    "Analise com mu-toolbox se disponível: mu = musyn(...,M)."
                                  ],
                                  "verification": "Plots gerados sem warnings; loop bem definido com 'isproper(Loop) == true'.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Funções sigma, usample, feedback; script de exemplo salvo como .m.",
                                  "tips": "Use 'wcgain' para worst-case gain; acelere plots com 'semilogx'.",
                                  "learningObjective": "Executar simulações de loops incertos.",
                                  "commonMistakes": "Não linearizar corretamente para sigma plots; ignorar fase em análises iniciais."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar estabilidade robusta via singular values",
                                  "subSteps": [
                                    "Calcule sigma_max(M(jw)) e sigma_min(Δ(jw)) em todo range de ω.",
                                    "Verifique small-gain theorem: max_w [sigma_bar(M(jw)) * sigma(Δ(jw))] < 1.",
                                    "Gere upper bound mu: [mu_upper, wc] = mussv(M,w).",
                                    "Interprete: Se ||M||_infty < 1/||Δ||_infty, estável.",
                                    "Documente conclusões em relatório com plots."
                                  ],
                                  "verification": "Condição de estabilidade satisfeita nos plots; mu <1 em todas frequências.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Funções sigma, mussv; exportar figuras para PDF.",
                                  "tips": "Zoom em crossover frequencies; use 'robuststab' para teste automático.",
                                  "learningObjective": "Interpretar análises de robustez quantitativamente.",
                                  "commonMistakes": "Confundir sigma_bar com sigma_underline; não checar DC e high-freq."
                                }
                              ],
                              "practicalExample": "Considere um controlador PID para um motor DC com incerteza de 20% no ganho: defina P(s)=K/(s(Js+B)), Δ=ultidyn('delta',1,'Bound',0.2), forme M=lft(P,K_pid), simule sigma(M) vs 1/|Δ|, confirmando estabilidade se sigma_max(M)<5.",
                              "finalVerifications": [
                                "Loop M-Δ simulado sem erros de MATLAB.",
                                "Singular value plots gerados e legíveis.",
                                "Condição small-gain verificada para estabilidade.",
                                "Instâncias aleatórias mostram consistência.",
                                "Relatório com interpretação escrito.",
                                "Código reproduzível salvo em .m."
                              ],
                              "assessmentCriteria": [
                                "Corretude na modelagem de M e Δ (dimensões e bounds).",
                                "Precisão dos plots de singular values (escala log, grid).",
                                "Aplicação correta do small-gain theorem.",
                                "Análise de worst-case scenarios com usample.",
                                "Clareza na interpretação de robustez.",
                                "Eficiência do código (sem loops desnecessários)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Decomposição em valores singulares (SVD) e análise em frequência.",
                                "Programação: Scripting avançado em MATLAB com toolboxes.",
                                "Física: Dinâmica de sistemas com incertezas paramétricas.",
                                "Estatística: Análise de ensembles com usample para variabilidade."
                              ],
                              "realWorldApplication": "Em controle de drones, simular M-Δ para incertezas aerodinâmicas garante estabilidade robusta contra variações de vento, evitando crashes em missões autônomas."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.2.3",
                    "name": "Análise de Estabilidade Robusta",
                    "description": "Critérios para estabilidade robusta utilizando o teorema do ganho pequeno e norma H∞.",
                    "individualConcepts": [
                      {
                        "id": "10.1.2.3.1",
                        "name": "Teorema do Ganho Pequeno",
                        "description": "O teorema do ganho pequeno fornece um critério suficiente para a estabilidade robusta de sistemas de laço fechado LIT sujeitos a incertezas normadas, estabelecendo que o sistema é estável se o produto das normas das funções de transferência de incerteza e complementar for menor que 1.",
                        "specificSkills": [
                          {
                            "id": "10.1.2.3.1.1",
                            "name": "Enunciar o teorema do ganho pequeno",
                            "description": "Explicar formalmente o teorema do ganho pequeno para sistemas interconectados, incluindo as condições de norma indutiva e o critério ||Δ|| ⋅ ||M|| < 1 para estabilidade, com exemplos de incertezas normadas por norma H∞.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os conceitos fundamentais de sistemas interconectados",
                                  "subSteps": [
                                    "Defina um sistema linear invariante no tempo (LIT) nominal M(s).",
                                    "Explique a interconexão com uma perturbação Δ(s), formando o sistema fechado.",
                                    "Revise normas de sistemas LIT, focando na norma H∞ como medida de ganho.",
                                    "Identifique a norma indutiva como supremo de ||M|| sobre todas as entradas admissíveis.",
                                    "Diferencie norma indutiva de outras normas como H2 ou L2."
                                  ],
                                  "verification": "Liste e defina corretamente os 5 conceitos principais sem erros.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Livro de Doyle et al. 'Feedback Control Theory'",
                                    "Notas sobre normas H∞",
                                    "Software MATLAB para visualização de normas"
                                  ],
                                  "tips": "Comece revisando exemplos simples de interconexões para fixar ideias.",
                                  "learningObjective": "Dominar terminologia e pré-requisitos para o teorema.",
                                  "commonMistakes": [
                                    "Confundir norma H∞ (ganho máximo) com norma L2 (energia), ignorar que Δ é estável mas desconhecida."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Enunciar formalmente o teorema do ganho pequeno",
                                  "subSteps": [
                                    "Escreva o enunciado: 'O sistema interconectado M Δ é bem-posto e estável se ||Δ|| ⋅ ||M||_i < 1, onde ||M||_i é a norma indutiva'.",
                                    "Descreva a hipótese: M e Δ são LIT estáveis, Δ pertence a um conjunto de incertezas normadas.",
                                    "Explique 'bem-posto' como a existência única de solução para a interconexão.",
                                    "Forneça a notação padrão: [P11 P12; P21 P22] para M e Δ no loop.",
                                    "Reescreva o teorema para o caso de incertezas aditivas ou multiplicativas."
                                  ],
                                  "verification": "Escreva o enunciado completo de cor e identifique todas as componentes.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Artigo original de Zames ou Vidyasagar",
                                    "Folha de anotações",
                                    "Quadro branco para diagrama"
                                  ],
                                  "tips": "Use diagramas de blocos para visualizar a interconexão antes de memorizar.",
                                  "learningObjective": "Reproduzir o enunciado preciso do teorema.",
                                  "commonMistakes": [
                                    "Omitir 'bem-posto', confundir com teorema pequeno ganho de Zames (versão escalar)."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explicar as condições de norma indutiva",
                                  "subSteps": [
                                    "Defina norma indutiva ||M||_i = sup_{||d||=1} ||M d||_∞ para sinais em tempo contínuo.",
                                    "Discuta por que norma indutiva é usada: captura pior caso de perturbações.",
                                    "Compare com norma H∞: ||M||_∞ ≤ ||M||_i ≤ n ||M||_∞ (n=ordem).",
                                    "Verifique estabilidade via pequeno ganho: se ||Δ||_∞ ||M||_∞ < 1/γ com γ conservador.",
                                    "Analise quando norma indutiva é finita (M estável causal)."
                                  ],
                                  "verification": "Calcule ||M||_i para um exemplo simples e compare com ||M||_∞.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "MATLAB com toolbox Control System",
                                    "Exemplos resolvidos de Zhou et al.",
                                    "Calculadora simbólica"
                                  ],
                                  "tips": "Pratique com sistemas de baixa ordem para intuir a norma indutiva.",
                                  "learningObjective": "Entender e justificar o uso da norma indutiva no teorema.",
                                  "commonMistakes": [
                                    "Achar que norma indutiva é sempre igual a H∞, ignorar causalidade."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar o critério de estabilidade com exemplos de incertezas H∞",
                                  "subSteps": [
                                    "Aplique critério: sistema estável se ||Δ||_∞ ⋅ ||M||_i < 1.",
                                    "Exemplo 1: Incerteza aditiva em planta G(s) = G0(s)(I + Δ(s)), com ||Δ||_∞ < 0.1.",
                                    "Exemplo 2: Incerteza multiplicativa em controlador, verificando ganho pequeno.",
                                    "Simule violação: ||Δ||_∞ ⋅ ||M||_∞ = 1.2 → instável.",
                                    "Discuta robustez: teorema garante estabilidade para todas Δ no conjunto."
                                  ],
                                  "verification": "Resolva 2 exemplos numéricos confirmando estabilidade/instabilidade.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Simulink para simulação",
                                    "Exercícios de Skogestad e Postlethwaite",
                                    "Python com control library"
                                  ],
                                  "tips": "Sempre normalize incertezas para ||Δ||_∞ ≤ 1 e escale M.",
                                  "learningObjective": "Usar o teorema para análise de robustez prática.",
                                  "commonMistakes": [
                                    "Usar norma errada no critério, esquecer de verificar bem-posedness."
                                  ]
                                }
                              ],
                              "practicalExample": "Em um sistema de controle de voo de um drone, o modelo nominal M(s) inclui dinâmica aerodinâmica e controlador PID. Uma incerteza Δ(s) modela variação de 20% nos coeficientes de arrasto (||Δ||_∞ ≈ 0.2). Calcule ||M||_i ≈ 4; como 0.2 × 4 = 0.8 < 1, o sistema é robustamente estável contra essa incerteza.",
                              "finalVerifications": [
                                "Enuncie o teorema completo sem omissões.",
                                "Defina e diferencie norma H∞ e indutiva.",
                                "Aplique critério a um exemplo dado.",
                                "Identifique quando o teorema não se aplica (ex: Δ instável).",
                                "Explique implicações para robustez.",
                                "Simule um caso limite no software."
                              ],
                              "assessmentCriteria": [
                                "Precisão no enunciado formal (100% correto).",
                                "Compreensão conceitual de normas (explicação clara).",
                                "Capacidade de aplicação em exemplos (cálculos exatos).",
                                "Identificação de condições e limitações.",
                                "Uso correto de terminologia técnica.",
                                "Criatividade em extensões (ex: μ-síntese)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria de operadores e normas em espaços de Banach.",
                                "Física: Modelagem de sistemas dinâmicos com perturbações reais.",
                                "Informática: Implementação numérica em MATLAB/Simulink para análise.",
                                "Engenharia Mecânica: Controle robusto em atuadores com incertezas.",
                                "Economia: Análise de risco em sistemas interconectados (modelos semelhantes)."
                              ],
                              "realWorldApplication": "No design de controladores para satélites, onde incertezas em parâmetros orbitais (modeladas por Δ H∞) devem satisfazer ||Δ|| ⋅ ||M|| < 1 para garantir estabilidade apesar de variações térmicas e envelhecimento de componentes."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.3.1.2",
                            "name": "Aplicar o teorema em modelos de incerteza",
                            "description": "Modelar incertezas aditivas, multiplicativas ou inversas em sistemas LIT escalares e verificar estabilidade robusta computando as normas relevantes e aplicando o critério do ganho pequeno.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Definir o sistema nominal LIT escalar e identificar o tipo de incerteza",
                                  "subSteps": [
                                    "Descreva o sistema nominal G(s) em função de transferência ou espaço de estados.",
                                    "Classifique a incerteza como aditiva (ΔG), multiplicativa (Δ(s)G(s)) ou inversa (G(s)(I + Δ(s)))^{-1}).",
                                    "Esboce a estrutura de incerteza usando blocos de diagrama.",
                                    "Especifique as suposições: sistema escalar LIT estável nominalmente.",
                                    "Documente os limites conhecidos da norma da incerteza ||Δ||_∞."
                                  ],
                                  "verification": "Confirme que o diagrama de estrutura de incerteza está corretamente desenhado e rotulado.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Papel ou software de diagramação (ex: Draw.io), referência ao teorema do ganho pequeno.",
                                  "tips": "Comece sempre pelo sistema nominal puro antes de adicionar incertezas.",
                                  "learningObjective": "Compreender e representar modelos de incerteza em sistemas LIT escalares.",
                                  "commonMistakes": "Confundir incerteza aditiva com multiplicativa; ignorar que é escalar."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Calcular as normas relevantes do sistema com incertezas",
                                  "subSteps": [
                                    "Determine a matriz de transferência de interconexão M(s) ou T(s) para o tipo de incerteza.",
                                    "Compute a norma H-infinito ||M||_∞ ou ||T||_∞ usando MATLAB/Simulink ou fórmula analítica.",
                                    "Para incerteza aditiva: ||G||_∞; multiplicativa: ||KG||_∞ onde K é controlador; etc.",
                                    "Valide o cálculo com plot de singular values (σ_max).",
                                    "Registre o valor numérico de ||Δ||_∞ máxima admissível."
                                  ],
                                  "verification": "Verifique se ||M||_∞ foi calculado corretamente comparando com simulação numérica.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "MATLAB com toolbox Control Systems, calculadora simbólica (ex: Mathematica).",
                                  "tips": "Use comando hinfnorm() no MATLAB para eficiência.",
                                  "learningObjective": "Dominar o cálculo de normas H-infinito em contextos de robustez.",
                                  "commonMistakes": "Usar norma L2 em vez de H-infinito; esquecer de estabilizar loops internos."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Aplicar o critério do teorema do ganho pequeno para verificar estabilidade robusta",
                                  "subSteps": [
                                    "Enuncie o teorema: sistema robustamente estável se ||M||_∞ * sup||Δ||_∞ < 1.",
                                    "Substitua os valores computados: verifique se ||M||_∞ < 1 / ||Δ||_∞.",
                                    "Analise o margem de robustez: quanto <1 indica quão robusto.",
                                    "Teste sensibilidade variando ||Δ||_∞ em ±20%.",
                                    "Conclua: estável robusto ou não, e sugira ajustes."
                                  ],
                                  "verification": "A condição ||M||_∞ * ||Δ||_∞ < 1 é explicitamente satisfeita com números.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Planilha ou script MATLAB para cálculos sensíveis.",
                                  "tips": "Lembre: teorema é suficiente mas não necessário; use para garantia conservadora.",
                                  "learningObjective": "Aplicar corretamente o critério de ganho pequeno para análise qualitativa e quantitativa.",
                                  "commonMistakes": "Inverter a condição (>1 em vez de <1); ignorar sup||Δ||."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Interpretar resultados e propor melhorias para robustez",
                                  "subSteps": [
                                    "Discuta implicações: se falha, identifique fonte (alta ganho em frequências críticas).",
                                    "Sugira redesenho: reduzir ||M||_∞ via filtro ou redesign de controlador.",
                                    "Simule com Δ real para validar teorema.",
                                    "Documente relatório com gráficos de Bode e σ(ω).",
                                    "Compare com método μ para lições aprendidas."
                                  ],
                                  "verification": "Relatório inclui interpretação, simulação e sugestões acionáveis.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "MATLAB Simulink para simulações com incertezas parametrizadas.",
                                  "tips": "Sempre simule para ganhar intuição além do teorema analítico.",
                                  "learningObjective": "Integrar análise teórica com simulação prática para decisões de engenharia.",
                                  "commonMistakes": "Aceitar teorema sem simulação; propor mudanças sem justificativa normativa."
                                }
                              ],
                              "practicalExample": "Considere um sistema de controle de temperatura de forno G(s) = 1/(s+1) com incerteza multiplicativa Δ(s) = 0.2 * (1/(s+0.1)). Calcule ||W G||_∞ onde W é peso, verifique se <5 (1/||Δ||_∞=5), confirmando estabilidade robusta contra variações de ganho de ±20%.",
                              "finalVerifications": [
                                "Diagrama de incerteza corretamente modelado.",
                                "||M||_∞ calculado com precisão <1% de erro.",
                                "Condição do teorema verificada numericamente.",
                                "Simulação com Δ máxima mostra estabilidade.",
                                "Relatório inclui gráficos de normas e interpretação.",
                                "Margem de robustez quantificada (>20%)."
                              ],
                              "assessmentCriteria": [
                                "Precisão no modelado de incertezas (aditiva/multiplicativa).",
                                "Correção no cálculo de normas H-infinito.",
                                "Aplicação fiel do critério ganho pequeno.",
                                "Qualidade da análise sensível e simulações.",
                                "Clareza no relatório com visualizações.",
                                "Sugestões práticas para melhoria de robustez."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria de operadores e normas em espaços de Hardy.",
                                "Programação: Scripts MATLAB para automação de análises robustas.",
                                "Física: Modelagem de dinâmicas reais com ruído/parametrização.",
                                "Estatística: Análise de pior-caso vs probabilística (complementar ao teorema)."
                              ],
                              "realWorldApplication": "Em automação industrial, como controle de motores em robótica ou aviônica, onde incertezas em parâmetros (ex: massa variável em drones) são modeladas para garantir estabilidade sob variações, evitando falhas catastróficas."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.3.1.3",
                            "name": "Interpretar o raio de estabilidade",
                            "description": "Calcular e interpretar o raio de estabilidade robusta como 1/||M||_∞, onde M é a função de transferência de incerteza complementar, e discutir limitações conservadoras do teorema.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a Função de Transferência Complementar M",
                                  "subSteps": [
                                    "Revise o diagrama de blocos do sistema de laço fechado com controlador K e planta P nominal.",
                                    "Identifique M(s) = K(s)(I + P(s)K(s))^{-1}P(s) como a função de transferência da incerteza complementar.",
                                    "Analise o significado físico: M captura como perturbações multiplicativas afetam a saída.",
                                    "Plote |M(jω)| para diferentes frequências usando ferramentas de simulação.",
                                    "Compare M com a função de sensibilidade S para destacar diferenças."
                                  ],
                                  "verification": "Desenhe o diagrama de blocos e explique o papel de M em uma planta perturbada Δ.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Livro de Doyle 'Feedback Control Theory'",
                                    "MATLAB ou Python com Control Systems Library",
                                    "Notas de aula sobre robustez"
                                  ],
                                  "tips": "Sempre normalize as funções para ganhar insight sobre picos de ressonância.",
                                  "learningObjective": "Dominar a definição e interpretação de M no contexto de incertezas multiplicativas.",
                                  "commonMistakes": [
                                    "Confundir M com a função de transferência nominal T",
                                    "Ignorar a dependência em ω na análise em frequência"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Calcular a Norma Infinito ||M||_∞",
                                  "subSteps": [
                                    "Defina ||M||_∞ = sup_ω |M(jω)|, o valor máximo do ganho em frequência.",
                                    "Use simulação numérica em MATLAB (norm(M, inf)) ou Python para computar.",
                                    "Identifique o pico de |M(jω)|, geralmente associado a cruzamentos de ganho.",
                                    "Analise singular values se M for MIMO, focando no maior σ_max(M(jω)).",
                                    "Valide o cálculo com plots de Bode de M."
                                  ],
                                  "verification": "Compute ||M||_∞ para um sistema exemplo e confira com software, obtendo valor exato dentro de 1%.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "MATLAB Control System Toolbox",
                                    "Exemplos de sistemas LIT padrão",
                                    "Calculadora gráfica para validação manual"
                                  ],
                                  "tips": "Ajuste a malha de frequências para capturar picos estreitos.",
                                  "learningObjective": "Executar cálculo preciso da norma H-infinito para funções de transferência.",
                                  "commonMistakes": [
                                    "Usar norma 2 em vez de ∞",
                                    "Esquecer de considerar todo o espectro de frequências"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Interpretar o Raio de Estabilidade r = 1/||M||_∞",
                                  "subSteps": [
                                    "Estabeleça que pelo Teorema do Ganho Pequeno, se ||Δ||_∞ < r, o sistema é estável.",
                                    "Interprete r como o raio máximo de incerteza admissível em norma ∞.",
                                    "Calcule r explicitamente e discuta implicações: r grande indica robustez.",
                                    "Simule perturbações Δ com ||Δ||_∞ próximo a r para observar transição de estabilidade.",
                                    "Quantifique robustez em termos percentuais (ex: r=0.5 permite 50% de variação)."
                                  ],
                                  "verification": "Para um M dado com ||M||_∞=1.2, afirme r=0.833 e justifique estabilidade para Δ<0.833.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Simulink para simulações de laço fechado",
                                    "Templates de MATLAB para robustez",
                                    "Gráficos de Nyquist"
                                  ],
                                  "tips": "Use μ-analysis para refinar se disponível, mas foque no pequeno ganho primeiro.",
                                  "learningObjective": "Interpretar r como métrica quantitativa de robustez e suas implicações práticas.",
                                  "commonMistakes": [
                                    "Inverter a fórmula (usar ||M||_∞ em vez de 1/||M||_∞)",
                                    "Ignorar que é uma cota suficiente, não necessária"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Discutir Limitações Conservadoras do Teorema",
                                  "subSteps": [
                                    "Explique conservadorismo: teorema garante estabilidade só se ||Δ||_∞ < r, mas pode ser estável além.",
                                    "Discuta suposições: Δ estável, norma ∞ conservadora para perturbações não-bloco.",
                                    "Compare com métodos menos conservadores como μ-síntese ou análise de valor estruturado.",
                                    "Analise cenários onde conservadorismo falha: perturbações dinâmicas complexas.",
                                    "Proponha mitigações: design de controladores H∞ para minimizar ||M||_∞."
                                  ],
                                  "verification": "Escreva um parágrafo resumindo 3 limitações principais e uma alternativa.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Artigo seminal de Doyle et al. sobre robustez",
                                    "Casos de estudo de falhas em controle robusto",
                                    "Fórum online de controle (ex: MATLAB Central)"
                                  ],
                                  "tips": "Leia exemplos reais de conservadorismo em sistemas aeroespaciais.",
                                  "learningObjective": "Criticar o teorema, reconhecendo seu conservadorismo e contextos de aplicação.",
                                  "commonMistakes": [
                                    "Superestimar robustez além de r",
                                    "Confundir com teoremas de estabilidade nominal"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um sistema de controle de posição de um braço robótico com planta P(s)=1/(s(s+1)) e controlador PID tunado, compute M(s). Simule ||M||_∞=1.5, logo r=0.667. Teste com Δ multiplicativa de 60% (instável) vs 50% (estável), ilustrando o limite prático.",
                              "finalVerifications": [
                                "Calcule r corretamente para 3 sistemas exemplo com precisão >95%.",
                                "Explique o impacto de um pico em |M(jω)| na robustez.",
                                "Simule e demonstre instabilidade para ||Δ||_∞ > r.",
                                "Liste 3 limitações conservadoras com exemplos.",
                                "Compare r com margem de ganho/fase tradicional.",
                                "Aplique em um caso real, prevendo robustez."
                              ],
                              "assessmentCriteria": [
                                "Precisão matemática nos cálculos de ||M||_∞ e r (pontos exatos).",
                                "Profundidade na interpretação qualitativa e quantitativa de r.",
                                "Capacidade de simular e validar com software.",
                                "Análise crítica das limitações, com referências.",
                                "Clareza em plots e explicações verbais.",
                                "Criatividade em exemplos práticos e conexões reais."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Análise complexa e normas de operadores em espaços de Hardy.",
                                "Programação: Implementação numérica de normas H∞ em MATLAB/Python.",
                                "Física: Modelagem de dinâmicas com incertezas paramétricas.",
                                "Economia/Engenharia: Trade-offs custo-benefício em designs robustos."
                              ],
                              "realWorldApplication": "No controle de drones autônomos, incertezas em parâmetros aerodinâmicos (vento, massa) são modeladas como Δ; r garante estabilidade em missões variadas, evitando crashes caros em aplicações comerciais como entregas."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.2.3.2",
                        "name": "Norma H∞ para Estabilidade Robusta",
                        "description": "A norma H∞ é utilizada para quantificar o pior caso de ganho de energia em sistemas LIT, fornecendo critérios para estabilidade robusta contra perturbações e incertezas com ||Δ||_∞ ≤ 1.",
                        "specificSkills": [
                          {
                            "id": "10.1.2.3.2.1",
                            "name": "Definir e calcular a norma H∞",
                            "description": "Definir a norma H∞ como sup_ω σ_max(G(jω)) para funções de transferência LIT estáveis, e demonstrar métodos computacionais como singular values para calcular ||G||_∞ em MATLAB.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a Definição Teórica da Norma H∞",
                                  "subSteps": [
                                    "Revise conceitos de sistemas LIT (Linear Invariantes no Tempo) e funções de transferência estáveis.",
                                    "Defina a norma H∞ como ||G||_∞ = sup_ω σ_max(G(jω)), onde σ_max é o maior valor singular.",
                                    "Explique o significado: ganho máximo em frequência sobre todas as frequências ω.",
                                    "Discuta estabilidade: requer todos os polos no semiplano esquerdo.",
                                    "Compare com outras normas (H2, L1) para contextualizar."
                                  ],
                                  "verification": "Escreva a definição formal e prove que para G estável, ||G||_∞ < ∞.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Livro de controle avançado (ex: Zhou, Doyle), notas de aula, calculadora simbólica.",
                                  "tips": "Use diagramas de Bode para visualizar o ganho em frequência.",
                                  "learningObjective": "Dominar a definição matemática e interpretação física da norma H∞.",
                                  "commonMistakes": "Confundir com norma H2 (RMS) ou esquecer requisito de estabilidade."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Estudar o Cálculo via Valores Singulares",
                                  "subSteps": [
                                    "Lembre-se que para SISO, σ_max(G(jω)) = |G(jω)|.",
                                    "Para MIMO, compute a decomposição SVD de G(jω) em uma grade de frequências.",
                                    "Entenda que sup_ω σ_max(G(jω)) é o pico do maior valor singular sobre ω.",
                                    "Discuta aproximação numérica: discretize ω de 10^-2 a 10^2 rad/s.",
                                    "Analise convergência e precisão da grade de frequências."
                                  ],
                                  "verification": "Calcule manualmente σ_max para um G(jω) simples em ω=1.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Folha de MATLAB para SVD, tabela de valores singulares.",
                                  "tips": "Plot σ_max vs ω para identificar o pico.",
                                  "learningObjective": "Aplicar SVD ao cálculo de normas em frequência.",
                                  "commonMistakes": "Usar grade de ω muito grosseira, perdendo o pico."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar Cálculo da Norma H∞ em MATLAB",
                                  "subSteps": [
                                    "Crie função de transferência G em MATLAB usando tf().",
                                    "Gere vetor ω com logspace().",
                                    "Compute G(jω) com freqresp() e SVD com svd().",
                                    "Encontre max(σ_max) sobre ω.",
                                    "Valide com sigma() e norm() built-in do Control Toolbox."
                                  ],
                                  "verification": "Execute script e confirme ||G||_∞ coincide com função built-in (erro <1%).",
                                  "estimatedTime": "90 minutos",
                                  "materials": "MATLAB com Control System Toolbox, script template.",
                                  "tips": "Use semilogx para plotar σ_i(ω).",
                                  "learningObjective": "Desenvolver código eficiente para norma H∞.",
                                  "commonMistakes": "Esquecer de estabilizar G ou usar freqs() em vez de freqresp()."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar em Análise de Estabilidade Robusta",
                                  "subSteps": [
                                    "Integre norma H∞ em critério de robustez: ||G Δ||_∞ <1 para Δ estável.",
                                    "Teste com modelo de incerteza aditiva/multiplicativa.",
                                    "Interprete: se ||G||_∞ pequeno, maior margem de robustez.",
                                    "Simule variação de parâmetros e recalcule norma.",
                                    "Gere relatório com plots e valores."
                                  ],
                                  "verification": "Demonstre que para Δ=0.5/G_max, sistema permanece estável.",
                                  "estimatedTime": "75 minutos",
                                  "materials": "MATLAB script do step 3, exemplos de incertezas.",
                                  "tips": "Estruture código modular para reutilização.",
                                  "learningObjective": "Conectar norma H∞ a estabilidade robusta prática.",
                                  "commonMistakes": "Ignorar fase ou confundir normas de incerteza."
                                }
                              ],
                              "practicalExample": "Para G(s) = 1/(s^2 + 2s + 1), estável, compute ||G||_∞ em MATLAB: ω=logspace(-1,1,1000); [re,im]=freqresp(tf(1,[1 2 1]),ω); Gjw=abs(re+1i*im); norma_inf=max(Gjw) ≈1 (pico DC). Para MIMO, G=[1/(s+1), 0; 0, 1/(s+2)], σ_max pico ≈1.",
                              "finalVerifications": [
                                "Definição escrita corretamente: sup_ω σ_max(G(jω)).",
                                "Código MATLAB roda sem erros e matches built-in.",
                                "Plot de σ_max(ω) mostra pico claro.",
                                "Exemplo numérico com erro <0.1%.",
                                "Explicação verbal de robustez.",
                                "Comparação com norma H2."
                              ],
                              "assessmentCriteria": [
                                "Precisão da definição teórica (20%).",
                                "Correção do código MATLAB (30%).",
                                "Interpretação de resultados (20%).",
                                "Qualidade de plots e verificações (15%).",
                                "Conexão com robustez (15%)."
                              ],
                              "crossCurricularConnections": [
                                "Álgebra Linear: Decomposição SVD.",
                                "Programação Numérica: MATLAB para análise em frequência.",
                                "Matemática Aplicada: Análise complexa e otimização.",
                                "Engenharia de Sinais: Resposta em frequência."
                              ],
                              "realWorldApplication": "Em controle de aeronaves, calcular ||G||_∞ garante robustez contra variações aerodinâmicas; em automação industrial, assegura estabilidade apesar de incertezas em atuadores."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.3.2.2",
                            "name": "Estabelecer critérios de estabilidade H∞",
                            "description": "Aplicar o critério de estabilidade robusta via norma H∞, garantindo ||T_Δ||_∞ < 1 para estabilidade em face de incertezas Δ com ||Δ||_∞ < 1, incluindo a forma padrão de malha fechada.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a norma H∞ e seu significado em estabilidade robusta",
                                  "subSteps": [
                                    "Defina a norma H∞ como o suprimo da função de transferência sobre o eixo jω: ||G||_∞ = sup_ω |G(jω)|.",
                                    "Explique o critério pequeno ganho: se ||Δ||_∞ < 1/||T_Δ||_∞, o sistema é estável para todas as incertezas Δ admissíveis.",
                                    "Revise a propriedade: estabilidade robusta se ||T_Δ||_∞ < 1 para ||Δ||_∞ < 1.",
                                    "Estude exemplos de singular values para visualizar picos da norma H∞.",
                                    "Discuta a diferença entre estabilidade nominal e robusta."
                                  ],
                                  "verification": "Resuma em um parágrafo o critério H∞ e resolva um exercício simples de cálculo de ||G||_∞ para G(s) = 1/(s+1).",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Livro de controle robusto (Zhou et al.), MATLAB para plotar singular values.",
                                  "tips": "Use o comando sigma(G) no MATLAB para visualizar a norma H∞ graficamente.",
                                  "learningObjective": "Entender conceitualmente a norma H∞ e seu uso no teorema de estabilidade robusta.",
                                  "commonMistakes": "Confundir norma H∞ com norma H2; ignorar que é suprimo sobre frequências."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Modelar incertezas e configurar o loop de malha fechada",
                                  "subSteps": [
                                    "Identifique incertezas Δ como blocos normados com ||Δ||_∞ < 1 (ex: incerteza aditiva, multiplicativa).",
                                    "Desenhe o diagrama de blocos do sistema nominal P com controlador K.",
                                    "Forme o loop unitário: interconecte P, K e Δ no ponto de injeção de incerteza.",
                                    "Escreva as equações de transferência do sinal de entrada para saída considerando Δ.",
                                    "Normalize Δ para garantir ||Δ||_∞ < 1."
                                  ],
                                  "verification": "Desenhe o diagrama para um sistema simples e escreva T_Δ explicitamente.",
                                  "estimatedTime": "1 hora",
                                  "materials": "Papel e lápis para diagramas, software Simulink ou MATLAB para modelagem.",
                                  "tips": "Sempre desenhe o loop antes de algebraizar para evitar erros de sinal.",
                                  "learningObjective": "Modelar corretamente sistemas com incertezas estruturadas.",
                                  "commonMistakes": "Esquecer a inversão no loop de realimentação; não normalizar Δ."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Construir a função de transferência T_Δ na forma padrão",
                                  "subSteps": [
                                    "Obtenha a planta generalizada (standard form): [z; y] = P [w; u], onde z é penalizado.",
                                    "Calcule T_Δ = Fl(P, K) ou a transferência de w para z com Δ no loop.",
                                    "Use fórmula algébrica: T_Δ = (I + M Δ)^(-1) M para loop unitário.",
                                    "Implemente em MATLAB usando funções como lft ou starprod para interconexões lineares fracionárias.",
                                    "Verifique dimensionalidade e causalidade de T_Δ."
                                  ],
                                  "verification": "Compute T_Δ para um exemplo dado e plote sua resposta em frequência.",
                                  "estimatedTime": "1 hora e 30 minutos",
                                  "materials": "MATLAB Robust Control Toolbox (norm, sigma), notas de aula sobre LFTs.",
                                  "tips": "Use sysic para interconectar sistemas no MATLAB e evite cálculos manuais longos.",
                                  "learningObjective": "Construir T_Δ corretamente para análise H∞.",
                                  "commonMistakes": "Erro na ordem de interconexão (upper/lower LFT); não considerar delays."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Calcular a norma H∞ de T_Δ e aplicar o critério de estabilidade",
                                  "subSteps": [
                                    "Compute ||T_Δ||_∞ usando hinf_norm() ou hinfnorm() no MATLAB.",
                                    "Analise o gráfico de singular values: verifique se max σ(T_Δ(jω)) < 1.",
                                    "Se ||T_Δ||_∞ ≥ 1, identifique frequências críticas e proponha ajustes.",
                                    "Teste com Δ aleatórias normadas para simular violações.",
                                    "Documente o resultado: estável se ||T_Δ||_∞ < 1."
                                  ],
                                  "verification": "Gere relatório com valor numérico de ||T_Δ||_∞ e gráfico confirmando <1.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "MATLAB com Robust Control Toolbox, exemplos de sistemas LIT.",
                                  "tips": "Aumente a precisão com grid denso em ω para picos estreitos.",
                                  "learningObjective": "Aplicar computacionalmente o critério H∞ para robustez.",
                                  "commonMistakes": "Interpretar erroneamente o pico como instabilidade sem checar toda banda; ignorar DC gain."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Verificar e interpretar resultados de estabilidade robusta",
                                  "subSteps": [
                                    "Compare estabilidade nominal (Δ=0) vs. robusta.",
                                    "Calcule margem de robustez: 1/||T_Δ||_∞.",
                                    "Simule respostas transitórias com Δ perturbadas.",
                                    "Discuta limitações: conservadorismo do critério H∞.",
                                    "Proponha melhorias como síntese H∞ se necessário."
                                  ],
                                  "verification": "Realize simulações com 3 Δ diferentes e confirme ausência de instabilidade.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "MATLAB para simulações (lsim, step), relatório template.",
                                  "tips": "Use wcgain para análise de worst-case gain.",
                                  "learningObjective": "Interpretar resultados H∞ no contexto de design robusto.",
                                  "commonMistakes": "Assumir robustez sem simulações; negligenciar não-linearidades em Δ."
                                }
                              ],
                              "practicalExample": "Considere um sistema de controle de velocidade de motor DC com planta P(s) = 1/(s+1) e controlador K(s) = 1. Incerteza multiplicativa Δ(s) = 0.2(s-1)/(s+1) com ||Δ||_∞ <1. Compute T_Δ = P K (I + P K)^{-1}, calcule ||T_Δ||_∞ ≈ 0.67 <1, confirmando estabilidade robusta. Plote σ(T_Δ(jω)) no MATLAB.",
                              "finalVerifications": [
                                "||T_Δ||_∞ < 1 computado corretamente.",
                                "Diagrama de blocos da forma padrão desenhado sem erros.",
                                "Singular values plotados mostrando pico abaixo de 1.",
                                "Simulações com Δ perturbadas estáveis.",
                                "Margem de robustez quantificada.",
                                "Relatório com interpretação escrita."
                              ],
                              "assessmentCriteria": [
                                "Precisão no cálculo de T_Δ (erro <1%).",
                                "Correta aplicação do teorema pequeno ganho.",
                                "Qualidade dos gráficos de frequência.",
                                "Análise de casos limite com Δ próxima de norma 1.",
                                "Capacidade de explicar conservadorismo H∞.",
                                "Simulações realistas e bem documentadas."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria de operadores normados e valores singulares.",
                                "Física: Dinâmica de sistemas com perturbações reais.",
                                "Programação: Implementação numérica em MATLAB/Simulink.",
                                "Estatística: Análise de incertezas estocásticas vs. worst-case."
                              ],
                              "realWorldApplication": "Em controle de aeronaves, onde incertezas em aerodinâmica (Δ) devido a variações de vento ou danos devem garantir estabilidade robusta via H∞, evitando oscilações catastróficas em voo autônomo."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.3.2.3",
                            "name": "Analisar estabilidade em exemplos numéricos",
                            "description": "Realizar análise de estabilidade robusta em sistemas LIT escalares com incertezas, plotando curvas de singular values e verificando condições H∞ usando ferramentas como o Robust Control Toolbox.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Definir o sistema nominal e modelar incertezas",
                                  "subSteps": [
                                    "Identifique o sistema LIT escalar nominal (ex: função de transferência G(s)).",
                                    "Defina tipos de incertezas (aditiva, multiplicativa ou inversa) com base no contexto.",
                                    "Use comandos MATLAB como tf() para criar o modelo nominal.",
                                    "Crie o modelo de incerteza com ureal() ou uncertain() do Robust Control Toolbox.",
                                    "Construa o sistema incerto combinando nominal e incerteza."
                                  ],
                                  "verification": "Execute o script MATLAB e confirme que o modelo incerto é exibido corretamente com usample() mostrando variações.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "MATLAB com Robust Control Toolbox instalado",
                                    "Documentação do Robust Control Toolbox",
                                    "Exemplo de sistema LIT escalar (ex: G(s) = 1/(s+1))"
                                  ],
                                  "tips": "Comece com incertezas simples (ex: 20% de variação) para validar o setup antes de complexificar.",
                                  "learningObjective": "Compreender e implementar modelagem de sistemas LIT com incertezas paramétricas ou dinâmicas.",
                                  "commonMistakes": [
                                    "Confundir tipos de incerteza (aditiva vs. multiplicativa)",
                                    "Esquecer de importar toolbox com robustcontrol",
                                    "Definir incertezas sem bounds realistas"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Computar a norma H∞ do sistema incerto",
                                  "subSteps": [
                                    "Use norm() ou hinfnorm() para calcular a norma H∞ do sistema incerto.",
                                    "Gere amostras do sistema incerto com usample() (pelo menos 100 amostras).",
                                    "Calcule singular values para cada amostra usando sigma().",
                                    "Identifique o valor máximo da norma H∞ entre todas as amostras.",
                                    "Registre o gamma (nível de robustez) como max(singular value)."
                                  ],
                                  "verification": "Verifique se o valor de gamma < 1 para garantia de estabilidade robusta; liste valores computados.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Script MATLAB do Step 1",
                                    "Funções: usample(), sigma(), hinfnorm()"
                                  ],
                                  "tips": "Aumente o número de amostras para maior precisão em sistemas com alta variância.",
                                  "learningObjective": "Dominar o cálculo da norma H∞ para quantificar robustez em sistemas incertos.",
                                  "commonMistakes": [
                                    "Usar norm() em vez de sigma() para singular values",
                                    "Amostrar poucas realizações levando a subestimação",
                                    "Ignorar frequência em que o pico ocorre"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Plotar curvas de singular values e analisar frequência",
                                  "subSteps": [
                                    "Configure bode() ou sigma() para plotar singular values vs. frequência.",
                                    "Plote curvas para sistema nominal, pior caso e envelope de incerteza.",
                                    "Use robustplot() ou loop margins para visualização integrada.",
                                    "Identifique picos de singular value e frequência crítica (ω_c).",
                                    "Anote o crossover frequency onde |σ(jω)| = 1."
                                  ],
                                  "verification": "Gráficos mostram envelope abaixo de 1 em todas as frequências para estabilidade; salve figuras.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Scripts dos steps anteriores",
                                    "Funções: sigma(), bode(), robustplot()"
                                  ],
                                  "tips": "Use logspace() para grid de frequências denso em regiões críticas.",
                                  "learningObjective": "Visualizar e interpretar curvas de singular values para diagnóstico de robustez.",
                                  "commonMistakes": [
                                    "Escala errada no eixo y (use dB com 20*log10())",
                                    "Plotar apenas nominal sem incerteza",
                                    "Ignorar fase em análises combinadas"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificar condições de estabilidade robusta H∞",
                                  "subSteps": [
                                    "Confirme se sup_ω σ̄(G(jω)) < 1 para todo ω (condição pequena ganho).",
                                    "Avalie estabilidade do loop fechado com feedback() e isstable().",
                                    "Teste sensibilidade com wcnorm() ou mu-analysis se aplicável.",
                                    "Gere relatório resumindo gamma, ω_c e conclusões de robustez.",
                                    "Simule respostas temporais para validação qualitativa."
                                  ],
                                  "verification": "Relatório final afirma 'Estável robustamente' se gamma < 1 e todos checks passam.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Todos scripts anteriores",
                                    "Funções: isstable(), step(), feedback()"
                                  ],
                                  "tips": "Combine com simulações temporais para robustez além da frequência.",
                                  "learningObjective": "Aplicar teorema H∞ para concluir sobre estabilidade robusta em exemplos numéricos.",
                                  "commonMistakes": [
                                    "Confundir norma H∞ com ganho estático",
                                    "Não testar loop fechado",
                                    "Concluir estabilidade sem checar todas as frequências"
                                  ]
                                }
                              ],
                              "practicalExample": "Considere um regulador de velocidade de motor DC com G(s) = 1/(s+1) e incerteza multiplicativa de 30% no ganho. Modele como G_Δ(s) = G(s)(1 + W_Δ(s)Δ), compute H∞, plote σ̄ e verifique se gamma < 1 garante estabilidade apesar de variações.",
                              "finalVerifications": [
                                "Modelo incerto corretamente definido e amostrado.",
                                "Norma H∞ (gamma) calculada e <1 para robustez.",
                                "Curvas de singular values plotadas com envelope abaixo de 1.",
                                "Frequência crítica identificada e analisada.",
                                "Conclusão de estabilidade robusta documentada.",
                                "Simulações temporais confirmam ausência de instabilidade."
                              ],
                              "assessmentCriteria": [
                                "Precisão na modelagem de incertezas (100% match com specs).",
                                "Correção dos cálculos de norma H∞ (erro <1%).",
                                "Qualidade e legibilidade dos plots (legendas, escalas adequadas).",
                                "Interpretação precisa das condições H∞.",
                                "Relatório completo com conclusões acionáveis.",
                                "Eficiência no uso do toolbox (código limpo e otimizado)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Análise de valores singulares e teoria de normas.",
                                "Programação: Scripting avançado em MATLAB e manipulação de objetos uncertain.",
                                "Física: Dinâmica de sistemas reais com perturbações.",
                                "Estatística: Amostragem Monte Carlo para análise de incertezas.",
                                "Engenharia de Software: Validação numérica e visualização de dados."
                              ],
                              "realWorldApplication": "Em controle de drones aeroespaciais, analisar estabilidade robusta garante operação segura apesar de variações em massa ou aerodinâmica, evitando crashes em missões autônomas."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.3.2.4",
                            "name": "Comparar com outros critérios de robustez",
                            "description": "Comparar o critério H∞ com o teorema do ganho pequeno, destacando conservadorismo e aplicações em projetos de controladores robustos para sistemas monovariáveis.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar o Critério H∞ para Estabilidade Robusta",
                                  "subSteps": [
                                    "Estude a definição da norma H∞ e seu papel na análise de estabilidade robusta para sistemas LIT com incertezas.",
                                    "Revise a condição de estabilidade: ||T||_∞ < 1, onde T é a função de transferência da perturbação para o erro.",
                                    "Analise exemplos gráficos de diagramas de Nyquist para normas H∞.",
                                    "Pratique o cálculo da norma H∞ usando MATLAB/Simulink para um sistema nominal.",
                                    "Identifique limitações iniciais do critério H∞ em sistemas monovariáveis."
                                  ],
                                  "verification": "Calcule corretamente a norma H∞ de um sistema dado e interprete se garante estabilidade robusta.",
                                  "estimatedTime": "2 horas",
                                  "materials": "Livro de controle avançado (e.g., Zhou et al.), MATLAB com toolbox Control Systems, notas de aula sobre normas H∞.",
                                  "tips": "Use o comando norm() no MATLAB para validação rápida; foque em picos de magnitude.",
                                  "learningObjective": "Compreender fundamentos do critério H∞ e sua formulação matemática.",
                                  "commonMistakes": "Confundir norma H∞ com norma H2; ignorar o sinal de fase nos diagramas."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Estudar o Teorema do Pequeno Ganho (Small Gain Theorem)",
                                  "subSteps": [
                                    "Revise a declaração do teorema: estabilidade se ||G||_∞ * ||Δ||_∞ < 1, para operador Δ de incerteza.",
                                    "Compare com loop aberto: ganho pequeno garante contração no loop fechado.",
                                    "Analise provas gráficas usando círculos pequenos e multiplicação de normas.",
                                    "Simule um exemplo simples com ganho variável para verificar o teorema.",
                                    "Discuta extensões para sistemas não lineares ou tempo-variante."
                                  ],
                                  "verification": "Aplique o teorema a um sistema com incerteza conhecida e confirme estabilidade via cálculo de normas.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": "Referências como Doyle ou Skogestad, software MATLAB para simulações de loop.",
                                  "tips": "Visualize com Bode plots; lembre que é uma condição suficiente, não necessária.",
                                  "learningObjective": "Dominar o teorema do pequeno ganho e sua interpretação intuitiva.",
                                  "commonMistakes": "Assumir que aplica apenas a sistemas lineares; confundir com teorema de valor pequeno."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Comparar Critério H∞ e Teorema do Pequeno Ganho",
                                  "subSteps": [
                                    "Liste similaridades: ambos usam normas ∞ para robustez contra incertezas aditivas/multiplicativas.",
                                    "Destaque diferenças: H∞ é específico para estabilidade robusta; pequeno ganho é mais geral.",
                                    "Crie uma tabela comparativa de condições, conservadorismo e computação.",
                                    "Analise casos onde um falha e o outro succeeds em sistemas monovariáveis.",
                                    "Discuta implicações para análise de robustez em projetos de controle."
                                  ],
                                  "verification": "Produza uma tabela comparativa precisa e explique verbalmente duas diferenças chave.",
                                  "estimatedTime": "2 horas",
                                  "materials": "Planilha Excel/Google Sheets para tabela, exemplos de artigos IEEE sobre robustez.",
                                  "tips": "Use setas em diagramas para mostrar conexões entre os teoremas.",
                                  "learningObjective": "Identificar e articular semelhanças e diferenças entre os critérios.",
                                  "commonMistakes": "Ignorar que H∞ é uma aplicação especial do pequeno ganho; superestimar generalidade."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar Conservadorismo e Aplicações em Controladores Robustos",
                                  "subSteps": [
                                    "Quantifique conservadorismo: H∞ pode ser mais conservador devido a pior-caso structured singular value.",
                                    "Compare margens de robustez em simulações com incertezas reais vs. bound.",
                                    "Estude design de controladores H∞ vs. LQG com pequeno ganho.",
                                    "Avalie trade-offs em performance vs. robustez para sistemas monovariáveis.",
                                    "Revise case studies de controladores robustos em indústria."
                                  ],
                                  "verification": "Simule um controlador e demonstre quando H∞ é excessivamente conservador.",
                                  "estimatedTime": "2.5 horas",
                                  "materials": "MATLAB Robust Control Toolbox, papers sobre μ-synthesis, exemplos industriais.",
                                  "tips": "Teste com incertezas não structured para expor conservadorismo.",
                                  "learningObjective": "Avaliar conservadorismo prático e aplicações em design de controladores.",
                                  "commonMistakes": "Confundir conservadorismo com instabilidade; negligenciar computação numérica."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Sintetizar Conhecimento e Praticar Integração",
                                  "subSteps": [
                                    "Resuma prós/contras de cada critério em um relatório curto.",
                                    "Resolva problemas mistos combinando ambos em análise robusta.",
                                    "Crie um fluxograma de decisão para escolher critério em projetos.",
                                    "Debata com pares ou tutor sobre cenários reais.",
                                    "Autoavalie compreensão via quiz personalizado."
                                  ],
                                  "verification": "Apresente fluxograma e resolva um problema híbrido corretamente.",
                                  "estimatedTime": "1 hora",
                                  "materials": "Ferramenta de diagrama (Draw.io), quiz online sobre robustez.",
                                  "tips": "Priorize aplicações monovariáveis; integre com μ-analysis se avançado.",
                                  "learningObjective": "Integrar comparação em workflow de design robusto.",
                                  "commonMistakes": "Sobrecarregar com multivariable sem foco mono."
                                }
                              ],
                              "practicalExample": "Considere um sistema de posição de motor DC com incerteza multiplicativa Δ (10-20%). Calcule norma H∞ da planta nominal e aplique pequeno ganho para bound. Compare: H∞ garante estabilidade para ||Δ||_∞ < 1/||G||_∞ = 0.8, mas simulação mostra robustez até 1.2, revelando conservadorismo. Desenhe controlador H∞ e avalie performance vs. LQG.",
                              "finalVerifications": [
                                "Explicar verbalmente como H∞ deriva do pequeno ganho.",
                                "Calcular normas e condições para um sistema dado.",
                                "Identificar cenário onde H∞ é mais conservador.",
                                "Citar aplicação em controlador robusto monovariável.",
                                "Produzir tabela comparativa precisa.",
                                "Simular estabilidade com MATLAB para incerteza."
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição e fórmulas (30%)",
                                "Profundidade da comparação e conservadorismo (25%)",
                                "Uso correto de ferramentas/simulações (20%)",
                                "Clareza em exemplos e aplicações (15%)",
                                "Integração interdisciplinar e criatividade (10%)"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria de normas e análise funcional.",
                                "Computação: Programação em MATLAB para robustez.",
                                "Otimização: Trade-offs em design H∞ vs. LMI.",
                                "Física: Modelagem de sistemas reais com incertezas.",
                                "Gestão de Projetos: Decisões em engenharia de controle."
                              ],
                              "realWorldApplication": "No design de controladores para drones ou veículos autônomos, usar H∞ para garantir estabilidade contra variações de massa/vento (mais conservador), enquanto pequeno ganho permite tuning menos restritivo em protótipos industriais como plantas químicas monovariáveis."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.2.4",
                    "name": "Margens de Robustez",
                    "description": "Definição e cálculo de margens de ganho e fase robustas para sistemas LIT com incertezas.",
                    "individualConcepts": [
                      {
                        "id": "10.1.2.4.1",
                        "name": "Margens de Ganho e Fase Clássicas",
                        "description": "Revisão dos conceitos fundamentais de margens de ganho e fase no contexto de sistemas de controle lineares invariantes no tempo (LIT) escalares, preparando o terreno para a extensão às margens robustas com incertezas.",
                        "specificSkills": [
                          {
                            "id": "10.1.2.4.1.1",
                            "name": "Definir e interpretar margem de ganho clássica",
                            "description": "Explicar a margem de ganho como o fator multiplicativo máximo pelo qual o ganho de malha aberta pode ser alterado até o ponto de instabilidade, identificando-o no diagrama de Bode e relacionando-o à estabilidade relativa.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a definição conceitual de margem de ganho clássica",
                                  "subSteps": [
                                    "Revise o conceito de ganho de malha aberta (G_ol(jω)) em sistemas de controle LIT.",
                                    "Defina margem de ganho (GM) como o fator multiplicativo máximo pelo qual o ganho de malha aberta pode ser aumentado até o ponto de instabilidade (fase = -180°).",
                                    "Estude a relação GM = 1 / |G_ol(jω_pc)|, onde ω_pc é a frequência de cruzamento de fase (-180°).",
                                    "Compare com margem de fase para diferenciar os conceitos.",
                                    "Anote exemplos qualitativos de sistemas estáveis e instáveis."
                                  ],
                                  "verification": "Escreva uma definição precisa da margem de ganho em suas próprias palavras e calcule GM para um exemplo dado.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Livro de controle clássico (ex: Ogata), diagrama de Bode básico",
                                    "Calculadora ou software como MATLAB/Octave"
                                  ],
                                  "tips": "Visualize GM como 'quanto mais eu posso amplificar o ganho antes de oscilar infinitamente?'.",
                                  "learningObjective": "Definir precisamente margem de ganho e sua fórmula matemática.",
                                  "commonMistakes": [
                                    "Confundir com margem de fase",
                                    "Ignorar que GM é em dB ou fator multiplicativo"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar a margem de ganho no diagrama de Bode",
                                  "subSteps": [
                                    "Plote ou analise o diagrama de Bode de magnitude e fase da função de malha aberta.",
                                    "Localize a frequência de cruzamento de fase (ω_pc) onde ∠G_ol(jω) = -180°.",
                                    "Meça a magnitude |G_ol(jω_pc)| no gráfico de magnitude.",
                                    "Calcule GM = 1 / |G_ol(jω_pc)| ou em dB: GM_dB = -20*log10(|G_ol(jω_pc)|).",
                                    "Pratique com pelo menos 3 diagramas de Bode fornecidos."
                                  ],
                                  "verification": "Anote ω_pc e GM para um diagrama de Bode dado e justifique a localização.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Diagramas de Bode de exemplos (impressos ou digitais)",
                                    "Ferramenta de plotagem como Python (matplotlib) ou MATLAB"
                                  ],
                                  "tips": "Use régua ou cursor digital para precisão na leitura de frequências.",
                                  "learningObjective": "Localizar e extrair GM diretamente de diagramas de Bode.",
                                  "commonMistakes": [
                                    "Escolher frequência errada para ω_pc",
                                    "Ler magnitude errada no eixo log"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Interpretar o valor da margem de ganho em termos de estabilidade",
                                  "subSteps": [
                                    "Classifique GM: GM > 1 (estável), GM = 1 (marginalmente estável), GM < 1 (instável).",
                                    "Relacione valores típicos: GM > 6 dB (cerca de 2x) indica boa robustez.",
                                    "Analise impacto de variações de ganho: ΔK < GM mantém estabilidade.",
                                    "Simule aumento de ganho até instabilidade em software.",
                                    "Discuta estabilidade relativa: maior GM implica maior distância à instabilidade."
                                  ],
                                  "verification": "Para um sistema com GM = 3 dB, explique o quanto o ganho pode variar antes da instabilidade.",
                                  "estimatedTime": "50 minutos",
                                  "materials": [
                                    "Software de simulação (MATLAB Simulink ou Python control library)",
                                    "Exemplos numéricos de funções de transferência"
                                  ],
                                  "tips": "Converta entre fator linear e dB para intuição: 6 dB ≈ fator 2.",
                                  "learningObjective": "Interpretar GM quantitativamente para avaliar robustez.",
                                  "commonMistakes": [
                                    "Interpretar GM < 0 dB como estável",
                                    "Confundir estabilidade absoluta com relativa"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar e relacionar margem de ganho à robustez geral",
                                  "subSteps": [
                                    "Integre GM com margem de fase (PM) para análise completa de robustez.",
                                    "Avalie trade-offs: alto GM pode implicar baixo PM em alguns sistemas.",
                                    "Teste em um loop de controle real: ajuste ganho e observe oscilações.",
                                    "Documente como GM mede incertezas em parâmetros de ganho.",
                                    "Resolva problemas: dado diagrama, prediga estabilidade após mudança de ganho."
                                  ],
                                  "verification": "Resolva um problema completo: calcule, interprete e discuta robustez para um caso dado.",
                                  "estimatedTime": "75 minutos",
                                  "materials": [
                                    "Exercícios de problemas resolvidos",
                                    "Hardware simples como kit Arduino para demo prática"
                                  ],
                                  "tips": "Sempre verifique tanto magnitude quanto fase juntos.",
                                  "learningObjective": "Relacionar GM à estabilidade relativa e robustez em contextos práticos.",
                                  "commonMistakes": [
                                    "Isolar GM sem considerar PM",
                                    "Ignorar não-linearidades em análises LIT"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um sistema de controle de velocidade de motor DC com G_ol(s) = K / (s(s+1)), plote Bode: ω_pc ≈ 1 rad/s, |G_ol(jω_pc)| = 0.5 (-6 dB), GM = 2 (6 dB). Aumentar K em até 2x mantém estabilidade; além disso, oscilações surgem.",
                              "finalVerifications": [
                                "Defina GM corretamente sem consulta.",
                                "Identifique ω_pc e GM em um novo diagrama de Bode.",
                                "Interprete GM = 10 dB como 'ganho pode dobrar 3 vezes antes de instabilidade'.",
                                "Explique relação com estabilidade relativa.",
                                "Simule e confirme em software.",
                                "Discuta limitações da análise clássica."
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição e fórmula de GM (20%)",
                                "Correta identificação em diagrama de Bode (25%)",
                                "Interpretação quantitativa e qualitativa (25%)",
                                "Relacionamento com robustez e estabilidade (20%)",
                                "Uso correto de ferramentas e exemplos práticos (10%)"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Análise complexa e transformada de Fourier.",
                                "Física: Dinâmica de sistemas oscilatórios e feedback.",
                                "Programação: Simulações numéricas em Python/MATLAB.",
                                "Estatística: Modelagem de incertezas paramétricas."
                              ],
                              "realWorldApplication": "Em controle de drones, GM garante que variações no peso da carga (afetando ganho) não causem instabilidade, permitindo voos robustos em condições variáveis."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.4.1.2",
                            "name": "Definir e interpretar margem de fase clássica",
                            "description": "Descrever a margem de fase como o ângulo adicional de fase necessário na frequência de ganho unitário para causar instabilidade, localizando-a no diagrama de Bode e avaliando seu impacto no amortecimento e desempenho transitório.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a definição conceitual de margem de fase",
                                  "subSteps": [
                                    "Estude o conceito de estabilidade em sistemas de controle via critério de Nyquist ou Bode.",
                                    "Identifique a frequência de ganho unitário (ω_c), onde |G(jω_c)| = 1 (0 dB).",
                                    "Entenda que instabilidade ocorre se a fase for -180° nessa frequência.",
                                    "Defina margem de fase (PM) como PM = 180° + ∠G(jω_c), o ângulo adicional necessário para instabilidade.",
                                    "Relacione com robustez: maior PM implica maior tolerância a atrasos ou variações de fase."
                                  ],
                                  "verification": "Explique verbalmente ou por escrito a definição e formule a equação PM = 180° + ∠G(jω_c).",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Livro de controle (ex: Ogata ou Franklin)",
                                    "Notas de aula sobre diagramas de Bode",
                                    "Calculadora científica"
                                  ],
                                  "tips": "Visualize o ponto crítico (-1,0) no plano complexo para fixar o conceito.",
                                  "learningObjective": "Dominar a definição precisa de margem de fase e sua relação com estabilidade.",
                                  "commonMistakes": [
                                    "Confundir com margem de ganho (que é em magnitude)",
                                    "Esquecer o sinal: usar 180° - ∠G ao invés de 180° + ∠G",
                                    "Ignorar que é na frequência de ganho unitário"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Localizar a margem de fase no diagrama de Bode",
                                  "subSteps": [
                                    "Plote ou analise o diagrama de Bode de magnitude e fase da função de transferência em malha aberta G(s).",
                                    "Encontre ω_c no gráfico de magnitude onde a curva cruza 0 dB.",
                                    "No gráfico de fase correspondente, leia o valor de ∠G(jω_c) na mesma frequência ω_c.",
                                    "Calcule PM = 180° + ∠G(jω_c) (geralmente ∠G é negativo, ex: -120° → PM=60°).",
                                    "Marque visualmente a distância da fase até -180° no diagrama."
                                  ],
                                  "verification": "Apresente um diagrama de Bode anotado com ω_c e PM destacados corretamente.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Software MATLAB ou Python (control library)",
                                    "Diagrama de Bode de exemplo impresso",
                                    "Régua e lápis para marcações manuais"
                                  ],
                                  "tips": "Use log-log para magnitude e log-linear para fase; zoom na região crítica para precisão.",
                                  "learningObjective": "Saber localizar e extrair numericamente a margem de fase de diagramas de Bode.",
                                  "commonMistakes": [
                                    "Ler frequência errada (não em 0 dB)",
                                    "Confundir eixos de magnitude e fase",
                                    "Usar escala errada (graus vs radianos)"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Interpretar o valor da margem de fase",
                                  "subSteps": [
                                    "Classifique PM: excelente (>60°), boa (45°-60°), marginal (30°-45°), ruim (<30°).",
                                    "Relacione PM com propriedades do sistema: maior PM → maior amortecimento.",
                                    "Analise trade-offs: PM alta pode reduzir banda passante e velocidade de resposta.",
                                    "Compare com exemplos: PM=0° → oscilatório limite; PM=90° → superamortecido.",
                                    "Discuta sensibilidade: PM mede robustez a variações de fase (ex: atrasos)."
                                  ],
                                  "verification": "Classifique PM de 3 exemplos numéricos e justifique com razões qualitativas.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Tabela de referência de margens típicas",
                                    "Exemplos de funções de transferência",
                                    "Planilha Excel para cálculos"
                                  ],
                                  "tips": "Lembre: PM ≈ 100 * ζ (aproximação para sistemas de 2ª ordem, ζ=fator de amortecimento).",
                                  "learningObjective": "Interpretar qualitativamente e quantitativamente o significado de diferentes valores de PM.",
                                  "commonMistakes": [
                                    "Achar que PM maior sempre é melhor (ignora trade-offs com desempenho)",
                                    "Não considerar o contexto do sistema (ex: servo vs regulador)",
                                    "Confundir com overshoot diretamente"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Avaliar impacto no amortecimento e desempenho transitório",
                                  "subSteps": [
                                    "Simule resposta ao degrau para diferentes PM usando ferramentas numéricas.",
                                    "Observe overshoot (menor com PM maior), tempo de estabilização e oscilações.",
                                    "Calcule fator de amortecimento ζ ≈ PM/100 para aproximação.",
                                    "Analise step response: PM baixa → overshoot alto e oscilações persistentes.",
                                    "Proponha compensadores (ex: lead) para melhorar PM se necessário."
                                  ],
                                  "verification": "Gere gráficos de resposta transitória para PM=30°, 60° e compare métricas.",
                                  "estimatedTime": "1 hora e 30 minutos",
                                  "materials": [
                                    "MATLAB/Simulink ou Python (matplotlib + control)",
                                    "Funções de transferência padrão (ex: G(s)=ω_n²/(s²+2ζω_n s + ω_n²))"
                                  ],
                                  "tips": "Use simulações para 'ver' o impacto: mude PM e observe step response em tempo real.",
                                  "learningObjective": "Conectar PM com métricas de desempenho transitório e amortecimento.",
                                  "commonMistakes": [
                                    "Ignorar não-linearidades reais",
                                    "Usar aproximações sem validar com simulação",
                                    "Confundir causa-efeito (PM afeta ζ, mas não é exata para ordens altas)"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um sistema de controle de posição de um braço robótico com G(s) = 10/(s(s+1)), plote o diagrama de Bode: ω_c ≈ 3.16 rad/s, ∠G(jω_c) ≈ -135°, PM = 45°. Simule step response: overshoot ≈25%, tempo de assentamento ≈2s. Se adicionar atraso de 0.1s, PM cai para 20°, causando oscilações visíveis.",
                              "finalVerifications": [
                                "Definir corretamente PM e sua fórmula.",
                                "Localizar ω_c e PM em um diagrama de Bode fornecido.",
                                "Interpretar PM=50° como 'boa' e justificar.",
                                "Prever qualitativamente o impacto de PM baixa na step response.",
                                "Calcular PM para uma G(s) simples.",
                                "Propor melhoria se PM<30°."
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição e fórmula (20%)",
                                "Correta localização e cálculo em Bode (25%)",
                                "Interpretação qualitativa e quantitativa (20%)",
                                "Análise de impacto em amortecimento/transitório (20%)",
                                "Uso de exemplos/simulações (10%)",
                                "Clareza e estrutura da explicação (5%)"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Análise de fasores e funções complexas.",
                                "Física: Dinâmica de osciladores amortecidos e estabilidade.",
                                "Informática: Simulação numérica com MATLAB/Python.",
                                "Engenharia Mecânica: Controle de vibrações em estruturas."
                              ],
                              "realWorldApplication": "Na aviação, a margem de fase em sistemas de piloto automático garante estabilidade do avião frente a turbulências ou variações de aerodinâmica, evitando oscilações perigosas e melhorando a robustez do voo."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.4.1.3",
                            "name": "Calcular margens clássicas a partir de diagramas de Bode",
                            "description": "Realizar o cálculo numérico das margens de ganho e fase utilizando diagramas de Bode de funções de transferência de malha aberta, interpretando os valores para avaliar robustez nominal.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Identificar Componentes Chave do Diagrama de Bode",
                                  "subSteps": [
                                    "Examinar o gráfico de magnitude em dB versus log(ω) e o gráfico de fase em graus versus log(ω).",
                                    "Localizar a frequência de ganho crossover (ω_gc), onde a magnitude cruza 0 dB.",
                                    "Identificar a frequência de fase crossover (ω_pc), onde a fase atinge -180°.",
                                    "Anotar escalas logarítmicas e pontos de referência como cantos de polos/zeros.",
                                    "Verificar se o diagrama representa a função de malha aberta G(s)H(s)."
                                  ],
                                  "verification": "Diagrama anotado com ω_gc e ω_pc marcados com precisão gráfica (±0.1 década).",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Diagrama de Bode impresso ou digital",
                                    "Régua ou software de plotagem (MATLAB/Python)",
                                    "Papel milimetrado"
                                  ],
                                  "tips": "Amplie o gráfico digitalmente para leituras precisas; use cursor para interpolar valores.",
                                  "learningObjective": "Dominar a leitura e anotação precisa de diagramas de Bode para análise de estabilidade.",
                                  "commonMistakes": [
                                    "Confundir eixos de magnitude e fase.",
                                    "Ler frequências em escala linear em vez de logarítmica.",
                                    "Ignorar a direção de cruzamento (ascendente/descendente)."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Calcular a Margem de Ganho (GM)",
                                  "subSteps": [
                                    "Localizar ω_pc no gráfico de fase onde φ(ω_pc) = -180° ± 360°k (geralmente o primeiro cruzamento).",
                                    "Ler o valor de magnitude |G(jω_pc)|_dB no gráfico de magnitude nessa frequência.",
                                    "Calcular GM_dB = -|G(jω_pc)|_dB; converter para linear se necessário: GM = 10^(-GM_dB/20).",
                                    "Confirmar unidade: dB para aditiva, fator para multiplicativa.",
                                    "Documentar o cálculo com equação e valor numérico."
                                  ],
                                  "verification": "Valor de GM calculado corretamente com fórmula e número exato (ex: GM = 10 dB).",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Diagrama de Bode anotado do Step 1",
                                    "Calculadora científica",
                                    "Folha de cálculos"
                                  ],
                                  "tips": "Interpole linearmente em log escala para precisão; GM > 0 indica estabilidade.",
                                  "learningObjective": "Executar cálculo numérico preciso da margem de ganho a partir de dados gráficos.",
                                  "commonMistakes": [
                                    "Usar ω_gc em vez de ω_pc.",
                                    "Esquecer o sinal negativo na conversão dB.",
                                    "Não considerar múltiplos cruzamentos de fase."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular a Margem de Fase (PM)",
                                  "subSteps": [
                                    "Localizar ω_gc no gráfico de magnitude onde |G(jω_gc)|_dB = 0 dB.",
                                    "Ler o valor de fase φ(ω_gc) no gráfico de fase nessa frequência.",
                                    "Calcular PM = 180° + φ(ω_gc) (para convenção padrão).",
                                    "Verificar consistência com direção de cruzamento de ganho.",
                                    "Registrar o valor em graus com justificativa."
                                  ],
                                  "verification": "Valor de PM calculado e justificado (ex: PM = 45°).",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Diagrama de Bode anotado",
                                    "Calculadora",
                                    "Tabela de referência de Bode"
                                  ],
                                  "tips": "PM é medida a partir de -180°; valores positivos indicam reserva de fase.",
                                  "learningObjective": "Realizar cálculo preciso da margem de fase com interpretação gráfica.",
                                  "commonMistakes": [
                                    "Usar ω_pc em vez de ω_gc.",
                                    "Errar o sinal: PM = φ(ω_gc) + 180°.",
                                    "Ignorar atrasos de fase adicionais."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Interpretar Margens para Avaliar Robustez Nominal",
                                  "subSteps": [
                                    "Comparar GM com thresholds: GM > 6 dB (bom), > 9 dB (excelente).",
                                    "Avaliar PM: PM > 45° (bom), > 60° (excelente).",
                                    "Analisar trade-offs: alto GM pode reduzir PM e vice-versa.",
                                    "Concluir sobre robustez: margens indicam tolerância a ganhos (±GM_dB, ±PM°).",
                                    "Discutir implicações para incertezas em parâmetros."
                                  ],
                                  "verification": "Relatório escrito com interpretação qualitativa e quantitativa da robustez.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Valores de GM e PM calculados",
                                    "Tabela de critérios de robustez",
                                    "Software de simulação opcional"
                                  ],
                                  "tips": "Use regra empírica: produto GM * PM > certo valor para robustez balanceada.",
                                  "learningObjective": "Interpretar margens clássicas para julgar estabilidade e robustez de sistemas LIT.",
                                  "commonMistakes": [
                                    "Interpretar GM < 0 como instável sem contexto.",
                                    "Ignorar interdependência entre GM e PM.",
                                    "Superestimar robustez sem considerar dinâmica rápida."
                                  ]
                                }
                              ],
                              "practicalExample": "Considere G(s)H(s) = 10 / (s(s+1)(s+10)) com diagrama Bode: ω_gc ≈ 3 rad/s (mag=0dB, fase≈-135°), ω_pc ≈ 5 rad/s (fase=-180°, mag≈-12dB). Cálculo: PM = 180° - 135° = 45°; GM = 12 dB. Interpretação: Robustez moderada, tolera variação de ganho até +12dB.",
                              "finalVerifications": [
                                "Identifica corretamente ω_gc e ω_pc no diagrama.",
                                "Calcula GM e PM com precisão numérica (±1 dB ou ±2°).",
                                "Interpreta margens com thresholds padrão.",
                                "Explica impacto em robustez nominal.",
                                "Aplica a exemplo prático sem erros.",
                                "Documenta todos os passos de forma clara."
                              ],
                              "assessmentCriteria": [
                                "Precisão gráfica: leituras de frequência e valores (±10% erro máximo).",
                                "Correção matemática: fórmulas GM/PM aplicadas corretamente.",
                                "Profundidade de interpretação: ligação com robustez e incertezas.",
                                "Clareza de documentação: anotações legíveis e lógicas.",
                                "Eficiência temporal: completa em <70 minutos totais.",
                                "Criatividade: sugere melhorias no loop de controle baseadas nas margens."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Operações logarítmicas e interpolação em escalas semilogarítmicas.",
                                "Eletrônica: Análise de filtros e amplificadores em frequência.",
                                "Física: Dinâmica de sistemas oscilatórios e amortecimento.",
                                "Programação: Geração de diagramas Bode via Python (control library) ou MATLAB.",
                                "Estatística: Análise de incertezas e variabilidade paramétrica."
                              ],
                              "realWorldApplication": "Em automação industrial, como controle de posição de braços robóticos, margens de Bode garantem estabilidade apesar de variações em massa de carga ou atrito, evitando oscilações destrutivas e melhorando precisão de rastreamento."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.2.4.1.1",
                              "10.1.2.4.1.2"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "10.1.2.4.2",
                        "name": "Margem de Ganho Robusta",
                        "description": "Definição formal da margem de ganho robusta para sistemas LIT com incertezas paramétricas ou dinâmicas, representando a tolerância máxima a variações de ganho sob todas as incertezas admissíveis.",
                        "specificSkills": [
                          {
                            "id": "10.1.2.4.2.1",
                            "name": "Definir margem de ganho robusta",
                            "description": "Formular a margem de ganho robusta como o mínimo das margens de ganho sobre o conjunto de plantas perturbadas por incertezas multiplicativas ou aditivas, utilizando a forma padrão de incerteza.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Conceitos Fundamentais de Margem de Ganho e Robustez",
                                  "subSteps": [
                                    "Estudar a definição de margem de ganho (gm) para um sistema de laço fechado nominal usando diagramas de Bode.",
                                    "Explicar o conceito de robustez como a capacidade do controlador manter estabilidade apesar de perturbações.",
                                    "Identificar a importância da margem de ganho na análise de estabilidade.",
                                    "Diferenciar incertezas estruturadas de não-estruturadas.",
                                    "Revisar a forma padrão de incerteza: PΔ = P (I + W Δ), onde |Δ| ≤ 1."
                                  ],
                                  "verification": "Explicar verbalmente ou por escrito a relação entre margem de ganho nominal e robustez, com um diagrama simples.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Livro de Doyle et al. 'Feedback Control Theory'",
                                    "Software MATLAB/Simulink",
                                    "Notas de aula sobre diagramas de Bode"
                                  ],
                                  "tips": "Desenhe diagramas de Bode manualmente para fixar conceitos visuais.",
                                  "learningObjective": "Dominar os pré-requisitos teóricos para margens robustas.",
                                  "commonMistakes": [
                                    "Confundir margem de ganho com margem de fase",
                                    "Ignorar a normalização das incertezas",
                                    "Não considerar o loop de realimentação unitária"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Modelar Incertezas Multiplicativas e Aditivas",
                                  "subSteps": [
                                    "Definir incerteza aditiva: PΔ(ω) = P(ω) + W_a(ω) Δ_a(ω), com ||Δ_a||_∞ ≤ 1.",
                                    "Definir incerteza multiplicativa: PΔ(ω) = P(ω) (I + W_m(ω) Δ_m(ω)), com ||Δ_m||_∞ ≤ 1.",
                                    "Construir funções peso W_a(s) e W_m(s) baseadas em dados de variação de parâmetros.",
                                    "Plotar as incertezas no plano de Nyquist ou Bode para visualização.",
                                    "Verificar a forma padrão unificada para ambos os tipos."
                                  ],
                                  "verification": "Construir e plotar um modelo de incerteza para uma planta simples e confirmar normalização.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "MATLAB com toolbox Control System",
                                    "Exemplos de Skogestad 'Multivariable Feedback Control'",
                                    "Planilha para dados de incerteza"
                                  ],
                                  "tips": "Use funções peso que capturem o pior caso em baixas e altas frequências.",
                                  "learningObjective": "Capacitar modelagem precisa de incertezas em plantas LIT.",
                                  "commonMistakes": [
                                    "Usar pesos inadequados que superestimam incerteza",
                                    "Confundir aditiva com multiplicativa em plantas integradoras",
                                    "Não normalizar Δ para ||Δ||_∞ ≤ 1"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Definir o Conjunto de Plantas Perturbadas",
                                  "subSteps": [
                                    "Descrever o conjunto Π = {PΔ : ||Δ||_∞ ≤ 1}, onde PΔ é a planta perturbada.",
                                    "Expressar a função de loop LΔ(s) = C(s) PΔ(s) para cada PΔ ∈ Π.",
                                    "Identificar que a estabilidade robusta requer |LΔ(jω)| < 1 para todos ω e PΔ.",
                                    "Relacionar com a condição μ ≤ 1/||T||_∞ para robustez.",
                                    "Listar todas as plantas perturbadas possíveis via vértices ou extremos."
                                  ],
                                  "verification": "Listar 3 plantas perturbadas extremas e plotar seus diagramas de Bode.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Script MATLAB para gerar conjunto Π",
                                    "Artigo sobre robustez de Zhou et al.",
                                    "Gráficos de Bode comparativos"
                                  ],
                                  "tips": "Foque em perturbações nos vértices de Δ para simplificar o conjunto.",
                                  "learningObjective": "Compreender o conjunto infinito de plantas como base para margens robustas.",
                                  "commonMistakes": [
                                    "Considerar apenas perturbações nominais",
                                    "Esquecer a multiplicação pela planta nominal",
                                    "Não usar norma ∞ corretamente"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Formular e Calcular a Margem de Ganho Robusta",
                                  "subSteps": [
                                    "Definir gm_rob = min_{PΔ ∈ Π} gm(LΔ), onde gm(LΔ) = 1 / max_ω |LΔ(jω)|.",
                                    "Calcular gm_rob como 1 / max_ω ||W_m(jω) T(jω)||_∞ para incerteza multiplicativa.",
                                    "Para aditiva: gm_rob = 1 / max_ω ||W_a(jω) S(jω) / P(jω)||_∞.",
                                    "Implementar computacionalmente via simulações de Monte Carlo ou otimização.",
                                    "Interpretar gm_rob > 1 como garantia de estabilidade robusta."
                                  ],
                                  "verification": "Calcular gm_rob para um exemplo dado e confirmar estabilidade para perturbações aleatórias.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "MATLAB function margin() estendida",
                                    "Robust Control Toolbox",
                                    "Exercícios resolvidos de controle robusto"
                                  ],
                                  "tips": "Use a fórmula conservadora ||W T||_∞ para aproximação rápida.",
                                  "learningObjective": "Formular matematicamente e computacionalmente a margem de ganho robusta.",
                                  "commonMistakes": [
                                    "Tomar mínimo local em vez de global",
                                    "Usar S em vez de T para multiplicativa",
                                    "Ignorar a frequência crítica"
                                  ]
                                }
                              ],
                              "practicalExample": "Para a planta nominal G(s) = 1/(s(s+1)) com controlador C(s) = 2(s+0.5), incerteza multiplicativa W_m(s) = 0.2(s+10)/(s+0.1). Calcule gm_rob = 1 / max_ω |W_m(jω) T(jω)| ≈ 1.5, garantindo estabilidade para |Δ_m| ≤ 1.",
                              "finalVerifications": [
                                "Definir corretamente o conjunto de plantas perturbadas Π.",
                                "Formular gm_rob como mínimo das margens nominais sobre Π.",
                                "Distinguir fórmulas para incertezas aditivas vs. multiplicativas.",
                                "Calcular numericamente gm_rob para um exemplo com erro < 5%.",
                                "Interpretar gm_rob < 1 como instabilidade robusta.",
                                "Plotar Bode de LΔ para planta pior-caso."
                              ],
                              "assessmentCriteria": [
                                "Precisão matemática na definição de gm_rob (100% correção).",
                                "Correta identificação de funções peso e normalização.",
                                "Qualidade dos plots e visualizações (clareza e legendas).",
                                "Eficiência computacional no cálculo (tempo < 1 min).",
                                "Interpretação física correta da robustez.",
                                "Tratamento de erros comuns ausente."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Normas de Hardy e análise funcional para ||.||_∞.",
                                "Programação: Implementação em MATLAB/Python para simulações robustas.",
                                "Física: Modelagem de sistemas reais com variações paramétricas.",
                                "Estatística: Análise de Monte Carlo para validação de incertezas.",
                                "Otimização: Minimização conservadora via μ-síntese."
                              ],
                              "realWorldApplication": "Em controle de processos químicos industriais, onde variações de temperatura causam incertezas multiplicativas nos ganhos de plantas, garantindo estabilidade sem desligamentos frequentes."
                            },
                            "estimatedTime": "0.75 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.2.4.1.3"
                            ]
                          },
                          {
                            "id": "10.1.2.4.2.2",
                            "name": "Modelar incertezas para cálculo de margem de ganho robusta",
                            "description": "Construir modelos de incertezas normalizados (ex.: Δ multiplicativa com ||Δ||∞ ≤1) e representar o sistema na forma padrão M-Δ para análise de robustez em ganho.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Identificar e normalizar incertezas no sistema",
                                  "subSteps": [
                                    "Analise o sistema LIT (Linear Invariante no Tempo) e identifique fontes de incerteza, como variações em parâmetros ou não-linearidades aproximadas.",
                                    "Defina o modelo de incerteza Δ como perturbador multiplicativo: G_Δ(s) = G(s)(I + Δ(s)), onde G(s) é a planta nominal.",
                                    "Normalize Δ tal que ||Δ||∞ ≤ 1, computando W_Δ(s) = |Δ(jω)| / |G(jω)| para escalonamento.",
                                    "Verifique a normalização plotando singular values de Δ normalizado.",
                                    "Documente as suposições sobre o tipo de incerteza (ex.: real, complexa)."
                                  ],
                                  "verification": "Confirme que o pico do valor singular máximo de Δ é ≤1 em todas as frequências.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "MATLAB/Simulink ou Python (Control Systems Library)",
                                    "Documentação do sistema nominal G(s)",
                                    "Gráficos de Bode para análise de frequência"
                                  ],
                                  "tips": "Comece com incertezas conhecidas de literatura ou simulações para validar.",
                                  "learningObjective": "Compreender como representar incertezas reais de forma normalizada para análise de robustez.",
                                  "commonMistakes": [
                                    "Esquecer de normalizar corretamente, levando a ||Δ||∞ >1",
                                    "Confundir Δ aditiva com multiplicativa",
                                    "Ignorar fase nas incertezas complexas"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Construir a representação padrão M-Δ",
                                  "subSteps": [
                                    "Defina os blocos do sistema de laço fechado: controlador K(s), planta G(s), e incerteza Δ(s).",
                                    "Monte a estrutura M-Δ onde M é o sistema nominal interconectado com Δ: saídas de M para entradas de Δ e vice-versa.",
                                    "Para ganho robusto, posicione Δ após G: M = [T; S] ou configuração apropriada para margem de ganho.",
                                    "Implemente em software: use funções como 'lft' no MATLAB para formar o sistema linear fracionário transformado (LFT).",
                                    "Valide a interconexão simulando respostas nominais."
                                  ],
                                  "verification": "Simule o LFT com Δ=0 e confirme que coincide com o sistema nominal.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "MATLAB Robust Control Toolbox",
                                    "Diagrama de blocos do sistema",
                                    "Funções sysic/ss para estados-espaciais"
                                  ],
                                  "tips": "Use diagramas de sinal para visualizar fluxos antes de codificar.",
                                  "learningObjective": "Dominar a formação da estrutura M-Δ para análise de robustez estrutural.",
                                  "commonMistakes": [
                                    "Posição incorreta de Δ (ex.: antes do controlador)",
                                    "Não converter para LFT adequadamente",
                                    "Misturar entradas/saídas de Δ"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular a margem de ganho robusta",
                                  "subSteps": [
                                    "Compute o valor μ (ganho estruturado) ou ||M||∞ para o pior caso Δ com ||Δ||∞ ≤1.",
                                    "A margem de ganho robusta é 1 / μ_MΔ, onde μ >1 indica instabilidade possível.",
                                    "Use mu-toolbox ou uss.norm para calcular normas H∞ de M.",
                                    "Analise curvas de μ vs. frequência para identificar pontos críticos.",
                                    "Compare com margens clássicas (ganho/fase) para insights."
                                  ],
                                  "verification": "Obtenha μ_MΔ ≤1 para robustez garantida em ganho.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "MATLAB Robust Control Toolbox (mu-analysis)",
                                    "Sistema M-Δ do passo anterior",
                                    "Plots de Nichols/Bode para comparação"
                                  ],
                                  "tips": "Para Δ escalar, μ coincide com ||M||∞; use para validação inicial.",
                                  "learningObjective": "Aplicar ferramentas de análise μ para quantificar robustez em ganho.",
                                  "commonMistakes": [
                                    "Confundir μ com norma H∞ sem estrutura",
                                    "Ignorar bloqueios em Δ full-block",
                                    "Interpretar erroneamente 1/μ como margem absoluta"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Validar e interpretar o modelo de robustez",
                                  "subSteps": [
                                    "Simule o sistema com Δ no limite ||Δ||∞=1 e verifique estabilidade.",
                                    "Sensitize o modelo variando parâmetros e recalcule margens.",
                                    "Gere relatório com plots de μ, singular values e respostas temporais.",
                                    "Discuta limitações: conservadorismo do modelo Δ.",
                                    "Proponha refinamentos, como Δ dinâmico vs. estático."
                                  ],
                                  "verification": "Todas as simulações com Δ perturbado mantêm estabilidade e desempenho.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Simulink para simulações não-lineares",
                                    "Relatórios gerados por publish no MATLAB"
                                  ],
                                  "tips": "Use grid-based uncertainty para validação Monte Carlo.",
                                  "learningObjective": "Interpretar resultados de robustez e propor melhorias iterativas.",
                                  "commonMistakes": [
                                    "Sobreestimar robustez ignorando simulações",
                                    "Não documentar suposições de Δ",
                                    "Confundir robustez com desempenho nominal"
                                  ]
                                }
                              ],
                              "practicalExample": "Considere um sistema de controle de posição de um motor DC com incerteza multiplicativa de 20% no ganho da planta G(s) = 1/(s(s+1)). Normalize Δ(s) = 0.2 * (real perturbation), forme M-Δ com controlador PI, e calcule margem de ganho robusta como 1/μ ≈ 1.15, indicando robustez marginal.",
                              "finalVerifications": [
                                "||Δ||∞ ≤ 1 confirmado por análise de frequência.",
                                "Estrutura M-Δ validada por simulação nominal.",
                                "Margem de ganho robusta 1/μ_MΔ >1 calculada corretamente.",
                                "Simulações com Δ extremo mostram estabilidade.",
                                "Relatório inclui plots de μ e singular values.",
                                "Limitações do modelo documentadas."
                              ],
                              "assessmentCriteria": [
                                "Precisão da normalização de Δ (erro <5%).",
                                "Corretude da interconexão M-Δ (simulação nominal idêntica).",
                                "Exatidão do cálculo μ (coerente com toolbox).",
                                "Profundidade da análise de frequência e temporal.",
                                "Clareza do relatório e interpretação de resultados.",
                                "Identificação de pelo menos 2 limitações/conservadorismos."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria de Normas (H∞, ∞-norma) e Valores Singulares.",
                                "Probabilidade e Estatística: Modelagem estocástica de incertezas.",
                                "Física: Dinâmica de sistemas mecânicos/elétricos com variações paramétricas.",
                                "Computação: Programação numérica em MATLAB/Python para análise de sistemas.",
                                "Engenharia de Software: Validação e verificação de modelos simulados."
                              ],
                              "realWorldApplication": "Em controle de voo de aeronaves, modela incertezas aerodinâmicas (variações de ângulo de ataque) para garantir margem de ganho robusta contra instabilidades, evitando falhas catastróficas em condições adversas como turbulência."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.2.4.2.1"
                            ]
                          },
                          {
                            "id": "10.1.2.4.2.3",
                            "name": "Calcular margem de ganho robusta numericamente",
                            "description": "Aplicar métodos como avaliação em malha ou otimização para computar a margem de ganho robusta, utilizando ferramentas como MATLAB para verificar estabilidade robusta.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar conceitos teóricos e preparar modelo do sistema",
                                  "subSteps": [
                                    "Estude a definição de margem de ganho robusta (kg) como o menor fator de ganho que causa instabilidade no pior caso de incerteza.",
                                    "Identifique o modelo nominal G(s) e as incertezas Δ (multiplicativa ou aditiva).",
                                    "Formule o loop de realimentação com controlador C(s) e incerteza.",
                                    "Desenhe o diagrama de bloco e escreva as equações para |1 + C G (I + Δ)| = 0.",
                                    "Compile referências teóricas de livros como Zhou 'Robust and Optimal Control'."
                                  ],
                                  "verification": "Crie um resumo de 1 página explicando kg e liste 3 exemplos de incertezas comuns; revise com um colega ou tutor.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Livro 'Robust and Optimal Control' (Zhou), MATLAB instalado, caderno para anotações"
                                  ],
                                  "tips": "Comece com sistemas LIT simples (1º ou 2º ordem) para intuição antes de casos complexos.",
                                  "learningObjective": "Compreender fundamentos teóricos da margem de ganho robusta e modelagem de incertezas.",
                                  "commonMistakes": [
                                    "Confundir margem de ganho nominal com robusta",
                                    "Ignorar estrutura da incerteza (ex: Δ real vs complexa)",
                                    "Esquecer normalização da incerteza"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar análise de malha numérica no MATLAB",
                                  "subSteps": [
                                    "Defina funções de transferência nominal G(s) e incerteza Δ usando tf() ou zpk().",
                                    "Gere uma malha de pontos no plano complexo para Δ usando meshgrid().",
                                    "Calcule o loop aberto L(jω) = C(jω)G(jω) para múltiplas frequências ω.",
                                    "Para cada ponto da malha, verifique se |1 + L(1 + Δ)| < 1 para instabilidade e encontre min(1/|Δ|).",
                                    "Use loop for ou parfor para eficiência computacional."
                                  ],
                                  "verification": "Execute o script e plote o mapa de estabilidade; confirme que kg é o raio mínimo do círculo de instabilidade.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "MATLAB com Control System Toolbox, script template para malha (disponível online)"
                                  ],
                                  "tips": "Use logspace para ω e evite malhas muito densas inicialmente para depuração rápida.",
                                  "learningObjective": "Dominar avaliação em malha para computar kg numericamente.",
                                  "commonMistakes": [
                                    "Escala errada na malha (use raios logarítmicos)",
                                    "Não discretizar ω adequadamente (pelo menos 100 pontos)",
                                    "Confundir critério de Nyquist com robusto"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar método de otimização para margem de ganho",
                                  "subSteps": [
                                    "Defina função objetivo f(δ) = |1 + C G (I + δ)| onde δ é parâmetro de incerteza escalar.",
                                    "Use fmincon() ou ga() do Optimization Toolbox para minimizar 1/|δ| sujeito a ||δ|| ≤ 1.",
                                    "Inclua restrições de fase e magnitude para incertezas realistas.",
                                    "Compare resultados da otimização com a malha para validação.",
                                    "Otimize parâmetros do controlador para maximizar kg."
                                  ],
                                  "verification": "Obtenha kg via otimização e confirme que coincide com malha dentro de 5%; gere relatório comparativo.",
                                  "estimatedTime": "2.5 horas",
                                  "materials": [
                                    "MATLAB Optimization Toolbox, exemplos de robustcontrol toolbox"
                                  ],
                                  "tips": "Inicialize com solução da malha como chute inicial para convergência rápida.",
                                  "learningObjective": "Aplicar otimização numérica para cálculo preciso de kg em sistemas complexos.",
                                  "commonMistakes": [
                                    "Restrições lineares em vez de não-lineares",
                                    "Não verificar gradientes numéricos",
                                    "Sobre-otimização levando a soluções não-físicas"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar resultados e verificar estabilidade robusta",
                                  "subSteps": [
                                    "Plote diagramas de Bode robustos e μ-plot usando robuststab().",
                                    "Calcule kg geral e compare com margens nominais.",
                                    "Simule respostas no tempo com incertezas extremas usando lsim() ou step().",
                                    "Documente trade-offs entre desempenho e robustez.",
                                    "Teste sensibilidade variando parâmetros do modelo."
                                  ],
                                  "verification": "Gere gráficos e relatório mostrando kg > 1 e estabilidade para ||Δ|| < 1/kg.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Robust Control Toolbox no MATLAB, templates de relatório LaTeX ou Word"
                                  ],
                                  "tips": "Use loopinfo() para visualizar caminhos de incerteza crítica.",
                                  "learningObjective": "Interpretar e validar margens de robustez em contexto de estabilidade.",
                                  "commonMistakes": [
                                    "Interpretar kg < 1 como estável",
                                    "Ignorar crosstalk entre incertezas",
                                    "Não simular casos de pior-caso"
                                  ]
                                }
                              ],
                              "practicalExample": "Para um controlador PI em um motor DC com incerteza multiplicativa de 30% no ganho, use G(s) = 1/(s+1), Δ = 0.3 * randn(). Implemente malha 100x100 e otimização para encontrar kg ≈ 2.1, confirmando estabilidade robusta via simulação de step response com Δ máxima.",
                              "finalVerifications": [
                                "Cálculo de kg via malha coincide com otimização (erro < 2%).",
                                "Plota de estabilidade mostra região estável correta.",
                                "Simulações no tempo com Δ = 1/kg mostram oscilações marginais mas estáveis.",
                                "Relatório explica limitações do método para sistemas não-LIT.",
                                "Código MATLAB é modular e comentado para reutilização.",
                                "kg > 1.5 para exemplo prático proposto."
                              ],
                              "assessmentCriteria": [
                                "Precisão numérica do kg (erro < 5% vs analítico quando possível).",
                                "Eficiência computacional (tempo < 5 min para malha 200x200).",
                                "Qualidade dos plots e visualizações (legíveis, anotados).",
                                "Correta interpretação de resultados em termos de robustez.",
                                "Código limpo, com funções reutilizáveis e tratamento de erros.",
                                "Integração de ambos métodos (malha + otimização) com comparação."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Otimização não-linear e análise complexa.",
                                "Programação: Algoritmos numéricos e vectorização em MATLAB.",
                                "Física: Dinâmica de sistemas com perturbações paramétricas.",
                                "Estatística: Análise de Monte Carlo para validação de incertezas estocásticas."
                              ],
                              "realWorldApplication": "Em controle de drones, calcular kg garante estabilidade apesar de variações em massa de carga ou vento, evitando crashes; usado na indústria aeroespacial pela NASA em projetos como o X-43A."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.2.4.2.2"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "10.1.2.4.3",
                        "name": "Margem de Fase Robusta",
                        "description": "Definição e interpretação da margem de fase robusta em sistemas LIT com incertezas, quantificando a tolerância a variações de fase preservando estabilidade para o conjunto de incertezas.",
                        "specificSkills": [
                          {
                            "id": "10.1.2.4.3.1",
                            "name": "Definir margem de fase robusta",
                            "description": "Estabelecer a margem de fase robusta como o mínimo das margens de fase sobre todas as perturbações de incerteza, diferenciando-a das margens clássicas em cenários com incertezas não estruturadas.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Conceitos Fundamentais de Margens de Fase Clássicas",
                                  "subSteps": [
                                    "Estude a definição de margem de fase em sistemas LIT estáveis: ângulo pelo qual o ganho de fase pode ser reduzido antes da instabilidade.",
                                    "Revise o diagrama de Bode e como identificar o ponto de ganho unitário (frequência de cruzamento de ganho).",
                                    "Analise exemplos simples de sistemas com e sem margem de fase positiva.",
                                    "Pratique o cálculo manual de margem de fase para um controlador proporcional-integral (PI).",
                                    "Discuta limitações das margens clássicas em sistemas nominais sem incertezas."
                                  ],
                                  "verification": "Calcule corretamente a margem de fase para um sistema dado e explique seu significado em um diagrama de Bode.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Livro de Ogata ou Franklin sobre Controle",
                                    "Software MATLAB/Simulink para Bode",
                                    "Notas de aula sobre estabilidade LIT"
                                  ],
                                  "tips": "Sempre verifique unidades de frequência (rad/s vs Hz) no diagrama de Bode.",
                                  "learningObjective": "Compreender a margem de fase clássica como métrica de estabilidade relativa.",
                                  "commonMistakes": [
                                    "Confundir margem de fase com margem de ganho",
                                    "Ignorar o ponto de ganho unitário",
                                    "Usar fase em vez de ganho no cruzamento"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Explorar Modelos de Incertezas Não Estruturadas",
                                  "subSteps": [
                                    "Defina incerteza não estruturada como perturbações representadas por normas (ex: norma H-infinito).",
                                    "Estude a representação multiplicativa ou aditiva de incertezas em laços de realimentação.",
                                    "Aprenda a modelar Δ (bloco de incerteza) com ||Δ||∞ ≤ 1.",
                                    "Construa um diagrama de laço fechado com incerteza não estruturada.",
                                    "Simule variações paramétricas para visualizar o impacto na resposta em frequência."
                                  ],
                                  "verification": "Desenhe o diagrama de incerteza não estruturada para um sistema dado e compute sua norma.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Referência: Doyle's Robust Control Notes",
                                    "MATLAB Robust Control Toolbox",
                                    "Exemplos de sistemas com variação de ganho/parâmetros"
                                  ],
                                  "tips": "Use a norma H-infinito para quantificar o 'tamanho' da incerteza de forma conservadora.",
                                  "learningObjective": "Modelar incertezas reais como blocos não estruturados para análise robusta.",
                                  "commonMistakes": [
                                    "Confundir incertezas estruturadas (paramétricas) com não estruturadas",
                                    "Esquecer a normalização da incerteza",
                                    "Subestimar o pior caso"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Definir Formalmente a Margem de Fase Robusta",
                                  "subSteps": [
                                    "Estabeleça a definição: φ_m robusta = min {φ_m (G(jω)(I + Δ_m))} sobre todas Δ com ||Δ||∞ ≤ 1.",
                                    "Derive a condição de estabilidade robusta via pequeno ganho teorema.",
                                    "Expresse como φ_m robusta = 180° - sup_ω [∠T(jω) + 20 log10(||T||∞)] onde T é a função de transferência complementar.",
                                    "Implemente o cálculo usando μ-síntese ou análise H-infinito.",
                                    "Valide com simulações de Monte Carlo para perturbações aleatórias."
                                  ],
                                  "verification": "Forneça a fórmula exata da margem de fase robusta e aplique a um LTI simples.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Artigo seminal de McFarlane/Glover sobre μ-analysis",
                                    "MATLAB mu-toolbox",
                                    "Planilhas de cálculo simbólico (SymPy)"
                                  ],
                                  "tips": "Lembre-se: é o mínimo sobre todas perturbações, garantindo robustez no pior caso.",
                                  "learningObjective": "Definir matematicamente a margem de fase robusta como métrica conservadora.",
                                  "commonMistakes": [
                                    "Usar média em vez de mínimo sobre perturbações",
                                    "Confundir com ganho robusto",
                                    "Ignorar a fase da sensibilidade complementar"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Diferenciar Margens Clássicas e Robustas com Exemplos",
                                  "subSteps": [
                                    "Compare cenários: margens clássicas falham em sistemas com Δ > 20%, mas robustas previnem.",
                                    "Calcule ambas para um sistema com variação de tempo morto.",
                                    "Analise trade-offs: robustez reduz performance nominal.",
                                    "Crie um relatório comparativo com gráficos de Bode para nominal vs pior caso.",
                                    "Discuta quando usar cada uma em design de controladores."
                                  ],
                                  "verification": "Explique diferenças em um exemplo numérico e mostre gráficos comparativos.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Simulink para simulações robustas",
                                    "Exemplos de Skogestad Postlethwaite",
                                    "Ferramentas de plotagem (Python Matplotlib)"
                                  ],
                                  "tips": "Sempre plote respostas no pior caso para validar robustez.",
                                  "learningObjective": "Diferenciar e justificar o uso da margem robusta em presença de incertezas.",
                                  "commonMistakes": [
                                    "Assumir equivalência entre margens clássicas e robustas",
                                    "Não considerar o custo computacional da análise robusta",
                                    "Overdesign sem necessidade"
                                  ]
                                }
                              ],
                              "practicalExample": "Para um sistema de posição de motor DC com G(s) = 1/(s(s+1)) e controlador PI, adicione incerteza multiplicativa Δ_m com ||Δ_m||∞=0.3. Calcule margem de fase clássica (~60°) vs robusta (~35°), simulando estabilidade no pior caso via Bode plot com fase mínima.",
                              "finalVerifications": [
                                "Define corretamente a margem de fase robusta como mínimo sobre perturbações.",
                                "Diferencia margens clássicas (nominal) de robustas (pior caso).",
                                "Aplica fórmula em exemplo simples com cálculo numérico.",
                                "Interpreta resultados em diagrama de Bode robusto.",
                                "Explica limitações em sistemas com incertezas não estruturadas.",
                                "Valida com simulação de estabilidade robusta."
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição matemática (100% match com literatura).",
                                "Correção em cálculos de exemplo (erro <5%).",
                                "Profundidade na diferenciação conceitual.",
                                "Qualidade de visualizações (gráficos claros).",
                                "Compreensão de implicações práticas em robustez.",
                                "Capacidade de generalizar para outros sistemas."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Análise complexa e normas em espaços de Hardy.",
                                "Programação: Implementação em MATLAB/Python para μ-cálculo.",
                                "Física: Modelagem de dinâmicas reais com ruído/parâmetros variáveis.",
                                "Estatística: Análise de Monte Carlo para validação.",
                                "Design de Engenharia: Trade-offs em otimização multiobjetivo."
                              ],
                              "realWorldApplication": "Em controle de voo de drones, onde variações de vento e massa criam incertezas não estruturadas; a margem de fase robusta garante estabilidade mesmo no pior cenário climático, evitando crashes."
                            },
                            "estimatedTime": "0.75 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.2.4.1.3",
                              "10.1.2.4.2.1"
                            ]
                          },
                          {
                            "id": "10.1.2.4.3.2",
                            "name": "Analisar impacto de incertezas na margem de fase",
                            "description": "Avaliar como incertezas dinâmicas afetam a margem de fase utilizando blocos de incerteza na forma padrão e critérios de robustez baseados em normas H∞.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Conceitos Fundamentais de Margem de Fase e Blocos de Incerteza",
                                  "subSteps": [
                                    "Defina margem de fase como o ângulo adicional de fase necessário para instabilidade em frequência de ganho unitário.",
                                    "Explique blocos de incerteza na forma padrão: Δ(jω) com ||Δ||∞ ≤ 1 representando incertezas normadas.",
                                    "Revise normas H∞ como medida de robustez: supremo da norma espectral da transferência.",
                                    "Identifique incertezas dinâmicas (ex.: variações paramétricas e não-paramétricas).",
                                    "Estude o lema de pequena ganho para estabilidade robusta."
                                  ],
                                  "verification": "Resuma em um diagrama os componentes de um loop com bloco de incerteza e liste 3 exemplos de incertezas dinâmicas.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Livro de Doyle 'Feedback Control Theory'",
                                    "MATLAB/Simulink com Robust Control Toolbox",
                                    "Notas de aula sobre H∞"
                                  ],
                                  "tips": "Use diagramas de bloco para visualizar incertezas multiplicativas ou aditivas.",
                                  "learningObjective": "Compreender a representação padrão de incertezas e seu impacto inicial na margem de fase.",
                                  "commonMistakes": [
                                    "Confundir margem de fase com margem de ganho",
                                    "Ignorar normatização das incertezas",
                                    "Não diferenciar incertezas estáticas de dinâmicas"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Modelar o Sistema com Blocos de Incerteza na Forma Padrão",
                                  "subSteps": [
                                    "Construa o sistema interconectado P(s) a partir do controlador C(s) e planta nominal G(s).",
                                    "Defina o bloco de incerteza Δ(s) para incertezas dinâmicas, garantindo ||Δ||∞ ≤ 1.",
                                    "Calcule pesos de incerteza WΔ(s) baseados em limites conhecidos de variação (ex.: ganho máximo).",
                                    "Implemente em MATLAB: sys = lft(P, Delta) para formar o sistema incerto.",
                                    "Gere ensemble de plantas incertas usando usim ou wcgain."
                                  ],
                                  "verification": "Crie e plote 10 realizações de plantas incertas e verifique se todas satisfazem as bounds de incerteza.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "MATLAB Robust Control Toolbox",
                                    "Tutoriais MathWorks sobre incertezas",
                                    "Plantas nominais de exemplos padrão (ex.: DC motor)"
                                  ],
                                  "tips": "Comece com incertezas multiplicativas para simplicidade em laços de feedback.",
                                  "learningObjective": "Modelar precisamente incertezas dinâmicas na forma padrão para análise posterior.",
                                  "commonMistakes": [
                                    "Não normatizar pesos WΔ corretamente",
                                    "Usar Delta não unitária levando a erros de escala",
                                    "Esquecer de incluir entradas de performance"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular Margem de Fase Robusta e Avaliar Impacto de Incertezas",
                                  "subSteps": [
                                    "Calcule a margem de fase nominal usando margin(sys_nominal).",
                                    "Use allmargin para margens robustas considerando incertezas: [Gm, Pm, Wcg, Wcp] = allmargin(sys_uncertain).",
                                    "Avalie o impacto via norma H∞ do sistema Tzw: gamma = norm(Tzw, inf).",
                                    "Plote curvas de singular values de T e WΔ para identificar frequências críticas.",
                                    "Simule respostas em malha fechada para ensembles incertos e observe oscilações."
                                  ],
                                  "verification": "Gere relatório com margens nominais vs. robustas e gráfico de singular values mostrando degradação.",
                                  "estimatedTime": "2.5 horas",
                                  "materials": [
                                    "Funções MATLAB: allmargin, norm, sigma",
                                    "Exemplos de benchmark como Quadrotor ou Inverted Pendulum"
                                  ],
                                  "tips": "Foco em frequência de crossover ωc onde fase é crítica para margem de fase.",
                                  "learningObjective": "Quantificar numericamente como incertezas reduzem a margem de fase usando métricas H∞.",
                                  "commonMistakes": [
                                    "Interpretar allmargin sem verificar mu-analysis para robustez estruturada",
                                    "Confundir Pm robusta com nominal",
                                    "Não plotar Bode de T para contexto"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Interpretar Resultados e Aplicar Critérios de Robustez",
                                  "subSteps": [
                                    "Compare margem de fase robusta Pm_robusta > 30° para aceitabilidade prática.",
                                    "Verifique condição de robustez: ||T * WΔ||∞ < 1 implica estabilidade.",
                                    "Analise sensibilidade: dPm/d||Δ|| para quantificar impacto.",
                                    "Proponha mitigação: ajuste controlador para maximizar Pm via síntese H∞.",
                                    "Documente trade-offs entre performance e robustez."
                                  ],
                                  "verification": "Escreva conclusão: 'Incertezas reduzem Pm de 45° para 20°, requer redesign' com evidências.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Ferramentas de síntese como hinfsyn",
                                    "Papéis sobre robustez em IEEE TAC"
                                  ],
                                  "tips": "Use mu-toolbox se disponível para análise estrutural avançada.",
                                  "learningObjective": "Interpretar análises H∞ para decisões de design robusto.",
                                  "commonMistakes": [
                                    "Aceitar Pm baixa sem contexto de aplicação",
                                    "Ignorar violações em baixas frequências",
                                    "Não considerar incertezas não modeladas"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um sistema de controle de velocidade de motor DC com incertezas dinâmicas na planta (variação de 20% em ganho e fase devido a carga), modele Δ(s) = WΔ(s)*Δ_unit(s), calcule allmargin mostrando redução de Pm de 50° para 25°, e simule step responses para verificar overshoot aumentado sob incertezas máximas.",
                              "finalVerifications": [
                                "Capacidade de modelar corretamente um sistema com blocos de incerteza Δ na forma padrão.",
                                "Cálculo preciso de margens robustas usando allmargin ou norm H∞.",
                                "Interpretação gráfica de singular values identificando frequências de pior caso.",
                                "Simulação de ensembles incertos sem instabilidades artificiais.",
                                "Proposta válida de mitigação baseada em análise.",
                                "Relatório coerente ligando incertezas à degradação de Pm."
                              ],
                              "assessmentCriteria": [
                                "Precisão matemática nos cálculos de normas H∞ (erro < 5%).",
                                "Completude do modelo de incertezas (todos pesos WΔ corretos).",
                                "Qualidade das visualizações (Bode, sigma plots legíveis).",
                                "Análise qualitativa e quantitativa do impacto em Pm.",
                                "Criatividade em exemplos e conexões práticas.",
                                "Clareza na documentação e avoidance de erros comuns."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria de operadores lineares e normas em espaços de Hardy.",
                                "Programação: Implementação numérica em MATLAB para análise de sistemas incertos.",
                                "Física: Modelagem de dinâmicas reais com ruído e variações paramétricas.",
                                "Estatística: Análise de ensembles e bounds probabilísticos de robustez."
                              ],
                              "realWorldApplication": "Em controle de flight de UAVs, onde incertezas aerodinâmicas dinâmicas (vento, massa variável) podem reduzir margem de fase, levando a oscilações; análise H∞ garante estabilidade robusta, evitando falhas em missões autônomas."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.2.4.3.1"
                            ]
                          },
                          {
                            "id": "10.1.2.4.3.3",
                            "name": "Calcular e interpretar margem de fase robusta",
                            "description": "Executar cálculos da margem de fase robusta via simulação ou métodos algorítmicos, interpretando resultados para especificações de projeto robusto em sistemas monovariáveis.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Fundamentos de Análise de Bode e Margens de Estabilidade Clássicas",
                                  "subSteps": [
                                    "Estude o diagrama de Bode de magnitude e fase para funções de transferência LIT.",
                                    "Identifique ganho de fase (PM) e margem de ganho (GM) em loops de controle unitário.",
                                    "Calcule PM e GM manualmente para um sistema simples usando ferramentas como MATLAB.",
                                    "Analise como variações paramétricas afetam as margens clássicas.",
                                    "Pratique com exemplos de sistemas de segunda ordem."
                                  ],
                                  "verification": "Construa e interprete corretamente o diagrama de Bode de um sistema dado, identificando PM e GM com erro <5° e <0.1 dB.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "MATLAB ou Octave",
                                    "Livro 'Feedback Control of Dynamic Systems' (cap. 6)",
                                    "Diagramas de Bode de exemplos pré-calculados"
                                  ],
                                  "tips": "Sempre normalize a função de laço unitário L(s) = G(s)H(s) antes da análise.",
                                  "learningObjective": "Compreender as bases para estender margens clássicas ao contexto robusto.",
                                  "commonMistakes": [
                                    "Confundir magnitude com fase",
                                    "Esquecer de considerar o ponto de ganho unitário",
                                    "Ignorar delays de fase"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Compreender Modelos de Incerteza e Robustez em Sistemas LIT",
                                  "subSteps": [
                                    "Defina incertezas aditivas, multiplicativas e paramétricas em funções de transferência nominais.",
                                    "Estude o conjunto de plantas incertas usando notação μ ou Structured Singular Value.",
                                    "Aprenda a representação de incertezas como Δ(s) com norma H∞ ≤1.",
                                    "Explore o teorema de robustez pequeno ganho (Small Gain Theorem).",
                                    "Simule famílias de plantas com variações de ±20% em parâmetros."
                                  ],
                                  "verification": "Descreva verbalmente ou por escrito o conjunto de plantas robustas para um exemplo dado.",
                                  "estimatedTime": "3 horas",
                                  "materials": [
                                    "Robust Control Toolbox (MATLAB)",
                                    "Artigo 'Robust Control Basics' de Doyle",
                                    "Notebooks Jupyter com exemplos de incertezas"
                                  ],
                                  "tips": "Visualize incertezas no plano complexo para intuição geométrica.",
                                  "learningObjective": "Modelar incertezas realistas em sistemas monovariáveis para análise robusta.",
                                  "commonMistakes": [
                                    "Confundir incerteza aditiva com multiplicativa",
                                    "Subestimar o impacto de delays",
                                    "Não normalizar incertezas"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular Margem de Fase Robusta via Simulação ou Algoritmos",
                                  "subSteps": [
                                    "Implemente o algoritmo de cálculo de margem de fase robusta (RPM) usando wcgain ou robuststab no MATLAB.",
                                    "Para simulação: Gere malha de plantas incertas e encontre o pior caso de PM.",
                                    "Calcule a frequência de cruzamento de ganho ω_c e a fase mínima sobre o conjunto incerto.",
                                    "Valide com método exato para sistemas de baixa ordem usando LMI ou μ-tools.",
                                    "Automatize o script para múltiplas simulações Monte Carlo."
                                  ],
                                  "verification": "Execute código que retorne RPM >45° para um sistema estável robusto, com log de simulações.",
                                  "estimatedTime": "4 horas",
                                  "materials": [
                                    "MATLAB Robust Control Toolbox",
                                    "Código-fonte de rpmcalc.m",
                                    "Datasets de plantas incertas (ex: DC motor com variação de resistência)"
                                  ],
                                  "tips": "Use gridsearch ou otimização para encontrar o pior caso eficientemente.",
                                  "learningObjective": "Executar cálculos precisos de RPM via ferramentas computacionais.",
                                  "commonMistakes": [
                                    "Amostragem insuficiente na malha de incertezas",
                                    "Erro em normalização da função de laço",
                                    "Confundir RPM com PM nominal"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Interpretar Resultados e Aplicar em Especificações de Projeto Robusto",
                                  "subSteps": [
                                    "Interprete RPM: valores >45° indicam robustez boa; <30° requer redesign.",
                                    "Compare RPM com margens clássicas e discuta trade-offs com desempenho.",
                                    "Defina especificações: RPM mínima para projeto dado ruído/distúrbios.",
                                    "Ajuste controlador (PID ou H∞) para melhorar RPM sem sacrificar velocidade.",
                                    "Documente relatório com gráficos de Bode robustos e conclusões."
                                  ],
                                  "verification": "Produza relatório de 1 página interpretando RPM para um caso e propondo melhorias.",
                                  "estimatedTime": "3 horas",
                                  "materials": [
                                    "Templates de relatório LaTeX",
                                    "Exemplos de controladores robustos",
                                    "Ferramenta sisotool para tuning"
                                  ],
                                  "tips": "Sempre plote Bode plots para nominal e pior caso lado a lado.",
                                  "learningObjective": "Traduzir RPM em decisões de design robusto práticas.",
                                  "commonMistakes": [
                                    "Ignorar interações com outras especificações",
                                    "Sobreestimar robustez baseada só em nominal",
                                    "Não considerar não-linearidades implícitas"
                                  ]
                                }
                              ],
                              "practicalExample": "Para um motor DC com função de transferência nominal P(s) = 1/(s(s+1)) e incerteza multiplicativa |Δ(s)|≤0.2, calcule RPM do laço com controlador C(s)=10(s+0.5). Simule 100 plantas, encontre PM mínima ≈52° no pior caso, confirmando estabilidade robusta para projeto de posicionamento.",
                              "finalVerifications": [
                                "Calcula RPM corretamente para sistema dado com erro <2° via simulação.",
                                "Identifica pior caso de incerteza e plota Bode robusto.",
                                "Interpreta RPM em termos de especificações de projeto (ex: RPM>40°).",
                                "Propõe ajustes no controlador se RPM insuficiente.",
                                "Valida estabilidade robusta com robuststab() retornando true.",
                                "Documenta processo com código reproduzível."
                              ],
                              "assessmentCriteria": [
                                "Precisão numérica do cálculo de RPM (90%+ acurácia).",
                                "Qualidade da modelagem de incertezas (cobertura realista).",
                                "Profundidade da interpretação (ligação com desempenho/estabilidade).",
                                "Eficiência computacional (tempo de simulação <5min).",
                                "Clareza de visualizações e relatório.",
                                "Criatividade em aplicações/extensões."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Análise complexa e otimização convexa (LMIs).",
                                "Programação: Algoritmos numéricos e simulação Monte Carlo.",
                                "Física: Dinâmica de sistemas mecânicos/elétricos com variações.",
                                "Estatística: Análise de ensembles e bounds probabilísticos."
                              ],
                              "realWorldApplication": "Em automação industrial, como controle robusto de temperatura em reatores químicos com variações de parâmetros (ex: viscosidade), garantindo estabilidade apesar de 20% de incerteza, evitando shutdowns caros e melhorando segurança em plantas da Petrobras ou indústrias farmacêuticas."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.2.4.3.2",
                              "10.1.2.4.2.3"
                            ]
                          },
                          {
                            "id": "10.1.2.4.3.4",
                            "name": "Comparar margens robustas com clássicas",
                            "description": "Comparar quantitativamente margens de ganho e fase robustas versus clássicas em exemplos práticos, destacando conservadorismo e requisitos de projeto.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Conceitos de Margens Clássicas de Ganho e Fase",
                                  "subSteps": [
                                    "Defina margem de ganho como a quantidade de ganho que pode ser aumentado antes da instabilidade (em dB).",
                                    "Defina margem de fase como o ângulo de fase adicional necessário para atingir -180° no ganho unitário.",
                                    "Construa o diagrama de Bode para um sistema de exemplo simples (ex: integrador com ganho).",
                                    "Identifique os pontos de corte de ganho (0 dB) e fase (-180°) nos gráficos de magnitude e fase.",
                                    "Calcule as margens usando as fórmulas padrão: GM = 1/|G(jω_pc)|, PM = 180° + ∠G(jω_gc)."
                                  ],
                                  "verification": "Construa manualmente ou simule o diagrama de Bode e anote valores corretos de GM e PM para um sistema dado.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Software de controle (MATLAB/Simulink ou Python com control library)",
                                    "Papel e calculadora para cálculos manuais"
                                  ],
                                  "tips": "Sempre verifique a estabilidade Nyquist primeiro para confirmar que as margens são válidas.",
                                  "learningObjective": "Compreender e calcular margens clássicas em sistemas LTI sem incertezas.",
                                  "commonMistakes": [
                                    "Confundir frequência de fase cruzada com ganho cruzada",
                                    "Ignorar unidades (dB vs linear)",
                                    "Não normalizar o loop de realimentação"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Introduzir Margens Robustas de Ganho e Fase",
                                  "subSteps": [
                                    "Explique incertezas multiplicativas Δ (ex: |Δ(jω)| ≤ w(ω), peso de incerteza).",
                                    "Defina margem robusta de ganho como inf_ω [1 / |T(jω)| * 1/|Δ_max(jω)| ] onde T é sensibilidade complementar.",
                                    "Defina margem robusta de fase considerando rotações de fase devido a incertezas.",
                                    "Aprenda a usar o valor singular estruturado μ para robustez (μ = 1/distância para instabilidade).",
                                    "Compare com clássicas: margens robustas são mais conservadoras devido a incertezas modeladas."
                                  ],
                                  "verification": "Derive ou recite as fórmulas para margens robustas e explique por que são menores que as clássicas.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Livro de referência em controle robusto (ex: Zhou 'Robust and Optimal Control')",
                                    "Tutoriais MATLAB Robust Control Toolbox"
                                  ],
                                  "tips": "Visualize incertezas como 'nuvem' ao redor da planta nominal no plano Nyquist.",
                                  "learningObjective": "Diferenciar margens robustas das clássicas incorporando modelos de incerteza.",
                                  "commonMistakes": [
                                    "Confundir Δ aditiva com multiplicativa",
                                    "Não escalar pesos de incerteza corretamente",
                                    "Ignorar a interconexão LFT"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Configurar e Simular um Exemplo Prático",
                                  "subSteps": [
                                    "Escolha um sistema: planta G(s) = 1/(s(s+1)), controlador C(s) = K(s+0.5)/s, incerteza multiplicativa w(s)=0.2.",
                                    "Monte o loop de realimentação e gere diagramas de Bode nominais.",
                                    "Incorpore incertezas usando interconexão LFT ou simulações Monte Carlo.",
                                    "Calcule margens clássicas usando funções como margin() no MATLAB.",
                                    "Calcule margens robustas com robuststab() ou usys robust control."
                                  ],
                                  "verification": "Gere plots de Bode e output numérico mostrando GM_clássica > GM_robusta.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "MATLAB com Robust Control Toolbox ou Python (control + slycot)",
                                    "Arquivos .m ou .py de exemplo"
                                  ],
                                  "tips": "Use grid() nos plots para precisão visual nas frequências críticas.",
                                  "learningObjective": "Implementar simulações práticas para margens em sistemas com incerteza.",
                                  "commonMistakes": [
                                    "Não fechar o loop corretamente",
                                    "Escolha de pesos w(s) irrealistas",
                                    "Simulações sem variação suficiente de parâmetros"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Comparar Quantitativamente e Analisar Implicações",
                                  "subSteps": [
                                    "Tabule valores: GM_clássica, PM_clássica vs GM_robusta, PM_robusta para o exemplo.",
                                    "Calcule ratios (ex: conservadorismo = GM_clássica / GM_robusta >1).",
                                    "Discuta requisitos de projeto: robustas garantem estabilidade para todas incertezas no modelo.",
                                    "Avalie trade-offs: controladores mais conservadores podem sacrificar performance nominal.",
                                    "Teste sensibilidade: varie incertezas e reforce comparações."
                                  ],
                                  "verification": "Crie uma tabela comparativa e gráfico destacando diferenças quantitativas.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Planilha Excel ou Jupyter notebook para tabelas",
                                    "Gráficos gerados no Step 3"
                                  ],
                                  "tips": "Quantifique conservadorismo com métricas como % de redução na margem.",
                                  "learningObjective": "Realizar comparações quantitativas destacando vantagens robustas em projetos.",
                                  "commonMistakes": [
                                    "Focar só qualitativamente sem números",
                                    "Ignorar contexto de incerteza no exemplo",
                                    "Generalizar de um caso só"
                                  ]
                                }
                              ],
                              "practicalExample": "Para um sistema de controle de velocidade de motor DC G(s) = 1/(s+1)(0.5s+1) com controlador PID e incerteza multiplicativa de 30% devido a variações de carga, as margens clássicas são GM=6 dB, PM=45°; robustas são GM=3.2 dB, PM=28°, mostrando 47% mais conservadorismo na GM.",
                              "finalVerifications": [
                                "Calcular corretamente margens clássicas e robustas para um sistema dado.",
                                "Explicar por que margens robustas são sempre menores ou iguais às clássicas.",
                                "Gerar tabela comparativa com ratios de conservadorismo.",
                                "Simular instabilidade com incertezas além da margem robusta.",
                                "Discutir impacto em requisitos de projeto (ex: ganho máximo permitido).",
                                "Identificar quando usar cada tipo baseado em nível de incerteza."
                              ],
                              "assessmentCriteria": [
                                "Precisão nos cálculos quantitativos (±5% de erro tolerado).",
                                "Clareza na tabela e gráficos comparativos.",
                                "Correta interpretação de conservadorismo e trade-offs.",
                                "Uso apropriado de ferramentas de simulação.",
                                "Profundidade na análise de implicações para design.",
                                "Capacidade de generalizar para outros sistemas."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Análise complexa e valores singulares (μ-analysis).",
                                "Programação: Simulações numéricas em MATLAB/Python.",
                                "Física: Modelagem de dinâmicas reais com incertezas paramétricas.",
                                "Estatística: Análise Monte Carlo para validação robusta.",
                                "Gestão de Projetos: Trade-offs entre robustez e performance."
                              ],
                              "realWorldApplication": "Em design de controladores para drones autônomos, margens robustas garantem estabilidade apesar de variações de vento e massa de carga, evitando crashes onde margens clássicas falhariam em cenários incertos."
                            },
                            "estimatedTime": "0.75 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.2.4.3.3"
                            ]
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.2.5",
                    "name": "Análise de Desempenho Robusto",
                    "description": "Avaliação de robustez em relação a especificações de desempenho como rastreamento e rejeição de distúrbios.",
                    "individualConcepts": [
                      {
                        "id": "10.1.2.5.1",
                        "name": "Especificações de Desempenho em Sistemas LIT",
                        "description": "Definição e caracterização das especificações clássicas de desempenho, como rastreamento de referências e rejeição de distúrbios, no contexto de sistemas lineares invariantes no tempo (LIT) monovariáveis.",
                        "specificSkills": [
                          {
                            "id": "10.1.2.5.1.1",
                            "name": "Definir métricas de rastreamento de referências",
                            "description": "Explicar e calcular o erro de rastreamento em regime permanente e transitório para entradas em degrau e rampa, utilizando funções de transferência de malha fechada e diagramas de Bode.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar funções de transferência de malha fechada e entradas padrão",
                                  "subSteps": [
                                    "Estudar a definição de função de transferência em malha fechada T(s) = G(s)/(1 + G(s)H(s)) para sistemas unitários.",
                                    "Identificar entradas degrau (1/s) e rampa (1/s²) no domínio de Laplace.",
                                    "Derivar a expressão geral do erro de rastreamento e(t) = r(t) - y(t).",
                                    "Explicar regime permanente (t → ∞) e transitório (t finito).",
                                    "Praticar derivação para sistemas de primeira e segunda ordem."
                                  ],
                                  "verification": "Derivar corretamente T(s) para um sistema dado e plotar respostas qualitativas para degrau e rampa.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Livro de controle (Ogata ou Franklin)",
                                    "Folha de papel e calculadora",
                                    "Software MATLAB/Simulink (opcional)"
                                  ],
                                  "tips": "Sempre verifique a estabilidade do sistema antes de analisar erros (polos no semiplano esquerdo).",
                                  "learningObjective": "Compreender a base teórica para análise de erros de rastreamento.",
                                  "commonMistakes": [
                                    "Confundir malha aberta com fechada",
                                    "Esquecer o feedback H(s)=1 em sistemas unitários",
                                    "Ignorar a transformada de Laplace das entradas"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Calcular erro de regime permanente para entrada em degrau",
                                  "subSteps": [
                                    "Aplicar o teorema do valor final: lim_{t→∞} e(t) = lim_{s→0} s E(s), onde E(s) = (1 - T(s)) R(s).",
                                    "Para degrau unitário R(s)=1/s, e_ss = 1 / (1 + K_p), com K_p = lim_{s→0} G(s).",
                                    "Classificar sistemas tipo 0, 1, 2 e seus erros: nulo para tipo ≥1.",
                                    "Resolver numericamente para G(s) exemplo: tipo 0 e tipo 1.",
                                    "Verificar com simulação ou tabela de erros padrão."
                                  ],
                                  "verification": "Calcular e_ss corretamente para 3 sistemas de tipos diferentes e justificar zero/nulo.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Tabelas de erros de regime permanente",
                                    "MATLAB para simulação",
                                    "Exercícios resolvidos de livros"
                                  ],
                                  "tips": "Lembre-se: K_p é o ganho estático posicional; aumente K para reduzir erro tipo 0.",
                                  "learningObjective": "Dominar cálculos de erro permanente para degrau usando teoremas finais.",
                                  "commonMistakes": [
                                    "Usar valor inicial em vez de final",
                                    "Confundir K_p com K_v",
                                    "Não considerar tipo do sistema"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular erro de regime permanente para entrada em rampa",
                                  "subSteps": [
                                    "Para rampa unitária R(s)=1/s², e_ss = 1 / K_v, com K_v = lim_{s→0} s G(s).",
                                    "Explicar nulo para tipo ≥2, finito para tipo 1, infinito para tipo 0.",
                                    "Derivar K_v para sistemas integrador e dupla integração.",
                                    "Comparar com degrau: rampa exige maior tipo para rastreamento perfeito.",
                                    "Praticar com exemplos mistos (degrau + rampa)."
                                  ],
                                  "verification": "Computar K_v e e_ss para sistemas tipo 0,1,2 e plotar respostas de erro.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Planilha Excel para cálculos",
                                    "Simulink para rampas",
                                    "Notas de aula sobre tipos de sistemas"
                                  ],
                                  "tips": "Ganho de velocidade K_v requer derivada em sG(s); verifique limites cuidadosamente.",
                                  "learningObjective": "Aplicar teorema para erros em rampa e classificar desempenho.",
                                  "commonMistakes": [
                                    "Esquecer o 's' em K_v = lim s G(s)",
                                    "Confundir rampa com parabólica (K_a)",
                                    "Assumir erro zero sem checar tipo"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar erro transitório usando funções de transferência e diagramas de Bode",
                                  "subSteps": [
                                    "Calcular E(s) = R(s) / (1 + G(s)) para malha fechada e inverter para e(t).",
                                    "Usar diagramas de Bode de T(s) para avaliar largura de banda e fase, impactando overshoot e settling time do erro.",
                                    "Interpretar: alta largura de banda reduz tempo transitório do erro.",
                                    "Simular respostas transitórias para degrau/rampa em software.",
                                    "Comparar erros transitórios com métricas: tempo de subida, pico, assentamento."
                                  ],
                                  "verification": "Gerar Bode de T(s), simular e(t) e identificar picos/máximos no transitório.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "MATLAB Control System Toolbox",
                                    "Ferramenta online de Bode (ex: control.com)",
                                    "Papel milimetrado para esboços"
                                  ],
                                  "tips": "Foco em margem de fase >45° para bom rastreamento transitório sem oscilações.",
                                  "learningObjective": "Integrar análise frequência para erros transitórios.",
                                  "commonMistakes": [
                                    "Analisar G(s) aberta em vez de T(s) fechada",
                                    "Ignorar delay de fase em baixas frequências",
                                    "Confundir erro transitório com permanente"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Sintetizar métricas e praticar em exemplo completo",
                                  "subSteps": [
                                    "Definir métricas completas: e_ss degrau/rampa + ITSE (integral tempo squared error) para transitório.",
                                    "Aplicar todas fórmulas em um sistema realista.",
                                    "Avaliar robustez: variar parâmetros e recalcular erros.",
                                    "Documentar relatório com cálculos, plots e conclusões.",
                                    "Resolver exercício de tunagem para minimizar erros."
                                  ],
                                  "verification": "Produzir relatório com métricas para sistema dado, <5% erro em cálculos.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Exemplo prático em PDF",
                                    "MATLAB script template",
                                    "Relatório template"
                                  ],
                                  "tips": "Use ITSE para quantificar transitório: ∫ t e²(t) dt.",
                                  "learningObjective": "Definir e calcular métricas completas de rastreamento.",
                                  "commonMistakes": [
                                    "Não normalizar entradas",
                                    "Omitir unidades em rampas (velocidade)",
                                    "Ignorar não-linearidades em simulações"
                                  ]
                                }
                              ],
                              "practicalExample": "Para um servo-motor de posição com G(s) = 100 / (s(s+10)), controlador P K=1 (T(s) ≈ 100/(s²+10s+100), tipo 1). Degrau: e_ss=0; Rampa v=1: e_ss=1/K_v=0.1 (K_v=10). Simule em MATLAB: erro transitório overshoot <10%, settling 0.5s. Bode: ω_c=30 rad/s.",
                              "finalVerifications": [
                                "Explicar verbalmente diferenças entre erros permanente/transitório para degrau/rampa.",
                                "Calcular corretamente e_ss para 2 sistemas tipo 1 sem erros.",
                                "Gerar diagrama Bode e interpretar impacto no transitório.",
                                "Simular e(t) em software e medir métricas (pico, ITSE).",
                                "Classificar sistema por tipo e prever rastreamento.",
                                "Aplicar em exemplo novo com <10% desvio dos valores esperados."
                              ],
                              "assessmentCriteria": [
                                "Precisão matemática nos limites e teoremas (90% correto).",
                                "Correta interpretação de Bode para transitório (margem fase/ganho).",
                                "Qualidade de simulações/plots (legendas, escalas adequadas).",
                                "Identificação de erros comuns e justificativas.",
                                "Integração de métricas em relatório coeso.",
                                "Criatividade em conexões robustez/desempenho."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Transformadas de Laplace e limites (teorema final).",
                                "Programação: Simulações em MATLAB/Python (Control Systems Library).",
                                "Física: Dinâmica de segunda ordem (massa-mola-amortecedor).",
                                "Estatística: Análise de incertezas em K_v via Monte Carlo.",
                                "Engenharia Mecânica: Aplicação em atuadores lineares."
                              ],
                              "realWorldApplication": "Em drones para rastreamento de trajetórias (rampa para velocidade constante), veículos autônomos (degrau para mudanças de set-point), ou robótica industrial (posição precisa sem erro permanente), garantindo robustez a perturbações como vento ou carga variável."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.5.1.2",
                            "name": "Analisar rejeição de distúrbios",
                            "description": "Avaliar a resposta do sistema a distúrbios aditivos em diferentes pontos da malha, calculando amplificadores de distúrbio e utilizando simulações em MATLAB para verificar especificações de atenuação.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender conceitos fundamentais de rejeição de distúrbios em sistemas LIT",
                                  "subSteps": [
                                    "Estude as funções de sensibilidade S(s) e função complementar T(s) em malhas de controle fechadas.",
                                    "Revise como distúrbios aditivos afetam a saída do sistema em pontos de referência, planta e sensor.",
                                    "Analise o impacto dos distúrbios na resposta transitória e em regime permanente.",
                                    "Identifique especificações típicas de atenuação, como atenuação em baixas e altas frequências.",
                                    "Discuta trade-offs entre rejeição de distúrbios e ruído de sensor."
                                  ],
                                  "verification": "Resuma em um diagrama esquemático os pontos de injeção de distúrbios e as funções de transferência relevantes.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Livro de controle avançado (ex: Franklin ou Dorf)",
                                    "Notas de aula sobre funções de sensibilidade",
                                    "Acesso a MATLAB para visualização básica"
                                  ],
                                  "tips": "Use diagramas de bloco para visualizar intuitivamente os efeitos dos distúrbios.",
                                  "learningObjective": "Dominar a teoria por trás da rejeição de distúrbios e funções de amplificação.",
                                  "commonMistakes": [
                                    "Confundir distúrbios aditivos com multiplicativos",
                                    "Ignorar o papel da ganho integral na rejeição em DC"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Modelar o sistema de controle com distúrbios aditivos em diferentes pontos",
                                  "subSteps": [
                                    "Desenhe a malha de controle monovariável incluindo controlador C(s), planta P(s) e pontos de distúrbio d1 (referência), d2 (entrada da planta) e d3 (saída).",
                                    "Derive as funções de transferência da saída y(s) para cada distúrbio: y(s)/d_i(s).",
                                    "Especifique um modelo de planta exemplo, como um sistema de segunda ordem.",
                                    "Defina o espectro de frequência do distúrbio (ex: passo, rampa ou senoidal).",
                                    "Calcule analiticamente a resposta em regime permanente para distúrbios constantes."
                                  ],
                                  "verification": "Crie um diagrama de bloco no MATLAB/Simulink mostrando as funções de transferência para cada distúrbio.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "MATLAB com Control System Toolbox",
                                    "Papel e lápis para derivações",
                                    "Templates de modelos LIT"
                                  ],
                                  "tips": "Padronize a notação: L(s) = C(s)P(s) para facilitar cálculos.",
                                  "learningObjective": "Construir modelos precisos que capturem efeitos de distúrbios em múltiplos pontos.",
                                  "commonMistakes": [
                                    "Esquecer feedback no cálculo das funções de transferência",
                                    "Usar modelo errado de distúrbio"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular amplificadores de distúrbio e funções de sensibilidade",
                                  "subSteps": [
                                    "Compute ||S||_∞ (norma H-infinito da sensibilidade) para rejeição em baixas frequências.",
                                    "Calcule ||T||_∞ para atenuação em altas frequências e amplificação de distúrbios.",
                                    "Plote os diagramas de Bode de S(jω) e T(jω) para análise qualitativa.",
                                    "Determine picos de ressonância e margens de atenuação.",
                                    "Compare com especificações: ex. atenuação > 20 dB em ω < 0.1 ω_c."
                                  ],
                                  "verification": "Gere gráficos de Bode mostrando os amplificadores e anote valores numéricos chave.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "MATLAB (bode(), norm(), sisotool)",
                                    "Planilha para cálculos analíticos"
                                  ],
                                  "tips": "Use sisotool para análise interativa de loops.",
                                  "learningObjective": "Quantificar robustez à rejeição de distúrbios via normas e gráficos.",
                                  "commonMistakes": [
                                    "Confundir S(s) com 1/L(s)",
                                    "Ignorar wrap-around em normas H-infinito"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Implementar simulações em MATLAB para resposta temporal a distúrbios",
                                  "subSteps": [
                                    "Configure o modelo Simulink com blocos de distúrbio (Step, Ramp, Band-Limited White Noise).",
                                    "Simule respostas a distúrbios unitários em cada ponto e plote y(t).",
                                    "Meça overshoot, tempo de assentamento e erro em regime permanente.",
                                    "Varie parâmetros do controlador e re-simule para observar trade-offs.",
                                    "Exporte dados para análise estatística (ex: variância da saída)."
                                  ],
                                  "verification": "Execute simulações e produza plots de resposta temporal com métricas quantificadas.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "MATLAB/Simulink com Control System Toolbox",
                                    "Exemplos de modelos de malha fechada"
                                  ],
                                  "tips": "Use lsim() para simulações lineares rápidas antes de Simulink.",
                                  "learningObjective": "Validar análises frecuenciais via simulações temporais precisas.",
                                  "commonMistakes": [
                                    "Escala errada nos eixos de tempo",
                                    "Não linearizar modelos não-lineares"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Verificar conformidade com especificações de atenuação",
                                  "subSteps": [
                                    "Defina especificações: ex. ||S||_∞ < 1/γ_d para distúrbios de baixa frequência.",
                                    "Compare resultados de simulação e análise com thresholds.",
                                    "Ajuste o controlador se necessário (ex: aumentar ganho integral).",
                                    "Documente relatório com gráficos, tabelas e conclusões.",
                                    "Teste sensibilidade a variações de parâmetros da planta."
                                  ],
                                  "verification": "Produza um relatório resumido confirmando ou refutando as especificações.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "MATLAB para plots e relatórios (publish)",
                                    "Template de relatório LaTeX ou Word"
                                  ],
                                  "tips": "Automatize verificações com scripts que checam normas contra limites.",
                                  "learningObjective": "Integrar análise e simulação para validação robusta de desempenho.",
                                  "commonMistakes": [
                                    "Especificações vagas sem quantificação numérica",
                                    "Não testar múltiplos cenários"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um sistema de controle de posição de um braço robótico, simule um distúrbio aditivo de força (d2 na entrada da planta) representando uma carga repentina. Calcule ||S||_∞ para verificar se a posição oscila menos que 5% e se assenta em <2s, usando um controlador PID com Ki ajustado.",
                              "finalVerifications": [
                                "Explicar verbalmente os três pontos comuns de injeção de distúrbios e suas funções de transferência.",
                                "Gerar Bode plots corretos de S(jω) e T(jω) para um loop dado.",
                                "Simular resposta a um degrau de distúrbio e medir erro em regime permanente.",
                                "Identificar se uma especificação de atenuação é atendida baseado em normas H-infinito.",
                                "Propor ajuste no controlador para melhorar rejeição sem degradar estabilidade.",
                                "Discutir limitações da análise LIT para distúrbios não-lineares."
                              ],
                              "assessmentCriteria": [
                                "Precisão dos cálculos analíticos de funções de sensibilidade (erro <5%).",
                                "Qualidade e legibilidade dos plots de Bode e temporal (rótulos, escalas corretas).",
                                "Conformidade das simulações com teoria (match qualitativo/quantitativo).",
                                "Correta interpretação de amplificadores vs. especificações.",
                                "Profundidade da análise de trade-offs e robustez.",
                                "Clareza e completude do relatório final."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Análise de sistemas lineares via transformada de Laplace e normas funcionais.",
                                "Programação: Desenvolvimento de scripts MATLAB/Simulink para automação de análises.",
                                "Física: Modelagem dinâmica de plantas reais com forças perturbadoras.",
                                "Estatística: Análise de variância e robustez estocástica em simulações.",
                                "Engenharia de Software: Validação e verificação de modelos numéricos."
                              ],
                              "realWorldApplication": "Na indústria automotiva, analisa-se rejeição de distúrbios em sistemas de controle de motor (torque variável por carga) para garantir aceleração suave; em processos químicos, verifica-se atenuação de variações de pressão em válvulas para manter níveis de tanque estáveis, evitando desperdícios e falhas de segurança."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.5.1.3",
                            "name": "Relacionar desempenho com margens de estabilidade",
                            "description": "Interpretar como margens de ganho e fase influenciam o desempenho de rastreamento e rejeição, através de exemplos numéricos e gráficos de Nyquist.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar conceitos fundamentais de margens de ganho e fase",
                                  "subSteps": [
                                    "Defina margem de ganho como a quantidade pela qual o ganho pode ser aumentado antes da instabilidade.",
                                    "Defina margem de fase como o ângulo adicional de fase necessário para atingir -180° no ponto de ganho unitário.",
                                    "Estude o critério de Nyquist para estabilidade.",
                                    "Identifique como essas margens são extraídas do diagrama de Bode.",
                                    "Pratique com exemplos simples de sistemas de primeira e segunda ordem."
                                  ],
                                  "verification": "Explique as definições em suas próprias palavras e calcule margens para um sistema dado.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Livro de Ogata ou Franklin sobre Controle",
                                    "Software MATLAB/Simulink",
                                    "Diagramas de Bode de exemplo"
                                  ],
                                  "tips": "Sempre verifique o loop aberto antes de analisar margens.",
                                  "learningObjective": "Compreender as definições e extração de margens de estabilidade.",
                                  "commonMistakes": "Confundir margem de ganho com crossover frequency ou ignorar o sinal de fase."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Entender métricas de desempenho de rastreamento e rejeição de distúrbios",
                                  "subSteps": [
                                    "Defina rastreamento como a capacidade do sistema seguir uma referência com erro mínimo (ex: overshoot, tempo de assentamento).",
                                    "Defina rejeição de distúrbios como minimizar impacto de ruídos ou cargas externas.",
                                    "Relacione sensibilidade S(s) = 1/(1+G(s)H(s)) com margens.",
                                    "Analise como baixa margem afeta picos de ressonância.",
                                    "Compare respostas no tempo para diferentes margens."
                                  ],
                                  "verification": "Descreva como uma margem baixa aumenta overshoot no rastreamento.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Simulador Step Response no MATLAB",
                                    "Gráficos de resposta ao degrau",
                                    "Tabelas de especificações de desempenho"
                                  ],
                                  "tips": "Use funções como stepinfo() no MATLAB para quantificar métricas.",
                                  "learningObjective": "Associar margens com comportamentos dinâmicos no tempo.",
                                  "commonMistakes": "Ignorar distúrbios em entradas não-referência ou confundir com estabilidade absoluta."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar influência através de exemplos numéricos",
                                  "subSteps": [
                                    "Escolha um controlador PID simples com G(s) = K/(s(s+1)).",
                                    "Varie K para alterar margem de ganho e simule respostas.",
                                    "Calcule numericamente: para margem de ganho 6dB, overshoot ~20%; para 3dB, ~50%.",
                                    "Repita para margem de fase, ajustando zeros/pólos.",
                                    "Tabule resultados comparativos."
                                  ],
                                  "verification": "Produza uma tabela com margens vs. métricas de desempenho para 3 casos.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "MATLAB com Control System Toolbox",
                                    "Planilha Excel para tabelas",
                                    "Exemplos numéricos de livros"
                                  ],
                                  "tips": "Comece com sistemas de segunda ordem para intuição clara.",
                                  "learningObjective": "Quantificar numericamente a relação margens-desempenho.",
                                  "commonMistakes": "Não linearizar modelos ou usar escalas erradas em simulações."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Interpretar gráficos de Nyquist para relacionar margens e desempenho",
                                  "subSteps": [
                                    "Plote diagrama de Nyquist para L(s) = G(s)H(s).",
                                    "Identifique distância ao ponto crítico (-1,0) como indicador de margens.",
                                    "Analise como curvas próximas ao ponto crítico degradam rastreamento/rejeição.",
                                    "Compare Nyquist de sistemas com margens variadas.",
                                    "Extraia lições: margens >6dB/45° para bom desempenho robusto."
                                  ],
                                  "verification": "Interprete um Nyquist dado e prediga desempenho qualitativo.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Nyquist Plot no MATLAB (nyquist())",
                                    "Papel milimetrado para plots manuais",
                                    "Casos de estudo robustez"
                                  ],
                                  "tips": "Amplie a região próxima a -1+j0 para precisão.",
                                  "learningObjective": "Usar Nyquist para visualizar impactos de margens no desempenho.",
                                  "commonMistakes": "Confundir contorno Nyquist com Bode ou ignorar encirclements."
                                }
                              ],
                              "practicalExample": "Em um sistema de controle de velocidade de motor DC com controlador PI, uma margem de ganho de 10 dB resulta em overshoot de 5% no rastreamento de referência e rejeição rápida de torque-distúrbio; reduzindo para 4 dB, overshoot sobe para 30% e oscilações persistem, demonstrado via simulação no MATLAB com nyquist(L) e step(resposta).",
                              "finalVerifications": [
                                "Calcular corretamente margens de ganho e fase para um laço dado.",
                                "Prever qualitativamente impacto de margens baixas no overshoot.",
                                "Interpretar distância no Nyquist como indicador de robustez.",
                                "Simular e comparar 2 sistemas com margens diferentes.",
                                "Explicar relação S(s) com rejeição de distúrbios.",
                                "Identificar quando margens insuficientes violam specs de desempenho."
                              ],
                              "assessmentCriteria": [
                                "Precisão nos cálculos de margens (±1 dB/°).",
                                "Correta associação entre margens e métricas temporais (overshoot, settling time).",
                                "Interpretação válida de gráficos Nyquist.",
                                "Uso apropriado de exemplos numéricos com quantificação.",
                                "Demonstração de robustez via sensibilidade.",
                                "Clareza na explicação verbal/escrita da relação."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Análise de funções complexas e diagramas polares.",
                                "Física: Dinâmica de sistemas mecânicos e elétricos.",
                                "Computação: Programação de simulações em MATLAB/Python.",
                                "Engenharia Elétrica: Projeto de amplificadores e filtros.",
                                "Estatística: Análise de incertezas e variância em modelos."
                              ],
                              "realWorldApplication": "No controle de drones, margens adequadas garantem rastreamento estável de trajetória apesar de ventos (distúrbios), evitando crashes; em plantas químicas, previnem oscilações perigosas em níveis de tanques, otimizando produção segura."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.2.5.2",
                        "name": "Modelos de Incertezas e seu Impacto no Desempenho",
                        "description": "Representação de incertezas paramétricas e dinâmicas em sistemas LIT e análise de como elas degradam as especificações de desempenho robusto.",
                        "specificSkills": [
                          {
                            "id": "10.1.2.5.2.1",
                            "name": "Modelar incertezas aditivas e multiplicativas",
                            "description": "Construir modelos padrão de incertezas (Δ aditiva, multiplicativa) para plantas nominais com variações paramétricas, utilizando a forma de coprimação e funções de transferência.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o Modelo Nominal da Planta e Variações Paramétricas",
                                  "subSteps": [
                                    "Revise funções de transferência de plantas monovariáveis típicas (ex: integrador com ganho).",
                                    "Identifique parâmetros nominais (ex: constantes de tempo, ganhos) e suas faixas de variação (ex: ±20%).",
                                    "Represente a planta real como P = P_n (1 + Δ_m) + Δ_a, onde P_n é nominal.",
                                    "Desenhe diagramas de bloco para visualizar incertezas aditiva (Δ_a) e multiplicativa (Δ_m).",
                                    "Calcule exemplos numéricos simples para P_n e variações."
                                  ],
                                  "verification": "Crie um diagrama de bloco correto para uma planta com incertezas e valide com simulação básica em MATLAB.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "MATLAB ou Octave",
                                    "Livro 'Robust and Optimal Control' de Zhou",
                                    "Papel e lápis para diagramas"
                                  ],
                                  "tips": "Comece com plantas de 1ª ou 2ª ordem para simplicidade; use syms no MATLAB para simbólico.",
                                  "learningObjective": "Dominar representação da planta nominal e introdução conceitual de incertezas aditivas/multiplicativas.",
                                  "commonMistakes": [
                                    "Confundir Δ_a com Δ_m",
                                    "Ignorar normalização das incertezas",
                                    "Usar percentuais sem converter para fração"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Definir e Normalizar Incertezas Aditivas e Multiplicativas",
                                  "subSteps": [
                                    "Defina Δ_a(w) como incerteza aditiva: ||Δ_a||_∞ ≤ 1, peso W_a(s) tal que |Δ_a(jw)| ≤ 1/|W_a(jw)|.",
                                    "Defina Δ_m(w) como multiplicativa: P = P_n (1 + W_m Δ_m), ||Δ_m||_∞ ≤ 1.",
                                    "Escolha pesos W_a e W_m baseados em dados de variação paramétrica (ex: Monte Carlo para envelope).",
                                    "Normalize incertezas para ||Δ||_∞ ≤ 1 usando mínimos quadrados ou bounding.",
                                    "Plote magnitudes de W_a e W_m vs. frequência para validar cobertura das variações."
                                  ],
                                  "verification": "Gere plots de Bode para W_a e W_m que envelopem todas as plantas perturbadas geradas.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "MATLAB Control System Toolbox",
                                    "Dados de simulação de variações paramétricas",
                                    "Planilha para Monte Carlo"
                                  ],
                                  "tips": "Use tf() e bode() no MATLAB; mire em sobrestimativa conservadora nos pesos para robustez.",
                                  "learningObjective": "Selecionar e normalizar pesos de incerteza corretamente para garantir ||Δ||_∞ ≤ 1.",
                                  "commonMistakes": [
                                    "Subestimar pesos levando a ||Δ||_∞ >1",
                                    "Confundir pesos aditivos com multiplicativos",
                                    "Ignorar dinâmica de alta frequência"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Introduzir Fatoração Coprima e Representação Padrão",
                                  "subSteps": [
                                    "Aprenda fatoração coprima direita (RCP): P_n = N_m M_m^{-1}, com N_m, M_m estáveis, coprimos.",
                                    "Calcule RCP usando função coprime() no MATLAB ou algoritmo de Youla.",
                                    "Formule modelo padrão: [M_m -N_m; V_m U_m] pertence a RH_∞, com Beoúlov lemma.",
                                    "Construa G = [P_n; 1] K [I -K], mas foque em Δ conectada em w = M_m^{-1} [Δ_m Δ_a] N_m.",
                                    "Verifique estabilidade interna do modelo com nyquist ou margins."
                                  ],
                                  "verification": "Obtenha N_m, M_m estáveis e coprimos para P_n dada, com resíduo < 10^{-6}.",
                                  "estimatedTime": "2.5 horas",
                                  "materials": [
                                    "MATLAB Robust Control Toolbox (coprimel, coprime)",
                                    "Referência: Skogestad 'Multivariable Feedback Control' Capítulo 9"
                                  ],
                                  "tips": "Use gamma=0.99 em coprime para estabilidade; normalize estados para evitar numéricos.",
                                  "learningObjective": "Executar fatoração coprima e entender sua role no framework de robustez H∞.",
                                  "commonMistakes": [
                                    "Fatoração não coprima levando a instabilidade",
                                    "Inverter ordem em RCP",
                                    "Não verificar coprimidade"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Construir e Validar o Modelo de Incerteza Completo",
                                  "subSteps": [
                                    "Integre Δ_a e Δ_m no loop: w = M^{-1} (Δ_m N + Δ_a) z.",
                                    "Simule sistema com Δ aleatórios unitários e verifique estabilidade/ desempenho.",
                                    "Calcule norma H∞ do sistema fechado para robustez: μ <1 garante robustez.",
                                    "Compare desempenho nominal vs. perturbado em step response e tracking.",
                                    "Documente modelo final em forma de transferência e diagrama."
                                  ],
                                  "verification": "Simule 100 casos com Δ randn e confirme 100% estável com overshoot <20%.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "MATLAB (lsim, step, hinfnorm, musyn)",
                                    "Scripts de simulação personalizados"
                                  ],
                                  "tips": "Use wcgain para análise μ; acelere com parallel computing para Monte Carlo.",
                                  "learningObjective": "Montar modelo padrão completo e validar robustez via simulação.",
                                  "commonMistakes": [
                                    "Conectar Δ incorretamente no diagrama",
                                    "Esquecer normalização em simulações",
                                    "Interpretar erroneamente normas >1"
                                  ]
                                }
                              ],
                              "practicalExample": "Para um motor DC nominal P_n(s) = 1000/(s(s+10)), com variação de ganho ±30% e polo ±20%: estime W_m(s)=0.3, W_a(s)=30/s; compute RCP, conecte Δ_m, Δ_a e simule controle PI robusto, verificando step response sob perturbações.",
                              "finalVerifications": [
                                "Construir RCP estável para P_n dada.",
                                "Plots de Bode de pesos envelopam variações paramétricas.",
                                "Simulação mostra robustez para ||Δ||_∞=1.",
                                "Norma H∞ do loop <1 para estabilidade robusta.",
                                "Diagrama de bloco completo e documentado.",
                                "Análise de sensibilidade confirma impacto das incertezas."
                              ],
                              "assessmentCriteria": [
                                "Precisão na fatoração coprima (resíduo <10^{-5}).",
                                "Correta normalização de pesos (max |Δ| ≤1).",
                                "Validação via simulação (taxa de falha <5%).",
                                "Clareza nos diagramas e explicações.",
                                "Análise quantitativa de robustez (μ-analysis).",
                                "Eficiência temporal (dentro de 8 horas totais)."
                              ],
                              "crossCurricularConnections": [
                                "Probabilidade e Estatística: Modelagem de variações paramétricas via Monte Carlo.",
                                "Otimização: Seleção de pesos minimizando conservadorismo.",
                                "Física/Engenharia Mecânica: Modelos de plantas reais como motores e servos.",
                                "Programação Numérica: Uso de toolboxes MATLAB para controle.",
                                "Análise de Sistemas: Extensão de Nyquist para robustez."
                              ],
                              "realWorldApplication": "Em controle de drones, modela variações de massa/carga (multiplicativa) e ruído de sensores (aditiva), garantindo estabilidade robusta em ventos variáveis; usado em aeroespacial (NASA), automotivo (ABS) e robótica industrial."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.5.2.2",
                            "name": "Avaliar degradação de desempenho por incertezas",
                            "description": "Simular o impacto de incertezas em erros de rastreamento e rejeição de distúrbios, calculando variações relativas no desempenho via Monte Carlo ou análise worst-case.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Modelar o sistema LIT com incertezas parametrizadas",
                                  "subSteps": [
                                    "Identifique os parâmetros nominais do sistema LIT (ex.: ganho, tempo constante).",
                                    "Defina distribuições de incerteza para cada parâmetro (ex.: normal com desvio padrão 10%).",
                                    "Incorpore perturbações aditivas nos distúrbios de entrada.",
                                    "Construa o modelo em software de simulação (MATLAB/Simulink ou Python com control library).",
                                    "Valide o modelo nominal sem incertezas contra resposta esperada."
                                  ],
                                  "verification": "Execute simulação nominal e compare curvas de resposta (overshoot, tempo de estabilização) com valores teóricos.",
                                  "estimatedTime": "2 horas",
                                  "materials": "MATLAB/Simulink ou Python (bibliotecas control, numpy, scipy); documentação do sistema LIT exemplo.",
                                  "tips": "Comece com um sistema simples de 2ª ordem para facilitar depuração.",
                                  "learningObjective": "Compreender como representar incertezas em modelos LIT para análise robusta.",
                                  "commonMistakes": "Ignorar correlações entre parâmetros ou usar distribuições inadequadas (ex.: uniforme em vez de normal)."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Definir métricas de desempenho para rastreamento e rejeição",
                                  "subSteps": [
                                    "Especifique referências de entrada para teste de rastreamento (degrau, rampa).",
                                    "Defina distúrbios para rejeição (degrau no torque de carga).",
                                    "Calcule métricas: IAE (Integral Absolute Error) para rastreamento, tempo de assentamento, overshoot.",
                                    "Para rejeição: pico de saída sob distúrbio, tempo de recuperação.",
                                    "Normalize métricas para permitir comparação relativa."
                                  ],
                                  "verification": "Liste métricas com fórmulas e compute valores nominais para validação.",
                                  "estimatedTime": "1 hora",
                                  "materials": "Planilha Excel ou script Python para cálculo de métricas; gráficos de resposta.",
                                  "tips": "Use IAE em vez de ISE para penalizar erros persistentes em sistemas com incertezas.",
                                  "learningObjective": "Selecionar e quantificar métricas relevantes para avaliar degradação por incertezas.",
                                  "commonMistakes": "Escolher métricas não sensíveis a incertezas (ex.: apenas ganho em DC)."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar simulação Monte Carlo para variações estatísticas",
                                  "subSteps": [
                                    "Configure gerador de amostras aleatórias para parâmetros incertos (N=1000 runs).",
                                    "Simule cada realização e compute métricas de desempenho.",
                                    "Calcule estatísticas: média, desvio padrão, percentil 95% das métricas.",
                                    "Estime variação relativa: (desvio padrão / média) * 100%.",
                                    "Gere histogramas e boxplots para visualização."
                                  ],
                                  "verification": "Verifique convergência: estatísticas estabilizam com N>500; sem NaNs nos resultados.",
                                  "estimatedTime": "3 horas",
                                  "materials": "MATLAB (montecarlo toolbox) ou Python (numpy.random, matplotlib); hardware com boa CPU.",
                                  "tips": "Paralelize simulações com parfor (MATLAB) ou multiprocessing (Python) para acelerar.",
                                  "learningObjective": "Aplicar Monte Carlo para quantificar degradação probabilística do desempenho.",
                                  "commonMistakes": "Número insuficiente de runs levando a estimativas não confiáveis; não seedar RNG para reprodutibilidade."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Realizar análise worst-case e calcular degradação relativa",
                                  "subSteps": [
                                    "Defina bounds de incerteza (ex.: ±20% em parâmetros).",
                                    "Use otimização ou grid search para encontrar pior caso maximizando métricas ruins.",
                                    "Compute degradação worst-case: (métrica_worst / métrica_nominal - 1) * 100%.",
                                    "Compare com resultados Monte Carlo (ex.: pior caso vs. percentil 99%).",
                                    "Documente cenários de pior desempenho."
                                  ],
                                  "verification": "Confirme que worst-case excede nominal em pelo menos 20-50%; plots mostram extremos.",
                                  "estimatedTime": "2 horas",
                                  "materials": "MATLAB Optimization Toolbox ou Python (scipy.optimize); scripts dos steps anteriores.",
                                  "tips": "Para sistemas LIT, use intervalos de valor próprio para bounds analíticos rápidos.",
                                  "learningObjective": "Avaliar degradação determinística em cenários extremos de incerteza.",
                                  "commonMistakes": "Bounds muito conservadores subestimando riscos reais; ignorar combinações não conservadoras."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Interpretar resultados e sintetizar avaliação de robustez",
                                  "subSteps": [
                                    "Compare degradações Monte Carlo vs. worst-case em tabela.",
                                    "Identifique parâmetros mais impactantes via análise de sensibilidade.",
                                    "Conclua sobre robustez: aceitável se variação <20%.",
                                    "Sugira mitigações (ex.: ganhos adaptativos).",
                                    "Gere relatório com gráficos e conclusões."
                                  ],
                                  "verification": "Relatório resume variações relativas <30% para Monte Carlo e identifica top-3 parâmetros críticos.",
                                  "estimatedTime": "1 hora",
                                  "materials": "Ferramentas de plotting e LaTeX/Word para relatório.",
                                  "tips": "Use coeficiente de variação (CV) para normalizar comparações entre métricas.",
                                  "learningObjective": "Sintetizar análises para decisões de design robusto.",
                                  "commonMistakes": "Não correlacionar resultados com requisitos de desempenho reais."
                                }
                              ],
                              "practicalExample": "Em um controlador PID para um motor DC (sistema LIT de 2ª ordem), simule incertezas de ±15% no ganho e tempo constante. Use Monte Carlo (1000 runs) para rastreamento de rampa (IAE nominal=2.5s) e worst-case para rejeição de distúrbio de torque, revelando degradação de 25% no IAE e 40% no pico de rejeição.",
                              "finalVerifications": [
                                "Simulações Monte Carlo convergem com CV<5% nas estatísticas.",
                                "Worst-case identifica cenários com degradação >20%.",
                                "Variações relativas calculadas corretamente para todas métricas.",
                                "Gráficos mostram distribuição clara de degradação.",
                                "Relatório sintetiza impactos e recomendações.",
                                "Reprodutibilidade confirmada com seeds fixos."
                              ],
                              "assessmentCriteria": [
                                "Precisão das modelagens de incerteza (distribuições apropriadas).",
                                "Correta implementação e convergência de Monte Carlo.",
                                "Identificação válida de worst-case com otimização.",
                                "Cálculo exato de variações relativas (erro <1%).",
                                "Interpretação qualitativa e quantitativa coerente.",
                                "Qualidade visual dos resultados (gráficos legíveis)."
                              ],
                              "crossCurricularConnections": [
                                "Estatística: Distribuições probabilísticas e análise Monte Carlo.",
                                "Programação: Simulações numéricas e paralelização.",
                                "Matemática: Otimização e análise de sensibilidade.",
                                "Física: Modelagem dinâmica de sistemas reais com ruído."
                              ],
                              "realWorldApplication": "Em aviões autônomos, avaliar como incertezas em aerodinâmica degradam rastreamento de trajetória, garantindo robustez para pousos seguros; ou em fábricas, quantificar impacto de variações em sensores na rejeição de vibrações em robôs industriais."
                            },
                            "estimatedTime": "2.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.5.2.3",
                            "name": "Usar funções de sensibilidade para análise",
                            "description": "Calcular funções de sensibilidade S, T e KS para quantificar robustez em relação a incertezas e seu efeito em especificações de desempenho.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender definições e fórmulas das funções de sensibilidade S, T e KS",
                                  "subSteps": [
                                    "Estudar a definição de S(s) = 1 / (1 + L(s)) como função de sensibilidade",
                                    "Analisar T(s) = L(s) / (1 + L(s)) como sensibilidade complementar",
                                    "Revisar KS como função de valor singular estruturado para incertezas estruturadas",
                                    "Memorizar relações fundamentais: S(s) + T(s) = 1 e implicações para robustez",
                                    "Explorar representações em diagrama de Bode para visualização"
                                  ],
                                  "verification": "Explicar em palavras próprias o papel de cada função na quantificação de robustez e fornecer as fórmulas corretas",
                                  "estimatedTime": "2 horas",
                                  "materials": "Livro de controle robusto (ex: Zhou, Doyle), notas de aula, MATLAB para plots iniciais",
                                  "tips": "Use o diagrama de Nyquist para visualizar loops de realimentação e relações entre S e T",
                                  "learningObjective": "Dominar as definições teóricas e relações matemáticas das funções de sensibilidade",
                                  "commonMistakes": "Confundir S (sensibilidade a perturbações) com T (sensibilidade a ruído de referência)"
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Calcular funções S, T e KS para um sistema LTI nominal",
                                  "subSteps": [
                                    "Definir o laço aberto L(s) = G(s)C(s) para um sistema monovariável",
                                    "Computar S(jω) e T(jω) numericamente usando ferramentas como MATLAB",
                                    "Gerar diagramas de Bode para S e T, identificando picos e larguras de banda",
                                    "Calcular KS usando toolbox robust control para modelo nominal",
                                    "Validar cálculos analíticos para casos simples (ex: integrador)"
                                  ],
                                  "verification": "Gerar plots de Bode corretos para S e T e comparar com valores esperados em frequências chave",
                                  "estimatedTime": "3 horas",
                                  "materials": "MATLAB/Simulink com Robust Control Toolbox, exemplos de sistemas LTI",
                                  "tips": "Sempre normalize frequências para visualizar melhor os trade-offs de desempenho",
                                  "learningObjective": "Aplicar fórmulas para calcular e plotar funções de sensibilidade em sistemas nominais",
                                  "commonMistakes": "Esquecer de usar jω na avaliação em frequência ou inverter L(s)"
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Incorporar incertezas e analisar robustez usando S, T e KS",
                                  "subSteps": [
                                    "Modelar incertezas como Δ(s) multiplicativa ou aditiva no laço aberto",
                                    "Calcular margens de robustez: ||T||∞ < 1/||Δ||∞ para estabilidade robusta",
                                    "Avaliar KS(ω) = μ(Δ) para incertezas estruturadas e identificar frequências críticas",
                                    "Simular efeitos de Δ em S e T via Monte Carlo ou pior caso",
                                    "Interpretar picos em KS como indicadores de fragilidade"
                                  ],
                                  "verification": "Demonstrar que para uma Δ dada, o sistema permanece estável e calcular margens numéricas",
                                  "estimatedTime": "4 horas",
                                  "materials": "MATLAB com mu-toolbox ou Robust Control Toolbox, modelos de incerteza parametrizados",
                                  "tips": "Comece com incertezas paramétricas simples (ex: variação de 20% no ganho) antes de Δ complexas",
                                  "learningObjective": "Quantificar impacto de incertezas no desempenho usando funções de sensibilidade",
                                  "commonMistakes": "Ignorar a estrutura de Δ ao usar KS, levando a superestimação de robustez"
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Interpretar resultados e avaliar conformidade com especificações de desempenho",
                                  "subSteps": [
                                    "Comparar ||S||∞ com requisitos de rejeição de perturbações",
                                    "Verificar ||T||∞ para atenuação de ruído e tracking",
                                    "Analisar KS para garantir robustez sob incertezas especificadas",
                                    "Ajustar controlador se necessário para atender specs (ex: reduzir picos)",
                                    "Documentar trade-offs em relatório com plots e conclusões"
                                  ],
                                  "verification": "Produzir relatório com análise mostrando se specs de desempenho são atendidas sob incertezas",
                                  "estimatedTime": "2 horas",
                                  "materials": "Plots gerados anteriormente, template de relatório",
                                  "tips": "Use escalas logarítmicas em Bode para destacar violações de specs",
                                  "learningObjective": "Ligar funções de sensibilidade a especificações práticas de robustez e desempenho",
                                  "commonMistakes": "Focar apenas em estabilidade nominal, ignorando robustez dinâmica"
                                }
                              ],
                              "practicalExample": "Em um sistema de controle de posição de um motor DC com controlador PI, L(s) = K/(s(s+1)), varie o ganho K em ±30%. Calcule S(jω), T(jω) e KS(ω); verifique se ||KS||∞ < 1/0.3 garante estabilidade robusta e se picos de S atendem rejeição de distúrbios < -20dB em baixas frequências.",
                              "finalVerifications": [
                                "Cálculo correto de S(jω) e T(jω) para pelo menos 3 frequências",
                                "Geração de diagrama de Bode com identificação de picos e largura de banda",
                                "Cálculo de KS e margens de robustez para incerteza Δ multiplicativa",
                                "Interpretação verbal de trade-offs entre desempenho nominal e robustez",
                                "Simulação confirmando estabilidade sob pior caso de incerteza",
                                "Relatório documentando conformidade com specs de desempenho"
                              ],
                              "assessmentCriteria": [
                                "Precisão numérica nos cálculos > 95%",
                                "Interpretação correta de picos em S/T/KS e implicações para robustez",
                                "Uso adequado de ferramentas para análise em frequência",
                                "Identificação precisa de trade-offs e recomendações de design",
                                "Relatório claro com plots e conclusões acionáveis",
                                "Capacidade de estender análise a incertezas realistas"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Análise de valores singulares e funções analíticas complexas",
                                "Programação: Implementação em MATLAB/Simulink para automação de cálculos",
                                "Estatística: Modelagem probabilística de incertezas paramétricas",
                                "Física: Dinâmica de sistemas reais com variações (ex: atrito variável)"
                              ],
                              "realWorldApplication": "No design de controladores para drones autônomos, onde variações em massa de carga ou vento afetam estabilidade; S, T e KS garantem que o sistema mantenha tracking preciso e rejeite distúrbios apesar de incertezas, evitando crashes."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.2.5.3",
                        "name": "Técnicas de Análise de Desempenho Robusto",
                        "description": "Métodos quantitativos para avaliar a robustez do desempenho, incluindo normas e síntese avançada como H∞.",
                        "specificSkills": [
                          {
                            "id": "10.1.2.5.3.1",
                            "name": "Aplicar norma H∞ para desempenho robusto",
                            "description": "Calcular a norma H∞ de funções de transferência ponderadas para verificar garantias de robustez em rastreamento e rejeição, usando MATLAB Robust Control Toolbox.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisão conceitual da norma H∞ e definição de funções de transferência ponderadas",
                                  "subSteps": [
                                    "Estude a definição matemática da norma H∞ para sistemas LIT: supremo do valor singular máximo sobre a frequência.",
                                    "Identifique os pesos de desempenho: Wp para erro de rastreamento e rejeição de distúrbios, We para ruído, Wu para sinal de controle.",
                                    "Revise funções de transferência do laço fechado ponderado: Tzw = Fl(P, K) com pesos incorporados.",
                                    "Analise o critério de robustez: ||Tzw||_∞ < 1 garante desempenho robusto.",
                                    "Consulte documentação do MATLAB Robust Control Toolbox sobre normas."
                                  ],
                                  "verification": "Explique verbalmente ou por escrito o significado de ||Tzw||_∞ < 1 e esboce um diagrama de blocos ponderado.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Documentação teórica de controle robusto (livro ou PDF)",
                                    "MATLAB instalado com Robust Control Toolbox"
                                  ],
                                  "tips": "Comece com exemplos simples de 1ª ordem para intuitar os pesos.",
                                  "learningObjective": "Compreender os fundamentos teóricos da norma H∞ e sua relação com robustez em desempenho.",
                                  "commonMistakes": [
                                    "Confundir norma H∞ com norma H2",
                                    "Ignorar a frequência em que o pico ocorre",
                                    "Definir pesos inadequados sem justificativa"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Configuração do ambiente MATLAB e modelagem do sistema nominal",
                                  "subSteps": [
                                    "Inicie o MATLAB e verifique a instalação do Robust Control Toolbox com 'verifymu'.",
                                    "Defina o plantio nominal P(s) como função de transferência (ex: sys = tf([1],[1 1 0])).",
                                    "Crie o controlador K(s) ou use um pré-definido para formar o sistema generalizado.",
                                    "Construa o sistema interconectado G = augw(P, Wp, Wu, We) usando funções como 'augw'.",
                                    "Plote respostas em frequência do sistema nominal para baseline."
                                  ],
                                  "verification": "Execute o código e confirme que o sistema G é criado sem erros, com plots de Bode visíveis.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "MATLAB R2020b ou superior",
                                    "Robust Control Toolbox",
                                    "Exemplos de scripts de controle robusto"
                                  ],
                                  "tips": "Use 'sisotool' para visualização interativa inicial.",
                                  "learningObjective": "Configurar modelos LIT no MATLAB para análise H∞.",
                                  "commonMistakes": [
                                    "Esquecer de linearizar modelos não-lineares",
                                    "Usar unidades erradas em tf()",
                                    "Não verificar estabilidade do laço fechado"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Cálculo da norma H∞ das funções ponderadas",
                                  "subSteps": [
                                    "Calcule a norma H∞ com norm(G, 'inf') ou hinfnorm(G).",
                                    "Obtenha o valor gamma = ||G||_∞ e a frequência de pico peak_freq.",
                                    "Gere plots de singular values com sigma(G, 'plot') e destaque o pico.",
                                    "Itere ajustes nos pesos se gamma > 1, visando gamma < 1.",
                                    "Salve resultados em variáveis: [gamma, peak_freq] = hinfnorm(G)."
                                  ],
                                  "verification": "Confirme gamma < 1 no workspace e visualize o plot com supremo abaixo de 1.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Scripts MATLAB personalizados",
                                    "Funções: norm(), sigma(), hinfnorm()"
                                  ],
                                  "tips": "Aumente resolução de frequência com logspace para precisão.",
                                  "learningObjective": "Executar computacionalmente a norma H∞ e identificar picos críticos.",
                                  "commonMistakes": [
                                    "Não normalizar pesos adequadamente",
                                    "Confundir norma de G com Tzw",
                                    "Ignorar warnings de toolbox"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Interpretação dos resultados para robustez em rastreamento e rejeição",
                                  "subSteps": [
                                    "Analise impacto no rastreamento: |Wp S| <1 garante bom tracking apesar de incertezas.",
                                    "Verifique rejeição de distúrbios: |Wp T| <1 para supressão robusta.",
                                    "Compare com simulações temporais usando lsim() para validar frequência.",
                                    "Teste sensibilidade variando parâmetros do plantio em ±20%.",
                                    "Documente conclusões em relatório com plots e valores gamma."
                                  ],
                                  "verification": "Gere relatório resumindo se o sistema atende especificações robustas (gamma <1 em todos cenários).",
                                  "estimatedTime": "1 hora e 30 minutos",
                                  "materials": [
                                    "Ferramentas de plot MATLAB (bode, step)",
                                    "Modelos com incertezas (usys)"
                                  ],
                                  "tips": "Use usample para Monte Carlo em incertezas.",
                                  "learningObjective": "Interpretar normas H∞ para validar desempenho robusto prático.",
                                  "commonMistakes": [
                                    "Sobrepor robustez a performance sem trade-off",
                                    "Não simular tempo para validar frequência",
                                    "Generalizar resultados sem testes"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Validação final e otimização",
                                  "subSteps": [
                                    "Realize análise mu para robustez estruturada se aplicável.",
                                    "Otimize pesos iterativamente com loop while até gamma <0.9.",
                                    "Compare com benchmarks H2 para trade-offs.",
                                    "Exporte modelo otimizado para Simulink.",
                                    "Teste em simulação fechada com ruído e referências."
                                  ],
                                  "verification": "Sistema otimizado roda em Simulink sem violações de especificações.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Simulink",
                                    "Funções mu-analysis: musyn, muserv"
                                  ],
                                  "tips": "Salve sessões com diary para rastreabilidade.",
                                  "learningObjective": "Aplicar iterações para síntese robusta completa.",
                                  "commonMistakes": [
                                    "Parar em gamma=1 sem margem",
                                    "Ignorar computacional custo alto",
                                    "Não validar com mu"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um sistema de controle de posição de um braço robótico com incertezas de 20% na massa, defina P(s) = 1/(s^2 + s), pesos Wp=0.1/(s/10+1) para tracking, Wu=0.1, We=0.01. Calcule ||Tzw||_∞ = 0.85 <1, confirmando robustez em rastreamento de rampa apesar de variações.",
                              "finalVerifications": [
                                "gamma = ||Tzw||_∞ <1 calculado corretamente.",
                                "Plots de sigma mostram picos abaixo de 1 em todas frequências.",
                                "Simulações temporais validam tracking erro <5% com ±20% incertezas.",
                                "Relatório explica trade-offs entre performance e robustez.",
                                "Código MATLAB reproduzível sem erros.",
                                "Análise sensível confirma garantias."
                              ],
                              "assessmentCriteria": [
                                "Precisão matemática no cálculo de normas (erro <1%).",
                                "Escolha justificada de pesos de desempenho.",
                                "Interpretação correta de resultados para robustez.",
                                "Qualidade dos plots e documentação.",
                                "Capacidade de otimizar iterativamente gamma.",
                                "Validação via simulações temporais e frequenciais."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria de operadores e valores singulares.",
                                "Programação: Desenvolvimento de scripts numéricos em MATLAB.",
                                "Física: Dinâmica linear de sistemas mecânicos e elétricos.",
                                "Engenharia de Software: Modelagem e verificação em Simulink.",
                                "Estatística: Análise de Monte Carlo para incertezas."
                              ],
                              "realWorldApplication": "No controle de flight de drones, aplica norma H∞ para garantir estabilidade e precisão de rastreamento GPS apesar de ventos variáveis e falhas de sensores, evitando crashes em missões autônomas."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.5.3.2",
                            "name": "Realizar análise μ para robustez estruturada",
                            "description": "Utilizar μ-síntese para analisar o desempenho robusto contra incertezas estruturadas, interpretando valores de μ e condições de estabilidade robusta.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender Fundamentos de Incertezas Estruturadas e Definição de μ",
                                  "subSteps": [
                                    "Estude a definição de incertezas estruturadas (blocos Δ com norma estruturada).",
                                    "Revise o valor estrutural μ(Δ, M) como o recíproco da menor norma de Δ que torna det(I - MΔ)=0.",
                                    "Identifique tipos de blocos Δ: full block, repeated scalar, etc.",
                                    "Aprenda condições: μ < 1 implica estabilidade robusta.",
                                    "Pratique com exemplos simples de matrizes M e Δ."
                                  ],
                                  "verification": "Resuma em um diagrama os conceitos chave e resolva um exercício manual de cálculo de μ para uma matriz 2x2.",
                                  "estimatedTime": "2 horas",
                                  "materials": "Livro 'Multivariable Feedback Control' de Skogestad, notas de aula, MATLAB para visualização.",
                                  "tips": "Use LFTs (Linear Fractional Transformations) para representar incertezas desde o início.",
                                  "learningObjective": "Dominar a teoria matemática por trás da análise μ e suas implicações para robustez.",
                                  "commonMistakes": "Confundir μ com normas padrão como H-infinito; ignorar estrutura de Δ."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Modelar o Sistema com Incertezas Estruturadas",
                                  "subSteps": [
                                    "Defina o sistema nominal G(s) em forma de LFT: M = [P11 P12; P21 P22].",
                                    "Especifique blocos de incerteza Δ (ex: Δ_param = W_p * δ, com ||δ||<1).",
                                    "Gere pesos de incerteza W baseados em dados experimentais ou bounds.",
                                    "Monte o modelo generalizado usando funções como 'lft' no MATLAB.",
                                    "Valide o modelo plotando respostas nominais."
                                  ],
                                  "verification": "Execute simulação do LFT e confirme que perturbações em Δ alteram o comportamento esperado.",
                                  "estimatedTime": "3 horas",
                                  "materials": "MATLAB Robust Control Toolbox, exemplos de sistemas LIT (ex: planta flexível).",
                                  "tips": "Comece com incertezas reais e coprime para prática.",
                                  "learningObjective": "Construir modelos precisos que capturem incertezas estruturadas realisticamente.",
                                  "commonMistakes": "Escolha inadequada de pesos W levando a conservadorismo excessivo."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Configurar e Executar Análise μ",
                                  "subSteps": [
                                    "Configure o objeto 'musyn' ou 'mu-analysis' no MATLAB.",
                                    "Defina opções: frequência de análise, bounds (upper/lower μ).",
                                    "Compute μ usando mussv() para upper bound e mu() para análise completa.",
                                    "Gere plots de μ vs. frequência para nominal e com margens.",
                                    "Analise convergência entre upper e lower bounds."
                                  ],
                                  "verification": "Obtenha plots onde μ(nominal) <1 em todo o intervalo de frequência de interesse.",
                                  "estimatedTime": "4 horas",
                                  "materials": "MATLAB com Robust Control Toolbox, script de exemplo para μ-analysis.",
                                  "tips": "Use D-K iteração se necessário para síntese, mas foque em análise aqui.",
                                  "learningObjective": "Executar computacionalmente a análise μ com precisão numérica.",
                                  "commonMistakes": "Não especificar estrutura correta de Δ, causando erros de computação."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Interpretar Resultados e Verificar Estabilidade Robusta",
                                  "subSteps": [
                                    "Identifique picos de μ e frequência crítica.",
                                    "Verifique se max(μ) <1 para estabilidade robusta; calcule margens de robustez.",
                                    "Analise sensibilidade a variações em Δ.",
                                    "Compare com análises não estruturadas (ex: H-infinito).",
                                    "Documente conclusões em relatório com plots."
                                  ],
                                  "verification": "Escreva um parágrafo interpretando se o sistema é robusto e por quê, suportado por valores numéricos.",
                                  "estimatedTime": "2.5 horas",
                                  "materials": "Plots gerados, template de relatório.",
                                  "tips": "μ >1 indica instabilidade; foque em robustez de desempenho também.",
                                  "learningObjective": "Extrair insights acionáveis dos valores de μ para design de controle.",
                                  "commonMistakes": "Ignorar discrepâncias entre upper/lower bounds como evidência de modelagem pobre."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Validar e Iterar o Modelo",
                                  "subSteps": [
                                    "Teste com Monte Carlo: gere Δ aleatórios e simule fechado-loop.",
                                    "Ajuste pesos W se μ inconsistente com dados reais.",
                                    "Compare com experimentos físicos se possível.",
                                    "Otimize o controlador se μ >1.",
                                    "Registre lições aprendidas."
                                  ],
                                  "verification": "Confirme que simulações com Δ max estabilizam em <5% das runs falham.",
                                  "estimatedTime": "3 horas",
                                  "materials": "Simulink para simulações, dados experimentais.",
                                  "tips": "Use seltool() no MATLAB para interatividade.",
                                  "learningObjective": "Garantir que a análise μ traduza para robustez prática.",
                                  "commonMistakes": "Sobreajuste de modelo sem validação externa."
                                }
                              ],
                              "practicalExample": "Analise um sistema de controle de posição de um braço robótico com incertezas estruturadas em massa (Δ_m = 20% variação) e atrito (Δ_f = repeated scalar). Modele como LFT, compute μ em [0.1, 10] rad/s, e verifique se PID ajustado garante μ<0.8, evitando oscilações em payloads variáveis.",
                              "finalVerifications": [
                                "μ upper bound <1 em todas as frequências de interesse.",
                                "Lower bound converge para upper bound (gap <10%).",
                                "Margem de robustez calculada corretamente (1/max(μ)).",
                                "Simulações com Δ extremas mantêm estabilidade e desempenho.",
                                "Relatório inclui plots Bode de μ e interpretação clara.",
                                "Comparação com análise não-μ mostra superioridade estruturada."
                              ],
                              "assessmentCriteria": [
                                "Precisão na modelagem LFT (sem erros de estrutura Δ).",
                                "Corretude computacional (bounds consistentes).",
                                "Interpretação qualitativa/quantitativa de μ.",
                                "Uso adequado de ferramentas MATLAB.",
                                "Documentação completa com conclusões acionáveis.",
                                "Validação via simulação/Monte Carlo.",
                                "Identificação de trade-offs robustez vs. desempenho."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria de valores singulares estruturados (SSV).",
                                "Programação: Scripts MATLAB/Simulink para automação.",
                                "Física: Modelagem dinâmica de sistemas mecatrônicos.",
                                "Estatística: Análise de sensibilidade e Monte Carlo.",
                                "Design de Engenharia: Otimização multiobjetivo."
                              ],
                              "realWorldApplication": "Em aviação, análise μ garante estabilidade robusta de sistemas de controle de voo contra variações estruturais em asas flexíveis ou danos, permitindo certificação FAA sob condições incertas de fabricação e fadiga."
                            },
                            "estimatedTime": "2.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.5.3.3",
                            "name": "Interpretar gráficos de robustez de desempenho",
                            "description": "Analisar diagramas de Bode robustos e curvas de singular values para avaliar margens de desempenho sob incertezas, com exemplos de Skogestad e Postlethwaite.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Fundamentos de Diagramas de Bode e Valores Singulares",
                                  "subSteps": [
                                    "Estude a construção de diagramas de Bode para funções de transferência nominais e perturbadas.",
                                    "Revise o conceito de valores singulares (singular values) de uma matriz de transferência.",
                                    "Identifique as curvas superior e inferior de Bode para conjuntos de plantas incertas.",
                                    "Pratique plotagem de singular values usando software de simulação.",
                                    "Compare Bode magnitude e phase com singular value plots para sistemas SISO e MIMO."
                                  ],
                                  "verification": "Plotar corretamente um diagrama de Bode nominal e um conjunto de singular values para um exemplo simples, confirmando com referência teórica.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Livro 'Multivariable Feedback Control' de Skogestad e Postlethwaite (Capítulos 4 e 9)",
                                    "MATLAB com toolbox Control System ou Python com library control"
                                  ],
                                  "tips": [
                                    "Comece com sistemas SISO para familiarizar; use log scales consistentemente.",
                                    "Anote frequências de crossover manualmente antes de simular."
                                  ],
                                  "learningObjective": "Compreender as representações gráficas básicas usadas em análises de robustez.",
                                  "commonMistakes": [
                                    "Confundir magnitude de Bode com singular values em MIMO.",
                                    "Ignorar a fase nos diagramas iniciais.",
                                    "Usar escalas lineares em vez de logarítmicas."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Entender Modelos de Incertezas e Conjuntos de Plantas",
                                  "subSteps": [
                                    "Defina modelos de incerteza aditiva, multiplicativa e inversa conforme Skogestad.",
                                    "Construa conjuntos de plantas incertas usando blocos Δ de incerteza.",
                                    "Gere curvas de Bode robustas: máximo e mínimo sobre o conjunto de incertezas.",
                                    "Calcule o raio de singular value da perturbação Δ.",
                                    "Interprete o teorema de pequena ganho para estabilidade robusta."
                                  ],
                                  "verification": "Desenhar manualmente as curvas de Bode superior/inferior para um modelo de incerteza simples e validar no software.",
                                  "estimatedTime": "3 horas",
                                  "materials": [
                                    "Skogestad e Postlethwaite (Seção 9.2-9.3)",
                                    "Exemplos MATLAB do livro disponíveis online",
                                    "Folha de papel para esboços manuais"
                                  ],
                                  "tips": [
                                    "Visualize incertezas como 'nuvens' ao redor da planta nominal.",
                                    "Use μ-analysis tools se disponível para validação."
                                  ],
                                  "learningObjective": "Modelar incertezas paramétricas e não-paramétricas em representações gráficas.",
                                  "commonMistakes": [
                                    "Confundir incerteza aditiva com multiplicativa.",
                                    "Subestimar o impacto de incertezas em altas frequências.",
                                    "Esquecer normalização das perturbações."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar Margens de Desempenho em Gráficos de Robustez",
                                  "subSteps": [
                                    "Identifique margens de ganho e fase robustas nos diagramas de Bode.",
                                    "Avalie desempenho robusto via singular values de sensibilidade (S) e complemento (T).",
                                    "Verifique condições: ||T||∞ < 1/||Δ|| para estabilidade e ||S||∞ < M para desempenho.",
                                    "Calcule margens de desempenho como distâncias gráficas entre curvas.",
                                    "Interprete picos de ressonância e largura de banda robusta."
                                  ],
                                  "verification": "Para um controlador dado, quantificar margens robustas e afirmar se o sistema atende especificações de desempenho.",
                                  "estimatedTime": "3 horas",
                                  "materials": [
                                    "Postlethwaite exemplos em Skogestad Capítulo 10",
                                    "MATLAB scripts para robust control toolbox"
                                  ],
                                  "tips": [
                                    "Foque em frequências ωcg (crossover gain) para margens críticas.",
                                    "Sobreponha curvas de LMI e RMI para visualização clara."
                                  ],
                                  "learningObjective": "Avaliar quantitativamente estabilidade e desempenho sob incertezas usando gráficos.",
                                  "commonMistakes": [
                                    "Medir margens na planta aberta em vez de loop fechado.",
                                    "Ignorar singular values condicionados.",
                                    "Confundir estabilidade robusta com desempenho nominal."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Praticar com Exemplos Clássicos de Skogestad e Postlethwaite",
                                  "subSteps": [
                                    "Reproduza Exemplo 9.3 do livro: análise de um destilador com incertezas.",
                                    "Analise diagrama de Bode robusto para controlador H∞.",
                                    "Calcule singular values para margens de desempenho no exemplo 10.4.",
                                    "Compare interpretações com resultados teóricos do livro.",
                                    "Gere relatório resumindo achados e limitações."
                                  ],
                                  "verification": "Gerar plots idênticos aos do livro e extrair margens numéricas coincidentes.",
                                  "estimatedTime": "4 horas",
                                  "materials": [
                                    "Cópia digital do livro Skogestad e Postlethwaite",
                                    "MATLAB ou Octave com exemplos reproduzíveis"
                                  ],
                                  "tips": [
                                    "Baixe códigos do site do autor para aceleração.",
                                    "Varie parâmetros de incerteza para testar sensibilidade."
                                  ],
                                  "learningObjective": "Aplicar técnicas de interpretação em casos reais documentados.",
                                  "commonMistakes": [
                                    "Usar dados errados do exemplo.",
                                    "Interpretar curvas sem contexto do sistema físico.",
                                    "Pular cálculos manuais de verificação."
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Sintetizar e Verificar Interpretações de Robustez",
                                  "subSteps": [
                                    "Crie um checklist para análise de qualquer gráfico de robustez.",
                                    "Teste com um sistema novo: avalie trade-offs estabilidade-desempenho.",
                                    "Documente limitações das técnicas gráficas (ex: conservadorismo).",
                                    "Discuta melhorias via síntese H∞ ou μ-synthesis.",
                                    "Autoavalie com perguntas de verificação final."
                                  ],
                                  "verification": "Aplicar checklist a um gráfico inédito e justificar conclusões por escrito.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Checklist auto-criado",
                                    "Artigos complementares sobre robust control"
                                  ],
                                  "tips": [
                                    "Mantenha diário de análises para padrões recorrentes.",
                                    "Consulte fóruns como StackExchange para dúvidas."
                                  ],
                                  "learningObjective": "Desenvolver autonomia na interpretação crítica de gráficos de robustez.",
                                  "commonMistakes": [
                                    "Generalizar excessivamente de exemplos específicos.",
                                    "Negligenciar incertezas não-modeladas.",
                                    "Confundir robustez com otimização nominal."
                                  ]
                                }
                              ],
                              "practicalExample": "Em um processo de destilação (Exemplo 9.3 de Skogestad), plote o diagrama de Bode robusto para a planta com incerteza multiplicativa de 20%. Interprete que a margem de ganho robusta é 2.5 dB em ω=1 rad/s, indicando bom desempenho apesar de variações paramétricas de ganho de ±30%.",
                              "finalVerifications": [
                                "Consegue plotar e rotular corretamente curvas de Bode robustas e singular values.",
                                "Calcula margens de desempenho robustas com precisão <5% de erro.",
                                "Identifica violações de especificações em gráficos de forma consistente.",
                                "Explica verbalmente o impacto de incertezas em estabilidade/desempenho.",
                                "Reproduz análises de exemplos do livro sem consulta.",
                                "Aplica conceitos a um sistema não-visto anteriormente."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de curvas superior/inferior (90%+ acerto).",
                                "Correção quantitativa de margens (ganho/fase/||.||∞).",
                                "Profundidade de interpretação contextual (referências a teoremas).",
                                "Qualidade de plots e anotações (clareza e completude).",
                                "Capacidade de detectar trade-offs e propor ajustes.",
                                "Originalidade em exemplos práticos fornecidos."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Análise de valores singulares e funções complexas.",
                                "Programação: Simulação em MATLAB/Python para automação de plots.",
                                "Física: Dinâmica de sistemas reais com ruído e não-linearidades.",
                                "Estatística: Modelagem probabilística de incertezas.",
                                "Gestão de Projetos: Avaliação de riscos em design de controladores."
                              ],
                              "realWorldApplication": "Em indústrias químicas, como refino de petróleo, engenheiros usam esses gráficos para garantir que controladores de temperatura mantenham desempenho estável apesar de variações em viscosidade ou fouling, evitando paradas custosas e otimizando eficiência energética."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.5.3.4",
                            "name": "Verificar especificações via otimização",
                            "description": "Implementar métodos algorítmicos de otimização de parâmetros para maximizar robustez de desempenho, utilizando ferramentas como MATLAB fmincon.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender Especificações de Desempenho e Robustez",
                                  "subSteps": [
                                    "Revisar o modelo LIT do sistema com matrizes de incerteza (Δ).",
                                    "Identificar especificações de desempenho: tempo de assentamento, sobressinal, margem de ganho/fase.",
                                    "Analisar impacto das incertezas nos polos e resposta em frequência.",
                                    "Definir métricas de robustez quantitativas (ex.: H-infinito norm).",
                                    "Documentar baselines de desempenho nominal e pior-caso."
                                  ],
                                  "verification": "Lista completa de especificações e métricas de robustez documentada, com gráficos de resposta nominal vs. incerta.",
                                  "estimatedTime": "1-2 hours",
                                  "materials": [
                                    "Modelo LIT em MATLAB (tf/sys), documentação de robustez em controle"
                                  ],
                                  "tips": "Use bode plots e step responses para visualizar impactos iniciais das incertezas.",
                                  "learningObjective": "Identificar e quantificar especificações críticas afetadas por incertezas no sistema.",
                                  "commonMistakes": [
                                    "Ignorar incertezas estruturadas vs. não-estruturadas",
                                    "Confundir robustez com estabilidade nominal"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Formular o Problema de Otimização",
                                  "subSteps": [
                                    "Definir parâmetros a otimizar (ex.: ganhos Kp, Ki, Kd ou matriz C).",
                                    "Construir função objetivo: minimizar erro de especificações + penalizar violações de robustez.",
                                    "Estabelecer restrições: limites físicos, margens de estabilidade, normas de incerteza.",
                                    "Incorporar métricas robustas (ex.: maximizar menor valor singular sob Δ).",
                                    "Testar formulação com valores iniciais aleatórios."
                                  ],
                                  "verification": "Função objetivo e constraints codificadas em script MATLAB, com teste de viabilidade inicial.",
                                  "estimatedTime": "2-3 hours",
                                  "materials": [
                                    "Documentação MATLAB Optimization Toolbox",
                                    "Exemplos de funções custo em controle robusto"
                                  ],
                                  "tips": "Use pesos normalizados nas especificações para balancear trade-offs.",
                                  "learningObjective": "Traduzir especificações qualitativas em problema de otimização quantitativo e factível.",
                                  "commonMistakes": [
                                    "Função objetivo não-convexa sem convexificação",
                                    "Restrições muito frouxas levando a soluções não-robuntas"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar e Executar Otimização com fmincon",
                                  "subSteps": [
                                    "Configurar opções do fmincon: algoritmo interior-point, tolerâncias, gradientes numéricos.",
                                    "Codificar função custo e constraints não-lineares usando sys robusto.",
                                    "Executar otimização com múltiplos pontos iniciais para evitar mínimos locais.",
                                    "Monitorar convergência e diagnosticar falhas (ex.: via fmincon output).",
                                    "Salvar solução ótima e parâmetros finais."
                                  ],
                                  "verification": "Otimização convergeu com status >0, parâmetros otimizados salvos e plots de histórico de custo.",
                                  "estimatedTime": "2-4 hours",
                                  "materials": [
                                    "MATLAB com Optimization Toolbox",
                                    "Sistema de exemplo com incertezas (ex.: robustControl toolbox)"
                                  ],
                                  "tips": "Ative parallel computing para avaliações custosas de robustez.",
                                  "learningObjective": "Aplicar fmincon para otimização não-linear em contextos de controle robusto.",
                                  "commonMistakes": [
                                    "Não fornecer gradientes/Jacobianos levando a lentidão",
                                    "Pontos iniciais ruins causando não-convergência"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificar Robustez e Analisar Resultados",
                                  "subSteps": [
                                    "Simular resposta com parâmetros otimizados sob nominal e ensemble de incertezas.",
                                    "Verificar todas especificações: step response, Nyquist, métricas H-inf.",
                                    "Comparar com baseline não-otimizado via métricas quantitativas.",
                                    "Realizar análise de sensibilidade a variações adicionais.",
                                    "Documentar trade-offs e sugestões de refinamento."
                                  ],
                                  "verification": "Relatório com gráficos confirmando todas especificações atendidas em 95% dos casos incertos.",
                                  "estimatedTime": "1-2 hours",
                                  "materials": [
                                    "robustControl toolbox para mu-analysis",
                                    "Scripts de simulação Monte Carlo"
                                  ],
                                  "tips": "Use usim ou wcgain para verificações rápidas de robustez.",
                                  "learningObjective": "Validar que a otimização maximiza robustez conforme especificações.",
                                  "commonMistakes": [
                                    "Verificar apenas nominal ignorando cenários extremos",
                                    "Sobre-otimizar uma métrica em detrimento de outras"
                                  ]
                                }
                              ],
                              "practicalExample": "Otimizar ganhos de um controlador PID para um sistema de posicionamento de braço robótico com ±20% variação em massa/inércia, usando fmincon para minimizar tempo de assentamento máximo sob incertezas enquanto mantém sobressinal <10%.",
                              "finalVerifications": [
                                "Todas especificações de desempenho atendidas no pior-caso de incerteza.",
                                "Otimização convergeu em <100 iterações com custo final < threshold definido.",
                                "Margens de robustez (ganho/fase) melhoradas >20% vs. baseline.",
                                "Simulações Monte Carlo confirmam robustez em 95% dos cenários.",
                                "Parâmetros otimizados dentro de limites físicos realistas.",
                                "Gráficos de resposta mostram melhoria visual clara."
                              ],
                              "assessmentCriteria": [
                                "Precisão da formulação: função custo captura todas especificações (peso 25%).",
                                "Eficiência computacional: tempo de execução <5min (peso 20%).",
                                "Robustez alcançada: violações <5% em testes (peso 30%).",
                                "Qualidade da verificação: cobertura completa de análises (peso 15%).",
                                "Documentação: clareza e reprodutibilidade (peso 10%)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Otimização não-linear e programação quadrática.",
                                "Programação: Desenvolvimento de funções MATLAB avançadas e debugging.",
                                "Física: Modelagem dinâmica de sistemas com incertezas paramétricas.",
                                "Estatística: Análise Monte Carlo e sensibilidade.",
                                "Engenharia de Software: Modularidade em scripts de otimização."
                              ],
                              "realWorldApplication": "Design de controladores robustos para drones em ventos variáveis, garantindo estabilidade e precisão de trajetória apesar de incertezas em aerodinâmica e payload."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      }
                    ]
                  }
                ]
              },
              {
                "id": "10.1.3",
                "name": "Técnicas Avançadas de Projeto: Formatação de Malha",
                "description": "Formatação de malha para projeto de controladores em sistemas LIT escalares.",
                "totalSkills": 57,
                "atomicTopics": [
                  {
                    "id": "10.1.3.1",
                    "name": "Conceitos Básicos de Formatação de Malha",
                    "description": "Princípios fundamentais de moldagem da malha aberta para especificações de desempenho e robustez em sistemas LIT escalares.",
                    "individualConcepts": [
                      {
                        "id": "76.4.4.1.1",
                        "name": "Projeto Clássico de Sistemas de Controle LIT Escalar",
                        "description": "Revisão dos conceitos fundamentais de estabilidade, desempenho transitório e em frequência, e técnicas clássicas de projeto como diagramas de Bode, Nyquist e Root Locus para sistemas lineares invariantes no tempo (LIT) escalares.",
                        "specificSkills": [
                          {
                            "id": "76.4.4.1.1.1",
                            "name": "Identificar critérios de estabilidade em malha fechada",
                            "description": "Aplicar critérios de Routh-Hurwitz, Nyquist e margens de ganho/fase para determinar a estabilidade absoluta e relativa de sistemas LIT escalares usando ferramentas clássicas.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender conceitos fundamentais de estabilidade em malha fechada",
                                  "subSteps": [
                                    "Definir estabilidade absoluta (todos os polos no semiplano esquerdo) e relativa (margens de estabilidade).",
                                    "Explicar sistemas LIT escalares e função de transferência em malha fechada.",
                                    "Diferenciar ferramentas clássicas: Routh-Hurwitz (domínio do tempo), Nyquist e Bode (frequência).",
                                    "Revisar equação característica de malha fechada: 1 + G(s)H(s) = 0.",
                                    "Identificar quando usar cada critério com base no tipo de sistema."
                                  ],
                                  "verification": "Escrever um resumo de 200 palavras explicando estabilidade absoluta vs. relativa e listar prós/contras de cada critério.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Livro de Controle Clássico (Ogata ou similar)",
                                    "Aulas gravadas sobre teoria de controle",
                                    "Folha de anotações"
                                  ],
                                  "tips": [
                                    "Comece com exemplos simples de sistemas instáveis para fixar conceitos.",
                                    "Use diagramas de blocos para visualizar malha fechada."
                                  ],
                                  "learningObjective": "Dominar os fundamentos teóricos para aplicação posterior dos critérios.",
                                  "commonMistakes": [
                                    "Confundir estabilidade absoluta com convergência da resposta ao degrau.",
                                    "Ignorar o papel do laço de realimentação na equação característica."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Aplicar o Critério de Routh-Hurwitz para estabilidade absoluta",
                                  "subSteps": [
                                    "Obter o polinômio característico da malha fechada.",
                                    "Construir a tabela Routh array passo a passo (primeira e segunda colunas).",
                                    "Calcular elementos da tabela usando regras de continuidade e auxiliares.",
                                    "Analisar a primeira coluna: ausência de mudança de sinal indica estabilidade.",
                                    "Identificar polos na origem ou imaginação pura via linhas inteiras de zero."
                                  ],
                                  "verification": "Resolver 3 exemplos manuais e verificar se todos os polos estão no semiplano esquerdo via raízes.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Calculadora ou MATLAB para raízes",
                                    "Tabelas de exemplo resolvidas",
                                    "Software SymPy ou MATLAB para tabela Routh"
                                  ],
                                  "tips": [
                                    "Sempre normalize o polinômio para grau conhecido.",
                                    "Pratique com polinômios de 3º e 4º ordem primeiro."
                                  ],
                                  "learningObjective": "Construir e interpretar tabelas Routh para determinar estabilidade absoluta.",
                                  "commonMistakes": [
                                    "Erro em cálculos de elementos derivados (use fórmula ε para aproximação).",
                                    "Esquecer de tratar linhas de zero."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Utilizar o Critério de Nyquist para estabilidade relativa",
                                  "subSteps": [
                                    "Plotar o diagrama de Nyquist de G(jω)H(jω) para ω de 0 a ∞.",
                                    "Identificar o número de polos instáveis de loop aberto (P).",
                                    "Contar encirclements (N) em torno de -1 no plano complexo.",
                                    "Aplicar critério: Z = N + P (polos instáveis em malha fechada = 0 para estável).",
                                    "Analisar para diferentes ganhos de K."
                                  ],
                                  "verification": "Desenhar Nyquist para um sistema dado e prever estabilidade para K=1 e K=2.",
                                  "estimatedTime": "2.5 horas",
                                  "materials": [
                                    "MATLAB/Simulink para plot Nyquist",
                                    "Papel milimetrado para plot manual",
                                    "Exemplos de diagramas Nyquist"
                                  ],
                                  "tips": [
                                    "Use simetria para ω negativo.",
                                    "Verifique assíntotas para altas frequências."
                                  ],
                                  "learningObjective": "Plotar e interpretar diagramas Nyquist para estabilidade.",
                                  "commonMistakes": [
                                    "Contar encirclements no sentido errado (deve ser anti-horário).",
                                    "Ignorar polos em jω no loop aberto."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Calcular e interpretar margens de ganho e fase",
                                  "subSteps": [
                                    "Gerar diagramas de Bode de magnitude e fase de L(jω) = G(jω)H(jω).",
                                    "Encontrar frequência de ganho unitário (ω_g) e margem de fase (PM = 180° + φ(ω_g)).",
                                    "Encontrar frequência de fase -180° (ω_p) e margem de ganho (GM = 1/|L(jω_p)| em dB).",
                                    "Interpretar: PM > 45° e GM > 6dB indicam boa estabilidade relativa.",
                                    "Relacionar com Nyquist: interseção com eixo real negativo."
                                  ],
                                  "verification": "Calcular PM e GM para um sistema e simular resposta ao degrau para validar robustez.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "MATLAB Bode plot function",
                                    "Tabelas de Bode pré-calculadas",
                                    "Simulador online de controle"
                                  ],
                                  "tips": [
                                    "Use log-log para magnitude.",
                                    "Ajuste K para margens desejadas."
                                  ],
                                  "learningObjective": "Quantificar estabilidade relativa via margens e especificar requisitos.",
                                  "commonMistakes": [
                                    "Confundir ω_g com ω_p.",
                                    "Esquecer conversão dB para razão absoluta."
                                  ]
                                }
                              ],
                              "practicalExample": "Para um sistema de controle de posição de um braço robótico com G(s) = K / (s(s+2)(s+10)), aplique Routh-Hurwitz para K=100 (verifique tabela sem mudança de sinal), Nyquist (sem encirclements de -1) e Bode (PM=60°, GM=8dB), confirmando estabilidade absoluta e relativa boa para rastreamento preciso.",
                              "finalVerifications": [
                                "Construir tabela Routh correta para polinômio de 4ª ordem.",
                                "Plotar Nyquist e contar Z corretamente.",
                                "Calcular PM e GM com precisão <5% de erro.",
                                "Explicar impacto de variação de K na estabilidade.",
                                "Simular sistema em MATLAB e observar overshoot <20%.",
                                "Comparar resultados dos 3 critérios para um caso."
                              ],
                              "assessmentCriteria": [
                                "Precisão matemática nos cálculos (90% correto).",
                                "Interpretação qualitativa e quantitativa adequada.",
                                "Uso correto de ferramentas (plots limpos e etiquetados).",
                                "Identificação de limitações de cada método.",
                                "Aplicação integrada em exemplo real.",
                                "Tempo de resolução eficiente."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Análise de polinômios e transformadas de Laplace.",
                                "Física: Modelagem dinâmica de sistemas mecânicos/elétricos.",
                                "Informática: Programação em MATLAB/Python para simulações.",
                                "Engenharia de Software: Validação de algoritmos de controle.",
                                "Estatística: Análise de robustez sob incertezas paramétricas."
                              ],
                              "realWorldApplication": "Em sistemas de controle de drones para estabilização de voo, onde Routh-Hurwitz garante ausência de oscilações divergentes, Nyquist previne instabilidades não lineares e margens de fase/ganho asseguram robustez a variações de vento ou carga, evitando crashes."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "76.4.4.1.1.2",
                            "name": "Avaliar especificações de desempenho em frequência",
                            "description": "Analisar diagramas de Bode para margens de estabilidade, largura de banda, atenuação em baixas e altas frequências, e rejeição de ruído em sistemas de controle LIT escalares.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Interpretar os componentes do diagrama de Bode",
                                  "subSteps": [
                                    "Identifique o eixo de frequência (logarítmico) e os eixos de magnitude e fase (em dB e graus).",
                                    "Diferencie o diagrama de magnitude (G(jω)) de fase (∠G(jω)).",
                                    "Localize pontos chave como frequência de corte, picos de ressonância e assimptotas.",
                                    "Anote as inclinações das assimptotas (20 dB/década por polo/zero).",
                                    "Compare com o diagrama teórico da função de transferência."
                                  ],
                                  "verification": "Desenhe ou anote corretamente os componentes principais do diagrama fornecido.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Diagrama de Bode exemplo, régua, calculadora científica",
                                  "tips": "Use escala logarítmica para precisão; foque em transições suaves entre assimptotas.",
                                  "learningObjective": "Compreender a estrutura visual do diagrama de Bode para análise subsequente.",
                                  "commonMistakes": "Confundir magnitude com fase; ignorar desvios das assimptotas reais."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Calcular margens de estabilidade (ganho e fase)",
                                  "subSteps": [
                                    "Encontre a frequência de ganho unitário (ω_cg) onde |G(jω)| = 0 dB.",
                                    "Meça a margem de fase: 180° + ∠G(jω_cg).",
                                    "Encontre a frequência de fase -180° (ω_cp) onde ∠G(jω) = -180°.",
                                    "Calcule a margem de ganho: 0 dB - |G(jω_cp)|.",
                                    "Verifique se margem de ganho > 6 dB e margem de fase > 45° para estabilidade."
                                  ],
                                  "verification": "Calcule valores numéricos corretos para ambas as margens em um diagrama dado.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Diagrama de Bode, transferidor ou software como MATLAB/Python",
                                  "tips": "Use interpolação linear em escalas log para frequências exatas.",
                                  "learningObjective": "Avaliar estabilidade relativa via critérios de Bode.",
                                  "commonMistakes": "Errar o sinal na margem de fase; usar frequência errada para cada margem."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Determinar largura de banda e atenuação em frequências extremas",
                                  "subSteps": [
                                    "Defina largura de banda como ω_bw onde |G(jω)| = -3 dB.",
                                    "Meça atenuação em baixas frequências (ω → 0): verifique ganho DC alto.",
                                    "Avalie atenuação em altas frequências (ω → ∞): confirme roll-off adequado (ex: -40 dB/déc).",
                                    "Compare com especificações: ω_bw > valor mínimo, atenuação alta > 40 dB.",
                                    "Registre valores exatos e tendências."
                                  ],
                                  "verification": "Identifique e quantifique ω_bw e atenuações corretamente.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Diagrama de Bode, tabela de especificações",
                                  "tips": "Largura de banda é ponto -3 dB no diagrama de magnitude.",
                                  "learningObjective": "Quantificar desempenho dinâmico em frequência.",
                                  "commonMistakes": "Confundir -3 dB com 0 dB; ignorar efeitos de picos."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar rejeição de ruído e sintetizar resultados",
                                  "subSteps": [
                                    "Avalie rejeição de ruído em baixas frequências: alta atenuação em |S(jω)| = 1/|G(jω)|.",
                                    "Verifique sensibilidade a ruído em altas frequências via diagrama de Bode do controlador.",
                                    "Integre todas as métricas: estabilidade, banda, atenuação, ruído.",
                                    "Compare com especificações do problema e identifique violações.",
                                    "Documente relatório com valores e conclusões."
                                  ],
                                  "verification": "Produza um relatório resumindo se as especificações são atendidas.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Diagrama de Bode, folha de relatório",
                                  "tips": "Ruído é rejeitado onde |G(jω)| >> 1; sensível onde |G(jω)| << 1.",
                                  "learningObjective": "Integrar análise para decisão sobre conformidade.",
                                  "commonMistakes": "Subestimar impacto de ruído em bandas de interesse."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Validar com simulação ou cálculo manual",
                                  "subSteps": [
                                    "Calcule pontos chave manualmente via função de transferência.",
                                    "Simule diagrama de Bode em software para confirmação.",
                                    "Ajuste interpretações se houver discrepâncias.",
                                    "Discuta trade-offs entre métricas (ex: banda vs. estabilidade).",
                                    "Prepare apresentação dos resultados."
                                  ],
                                  "verification": "Resultados da simulação coincidem com análise gráfica (±5%).",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Software (MATLAB/SciPy), função de transferência",
                                  "tips": "Use Bode plot built-in functions para validação rápida.",
                                  "learningObjective": "Garantir robustez da análise via verificação cruzada.",
                                  "commonMistakes": "Não validar com cálculos; confiar cegamente no gráfico."
                                }
                              ],
                              "practicalExample": "Em um sistema de controle de posição de um braço robótico com G(s) = 100 / (s(s+10)), analise o diagrama de Bode após adicionar controlador PI: verifique margem de fase >50°, ω_bw >5 rad/s, atenuação >30 dB em ω>100 rad/s e rejeição de ruído em DC.",
                              "finalVerifications": [
                                "Margens de ganho e fase atendem critérios mínimos (6 dB e 45°).",
                                "Largura de banda ≥ especificada.",
                                "Atenuação em baixas frequências > ganho DC desejado.",
                                "Roll-off em altas frequências ≥ -40 dB/década.",
                                "Rejeição de ruído confirmada em bandas críticas.",
                                "Nenhum pico de ressonância excessivo (>6 dB)."
                              ],
                              "assessmentCriteria": [
                                "Precisão nos cálculos de margens (±1 dB/grau).",
                                "Identificação correta de largura de banda e atenuações.",
                                "Integração coerente de todas as métricas em relatório.",
                                "Validação com simulação ou teoria.",
                                "Explicação clara de trade-offs e recomendações.",
                                "Uso adequado de ferramentas e documentação."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Análise de funções complexas e logarítmica.",
                                "Eletrônica: Projeto de filtros analógicos e amplificadores.",
                                "Física: Dinâmica de sistemas mecânicos vibratórios.",
                                "Programação: Simulação numérica em Python/MATLAB."
                              ],
                              "realWorldApplication": "Em automação industrial, como controle de velocidade de motores em linhas de produção, onde diagramas de Bode garantem estabilidade contra variações de carga e rejeitam ruído elétrico, evitando oscilações que causam falhas em fábricas."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "76.4.4.1.1.3",
                            "name": "Aplicar técnicas clássicas de sintonia de controladores",
                            "description": "Utilizar métodos como Ziegler-Nichols, sintonia por Bode ou Root Locus para projetar controladores PID que atendam especificações de desempenho em sistemas LIT escalares.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Modelar o sistema LIT escalar e definir especificações de desempenho",
                                  "subSteps": [
                                    "Identifique a função de transferência do sistema LIT escalar a partir de equações diferenciais ou dados experimentais.",
                                    "Defina especificações claras: overshoot máximo (ex: <20%), tempo de subida (ex: <5s), tempo de estabilização (ex: <30s) e erro em regime estacionário (ex: <2%).",
                                    "Linearize o modelo se necessário, assumindo operação em torno de um ponto de equilíbrio.",
                                    "Simule o sistema em malha aberta para validar o modelo.",
                                    "Documente as especificações em uma tabela para referência futura."
                                  ],
                                  "verification": "O modelo simulado em malha aberta reproduz fielmente o comportamento esperado do sistema físico ou dados de referência.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Software de simulação (MATLAB/Simulink ou Python com control library)",
                                    "Documentação do sistema físico",
                                    "Papel e caneta para esboços"
                                  ],
                                  "tips": "Sempre valide o modelo com step response em malha aberta antes de prosseguir.",
                                  "learningObjective": "Compreender e quantificar especificações de desempenho para guiar o projeto do controlador.",
                                  "commonMistakes": [
                                    "Ignorar não-linearidades que afetam a linearização",
                                    "Definir specs irreais sem considerar limitações do atuador",
                                    "Esquecer de normalizar unidades no modelo"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Aplicar método de sintonia Ziegler-Nichols",
                                  "subSteps": [
                                    "Aplique oscilação sustentada em malha fechada com controlador P para encontrar Ku (ganho crítico) e Tu (período crítico).",
                                    "Calcule parâmetros PID usando regras Ziegler-Nichols: Kp = 0.6 Ku, Ti = 0.5 Tu, Td = 0.125 Tu.",
                                    "Implemente o controlador PID no simulador e aplique entrada degrau.",
                                    "Analise resposta: meça overshoot, tempo de subida e estabilização.",
                                    "Ajuste manualmente se necessário para atender specs iniciais."
                                  ],
                                  "verification": "Os parâmetros PID calculados produzem resposta com oscilação crítica observável e specs próximas às desejadas.",
                                  "estimatedTime": "3 horas",
                                  "materials": [
                                    "Simulador (MATLAB/Simulink)",
                                    "Função de transferência do Step 1",
                                    "Tabelas de regras Ziegler-Nichols"
                                  ],
                                  "tips": "Use automação no simulador para encontrar Ku precisamente via relay feedback.",
                                  "learningObjective": "Dominar sintonia empírica Ziegler-Nichols para controladores PID robustos.",
                                  "commonMistakes": [
                                    "Confundir Ku com ganho em malha aberta",
                                    "Aplicar regras erradas para variantes (ex: P-only vs PID)",
                                    "Não considerar delays no sistema"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Realizar sintonia usando diagrama de Bode",
                                  "subSteps": [
                                    "Gere diagramas de Bode da planta G(s) e do loop de malha fechada L(s) = K G(s).",
                                    "Ajuste ganho K para margem de fase de 45-60° e margem de ganho >6dB nas frequências desejadas.",
                                    "Incorpore integrador para eliminar erro estacionário e derive para derivativo se damping necessário.",
                                    "Simule resposta temporal e verifique trade-offs entre estabilidade e desempenho.",
                                    "Otimize iterativamente os parâmetros para specs exatas."
                                  ],
                                  "verification": "Diagramas de Bode mostram margens de estabilidade adequadas e crossover frequency alinhada com tempo de resposta desejado.",
                                  "estimatedTime": "3 horas",
                                  "materials": [
                                    "MATLAB bode() ou Python control.bode_plot()",
                                    "Modelos do Step 1",
                                    "Tabelas de especificações de margens"
                                  ],
                                  "tips": "Foque em frequência de crossover ωc ≈ 1/(tempo de subida desejado).",
                                  "learningObjective": "Usar análise em frequência para sintonia que garante estabilidade robusta.",
                                  "commonMistakes": [
                                    "Ignorar picos de ressonância no Bode",
                                    "Confundir margem de fase com ganho",
                                    "Não compensar delays de fase"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Empregar Root Locus e validar projeto final",
                                  "subSteps": [
                                    "Plote o Root Locus de 1 + K G(s) = 0 e selecione K para polos desejados (ex: damping ζ=0.7, ωn adequado).",
                                    "Adicione zeros para PID e reforce o locus para atender specs de assentamento e overshoot.",
                                    "Compare respostas de todos métodos (ZN, Bode, RL) em simulações side-by-side.",
                                    "Teste robustez com variações de parâmetros (±20%) e perturbações.",
                                    "Documente o melhor controlador e justifique escolha."
                                  ],
                                  "verification": "Root Locus mostra polos fechados no semiplano esquerdo com características desejadas; simulações comparativas atendem todas specs.",
                                  "estimatedTime": "4 horas",
                                  "materials": [
                                    "Funções rlocus() no MATLAB/Python",
                                    "Simulador completo",
                                    "Ferramentas de análise de sensibilidade"
                                  ],
                                  "tips": "Use regra de que overshoot ≈ e^(-πζ / sqrt(1-ζ²)) para guiar seleção de polos.",
                                  "learningObjective": "Integrar análise de root locus para sintonia precisa e comparação de métodos.",
                                  "commonMistakes": [
                                    "Interpretar errado branches do locus",
                                    "Esquecer contribuições de zeros no PID",
                                    "Não validar com simulações não-lineares"
                                  ]
                                }
                              ],
                              "practicalExample": "Para um motor DC com G(s) = 1/(s(s+1)), defina specs: overshoot <15%, Ts <4s. Aplique ZN para obter Kp=3.2, Ti=0.8, Td=0.2; refine com Bode para margem fase 50° e RL para polos em -1.5 ± j1.2. Simule step response mostrando Ts=3.2s, overshoot=12%.",
                              "finalVerifications": [
                                "Implementou pelo menos dois métodos com cálculos corretos.",
                                "Todas simulações atendem specs de desempenho definidas.",
                                "Comparou métodos e justificou o melhor.",
                                "Testou robustez com ±20% variação de parâmetros.",
                                "Documentou processo com plots de Bode, RL e step responses.",
                                "Identificou limitações de cada método no contexto do sistema."
                              ],
                              "assessmentCriteria": [
                                "Precisão matemática nos cálculos de parâmetros PID (erro <5%).",
                                "Atendimento integral às especificações de desempenho em simulações.",
                                "Qualidade das análises de estabilidade (margens >45° fase, >6dB ganho).",
                                "Profundidade da comparação entre métodos clássicos.",
                                "Clareza e completude da documentação com visualizações.",
                                "Demonstração de robustez e tratamento de erros comuns."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Análise de funções complexas e transformadas de Laplace.",
                                "Programação: Implementação em MATLAB/Python para simulações dinâmicas.",
                                "Física: Modelagem de sistemas dinâmicos reais (ex: circuitos RLC).",
                                "Estatística: Análise de sensibilidade e Monte Carlo para robustez.",
                                "Engenharia de Software: Versionamento de modelos e scripts de simulação."
                              ],
                              "realWorldApplication": "Em indústrias como petroquímica para controle de nível de tanques, automotiva para estabilidade de ABS, ou manufatura para precisão em CNC, onde controladores PID sintonizados classicamente garantem operação segura e eficiente de processos contínuos."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "76.4.4.1.2",
                        "name": "Modelos de Incertezas e Robustez em Sistemas LIT",
                        "description": "Introdução aos modelos de incertezas (aditivas, multiplicativas e inversa) e à forma padrão de análise de robustez para quantificar a sensibilidade de sistemas LIT escalares a variações paramétricas e não paramétricas.",
                        "specificSkills": [
                          {
                            "id": "76.4.4.1.2.1",
                            "name": "Modelar incertezas aditivas e multiplicativas",
                            "description": "Representar incertezas no modelo de planta como perturbações aditivas na saída ou multiplicativas na transferência, utilizando normas de pico e H-infinito para quantificação.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender Conceitos Fundamentais de Incertezas em Sistemas LIT",
                                  "subSteps": [
                                    "Estude a definição de sistemas Linearmente Invariantes no Tempo (LIT) e suas limitações reais devido a incertezas.",
                                    "Diferencie incertezas aditivas (perturbações na saída) de multiplicativas (perturbações nos parâmetros da transferência).",
                                    "Revise representações gráficas de modelos nominais com blocos de incerteza Δ.",
                                    "Analise exemplos simples de plantas nominais P(s) com adição de Δ_add e multiplicação por Δ_mult.",
                                    "Explore o papel das incertezas na estabilidade e desempenho do laço de controle."
                                  ],
                                  "verification": "Resuma em um diagrama de blocos as diferenças entre Δ_add e Δ_mult, explicando verbalmente para um colega.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Livro de Controle Avançado (Doyle ou Zhou), MATLAB/Simulink, notas de aula sobre sistemas LIT"
                                  ],
                                  "tips": "Use diagramas de blocos para visualizar; comece com sistemas de primeira ordem para simplicidade.",
                                  "learningObjective": "Identificar e diferenciar tipos de incertezas em modelos de plantas de controle.",
                                  "commonMistakes": [
                                    "Confundir aditiva com multiplicativa",
                                    "Ignorar o impacto na saída vs. transferência",
                                    "Não considerar sistemas LIT como base"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Modelar Perturbações Aditivas na Saída",
                                  "subSteps": [
                                    "Defina o modelo nominal P(s) e adicione Δ_add(w) como perturbação aditiva na saída y = P(s)u + Δ_add(w)u.",
                                    "Represente Δ_add como um bloco em paralelo com P(s) no diagrama de laço.",
                                    "Gere funções de incerteza aditiva baseadas em dados experimentais ou bounds conhecidos.",
                                    "Implemente em MATLAB o modelo com perturbação aditiva usando tf() e feedback().",
                                    "Simule respostas em frequência para observar o impacto de Δ_add."
                                  ],
                                  "verification": "Crie e simule um modelo em MATLAB mostrando variação na resposta devido a Δ_add de magnitude 10%.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "MATLAB com Control System Toolbox, exemplos de plantas como motor DC"
                                  ],
                                  "tips": "Normalise incertezas para |Δ_add| ≤ 1; use bode() para análise em frequência.",
                                  "learningObjective": "Construir e simular modelos com incertezas aditivas corretamente.",
                                  "commonMistakes": [
                                    "Colocar Δ_add em série em vez de paralelo",
                                    "Esquecer de normalizar a incerteza",
                                    "Não simular em frequência"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Modelar Perturbações Multiplicativas na Função de Transferência",
                                  "subSteps": [
                                    "Modele a planta perturbada como P_pert(s) = P(s)(1 + Δ_mult(s)), onde Δ_mult captura variações paramétricas.",
                                    "Desenhe o diagrama de blocos com Δ_mult em série após P(s).",
                                    "Estime Δ_mult a partir de desvios paramétricos (ex: ganho ±20%, polo deslocado).",
                                    "Implemente no Simulink um modelo com multiplicador randômico para Δ_mult.",
                                    "Compare respostas nominais vs. perturbadas em tempo e frequência."
                                  ],
                                  "verification": "Gere plots de Bode para P(s) e P_pert(s), confirmando ampliação de incerteza em bandas específicas.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Simulink, funções MATLAB como uss() para sistemas incertos"
                                  ],
                                  "tips": "Use ureal() no Robust Control Toolbox para modelagem estruturada de Δ_mult.",
                                  "learningObjective": "Representar e simular incertezas multiplicativas em funções de transferência.",
                                  "commonMistakes": [
                                    "Usar aditiva em vez de multiplicativa para variações paramétricas",
                                    "Não limitar |Δ_mult(jω)| ≤ 1",
                                    "Ignorar fase da incerteza"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Quantificar Incertezas Usando Normas de Pico e H-Infinito",
                                  "subSteps": [
                                    "Defina norma de pico ||Δ||_∞ = sup_ω |Δ(jω)| e seu papel na robustez.",
                                    "Calcule normas H-infinito de Δ_add e Δ_mult usando hinfnorm() no MATLAB.",
                                    "Estabeleça condições de robustez: ||Tzw||_∞ < 1 / ||Δ||_∞ para estabilidade.",
                                    "Analise um laço completo com incertezas e verifique margens de robustez.",
                                    "Otimize bounds de incerteza para cobrir cenários reais."
                                  ],
                                  "verification": "Compute ||Δ||_∞ para seus modelos e confirme estabilidade robusta com gamma < 1.",
                                  "estimatedTime": "2.5 horas",
                                  "materials": [
                                    "Robust Control Toolbox MATLAB, tutoriais sobre mu-síntese"
                                  ],
                                  "tips": "Plot uss para visualizar bounds; foque em frequências críticas.",
                                  "learningObjective": "Aplicar normas para quantificar e garantir robustez contra incertezas.",
                                  "commonMistakes": [
                                    "Confundir norma de pico com L2",
                                    "Não inverter na condição de robustez",
                                    "Calcular norma sem normalização"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um sistema de controle de posição de um braço robótico, modele P(s) = 1/(s^2 + s) nominal. Adicione Δ_add = 0.1 sen(10t) na saída para ruído sensorial e Δ_mult = 0.2 para variação no ganho do atuador. Simule e quantifique ||Δ||_∞ = 0.2, garantindo estabilidade com controlador ajustado.",
                              "finalVerifications": [
                                "Diagrama de blocos completo com Δ_add e Δ_mult integrado.",
                                "Simulações em MATLAB mostrando impacto das incertezas.",
                                "Cálculos de normas H-infinito corretos para ambos tipos.",
                                "Análise de robustez confirmando ||M||_∞ * ||Δ||_∞ < 1.",
                                "Relatório resumindo diferenças e aplicações."
                              ],
                              "assessmentCriteria": [
                                "Precisão na representação gráfica de incertezas (90%+ correção).",
                                "Corretude das simulações e plots de frequência.",
                                "Cálculos numéricos de normas exatos (erro < 5%).",
                                "Explicação clara das implicações para robustez.",
                                "Integração coerente no contexto de formatação de malha."
                              ],
                              "crossCurricularConnections": [
                                "Probabilidade e Estatística: Modelagem estocástica de perturbações.",
                                "Análise Numérica: Cálculo de normas e simulações discretas.",
                                "Física Aplicada: Modelos dinâmicos reais com ruído.",
                                "Otimização: Síntese de controladores H-infinito."
                              ],
                              "realWorldApplication": "Em controle de voo de aeronaves, modela incertezas aditivas como turbulência na saída de sensores e multiplicativas como variações aerodinâmicas, usando H-infinito para certificação de robustez pela FAA."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "76.4.4.1.2.2",
                            "name": "Utilizar a forma padrão para análise de robustez",
                            "description": "Reescrever o laço de controle LIT escalar na forma padrão M-Δ para avaliar estabilidade robusta via critério de pequeno ganho e calcular margens de robustez.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar conceitos fundamentais de laços de controle LIT e modelos de incerteza",
                                  "subSteps": [
                                    "Estude a estrutura de um laço de controle LIT escalar, identificando planta P(s), controlador C(s) e realimentação unitária.",
                                    "Revise modelos de incertezas aditivas, multiplicativas e de estrutura coprime para Δ.",
                                    "Entenda o critério de pequeno ganho: ||M||_∞ < 1/||Δ||_∞ implica estabilidade robusta.",
                                    "Analise exemplos simples de perturbações em plantas nominais.",
                                    "Desenhe diagramas de bloco para laços com incertezas."
                                  ],
                                  "verification": "Resuma em um diagrama os componentes de um laço LIT com incerteza Δ e explique o critério de pequeno ganho verbalmente.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Livro de Doyle 'Feedback Control Theory' (cap. robustez), MATLAB para plotar respostas em frequência.",
                                  "tips": "Comece com laços simples SISO para fixar ideias antes de generalizar.",
                                  "learningObjective": "Compreender a representação de laços LIT e incertezas para preparar a transformação M-Δ.",
                                  "commonMistakes": "Confundir incerteza aditiva com multiplicativa; sempre verifique o ponto de injeção da Δ."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Derivar a forma padrão M-Δ para um laço de controle LIT escalar",
                                  "subSteps": [
                                    "Reescreva o laço fechado como [I + M Δ]^(-1) usando fatorização coprime.",
                                    "Identifique M como função de transferência nominal: M = [P K; I + P K] para fatorização dupla coprime.",
                                    "Copie fórmulas padrão para M de laços unitários de realimentação.",
                                    "Implemente em MATLAB a função tf para calcular M(s) a partir de P(s) e C(s).",
                                    "Valide a derivação manipulando expressões algébricas."
                                  ],
                                  "verification": "Derive M(s) para um laço exemplo e plote ||M(jω)|| para confirmação.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Folha de derivações, MATLAB/Simulink, notas de aula sobre fatorização coprime.",
                                  "tips": "Use syms no MATLAB para derivações simbólicas se possível.",
                                  "learningObjective": "Dominar a reescrita algébrica do laço na forma M-Δ.",
                                  "commonMistakes": "Esquecer a normalização; M deve ser estável e mínimo de fase."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Avaliar estabilidade robusta usando o critério de pequeno ganho",
                                  "subSteps": [
                                    "Calcule a norma H-infinito de M: sup_ω ||M(jω)||_∞.",
                                    "Estime ||Δ||_∞ da incerteza (ex: de dados experimentais ou bounds).",
                                    "Verifique se ||M||_∞ ||Δ||_∞ < 1 para estabilidade.",
                                    "Plote singular values de M(jω) e compare com 1/||Δ||.",
                                    "Simule respostas para Δ na borda da estabilidade."
                                  ],
                                  "verification": "Para um M dado, confirme estabilidade robusta e gere gráfico de margens.",
                                  "estimatedTime": "50 minutos",
                                  "materials": "MATLAB Control System Toolbox (norm, sigma), exemplos de plantas com incerteza.",
                                  "tips": "Use grid() no plot para visualizar picos claramente.",
                                  "learningObjective": "Aplicar critério de pequeno ganho para julgar robustez.",
                                  "commonMistakes": "Usar norma L2 em vez de H∞; sempre use sup_ω."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Calcular margens de robustez quantitativas",
                                  "subSteps": [
                                    "Defina margem de ganho robusto: 1 / ||M||_∞.",
                                    "Calcule margem de fase ou estrutura via inverso da peak de M.",
                                    "Quantifique tamanho máximo admissível de Δ: ||Δ||_max = 1 / ||M||_∞.",
                                    "Gere tabela de margens para diferentes frequências.",
                                    "Interprete margens: >3dB bom, <0dB instável."
                                  ],
                                  "verification": "Compute margens para exemplo e explique implicações em relatório curto.",
                                  "estimatedTime": "40 minutos",
                                  "materials": "MATLAB (hinfnorm), calculadora para bounds manuais.",
                                  "tips": "Foque em ω_crossover para margens mais relevantes.",
                                  "learningObjective": "Quantificar e interpretar margens de robustez.",
                                  "commonMistakes": "Ignorar fase; margens são multidimensionais em robustez."
                                }
                              ],
                              "practicalExample": "Considere um laço com planta P(s) = 1/(s+1) e controlador C(s) = 1, com incerteza multiplicativa Δ(s) = 0.2. Reescreva em M-Δ, calcule ||M||_∞ ≈ 1.5, verifique ||Δ||_∞ * 1.5 <1 (robustez ok), margem = 1/1.5 ≈ 0.67 (-3.5dB). Simule em MATLAB para validar.",
                              "finalVerifications": [
                                "Transforma corretamente qualquer laço LIT escalar em forma M-Δ.",
                                "Calcula ||M||_∞ com precisão usando software.",
                                "Aplica critério de pequeno ganho sem erros.",
                                "Computa margens de robustez e interpreta valores.",
                                "Gera plots de singular values para análise visual.",
                                "Explica limitações do método em casos não escalares."
                              ],
                              "assessmentCriteria": [
                                "Precisão na derivação de M(s) (100% match com fórmula padrão).",
                                "Correção no cálculo de normas H∞ (erro <1%).",
                                "Interpretação qualitativa e quantitativa de robustez.",
                                "Qualidade de plots e visualizações (legendas, escalas).",
                                "Capacidade de lidar com exemplos reais com incertezas medidas.",
                                "Relatório claro com conclusões acionáveis."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Análise funcional (normas H∞) e álgebra linear (singular values).",
                                "Física: Dinâmica de sistemas com perturbações reais.",
                                "Computação: Programação numérica em MATLAB para controle.",
                                "Engenharia de Software: Validação de modelos em simulações."
                              ],
                              "realWorldApplication": "Em controle de motores de aviões (Boeing 787), usa-se M-Δ para garantir estabilidade apesar de variações em aerodinâmica; margens >6dB evitam oscilações catastróficas em turbulência."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "76.4.4.1.2.3",
                            "name": "Quantificar robustez via normas de frequência",
                            "description": "Calcular o pico da função de sensibilidade e funções complementares usando diagramas de Bode para prever robustez a incertezas em sistemas LIT escalares.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender Funções de Sensibilidade e Complementares",
                                  "subSteps": [
                                    "Defina a função de loop aberto L(s) e a função de sensibilidade fechada S(s) = 1 / (1 + L(s))",
                                    "Defina a função complementar T(s) = L(s) / (1 + L(s)) e note que S(s) + T(s) = 1",
                                    "Explique o significado de ||S||_∞ (pico máximo de |S(jω)|) como medida de robustez a perturbações",
                                    "Discuta funções adicionais como KS(s) = |L(s)| / |1 + L(s)|^2 para ruído de sensores",
                                    "Relacione normas de frequência com limites de robustez para incertezas aditivas e multiplicativas"
                                  ],
                                  "verification": "Escreva definições e equações em um caderno e explique para um colega ou grave um vídeo de 2 minutos",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Livro de controle avançado (ex: Zhou, Doyle), calculadora simbólica (MATLAB/SymPy), notas de aula"
                                  ],
                                  "tips": "Visualize S(s) como filtro de perturbações e T(s) como filtro de referências",
                                  "learningObjective": "Dominar definições matemáticas e interpretações físicas das funções chave para robustez",
                                  "commonMistakes": [
                                    "Confundir S(s) com T(s)",
                                    "Ignorar dependência em frequência ω",
                                    "Esquecer normalização ||.||_∞"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Construir Diagramas de Bode para L(s), S(s) e T(s)",
                                  "subSteps": [
                                    "Obtenha ou derive a função de transferência de loop aberto L(s) para um sistema LIT escalar",
                                    "Calcule S(jω) e T(jω) numericamente para um range de frequências ω (ex: 10^-2 a 10^3 rad/s)",
                                    "Plote diagramas de Bode de magnitude e fase para |S(jω)|, |T(jω)| e |L(jω)| usando software",
                                    "Identifique regiões de baixa e alta frequência e transições (banda de ganho unitário)",
                                    "Valide plots comparando com propriedades conhecidas (ex: |S|≈1 em baixas ω, |T|≈1 em altas ω)"
                                  ],
                                  "verification": "Gere plots de Bode corretos e compare com um exemplo padrão de um textbook",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Software MATLAB/Python (control toolbox ou scipy), exemplos de sistemas LIT"
                                  ],
                                  "tips": "Use logscale para ω para melhor visualização de picos",
                                  "learningObjective": "Habilitar plotagem precisa de diagramas de Bode para análise de robustez",
                                  "commonMistakes": [
                                    "Escala errada em eixos log",
                                    "Não converter s para jω adequadamente",
                                    "Plots sem fase"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular Picos de Magnitude e Normas de Frequência",
                                  "subSteps": [
                                    "Identifique o pico máximo de |S(jω)| no diagrama de Bode (||S||_∞)",
                                    "Calcule ||T||_∞ e outros picos relevantes como max |KS(jω)|",
                                    "Use interpolação ou funções de otimização para precisão numérica do pico",
                                    "Compare com critérios de robustez: ||S||_∞ < 1/γ para ganho de incerteza γ",
                                    "Documente valores exatos e frequências associadas (ω_peak)"
                                  ],
                                  "verification": "Calcule ||S||_∞ para um sistema dado e verifique se atende a um limite especificado (ex: < 2)",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "MATLAB (bode(), max()), Python (bode_plot, np.max()), papel milimetrado"
                                  ],
                                  "tips": "Picos ocorrem perto da frequência de cruzamento de ganho (ω_c onde |L|=1)",
                                  "learningObjective": "Executar cálculos precisos de normas infinitas a partir de diagramas",
                                  "commonMistakes": [
                                    "Medir amplitude errada em dB (lembre: 20log10(|S|))",
                                    "Confundir picos locais vs global",
                                    "Ignorar wrap-around em fase"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Interpretar Resultados para Previsão de Robustez",
                                  "subSteps": [
                                    "Avalie robustez: pequeno ||S||_∞ indica boa rejeição de perturbações",
                                    "Preveja estabilidade para incertezas Δ: ||T Δ||_∞ <1 garante robustez",
                                    "Simule sistema com incertezas introduzidas e compare respostas",
                                    "Ajuste controlador (ex: ganho) para otimizar picos e re-teste",
                                    "Registre conclusões em relatório: 'Sistema robusto se ||S||_∞ < 1.5'"
                                  ],
                                  "verification": "Simule variação de 20% em parâmetros e confirme estabilidade via step response",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Simulink/Python simulator, exemplos de plantas com incertezas"
                                  ],
                                  "tips": "Use small-gain theorem: robustez se ||FL(L,Δ)||_∞ <1",
                                  "learningObjective": "Aplicar normas para prever e quantificar robustez prática",
                                  "commonMistakes": [
                                    "Interpretar ||S||_∞ grande como robusto",
                                    "Não testar com simulações reais",
                                    "Esquecer trade-offs com performance"
                                  ]
                                }
                              ],
                              "practicalExample": "Para um sistema de controle de posição de um braço robótico com L(s) = 10/(s(s+1)), plote Bode de S(s), encontre ||S||_∞ ≈ 1.8 em ω≈2 rad/s, concluindo robustez moderada a variações de 30% na constante de tempo.",
                              "finalVerifications": [
                                "Calcule ||S||_∞ e ||T||_∞ corretamente para um L(s) dado (±5%)",
                                "Interprete picos: alto ||S||_∞ indica sensibilidade a perturbações",
                                "Gere Bode plots com picos destacados",
                                "Simule robustez com Δ=0.2 e verifique estabilidade",
                                "Explique small-gain theorem em contexto LIT escalar",
                                "Compare com método de margem de ganho/fase"
                              ],
                              "assessmentCriteria": [
                                "Precisão nos cálculos de picos (±0.1 em magnitude)",
                                "Qualidade dos diagramas de Bode (escalas corretas, legendas)",
                                "Correta interpretação de robustez (limites quantitativos)",
                                "Uso apropriado de software para simulações",
                                "Relatório claro com equações, plots e conclusões",
                                "Identificação de trade-offs (robustez vs performance)"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Análise de Fourier e normas L-infinito",
                                "Física: Dinâmica linear e estabilidade de sistemas",
                                "Engenharia de Sinais: Processamento em domínio de frequência",
                                "Estatística: Modelagem de incertezas probabilísticas",
                                "Computação: Programação numérica para controle (MATLAB/Python)"
                              ],
                              "realWorldApplication": "Em controle de processos industriais como reatores químicos, quantificar ||S||_∞ via Bode assegura estabilidade apesar de variações em parâmetros (ex: temperatura, viscosidade), evitando falhas em plantas de produção 24/7."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "76.4.4.1.3",
                        "name": "Princípios Fundamentais de Formatação de Malha Aberta",
                        "description": "Princípios básicos de moldagem da resposta em frequência da malha aberta (loop shaping) para satisfazer especificações simultâneas de desempenho (rastreamento, rejeição de distúrbios) e robustez em sistemas LIT escalares.",
                        "specificSkills": [
                          {
                            "id": "76.4.4.1.3.1",
                            "name": "Definir especificações de formatação de malha",
                            "description": "Estabelecer requisitos em frequência para crossover, margens de fase/ganho, roll-off em altas frequências e shape desejado da malha aberta baseado em desempenho e robustez.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender Princípios Fundamentais da Resposta em Frequência da Malha Aberta",
                                  "subSteps": [
                                    "Estudar diagramas de Bode para malha aberta, identificando magnitude e fase vs. frequência logarítmica.",
                                    "Aprender a interpretar crossover frequency (ω_c) como ponto onde |G(jω)| = 1.",
                                    "Analisar impacto de margens de fase (PM) e ganho (GM) na estabilidade.",
                                    "Explorar roll-off como declive da magnitude em altas frequências.",
                                    "Relacionar shape da curva com trade-offs entre desempenho (rápido tracking) e robustez (margens amplas)."
                                  ],
                                  "verification": "Desenhar manualmente um diagrama de Bode exemplo e rotular ω_c, PM, GM e roll-off corretamente.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Livro de Controle Clássico (ex: Ogata ou Franklin)",
                                    "Tutoriais online sobre diagramas de Bode",
                                    "MATLAB ou Python (Control Systems Toolbox)"
                                  ],
                                  "tips": [
                                    "Visualize fisicamente: ω_c define 'velocidade' do loop, PM/GM definem 'segurança'.",
                                    "Use escalas logarítmicas para intuição."
                                  ],
                                  "learningObjective": "Dominar interpretação da resposta em frequência da malha aberta para basear especificações.",
                                  "commonMistakes": [
                                    "Confundir malha aberta com fechada.",
                                    "Ignorar escala logarítmica, levando a erros de magnitude.",
                                    "Subestimar impacto de ruído em altas frequências."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Determinar Frequência de Crossover Desejada (ω_c)",
                                  "subSteps": [
                                    "Identificar requisitos de desempenho: tempo de subida, largura de banda desejada (ω_c ≈ 2-10x ω_bw).",
                                    "Calcular ω_c inicial baseado em dinâmica da planta (ex: ω_c = 0.2 / τ para sistemas de primeira ordem).",
                                    "Ajustar para restrições atuador/sensor (não exceder 1/10 da freq. de amostragem).",
                                    "Simular impacto: plotar step response para diferentes ω_c.",
                                    "Documentar justificativa com equações e trade-offs (alta ω_c = rápido, mas menos robusto)."
                                  ],
                                  "verification": "Selecionar ω_c para um sistema dado e justificar com simulação mostrando step response adequada.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Simulink/MATLAB para modelagem",
                                    "Planilha com fórmulas de performance (ex: ts ≈ 4/ω_c)",
                                    "Exemplos de plantas reais (motor DC)"
                                  ],
                                  "tips": [
                                    "Comece conservador (baixa ω_c) e itere para cima.",
                                    "Considere ruído: ω_c < 1/10 f_amostragem."
                                  ],
                                  "learningObjective": "Estabelecer ω_c alinhada a specs de velocidade e limitações físicas.",
                                  "commonMistakes": [
                                    "Escolher ω_c muito alta sem checar atuador.",
                                    "Ignorar fase da planta em ω_c.",
                                    "Não relacionar com overshoot/desempenho temporal."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Especificar Margens de Fase e Ganho",
                                  "subSteps": [
                                    "Definir PM alvo: 45-60° para bom amortecimento (overshoot <20%).",
                                    "Calcular GM alvo: 6-12 dB para tolerância a ganho (+/- 50%).",
                                    "Avaliar trade-offs: alta PM = lento, alta GM = conservador.",
                                    "Usar ferramentas para medir: nyquist/gm_pm em MATLAB.",
                                    "Ajustar baseado em incertezas modelo (PM >60° para robustez)."
                                  ],
                                  "verification": "Gerar specs PM=50°, GM=8dB para uma planta e verificar estabilidade via simulação.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Funções MATLAB: margin(), bode()",
                                    "Tabelas de guidelines (PM vs. damping ratio)",
                                    "Exemplos de controladores robustos"
                                  ],
                                  "tips": [
                                    "PM + GM > 90° é bom heuristic.",
                                    "Meça em múltiplas condições (nominal/perturbada)."
                                  ],
                                  "learningObjective": "Definir margens que garantam estabilidade e robustez adequada.",
                                  "commonMistakes": [
                                    "Confundir PM com GM.",
                                    "Especificar sem contexto de incertezas.",
                                    "Alvo PM<30° levando a oscilações."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Definir Roll-off e Comportamento em Altas Frequências",
                                  "subSteps": [
                                    "Especificar roll-off: -20 dB/dec (1 polo) para ruído mínimo, ou -40 dB/dec para rejeição.",
                                    "Garantir |G(jω)| <<1 para ω >> ω_c (ex: -40 dB em 10 ω_c).",
                                    "Considerar ruído/distúrbios: roll-off íngreme reduz impacto.",
                                    "Simular sensibilidade a altas freq. (bode de S/T).",
                                    "Ajustar para filtros anti-aliasing se digital."
                                  ],
                                  "verification": "Plotar Bode com roll-off especificado e confirmar atenuação >40 dB acima de 5 ω_c.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "MATLAB bodeplot()",
                                    "Referências sobre rejeição de ruído",
                                    "Modelos com ruído adicionado"
                                  ],
                                  "tips": [
                                    "Mais polos = mais roll-off, mas fase lag.",
                                    "Teste com ruído white simulado."
                                  ],
                                  "learningObjective": "Garantir rejeição de ruído e distúrbios em altas frequências.",
                                  "commonMistakes": [
                                    "Roll-off fraco permitindo ruído no loop.",
                                    "Ignorar ressonâncias da planta.",
                                    "Especificar sem simular impacto."
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Integrar Especificações para Shape Geral Baseado em Desempenho e Robustez",
                                  "subSteps": [
                                    "Combinar todas specs em template: ω_c, PM/GM, roll-off, shape (plano em baixas freq., declínio suave).",
                                    "Avaliar trade-offs globais: desempenho vs. robustez via μ-analysis ou simulações Monte Carlo.",
                                    "Iterar specs com simulações fechadas para validar.",
                                    "Documentar em formato padrão (tabela ou sketch Bode).",
                                    "Verificar viabilidade com limitações físicas."
                                  ],
                                  "verification": "Criar spec sheet completo e simular loop fechado estável/robusto.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Template de spec sheet",
                                    "Ferramentas robustez (ex: MATLAB Robust Control)",
                                    "Casos de estudo industriais"
                                  ],
                                  "tips": [
                                    "Use sketches manuais antes de simular.",
                                    "Priorize: performance > robustez se specs conflitantes."
                                  ],
                                  "learningObjective": "Sintetizar specs coerentes otimizando desempenho e robustez.",
                                  "commonMistakes": [
                                    "Specs incoerentes (alta ω_c + baixa PM).",
                                    "Não iterar com simulações.",
                                    "Ignorar robustez a variações."
                                  ]
                                }
                              ],
                              "practicalExample": "Para um controlador de velocidade de motor DC (planta G(s)=1/(s+1)), defina: ω_c=5 rad/s (para ts<1s), PM=55° (damping=0.6), GM=10 dB, roll-off=-40 dB/dec acima de 50 rad/s, shape com magnitude plana até ω_c e declínio íngreme para rejeitar ruído do encoder. Simule em MATLAB: sys = tf(1,[1 1]); [Gm,Pm,Wcg,Wcp] = margin(sys*K); ajuste K para specs.",
                              "finalVerifications": [
                                "Especificações documentadas em tabela com valores numéricos e justificativas.",
                                "Diagrama de Bode da malha aberta atinge todas specs (ω_c, PM, GM, roll-off).",
                                "Simulação fechada mostra step response com overshoot<20%, ts< specs.",
                                "Teste robustez: ±20% variação ganho mantém estabilidade.",
                                "Rejeição ruído: alta freq. atenuada >40 dB.",
                                "Trade-offs explicitados (ex: ω_c vs. ruído)."
                              ],
                              "assessmentCriteria": [
                                "Precisão técnica: specs corretas e factíveis (90%+).",
                                "Justificativa baseada em teoria/desempenho (clara e quantitativa).",
                                "Simulações/validações incluídas e interpretadas.",
                                "Trade-offs considerados (desempenho vs. robustez).",
                                "Documentação profissional (tabelas, plots legíveis).",
                                "Criatividade em exemplos reais."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Análise de Fourier/Laplace e funções complexas para Bode.",
                                "Física/Eletrônica: Dinâmica de sistemas e filtros passivos/ativos.",
                                "Programação: Simulação numérica em MATLAB/Python (controle systems).",
                                "Estatística: Análise de robustez e Monte Carlo para incertezas.",
                                "Design de Engenharia: Trade-offs em projetos mecatrônicos."
                              ],
                              "realWorldApplication": "Em aviões comerciais, specs de formatação de malha definem controladores de autopilot para resposta rápida a turbulências (alta ω_c), estabilidade (PM>45°) e rejeição ruído sensor (roll-off íngreme), garantindo segurança e conforto em voo autônomo."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "76.4.4.1.3.2",
                            "name": "Moldar a malha aberta com pré e pós-compensadores",
                            "description": "Projetar compensadores de ganho, integradores e filtros para ajustar a magnitude e fase da malha aberta LIT escalar, visando specs de robustez e desempenho.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Avaliar a malha aberta atual e definir especificações",
                                  "subSteps": [
                                    "Obtenha o diagrama de Bode da função de transferência da planta G(s) em malha aberta.",
                                    "Identifique margens de ganho e fase atuais e compare com specs desejadas (ex: PM > 45°, GM > 6dB).",
                                    "Defina requisitos de magnitude (níveis de ganho em frequências específicas) e fase (correções necessárias).",
                                    "Registre discrepâncias em magnitude e fase para guiar o design dos compensadores.",
                                    "Crie um template de specs com robustez (sensibilidade) e desempenho (banda passante)."
                                  ],
                                  "verification": "Diagrama de Bode anotado com specs destacadas e tabela de discrepâncias completa.",
                                  "estimatedTime": "2 horas",
                                  "materials": "Software MATLAB/Simulink ou Python (Control Systems Library), função de transferência da planta.",
                                  "tips": "Use log-log para magnitude e semi-log para fase para melhor visualização.",
                                  "learningObjective": "Compreender análise de frequência da malha aberta e mapear requisitos de compensação.",
                                  "commonMistakes": "Ignorar efeitos de não-minimum phase ou atrasos na planta."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Projetar pré-compensador para correção inicial de magnitude e fase",
                                  "subSteps": [
                                    "Escolha tipo: ganho K para magnitude ou lead/lag para fase.",
                                    "Calcule polo/zero necessários usando fórmulas: para lead, α = (1-sinφ)/(1+sinφ), onde φ é ângulo máximo.",
                                    "Posicione zero/polo em frequência geométrica média da faixa de correção.",
                                    "Simule Bode do pré-compensador C_pre(s) isolado e verifique contribuição.",
                                    "Ajuste iterativamente para maximizar PM sem exceder GM specs."
                                  ],
                                  "verification": "Bode de C_pre(s) * G(s) mostra melhoria inicial em magnitude/fase alinhada a specs.",
                                  "estimatedTime": "3 horas",
                                  "materials": "MATLAB (sisotool ou rlocus), papel para sketches manuais de Bode.",
                                  "tips": "Comece com compensador simples (ganho ou lead) antes de complexos.",
                                  "learningObjective": "Dominar design de pré-compensadores para moldar contorno de Bode upstream.",
                                  "commonMistakes": "Colocar zero/polo muito altos, causando ruído em altas frequências."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Projetar pós-compensador para refinamento final",
                                  "subSteps": [
                                    "Analise resíduo após pré-compensador: identifique gaps restantes em magnitude/fase.",
                                    "Desenhe pós-compensador C_post(s), tipicamente lag para ganho baixo-freq ou filtro notch.",
                                    "Use método de colocação: resolva para parâmetros via equações ou otimização.",
                                    "Integre C_pre(s) * G(s) * C_post(s) e plote Bode completo.",
                                    "Ajuste para specs de robustez (ex: |S(jω)| < 1 em banda crítica)."
                                  ],
                                  "verification": "Malha aberta combinada atende 80% das specs em Bode plot.",
                                  "estimatedTime": "3 horas",
                                  "materials": "Mesmo software do Step 1, templates de compensadores padrão (lead/lag/PID).",
                                  "tips": "Pós-compensador corrige erros do pré; priorize estabilidade sobre desempenho inicial.",
                                  "learningObjective": "Aplicar pós-compensação para otimizar robustez e desempenho global.",
                                  "commonMistakes": "Sobrecorrigir fase, reduzindo margem de ganho."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Validar, simular e otimizar o design completo",
                                  "subSteps": [
                                    "Simule resposta em malha fechada: step, rampa, rejeição de distúrbio.",
                                    "Verifique sensibilidade e robustez via Monte Carlo ou variações paramétricas.",
                                    "Otimize trade-offs usando ferramentas como loopshaping ou H-infinity basics.",
                                    "Documente design final com equações, plots e justificativas.",
                                    "Teste sensitividade a não-linearidades da planta."
                                  ],
                                  "verification": "Relatório com plots de malha fechada e métricas atendendo todas specs.",
                                  "estimatedTime": "2 horas",
                                  "materials": "Simulink para simulações dinâmicas, relatório template.",
                                  "tips": "Sempre cheque Nyquist para estabilidade absoluta.",
                                  "learningObjective": "Integrar compensadores e validar holisticamente specs de desempenho/robustez.",
                                  "commonMistakes": "Focar só em Bode, ignorando tempo domínio."
                                }
                              ],
                              "practicalExample": "Para um motor DC com G(s) = 1/(s(s+1)), specs: PM=60°, ω_c=10 rad/s. Pré: lead compensador com zero em 2 rad/s, polo em 20 rad/s. Pós: ganho K=5 e lag para steady-state. Resultado: overshoot <10%, settling <0.5s.",
                              "finalVerifications": [
                                "Margem de fase >45° e ganho >6dB no crossover.",
                                "Banda passante atende spec de velocidade.",
                                "Rejeição de distúrbio em baixa freq < -40dB.",
                                "Sensibilidade |S| <1 na banda crítica.",
                                "Simulação step response: overshoot <20%, settling <4/ω_c.",
                                "Nyquist encircles -1 corretamente (0 encirclements)."
                              ],
                              "assessmentCriteria": [
                                "Precisão no design de polo/zero (erro <10% em cálculos).",
                                "Atendimento completo a specs de Bode (todos pontos críticos).",
                                "Qualidade de simulações (plots claros, múltiplos cenários).",
                                "Justificativa técnica robusta (equações + raciocínio).",
                                "Otimização de trade-offs (desempenho vs robustez).",
                                "Documentação profissional e organizada."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Análise complexa e transformadas de Laplace para Bode.",
                                "Eletrônica: Implementação prática de filtros analógicos/digitais.",
                                "Física: Dinâmica de sistemas mecânicos/elétricos em controle.",
                                "Programação: Scripts MATLAB/Python para automação de design."
                              ],
                              "realWorldApplication": "Em plantas industriais como fornos ou robôs, pré-compensadores corrigem dinâmicas da planta (ex: atrasos), pós-compensadores filtram ruído de sensores, garantindo estabilidade em linhas de produção automotiva ou processos químicos."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "76.4.4.1.3.3",
                            "name": "Verificar trade-offs entre desempenho e robustez",
                            "description": "Analisar compromissos inerentes na formatação de malha, como o limite de Bode entre largura de banda e robustez, usando ferramentas gráficas em frequência.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender Conceitos Fundamentais de Desempenho e Robustez",
                                  "subSteps": [
                                    "Definir desempenho em sistemas de controle: tempo de subida, tempo de assentamento, overshoot.",
                                    "Definir robustez: margens de ganho e fase, sensibilidade a perturbações e variações de parâmetros.",
                                    "Explicar o trade-off inerente: alta largura de banda melhora desempenho, mas reduz robustez.",
                                    "Revisar exemplos qualitativos de sistemas reais onde o trade-off é evidente.",
                                    "Mapear métricas de desempenho no domínio do tempo e robustez no domínio da frequência."
                                  ],
                                  "verification": "Escrever um resumo de 200 palavras explicando os conceitos e trade-offs, sem consultar materiais.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Notas de aula sobre controle",
                                    "Livro-texto de Engenharia de Controle (ex: Ogata)",
                                    "Acesso a definições online de margens de estabilidade"
                                  ],
                                  "tips": "Use analogias cotidianas, como acelerar um carro (desempenho) vs. estabilidade em curvas (robustez).",
                                  "learningObjective": "Diferenciar e relacionar métricas de desempenho e robustez em sistemas de controle.",
                                  "commonMistakes": "Confundir largura de banda (desempenho) com margem de fase (robustez); ignorar impacto de não-linearidades."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Construir e Interpretar Diagramas de Bode",
                                  "subSteps": [
                                    "Obter ou derivar a função de transferência de malha aberta do sistema.",
                                    "Calcular e plotar o diagrama de Bode de magnitude e fase usando software.",
                                    "Identificar frequência de cruzamento (crossover frequency), largura de banda e inclinação da magnitude.",
                                    "Medir margens de ganho (distância ao -180° em fase) e fase (distância a 0dB em magnitude).",
                                    "Anotar pontos críticos no gráfico para análise posterior."
                                  ],
                                  "verification": "Plotar manualmente um Bode simples e rotular margens corretamente em papel.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Software MATLAB ou Python (control library)",
                                    "Função de transferência exemplo (ex: G(s) = 1/(s(s+1)))",
                                    "Papel milimetrado para plot manual"
                                  ],
                                  "tips": "Comece com sistemas simples de segunda ordem para ganhar confiança nos plots.",
                                  "learningObjective": "Gerar e interpretar diagramas de Bode para extrair métricas chave.",
                                  "commonMistakes": "Erro na escala logarítmica; confundir magnitude com fase nos cálculos."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Aplicar o Limite de Bode para Analisar Trade-offs",
                                  "subSteps": [
                                    "Estudar o limite de Bode: relação fundamental entre ganho DC, largura de banda e margens.",
                                    "Para um sistema dado, variar parâmetros do controlador (ex: ganho proporcional) e re-plotar Bodes.",
                                    "Quantificar trade-off: calcular como aumento de largura de banda reduz margem de fase.",
                                    "Usar desigualdades de Bode para prever limites teóricos de desempenho vs. robustez.",
                                    "Documentar uma tabela comparativa de cenários (alta performance vs. alta robustez)."
                                  ],
                                  "verification": "Prever corretamente o impacto de dobrar a largura de banda na margem de fase para um exemplo.",
                                  "estimatedTime": "75 minutos",
                                  "materials": [
                                    "Documentação do limite de Bode (artigo ou capítulo)",
                                    "MATLAB script para varredura paramétrica",
                                    "Planilha Excel para tabela de trade-offs"
                                  ],
                                  "tips": "Fixe um requisito (ex: margem > 45°) e otimize desempenho dentro dele.",
                                  "learningObjective": "Aplicar teoremas de Bode para quantificar e prever trade-offs.",
                                  "commonMistakes": "Ignorar atrasos de fase não-mínimos; superestimar margens em sistemas com múltiplos cruzamentos."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Simular e Verificar Trade-offs com Ferramentas Gráficas",
                                  "subSteps": [
                                    "Implementar controlador em simulador (ex: Simulink) com diferentes tunings.",
                                    "Simular respostas no tempo para validar trade-offs observados em frequência.",
                                    "Analisar sensibilidade: introduzir variações de planta (±20%) e checar estabilidade.",
                                    "Gerar relatório gráfico comparando curvas de Bode e respostas temporais.",
                                    "Propor um tuning ótimo balanceando métricas."
                                  ],
                                  "verification": "Demonstrar que tuning de alta performance falha em simulação robusta, mas tuning robusto atende specs.",
                                  "estimatedTime": "90 minutos",
                                  "materials": [
                                    "MATLAB/Simulink",
                                    "Modelo de planta exemplo (ex: motor DC)",
                                    "Templates de relatório"
                                  ],
                                  "tips": "Use loops de Nichols para visualização alternativa de trade-offs.",
                                  "learningObjective": "Integrar análise em frequência e tempo para validar trade-offs práticos.",
                                  "commonMistakes": "Não simular domínio tempo após ajustes em frequência; ignorar saturação de atuadores."
                                }
                              ],
                              "practicalExample": "Em um sistema de controle de velocidade de um motor DC, aumente o ganho do controlador PID para dobrar a largura de banda (de 10 rad/s para 20 rad/s), plotando Bode no MATLAB. Observe a margem de fase cair de 60° para 30°, simulando resposta com variação de 20% na constante de tempo, confirmando perda de robustez com oscilações instáveis.",
                              "finalVerifications": [
                                "Corrretamente plota e interpreta Bode para um sistema dado.",
                                "Quantifica trade-off: largura de banda vs. margem de fase usando limite de Bode.",
                                "Simula impacto de variações paramétricas na estabilidade.",
                                "Propõe tuning balanceado com justificativa gráfica.",
                                "Explica verbalmente o trade-off em termos reais."
                              ],
                              "assessmentCriteria": [
                                "Precisão nas medições de margens (>95% acurácia).",
                                "Profundidade na análise de trade-offs (múltiplos cenários comparados).",
                                "Integração correta de teoria (Bode) com simulação prática.",
                                "Clareza em gráficos e relatórios (legendas, anotações).",
                                "Criatividade em propostas de otimização.",
                                "Identificação de erros comuns evitados."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Análise de funções complexas e logarítmica.",
                                "Física: Dinâmica de sistemas e estabilidade.",
                                "Informática: Programação em MATLAB/Python para análise numérica.",
                                "Economia: Análise custo-benefício em design de engenharia."
                              ],
                              "realWorldApplication": "No controle de drones autônomos, onde alta largura de banda permite manobras ágeis (desempenho), mas margens robustas são cruciais contra ventos variáveis ou falhas de sensores, evitando crashes."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "76.4.4.1.3.4",
                            "name": "Avaliar a malha formatada na forma padrão",
                            "description": "Verificar se a malha aberta formatada satisfaz condições de robustez na forma M-Δ, calculando singular values e margens para incertezas modeladas.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Representar a malha aberta na forma padrão M-Δ",
                                  "subSteps": [
                                    "Identifique os blocos da malha aberta formatada (planta, controlador, pré-filtros).",
                                    "Construa a estrutura de interconexão P e aplique o controlador K para formar M.",
                                    "Defina as entradas e saídas de incertezas para isolar Δ na forma M-Δ.",
                                    "Verifique a linearidade e causalidade da representação.",
                                    "Desenhe o diagrama de blocos da forma padrão."
                                  ],
                                  "verification": "Confirme que a equação z = M w, com w = Δ z, está corretamente representada e balanceada.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Software de simulação (MATLAB/Simulink)",
                                    "Papel e lápis para diagrama",
                                    "Modelo do sistema em formato transfer function"
                                  ],
                                  "tips": "Use a convenção de sinalização padrão (setor de incertezas à direita) para evitar erros de sinal.",
                                  "learningObjective": "Compreender e construir a estrutura M-Δ para análise de robustez.",
                                  "commonMistakes": [
                                    "Inverter entradas/saídas de Δ",
                                    "Esquecer normalização das incertezas",
                                    "Não isolar corretamente as incertezas aditivas/multiplicativas"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Modelar e normalizar as incertezas Δ",
                                  "subSteps": [
                                    "Liste as incertezas do sistema (paramétricas, não-lineares aproximadas como lineares).",
                                    "Converta incertezas em blocos Δ normados (||Δ||∞ ≤ 1).",
                                    "Defina o conjunto de incertezas estruturadas (Δ-bloco diagonal).",
                                    "Valide o modelo de incerteza com dados reais ou simulações nominais.",
                                    "Calcule os pesos de incerteza W_Δ para normalização."
                                  ],
                                  "verification": "Verifique se max singular value de Δ é ≤1 em todas as frequências.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "MATLAB com Robust Control Toolbox",
                                    "Dados de identificação do sistema",
                                    "Folha de cálculo para pesos"
                                  ],
                                  "tips": "Comece com incertezas conservadoras mas realistas; refine iterativamente.",
                                  "learningObjective": "Modelar incertezas de forma normada para análise estruturada.",
                                  "commonMistakes": [
                                    "Usar normas erradas (H2 em vez de H∞)",
                                    "Não normalizar corretamente levando a margens inválidas",
                                    "Ignorar estrutura diagonal de Δ"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular valores singulares e margens de robustez",
                                  "subSteps": [
                                    "Compute σ_max(M(jω)) para uma grade de frequências ω (ex: logspace).",
                                    "Calcule σ_max(Δ(jω)) ou use bound superior para Δ.",
                                    "Determine a margem de robustez μ = 1 / (σ_max(M) * σ_max(Δ)) em cada ω.",
                                    "Plote Bode de σ_max(M(jω)) e compare com 1/σ_max(Δ).",
                                    "Identifique frequências críticas onde μ < 1."
                                  ],
                                  "verification": "Gráficos mostram μ(ω) ≥ 1 para todo ω, ou identifique violações.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "MATLAB script com musyn/sigma",
                                    "Função bode/singular_value",
                                    "Hardware computacional"
                                  ],
                                  "tips": "Use mu-toolbox para Δ estruturado; evite computação numérica excessiva em ω alta.",
                                  "learningObjective": "Aplicar cálculo de valores singulares para quantificar robustez.",
                                  "commonMistakes": [
                                    "Erro numérico em singular values em ω=0/∞",
                                    "Confundir σ_max(M) com ||M||∞",
                                    "Não usar grade logarítmica fina"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Avaliar satisfação das condições de robustez",
                                  "subSteps": [
                                    "Verifique se inf_ω μ(Δ, M(jω)) > 1 para estabilidade robusta.",
                                    "Calcule margens de ganho/fase robustas se aplicável.",
                                    "Analise sensibilidade a variações de parâmetros.",
                                    "Simule closed-loop com Δ extremas para validar.",
                                    "Documente conclusões e recomendações de redesign."
                                  ],
                                  "verification": "Relatório confirma robustez ou lista falhas com evidências.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Simulink para simulações",
                                    "Relatório template",
                                    "Dados de simulação anterior"
                                  ],
                                  "tips": "Sempre valide análise teórica com simulações temporais.",
                                  "learningObjective": "Interpretar resultados e decidir sobre viabilidade da malha.",
                                  "commonMistakes": [
                                    "Ignorar picos locais em μ(ω)",
                                    "Confundir robustez com performance nominal",
                                    "Não testar Δ corner cases"
                                  ]
                                }
                              ],
                              "practicalExample": "Para um controlador PI em um motor DC com incerteza de 20% no ganho da planta: Represente P(s) = K/(s(τs+1)), K=ΔK nominal, Δ multiplicativo. Compute M para LQG-like, verifique μ>1.5 em ω<10 rad/s via MATLAB sigma(M).",
                              "finalVerifications": [
                                "σ_max(M(jω)) * σ_max(Δ(jω)) < 1 para todo ω.",
                                "Margem μ mínima >1 com reserva (ex: >1.2).",
                                "Simulações com Δ extremas mantêm estabilidade.",
                                "Nenhuma violação em frequências de crossover.",
                                "Relatório documenta todos cálculos e plots.",
                                "Consistência com análise nominal."
                              ],
                              "assessmentCriteria": [
                                "Precisão dos cálculos de singular values (erro <1%).",
                                "Correta modelagem e normalização de Δ.",
                                "Interpretação adequada de margens μ.",
                                "Uso apropriado de ferramentas computacionais.",
                                "Identificação de frequências críticas.",
                                "Qualidade dos plots e documentação.",
                                "Validação via simulação."
                              ],
                              "crossCurricularConnections": [
                                "Álgebra Linear: Decomposição SVD para singular values.",
                                "Programação Numérica: Scripts MATLAB para análise H∞.",
                                "Identificação de Sistemas: Modelagem de incertezas reais.",
                                "Otimização: Trade-offs robustez vs performance."
                              ],
                              "realWorldApplication": "Em automação industrial, avaliar robustez de malhas de controle de temperatura em reatores químicos contra variações paramétricas, evitando instabilidades que causam falhas de produção ou segurança."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.3.2",
                    "name": "Modelagem de Incertezas",
                    "description": "Representação de incertezas aditivas, multiplicativas e coprime em plantas LIT para análise de robustez.",
                    "individualConcepts": [
                      {
                        "id": "10.1.3.2.1",
                        "name": "Incertezas Aditivas",
                        "description": "Representação de incertezas que se manifestam como perturbações aditivas na saída da planta nominal LIT, modeladas como Δ(s) onde P(s) = P₀(s) + Δ(s), usadas para capturar erros de modelagem ou ruídos não modelados em análises de robustez.",
                        "specificSkills": [
                          {
                            "id": "10.1.3.2.1.1",
                            "name": "Identificar incertezas aditivas em plantas LIT",
                            "description": "Reconhecer cenários onde incertezas aparecem como termos aditivos na saída da planta, diferenciando de outros tipos e justificando sua aplicação em sistemas com perturbações externas ou imprecisões de alto ganho.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Fundamentos de Plantas LIT e Modelagem de Incertezas",
                                  "subSteps": [
                                    "Defina planta LIT: sistema linear invariante no tempo representado por funções de transferência G(s).",
                                    "Explique a estrutura geral de uma planta: y(s) = G(s)u(s) + d(s), onde d(s) representa distúrbios.",
                                    "Identifique fontes comuns de incertezas: variações paramétricas, não-linearidades e perturbações externas.",
                                    "Desenhe diagramas de bloco para plantas nominais vs. com incertezas.",
                                    "Calcule exemplos simples de saída com ruído aditivo."
                                  ],
                                  "verification": "Explique verbalmente ou por escrito a diferença entre planta nominal e com incerteza aditiva, resolvendo um exemplo básico.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Função de transferência básica G(s)",
                                    "Papel e lápis ou software como MATLAB para diagramas de bloco",
                                    "Referência: Livro de Ogata 'Engenharia de Controle Moderno' capítulo 4"
                                  ],
                                  "tips": "Sempre normalize a planta dividindo por ganho DC para visualizar incertezas claramente.",
                                  "learningObjective": "Compreender a representação matemática de plantas LIT e introduzir incertezas como componentes aditivos na saída.",
                                  "commonMistakes": [
                                    "Confundir invariância no tempo com linearidade",
                                    "Ignorar o impacto de perturbações em malhas de feedback"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Classificar Tipos de Incertezas em Sistemas de Controle",
                                  "subSteps": [
                                    "Liste tipos principais: aditivas (Δ(s) na saída), multiplicativas (Δ(s)G(s)), inversas (1/(G(s)+Δ(s))) e normais.",
                                    "Compare representações: aditiva y = G u + Δ u ou y = G u + Δ.",
                                    "Analise magnitude: incertezas aditivas dominam em baixas frequências para plantas de alto ganho.",
                                    "Use gráficos de Bode para visualizar |Δ(jω)| vs. |G(jω)|.",
                                    "Diferencie de incertezas paramétricas via exemplos numéricos."
                                  ],
                                  "verification": "Classifique 3 exemplos de incertezas fornecidos (aditiva vs. multiplicativa) com justificativa gráfica.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Gráficos de Bode em MATLAB/Simulink",
                                    "Exemplos de funções de transferência: G(s)=1/(s+1), Δ(s)=0.1",
                                    "Planilha para cálculos de magnitude"
                                  ],
                                  "tips": "Lembre-se: aditivas são independentes do sinal de controle u, afetam diretamente a saída.",
                                  "learningObjective": "Distinguir incertezas aditivas de outros tipos baseando-se em estrutura matemática e análise frecuencial.",
                                  "commonMistakes": [
                                    "Assumir todas perturbações como aditivas",
                                    "Confundir aditiva com multiplicativa em plantas de ganho baixo"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Identificar Características Específicas de Incertezas Aditivas",
                                  "subSteps": [
                                    "Reconheça cenários: perturbações externas (ruído sensor/atuador) ou imprecisões modeladas como adição na saída.",
                                    "Verifique critério: incerteza aparece como termo +Δ(s) em y(s), não escalando com |G(s)|.",
                                    "Analise plantas de alto ganho: aditivas são críticas pois |G| grande amplifica erros relativos.",
                                    "Simule em software: adicione Δ(s) = 0.05/(s+0.1) a uma planta e observe resposta.",
                                    "Justifique uso: ideal para robustez em H-infinito ou mu-síntese."
                                  ],
                                  "verification": "Identifique incerteza aditiva em 2 plantas LIT dadas, plotando respostas com/ sem Δ.",
                                  "estimatedTime": "75 minutos",
                                  "materials": [
                                    "MATLAB com toolbox Control System",
                                    "Funções de transferência exemplo: G(s)=10/(s^2 + s +1)",
                                    "Templates de Simulink para simulação"
                                  ],
                                  "tips": "Use norma H-infinito ||Δ||_∞ para quantificar severidade da incerteza aditiva.",
                                  "learningObjective": "Reconhecer padrões onde incertezas aditivas emergem em plantas LIT com perturbações externas.",
                                  "commonMistakes": [
                                    "Negligenciar fase da incerteza em análise frecuencial",
                                    "Confundir com distúrbios rejeitados por integradores"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Diferenciar, Justificar e Aplicar Identificação em Cenários Reais",
                                  "subSteps": [
                                    "Compare com outros tipos: aditiva vs. multiplicativa via razão |Δ|/|G|.",
                                    "Justifique aplicação: perturbações externas (vento em drones) ou alto ganho (amplificadores).",
                                    "Crie modelo robusto: incorpore Δ_add em LFT (Linear Fractional Transformation).",
                                    "Avalie impacto: simule estabilidade com robustcontrol toolbox.",
                                    "Documente relatório: cenário, identificação, justificativa e mitigação."
                                  ],
                                  "verification": "Produza um relatório curto identificando incerteza aditiva em um caso dado, com simulação e justificativa.",
                                  "estimatedTime": "90 minutos",
                                  "materials": [
                                    "MATLAB Robust Control Toolbox",
                                    "Casos de estudo: planta de motor DC com ruído",
                                    "Template de relatório LaTeX ou Word"
                                  ],
                                  "tips": "Sempre valide com simulações de Monte Carlo para incertezas estocásticas aditivas.",
                                  "learningObjective": "Justificar o uso de modelagem de incertezas aditivas em contextos específicos de plantas LIT.",
                                  "commonMistakes": [
                                    "Superestimar robustez sem checar cruzamento de ganho",
                                    "Ignorar incertezas em frequências de interesse"
                                  ]
                                }
                              ],
                              "practicalExample": "Considere uma planta LIT de posicionamento de antena parabólica G(s) = 50 / (s(s+5)), com perturbação externa de vento modelada como Δ(s) = 2 / (s+0.2) adicionada à saída y(t). Identifique como aditiva pois Δ não escala com u, domine em baixas frequências devido ao alto ganho DC de G. Simule em MATLAB: step(tf(50,[1 5 0])) + lsim(Δ, wind_signal, t).",
                              "finalVerifications": [
                                "Classifique corretamente 5 plantas LIT com diferentes incertezas como aditivas ou não.",
                                "Plote gráficos de Bode mostrando |Δ_add| << |G| em DC para alto ganho.",
                                "Justifique verbalmente por que aditivas são adequadas para perturbações externas.",
                                "Simule e compare respostas nominais vs. com Δ_add, medindo erro RMS.",
                                "Crie LFT para uma planta com incerteza aditiva identificada.",
                                "Explique diferença em design de controlador robusto."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação: 90% acerto em classificação de tipos.",
                                "Profundidade de justificativa: ligação clara com perturbações externas/alto ganho.",
                                "Qualidade de simulações: gráficos corretos de Bode e respostas temporais.",
                                "Análise frecuencial: interpretação adequada de magnitudes e fases.",
                                "Relatório estruturado: inclusão de verificações e mitigações.",
                                "Criatividade em exemplos: aplicação a cenários reais viáveis."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Álgebra linear e análise complexa para funções de transferência.",
                                "Física: Dinâmica de sistemas com forças externas perturbadoras.",
                                "Estatística: Modelagem de ruído gaussiano como incertezas aditivas estocásticas.",
                                "Programação: Simulações numéricas em MATLAB/Python para validação.",
                                "Engenharia de Software: Integração em frameworks de controle embarcado."
                              ],
                              "realWorldApplication": "Em controle de drones, incertezas aditivas modelam rajadas de vento na saída de posição, permitindo design de controladores robustos H∞ que mantêm trajetória apesar de perturbações externas, evitando crashes em missões autônomas."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.2.1.2",
                            "name": "Representar matematicamente incertezas aditivas",
                            "description": "Formular o modelo P(s) = P₀(s) + W_a(s) Δ_a(s), onde W_a(s) é o peso de incerteza e ||Δ_a||_∞ ≤ 1, e derivar condições de robustez via desigualdade ||T||_∞ < 1/||W_a||_∞ para estabilidade robusta.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender o conceito de incertezas aditivas em sistemas de controle",
                                  "subSteps": [
                                    "Revise a planta nominal P₀(s) como modelo ideal sem perturbações.",
                                    "Diferencie incertezas aditivas de multiplicativas: aditivas afetam diretamente a saída somando perturbação.",
                                    "Estude exemplos reais, como variações paramétricas em ganhos de amplificadores.",
                                    "Identifique quando usar representação aditiva: para desvios pequenos em plantas lineares.",
                                    "Anote as limitações: não captura variações proporcionais à planta."
                                  ],
                                  "verification": "Explique em suas palavras a diferença entre incertezas aditivas e multiplicativas, com um diagrama simples.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Livro de controle robusto (Skogestad ou Zhou)",
                                    "Notas de aula sobre modelagem de sistemas",
                                    "Papel e caneta para diagramas"
                                  ],
                                  "tips": "Use blocos de diagrama para visualizar P₀(s) + perturbação.",
                                  "learningObjective": "Compreender o papel das incertezas aditivas na modelagem de sistemas incertos.",
                                  "commonMistakes": [
                                    "Confundir com incertezas multiplicativas",
                                    "Ignorar que aditivas são independentes da magnitude da planta"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Formular o modelo matemático P(s) = P₀(s) + W_a(s) Δ_a(s)",
                                  "subSteps": [
                                    "Defina P₀(s) como a planta nominal transfer function.",
                                    "Introduza W_a(s) como função de peso que normaliza a incerteza aditiva.",
                                    "Escolha Δ_a(s) como função unitária de incerteza com ||Δ_a||_∞ ≤ 1.",
                                    "Escreva a equação completa e verifique dimensionalidade.",
                                    "Teste com um exemplo simples: P₀(s) = 1/(s+1), W_a(s) = 0.1."
                                  ],
                                  "verification": "Escreva o modelo para um sistema dado e compute P(s) para Δ_a(s) = 1.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "MATLAB/Simulink para plotar funções",
                                    "Tabela de funções de transferência comuns",
                                    "Calculadora simbólica (SymPy ou Mathematica)"
                                  ],
                                  "tips": "Escolha W_a(s) para englobar o pior caso de incerteza observada.",
                                  "learningObjective": "Construir corretamente a representação normalizada de incertezas aditivas.",
                                  "commonMistakes": [
                                    "Esquecer a normalização ||Δ_a||_∞ ≤ 1",
                                    "Usar norma errada inicialmente"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Compreender a norma infinito e suas propriedades para robustez",
                                  "subSteps": [
                                    "Defina ||G(s)||_∞ = sup_ω |G(jω)| como ganho máximo em frequência.",
                                    "Calcule ||Δ_a||_∞ ≤ 1 como bounding da incerteza.",
                                    "Discuta propriedades: multiplica para sistemas em série, soma para paralelos.",
                                    "Pratique computando ||W_a||_∞ para funções simples.",
                                    "Relacione com singular values para MIMO, mas foque em SISO."
                                  ],
                                  "verification": "Compute ||W_a(s)||_∞ para W_a(s) = 0.2 / (s/10 + 1) usando plot de Bode.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Software de análise de frequência (MATLAB bode)",
                                    "Tabelas de normas H-infinito",
                                    "Exercícios resolvidos de robustez"
                                  ],
                                  "tips": "Use plot de magnitude para encontrar sup_ω facilmente.",
                                  "learningObjective": "Dominar o uso da norma H∞ na quantificação de incertezas.",
                                  "commonMistakes": [
                                    "Confundir com norma 2 (RMS)",
                                    "Ignorar frequência em cálculos manuais"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Derivar e aplicar a condição de robustez ||T||_∞ < 1/||W_a||_∞",
                                  "subSteps": [
                                    "Defina T(s) como função de transferência fechada do loop (complementar sensibilidade).",
                                    "Derive a desigualdade: estabilidade se ||T Δ_a||_∞ < 1 para todo ||Δ_a||_∞ ≤ 1.",
                                    "Simplifique para ||T||_∞ ||W_a||_∞ < 1, pois P(s) = P₀(1 + W_a Δ_a / P₀).",
                                    "Aplique em um controlador simples: projete para satisfazer a condição.",
                                    "Simule violações para ver instabilidade."
                                  ],
                                  "verification": "Para um sistema dado, verifique se ||T||_∞ < 1/||W_a||_∞ e simule estabilidade.",
                                  "estimatedTime": "2.5 horas",
                                  "materials": [
                                    "MATLAB Robust Control Toolbox",
                                    "Templates de simulação H∞",
                                    "Artigos sobre μ-síntese"
                                  ],
                                  "tips": "Itere no design de C(s) para minimizar ||T||_∞.",
                                  "learningObjective": "Derivar e verificar condições de estabilidade robusta para incertezas aditivas.",
                                  "commonMistakes": [
                                    "Usar T como sensibilidade S em vez de complementar",
                                    "Esquecer o bounding ||Δ_a||_∞ ≤ 1"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Validar o modelo com simulações e análise",
                                  "subSteps": [
                                    "Implemente o modelo em Simulink com blocos de incerteza.",
                                    "Varie Δ_a(s) no bounding e cheque estabilidade.",
                                    "Compare com métodos pequenos ganhos.",
                                    "Documente o peso W_a baseado em dados experimentais.",
                                    "Otimize W_a para cobertura mínima."
                                  ],
                                  "verification": "Gere relatório com plots de ||T W_a||_∞ < 1.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Simulink com Uncertainty blocks",
                                    "Dados experimentais simulados",
                                    "Relatório template"
                                  ],
                                  "tips": "Use randunc para gerar Δ_a aleatórios.",
                                  "learningObjective": "Integrar teoria com simulação prática para validação robusta.",
                                  "commonMistakes": [
                                    "W_a muito conservador levando a controladores pobres",
                                    "Não checar DC gain separadamente"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um sistema de controle de posição de um motor DC, a planta nominal é P₀(s) = 1/(s(s+1)). Devido a variações no enrolamento, incerteza aditiva ΔP(s) ≈ 0.05/(s+0.5). Normalize com W_a(s) = 0.05/(s+0.5) para ||Δ_a||_∞ ≤1. Com controlador PI, compute T(s) e verifique ||T||_∞ < 20 para robustez.",
                              "finalVerifications": [
                                "Escreva corretamente P(s) = P₀(s) + W_a(s) Δ_a(s) com definições.",
                                "Compute ||W_a||_∞ e 1/||W_a||_∞ para um exemplo.",
                                "Derive a condição de robustez passo a passo.",
                                "Simule um caso com ||T||_∞ > 1/||W_a||_∞ mostrando instabilidade.",
                                "Explique trade-offs entre W_a conservador e performance.",
                                "Crie diagrama de bloco da estrutura de incerteza aditiva."
                              ],
                              "assessmentCriteria": [
                                "Precisão na formulação do modelo (100% match com equação padrão).",
                                "Correção no cálculo de normas H∞ (erro <5%).",
                                "Derivação lógica da condição de robustez.",
                                "Qualidade da simulação: plots claros e conclusivos.",
                                "Profundidade na escolha e justificativa de W_a(s).",
                                "Capacidade de relacionar com aplicações reais."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Análise funcional e normas em espaços de Hardy.",
                                "Programação: Implementação em MATLAB para análise H∞.",
                                "Física: Modelagem dinâmica de sistemas eletromecânicos.",
                                "Estatística: Bounding probabilístico de incertezas.",
                                "Engenharia de Software: Validação numérica de modelos."
                              ],
                              "realWorldApplication": "Em controle de voo de aeronaves, onde variações em aerodinâmica devido a turbulência são modeladas como incertezas aditivas, garantindo estabilidade robusta via H∞ mesmo com desvios de 10-20% nos coeficientes de sustentação."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.2.1.3",
                            "name": "Aplicar em análise de robustez",
                            "description": "Calcular o limite de robustez para incertezas aditivas usando o teorema de pequeno ganho e interpretar gráficos de Bode ou Nyquist para verificar estabilidade robusta em presença de Δ_a.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Modelar o sistema de controle com incerteza aditiva Δ_a",
                                  "subSteps": [
                                    "Identifique a planta nominal G(s) e o controlador C(s) do sistema monovariável.",
                                    "Defina a incerteza aditiva Δ_a como uma perturbação na saída da planta: G_Δ(s) = G(s) + Δ_a(s).",
                                    "Represente a estrutura em laço fechado, destacando a função de sensibilidade ou complemento para análise.",
                                    "Esboce o diagrama de blocos mostrando a interconexão com Δ_a.",
                                    "Verifique se Δ_a é normada adequadamente (ex: norma H∞)."
                                  ],
                                  "verification": "Confirme que o modelo matemático está corretamente representado em software como MATLAB e que a incerteza é aditiva.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "MATLAB/Simulink, papel e lápis para diagrama de blocos, referência ao teorema de pequeno ganho.",
                                  "tips": "Sempre normalize as incertezas para facilitar comparações com normas de estabilidade.",
                                  "learningObjective": "Compreender e representar matematicamente incertezas aditivas em sistemas de controle.",
                                  "commonMistakes": "Confundir incerteza aditiva com multiplicativa; ignorar a norma da incerteza."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Calcular o limite de robustez usando o teorema de pequeno ganho",
                                  "subSteps": [
                                    "Recupere o teorema: o sistema é estável para ||Δ_a||_∞ < 1 / ||T||_∞, onde T é a função de transferência da interconexão.",
                                    "Identifique a função relevante (geralmente T = L / (1 + L), com L = C G).",
                                    "Calcule a norma H∞ de T usando comandos como 'norm' no MATLAB ou análise analítica.",
                                    "Determine o limite de robustez β = 1 / ||T||_∞.",
                                    "Compare β com a magnitude esperada de Δ_a."
                                  ],
                                  "verification": "O valor de β é calculado corretamente e ||Δ_a||_∞ < β garante estabilidade.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "MATLAB Control System Toolbox, calculadora simbólica (ex: MuPAD), equações do teorema.",
                                  "tips": "Use 'hinfnorm' no MATLAB para normas H∞ precisas em sistemas de alta ordem.",
                                  "learningObjective": "Aplicar o teorema de pequeno ganho para quantificar o limite de robustez.",
                                  "commonMistakes": "Usar a função errada para T (ex: sensibilidade S em vez de complemento); calcular norma L1 em vez de H∞."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Gerar gráficos de Bode e Nyquist para análise gráfica",
                                  "subSteps": [
                                    "Gere o diagrama de Bode de T(jω) ou da função de loop L(jω).",
                                    "Plote o diagrama de Nyquist de T(jω) para visualização no plano complexo.",
                                    "Marque o limite de robustez β no gráfico de magnitude de Bode.",
                                    "Inclua contornos de incerteza Δ_a no Nyquist para inspeção visual.",
                                    "Ajuste escalas para destacar margens de robustez."
                                  ],
                                  "verification": "Gráficos mostram claramente se |T(jω)| < 1 / |Δ_a(jω)| para todos ω.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "MATLAB (bode(), nyquist()), Python com Control library.",
                                  "tips": "Use logscale no Bode para melhor visualização de picos de ressonância.",
                                  "learningObjective": "Produzir e interpretar representações gráficas para robustez.",
                                  "commonMistakes": "Plotar fase em vez de magnitude para limite; ignorar wrap-around no Nyquist."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Interpretar gráficos e verificar estabilidade robusta",
                                  "subSteps": [
                                    "Analise o Bode: verifique se a magnitude de T fica abaixo de β em todas as frequências.",
                                    "No Nyquist: confirme que o contorno de Δ_a não intersecta a imagem de T.",
                                    "Avalie margens: distância ao ponto crítico (-1,0) deve ser maior que ||Δ_a||.",
                                    "Conclua sobre robustez: estável se condições do small gain theorem forem satisfeitas.",
                                    "Documente achados em relatório com capturas de gráficos."
                                  ],
                                  "verification": "Relatório confirma estabilidade robusta ou identifica violações específicas.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Gráficos gerados, régua virtual para medições, template de relatório.",
                                  "tips": "Foque em frequências de crossover para picos potenciais de ||T||.",
                                  "learningObjective": "Interpretar visualmente critérios de robustez e tirar conclusões acionáveis.",
                                  "commonMistakes": "Interpretar interseção errada no Nyquist; negligenciar altas frequências."
                                }
                              ],
                              "practicalExample": "Em um sistema de controle de posição de um motor DC com perturbação aditiva Δ_a modelando variação de carga (||Δ_a||_∞ = 0.2), use C(s) = 10/(s+1), G(s)=1/s^2. Calcule ||T||_∞ ≈ 4.5, β ≈ 0.22 > 0.2, e confirme nos gráficos de Bode que magnitude fica abaixo de 0.22.",
                              "finalVerifications": [
                                "Limite β calculado corretamente via small gain theorem.",
                                "Gráficos de Bode/Nyquist gerados e anotados com β.",
                                "Interpretação confirma estabilidade para dada Δ_a.",
                                "Relatório resume modelo, cálculos e conclusões.",
                                "Teste numérico/simulação valida resultados gráficos.",
                                "Margens de robustez quantificadas (ex: fator de segurança)."
                              ],
                              "assessmentCriteria": [
                                "Precisão no cálculo de ||T||_∞ e β (erro <5%).",
                                "Qualidade e correção dos gráficos (escalas adequadas, anotações).",
                                "Interpretação coerente com teorema (sem contradições).",
                                "Identificação de erros comuns evitados.",
                                "Relatório claro e completo.",
                                "Aplicação correta a exemplo prático."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Análise de funções complexas e normas H∞.",
                                "Programação: Simulações em MATLAB/Python para análise numérica.",
                                "Física: Modelagem de dinâmicas reais com perturbações.",
                                "Estatística: Análise de incertezas e variabilidade paramétrica."
                              ],
                              "realWorldApplication": "Em controle de drones, análise de robustez contra ventos variáveis (Δ_a) garante estabilidade de voo; em automação industrial, verifica controle de temperatura em fornos com variações de carga térmica."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.3.2.2",
                        "name": "Incertezas Multiplicativas",
                        "description": "Modelagem de variações relativas na planta nominal LIT, expressas como P(s) = P₀(s) (1 + Δ_m(s)), ideais para incertezas proporcionais como mudanças de ganho ou variações paramétricas em sistemas de fase crítica.",
                        "specificSkills": [
                          {
                            "id": "10.1.3.2.2.1",
                            "name": "Identificar incertezas multiplicativas",
                            "description": "Detectar incertezas que afetam proporcionalmente a dinâmica da planta, como flutuações em parâmetros físicos, e contrastar com incertezas aditivas em termos de impacto em baixas e altas frequências.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Fundamentos de Incertezas em Sistemas de Controle",
                                  "subSteps": [
                                    "Estude a definição de incertezas em modelagem de plantas dinâmicas.",
                                    "Identifique fontes comuns de incertezas, como variações em parâmetros físicos (ex.: massa, rigidez).",
                                    "Revise representações matemáticas de plantas nominais G(s).",
                                    "Explore exemplos iniciais de perturbações aditivas e multiplicativas.",
                                    "Anote diferenças qualitativas entre tipos de incertezas."
                                  ],
                                  "verification": "Resuma em um parágrafo as fontes principais de incertezas e forneça um diagrama simples de uma planta com incerteza.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Livro de Controle Avançado (capítulo de modelagem)",
                                    "Slides de aula sobre incertezas",
                                    "Papel e caneta para diagramas"
                                  ],
                                  "tips": "Comece com exemplos familiares como sistemas massa-mola para fixar conceitos.",
                                  "learningObjective": "Compreender as origens e representações básicas de incertezas em sistemas dinâmicos.",
                                  "commonMistakes": [
                                    "Confundir incertezas com ruídos de medição",
                                    "Ignorar o contexto dinâmico da planta"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Diferenciar Incertezas Aditivas de Multiplicativas",
                                  "subSteps": [
                                    "Defina incerteza aditiva: ΔG(s) = G(s) + W(s), impacto absoluto.",
                                    "Defina incerteza multiplicativa: ΔG(s) = G(s)(1 + W(s)), impacto proporcional.",
                                    "Compare graficamente em diagramas de Bode: aditiva afeta mais baixas frequências, multiplicativa altas.",
                                    "Simule em software (ex.: MATLAB) um exemplo simples para ambos os tipos.",
                                    "Crie uma tabela comparativa de características."
                                  ],
                                  "verification": "Gere gráficos de Bode para G nominal, aditiva e multiplicativa, e explique diferenças observadas.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "MATLAB ou Octave",
                                    "Templates de scripts para robustez",
                                    "Tabela comparativa em Excel"
                                  ],
                                  "tips": "Use funções de peso W(s) realistas, como W(s) = 0.2 para multiplicativa.",
                                  "learningObjective": "Distinguir matematicamente e graficamente incertezas aditivas de multiplicativas.",
                                  "commonMistakes": [
                                    "Invertar os impactos frecuenciais",
                                    "Usar pesos inadequados nos exemplos"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Detectar Incertezas Multiplicativas em Modelos de Plantas",
                                  "subSteps": [
                                    "Analise parâmetros físicos da planta (ganho, constantes de tempo) sujeitos a flutuações relativas.",
                                    "Identifique cenários onde variação é proporcional: ex. desgaste em atuadores afetando ganho.",
                                    "Modele Δm(s) = m(s)(1 + Δ(s)) para planta m(s).",
                                    "Aplique testes: se incerteza escala com magnitude da planta, é multiplicativa.",
                                    "Pratique em 2-3 plantas exemplo (motor DC, tanque de nível)."
                                  ],
                                  "verification": "Para uma planta dada, classifique 3 incertezas potenciais como aditivas ou multiplicativas com justificativa.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Exemplos de plantas em PDF",
                                    "Simulink ou Python Control Systems Library",
                                    "Folha de exercícios"
                                  ],
                                  "tips": "Pergunte: 'A incerteza muda o ganho relativo ou adiciona offset?'",
                                  "learningObjective": "Reconhecer padrões de incertezas multiplicativas em descrições de sistemas reais.",
                                  "commonMistakes": [
                                    "Classificar variações absolutas como multiplicativas",
                                    "Ignorar dependência de frequência"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Contrastar Impactos em Baixas e Altas Frequências",
                                  "subSteps": [
                                    "Estude respostas em frequência: aditivas dominam em baixas ω (estabilidade DC), multiplicativas em altas ω (fase/ganho).",
                                    "Gere μ-plots ou loops de Nyquist para visualização.",
                                    "Simule estabilidade com H-infinito para ambos tipos.",
                                    "Discuta implicações para síntese de controladores robustos.",
                                    "Resolva um problema: dado G(s), identifique faixa crítica de frequências por tipo."
                                  ],
                                  "verification": "Produza um relatório com gráficos contrastando impactos e recomendações de controlador.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "MATLAB Robust Control Toolbox",
                                    "Artigos sobre μ-síntese",
                                    "Templates de Nyquist"
                                  ],
                                  "tips": "Foque em crossover frequency para priorizar tipos de incerteza.",
                                  "learningObjective": "Analisar e contrastar efeitos dinâmicos de incertezas em domínios frecuenciais.",
                                  "commonMistakes": [
                                    "Generalizar impactos sem análise frecuencial",
                                    "Confundir magnitude com fase"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um motor DC, flutuações no torque constante Kt (devido a temperatura) causam incerteza multiplicativa no ganho da planta G(s) = Kt/(Js+ b), afetando proporcionalmente altas frequências e requerendo controladores com roll-off adequado.",
                              "finalVerifications": [
                                "Classifica corretamente incertezas em uma planta exemplo como aditiva ou multiplicativa.",
                                "Explica impacto frecuencial com gráficos de Bode precisos.",
                                "Identifica fontes reais de incertezas multiplicativas em sistemas industriais.",
                                "Propõe modelagem correta ΔG(s) = G(s)(1 + W(s)) para um caso dado.",
                                "Contrasta estabilidade sob ambos tipos em simulação."
                              ],
                              "assessmentCriteria": [
                                "Precisão na diferenciação conceitual (aditiva vs multiplicativa): 25%",
                                "Qualidade de detecção em exemplos práticos: 25%",
                                "Análise frecuencial com gráficos corretos: 20%",
                                "Modelagem matemática rigorosa: 15%",
                                "Clareza em contrastes e implicações: 15%"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Análise de funções complexas e multiplicadores.",
                                "Física: Variações paramétricas em dinâmica de sistemas.",
                                "Estatística: Modelagem de variabilidade proporcional.",
                                "Engenharia de Processos: Incertezas em plantas químicas."
                              ],
                              "realWorldApplication": "Em controle de robôs industriais, identificar incertezas multiplicativas em ganhos de atuadores devido a desgaste permite projetar controladores robustos que mantêm precisão em altas velocidades, evitando oscilações em frequências críticas."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.2.2.2",
                            "name": "Formular modelo matemático de incertezas multiplicativas",
                            "description": "Escrever P(s) = P₀(s) (1 + W_m(s) Δ_m(s)) com ||Δ_m||_∞ ≤ 1, e derivar a função de transferência complementar T(s) = C(s)P(s)/(1 + C(s)P(s)) para análise de robustez via ||W_m T||_∞ < 1.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Fundamentos de Incertezas em Sistemas de Controle",
                                  "subSteps": [
                                    "Estude a diferença entre incertezas aditivas e multiplicativas em plantas nominais P₀(s).",
                                    "Revise a norma infinita ||Δ||_∞ ≤ 1 para incertezas normalizadas.",
                                    "Analise exemplos gráficos de incertezas multiplicativas em diagramas de Bode.",
                                    "Identifique quando usar W_m(s) como peso para modelar incertezas de alta frequência.",
                                    "Pratique notação: P(s) = P₀(s) (1 + W_m(s) Δ_m(s))."
                                  ],
                                  "verification": "Explique verbalmente ou por escrito por que incertezas multiplicativas são adequadas para variações percentuais na planta.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Livro 'Multivariable Feedback Control' de Skogestad (Cap. 9)",
                                    "Notas de aula sobre robustez",
                                    "Software MATLAB para plotar Bode"
                                  ],
                                  "tips": "Comece com exemplos simples como um integrador para visualizar Δ_m(s).",
                                  "learningObjective": "Compreender o papel das incertezas multiplicativas na modelagem de plantas incertas.",
                                  "commonMistakes": [
                                    "Confundir com incertezas aditivas",
                                    "Ignorar a normalização ||Δ_m||_∞ ≤ 1"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Formular o Modelo Matemático da Planta com Incerteza Multiplicativa",
                                  "subSteps": [
                                    "Defina a planta nominal P₀(s) para um sistema específico (ex: motor DC).",
                                    "Selecione ou derive o peso W_m(s) baseado em dados de incerteza (ex: ±20% em ganhos altos).",
                                    "Escreva explicitamente P(s) = P₀(s) (1 + W_m(s) Δ_m(s)) com Δ_m(s) unitário.",
                                    "Verifique dimensionalidade e estabilidade da perturbação.",
                                    "Plote |W_m(jω)| sobre a planta nominal para validar cobertura de incerteza."
                                  ],
                                  "verification": "Gere o modelo P(s) em MATLAB e confirme que para Δ_m=0, P(s)=P₀(s).",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "MATLAB/Simulink",
                                    "Dados experimentais simulados de planta",
                                    "Folha de cálculo para ajuste de W_m(s)"
                                  ],
                                  "tips": "Use estrutura coprime para estimar W_m se dados reais estiverem disponíveis.",
                                  "learningObjective": "Construir corretamente o modelo P(s) incorporando incertezas multiplicativas.",
                                  "commonMistakes": [
                                    "Escolha errada de W_m(s) que não engloba todas as incertezas",
                                    "Esquecer o fator (1 + ... )"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Derivar a Função de Transferência Complementar T(s)",
                                  "subSteps": [
                                    "Lembre a estrutura de malha fechada: T(s) = C(s)P(s) / (1 + C(s)P(s)).",
                                    "Substitua P(s) na fórmula de T(s), mantendo Δ_m(s) simbólico.",
                                    "Simplifique para mostrar dependência em incertezas: T(s) ≈ T₀(s) + termos perturbados.",
                                    "Implemente em MATLAB usando tf e feedback para computar T(s).",
                                    "Plote diagrama de Bode de T(s) para diferentes Δ_m."
                                  ],
                                  "verification": "Derive T(s) analiticamente e compare com simulação numérica (erro <1%).",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "MATLAB Control System Toolbox",
                                    "Papel e lápis para derivação simbólica",
                                    "Exemplos resolvidos de robustez"
                                  ],
                                  "tips": "Use aproximações de pequena perturbação para insight inicial.",
                                  "learningObjective": "Derivar T(s) corretamente para análise de robustez.",
                                  "commonMistakes": [
                                    "Erro na fórmula de malha fechada",
                                    "Substituir P(s) incorretamente em T(s)"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar Critério de Robustez via Norma Infinita",
                                  "subSteps": [
                                    "Compute ||W_m T||_∞ usando hinfnorm no MATLAB.",
                                    "Verifique se ||W_m T||_∞ < 1 garante robustez para todo ||Δ_m||_∞ ≤ 1.",
                                    "Ajuste C(s) iterativamente até satisfazer a condição.",
                                    "Analise singular values de W_m T para frequências críticas.",
                                    "Documente o valor máximo de ||W_m T||_∞ e margens de robustez."
                                  ],
                                  "verification": "Simule com Δ_m no limite e confirme estabilidade/ desempenho.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "MATLAB Robust Control Toolbox",
                                    "Templates de script para hinfnorm",
                                    "Gráficos de μ-analysis"
                                  ],
                                  "tips": "Monitore picos em baixas frequências onde incertezas são altas.",
                                  "learningObjective": "Avaliar robustez usando ||W_m T||_∞ < 1.",
                                  "commonMistakes": [
                                    "Confundir com ||T||_∞ sem peso",
                                    "Ignorar fase em normas infinitas"
                                  ]
                                }
                              ],
                              "practicalExample": "Para um sistema de controle de posição de um braço robótico com P₀(s) = 1/(s(s+1)), incerteza de ±30% em ganhos de alta frequência modelada por W_m(s) = 0.3 s / (s + 0.1). Formule P(s), derive T(s) com C(s) = PID, e verifique robustez com ||W_m T||_∞ = 0.85 < 1 em MATLAB.",
                              "finalVerifications": [
                                "Modelo P(s) reproduz P₀(s) quando Δ_m=0.",
                                "T(s) derivada matches simulação em Bode plot.",
                                "||W_m T||_∞ < 1 computado corretamente.",
                                "Simulação com Δ_m=1 na direção pior-caso mantém estabilidade.",
                                "Relatório explica escolha de W_m(s)."
                              ],
                              "assessmentCriteria": [
                                "Precisão na formulação de P(s) (30%)",
                                "Correção na derivação de T(s) (25%)",
                                "Cálculo exato de ||W_m T||_∞ (20%)",
                                "Interpretação de resultados de robustez (15%)",
                                "Clareza em plots e documentação (10%)"
                              ],
                              "crossCurricularConnections": [
                                "Probabilidade e Estatística: Modelagem de Δ_m via distribuições uniformes.",
                                "Otimização: Minimização de ||W_m T||_∞ via H-infinito synthesis.",
                                "Física: Dinâmica de sistemas com atrito variável (incertezas reais).",
                                "Programação: Implementação numérica em Python (control library)."
                              ],
                              "realWorldApplication": "Em controle de aviões (incertezas aerodinâmicas), automóveis autônomos (variações em pneus/massa) e processos industriais (reatores químicos com variações paramétricas), garantindo estabilidade apesar de imprecisões de modelo."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.2.2.3",
                            "name": "Avaliar robustez com incertezas multiplicativas",
                            "description": "Usar singular values ou normas H∞ para quantificar o grau de robustez, plotar curvas de peso W_m e interpretar desvios permitidos em diagramas de Nyquist para garantia de estabilidade.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Modelar Incertezas Multiplicativas e Definir Pesos Wm",
                                  "subSteps": [
                                    "Revise a estrutura de incerteza multiplicativa: Δ_m(s) = W_m(s) * Δ_tilde(s), onde ||Δ_tilde||_∞ ≤ 1",
                                    "Analise o sistema nominal G(s) e identifique fontes de incerteza (ex.: variação de ganho ou fase)",
                                    "Selecione W_m(s) com magnitude que envolva a incerteza esperada em todo o espectro de frequências",
                                    "Verifique a modelagem plotando |Δ_m(jω)| e |W_m(jω)| em gráfico de Bode",
                                    "Ajuste W_m para ser o menor possível que ainda garanta cobertura conservadora"
                                  ],
                                  "verification": "Explique em palavras próprias o papel de W_m e demonstre com um plot de Bode que ela upper-bound a incerteza",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Software MATLAB ou Python (Control Systems Toolbox)",
                                    "Referência: Skogestad 'Multivariable Feedback Control'",
                                    "Plantas nominais e perturbadas de exemplo"
                                  ],
                                  "tips": "Use dados reais de variação de parâmetros para calibrar W_m, evitando superestimações desnecessárias",
                                  "learningObjective": "Dominar a modelagem quantitativa de incertezas multiplicativas via pesos de frequência",
                                  "commonMistakes": [
                                    "Confundir incertezas multiplicativas com aditivas",
                                    "Ignorar comportamento em baixas e altas frequências ao definir W_m",
                                    "Escolher W_m constante quando variação é dinâmica"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Calcular Medidas de Robustez: Valores Singulares e Norma H∞",
                                  "subSteps": [
                                    "Forme a matriz de sistema generalizado M(s) = [Fl(P,K)] para o loop com incerteza",
                                    "Compute os valores singulares de M(jω): σ_bar(M(jω)) usando svd() no MATLAB",
                                    "Calcule a norma H∞: ||M||_∞ = sup_ω σ_bar(M(jω))",
                                    "Verifique a condição de robustez: ||M||_∞ < 1 / ||W_m||_∞ ou equivalentemente μ < 1",
                                    "Compare com limite de robustez: plot σ_bar(M) vs 1/|W_m|"
                                  ],
                                  "verification": "Produza plots de valores singulares e confirme se ||M||_∞ < 1 implica robustez",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "MATLAB com Robust Control Toolbox",
                                    "Função sigma() para singular values",
                                    "Exemplos de sistemas LTI"
                                  ],
                                  "tips": "Use grid() nos plots para visualizar cruzamentos claros; normalize frequências para rad/s",
                                  "learningObjective": "Aplicar ferramentas numéricas para quantificar robustez via normas estruturadas",
                                  "commonMistakes": [
                                    "Esquecer de linearizar o sistema fechado",
                                    "Confundir σ_bar com norma L2",
                                    "Não considerar o pior caso de Δ_tilde"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Plotar Curvas de Peso Wm e Análise de Frequência",
                                  "subSteps": [
                                    "Gere gráfico de Bode de |W_m(jω)| destacando regiões críticas (ganho, fase)",
                                    "Sobreponha |T(jω)| ou |S(jω)| relevantes para contexto de robustez",
                                    "Identifique frequências onde incerteza é máxima e impacto em estabilidade",
                                    "Calcule margens de robustez em magnitude e fase baseadas em desvios permitidos",
                                    "Documente desvios: δ_max = 1 / |W_m(jω)| para garantia de estabilidade"
                                  ],
                                  "verification": "Crie e interprete um plot de Bode de W_m com anotações de desvios permitidos",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "MATLAB bode() e margin() functions",
                                    "Templates de scripts para análise robusta"
                                  ],
                                  "tips": "Use logscale para frequências e magnitude; adicione legendas claras para cada curva",
                                  "learningObjective": "Visualizar e interpretar pesos de incerteza em domínio de frequência",
                                  "commonMistakes": [
                                    "Plotar apenas magnitude sem fase",
                                    "Ignorar roll-off de W_m em altas frequências",
                                    "Confundir W_m com sensitivity W_s"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Interpretar Diagramas de Nyquist com Desvios Permitidos",
                                  "subSteps": [
                                    "Plote o diagrama de Nyquist do loop aberto L(jω) nominal",
                                    "Desenhe o disco de M-circle centrado em -1 com raio baseado em |W_m(jω)|",
                                    "Verifique se o Nyquist nominal permanece dentro dos discos de estabilidade permitidos",
                                    "Simule perturbações multiplicativas e confirme não encirclement do ponto crítico",
                                    "Conclua sobre garantia de estabilidade: distância ao -1 > raio máximo de desvio"
                                  ],
                                  "verification": "Anote no diagrama regiões seguras e demonstre que perturbações não violam estabilidade",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "MATLAB nyquist() e nichols()",
                                    "Ferramenta para M-circles (rcircle toolbox)"
                                  ],
                                  "tips": "Comece com ω baixa a alta; use zoom em torno de -1 para precisão",
                                  "learningObjective": "Usar Nyquist para validar robustez gráfica contra incertezas",
                                  "commonMistakes": [
                                    "Esquecer de plotar contorno de incerteza",
                                    "Confundir Nyquist de L com de T",
                                    "Não considerar direção das perturbações"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Sintetizar Resultados e Verificar Garantia de Estabilidade",
                                  "subSteps": [
                                    "Compile todos os plots: singular values, Bode de W_m, Nyquist com desvios",
                                    "Calcule índice de robustez: min(1/|W_m σ_bar(M)|)",
                                    "Teste com simulações de Monte Carlo de Δ_tilde aleatórias",
                                    "Documente conclusões: robusto se todas métricas <1",
                                    "Sugira melhorias no controlador se robustez marginal"
                                  ],
                                  "verification": "Gere relatório com plots e declaração final de robustez (robusto/não robusto)",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Script integrado MATLAB",
                                    "Templates de relatório LaTeX ou Markdown"
                                  ],
                                  "tips": "Automatize com loop for frequências; valide com casos conhecidos",
                                  "learningObjective": "Integrar análises para decisão final sobre robustez do sistema",
                                  "commonMistakes": [
                                    "Sobrepor confiança em uma métrica só",
                                    "Ignorar validação numérica além de analítica",
                                    "Não reportar trade-offs performance vs robustez"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um controlador PID para um motor DC com constante de tempo variando 20-40% (incerteza multiplicativa), defina W_m(s) = 0.3 * (s/10 +1)/(s/100 +1), calcule ||M||_∞ ≈0.85 <1, plote singular values abaixo de 1/|W_m|, e confirme no Nyquist que perturbações não encirculam -1, garantindo estabilidade em toda faixa operacional.",
                              "finalVerifications": [
                                "Calcula corretamente singular values e norma H∞ de M(s)",
                                "Plota e interpreta curvas de W_m em Bode com desvios δ_max",
                                "Valida estabilidade no diagrama de Nyquist com discos de incerteza",
                                "Conclui robustez corretamente baseado em ||M||_∞ < 1/||W_m||_∞",
                                "Simula perturbações e confirma ausência de instabilidade",
                                "Documenta trade-offs entre performance e robustez"
                              ],
                              "assessmentCriteria": [
                                "Precisão numérica nos cálculos de normas e singular values (erro <1%)",
                                "Qualidade e legibilidade dos plots (legendas, escalas, anotações)",
                                "Correção na interpretação de desvios e condições de robustez",
                                "Profundidade na modelagem de W_m baseada em incertezas reais",
                                "Capacidade de integrar análises gráficas e numéricas",
                                "Clareza no relatório final com conclusões acionáveis"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Álgebra linear (SVD, normas induzidas) e análise complexa",
                                "Programação: MATLAB/Python para análise de sistemas lineares e visualização",
                                "Física: Dinâmica de sistemas reais com variações paramétricas",
                                "Estatística: Modelagem probabilística de incertezas via Monte Carlo",
                                "Engenharia de Software: Scripts reutilizáveis para análise robusta"
                              ],
                              "realWorldApplication": "Em controle de aeronaves, avaliar se um controlador de atitude permanece estável apesar de incertezas multiplicativas em coeficientes aerodinâmicos devido a Mach variável ou danos estruturais, evitando falhas catastróficas."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.3.2.3",
                        "name": "Incertezas Coprime",
                        "description": "Representação geral de incertezas em plantas LIT via fatorização coprime, P(s) = N_m(s) M_m⁻¹(s), onde Δ = [Δ₁ Δ₂] pertence a conjuntos coprime estáveis, abrangendo aditivas e multiplicativas para análise de robustez estrutural.",
                        "specificSkills": [
                          {
                            "id": "10.1.3.2.3.1",
                            "name": "Entender fatorização coprime",
                            "description": "Realizar fatorização coprime direita ou esquerda de plantas LIT nominais, identificando fatores N_m e M_m bezoutianos estáveis, e explicar sua unicidade módulo unidades biproprias.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Fundamentos de Sistemas LIT e Anéis de Funções Estáveis",
                                  "subSteps": [
                                    "Defina sistemas LIT nominais e suas representações em fração de transferência.",
                                    "Explique o anel RH_infty de funções estáveis racionais próprias.",
                                    "Discuta coprimidade em anéis euclidianos e sua relevância para controle.",
                                    "Identifique exemplos simples de plantas LIT nominais.",
                                    "Revise identidades Bezoutianas básicas em polinômios."
                                  ],
                                  "verification": "Resuma em um parágrafo os conceitos chave e forneça um exemplo de fração de transferência LIT estável.",
                                  "estimatedTime": "2 horas",
                                  "materials": "Livro 'Feedback Control Theory' de Doyle; MATLAB para plotar respostas de sistemas LIT.",
                                  "tips": "Use diagramas de blocos para visualizar plantas LIT antes de mergulhar em fatorizações.",
                                  "learningObjective": "Compreender o contexto algébrico para fatorações coprimes em sistemas de controle.",
                                  "commonMistakes": "Confundir estabilidade com causalidade; assumir que toda fração é coprime sem verificar."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Aprender Fatoração Coprime Direita e Esquerda",
                                  "subSteps": [
                                    "Defina fatoração coprime direita: G = N_m M_m^{-1} com N_m, M_m estáveis e coprimes.",
                                    "Defina fatoração coprime esquerda: G = M_m^{-1} N_m com propriedades similares.",
                                    "Aprenda o algoritmo de normalização para obter fatores biproprios unitários.",
                                    "Pratique fatorando uma planta nominal simples como G(s) = 1/(s+1).",
                                    "Compare fatorizações direita e esquerda para o mesmo sistema."
                                  ],
                                  "verification": "Fatore uma planta LIT nominal dada e verifique se M_m é unimodular (invertível em RH_infty).",
                                  "estimatedTime": "3 horas",
                                  "materials": "Notas de aula sobre RH_infty; software Symbolic Math Toolbox no MATLAB.",
                                  "tips": "Sempre normalize os fatores para que det(M_m(jω)) tenha fase zero em ω=∞.",
                                  "learningObjective": "Realizar explicitamente fatorações coprimes direita e esquerda para plantas LIT.",
                                  "commonMistakes": "Escolher fatores não-estáveis; ignorar a normalização bipropria."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Identificar Fatores Bezoutianos Estáveis N_m e M_m",
                                  "subSteps": [
                                    "Explique a identidade Bezout: existência de X, Y estáveis tal que X N_m + Y M_m = I.",
                                    "Aprenda a resolver para X_m, Y_m usando equações de Sylvester ou métodos de controle.",
                                    "Verifique estabilidade dos fatores Bezoutianos para uma fatoração coprime.",
                                    "Discuta como fatores bezoutianos garantem robustez em malhas de controle.",
                                    "Implemente numericamente em MATLAB para um exemplo."
                                  ],
                                  "verification": "Encontre X_m e Y_m para uma fatoração coprime e confirme X_m N_m + Y_m M_m = I.",
                                  "estimatedTime": "3 horas",
                                  "materials": "MATLAB Control System Toolbox; paper 'Coprime Factorization' de Vidyasagar.",
                                  "tips": "Use o comando coprime() no MATLAB para validar seus cálculos manuais.",
                                  "learningObjective": "Identificar e computar fatores bezoutianos estáveis para validar coprimidade.",
                                  "commonMistakes": "Assumir coprimidade sem Bezout explícito; soluções instáveis para X,Y."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Explicar Unicidade Módulo Unidades Biproprias",
                                  "subSteps": [
                                    "Defina unidades biproprias: pares (U,V) em RH_infty com U V^{-1} unimodular.",
                                    "Prove que fatorizações coprimes são únicas módulo unidades biproprias.",
                                    "Mostre que [N_m', M_m'] = [N_m, M_m] [U; V] para unidades biproprias.",
                                    "Aplique a uma planta nominal e compare múltiplas fatorações.",
                                    "Discuta implicações para síntese de controladores robustos."
                                  ],
                                  "verification": "Gere duas fatorações diferentes para a mesma G e mostre equivalência módulo biproprias.",
                                  "estimatedTime": "2 horas",
                                  "materials": "Artigo seminal de Youla-Kucera; quadro branco para provas algébricas.",
                                  "tips": "Lembre-se: unicidade é até multiplicação por unimodulares biproprios, não absoluta.",
                                  "learningObjective": "Compreender e demonstrar a unicidade das fatorações coprimes.",
                                  "commonMistakes": "Confundir unicidade com normalização; ignorar o módulo biproprio."
                                }
                              ],
                              "practicalExample": "Para a planta nominal G(s) = 1/(s^2 + 2s + 2), realize fatoração coprime direita: escolha M_m(s) = (s^2 + 2s + 2)/(s^2 + 2s + 3), N_m(s) = 1/(s^2 + 2s + 3), normalize bipropriamente, encontre X_m, Y_m bezoutianos e verifique unicidade.",
                              "finalVerifications": [
                                "Fatore corretamente uma planta LIT nominal direita e esquerda.",
                                "Identifique fatores N_m, M_m bezoutianos estáveis para pelo menos dois exemplos.",
                                "Explique verbalmente a unicidade módulo unidades biproprias.",
                                "Valide coprimidade via identidade Bezout em MATLAB.",
                                "Compare fatorizações e discuta robustez em incertezas coprimes.",
                                "Resolva um problema de fatoração sem erros comuns."
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição e execução de fatorações coprimes (30%).",
                                "Correta identificação e verificação de fatores bezoutianos (25%).",
                                "Explicação clara da unicidade módulo biproprias (20%).",
                                "Uso correto de ferramentas computacionais (15%).",
                                "Profundidade em exemplos práticos e conexões com controle (10%)."
                              ],
                              "crossCurricularConnections": [
                                "Álgebra Linear: Extensões de identidades Bezout a operadores.",
                                "Teoria de Controle Básica: Relação com parametrização de Youla.",
                                "Análise Complexa: Propriedades de RH_infty no semiplano direito.",
                                "Programação Numérica: Implementação em MATLAB/Simulink."
                              ],
                              "realWorldApplication": "Em controle robusto de plantas com incertezas modeladas como perturbações coprimes (ex: motores industriais com variações paramétricas), permite síntese de controladores Q-parametrizados estáveis para todo o conjunto de plantas perturbadas, essencial em automação aeroespacial e robótica."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.2.3.2",
                            "name": "Modelar incertezas coprime",
                            "description": "Expressar plantas perturbadas como [P Δ] = [N_m M_m] [H_Δ 0; 0 I], com H_Δ estável e ||H_Δ||_∞ < γ, e conectar à parametrização de Youla para todos os controladores estabilizantes.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Fundamentos de Fatorização Coprime",
                                  "subSteps": [
                                    "Estude a definição de fatores coprimes de Bezout para sistemas lineares: pares (N_m, M_m) tais que existam X, Y com X N_m - Y M_m = I.",
                                    "Revise a fatorização coprime direita (RCP) e esquerda (LCP) para plantas nominais P = N_m M_m^{-1}.",
                                    "Pratique computando fatores coprimes para um exemplo simples de planta de primeira ordem usando MATLAB ou Python (Control Systems Toolbox).",
                                    "Entenda a unicidade da fatorização coprime normalizada.",
                                    "Derive a identidade de Bezout para um caso didático."
                                  ],
                                  "verification": "Resolva um exercício onde você fatoriza uma planta SISO em fatores coprimes e verifica a identidade de Bezout com norma < 1.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Livro 'Feedback Control Theory' de Doyle et al.",
                                    "MATLAB com Robust Control Toolbox",
                                    "Notas de aula sobre H-infinity control"
                                  ],
                                  "tips": "Sempre normalize os fatores para ||M_m||_∞ =1 e ||N_m||_∞ <1 para simplificar cálculos.",
                                  "learningObjective": "Compreender e computar fatorizações coprimes para plantas nominais.",
                                  "commonMistakes": [
                                    "Confundir RCP com LCP",
                                    "Esquecer normalização",
                                    "Não verificar identidade de Bezout"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Modelar a Planta Nominal e Introduzir Perturbação",
                                  "subSteps": [
                                    "Defina a planta nominal P e compute seus fatores coprimes (N_m, M_m).",
                                    "Introduza a perturbação Δ estável com ||Δ||_∞ < γ^{-1}.",
                                    "Expresse a planta perturbada como P_Δ = (N_m + M_m Δ)(I - Δ H_Δ)^{-1}, onde H_Δ é a função de transferência de incerteza.",
                                    "Derive graficamente o loop de incerteza usando diagramas de bloco.",
                                    "Simule em software a planta nominal e adicione uma perturbação escalar."
                                  ],
                                  "verification": "Gere plots de Bode para P e P_Δ, confirmando que Δ altera a planta dentro de γ.",
                                  "estimatedTime": "3 horas",
                                  "materials": [
                                    "Software MATLAB/Simulink",
                                    "Exemplos de plantas como integrador com ganho variável"
                                  ],
                                  "tips": "Use a forma LFT (Linear Fractional Transformation) para visualizar [P Δ].",
                                  "learningObjective": "Representar plantas perturbadas usando estrutura coprime.",
                                  "commonMistakes": [
                                    "Inverter a ordem na multiplicação",
                                    "Assumir Δ comutativa",
                                    "Ignorar estabilidade de Δ"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Construir a Representação Estruturada [P Δ] = [N_m M_m] [H_Δ 0; 0 I]",
                                  "subSteps": [
                                    "Monte a matriz de entrada [N_m M_m] para a planta nominal.",
                                    "Defina a perturbação estruturada como [H_Δ 0; 0 I], onde H_Δ captura incertezas coprimes.",
                                    "Verifique algebraicamente que P_Δ = Fl([N_m M_m], [H_Δ 0; 0 I]).",
                                    "Implemente em código a LFT e compute respostas em frequência.",
                                    "Teste com γ pequeno para ver limites de robustez."
                                  ],
                                  "verification": "Confirme que a norma H_∞ da interconexão é < γ via mu-toolbox ou hinfsyn.",
                                  "estimatedTime": "4 horas",
                                  "materials": [
                                    "MATLAB Robust Control Toolbox (lft, norm)",
                                    "Paper de McFarlane e Glover sobre coprime factor uncertainty"
                                  ],
                                  "tips": "Use star product (*) para compor incertezas de forma modular.",
                                  "learningObjective": "Construir e validar a representação matricial de incertezas coprimes.",
                                  "commonMistakes": [
                                    "Erro na posição dos blocos na perturbação",
                                    "Não estabilizar H_Δ",
                                    "Confundir norma induzida"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Impor Condições de Estabilidade e Norma para H_Δ",
                                  "subSteps": [
                                    "Garanta que H_Δ seja estável e derive ||H_Δ||_∞ < γ.",
                                    "Use desigualdade de pequena ganho para provar estabilidade da interconexão.",
                                    "Otimize γ minimizando via síntese H-infinity para o pior caso.",
                                    "Simule cenários com H_Δ próximo ao limite γ.",
                                    "Analise sensibilidade com gráficos de singular values."
                                  ],
                                  "verification": "Calcule ||H_Δ||_∞ e confirme < γ com tolerância 1e-3.",
                                  "estimatedTime": "3 horas",
                                  "materials": [
                                    "Funções hinfnorm() no MATLAB",
                                    "Teorema 14.1 do livro de Zhou et al."
                                  ],
                                  "tips": "Escolha γ conservador inicialmente (ex: 0.5) e refine iterativamente.",
                                  "learningObjective": "Aplicar condições de robustez para incertezas coprimes.",
                                  "commonMistakes": [
                                    "Usar norma L2 em vez de H∞",
                                    "Esquecer estabilidade mínima de fase",
                                    "Não checar singular values"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Conectar à Parametrização de Youla para Controladores Estabilizantes",
                                  "subSteps": [
                                    "Revise parametrização de Youla: todos controladores C = (X + D_m Q)(Y - N_m Q)^{-1} para Q estável.",
                                    "Mostre que robustez contra Δ é ||Fl[M_m -N_m; -V_m U_m] Q||_∞ < γ^{-1}.",
                                    "Derive o problema de síntese para Q robusto.",
                                    "Implemente um controlador via Youla e teste com P_Δ.",
                                    "Compare performance nominal vs. robusta."
                                  ],
                                  "verification": "Sintetize Q via H∞ e estabilize P_Δ para ||Δ||_∞ < γ^{-1}.",
                                  "estimatedTime": "4 horas",
                                  "materials": [
                                    "Youla paper original",
                                    "MATLAB hinfsyn() para síntese"
                                  ],
                                  "tips": "Use Q=0 para controlador nominal central.",
                                  "learningObjective": "Integrar modelagem coprime com design de controladores via Youla.",
                                  "commonMistakes": [
                                    "Confundir Q estável com controlador",
                                    "Não parametrizar corretamente V_m, U_m",
                                    "Ignorar inversibilidade"
                                  ]
                                }
                              ],
                              "practicalExample": "Para um motor DC com incerteza no ganho de 20% (P = 1/(s+1), Δ = 0.2), compute fatores coprimes, forme [P Δ], encontre γ=1.25 tal que ||H_Δ||_∞ <1.25, e sintetize controlador Youla que estabiliza para variações ±20%. Simule step response em Simulink.",
                              "finalVerifications": [
                                "Computa corretamente fatores coprimes para uma planta dada.",
                                "Constrói a LFT [P Δ] e verifica estabilidade.",
                                "Confirma ||H_Δ||_∞ < γ com software.",
                                "Liga à Youla parametrizando um controlador robusto.",
                                "Simula e compara performance nominal vs. perturbada.",
                                "Explica verbalmente o teorema de robustez coprime."
                              ],
                              "assessmentCriteria": [
                                "Precisão algébrica na derivação da representação (90% correto).",
                                "Correta aplicação de normas H∞ e verificação numérica.",
                                "Simulações mostram estabilidade para ||Δ||_∞ até γ^{-1}.",
                                "Conexão clara com Youla sem erros conceituais.",
                                "Explicação didática com exemplos numéricos.",
                                "Tempo de convergência em simulação < 5s com overshoot <20%."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Álgebra linear (singular values), análise funcional (normas H∞).",
                                "Física: Dinâmica de sistemas (modelos perturbados em aeroespacial).",
                                "Programação: Simulação numérica (MATLAB/Python para controle robusto).",
                                "Estatística: Modelagem probabilística de incertezas (bayesiana).",
                                "Economia: Otimização de custo em design robusto industrial."
                              ],
                              "realWorldApplication": "Em controle de aeronaves (ex: F-16), modela incertezas aerodinâmicas coprimes para garantir estabilidade robusta sob variações de vento/massa, usando H∞ synthesis via Youla para todos controladores estabilizantes."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.2.3.3",
                            "name": "Analisar robustez coprime",
                            "description": "Calcular o limite de robustez γ = 1 / b(P₀, C), onde b é o fator de estabilidade coprime, e usar ferramentas como MATLAB para síntese H∞ visando minimizar γ em formatação de malha.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os Conceitos Fundamentais de Fator Coprime e Robustez",
                                  "subSteps": [
                                    "Estude a definição de fator de estabilidade coprime b(P₀, C), onde P₀ é a planta nominal e C o controlador.",
                                    "Revise os teoremas de robustez coprime: estabilidade garantida se b(P₀, C) > γ para perturbações com ||Δ|| < γ.",
                                    "Analise a relação γ = 1 / b(P₀, C) como medida de robustez.",
                                    "Explore o contexto de incertezas coprime em formatação de malha."
                                  ],
                                  "verification": "Resuma em um parágrafo os conceitos chave e relacione γ com estabilidade robusta.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Livro de Controle Avançado (Doyle ou Zhou)",
                                    "Notas de aula sobre H∞"
                                  ],
                                  "tips": "Use diagramas de Bode para visualizar o impacto de incertezas.",
                                  "learningObjective": "Entender matematicamente o fator b e sua inversa como métrica de robustez.",
                                  "commonMistakes": [
                                    "Confundir planta nominal P₀ com planta perturbada",
                                    "Ignorar normalização das funções de transferência"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Calcular Manualmente o Fator b(P₀, C)",
                                  "subSteps": [
                                    "Obtenha funções de transferência normalizadas de P₀ e C.",
                                    "Compute o sistema de malha fechada T = P₀ C (I + P₀ C)^{-1}.",
                                    "Calcule b(P₀, C) = inf_ω σ_min [M(jω)], onde M = [I; C] (I + P₀ C)^{-1} [I, P₀].",
                                    "Determine γ = 1 / b(P₀, C) e interprete seu valor.",
                                    "Teste com um exemplo simples de 1ª ordem."
                                  ],
                                  "verification": "Realize o cálculo para um sistema exemplo e verifique se γ < 1 implica robustez.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Papel e calculadora simbólica (Wolfram Alpha)",
                                    "Exemplos resolvidos de robustez coprime"
                                  ],
                                  "tips": "Normalize as funções para ||P||_∞ =1 e ||C||_∞=1 para simplificar.",
                                  "learningObjective": "Dominar o cálculo analítico ou numérico de b e γ.",
                                  "commonMistakes": [
                                    "Erro na montagem da matriz M",
                                    "Não considerar frequência ω em todo o espectro"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar Análise de Robustez em MATLAB",
                                  "subSteps": [
                                    "Instale e configure a toolbox Robust Control do MATLAB.",
                                    "Defina modelos P₀ e C usando tf() ou ss().",
                                    "Use a função coprime() ou sigma() para plotar σ_min[M(jω)] e encontrar inf.",
                                    "Calcule γ automaticamente e plote curvas de robustez.",
                                    "Simule perturbações coprime para validar."
                                  ],
                                  "verification": "Gere plots de σ_min e confirme γ numérico coincidente com cálculo manual.",
                                  "estimatedTime": "2.5 horas",
                                  "materials": [
                                    "MATLAB com Robust Control Toolbox",
                                    "Scripts exemplo de análise H∞"
                                  ],
                                  "tips": "Use grid() nos plots para precisão visual e loop para varredura de ω.",
                                  "learningObjective": "Aplicar ferramentas computacionais para análise precisa de robustez.",
                                  "commonMistakes": [
                                    "Falta de normalização das plantas",
                                    "Escolha inadequada de gama de frequências"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Síntese de Controlador H∞ para Minimizar γ",
                                  "subSteps": [
                                    "Defina o problema de síntese H∞ com pesos para incertezas coprime.",
                                    "Use hinfsyn() para sintetizar C otimizado minimizando γ.",
                                    "Compare γ inicial e final, analisando trade-offs.",
                                    "Valide estabilidade com usim() ou step() em malha fechada.",
                                    "Itere ajustes nos pesos para γ ótimo."
                                  ],
                                  "verification": "Obtenha γ reduzida (<0.8) e demonstre melhoria em simulações.",
                                  "estimatedTime": "3 horas",
                                  "materials": [
                                    "MATLAB Robust Control Toolbox",
                                    "Documentação hinfsyn()"
                                  ],
                                  "tips": "Comece com pesos unitários e ajuste W1, W2 para balancear performance e robustez.",
                                  "learningObjective": "Sintetizar controladores que otimizam robustez coprime.",
                                  "commonMistakes": [
                                    "Controlador não estabilizador inicial",
                                    "Ignorar condição de normalização"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Interpretar e Verificar Resultados de Robustez",
                                  "subSteps": [
                                    "Analise sensibilidade de γ a variações paramétricas.",
                                    "Compare com métodos alternativos (μ-síntese).",
                                    "Documente relatório com plots, valores de γ e conclusões.",
                                    "Teste cenários de pior caso com Δ coprime aleatórios.",
                                    "Discuta limitações do approach coprime."
                                  ],
                                  "verification": "Elabore um relatório resumindo análise e síntese, com γ minimizado comprovado.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Templates de relatório LaTeX ou Word",
                                    "Plots gerados no MATLAB"
                                  ],
                                  "tips": "Use legendas claras nos plots e cite referências teóricas.",
                                  "learningObjective": "Interpretar resultados no contexto de design robusto.",
                                  "commonMistakes": [
                                    "Sobreestimar robustez sem validação simulada",
                                    "Não discutir trade-offs"
                                  ]
                                }
                              ],
                              "practicalExample": "Para um sistema de controle de velocidade de um motor DC com incertezas de 20% nos parâmetros (massa e atrito), modele P₀(s) = 1/(s+1), sintetize C via H∞, calcule γ inicial ≈1.2 (instável) e otimize para γ=0.6, validando estabilidade sob perturbações coprime Δ_m, Δ_c.",
                              "finalVerifications": [
                                "Cálculo de b(P₀, C) e γ correto em pelo menos dois exemplos.",
                                "Plots de σ_min[M(jω)] com infω claramente identificado.",
                                "Controlador H∞ sintetizado com γ <1 e malha fechada estável.",
                                "Simulações de pior caso confirmam robustez.",
                                "Relatório documenta todos os passos e interpretações.",
                                "Comparação quantitativa pré e pós-otimização."
                              ],
                              "assessmentCriteria": [
                                "Precisão matemática nos cálculos de b e γ (erro <1%).",
                                "Qualidade dos scripts MATLAB (comentados e reproduzíveis).",
                                "Interpretação correta de robustez vs. performance.",
                                "Criatividade na síntese (γ minimizado efetivamente).",
                                "Documentação completa e clara.",
                                "Validação via simulações realistas."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Álgebra linear (singular values σ_min) e análise complexa.",
                                "Programação: Desenvolvimento de scripts em MATLAB para automação.",
                                "Física: Modelagem dinâmica de sistemas com incertezas paramétricas.",
                                "Engenharia de Software: Validação e testes de robustez em código."
                              ],
                              "realWorldApplication": "Em controle de aeronaves, onde incertezas aerodinâmicas (vento, variações de configuração) exigem análise coprime para garantir estabilidade em todo envelope de voo, minimizando γ via H∞ para certificação FAA."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.2.3.4",
                            "name": "Relacionar com outros tipos de incertezas",
                            "description": "Mostrar equivalência entre incertezas coprime e aditivas/multiplicativas via pesos apropriados, e aplicar em problemas de robustez para sistemas monovariáveis LIT.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar conceitos fundamentais de incertezas em sistemas de controle",
                                  "subSteps": [
                                    "Defina incertezas aditivas como perturbações δG = G₀ + Δ, onde Δ é bounded.",
                                    "Explique incertezas multiplicativas como δG = G₀ (1 + Wₘ Δ), com ||Δ||∞ ≤ 1.",
                                    "Descreva incertezas coprime como fatorização de plantas nominais com fatores estáveis e bounded.",
                                    "Compare visualmente as representações em diagramas de Bode para um sistema LIT simples.",
                                    "Liste vantagens de cada tipo em modelagem de robustez."
                                  ],
                                  "verification": "Resuma em um quadro comparativo as diferenças e semelhanças entre os três tipos.",
                                  "estimatedTime": "1 hora",
                                  "materials": "Livro 'Feedback Control Theory' de Doyle; MATLAB para plots de Bode.",
                                  "tips": "Use gráficos para visualizar o impacto das incertezas na frequência.",
                                  "learningObjective": "Compreender as definições e representações de incertezas aditivas, multiplicativas e coprime.",
                                  "commonMistakes": "Confundir normas usadas (H∞ vs ∞) ou ignorar estabilidade dos fatores coprime."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Introduzir pesos apropriados para equivalência entre representações",
                                  "subSteps": [
                                    "Defina pesos Wₐ para incertezas aditivas: δG = Wₐ Δ com ||Δ||∞ ≤ 1.",
                                    "Estabeleça pesos Wₘ para multiplicativas: δG = G₀ Wₘ Δ.",
                                    "Mostre pesos para coprime: [M⁻¹, N⁻¹] onde M, N são fatores coprime da planta nominal.",
                                    "Derive condições para que as três representações cubram o mesmo conjunto de plantas perturbadas.",
                                    "Calcule pesos para um exemplo numérico simples de planta LIT."
                                  ],
                                  "verification": "Calcule pesos equivalentes para uma planta G(s) = 1/(s+1) com bounds conhecidos.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": "Notas de aula sobre H∞ control; software MATLAB/Simulink.",
                                  "tips": "Sempre normalize as incertezas para ||Δ||∞ ≤ 1 para facilitar comparações.",
                                  "learningObjective": "Identificar e calcular pesos que tornam as representações de incerteza equivalentes.",
                                  "commonMistakes": "Escolher pesos inadequados que não capturam a magnitude real da incerteza."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Demonstrar matematicamente a equivalência entre incertezas coprime e aditivas/multiplicativas",
                                  "subSteps": [
                                    "Prove que incertezas coprime podem ser reescritas como aditivas via M⁻¹ Δ₁ - N⁻¹ Δ₂.",
                                    "Mostre que pesos Wₐ = M⁻¹ e Wₘ = |G₀| M⁻¹ / |N₀| equivalem às formas aditiva/multiplicativa.",
                                    "Verifique com o teorema de small gain para estabilidade robusta.",
                                    "Implemente em MATLAB a transformação entre representações.",
                                    "Analise numericamente o conjunto de plantas admissíveis."
                                  ],
                                  "verification": "Derive e implemente código que gera plantas equivalentes nas três formas.",
                                  "estimatedTime": "2 horas",
                                  "materials": "MATLAB com toolbox Robust Control; paper 'Coprime Factor Uncertainty' de McFarlane/ Glover.",
                                  "tips": "Use singular values para visualizar o 'volume' do conjunto de incertezas.",
                                  "learningObjective": "Derivar e comprovar a equivalência matemática entre os tipos de incerteza.",
                                  "commonMistakes": "Ignorar a inversibilidade de M ou falhar em manter estabilidade dos fatores."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar a equivalência em problemas de robustez para sistemas monovariáveis LIT",
                                  "subSteps": [
                                    "Selecione um sistema LIT monovariável, como um motor DC: G(s) = K/(s(Js+B)).",
                                    "Modele incertezas em parâmetros (J, B) usando coprime e converta para aditiva/multiplicativa.",
                                    "Projete um controlador H∞ usando cada representação e compare desempenho.",
                                    "Simule respostas a comandos e perturbações para verificar robustez.",
                                    "Avalie margens de robustez (estabilidade e performance) em cada caso."
                                  ],
                                  "verification": "Gere simulações mostrando estabilidade robusta idêntica nas três abordagens.",
                                  "estimatedTime": "2.5 horas",
                                  "materials": "Simulink para simulação; toolbox Robust Control Toolbox.",
                                  "tips": "Teste com variações extremas de parâmetros para validar robustez.",
                                  "learningObjective": "Aplicar a equivalência prática em síntese de controladores robustos.",
                                  "commonMistakes": "Subestimar incertezas em baixas frequências, levando a controle agressivo."
                                }
                              ],
                              "practicalExample": "Para um regulador de velocidade de motor DC com incertezas em inércia J (±20%) e atrito B (±30%), modele como coprime factors, converta pesos para aditiva/multiplicativa e sintetize C(s) via H∞ para garantir ganho de loop <1 em todas as formas.",
                              "finalVerifications": [
                                "Explicar verbalmente a equivalência entre coprime e aditiva usando pesos.",
                                "Implementar código MATLAB que gera plantas equivalentes.",
                                "Simular e plotar respostas robustas para um sistema LIT dado.",
                                "Calcular μ-values para robustez estruturada nas três representações.",
                                "Discutir limitações da equivalência em sistemas não-LIT.",
                                "Comparar computational cost de cada método em síntese."
                              ],
                              "assessmentCriteria": [
                                "Precisão na derivação matemática da equivalência (80% correto).",
                                "Correção dos pesos calculados e simulações (sem erros numéricos).",
                                "Profundidade da análise de robustez (margens >6dB).",
                                "Clareza na explicação e visualizações (gráficos Bode/SV).",
                                "Criatividade na aplicação a um exemplo realista.",
                                "Identificação de erros comuns e soluções."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Análise funcional e normas H∞/L∞.",
                                "Física: Dinâmica de sistemas mecânicos/elétricos com perturbações.",
                                "Informática: Programação numérica em MATLAB para controle ótimo.",
                                "Engenharia Mecânica: Modelagem de atuadores com incertezas paramétricas.",
                                "Estatística: Modelagem probabilística de incertezas vs determinística."
                              ],
                              "realWorldApplication": "Em automação industrial, como controle de robôs ou processos químicos, onde variações em parâmetros (ex: viscosidade em bombas) são modeladas como incertezas coprime e convertidas para síntese de controladores robustos que mantêm performance apesar de não-linearidades e desgaste."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.3.3",
                    "name": "Forma Padrão do Problema",
                    "description": "Formulação padrão usando fatorizações coprime para estabilização robusta de sistemas com incertezas.",
                    "individualConcepts": [
                      {
                        "id": "10.1.3.3.1",
                        "name": "Fatorizações Coprime",
                        "description": "Definição e propriedades das fatorizações coprime direita (RCF) e esquerda (LCF) de plantas de transferência estáveis e instáveis, fundamentais para a parametrização de controladores estabilizadores.",
                        "specificSkills": [
                          {
                            "id": "10.1.3.3.1.1",
                            "name": "Definir Fatorização Coprime Direita (RCF)",
                            "description": "Explicar a decomposição de uma planta P(s) = N(s)M^{-1}(s), onde N e M são estavelmente coprimes, e demonstrar a existência única para plantas próprias.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Fundamentos de Plantas e Coprimidade Estável",
                                  "subSteps": [
                                    "Estude a representação de plantas como funções racionais P(s) = N(s)/D(s), onde N e D são polinômios.",
                                    "Defina coprimidade em anéis de polinômios: N e M são coprimes se não compartilham fatores instáveis comuns.",
                                    "Entenda coprimidade estável: bezout identity com polinômios estáveis X e Y tal que XN + YM = 1.",
                                    "Identifique plantas próprias: plantas bipropriamente estáveis, i.e., estáveis e com inversa estável.",
                                    "Pratique verificando coprimidade estável para pares simples de polinômios."
                                  ],
                                  "verification": "Resolva 3 exemplos de pares de polinômios e confirme coprimidade estável via identidade de Bezout.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Livro de controle avançado (e.g., Zhou's Robust Control), MATLAB para fatoração de polinômios.",
                                  "tips": "Use o algoritmo euclidiano estendido para encontrar X e Y na identidade de Bezout.",
                                  "learningObjective": "Compreender os pré-requisitos de coprimidade estável para fatorizações de plantas.",
                                  "commonMistakes": "Confundir coprimidade global com coprimidade estável; ignorar estabilidade de polinômios."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Definir Formalmente a Fatorização Coprime Direita (RCF)",
                                  "subSteps": [
                                    "Defina RCF: P(s) = N(s)M^{-1}(s), onde N e M são estavelmente coprimes e bipropriamente estáveis.",
                                    "Especifique que N e M pertencem a RH_infty (funções harmônicas estáveis estritamente próprias).",
                                    "Discuta a direção 'direita' versus 'esquerda': aqui M^{-1} à direita.",
                                    "Escreva as condições matemáticas: ∃ X, Y estáveis tal que XN + Y M = I.",
                                    "Compare com fatorização coprime esquerda para clareza."
                                  ],
                                  "verification": "Escreva a definição formal de RCF e identifique os componentes chave em notação matemática.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Notas de aula, quadro branco ou editor LaTeX para equações.",
                                  "tips": "Lembre-se: bipropriedade garante estabilidade em malhas de feedback unitário.",
                                  "learningObjective": "Dominar a definição precisa de RCF e suas propriedades bipropriamente estáveis.",
                                  "commonMistakes": "Omitir bipropriedade; confundir com fatorizações não-estáveis."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Provar a Existência da RCF para Plantas Próprias",
                                  "subSteps": [
                                    "Comece com uma planta própria P estável com inversa estável.",
                                    "Use o lema de coprimidade dupla: existe fatorização onde N = P M e M é escolhido bipropriamente estável.",
                                    "Construa M via solução de equações de Diophantine lineares para garantir coprimidade.",
                                    "Verifique bipropriedade: mostre que [N M] e [-X Y] têm inversas estáveis.",
                                    "Generalize para plantas não próprias usando estados mínimos."
                                  ],
                                  "verification": "Esboce a prova de existência passo a passo para uma planta simples.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Referência: Vidyasagar's Control System Synthesis, simulador MATLAB para validação.",
                                  "tips": "Foquem em normalizações de estados para garantir minimalidade e estabilidade.",
                                  "learningObjective": "Demonstrar matematicamente que toda planta própria admite uma RCF.",
                                  "commonMistakes": "Falhar em provar bipropriedade; assumir existência sem construção explícita."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Demonstrar a Unicidade da RCF",
                                  "subSteps": [
                                    "Assuma duas RCFs: P = N1 M1^{-1} = N2 M2^{-1}, com todas bipropriamente estáveis.",
                                    "Mostre que U = M2 M1^{-1} = N1^{-1} N2 é unitário estável (RH_infty unimodular).",
                                    "Conclua que N2 = N1 U e M2 = M1 U, com U unimodular.",
                                    "Discuta implicações para parametrização de Youla-Kucera.",
                                    "Verifique com exemplo numérico."
                                  ],
                                  "verification": "Prove unicidade módulo unitários estáveis e aplique a um exemplo.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Papel e lápis para prova, MATLAB para computar unitários.",
                                  "tips": "Unimodulares em RH_infty são constantes de módulo 1 ou blocos diagonais.",
                                  "learningObjective": "Entender a unicidade da RCF até fatores unitários estáveis.",
                                  "commonMistakes": "Ignorar o papel dos unitários; confundir unicidade absoluta com relativa."
                                }
                              ],
                              "practicalExample": "Para P(s) = (s+1)/(s^2 + 3s + 2), encontre RCF: Normalize estados para M(s) = 1/(s+1)(s+2), N(s) = (s+1)M(s). Verifique coprimidade via Bezout: X(s)(s+1) + Y(s)/(s+1)(s+2) = 1 com X,Y estáveis.",
                              "finalVerifications": [
                                "Decompor corretamente uma planta própria dada em RCF.",
                                "Verificar coprimidade estável usando identidade de Bezout.",
                                "Provar bipropriedade para N e M.",
                                "Explicar unicidade módulo unitários RH_infty.",
                                "Aplicar RCF em um controlador Q parametrizado.",
                                "Identificar erros em uma RCF proposta."
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição de RCF e coprimidade estável (30%).",
                                "Correção na prova de existência e unicidade (40%).",
                                "Qualidade do exemplo prático com verificações (20%).",
                                "Clareza na explicação de bipropriedade (10%)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Álgebra commutativa e teoria de anéis (RH_infty).",
                                "Programação: Implementar RCF em MATLAB/Simulink para simulações.",
                                "Física: Modelagem de sistemas dinâmicos lineares invariantes no tempo.",
                                "Engenharia de Software: Verificação formal de propriedades estáveis."
                              ],
                              "realWorldApplication": "Em controle robusto, RCF é base para parametrização de Youla, permitindo síntese de controladores estáveis para todas as plantas incertas no conjunto coprime gráfico, usado em aviões (controle de voo) e processos industriais (regulação de temperatura)."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.3.1.2",
                            "name": "Definir Fatorização Coprime Esquerda (LCF)",
                            "description": "Descrever P(s) = \tilde{M}^{-1}(s)\tilde{N}(s) com coprimidade estável à esquerda, e relacionar com a RCF via fatores de Bezout.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Fatorização Coprime à Direita (RCF)",
                                  "subSteps": [
                                    "Relembre a definição de RCF: P(s) = N(s) M^{-1}(s), onde N e M são estáveis e coprime à direita.",
                                    "Entenda coprimidade à direita: existem X, Y estáveis tais que X N + Y M = I.",
                                    "Estude exemplos simples de RCF para plantas monovariáveis.",
                                    "Verifique estabilidade usando polos no semiplano esquerdo.",
                                    "Compare com decomposições polinomiais coprimes."
                                  ],
                                  "verification": "Escreva a definição de RCF e um exemplo com matrizes de Bezout à direita.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Livro de controle avançado (e.g., Zhou et al.), notas de aula sobre RCF.",
                                  "tips": "Comece com frações próprias para simplificar cálculos.",
                                  "learningObjective": "Compreender a base da RCF para contrastar com LCF.",
                                  "commonMistakes": "Confundir coprimidade à direita com à esquerda; ignorar estabilidade."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Introduzir Conceito de Coprimidade à Esquerda",
                                  "subSteps": [
                                    "Defina coprimidade à esquerda em anéis de frações estáveis: \tilde{N} e \tilde{M} são coprimes à esquerda se existem \tilde{X}, \tilde{Y} estáveis com \tilde{X} \tilde{M} + \tilde{Y} \tilde{N} = I.",
                                    "Discuta o anel RH_infty de funções estáveis próprias.",
                                    "Compare com coprimidade à direita usando identidades de Bezout.",
                                    "Analise por que a direção importa em sistemas não comutativos.",
                                    "Resolva um exercício simples de Bezout à esquerda."
                                  ],
                                  "verification": "Construa identidades de Bezout à esquerda para um par simples de transfer functions.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Software MATLAB para validação de estabilidade, referências teóricas.",
                                  "tips": "Use o lema de Youla-Kucera para gerar soluções de Bezout.",
                                  "learningObjective": "Diferenciar coprimidade direcional e seu papel na estabilidade.",
                                  "commonMistakes": "Assumir comutatividade; esquecer requisitos de estabilidade."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Definir Formalmente a Fatorização Coprime à Esquerda (LCF)",
                                  "subSteps": [
                                    "Escreva P(s) = \tilde{M}^{-1}(s) \tilde{N}(s), onde \tilde{M}, \tilde{N} \notin RH_infty e coprimes à esquerda.",
                                    "Especifique que \tilde{M} é unimodular em RH_infty após normalização.",
                                    "Verifique que P \tilde{M} = \tilde{N} como identidade fundamental.",
                                    "Normalize para que ||\tilde{M}||_\beta = 1 e \tilde{M}(j0) = I.",
                                    "Teste com um exemplo numérico de planta de segunda ordem."
                                  ],
                                  "verification": "Escreva a definição completa de LCF e aplique a uma P(s) dada.",
                                  "estimatedTime": "40 minutos",
                                  "materials": "Folha de exercícios, MATLAB/Simulink para plotar funções.",
                                  "tips": "Sempre verifique invertibilidade à esquerda de \tilde{M}.",
                                  "learningObjective": "Dominar a notação e propriedades da LCF.",
                                  "commonMistakes": "Inverter a ordem em P = \tilde{M}^{-1} \tilde{N}; omitir normalização."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Relacionar LCF com RCF via Fatores de Bezout",
                                  "subSteps": [
                                    "Mostre que toda LCF pode ser convertida em RCF usando transformações biproprias.",
                                    "Derive os fatores de Bezout compartilhados: bezoutians à esquerda e direita.",
                                    "Explique unicidade até unidade estável: \tilde{M}' = U \tilde{M}, etc.",
                                    "Resolva um problema de conversão LCF para RCF.",
                                    "Discuta implicações para síntese de controladores Q-parameterizados."
                                  ],
                                  "verification": "Converta uma LCF dada em RCF e verifique coprimidade dupla.",
                                  "estimatedTime": "50 minutos",
                                  "materials": "Artigos sobre fatorizações coprime (Vidyasagar), simulador simbólico.",
                                  "tips": "Use grafos de sinal para visualizar relações matriciais.",
                                  "learningObjective": "Conectar LCF e RCF para aplicações em controle.",
                                  "commonMistakes": "Ignorar fatores biproprios; confundir direções de Bezout."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Aplicar e Sintetizar o Conhecimento",
                                  "subSteps": [
                                    "Crie uma LCF para uma planta instável exemplo.",
                                    "Valide estabilidade e coprimidade usando normas H_infty.",
                                    "Compare desempenhos de controladores baseados em LCF vs RCF.",
                                    "Documente o processo em um relatório curto.",
                                    "Resolva variações com delays ou não-linearidades."
                                  ],
                                  "verification": "Produza uma LCF completa para P(s) = 1/(s-1) com verificações.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "MATLAB Robust Control Toolbox, exemplos de código.",
                                  "tips": "Teste numericamente com tf() e norm() functions.",
                                  "learningObjective": "Aplicar LCF de forma independente em contextos reais.",
                                  "commonMistakes": "Não normalizar; falhar em estabilidade dupla."
                                }
                              ],
                              "practicalExample": "Para P(s) = 1/(s^2 + s + 1), encontre LCF: Escolha \tilde{M}(s) = (s^2 + s + 2)/(s^2 + 2s + 2), \tilde{N}(s) = 1/(s^2 + 2s + 2), verifique Bezout \tilde{X} \tilde{M} + \tilde{Y} \tilde{N} = I com MATLAB.",
                              "finalVerifications": [
                                "Pode definir LCF matematicamente?",
                                "Constrói Bezout à esquerda para um exemplo?",
                                "Converte LCF para RCF corretamente?",
                                "Identifica erros comuns em normalização?",
                                "Aplica LCF a uma planta instável?",
                                "Explica relação com controle robusto?"
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição de LCF e coprimidade à esquerda (30%)",
                                "Correta construção de identidades de Bezout (25%)",
                                "Validação de estabilidade e normalização (20%)",
                                "Conversão precisa entre LCF e RCF (15%)",
                                "Exemplo prático funcional e verificado (10%)"
                              ],
                              "crossCurricularConnections": [
                                "Álgebra Linear: Matrizes biproprias e identidades de Bezout.",
                                "Análise Funcional: Espaços Hardy H_infty para estabilidade.",
                                "Programação: Simulações em MATLAB para validação numérica.",
                                "Otimização: Normas H_infty em síntese de controladores."
                              ],
                              "realWorldApplication": "Em controle avançado de aeronaves, LCF permite design de controladores robustos para plantas com incertezas, como em sistemas fly-by-wire da Boeing, garantindo estabilidade apesar de variações paramétricas."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.3.3.1.1"
                            ]
                          },
                          {
                            "id": "10.1.3.3.1.3",
                            "name": "Calcular Fatorizações Coprime para uma Planta",
                            "description": "Aplicar o algoritmo de estado-espaco ou coprimação de frações para computar N, M, \tilde{N}, \tilde{M} de uma planta LIT escalar com MATLAB ou manualmente.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Modelar a Planta LTI em Forma de Estado-Espaço",
                                  "subSteps": [
                                    "Identifique os coeficientes da planta escalar LIT dada (ex: G(s) = num(s)/den(s))",
                                    "Converta para representação de estado-espaço mínima: encontre matrizes A, B, C, D usando métodos como controllability canonical form",
                                    "Verifique a minimalidade da realização (rank das matrizes de controllability e observability)",
                                    "Salve o modelo em formato compatível com MATLAB (tf, ss)",
                                    "Documente as matrizes A, B, C, D"
                                  ],
                                  "verification": "Confirme que as matrizes reproduzem a função de transferência original via simulação ou cálculo manual",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Papel e caneta, MATLAB (Control System Toolbox), calculadora",
                                  "tips": "Use sys = ss(A,B,C,D) no MATLAB para validar",
                                  "learningObjective": "Dominar a conversão de funções de transferência para estado-espaço mínima",
                                  "commonMistakes": "Esquecer de normalizar para realização mínima, levando a fatores não coprimos"
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Projetar Estabilizadores de Estado (Feedback e Observador)",
                                  "subSteps": [
                                    "Calcule os polos desejados para o sistema fechado (estáveis, ex: polos em -1 ± j, -2)",
                                    "Projete o ganho de feedback de estado F usando place() ou lqr() para estabilizar A + B F",
                                    "Projete o ganho de observador L usando place() para estabilizar A + L C",
                                    "Verifique estabilidade via eigenvalues de A+BF e A+LC (todos com parte real negativa)",
                                    "Ajuste polos se necessário para garantir convergência rápida"
                                  ],
                                  "verification": "Eigenvalues(A + B*F) e eigenvalues(A + L*C) têm Re < 0",
                                  "estimatedTime": "60 minutos",
                                  "materials": "MATLAB (place, eig funções), software de álgebra linear",
                                  "tips": "Comece com polos 2-3x mais rápidos que os originais para bom desempenho",
                                  "learningObjective": "Aprender a estabilizar sistemas via feedback e observador de estado",
                                  "commonMistakes": "Polos mal escolhidos causando instabilidade ou resposta lenta"
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Construir as Fatorizações Coprime N, M, Ñ, M̃",
                                  "subSteps": [
                                    "Para fatorização direita coprima: N = ss(A+BF, B, C+DF, D), M = ss(A+BF, B, C+DF, I)",
                                    "Para esquerda coprima: Ñ = ss(A+LC, L, I, 0), M̃ = ss(A+LC, B+LC D, C+LC D, D)",
                                    "Normalize se necessário (ganhos DC =1 para escalares)",
                                    "Implemente manualmente para casos simples ou use coprime() no MATLAB Robust Control Toolbox",
                                    "Armazene como objetos ss no MATLAB"
                                  ],
                                  "verification": "Verifique P = N * inv(M) e P = inv(M̃) * Ñ aproximadamente iguais à planta original",
                                  "estimatedTime": "45 minutos",
                                  "materials": "MATLAB (ss, Robust Control Toolbox), papel para cálculos manuais",
                                  "tips": "Use feedback(sys1, sys2) para Bezout mais tarde",
                                  "learningObjective": "Construir explicitamente fatores coprimos via realizações estabilizadas",
                                  "commonMistakes": "Erro nos offsets D ou não estabilizar corretamente as realizações"
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificar Propriedades Coprimas e Bezout Identity",
                                  "subSteps": [
                                    "Calcule a identidade de Bezout: N * M̃ - Ñ * M = I (ou próximo de I numericamente)",
                                    "Confirme estabilidade de todos os fatores (pole() < 0)",
                                    "Verifique unimodularidade: inv(M) e inv(M̃) estáveis",
                                    "Teste sensibilidade: perturbe e veja se mantém coprimidade",
                                    "Gere relatório com plots de Bode dos fatores"
                                  ],
                                  "verification": "||N M̃ - Ñ M - I|| < 1e-6 e todos fatores estáveis",
                                  "estimatedTime": "30 minutos",
                                  "materials": "MATLAB (norm, pole, bode), exportar figuras",
                                  "tips": "Use tol=1e-8 em funções numéricas para precisão",
                                  "learningObjective": "Validar rigorosamente as fatorizações coprimas",
                                  "commonMistakes": "Ignorar erros numéricos em MATLAB levando a falsos positivos"
                                }
                              ],
                              "practicalExample": "Para a planta G(s) = 1/(s^2 - s + 1), converta para ss: A=[0 1; -1 1], B=[0;1], C=[1 0], D=0. Escolha polos [-2,-3], F=place(A,B,[-2,-3]), L=place(A',C',[-2,-3])'. Construa N,M,Ñ,M̃ e verifique N*M̃ - Ñ*M ≈ I.",
                              "finalVerifications": [
                                "Função de transferência reconstruída P = N/M = original",
                                "Todos fatores N,M,Ñ,M̃ estáveis (polos Re<0)",
                                "Bezout identity satisfeita: ||N M̃ - Ñ M - I|| < ε",
                                "Realizações mínimas e normalizadas (DC gain=1)",
                                "Plots de Bode mostram fatores próprios estáveis"
                              ],
                              "assessmentCriteria": [
                                "Precisão numérica das matrizes e fatores (erro <1%)",
                                "Correta estabilização dos sistemas auxiliares",
                                "Validação completa da identidade de Bezout",
                                "Eficiência computacional (tempo <3h total)",
                                "Relatório claro com código MATLAB reproduzível",
                                "Tratamento de casos edge (polos instáveis)"
                              ],
                              "crossCurricularConnections": [
                                "Álgebra Linear: Eigenvalues, place algorithm",
                                "Programação: MATLAB scripting e toolboxes",
                                "Matemática Aplicada: Teoria de Frações Coprimas em Anéis",
                                "Física: Modelagem dinâmica de sistemas lineares"
                              ],
                              "realWorldApplication": "Usado em síntese de controladores robustos (H∞, μ-synthesis) para plantas incertas em robótica industrial, aeroespacial e automação, permitindo parametrizar todos estabilizadores via Youla-Kucera."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.3.3.1.1",
                              "10.1.3.3.1.2"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "10.1.3.3.2",
                        "name": "Modelos de Incertezas em Plantas",
                        "description": "Representação de incertezas paramétricas e dinâmicas em plantas monovariáveis usando perturbações normadas, preparando para robustez.",
                        "specificSkills": [
                          {
                            "id": "10.1.3.3.2.1",
                            "name": "Modelar Incertezas Multiplicativas",
                            "description": "Formular a planta perturbada como P_\triangle(s) = [I + W_m(s)\triangle_m(s)] P_0(s), onde ||\triangle_m||_\fty <1, e definir pesos W_m para capturar incertezas de ganho e fase.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender o Modelo Nominal e Incertezas Multiplicativas",
                                  "subSteps": [
                                    "Revise o conceito de planta nominal P_0(s) como o modelo ideal sem perturbações.",
                                    "Identifique fontes de incerteza multiplicativa: variações paramétricas que afetam ganho e fase de forma relativa.",
                                    "Estude a norma ∞ de Δ_m, garantindo ||Δ_m||_∞ < 1 para estabilidade.",
                                    "Compare com incertezas aditivas para contextualizar diferenças.",
                                    "Anote exemplos reais de incertezas em sistemas físicos como motores ou processos químicos."
                                  ],
                                  "verification": "Explique verbalmente ou por escrito a diferença entre modelo nominal e perturbado, citando a fórmula P(s) = [I + W_m Δ_m] P_0(s).",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Livro de Controle Robusto (Skogestad ou Zhou)",
                                    "Notas de aula sobre modelagem de plantas",
                                    "Calculadora simbólica (MATLAB/SymPy)"
                                  ],
                                  "tips": "Use diagramas de bloco para visualizar a multiplicação da perturbação pela planta nominal.",
                                  "learningObjective": "Compreender a representação matemática de incertezas multiplicativas e sua relação com o modelo nominal.",
                                  "commonMistakes": [
                                    "Confundir incertezas multiplicativas com aditivas",
                                    "Ignorar a condição ||Δ_m||_∞ < 1",
                                    "Não relativizar incertezas ao ganho nominal"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Formular a Planta Perturbada P_Δ(s)",
                                  "subSteps": [
                                    "Escreva a equação P_Δ(s) = [I + W_m(s) Δ_m(s)] P_0(s) para sistemas SISO e MIMO.",
                                    "Para SISO, expanda como P_Δ(s) = P_0(s) (1 + W_m(s) Δ_m(s)).",
                                    "Verifique dimensionalidade: W_m(s) deve ter a mesma estrutura dinâmica de P_0(s).",
                                    "Implemente em software: defina P_0(s) e gere P_Δ(s) com Δ_m aleatório unitário.",
                                    "Plote respostas em frequência para visualizar o envelope de incerteza."
                                  ],
                                  "verification": "Gere e plote pelo menos 3 realizações de P_Δ(s) e confirme que variam em torno de P_0(s).",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "MATLAB/Simulink ou Python (Control Systems Library)",
                                    "Templates de funções de transferência de plantas exemplo"
                                  ],
                                  "tips": "Comece com sistemas SISO simples para evitar complexidade matricial inicial.",
                                  "learningObjective": "Dominar a formulação algébrica e computacional da planta perturbada.",
                                  "commonMistakes": [
                                    "Esquecer o termo identidade I em MIMO",
                                    "Usar Δ_m com norma >1",
                                    "Não normalizar W_m corretamente"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Definir Pesos W_m para Incertezas de Ganho",
                                  "subSteps": [
                                    "Meça o ganho relativo máximo: |P(jω)/P_0(jω)| em frequência.",
                                    "Ajuste W_m(s) como ganho constante ou dinâmico para capturar picos de variação.",
                                    "Para ganho constante, W_m = max(|Δganho|), onde Δganho = (P_max - P_min)/P_0.",
                                    "Valide: o envelope |W_m(jω) P_0(jω)| deve cobrir todas as curvas de incerteza.",
                                    "Otimize W_m minimizando o erro de cobertura via simulação."
                                  ],
                                  "verification": "Crie um diagrama de Bode com P_0, envelope e curvas reais; confirme cobertura total.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Software de análise em frequência (Bode plots)",
                                    "Dados experimentais de planta real ou simulada"
                                  ],
                                  "tips": "Use regra prática: W_m ≈ 0.2-0.5 para ±20-50% de variação de ganho.",
                                  "learningObjective": "Selecionar W_m que capture precisamente variações de ganho relativo.",
                                  "commonMistakes": [
                                    "Subestimar variações em baixas frequências",
                                    "Confundir ganho absoluto com relativo",
                                    "Não validar com múltiplas curvas"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Definir Pesos W_m para Incertezas de Fase",
                                  "subSteps": [
                                    "Identifique desvios de fase: arg(P(jω)/P_0(jω)) em graus.",
                                    "Modele W_m(s) com fase all-pass para capturar atrasos: W_m(s) = |W_m| * (Ts + 1)/(Ts α + 1) com α <1.",
                                    "Ajuste dinamicamente para mismatches em banda de crossover.",
                                    "Combine com W_m de ganho: W_m_total = max(W_ganho, W_fase) ou produto se correlacionados.",
                                    "Teste robustez gerando Δ_m de fase e verificando estabilidade."
                                  ],
                                  "verification": "Simule laço fechado com controlador simples e confirme estabilidade para ||Δ_m||_∞ = 0.9.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Ferramentas de síntese H∞ (MATLAB Robust Control Toolbox)",
                                    "Exemplos de plantas com dados de fase"
                                  ],
                                  "tips": "Fase é crítica em crossover; priorize W_m com pico de fase lá.",
                                  "learningObjective": "Modelar incertezas de fase com pesos dinâmicos precisos.",
                                  "commonMistakes": [
                                    "Usar W_m constante para fase variável",
                                    "Ignorar correlação ganho-fase",
                                    "Exceder norma em validação"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Validar e Integrar o Modelo de Incerteza",
                                  "subSteps": [
                                    "Integre W_m em framework μ-síntese ou LMI para teste.",
                                    "Gere 100 amostras de Δ_m e compute estatísticas de ||Δ_m||_∞.",
                                    "Compare modelo com dados reais: ajuste iterativamente W_m.",
                                    "Documente o modelo final com justificativa de pesos.",
                                    "Discuta limitações: não captura não-linearidades ou incertezas não-multiplicativas."
                                  ],
                                  "verification": "Relatório com plots, normas e conclusão de cobertura >95%.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "MonteCarlo simulation script",
                                    "Relatório template"
                                  ],
                                  "tips": "Automatize simulações para eficiência.",
                                  "learningObjective": "Validar o modelo completo e prepará-lo para síntese de controladores robustos.",
                                  "commonMistakes": [
                                    "Não testar múltiplas Δ_m",
                                    "Sobreajustar W_m levando a conservadorismo",
                                    "Omitir documentação"
                                  ]
                                }
                              ],
                              "practicalExample": "Para um motor DC com P_0(s) = 1/(s+1), incertezas de ganho ±30% e fase ±20° em ω=1 rad/s. Defina W_m(s) = 0.3 * (0.5s +1)/(0.5*0.5 s +1), gere P_Δ(s) e plote envelopes em Bode para controle de velocidade robusto.",
                              "finalVerifications": [
                                "Formulação correta de P_Δ(s) com I + W_m Δ_m.",
                                "W_m captura >95% das variações observadas de ganho e fase.",
                                "||Δ_m||_∞ <1 para todas as perturbações geradas.",
                                "Plots de Bode mostram cobertura adequada do envelope.",
                                "Simulação de laço fechado estável para ||Δ_m||_∞=0.9.",
                                "Documentação inclui justificativa e limitações."
                              ],
                              "assessmentCriteria": [
                                "Precisão da formulação matemática (30%)",
                                "Adequação dos pesos W_m à incerteza especificada (25%)",
                                "Qualidade dos plots e validações (20%)",
                                "Correção na manipulação de normas ∞ (15%)",
                                "Clareza da explicação e documentação (10%)"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Análise de normas em espaços de Hardy ∞ e funções de transferência.",
                                "Programação: Simulações em MATLAB/Python para análise estocástica.",
                                "Física: Modelagem de sistemas dinâmicos reais com parametrização estruturada.",
                                "Estatística: Análise de Monte Carlo para validação de incertezas.",
                                "Engenharia de Software: Desenvolvimento de scripts reutilizáveis para robustez."
                              ],
                              "realWorldApplication": "Em aeroespacial, modela incertezas em atuadores de aeronaves para controladores robustos H∞ que garantem estabilidade apesar de variações de fabricação e envelhecimento, evitando falhas catastróficas em voo."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.3.3.1.3"
                            ]
                          },
                          {
                            "id": "10.1.3.3.2.2",
                            "name": "Modelar Incertezas Aditivas e Inversas",
                            "description": "Descrever perturbações aditivas P_\triangle = P_0 + W_a \triangle_a e inversas para estabilidade robusta, com exemplos de sistemas reais.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender Conceitos Fundamentais de Incertezas em Plantas de Controle",
                                  "subSteps": [
                                    "Revise a representação nominal da planta P_0 em sistemas de controle monovariáveis.",
                                    "Estude definições de incertezas aditivas (Δ_a) e inversas (Δ_i) em contextos de robustez.",
                                    "Analise a forma padrão P_Δ = P_0 + W_a Δ_a para perturbações aditivas.",
                                    "Explore a modelagem inversa como P_Δ^{-1} ≈ P_0^{-1} (I - W_i Δ_i P_0^{-1}) para incertezas multiplicativas.",
                                    "Discuta o papel das funções de peso W_a e W_i na captura de magnitude de incertezas."
                                  ],
                                  "verification": "Resuma em um diagrama as diferenças entre modelos aditivos e inversos, confirmando com equações corretas.",
                                  "estimatedTime": "2 horas",
                                  "materials": "Livro de controle avançado (ex: Skogestad), MATLAB/Simulink para visualização, notas de aula sobre H-infinito.",
                                  "tips": "Use blocos de diagrama para visualizar como incertezas afetam o loop de controle.",
                                  "learningObjective": "Identificar e diferenciar tipos de incertezas aditivas e inversas em plantas nominais.",
                                  "commonMistakes": "Confundir aditivas (soma) com multiplicativas (produto); ignorar funções de peso."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Modelar Incertezas Aditivas em Plantas",
                                  "subSteps": [
                                    "Selecione uma planta nominal P_0 de um sistema real (ex: motor DC).",
                                    "Defina o conjunto de incertezas Δ_a com ||Δ_a||_∞ ≤ 1.",
                                    "Construa W_a baseada em dados experimentais de variações (ganho, fase).",
                                    "Implemente P_Δ = P_0 + W_a Δ_a em software de simulação.",
                                    "Simule respostas em frequência para validar o modelo."
                                  ],
                                  "verification": "Gere gráficos de Bode para P_0 e P_Δ, mostrando desvios dentro de W_a.",
                                  "estimatedTime": "3 horas",
                                  "materials": "MATLAB com toolbox Control System, dados de planta real (ex: SysID Toolbox).",
                                  "tips": "Comece com incertezas pequenas (Δ_a = 0.1) para validar linearidade.",
                                  "learningObjective": "Construir e simular modelos de incertezas aditivas precisos.",
                                  "commonMistakes": "Escolher W_a muito ampla, levando a modelos irrealistas; não normalizar Δ_a."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Modelar Incertezas Inversas e Integração com Aditivas",
                                  "subSteps": [
                                    "Derive a aproximação para incertezas inversas: perturbações em P_0^{-1}.",
                                    "Defina W_i para capturar variações no inverso da planta.",
                                    "Combine modelos: P_Δ total incorporando ambos aditivas e inversas.",
                                    "Implemente em código, testando estabilidade com Nyquist ou μ-analysis.",
                                    "Ajuste pesos baseados em tolerâncias de robustez desejadas."
                                  ],
                                  "verification": "Verifique se o modelo unificado mantém estabilidade robusta para ||Δ||_∞ ≤ 1.",
                                  "estimatedTime": "4 horas",
                                  "materials": "Robust Control Toolbox no MATLAB, exemplos de Skogestad Chapter 9.",
                                  "tips": "Use linearização em torno de P_0 para aproximações inversas precisas.",
                                  "learningObjective": "Integrar incertezas aditivas e inversas em um modelo coeso.",
                                  "commonMistakes": "Negligenciar não-minimum phase em inversos; superestimar W_i sem dados."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar Modelos em Exemplos Reais e Análise de Estabilidade",
                                  "subSteps": [
                                    "Escolha um sistema real: ex: controle de altitude de drone com variações de massa.",
                                    "Colete dados reais ou simule incertezas (vento como aditiva, mudança de hélice como inversa).",
                                    "Sintetize controlador robusto (H∞) usando os modelos.",
                                    "Avalie desempenho com simulações Monte Carlo de Δ_a e Δ_i.",
                                    "Documente trade-offs entre robustez e performance nominal."
                                  ],
                                  "verification": "Confirme estabilidade para 100 simulações com Δ aleatórias; performance dentro de specs.",
                                  "estimatedTime": "3 horas",
                                  "materials": "Simulink para simulação de drone, dados públicos de UAVs.",
                                  "tips": "Use μ-síntese para síntese automática de controladores robustos.",
                                  "learningObjective": "Aplicar modelagem a sistemas reais com verificação de robustez.",
                                  "commonMistakes": "Ignorar dinâmica não-linear em exemplos reais; não validar com dados experimentais."
                                }
                              ],
                              "practicalExample": "Em um sistema de controle de velocidade de um motor DC em um robô móvel, modele incertezas aditivas devido a variações de carga (W_a captura ±20% de torque extra) como P_Δ = P_0 + W_a Δ_a, e inversas por desgaste de escovas afetando ganho inverso. Simule em MATLAB: com Δ_a = 0.5 sen(ωt), verifique estabilidade do controlador PI robusto mantendo overshoot <10%.",
                              "finalVerifications": [
                                "Modelos P_Δ aditivo e inverso implementados corretamente em código/simulação.",
                                "Gráficos de incerteza (disk plots) mostram cobertura realista de variações.",
                                "Análise μ confirma robustez para ||Δ||_∞ ≤ 1.",
                                "Simulações com exemplos reais mostram estabilidade e performance.",
                                "Documentação inclui derivações e justificativas de pesos W_a/W_i.",
                                "Trade-offs entre robustez e desempenho nominal explicitados."
                              ],
                              "assessmentCriteria": [
                                "Precisão das equações de modelagem (aditiva e inversa corretas).",
                                "Adequação das funções de peso W_a/W_i aos dados reais.",
                                "Corretude da análise de estabilidade robusta (Nyquist/μ).",
                                "Qualidade dos exemplos práticos e simulações.",
                                "Clareza na documentação de passos e verificações.",
                                "Capacidade de integrar ambos tipos de incertezas."
                              ],
                              "crossCurricularConnections": [
                                "Probabilidade e Estatística: Uso de distribuições para gerar Δ_a/Δ_i em Monte Carlo.",
                                "Programação Numérica: Implementação em MATLAB/Python para análise de robustez.",
                                "Física Aplicada: Modelagem de sistemas dinâmicos reais (ex: aeroespacial).",
                                "Otimização: Síntese H∞ como problema de minimização.",
                                "Análise de Dados: Identificação de plantas via SysID para definir incertezas."
                              ],
                              "realWorldApplication": "Na indústria aeroespacial, modela incertezas aditivas (turbulência em asas) e inversas (variações em atuadores) para controladores de flight envelope protection em aviões como Boeing 787, garantindo estabilidade robusta apesar de manufatura e envelhecimento, reduzindo riscos de falhas catastróficas."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.3.3.2.1"
                            ]
                          },
                          {
                            "id": "10.1.3.3.2.3",
                            "name": "Usar Fatorizações Coprime para Incertezas",
                            "description": "Incorporar incertezas na forma coprime: P_\triangle = (N + \triangle_{11} M)(M + \triangle_{12} M)^{-1}, com ||[\triangle_{11} \triangle_{12}]||_\fty < \tilde{\beta}.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender Fatorizações Coprime em Sistemas Lineares",
                                  "subSteps": [
                                    "Revise a definição de fatorizações coprime direita (RCP) e esquerda (LCP) para plantas estáveis.",
                                    "Estude a representação de uma planta nominal P = N M^{-1} = \tilde{M}^{-1} \tilde{N}, onde N, M são estáveis e coprimes.",
                                    "Aprenda o lema de Bezout: existência de X, Y estáveis tais que X N - Y M = I.",
                                    "Pratique decompondo uma planta simples em fatores coprime usando fatorização de Smith ou SVD.",
                                    "Verifique coprimidade computando o maior divisor comum espectral."
                                  ],
                                  "verification": "Construa RCP para uma planta dada e confirme que [N M] é unimodularmente completável.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Livro 'Feedback Control Theory' de Doyle",
                                    "MATLAB com toolbox de controle",
                                    "Notas de aula sobre RCP"
                                  ],
                                  "tips": "Comece com plantas SISO para simplicidade antes de MIMO.",
                                  "learningObjective": "Compreender e decompor plantas em fatorizações coprime estáveis.",
                                  "commonMistakes": [
                                    "Confundir RCP com LCP",
                                    "Esquecer estabilidade dos fatores",
                                    "Não verificar coprimidade adequadamente"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Representar Planta Nominal na Forma Padrão",
                                  "subSteps": [
                                    "Obtenha a planta nominal P e compute suas fatorizações coprime N, M.",
                                    "Forme as matrizes normalizadas: escolha γ tal que ||[N M]||_∞ < γ, então defina \tilde{N} = N/γ, etc.",
                                    "Estruture a forma padrão do problema: introduza blocos Δ para incertezas.",
                                    "Escreva P_Δ = (N + Δ_{11} M)(M + Δ_{12} M)^{-1}.",
                                    "Confirme invertibilidade assumindo ||Δ_{12}|| pequeno."
                                  ],
                                  "verification": "Escreva explicitamente P_Δ para uma P nominal dada e verifique que Δ=0 recupera P.",
                                  "estimatedTime": "3 horas",
                                  "materials": [
                                    "MATLAB script para RCP",
                                    "Paper 'Coprime Factor Uncertainty' de McFarlane",
                                    "Calculadora simbólica como SymPy"
                                  ],
                                  "tips": "Use normalização para facilitar análise de normas.",
                                  "learningObjective": "Construir a representação da planta com estrutura coprime para incertezas.",
                                  "commonMistakes": [
                                    "Erro na inversão: lembre que é (M + Δ_{12} M)^{-1}",
                                    "Ignorar normalização de normas",
                                    "Confundir Δ_{11} e Δ_{12}"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Incorporar e Analisar Incertezas Coprime",
                                  "subSteps": [
                                    "Defina as incertezas Δ_{11}, Δ_{12} estáveis com norma ||[Δ_{11} Δ_{12}]||_∞ < \tilde{β}.",
                                    "Estenda para incertezas normalizadas: defina b = 1/(1 - \tilde{β}) para estabilidade.",
                                    "Use o lema de robustez: sistema estável se ||K (I - P K)^{-1} [M^{-1} -\tilde{N}]||_∞ < 1/b.",
                                    "Compute o conjunto de plantas perturbadas e visualize graficamente.",
                                    "Simule pequenas perturbações e observe mudança em diagramas de Bode."
                                  ],
                                  "verification": "Gere 5 plantas P_Δ aleatórias dentro da bola de incerteza e confirme estabilidade.",
                                  "estimatedTime": "4 horas",
                                  "materials": [
                                    "MATLAB Robust Control Toolbox",
                                    "Exemplos numéricos de Vidyasagar",
                                    "Python com control library"
                                  ],
                                  "tips": "Sempre normalize incertezas para trabalhar com normas unitárias.",
                                  "learningObjective": "Modelar incertezas aditivas/multiplicativas via coprime e verificar condições.",
                                  "commonMistakes": [
                                    "Usar norma errada (H2 em vez de H∞)",
                                    "Esquecer fator b na condição",
                                    "Não garantir estabilidade de Δ"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificar Condição de Norma e Projetar Controlador Robusto",
                                  "subSteps": [
                                    "Calcule a norma H∞ do operador de incerteza para um controlador dado.",
                                    "Ajuste o controlador K para satisfazer ||[Δ_{11} Δ_{12}]||_∞ < \tilde{β}.",
                                    "Use μ-síntese ou loop-shaping para maximizar \tilde{β}.",
                                    "Valide com simulações de Monte Carlo sobre Δ aleatórios.",
                                    "Documente o valor máximo de \tilde{β} alcançado."
                                  ],
                                  "verification": "Confirme que para Δ na fronteira da norma, o laço fechado permanece estável.",
                                  "estimatedTime": "3 horas",
                                  "materials": [
                                    "MATLAB μ-Tools",
                                    "Tutorial H∞ de Skogestad",
                                    "Hardware simulador como Simulink"
                                  ],
                                  "tips": "Itere com otimização para encontrar o maior \tilde{β}.",
                                  "learningObjective": "Aplicar fatorizações coprime para garantir robustez via normas H∞.",
                                  "commonMistakes": [
                                    "Calcular norma aberta em vez fechada",
                                    "Ignorar conservadorismo da abordagem",
                                    "Não testar Δ extremas"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Simular e Avaliar Aplicação Prática",
                                  "subSteps": [
                                    "Implemente o modelo P_Δ em Simulink com parâmetros variáveis.",
                                    "Teste desempenho do controlador sob incertezas nominais e perturbadas.",
                                    "Compare métricas: tempo de estabilização, overshoot, robustez.",
                                    "Gere relatório com gráficos de resposta temporal e Nyquist.",
                                    "Otimize hiperparâmetros baseados em \tilde{β}."
                                  ],
                                  "verification": "Simulação bem-sucedida com 100% de estabilidade em 100 trials de Δ.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Simulink",
                                    "Dados reais de planta (ex: motor DC)",
                                    "Jupyter notebook para análise"
                                  ],
                                  "tips": "Use seeds fixos para reprodutibilidade em simulações.",
                                  "learningObjective": "Integrar e validar o uso de fatorizações coprime em cenários reais.",
                                  "commonMistakes": [
                                    "Sobrecarregar simulações sem paralelização",
                                    "Ignorar efeitos não-lineares",
                                    "Não quantificar degradação de performance"
                                  ]
                                }
                              ],
                              "practicalExample": "Considere uma planta de motor DC nominal P(s) = 1/(s+1). Compute RCP: N(s)=1/(s+2), M(s)=(s+1)/(s+2). Introduza Δ_{11}=0.1 sin(ωt)/(s+0.1), Δ_{12}=0.05/(s+0.5), com ||[Δ_{11} Δ_{12}]||_∞ < 0.1. Verifique estabilidade do laço com K(s)=1 para perturbações.",
                              "finalVerifications": [
                                "Decompor corretamente uma planta dada em RCP/LCP.",
                                "Escrever P_Δ explicitamente e recuperar P quando Δ=0.",
                                "Calcular ||[Δ_{11} Δ_{12}]||_∞ e confirmar < \tilde{β}.",
                                "Simular 10 perturbações e verificar estabilidade em todas.",
                                "Explicar o papel de b na condição de robustez.",
                                "Projetar K simples que maximize \tilde{β}."
                              ],
                              "assessmentCriteria": [
                                "Precisão na decomposição coprime (90% match com solução analítica).",
                                "Correção da forma P_Δ e normas H∞ (<5% erro).",
                                "Qualidade das simulações (gráficos claros, >95% estabilidade).",
                                "Profundidade da análise de erros comuns e tips.",
                                "Capacidade de generalizar para MIMO.",
                                "Relatório completo com verificações finais."
                              ],
                              "crossCurricularConnections": [
                                "Álgebra Linear: SVD e fatorizações de matrizes para coprimidade.",
                                "Análise Numérica: Cálculo de normas H∞ via algoritmos de estado-espaço.",
                                "Programação: Implementação em MATLAB/Python para simulações robustas.",
                                "Probabilidade: Modelagem de Δ estocásticos via Monte Carlo.",
                                "Física: Aplicação em dinâmica de sistemas reais com ruído."
                              ],
                              "realWorldApplication": "Em controle de aeronaves, modela incertezas aerodinâmicas (variações de vento, desgaste) usando fatorizações coprime para sintetizar controladores H∞ que garantem estabilidade robusta durante manobras, evitando falhas catastróficas."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.3.3.1.3",
                              "10.1.3.3.2.1"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "10.1.3.3.3",
                        "name": "Forma Padrão do Problema de Estabilização Robusta",
                        "description": "Formulação unificada do problema de estabilização robusta usando blocos generalizados de plantas com entradas/saídas de incerteza e desempenho.",
                        "specificSkills": [
                          {
                            "id": "10.1.3.3.3.1",
                            "name": "Formular a Forma Padrão Geral",
                            "description": "Construir o sistema generalizado [P] com blocos P_{11}, P_{12}, P_{21}, P_{22} para incertezas e especificações de desempenho via conexão estrela.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Identificar Componentes do Problema: Planta Nominal, Incertezas e Especificações",
                                  "subSteps": [
                                    "Analise a planta nominal G(s) ou modelo discreto do sistema monovariável.",
                                    "Identifique fontes de incerteza Δ (ex.: variação paramétrica, não-linearidades modeladas como Δ).",
                                    "Defina especificações de desempenho: rejeição de distúrbios, rastreamento de referências, limites em atuadores.",
                                    "Liste sinais exógenos w (distúrbios d, referências r) e de performance z (erros e)",
                                    "Documente entradas de controle u e saídas de medição y."
                                  ],
                                  "verification": "Crie um diagrama esquemático com planta G, Δ e pesos Wp, Wu, Wd conectados corretamente.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Papel e lápis para diagrama",
                                    "Software de simulação como MATLAB/Simulink",
                                    "Referências teóricas: Zhou et al. 'Robust and Optimal Control' Capítulo 9"
                                  ],
                                  "tips": "Comece com um sistema simples como um motor DC para praticar.",
                                  "learningObjective": "Compreender a decomposição do problema de controle robusto em componentes modulares.",
                                  "commonMistakes": [
                                    "Confundir sinais w e z",
                                    "Ignorar incertezas não aditivas",
                                    "Esquecer pesos de desempenho"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Definir Sinais e Pesos de Desempenho",
                                  "subSteps": [
                                    "Selecione pesos de desempenho: Wp para erro de rastreamento, Wu para uso de controle, Wt para sensibilidade.",
                                    "Modele incertezas: Δ como bloco normado ||Δ||∞ ≤ 1.",
                                    "Defina partições: w = [w_perf; w_unc], z = [z_perf; z_unc], u = [u_ctrl; u_unc], y = [y_meas; y_unc].",
                                    "Verifique dimensões: compatibilidade entre w, z, u, y.",
                                    "Esboce o loop de incerteza: (I - P22 K)^{-1} etc."
                                  ],
                                  "verification": "Confirme que as dimensões de entrada/saída dos pesos combinam com os sinais (ex.: size(Wp) = [dim_z_perf, dim_w_perf]).",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "MATLAB para definir funções de transferência tf()",
                                    "Folha de cálculo para rastrear dimensões"
                                  ],
                                  "tips": "Use pesos conservadores inicialmente: Wp = 1/(s+1) para erro DC.",
                                  "learningObjective": "Mapear especificações qualitativas para pesos quantitativos H∞.",
                                  "commonMistakes": [
                                    "Pesos com polos no RHP sem justificativa",
                                    "Dimensões incompatíveis",
                                    "Confundir Δ aditiva e multiplicativa"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Construir os Blocos P11, P12, P21 e P22",
                                  "subSteps": [
                                    "Monte P11: via da performance [Wp 0; 0 1] * [G; I] ou similar para z_perf e z_unc.",
                                    "Defina P12: [Wp 0; 0 1] * [0; I] para entradas de controle em z.",
                                    "Construa P21: [Wd G; I 0] para y de w e u.",
                                    "Forme P22: G, a planta para o controlador.",
                                    "Use conexão estrela: z = P11 w + P12 u, y = P21 w + P22 u."
                                  ],
                                  "verification": "Implemente em MATLAB: P = [P11 P12; P21 P22] com p11 = tf(num,den), etc., e cheque size(P).",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "MATLAB Control System Toolbox: sysic para interconexões",
                                    "Documentação H∞ padrão"
                                  ],
                                  "tips": "Use blkdiag() para blocos diagonais em P11/P12.",
                                  "learningObjective": "Construir blocos modulares que encapsulem incertezas e specs via conexão estrela.",
                                  "commonMistakes": [
                                    "P11 sem caminho direto w->z",
                                    "P22 não é exatamente a planta G",
                                    "Esquecer normalização de Δ"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Montar e Validar o Sistema Generalizado [P]",
                                  "subSteps": [
                                    "Combine blocos: P = [P11, P12; P21, P22] usando append ou sysic.",
                                    "Verifique estabilidade intrínseca: sem cancelamentos instáveis.",
                                    "Simule resposta aberta: step(P22), bode(P11).",
                                    "Confirme problema padrão: min ||Tzw||∞ < γ com K estável.",
                                    "Documente equações: Tzw = (P11 + P12 K (I - P22 K)^{-1} P21)."
                                  ],
                                  "verification": "Rode simulação: gamma = hinfsyn(P, n_meas, n_ctrl) sem erro.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "MATLAB: hinfsyn(), sigma() para plotar singular values"
                                  ],
                                  "tips": "Teste com γ=1 inicialmente para viabilidade.",
                                  "learningObjective": "Validar formulação para síntese de controladores H∞/μ.",
                                  "commonMistakes": [
                                    "Particionamento errado de sinais",
                                    "P instável aberto",
                                    "Ignorar D-K iteration para μ"
                                  ]
                                }
                              ],
                              "practicalExample": "Para um servo-motor com incerteza em ganho K_m (±20%): G(s)=K_m/(s(Js+B)), Δ multiplicativa. w=[r;d], z=[e;u], P11 inclui Wp*G, P12=Wp, P21=[I G], P22=G. Simule em MATLAB e sintetize K.",
                              "finalVerifications": [
                                "Dimensões de P corretas: inputs/outputs partitionados adequadamente.",
                                "Blocos Pij implementados sem erros de sinal.",
                                "Simulação aberta de P22 recupera planta nominal.",
                                "Pesos geram ||Tzw||∞ <1 para problema bem-posed.",
                                "Diagrama de conexão estrela desenhado e legível.",
                                "Código MATLAB reproduzível e comentado."
                              ],
                              "assessmentCriteria": [
                                "Precisão na modelagem de incertezas e pesos (90% match com specs).",
                                "Corretude dimensional e conexão estrela (sem erros de size).",
                                "Validação via simulação H∞ (γ <2 viável).",
                                "Clareza na documentação e diagrama.",
                                "Identificação de erros comuns evitados.",
                                "Eficiência temporal: dentro de 6 horas totais."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Álgebra linear (particionamento matricial), Análise Complexa (normas H∞).",
                                "Programação: MATLAB/Simulink para modelagem state-space.",
                                "Física: Dinâmica de sistemas mecânicos/elétricos.",
                                "Otimização: Problemas minimax em controle robusto."
                              ],
                              "realWorldApplication": "Projeto de controladores robustos para drones, onde incertezas aerodinâmicas (Δ) e specs de rejeição de vento (Wp) são formuladas em [P] para síntese μ-synthesis, garantindo estabilidade apesar de variações de payload."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.3.3.2.3"
                            ]
                          },
                          {
                            "id": "10.1.3.3.3.2",
                            "name": "Aplicar à Estabilização com Coprimes",
                            "description": "Derivar a condição de robustez: existe C estabilizador robusto se ||K||_\fty < 1/\beta, onde K é o grafo do controlador na forma coprime normalizada.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Fatorizações Coprimas e Forma Coprime Normalizada",
                                  "subSteps": [
                                    "Estude as definições de fatorizações coprimas direita (RCR) e esquerda (LCL) para plantas e controladores.",
                                    "Aprenda a normalizar as fatorizações coprimas para que ||[M̃ Ñ]||_∞ = 1 ou ||[Ṽ Ũ]||_∞ = 1.",
                                    "Identifique a forma coprime normalizada do controlador C(s) como [Ṽ Ũ] com grafos normalizados.",
                                    "Revise o lema de estabilização: todo controlador estabilizador pode ser parametrizado via coprimos.",
                                    "Pratique com um exemplo simples de planta estável."
                                  ],
                                  "verification": "Resuma em um diagrama os grafos coprimos normalizados e confirme normalização via norma infinita igual a 1.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Livro de Doyle ou Zhou sobre controle robusto, MATLAB para simulações iniciais",
                                  "tips": "Sempre verifique a coprimidade resolvendo Bezout: existe X,Y tal que X M - N Y = I.",
                                  "learningObjective": "Compreender a representação coprime normalizada como base para análise de robustez.",
                                  "commonMistakes": "Confundir RCR com LCL; esquecer de normalizar as fatorizações."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Construir o Grafo do Controlador K",
                                  "subSteps": [
                                    "Defina K como o grafo do controlador: K = [-C  I; I  0] na forma de transferência.",
                                    "Expresse K em termos das fatorizações coprimas normalizadas: K = [Ũ Ṽ; -Ñ M̃] ou similar.",
                                    "Verifique que K é estável e bipropriedade (grafo bem-possuído).",
                                    "Calcule grafos auxiliares para a planta P: J = [N M; -M̃ Ñ] ou inverso.",
                                    "Integre no problema padrão de estabilização robusta."
                                  ],
                                  "verification": "Desenhe o grafo K e confirme estabilidade computando polos ou usando nyquist.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Folha de papel para diagramas, software como MATLAB Control Toolbox",
                                  "tips": "Use a convenção consistente: prefira grafos à direita para consistência com H∞.",
                                  "learningObjective": "Construir corretamente o grafo K a partir do controlador coprime normalizado.",
                                  "commonMistakes": "Erro nos sinais: o termo superior esquerdo é -C, não C."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular a Norma H-Infinito de K",
                                  "subSteps": [
                                    "Lembre que ||K||_∞ = sup_ω σ̄(K(jω)), onde σ̄ é o valor singular máximo.",
                                    "Use MATLAB (hinfnorm ou sigma) para computar a norma infinita de K.",
                                    "Analise graficamente o diagrama de Bode de σ̄(K(jω)) para identificar picos.",
                                    "Para sistemas de baixa ordem, compute analiticamente via valores singulares.",
                                    "Interprete: ||K||_∞ mede a 'tamanho' do controlador em frequência."
                                  ],
                                  "verification": "Obtenha ||K||_∞ numérico < 1.5 em um exemplo teste e plote o gráfico.",
                                  "estimatedTime": "40 minutos",
                                  "materials": "MATLAB com Robust Control Toolbox, exemplos de Zhou cap. 17",
                                  "tips": "Balance o sistema primeiro com balreal() para precisão numérica.",
                                  "learningObjective": "Dominar o cálculo da norma H∞ para grafos de controladores.",
                                  "commonMistakes": "Confundir com norma 2; não checar estabilidade de K antes."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar e Verificar a Condição de Robustez",
                                  "subSteps": [
                                    "Defina β como o limite de incerteza: ||[Δ1 Δ2]||_∞ < β para perturbações admissíveis.",
                                    "Verifique a condição: existe C robusto se ||K||_∞ < 1/β.",
                                    "Se violada, ajuste o controlador (ex: aumente roll-off ou ganho).",
                                    "Teste com simulações de laço fechado sob perturbações Δ.",
                                    "Documente o valor de γ = ||K||_∞ * β < 1 como margem de robustez."
                                  ],
                                  "verification": "Simule planta nominal e perturbada; confirme estabilidade em ambos.",
                                  "estimatedTime": "35 minutos",
                                  "materials": "MATLAB scripts para loopshaping, banco de plantas teste",
                                  "tips": "Use mu-toolbox para análise estrutural se Δ for bloco.",
                                  "learningObjective": "Derivar e aplicar a condição de robustez coprime em problemas reais.",
                                  "commonMistakes": "Inverter β: é 1/β, não β; ignorar normalização."
                                }
                              ],
                              "practicalExample": "Considere a planta P(s) = 1/(s^2 + 0.2s + 1) com incerteza aditiva ||Δ||_∞ < 0.5 (β=0.5). Projetar C(s) = 10(s+1)/(s+10) em forma coprime normalizada. Construa K, compute ||K||_∞ ≈ 0.8 < 1/0.5=2. Simule laço fechado com Δ=0.4/s+1 estável.",
                              "finalVerifications": [
                                "Derivar corretamente K a partir de coprimos normalizados.",
                                "Calcular ||K||_∞ com precisão numérica <1% de erro.",
                                "Verificar γ = ||K||_∞ * β <1 em exemplo dado.",
                                "Simular estabilidade robusta com perturbação máxima.",
                                "Explicar verbalmente o lema de McFarlane-Glover."
                              ],
                              "assessmentCriteria": [
                                "Precisão na construção de grafos coprimos (100% correta).",
                                "Cálculo exato de ||K||_∞ via software ou analítico.",
                                "Interpretação correta da condição de robustez.",
                                "Qualidade das simulações (plots de step response nominal/perturbado).",
                                "Documentação clara com fórmulas e valores numéricos."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria de operadores lineares e normas em espaços de Hardy.",
                                "Programação: Implementação em MATLAB/Simulink para análise H∞.",
                                "Física: Modelagem dinâmica de sistemas com incertezas paramétricas.",
                                "Estatística: Análise de Monte Carlo para validação de robustez."
                              ],
                              "realWorldApplication": "Em controle de drones, onde incertezas aerodinâmicas (β≈0.3) exigem ||K||_∞ < 3.3 para estabilização robusta sob ventos variáveis, evitando crashes."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.3.3.1.3",
                              "10.1.3.3.3.1"
                            ]
                          },
                          {
                            "id": "10.1.3.3.3.3",
                            "name": "Verificar Estabilização Robusta",
                            "description": "Usar o teorema de robustez de Doyle-McFarlane para checar se \beta > ||[\tilde{K} K]||_\fty, com simulações em MATLAB para plantas com incertezas.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o Teorema de Robustez de Doyle-McFarlane",
                                  "subSteps": [
                                    "Estude a declaração formal do teorema: para sistemas com incertezas normais, a estabilidade é garantida se β > ||[\\tilde{K} K]||_∞.",
                                    "Revise os conceitos de norma H-infinito (∞-norm) e sua interpretação como ganho supremo.",
                                    "Analise as premissas do teorema, incluindo plantas estáveis e controladores próprios.",
                                    "Derive intuitivamente por que a condição β > norma assegura robustez contra perturbações.",
                                    "Resolva um exemplo analítico simples com matrizes 1x1 para fixar o conceito."
                                  ],
                                  "verification": "Explique verbalmente ou por escrito o teorema e resolva um exemplo básico corretamente.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Livro de Doyle ou Skogestad 'Multivariable Feedback Control'",
                                    "Notas de aula sobre normas H-infinito",
                                    "Calculadora simbólica (MATLAB Symbolic Toolbox)"
                                  ],
                                  "tips": "Comece com casos escalares antes de multivariáveis para construir intuição.",
                                  "learningObjective": "Dominar a teoria por trás da condição de robustez de Doyle-McFarlane.",
                                  "commonMistakes": [
                                    "Confundir norma H-infinito com norma 2",
                                    "Ignorar a necessidade de plantas bem-pósicas",
                                    "Esquecer que β relaciona-se à incerteza admissível"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Modelar a Planta com Incertezas",
                                  "subSteps": [
                                    "Defina a planta nominal G(s) em forma de transferência ou estado-espaco.",
                                    "Incorpore incertezas aditivas ou multiplicativas, definindo Δ com ||Δ||_∞ < β.",
                                    "Converta o modelo para a forma padrão de Doyle-McFarlane: P = [G; I] ou similar.",
                                    "Gere matrizes de incerteza paramétrica (ex: variação de 20% em ganhos/polos).",
                                    "Valide o modelo com plots de Bode nominais e incertos."
                                  ],
                                  "verification": "Gere e plote respostas em frequência para nominal e 3 cenários incertos sem instabilidades.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "MATLAB Control System Toolbox",
                                    "Documentação de uncertain models no MATLAB",
                                    "Exemplos de plantas como inversor pendular ou motor DC"
                                  ],
                                  "tips": "Use ureal() e uss() no MATLAB para modelagem uncertaint; visualize com usample().",
                                  "learningObjective": "Construir modelos realistas de plantas com incertezas quantificadas.",
                                  "commonMistakes": [
                                    "Sobrestimar incertezas sem base física",
                                    "Não normalizar incertezas adequadamente",
                                    "Usar modelos discretos em vez de contínuos"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Projetar e Obter o Controlador K e \\tilde{K}",
                                  "subSteps": [
                                    "Projete K usando LQG, H-infinito ou outro método para o nominal.",
                                    "Calcule \\tilde{K} = K (I + G K)^{-1}, a forma de loop aberto equivalente.",
                                    "Forme a matriz coprima [\\tilde{K} K].",
                                    "Verifique estabilidade interna do laço com nyquist() ou sigma().",
                                    "Ajuste K iterativamente se necessário para estabilidade nominal."
                                  ],
                                  "verification": "Confirme que o laço fechado nominal é estável com margens de fase/ganho > 45°/6dB.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "MATLAB hinfsyn() ou lqgr()",
                                    "Funções feedback(), series()",
                                    "Templates de script para robust control"
                                  ],
                                  "tips": "Use loopshaping para facilitar o design inicial de K.",
                                  "learningObjective": "Integrar controlador na estrutura de Doyle-McFarlane corretamente.",
                                  "commonMistakes": [
                                    "Erro na formação de \\tilde{K}",
                                    "Não inverter adequadamente (I + GK)",
                                    "Ignorar singularidades em baixas frequências"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Calcular a Norma H-infinito e Verificar a Condição",
                                  "subSteps": [
                                    "Compute M = [\\tilde{K} K] usando stack ou append no MATLAB.",
                                    "Calcule ||M||_∞ com norm(M, inf) ou hinfnorm().",
                                    "Defina β baseado na magnitude máxima de incertezas (ex: β = 1/max(||Δ||)).",
                                    "Verifique se β > ||M||_∞; se não, ajuste K ou reduza incertezas.",
                                    "Documente os valores numéricos e plots de σ(M(jω))."
                                  ],
                                  "verification": "Obtenha ||M||_∞ < β com evidência numérica e gráfica.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "MATLAB Robust Control Toolbox",
                                    "Função hinfnorm()",
                                    "Scripts de automação para iterações"
                                  ],
                                  "tips": "Plot σ_max(M(jω)) para identificar picos críticos.",
                                  "learningObjective": "Aplicar computação de normas para teste de robustez.",
                                  "commonMistakes": [
                                    "Usar norma errada (ex: 2-norm)",
                                    "Não considerar frequência inteira",
                                    "Arredondamento numérico em sistemas rígidos"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Simular e Validar Robustez em MATLAB",
                                  "subSteps": [
                                    "Gere 50-100 amostras de incertezas com usample(M, 100).",
                                    "Simule respostas temporais para entradas como step ou sinusóide.",
                                    "Analise estabilidade: verifique polos no semiplano esquerdo para todas amostras.",
                                    "Compare desempenho: overshoot <20%, tempo de assentamento <5s.",
                                    "Gere relatório com wcs() para pior caso."
                                  ],
                                  "verification": "100% das simulações incertas estáveis com desempenho dentro de specs.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "MATLAB sim() e stepinfo()",
                                    "Robust Control Toolbox: usim(), wcs()",
                                    "Dados de entrada realistas"
                                  ],
                                  "tips": "Use parfor para aceleração em múltiplas simulações.",
                                  "learningObjective": "Validar teoricamente a robustez via simulações empíricas.",
                                  "commonMistakes": [
                                    "Poucas amostras levando a falsos positivos",
                                    "Ignorar transientes iniciais",
                                    "Não testar entradas saturadas"
                                  ]
                                }
                              ],
                              "practicalExample": "Para um sistema de posicionamento de antena parabólica com incertezas de 15% no ganho do motor e atrito variável, modele G(s) = 1/(s^2 + 0.1s), projete K via H-infinito, compute ||[\\tilde{K} K]||_∞ = 0.8 < β=1.2, e simule 100 casos confirmando estabilidade sob vento/gust loads.",
                              "finalVerifications": [
                                "Explicar corretamente o teorema de Doyle-McFarlane em termos leigos.",
                                "Modelar uma planta com incertezas e plotar respostas incertas.",
                                "Computar ||[\\tilde{K} K]||_∞ <1 para um controlador dado.",
                                "Simular 50 cenários e confirmar 100% estáveis.",
                                "Identificar e corrigir um design não-robusto.",
                                "Gerar relatório com plots de σ(M) e wcs."
                              ],
                              "assessmentCriteria": [
                                "Precisão na computação de normas H-infinito (±1%).",
                                "Qualidade do modelo de incertezas (baseado em dados reais).",
                                "Eficiência das simulações (tempo <10min para 100 runs).",
                                "Correta interpretação de falhas (ex: norma >β).",
                                "Documentação clara com código reproduzível.",
                                "Criatividade em conexões com aplicações reais."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Análise funcional e normas em espaços de Hardy.",
                                "Programação: Otimização numérica e automação em MATLAB.",
                                "Física: Modelagem dinâmica de sistemas mecatrônicos.",
                                "Estatística: Análise de Monte Carlo para incertezas.",
                                "Engenharia de Software: Validação e verificação de código."
                              ],
                              "realWorldApplication": "Em controle de drones autônomos, verifica se o controlador permanece estável apesar de variações em massa de payload ou vento, evitando crashes em missões de vigilância."
                            },
                            "estimatedTime": "2.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.3.3.3.2"
                            ]
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.3.4",
                    "name": "Projeto de Pré e Pós-compensadores",
                    "description": "Seleção de pesos para formatar a singularidade da malha aberta e atender critérios de robustez.",
                    "individualConcepts": [
                      {
                        "id": "10.1.3.4.1",
                        "name": "Pré-compensadores",
                        "description": "Componentes adicionados antes da planta para formatar a singularidade da malha aberta, aproximando o modelo nominal da planta e incorporando incertezas multiplicativas ou aditivas na entrada.",
                        "specificSkills": [
                          {
                            "id": "10.1.3.4.1.1",
                            "name": "Identificar a necessidade de pré-compensação",
                            "description": "Analisar a singularidade da malha aberta (σ(Gl)) para determinar regiões onde a pré-compensação é requerida, com base em critérios de desempenho e robustez para sistemas LIT escalares.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Modelar o sistema LIT escalar e formar a função de malha aberta Gl(s)",
                                  "subSteps": [
                                    "Obtenha a função de transferência da planta Gp(s) a partir dos dados do sistema.",
                                    "Defina o controlador inicial C(s), tipicamente um PID ou proporcional simples.",
                                    "Forme Gl(s) = C(s) * Gp(s) ou Gl(s) = Gp(s) * Kp(s) dependendo da configuração de pré-compensação.",
                                    "Verifique a estabilidade e causalidade de Gl(s) usando polos e zeros.",
                                    "Documente os parâmetros do sistema (ganhos, constantes de tempo)."
                                  ],
                                  "verification": "Confirme que Gl(s) está corretamente derivada comparando com simulações iniciais de resposta em malha aberta.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Função de transferência da planta",
                                    "Software de controle como MATLAB/Simulink",
                                    "Papel e calculadora para cálculos simbólicos"
                                  ],
                                  "tips": "Sempre normalize unidades e verifique dimensões para evitar erros de escala.",
                                  "learningObjective": "Compreender como compor a malha aberta para análise de pré-compensação.",
                                  "commonMistakes": [
                                    "Esquecer de incluir atrasos ou não-linearidades aproximadas",
                                    "Invertar a ordem de cascata planta-controlador",
                                    "Ignorar pólos instáveis iniciais"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Definir critérios de desempenho e robustez para o sistema",
                                  "subSteps": [
                                    "Estabeleça limites de ganho desejados (ex: |σ(Gl)| < 1 em baixas frequências para tracking).",
                                    "Defina margens de fase e ganho mínimas (ex: 45° fase, 6dB ganho).",
                                    "Especifique largura de banda alvo e rejeição de distúrbios.",
                                    "Considere robustez a variações paramétricas (ex: ±20% em ganhos).",
                                    "Documente os critérios em uma tabela de especificações."
                                  ],
                                  "verification": "Crie um template de critérios e valide com um sistema de referência conhecido.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Literatura de controle (ex: Franklin ou Doyle)",
                                    "Planilha Excel para tabelas",
                                    "Gráficos de especificações padrão"
                                  ],
                                  "tips": "Priorize critérios conflitantes usando trade-offs quantitativos como índice de desempenho.",
                                  "learningObjective": "Selecionar métricas relevantes para análise de singularidade em robustez.",
                                  "commonMistakes": [
                                    "Definir critérios muito ambiciosos sem base física",
                                    "Ignorar frequências de interesse específicas do aplicativo",
                                    "Confundir critérios de malha aberta com malha fechada"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular e plotar os valores singulares σ(Gl(jω)) ao longo do espectro de frequências",
                                  "subSteps": [
                                    "Use sigma(Gl(jω)) no MATLAB ou equivalente para SISO (|Gl(jω)|).",
                                    "Gere vetor de frequências log-espacial de 10^-2 a 10^2 rad/s.",
                                    "Plote σ(Gl(jω)) em escala log-log e Bode plot associado.",
                                    "Calcule estatísticas: picos, cruzamentos de ganho 0dB, inclinação em baixas/altas frequências.",
                                    "Anote regiões de interesse (ex: ressonâncias, roll-off inadequado)."
                                  ],
                                  "verification": "Compare o plot com simulação numérica e verifique consistência em pontos amostrados.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "MATLAB com Control Systems Toolbox",
                                    "Python com control library (opcional)",
                                    "Templates de scripts para sigma plot"
                                  ],
                                  "tips": "Use logspace para frequências para capturar dinâmicas em todas as escalas.",
                                  "learningObjective": "Dominar a computação e visualização de singular values para análise de malha aberta.",
                                  "commonMistakes": [
                                    "Escala linear em frequência em vez de log",
                                    "Plotar apenas magnitude sem fase",
                                    "Não estender faixa de frequência suficiente"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar σ(Gl(jω)) e identificar regiões requerendo pré-compensação",
                                  "subSteps": [
                                    "Sobreponha os plots de σ(Gl) aos critérios de desempenho.",
                                    "Identifique violações: ex: σ(Gl) > limite em médias frequências (ruim para robustez).",
                                    "Classifique regiões: baixa freq (tracking), média (distúrbios), alta (ruído).",
                                    "Justifique necessidade de pré-compensador (ex: notch para picos, integrator para DC gain).",
                                    "Registre recomendações específicas de pré-compensação por região."
                                  ],
                                  "verification": "Produza um relatório resumido com regiões destacadas e justificativas.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Plots gerados do Step 3",
                                    "Ferramenta de edição de imagens para anotações",
                                    "Checklist de critérios"
                                  ],
                                  "tips": "Use setas e cores nos plots para destacar violações claramente.",
                                  "learningObjective": "Interpretar desvios em σ(Gl) para decisões de design de compensadores.",
                                  "commonMistakes": [
                                    "Atribuir causalidade errada a violações",
                                    "Recomendar compensação sem ligação direta à métrica",
                                    "Ignorar trade-offs entre regiões"
                                  ]
                                }
                              ],
                              "practicalExample": "Para um servo-motor com Gp(s) = 100 / (s(s+10)), controlador P=1, forme Gl(s)=100/(s(s+10)). Plote σ(Gl(jω))=|Gl(jω)|, observe alto ganho em baixas frequências (>1, ruim para estabilidade) e roll-off lento em altas; identifique necessidade de pré-compensador integrador em baixa freq e lead em alta.",
                              "finalVerifications": [
                                "Pode derivar Gl(s) corretamente para um sistema dado.",
                                "Gera plots precisos de σ(Gl(jω)) com MATLAB.",
                                "Identifica pelo menos 2 regiões de violação com justificativa.",
                                "Liga violações a critérios específicos de robustez/desempenho.",
                                "Propõe tipo correto de pré-compensador por região.",
                                "Valida análise com simulação de sensibilidade paramétrica."
                              ],
                              "assessmentCriteria": [
                                "Precisão na formação e cálculo de Gl(s) (20%)",
                                "Qualidade e completude dos plots de singular values (25%)",
                                "Correta identificação e classificação de regiões problemáticas (25%)",
                                "Justificativas baseadas em teoria de controle robusto (15%)",
                                "Clareza do relatório e recomendações acionáveis (15%)"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria de valores singulares e análise em frequência",
                                "Programação: Simulações numéricas em MATLAB/Python para controle",
                                "Física: Modelagem dinâmica de sistemas mecânicos/elétricos",
                                "Estatística: Análise de sensibilidade e Monte Carlo para robustez",
                                "Design de Engenharia: Trade-offs em especificações de sistemas"
                              ],
                              "realWorldApplication": "Em automação industrial, como controle de velocidade de motores em linhas de montagem, identificar regiões onde σ(Gl) excede limites permite adicionar pré-compensadores para prevenir oscilações sob variações de carga, garantindo robustez e downtime mínimo."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.4.1.2",
                            "name": "Selecionar pesos de entrada para planta nominal",
                            "description": "Projetar funções de peso W1(s) que aproximem a dinâmica da planta nominal P(s), garantindo que |W1(jω)| ≈ |P(jω)| em todo o espectro de frequências relevante.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Identificar o espectro de frequências relevante da planta nominal P(s)",
                                  "subSteps": [
                                    "Analise as especificações do sistema para determinar faixas de frequência de interesse (baixa, média e alta).",
                                    "Calcule ou obtenha o modelo transfer function P(s) da planta nominal.",
                                    "Plote o diagrama de Bode de P(s) focando em |P(jω)|.",
                                    "Defina limites de frequência ω_min e ω_max baseados em requisitos de desempenho (ex.: largura de banda desejada).",
                                    "Documente o espectro relevante com valores numéricos aproximados."
                                  ],
                                  "verification": "Confirme que o diagrama de Bode cobre o espectro relevante e anote ω_min, ω_max e ganhos chave.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Software de análise (MATLAB/Simulink, Python com control library), modelo P(s), especificações do sistema.",
                                  "tips": "Comece com frequências onde o ganho é unitário para priorizar matching.",
                                  "learningObjective": "Compreender o espectro de frequências crítico para o design de controladores robustos.",
                                  "commonMistakes": "Ignorar frequências altas onde ruído é dominante ou baixas onde distúrbios ocorrem."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar a resposta em magnitude |P(jω)| no espectro relevante",
                                  "subSteps": [
                                    "Gere o plot de Bode de magnitude de P(s) em escala log-log.",
                                    "Identifique slopes assintóticos (ex.: -20 dB/década) e cantos de frequência.",
                                    "Meça ganhos em pontos chave (DC gain, crossover frequency, high-frequency roll-off).",
                                    "Ajuste a resolução do plot para capturar detalhes finos no espectro.",
                                    "Registre dados tabulares de |P(jω)| em pelo menos 10 pontos por década."
                                  ],
                                  "verification": "Verifique se o plot de Bode é suave e cobre 4-6 décadas de frequência com marcações precisas.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Ferramentas de plotting (MATLAB bode(), Python bode_plot), papel milimetrado para esboços manuais.",
                                  "tips": "Use zoom em regiões de interesse para precisão; evite plots lineares.",
                                  "learningObjective": "Dominar análise em frequência para caracterizar dinâmica de plantas.",
                                  "commonMistakes": "Usar escala errada (linear vs log) ou esquecer de normalizar unidades."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Projetar a forma inicial de W1(s) para aproximar |P(jω)|",
                                  "subSteps": [
                                    "Escolha ordem de W1(s) biprópria (ex.: 1ª ou 2ª ordem) baseada na complexidade de P(s).",
                                    "Defina estrutura: W1(s) = k * (Ts + 1)/(αTs + 1) para matching de ganho e fase relativa.",
                                    "Inicialize parâmetros: k ≈ ganho DC de P, T ≈ tempo dominante de P.",
                                    "Plote |W1(jω)| inicial sobreposto a |P(jω)|.",
                                    "Ajuste heurísticas: α >1 para roll-off similar."
                                  ],
                                  "verification": "A forma inicial deve matching aproximado (>70%) em pelo menos 3 pontos chave.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "MATLAB/Simulink ou Python (sympy para manipulação simbólica), templates de funções de peso.",
                                  "tips": "Prefira formas simples; overparameterize só se necessário para matching preciso.",
                                  "learningObjective": "Aprender a selecionar estruturas de funções de peso para H∞ design.",
                                  "commonMistakes": "Escolher ordem muito alta levando a il-condicionamento numérico."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Otimizar parâmetros de W1(s) para minimizar erro de aproximação",
                                  "subSteps": [
                                    "Defina métrica de erro: ∫ log(|W1(jω)/P(jω)|) dω ou max error em dB.",
                                    "Use otimização numérica (fminsearch em MATLAB, scipy.optimize em Python).",
                                    "Itere ajustes manuais em parâmetros (ganho, polos/zeros) baseados em resíduos do Bode plot.",
                                    "Valide em todo espectro: erro < 3dB em 80% da faixa.",
                                    "Salve W1(s) final em forma simbólica e numérica."
                                  ],
                                  "verification": "Erro médio < 2dB e max < 5dB no espectro relevante via plot sobreposto.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Otimizadores (MATLAB Optimization Toolbox, Python scipy), scripts de erro.",
                                  "tips": "Comece com otimização grossa, refine com bounds nos parâmetros.",
                                  "learningObjective": "Aplicar técnicas de otimização em design de controladores.",
                                  "commonMistakes": "Otimizar só em pontos discretos ignorando comportamento contínuo."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Validar e documentar o design de W1(s)",
                                  "subSteps": [
                                    "Simule resposta em frequência combinada em loop fechado simulado.",
                                    "Compare sensibilidade shaped por W1 vs sem.",
                                    "Teste robustez variando P(s) em ±20%.",
                                    "Documente W1(s), plots e métricas em relatório.",
                                    "Arquive código e dados para reprodutibilidade."
                                  ],
                                  "verification": "W1(s) mantém |W1(jω)| ≈ |P(jω)| e melhora shaping em simulações.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Simulink/Python simulation environment, LaTeX/Word para relatório.",
                                  "tips": "Sempre teste com perturbações para validar robustez.",
                                  "learningObjective": "Garantir qualidade e reprodutibilidade em designs de controle.",
                                  "commonMistakes": "Pular validação robusta assumindo matching perfeito."
                                }
                              ],
                              "practicalExample": "Para uma planta nominal de motor DC P(s) = 1000 / (s(s+10)(s+100)), o espectro relevante é 0.1-100 rad/s. Projetamos W1(s) = 10*(0.1s+1)/(0.01s+1), ajustando para matching: ganho DC=10, canto baixo em 10 rad/s, roll-off similar. Plots de Bode mostram erro <2dB de 1-50 rad/s.",
                              "finalVerifications": [
                                "Plots de Bode sobrepostos mostram |W1(jω)| ≈ |P(jω)| com erro <3dB no espectro relevante.",
                                "Métrica de erro integral < 0.5 (normalizada).",
                                "W1(s) é biprópria (lim s→∞ W1=constante finita).",
                                "Simulação em loop fechado com W1 melhora peaking de sensibilidade.",
                                "Documentação inclui equações, plots e código fonte.",
                                "Teste de sensibilidade a variações de P(s) mantém matching."
                              ],
                              "assessmentCriteria": [
                                "Precisão do matching: erro médio <2dB (40%).",
                                "Cobertura do espectro: matching em >80% da faixa relevante (20%).",
                                "Simplicidade da função W1(s): ordem mínima efetiva (15%).",
                                "Validação robusta: performance sob ±20% variação em P (15%).",
                                "Documentação e reprodutibilidade: código executável e relatório claro (10%)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Análise de Fourier e otimização não-linear.",
                                "Programação: Uso de bibliotecas de controle (MATLAB Control System Toolbox, Python Control).",
                                "Física: Dinâmica de sistemas lineares invariantes no tempo.",
                                "Engenharia de Software: Boas práticas em simulação e versionamento de modelos."
                              ],
                              "realWorldApplication": "Em controle robusto H∞ para aeronaves, W1(s) modela dinâmica do atuador (planta nominal), permitindo sintetizar controladores que rejeitam distúrbios e incertezas, como em flight control systems da Boeing ou drones autônomos."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.4.1.3",
                            "name": "Incorporar incertezas na pré-compensação",
                            "description": "Modelar incertezas na entrada da planta com pesos relativos δ(s), definindo W2(s) = |δ(s)| * |P(s)| para capturar variações paramétricas ou não-paramétricas na formatação de malha.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender Tipos de Incertezas na Planta",
                                  "subSteps": [
                                    "Identifique incertezas paramétricas (ex.: variação de ganho, polos/zeros) e não-paramétricas (ex.: dinâmica não modelada).",
                                    "Revise o modelo nominal da planta P(s) e colete dados de variação real de parâmetros de simulações ou experimentos.",
                                    "Classifique as incertezas como aditivas, multiplicativas ou inversas, focando em relativas para pré-compensação.",
                                    "Plote magnitude e fase de P(s) nominal vs. casos perturbados para visualizar o envelope de incerteza.",
                                    "Documente o tamanho relativo das incertezas em frequência (ex.: ±20% em baixas frequências)."
                                  ],
                                  "verification": "Confirme com gráficos de Bode mostrando envelope de incerteza ao redor de P(s) nominal.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": "MATLAB/Simulink, dados experimentais da planta, livro 'Multivariable Feedback Control' de Skogestad.",
                                  "tips": "Comece com incertezas paramétricas simples antes de adicionar não-paramétricas para construir intuição.",
                                  "learningObjective": "Diferenciar e quantificar incertezas paramétricas e não-paramétricas na planta de controle.",
                                  "commonMistakes": "Ignorar incertezas em altas frequências, levando a modelos subestimados."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Definir Pesos Relativos de Incerteza δ(s)",
                                  "subSteps": [
                                    "Defina δ(s) como a perturbação relativa normalizada: |δ(jω)| ≈ |ΔP(jω)/P(jω)|, com ||δ||_∞ ≤ 1.",
                                    "Estime |δ(jω)| a partir do envelope de incerteza plotado no passo anterior.",
                                    "Ajuste δ(s) para capturar o pior caso de variação paramétrica (ex.: ganho, tempo morto).",
                                    "Valide δ(s) interpolando pontos de frequência crítica e suavizando com filtro de ordem baixa.",
                                    "Teste com múltiplos cenários perturbados para garantir que todos caibam dentro de |δ(jω)|."
                                  ],
                                  "verification": "Verifique se todos os modelos perturbados P_pert satisfazem | (P_pert - P)/P | ≤ |δ(jω)| em diagrama de Bode.",
                                  "estimatedTime": "2 horas",
                                  "materials": "MATLAB (bodeplot, norm), planilhas com dados de variação paramétrica.",
                                  "tips": "Use log-log para visualizar |δ(jω)| e priorize frequências de crossover do loop.",
                                  "learningObjective": "Modelar incertezas relativas como δ(s) normalizada para análise robusta.",
                                  "commonMistakes": "Superestimar δ(s) em todo o espectro, resultando em controladores conservadores."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Construir o Peso de Incerteza W2(s)",
                                  "subSteps": [
                                    "Defina W2(s) = |δ(s)| * |P(s)| conforme a formatação de malha para incertezas multiplicativas.",
                                    "Implemente W2(s) como função de transferência: escolha ordem baixa (ex.: 1-2 polos) para encaixar |δ(jω)| * |P(jω)|.",
                                    "Ajuste parâmetros de W2(s) minimizando erro entre |W2(jω)| e o envelope desejado via otimização.",
                                    "Plote |W2(jω)| sobreposto ao envelope de incerteza para validação visual.",
                                    "Garanta que W2(s) seja estável e próprio, com roll-off adequado em altas frequências."
                                  ],
                                  "verification": "Confirme que o diagrama de Bode de W2(s) envolve superiormente todas as perturbações reais.",
                                  "estimatedTime": "2.5 horas",
                                  "materials": "MATLAB (tf, bode, fminsearch para fitting), modelo P(s).",
                                  "tips": "Inicie com W2(s) = k / (s/ω_c + 1) para capturar picos em baixas frequências.",
                                  "learningObjective": "Construir W2(s) explicitamente para representar o tamanho das incertezas na entrada da planta.",
                                  "commonMistakes": "Confundir W2(s) com peso de performance W1(s), misturando robustez e desempenho."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Integrar W2(s) na Pré-Compensação e Formatação de Malha",
                                  "subSteps": [
                                    "Incorpore W2(s) na estrutura de malha: considere P(s) (1 + W2(s) Δ(s)) com ||Δ||_∞ ≤ 1.",
                                    "Projete o pré-compensador C(s) considerando W2(s) no loop aberto L(s) = C(s) P(s).",
                                    "Aplique critérios de robustez (ex.: |T(jω)| < 1/|W2(jω)| para estabilidade robusta).",
                                    "Simule respostas em malha fechada para P nominal e perturbadas.",
                                    "Ajuste C(s) iterativamente para atender margins com W2(s) incluso."
                                  ],
                                  "verification": "Simulações mostram estabilidade e desempenho similar para todas perturbações dentro de W2(s).",
                                  "estimatedTime": "3 horas",
                                  "materials": "Simulink para simulação, toolbox Robust Control.",
                                  "tips": "Use μ-síntese se necessário, mas foque em H∞ simples para pré-compensadores.",
                                  "learningObjective": "Integrar W2(s) no projeto de pré-compensador para robustez na formatação de malha.",
                                  "commonMistakes": "Esquecer de escalar P(s) por W2(s) nas simulações de pior caso."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Validar e Refinar a Modelagem de Incertezas",
                                  "subSteps": [
                                    "Execute análise de robustez: compute margens de estabilidade com W2(s).",
                                    "Teste com conjunto de plantas perturbadas geradas via Monte Carlo.",
                                    "Avalie sensibilidade: perturbe δ(s) ±10% e verifique impacto no desempenho.",
                                    "Documente relatório com gráficos de Bode, step responses e métricas (ex.: ||S||_∞, ||T||_∞).",
                                    "Refine W2(s) se necessário para melhor ajuste."
                                  ],
                                  "verification": "Todas simulações perturbadas mantêm overshoot <20%, settling time <5s.",
                                  "estimatedTime": "2 horas",
                                  "materials": "MATLAB Robust Control Toolbox, scripts de simulação personalizados.",
                                  "tips": "Automatize testes com loops for para eficiência.",
                                  "learningObjective": "Validar a eficácia de W2(s) na captura de incertezas reais.",
                                  "commonMistakes": "Validar apenas no nominal, ignorando cenários de borda."
                                }
                              ],
                              "practicalExample": "Para uma planta de motor DC P(s) = 1000 / (s(s+10)), com variação de ganho ±20% e polo adicional em altas frequências. Estime δ(s) ≈ 0.3 * (s/10 +1)/(s/100 +1), então W2(s) = |δ(s)| * |P(s)|. Projetar C(s) tal que |T| < 1/|W2| garante robustez.",
                              "finalVerifications": [
                                "Envelope de incertezas está contido em |W2(jω)| no diagrama de Bode.",
                                "Malha fechada estável para 10 plantas perturbadas aleatórias dentro de δ(s).",
                                "Margem de ganho > 6dB e fase > 45° considerando W2(s).",
                                "Resposta ao degrau nominal e perturbado tem erro <5%.",
                                "W2(s) tem ordem mínima e roll-off suave.",
                                "Análise μ confirma robustez estruturada."
                              ],
                              "assessmentCriteria": [
                                "Precisão do fitting de W2(s) ao envelope (erro <2dB).",
                                "Número de steps bem-sucedidos sem erros comuns.",
                                "Qualidade das simulações: desempenho robusto quantificado.",
                                "Documentação completa com gráficos e justificativas.",
                                "Criatividade em conexões interdisciplinares.",
                                "Tempo total dentro de 11 horas estimadas."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Análise de funções complexas e normas H∞.",
                                "Probabilidade: Modelagem estocástica de variações paramétricas.",
                                "Física: Dinâmica de sistemas reais com ruído e não-linearidades.",
                                "Informática: Otimização numérica e simulação em MATLAB."
                              ],
                              "realWorldApplication": "Em automação industrial, como controle de velocidade de motores em linhas de produção, onde variações de carga e temperatura alteram parâmetros da planta, garantindo operação estável sem retuning manual."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.4.1.4",
                            "name": "Validar pré-compensador via singularidade",
                            "description": "Verificar se a pré-compensação resulta em σ(Gl) próxima de 1 na banda de crossover desejada, usando ferramentas como Bode ou singular value plots no MATLAB.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar o modelo do sistema em malha fechada com pré-compensador",
                                  "subSteps": [
                                    "Identifique a planta G(s) e o pré-compensador C(s) do sistema.",
                                    "Forme o loop aberto Gl(s) = C(s) * G(s).",
                                    "Defina a frequência de crossover desejada ω_c.",
                                    "Verifique a estabilidade inicial do sistema sem compensação.",
                                    "Documente os parâmetros numéricos ou simbólicos."
                                  ],
                                  "verification": "Modelo Gl(s) implementado corretamente e estável em simulação básica.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "MATLAB com Control System Toolbox",
                                    "Especificações do sistema (G(s), C(s), ω_c)"
                                  ],
                                  "tips": "Use tf() ou ss() para modelos de transferência ou estado-espaço para precisão.",
                                  "learningObjective": "Compreender a composição do loop de controle para análise de singularidades.",
                                  "commonMistakes": [
                                    "Esquecer de incluir o pré-compensador no loop",
                                    "Usar frequência errada de crossover",
                                    "Não linearizar modelos não-lineares"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Configurar o ambiente MATLAB para análise de valores singulares",
                                  "subSteps": [
                                    "Abra o MATLAB e carregue o Control System Toolbox.",
                                    "Defina o modelo Gl(s) usando comandos como sys = tf(num, den).",
                                    "Gere o vetor de frequências ω com logspace(0.1, 10, 1000) incluindo ω_c.",
                                    "Prepare a função sigma(sys, ω) para plot de valores singulares.",
                                    "Teste a sintaxe com um plot simples."
                                  ],
                                  "verification": "Comando sigma() executa sem erros e gera dados preliminares.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "MATLAB instalado",
                                    "Documentação do Control System Toolbox"
                                  ],
                                  "tips": "Use sigma(sys, ω) em vez de bode para MIMO ou análise robusta.",
                                  "learningObjective": "Dominar ferramentas MATLAB para análise em frequência de loops de controle.",
                                  "commonMistakes": [
                                    "Intervalo de frequências inadequado",
                                    "Confundir sigma com bode",
                                    "Não incluir ponto exato de ω_c"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Gerar e visualizar o plot de valores singulares σ(Gl(jω))",
                                  "subSteps": [
                                    "Execute [σ, σU, σL] = sigma(Gl, ω);",
                                    "Plote semilogx(ω, 20*log10(σ)) para magnitude em dB.",
                                    "Adicione grid, labels e destaque ω_c com linha vertical.",
                                    "Verifique o valor máximo e mínimo de σ na vizinhança de ω_c.",
                                    "Salve a figura como PNG para relatório."
                                  ],
                                  "verification": "Plot gerado mostra σ(Gl) claramente na banda de crossover.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Script MATLAB pronto",
                                    "Ferramenta de plot como semilogx"
                                  ],
                                  "tips": "Use mag2db(σ) para escala em dB e facilitar leitura.",
                                  "learningObjective": "Interpretar visualmente singular values para robustez.",
                                  "commonMistakes": [
                                    "Escala errada (linear vs log)",
                                    "Não destacar ω_c",
                                    "Plotar bode em vez de sigma"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar e validar a pré-compensação na banda de crossover",
                                  "subSteps": [
                                    "Identifique σ(Gl(jω_c)) e verifique se está próxima de 1 (0.8-1.2 ideal).",
                                    "Analise o diâmetro da banda: max(σ)/min(σ) < 2 para bom condicionamento.",
                                    "Compare com critérios de robustez (ex: ganho de fase).",
                                    "Se não atender, sugira ajustes no C(s) e reexecute.",
                                    "Registre conclusões em relatório com valores exatos."
                                  ],
                                  "verification": "Relatório confirma σ(Gl(jω_c)) ≈ 1 e recomendações claras.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Plot gerado",
                                    "Critérios de aceitação definidos"
                                  ],
                                  "tips": "Use findpeaks() para detectar picos automáticos em σ.",
                                  "learningObjective": "Avaliar efetividade da pré-compensação via singularidade.",
                                  "commonMistakes": [
                                    "Ignorar variação de σ na banda",
                                    "Aceitar valores fora de tolerância",
                                    "Não documentar numericamente"
                                  ]
                                }
                              ],
                              "practicalExample": "Para um motor DC com G(s) = 100/(s(s+10)) e pré-compensador C(s) = 0.1(s+5)/(s+50), defina ω_c = 5 rad/s. No MATLAB: Gl = C*G; ω = logspace(-1,2,1000); sigma(Gl,ω). Verifique se σ(Gl(j5)) ≈ 1 dB (0 dB ideal).",
                              "finalVerifications": [
                                "σ(Gl(jω_c)) está entre -2 dB e +2 dB (próxima de 1).",
                                "Diâmetro da singular value na banda ±10% ω_c é < 6 dB.",
                                "Não há picos indesejados > 6 dB em baixas frequências.",
                                "Plot de Bode correlaciona com sigma (fase ok).",
                                "Sistema permanece estável em simulação de resposta ao degrau.",
                                "Relatório inclui valores exatos e figura anotada."
                              ],
                              "assessmentCriteria": [
                                "Precisão na modelagem de Gl(s) (sem erros numéricos).",
                                "Correta geração e interpretação do plot sigma.",
                                "Análise quantitativa rigorosa de σ em ω_c.",
                                "Identificação de problemas e sugestões de melhoria.",
                                "Documentação clara e profissional.",
                                "Tempo de execução dentro do estimado."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria de valores singulares e análise em frequência.",
                                "Programação: Scripting avançado em MATLAB e visualização de dados.",
                                "Física: Modelagem dinâmica de sistemas de controle.",
                                "Estatística: Métricas de robustez e incerteza em frequências.",
                                "Engenharia de Software: Validação automatizada de controladores."
                              ],
                              "realWorldApplication": "Na indústria aeroespacial, validação via singularidade garante que controladores de atitude de satélites mantenham ganho unitário em bandas críticas apesar de variações paramétricas, evitando instabilidades em órbita."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.3.4.2",
                        "name": "Pós-compensadores",
                        "description": "Componentes adicionados após a planta para especificar os desejos de desempenho na sensibilidade e robustez, formatando a singularidade da malha aberta para atender normas H∞ ou μ.",
                        "specificSkills": [
                          {
                            "id": "10.1.3.4.2.1",
                            "name": "Definir pós-compensador para sensibilidade",
                            "description": "Projetar peso W3(s) para a sensibilidade S(s), garantindo atenuação de distúrbios em baixas frequências e bom condicionamento em altas frequências.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Analisar o modelo do sistema e especificações de sensibilidade",
                                  "subSteps": [
                                    "Obtenha o modelo de planta G(s) e o controlador C(s) preliminar.",
                                    "Calcule a sensibilidade S(s) = 1/(1 + G(s)C(s)P(s)) usando ferramentas como Bode plot.",
                                    "Identifique faixas de frequência: baixa (distúrbios) e alta (condicionamento).",
                                    "Defina requisitos quantitativos: atenuação >20dB em ω<ω_c e |W3 S| <0dB em ω>10ω_c.",
                                    "Documente o perfil desejado de |W3(jω)| no diagrama de Bode."
                                  ],
                                  "verification": "Confirme que o diagrama de Bode de S(s) atual atende parcialmente e destaque gaps.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Software MATLAB/Simulink, modelo G(s), especificações do problema.",
                                  "tips": "Use log-log scale para visualizar melhor as magnitudes em frequências extremas.",
                                  "learningObjective": "Compreender como S(s) afeta rejeição de distúrbios e robustez.",
                                  "commonMistakes": "Ignorar fase de S(s) inicialmente; focar só em magnitude."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Definir a forma e estrutura do peso W3(s)",
                                  "subSteps": [
                                    "Escolha estrutura: filtro passa-baixa de 1ª ou 2ª ordem para atenuação em baixa frequência.",
                                    "Defina ganho DC alto para amplificar sensibilidade em LF (ex: |W3(0)|=10).",
                                    "Coloque polos em ω_p ≈ 0.1 ω_c para roll-off suave.",
                                    "Adicione zero em alta frequência se necessário para condicionamento.",
                                    "Esboce manualmente |W3(jω)| sobreposto a 1/|S(jω)| desejado."
                                  ],
                                  "verification": "Verifique se |W3(jω)| ≈ 1/|S_desejada(jω)| nas faixas críticas.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Papel milimetrado ou MATLAB para esboço de Bode.",
                                  "tips": "Comece com ordem baixa; aumente complexidade só se necessário.",
                                  "learningObjective": "Selecionar estruturas de filtro otimizadas para especificações de sensibilidade.",
                                  "commonMistakes": "Ganho DC muito alto causando instabilidade; polos muito próximos de ω_c."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Sintetizar parâmetros do W3(s) e otimizar",
                                  "subSteps": [
                                    "Inicialize parâmetros: ganho k, polo ω_p, zero ω_z via otimização manual.",
                                    "Use função de custo: ∫ |20log|W3 S| - spec| dω sobre faixas.",
                                    "Ajuste iterativamente com loop optimizer no MATLAB (fmincon).",
                                    "Inclua restrições: ordem máxima 2, fase mínima -90°.",
                                    "Gere equação final W3(s) = k (s+ω_z)/(s+ω_p)."
                                  ],
                                  "verification": "Simule |W3(jω) S(jω)| e confirme atenuação > spec em LF e <0dB em HF.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "MATLAB Optimization Toolbox, script de simulação Bode.",
                                  "tips": "Use grid search inicial para bounds antes de otimização não-linear.",
                                  "learningObjective": "Aplicar otimização para ajuste preciso de pesos de desempenho.",
                                  "commonMistakes": "Sobre-otimizar uma faixa ignorando trade-offs com outras funções (ex: T(s))."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Validar e refinar o pós-compensador W3(s)",
                                  "subSteps": [
                                    "Integre W3(s) na malha H∞ ou LQG e resolva o problema de síntese.",
                                    "Analise singular values de sensibilidade ponderada ||W3 S||_∞ <1.",
                                    "Teste robustez com variações de planta (±20%).",
                                    "Simule resposta a step distúrbio em tempo discreto.",
                                    "Ajuste se ||W3 S||_∞ >1 ou overshoot excessivo."
                                  ],
                                  "verification": "||W3 S||_∞ ≤1 e simulações em tempo mostram rejeição rápida de distúrbios.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Simulink para simulação temporal, hinfsyn() no MATLAB Robust Control Toolbox.",
                                  "tips": "Sempre cheque γ = ||[W1;W2;W3]|| <1 para feasibility.",
                                  "learningObjective": "Validar design em contexto completo da malha de controle.",
                                  "commonMistakes": "Validar só em frequência, ignorando simulações em tempo."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Documentar e preparar para implementação",
                                  "subSteps": [
                                    "Escreva equação W3(s) com parâmetros numéricos.",
                                    "Gere relatório com Bodes antes/depois e γ final.",
                                    "Discuta trade-offs com outros pesos (W1, W2).",
                                    "Planeje discretização para implementação digital.",
                                    "Arquive código e plots para revisão."
                                  ],
                                  "verification": "Relatório completo com todos plots e γ<1 assinado.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "LaTeX ou Word para relatório, Git para versionamento.",
                                  "tips": "Inclua sensibilidade a parâmetros para análise de robustez.",
                                  "learningObjective": "Comunicar design de forma profissional e reprodutível.",
                                  "commonMistakes": "Omitir unidades ou contexto de frequências no relatório."
                                }
                              ],
                              "practicalExample": "Para um servo-motor DC com G(s)=1/(s(s+1)), controleur PI preliminar, defina W3(s)=10(s+10)/(s+0.1) para atenuar distúrbios em ω<1 rad/s (ruído de carga) e condicionar em ω>10 rad/s, resultando em ||W3 S||_∞=0.9 após síntese H∞.",
                              "finalVerifications": [
                                "|W3(jω) S(jω)| < -20dB para ω < 0.1 ω_c (atenuação LF).",
                                "|W3(jω) S(jω)| < 0dB para ω > 10 ω_c (condicionamento HF).",
                                "||W3 S||_∞ ≤ 1 confirmando feasibility da síntese.",
                                "Fase de W3(s) não introduz mais de 45° de atraso em ω_c.",
                                "Resposta temporal a distúrbio unitário: settling time < 2s sem overshoot >10%.",
                                "Robustez: γ varia <10% com ΔG=±20%.",
                                "Equação W3(s) implementável em ordem ≤2."
                              ],
                              "assessmentCriteria": [
                                "Precisão na modelagem de S(s): erro <5% em magnitude Bode.",
                                "Adequação de estrutura W3(s): ordem mínima com specs atendidas.",
                                "Eficiência de otimização: convergência em <10 iterações.",
                                "Qualidade de validação: todos checks passados com margem >10%.",
                                "Clareza da documentação: relatório auto-contido e reproduzível.",
                                "Trade-offs considerados: impacto mínimo em KS ou T(s).",
                                "Criatividade: solução inovadora se specs conflictantes."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Análise complexa e otimização não-linear (fmincon).",
                                "Programação: Scripts MATLAB para automação de Bodes e síntese.",
                                "Física: Modelagem dinâmica de sistemas (Laplace, frequências).",
                                "Estatística: Análise de Monte Carlo para robustez.",
                                "Gestão de Projetos: Documentação e versionamento com Git."
                              ],
                              "realWorldApplication": "Em plantas químicas, W3(s) projetado assim reduz impacto de variações de carga em reatores, mantendo precisão de temperatura ±0.1°C apesar de distúrbios em baixa frequência, como usado em refinarias da Petrobras."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.4.2.2",
                            "name": "Selecionar pesos para robustez de desempenho",
                            "description": "Escolher W4(s) para a sensibilidade complementar T(s), limitando picos de ressonância e garantindo estabilidade robusta frente a incertezas aditivas na saída.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Conceitos Fundamentais de Sensibilidade Complementar T(s)",
                                  "subSteps": [
                                    "Calcule T(s) = 1 - S(s) a partir do controlador projetado C(s) e planta P(s).",
                                    "Analise o diagrama de Bode de T(s) para identificar picos de ressonância.",
                                    "Estude o impacto de incertezas aditivas na saída Δy sobre a estabilidade.",
                                    "Revise o critério de robustez: ||W4(s) T(s)||_∞ < 1 para garantir estabilidade.",
                                    "Simule respostas em malha fechada com ruído aditivo para observar efeitos."
                                  ],
                                  "verification": "Confirme que o gráfico de Bode de T(s) mostra picos claros e que você pode explicar verbalmente o papel de T(s) em robustez.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": "MATLAB/Simulink, notas de aula sobre controle H-infinito, planta P(s) exemplo.",
                                  "tips": "Use logspace para frequências completas no Bode para não perder picos altos.",
                                  "learningObjective": "Compreender o significado físico e matemático de T(s) em relação a incertezas aditivas.",
                                  "commonMistakes": "Confundir T(s) com S(s); ignorar fase no Bode plot."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar Frequências Críticas de Ressonância em T(s)",
                                  "subSteps": [
                                    "Plote magnitude e fase de T(s) em escala logarítmica.",
                                    "Meça as frequências ω_r onde |T(jω_r)| > 1 (picos de ressonância).",
                                    "Estime o ganho máximo de T(s) nos picos identificados.",
                                    "Avalie largura de banda dos picos para definir roll-off de W4(s).",
                                    "Documente tabela com ω_r, |T|_max e razões físicas (ex: modos não amortecidos)."
                                  ],
                                  "verification": "Crie uma tabela com pelo menos 2-3 picos identificados e seus valores exatos.",
                                  "estimatedTime": "1 hora",
                                  "materials": "MATLAB (bodeplot, peakfind), simulador de sistemas lineares.",
                                  "tips": "Aplique filtro passa-banda virtual para isolar picos em simulações.",
                                  "learningObjective": "Localizar precisamente regiões de vulnerabilidade em T(s).",
                                  "commonMistakes": "Focar apenas em magnitude máxima sem considerar largura do pico."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Projetar a Forma Inicial de W4(s)",
                                  "subSteps": [
                                    "Escolha estrutura bandpass para W4(s): W4(s) = (s/ω1)/(1 + s/ω1) * (ω2/s)/(1 + ω2/s).",
                                    "Defina ω1 abaixo do primeiro pico, ω2 acima do último pico.",
                                    "Ajuste ganho k para que |W4(jω_r)| ≈ 1 / |T(jω_r)| nos picos.",
                                    "Inclua roll-off alto-frequência (ex: ordem 2) para estabilidade.",
                                    "Plote |W4 T| e verifique se <1 em todo o espectro."
                                  ],
                                  "verification": "Gere Bode de W4(s) e W4(s)T(s), confirmando ||W4 T||_∞ < 1.",
                                  "estimatedTime": "2 horas",
                                  "materials": "MATLAB (tf, bode), toolbox Control System.",
                                  "tips": "Comece com k=1 e itere; use sisotool para ajuste gráfico.",
                                  "learningObjective": "Criar W4(s) que envolva adequadamente os picos de T(s).",
                                  "commonMistakes": "Escolher banda muito estreita, deixando picos laterais expostos."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Otimizar Pesos e Verificar Robustez",
                                  "subSteps": [
                                    "Aplique síntese H-infinito ou LMI para refinar W4(s) com outros pesos.",
                                    "Simule com Δy = 20% ruído aditivo e cheque estabilidade/overshoot.",
                                    "Teste sensibilidade a variações de parâmetros da planta (±10%).",
                                    "Ajuste iterativamente para minimizar ||W4 T||_∞ enquanto mantém desempenho.",
                                    "Compare métricas pré e pós-W4: tempo de estabilização, pico de T."
                                  ],
                                  "verification": "Simulações mostram sistema estável com incertezas e ||W4 T||_∞ ≤ 0.9.",
                                  "estimatedTime": "2.5 horas",
                                  "materials": "Simulink para simulações não-lineares, hinfsyn toolbox.",
                                  "tips": "Use mu-toolbox para análise estrutural se disponível.",
                                  "learningObjective": "Garantir robustez quantitativa via otimização de pesos.",
                                  "commonMistakes": "Sobrecompensar, degradando largura de banda do sistema."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Documentar e Avaliar Trade-offs",
                                  "subSteps": [
                                    "Registre equações finais de W4(s) e justificativas de design.",
                                    "Calcule margens de robustez (ganho, fase) com novo controlador.",
                                    "Discuta trade-offs: robustez vs. desempenho nominal.",
                                    "Prepare relatório com gráficos comparativos.",
                                    "Teste em benchmark padrão (ex: sistema de 2 massas)."
                                  ],
                                  "verification": "Relatório completo com gráficos e métricas validadas por simulação.",
                                  "estimatedTime": "1 hora",
                                  "materials": "LaTeX/Markdown para relatório, exemplos de benchmarks.",
                                  "tips": "Inclua sensibilidade a mudanças em W4 para mostrar robustez do design.",
                                  "learningObjective": "Sintetizar conhecimento em design robusto documentado.",
                                  "commonMistakes": "Ignorar impactos em outros canais como rastreamento."
                                }
                              ],
                              "practicalExample": "Em um sistema de controle de posição de um braço robótico com ressonância em 10 rad/s devido a flexibilidade, calcule T(s) mostrando pico de 5 dB. Desenhe W4(s) bandpass centrado em 10 rad/s com |W4| = -5 dB ali, resultando em ||W4 T||_∞ = 0.8, estabilizando contra variações de carga de ±20%.",
                              "finalVerifications": [
                                "||W4(s) T(s)||_∞ < 1 em todo o espectro de frequências.",
                                "Simulação com incerteza aditiva Δy = 0.2 y_nom mostra overshoot < 20%.",
                                "Margem de ganho > 6 dB e fase > 45° no novo loop.",
                                "Picos de ressonância em T(s) reduzidos para < 0 dB.",
                                "Sistema permanece estável com ±15% variação em parâmetros da planta.",
                                "Tempo de assentamento nominal não aumenta > 20%."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de picos de T(s) (erro < 5% em ω_r).",
                                "Adequação de W4(s): cobertura completa dos picos com roll-off apropriado.",
                                "Valor de ||W4 T||_∞ ≤ 0.95 com justificativa iterativa.",
                                "Qualidade das simulações: múltiplos cenários de incerteza testados.",
                                "Documentação clara com trade-offs explicitados.",
                                "Criatividade em estrutura de W4(s) para sistemas complexos."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Análise de funções de transferência e otimização H-infinito.",
                                "Programação: Implementação em MATLAB para síntese e análise.",
                                "Física: Dinâmica de sistemas mecânicos com modos ressonantes.",
                                "Estatística: Modelagem de incertezas aditivas como ruído gaussiano."
                              ],
                              "realWorldApplication": "Em controle de flaps de aeronaves, onde ressonâncias aerodinâmicas podem amplificar turbulências (incertezas aditivas), W4(s) garante estabilidade robusta, prevenindo oscilações catastróficas durante manobras."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.4.2.3",
                            "name": "Ajustar pós-compensador para μ-síntese",
                            "description": "Incorporar incertezas estruturadas via pesos blocos δ_μ, formatando σ(Gl) para minimizar o μ da malha fechada em métodos avançados.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender Conceitos Fundamentais de μ-Síntese e Pós-Compensadores",
                                  "subSteps": [
                                    "Revise a definição de μ-síntese como medida de robustez para incertezas estruturadas.",
                                    "Estude o papel do pós-compensador na malha de controle para moldar a resposta em frequência.",
                                    "Analise a planta generalizada Gl e seu papel na minimização de μ da malha fechada.",
                                    "Identifique pesos de desempenho Wp e robustez Wr para formatar σ(Gl).",
                                    "Explore exemplos simples de blocos de incerteza δ_μ."
                                  ],
                                  "verification": "Resuma em um diagrama os componentes chave da μ-síntese e explique verbalmente o impacto do pós-compensador.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": "Livro de Skogestad 'Multivariable Feedback Control', MATLAB Robust Control Toolbox, notas de aula sobre controle robusto.",
                                  "tips": "Use diagramas de bloco para visualizar a interconexão antes de codificar.",
                                  "learningObjective": "Dominar os princípios teóricos da μ-síntese e o ajuste de pós-compensadores.",
                                  "commonMistakes": "Confundir μ com normas H-infinito sem incertezas estruturadas."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Modelar Incertezas Estruturas com Blocos δ_μ e Pesos",
                                  "subSteps": [
                                    "Identifique incertezas paramétricas e dinâmicas no sistema (ex: variação de ganho, atrasos).",
                                    "Defina blocos δ_μ normados (||δ_μ||_∞ ≤ 1) para representar incertezas estruturadas.",
                                    "Selecione pesos de robustez Wr e desempenho Wp baseados em especificações.",
                                    "Construa o modelo de incerteza Δ usando blocos δ_μ em paralelo ou série.",
                                    "Valide o modelo comparando com simulações nominais."
                                  ],
                                  "verification": "Gere um script MATLAB que plote os pesos e incertezas, confirmando normas unitárias.",
                                  "estimatedTime": "2 horas",
                                  "materials": "MATLAB com Robust Control Toolbox (funções musyn, lft), dados do sistema real.",
                                  "tips": "Comece com incertezas de baixa ordem para simplicidade iterativa.",
                                  "learningObjective": "Modelar precisamente incertezas estruturadas para μ-síntese.",
                                  "commonMistakes": "Sobrestimar ou subestimar pesos, levando a μ excessivo."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Construir e Formatar a Planta Generalizada Gl",
                                  "subSteps": [
                                    "Integre o pós-compensador C(s) inicial na malha de controle.",
                                    "Forme Gl usando interconexão linear fracionada (LFT) com Δ e pesos.",
                                    "Ajuste pesos para maximizar σ(Gl) em frequências críticas de interesse.",
                                    "Plote σ(Gl) e verifique picos que indicam problemas de robustez.",
                                    "Itere pesos iniciais para achatar σ(Gl) uniformemente."
                                  ],
                                  "verification": "Execute sysic ou lft em MATLAB e confirme que σ(Gl) está formatado corretamente com plot.",
                                  "estimatedTime": "2.5 horas",
                                  "materials": "MATLAB (augw, lft, sigma), exemplos de plantas como flexível beam ou DC motor.",
                                  "tips": "Use logspace para frequências e footequalize para balancear pesos.",
                                  "learningObjective": "Criar uma Gl otimizada para síntese de μ.",
                                  "commonMistakes": "Esquecer normalização de entradas/saídas, distorcendo σ(Gl)."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Sintetizar e Ajustar o Pós-Compensador para Minimizar μ",
                                  "subSteps": [
                                    "Aplique musyn ou hinfsyn para sintetizar o controlador K otimizado.",
                                    "Incorpore K no pós-compensador C(s) e compute μ da malha fechada.",
                                    "Itere ajustes em C(s) (ganhos, zeros/pólos) para reduzir μ < 1.",
                                    "Simule malha fechada com incertezas máximas e verifique estabilidade.",
                                    "Otimize via grid search ou otimização não-linear em parâmetros de C(s)."
                                  ],
                                  "verification": "Confirme μ_upper < 1 em todas as frequências via muplot ou musv.",
                                  "estimatedTime": "3 horas",
                                  "materials": "MATLAB Robust Control Toolbox (musyn, mu, loopmargin), simulador Simulink.",
                                  "tips": "Monitore condição numérica; use D-K iteração se necessário.",
                                  "learningObjective": "Ajustar iterativamente o pós-compensador para robustez ótima.",
                                  "commonMistakes": "Ignorar il-condicionamento levando a controladores irreais."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Validar e Refinar a Solução",
                                  "subSteps": [
                                    "Teste com Monte Carlo sobre Δ aleatórias normadas.",
                                    "Compare desempenho nominal vs. robusto em métricas como overshoot e settling time.",
                                    "Ajuste trade-offs entre desempenho e robustez via pesos.",
                                    "Documente mudanças no pós-compensador e impactos em μ.",
                                    "Prepare relatório com gráficos de Bode, Nyquist e μ."
                                  ],
                                  "verification": "Relatório mostra μ < 1 e estabilidade em 100% das simulações.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": "Simulink para simulações não-lineares, LaTeX para relatório.",
                                  "tips": "Salve versões iterativas para rollback.",
                                  "learningObjective": "Garantir robustez prática através de validação.",
                                  "commonMistakes": "Focar só em μ sem checar desempenho temporal."
                                }
                              ],
                              "practicalExample": "Em um motor DC com variação de 20% no momento de inércia e atraso de 10ms, modele δ_μ para inércia e atraso, formate Gl com pós-compensador PID-like, sintetize K via musyn resultando em μ=0.85, ajustando ganho para estabilidade robusta em velocidade constante.",
                              "finalVerifications": [
                                "μ da malha fechada < 1 em todo o espectro de frequência.",
                                "Estabilidade mantida para todas Δ com ||Δ||_∞ ≤ 1.",
                                "Desempenho nominal atende specs (ex: overshoot < 10%).",
                                "σ(Gl) uniformizado sem picos excessivos.",
                                "Simulações com incertezas máximas mostram convergência.",
                                "Controlador realizável (ordem baixa, ganhos finitos)."
                              ],
                              "assessmentCriteria": [
                                "Precisão na modelagem de δ_μ e pesos (nota em fidelidade).",
                                "Efetividade na minimização de μ (<1 com iterações ≤5).",
                                "Qualidade de formatação de σ(Gl) (achatamento visual).",
                                "Validação completa com simulações e gráficos.",
                                "Clareza no relatório explicando ajustes no pós-compensador.",
                                "Trade-off otimizado entre robustez e desempenho."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria de valores singulares estruturados e LMIs.",
                                "Programação: Otimização numérica em MATLAB/Simulink.",
                                "Física: Dinâmica de sistemas com incertezas paramétricas.",
                                "Engenharia de Software: Validação e testes unitários em modelos.",
                                "Estatística: Análise Monte Carlo para robustez probabilística."
                              ],
                              "realWorldApplication": "Ajuste de controladores em drones para lidar com variações de carga/payload e ventos turbulentos, garantindo estabilidade de voo robusta via μ-síntese em autopilotos como no PX4 ou MATLAB Aerospace Toolbox."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.4.2.4",
                            "name": "Avaliar impacto na formatação de malha",
                            "description": "Simular e analisar como os pós-compensadores modificam a singularidade da malha aberta, assegurando margens de ganho e fase adequadas.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar o modelo do sistema com pós-compensador",
                                  "subSteps": [
                                    "Obtenha a função de transferência do sistema original (planta G(s)) e do controlador pré-compensador C(s).",
                                    "Defina a estrutura do pós-compensador D(s), tipicamente um filtro lead ou lag-lead, com parâmetros iniciais baseados em design prévio.",
                                    "Construa a função de malha aberta L(s) = C(s) * G(s) * D(s).",
                                    "Implemente o modelo em software de simulação (ex: MATLAB).",
                                    "Valide o modelo comparando resposta em malha fechada sem D(s)."
                                  ],
                                  "verification": "Confirme que L(s) está corretamente implementada executando uma simulação simples e verificando polos/zeros.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "MATLAB/Simulink, funções de transferência documentadas, caderno para anotações.",
                                  "tips": "Use sys = series(series(C,G),D) no MATLAB para compor facilmente.",
                                  "learningObjective": "Entender como integrar o pós-compensador ao loop de controle.",
                                  "commonMistakes": "Esquecer de normalizar ganhos ou inverter sinais no pós-compensador."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Simular a resposta em frequência da malha aberta",
                                  "subSteps": [
                                    "Gere diagramas de Bode para magnitude e fase de L(s).",
                                    "Identifique a frequência de cruzamento de ganho (ω_gc onde |L(jω)|=0dB).",
                                    "Identifique a frequência de cruzamento de fase (ω_pc onde arg(L(jω))=-180°).",
                                    "Plote curvas antes e depois da adição de D(s) para comparação visual.",
                                    "Exporte dados numéricos de magnitude e fase em tabela."
                                  ],
                                  "verification": "Verifique se os diagramas mostram mudança na inclinação ou fase devido a D(s).",
                                  "estimatedTime": "30 minutos",
                                  "materials": "MATLAB (bodeplot), exportador de dados para Excel.",
                                  "tips": "Use grid on e zoom em regiões críticas para melhor visualização.",
                                  "learningObjective": "Dominar análise em frequência via diagramas de Bode.",
                                  "commonMistakes": "Confundir malha aberta com fechada ou escalas erradas em dB."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular e analisar margens de ganho e fase",
                                  "subSteps": [
                                    "Calcule a margem de fase PM = 180° + arg(L(jω_gc)) em graus.",
                                    "Calcule a margem de ganho GM = 1 / |L(jω_pc)| em dB.",
                                    "Avalie estabilidade: PM > 45° e GM > 6dB tipicamente.",
                                    "Compare com especificações do projeto (ex: PM alvo 60°).",
                                    "Quantifique o impacto de D(s): ΔPM e ΔGM."
                                  ],
                                  "verification": "Registre valores numéricos exatos e confirme que atendem critérios mínimos.",
                                  "estimatedTime": "40 minutos",
                                  "materials": "Função margin() no MATLAB, calculadora científica.",
                                  "tips": "Use allmargin(sys) para automação, mas entenda os cálculos manuais.",
                                  "learningObjective": "Aplicar definições precisas de margens de estabilidade.",
                                  "commonMistakes": "Usar ω errada para cada margem ou ignorar múltiplos cruzamentos."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Avaliar impacto geral e recomendar ajustes",
                                  "subSteps": [
                                    "Sintetize mudanças: como D(s) modifica singularidades (polos/zeros).",
                                    "Verifique robustez simulando variações paramétricas (±20% em G(s)).",
                                    "Compare desempenho em malha fechada (tempo de subida, overshoot).",
                                    "Documente relatório com gráficos e métricas.",
                                    "Proponha iterações em D(s) se margens inadequadas."
                                  ],
                                  "verification": "Crie um relatório resumido confirmando adequação ou necessidade de redesign.",
                                  "estimatedTime": "35 minutos",
                                  "materials": "MATLAB para simulações robustas, template de relatório.",
                                  "tips": "Foco em trade-offs: mais PM pode reduzir banda passante.",
                                  "learningObjective": "Integrar análise para decisão de design iterativo.",
                                  "commonMistakes": "Ignorar efeitos em tempo real ou superestimar robustez."
                                }
                              ],
                              "practicalExample": "Em um sistema de posicionamento de antena parabólica com G(s) = 10/(s(s+1)), adicione D(s) = (s+2)/(0.5s+1) como pós-compensador lead. Simule Bode: sem D(s), PM=30°; com D(s), PM=65°, GM=12dB, melhorando estabilidade.",
                              "finalVerifications": [
                                "Margem de fase PM ≥ 45° e margem de ganho GM ≥ 6dB confirmadas numericamente.",
                                "Diagramas de Bode mostram modificação clara da singularidade por D(s).",
                                "Simulações em malha fechada exibem overshoot <20% e tempo de estabilização adequado.",
                                "Análise de robustez tolera ±20% variação sem perda de estabilidade.",
                                "Relatório documenta todas métricas e comparações pré/pós D(s)."
                              ],
                              "assessmentCriteria": [
                                "Precisão nos cálculos de PM e GM (erro <5%).",
                                "Qualidade dos diagramas de Bode com anotações claras.",
                                "Profundidade da análise de impacto de D(s) na singularidade.",
                                "Correta identificação de trade-offs e recomendações iterativas.",
                                "Completude do relatório com evidências simuladas.",
                                "Demonstração de robustez via simulações variadas."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Análise de funções complexas e transformada de Laplace.",
                                "Programação: Scripts MATLAB para automação de simulações.",
                                "Física: Dinâmica de sistemas de segunda ordem e estabilidade.",
                                "Estatística: Análise de sensibilidade paramétrica."
                              ],
                              "realWorldApplication": "Em plantas industriais como fornos de refino ou atuadores de aviões, pós-compensadores ajustam margens para operação segura sob variações de carga, prevenindo oscilações que causam falhas ou desgaste."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.3.4.3",
                        "name": "Seleção Integrada de Pesos para Robustez",
                        "description": "Processo iterativo de escolha de todos os pesos (pré e pós) para otimizar a singularidade da malha aberta, atendendo critérios de robustez via H∞ ou otimização numérica.",
                        "specificSkills": [
                          {
                            "id": "10.1.3.4.3.1",
                            "name": "Iterar seleção de pesos combinados",
                            "description": "Realizar iterações manuais ou algorítmicas para balancear pesos W1-W4, visando σ(Gl) = 1 na frequência de crossover e roll-off adequado.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Definir valores iniciais dos pesos W1-W4",
                                  "subSteps": [
                                    "Analise os requisitos do sistema: identifique a frequência de crossover (wc) desejada e margens de robustez.",
                                    "Estabeleça valores iniciais para W1 (peso de performance), W2 (peso de ruído), W3 (peso de referência) e W4 (peso de robustez) baseados em magnitudes típicas do plantio.",
                                    "Normalize os pesos para que sua soma inicial seja unitária ou escalada adequadamente.",
                                    "Documente as justificativas para cada escolha inicial.",
                                    "Plote os pesos em escala logarítmica para visualização inicial."
                                  ],
                                  "verification": "Confirme que os pesos iniciais estão documentados e plotados corretamente, com justificativas alinhadas aos requisitos.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Software de simulação (MATLAB/Simulink ou Python com Control library), diagrama do sistema, especificações de wc e roll-off.",
                                  "tips": "Comece com W1=1 na wc para performance, e ajuste outros para 0.1-1 para evitar dominância inicial.",
                                  "learningObjective": "Compreender como pesos iniciais influenciam o trade-off entre performance e robustez no design H-infinito.",
                                  "commonMistakes": "Escolher pesos muito desbalanceados levando a sigma(Gl)>>1 imediatamente; ignorar unidades ou escalas do plantio."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Avaliar desempenho inicial e identificar desvios",
                                  "subSteps": [
                                    "Sintetize o controlador com pesos iniciais usando solver H-infinito.",
                                    "Calcule e plote sigma(Gl), verificando se sigma(Gl)(wc) ≈ 1 e roll-off adequado (ex: -20 dB/década pós-wc).",
                                    "Meça desvios: excesso de sigma(Gl) em wc indica necessidade de aumentar pesos de robustez; roll-off insuficiente sugere ajuste em W4.",
                                    "Registre métricas quantitativas: max(sigma(Gl))-1, slope do roll-off.",
                                    "Simule respostas temporais para validar estabilidade."
                                  ],
                                  "verification": "Plots de sigma(Gl) mostram wc identificada corretamente e desvios quantificados em tabela.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "MATLAB Robust Control Toolbox ou equivalente, plantio modelo (G(s)), scripts de síntese.",
                                  "tips": "Use sigma plot com grid para precisão visual; foque em wc ±1 oitava.",
                                  "learningObjective": "Avaliar criticamente o impacto dos pesos no shaping de sigma(Gl).",
                                  "commonMistakes": "Confundir sigma(Gl) com |T| ou |S|; não verificar estabilidade fechada do loop."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Realizar iterações manuais ou algorítmicas para balanceamento",
                                  "subSteps": [
                                    "Escolha método: manual (grid search) ou algorítmico (otimização gradient-based como fmincon).",
                                    "Ajuste iterativamente: aumente W2/W4 se sigma(Gl)>1 em wc; diminua W1 se overshoot em roll-off.",
                                    "Execute 5-10 iterações, registrando sigma(Gl) por trial em log.",
                                    "Monitore convergência: pare quando |sigma(Gl)(wc)-1| < 0.1 e roll-off > -20 dB/déc.",
                                    "Refine com sensibilidade: teste variações ±10% em parâmetros do plantio."
                                  ],
                                  "verification": "Log de iterações mostra convergência para sigma(Gl)=1, com pelo menos 5 trials documentados.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Otimização toolbox (MATLAB fmincon ou SciPy optimize), script iterativo reutilizável.",
                                  "tips": "Use escalas log para pesos em otimização; automatize com loop for loops iniciais.",
                                  "learningObjective": "Dominar iteração sistemática para otimização multi-objetivo em controle robusto.",
                                  "commonMistakes": "Iterar sem registro, levando a ciclos infinitos; ignorar não-convexidade do problema."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Validar e finalizar seleção de pesos",
                                  "subSteps": [
                                    "Teste robustez: varie plantio ±20% e verifique sigma(Gl) ainda ≈1.",
                                    "Avalie trade-offs: performance (tempo de assentamento), robustez (margens de ganho/fase).",
                                    "Compare com baseline (sem iteração) em métricas normalizadas.",
                                    "Documente pesos finais, plots e lições aprendidas.",
                                    "Exporte controlador para implementação simulada."
                                  ],
                                  "verification": "Relatório final com plots robustez, métricas melhoradas vs inicial, e pesos locked.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Scripts de Monte Carlo para robustez, template de relatório.",
                                  "tips": "Sempre valide em tempo discreto se aplicável; use mu-analysis para robustez estrutural.",
                                  "learningObjective": "Garantir que pesos otimizados atendam requisitos globais de robustez.",
                                  "commonMistakes": "Pular validação robustez, assumindo convergência = sucesso; não comparar com baseline."
                                }
                              ],
                              "practicalExample": "Para um servo-motor com plantio G(s) = 1/(s(s+1)), defina wc=10 rad/s. Inicial: W1=1/(|G|wc), W2=0.1, W3=1, W4=0.01/s. Após 7 iterações manuais, ajuste para W1=0.8, W2=0.15, W3=1.2, W4=0.05/s, alcançando sigma(Gl)(10)=1.02 com roll-off -25 dB/déc.",
                              "finalVerifications": [
                                "sigma(Gl) na wc está entre 0.9 e 1.1.",
                                "Roll-off pós-wc é pelo menos -20 dB/década.",
                                "Margens de ganho e fase > 6 dB e 45°.",
                                "Resposta temporal: overshoot < 20%, assentamento < 4/wc.",
                                "Robustez: sigma(Gl)<1 para plantio variado ±20%.",
                                "Convergência em <15 iterações."
                              ],
                              "assessmentCriteria": [
                                "Precisão: erro em sigma(Gl)(wc) < 10%.",
                                "Eficiência: número de iterações <10.",
                                "Documentação: log completo com plots e justificativas.",
                                "Robustez demonstrada via simulações variadas.",
                                "Trade-off balanceado: performance sem sacrificar estabilidade.",
                                "Código reutilizável e comentado."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Otimização não-linear e análise singular.",
                                "Programação: Algoritmos iterativos e automação em MATLAB/Python.",
                                "Física: Dinâmica de sistemas e estabilidade.",
                                "Engenharia de Software: Versionamento de iterações e relatórios.",
                                "Estatística: Análise de sensibilidade e Monte Carlo."
                              ],
                              "realWorldApplication": "Em drones para controle de atitude, itera pesos para lidar com variações de vento/massa, garantindo sigma(Gl)=1 em wc=5 Hz para manobras precisas sem oscilações."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.4.3.2",
                            "name": "Verificar critérios de robustez",
                            "description": "Calcular normas H∞ da malha generalizada e margens de robustez, usando funções MATLAB como hinfsyn ou robust-control toolbox para validar o projeto.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar o Modelo da Malha Generalizada",
                                  "subSteps": [
                                    "Definir o sistema planta P(s) e os sinais de entrada/saída da malha generalizada (w, z, u, y).",
                                    "Construir as funções de peso W_e, W_u e W_t para modelar especificações de desempenho e robustez.",
                                    "Montar a malha generalizada M usando o comando 'augw' do Robust Control Toolbox.",
                                    "Verificar dimensionalidade e estabilidade interna do modelo com 'isstable' ou análise de polos."
                                  ],
                                  "verification": "Executar 'size(M)' e 'pole(M)' para confirmar dimensões corretas e ausência de polos instáveis.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "MATLAB com Robust Control Toolbox; script com modelo planta P(s); funções de peso definidas.",
                                  "tips": "Use 'tf' ou 'ss' para modelos consistentes; normalize pesos para gamma inicial próximo de 1.",
                                  "learningObjective": "Entender a estrutura da malha generalizada e seu papel na síntese H∞.",
                                  "commonMistakes": "Esquecer de incluir todas as entradas/saídas; usar pesos inadequados que violam escalas."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Calcular a Norma H∞ da Malha Generalizada",
                                  "subSteps": [
                                    "Executar 'norm(M, inf)' ou 'hinfnorm(M)' para computar a norma H∞ (gamma).",
                                    "Analisar singular values com 'sigma(M, w)' em frequências relevantes.",
                                    "Identificar picos de ganho e verificar se gamma < 1 para robustez.",
                                    "Plotar curvas de singular values usando 'sigma plot' para visualização.",
                                    "Ajustar pesos iterativamente se gamma > 1."
                                  ],
                                  "verification": "gamma = norm(M, inf) deve ser reportado e plotado; confirme gamma < 1.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "MATLAB Robust Control Toolbox; malha M pronta do step anterior.",
                                  "tips": "Use grid de frequências logspace para sigma; foque em crossover frequencies.",
                                  "learningObjective": "Dominar o cálculo e interpretação da norma H∞ como medida de robustez.",
                                  "commonMistakes": "Não linearizar modelos não-lineares corretamente; ignorar wrap-around em plots."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Computar Margens de Robustez",
                                  "subSteps": [
                                    "Usar 'robuststab' ou 'allmargin' no controlador sintetizado K para margens de ganho/fase.",
                                    "Aplicar 'robustperf' para performance robusta sob incertezas Delta.",
                                    "Modelar incertezas aditivas/multiplicativas no sistema.",
                                    "Gerar relatório com 'show' em objetos robustcontrol.",
                                    "Comparar margens com critérios: GM > 2, PM > 45°, robustperf > 0.5."
                                  ],
                                  "verification": "Relatório de margens impresso; todas margens acima dos thresholds mínimos.",
                                  "estimatedTime": "40 minutos",
                                  "materials": "Controlador K de hinfsyn; toolbox robust-control.",
                                  "tips": "Sintetize K com 'hinfsyn(G, nw, nz)' se necessário; use uss para sistemas incertos.",
                                  "learningObjective": "Aplicar ferramentas para margens de estabilidade e performance robusta.",
                                  "commonMistakes": "Confundir margens nominais com robustas; não modelar Delta corretamente."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Interpretar Resultados e Validar Projeto",
                                  "subSteps": [
                                    "Compilar métricas: gamma, GM, PM, robuststab/performance values.",
                                    "Simular step response da malha fechada com incertezas usando 'lsim'.",
                                    "Verificar overshoot, settling time e robustez via Monte Carlo se aplicável.",
                                    "Documentar trade-offs e recomendações de ajuste.",
                                    "Gerar relatório final com plots e tabelas."
                                  ],
                                  "verification": "Relatório escrito confirmando critérios atendidos; simulações sem instabilidades.",
                                  "estimatedTime": "35 minutos",
                                  "materials": "Todos outputs anteriores; simulações MATLAB.",
                                  "tips": "Salve figures com 'saveas'; use 'stepinfo' para métricas automáticas.",
                                  "learningObjective": "Integrar análises para validar robustez global do projeto.",
                                  "commonMistakes": "Sobrepor robustez a performance; ignorar sensibilidade a ruído."
                                }
                              ],
                              "practicalExample": "Em um sistema de controle de posição de um drone quadrotor, com planta P(s) modelando dinâmica rotacional, pesos W_e para tracking error <10%, W_u para atuador saturation, calcule H∞ da malha M e verifique GM>3dB, PM>60° para robustez contra variações de massa de ±20%.",
                              "finalVerifications": [
                                "Norma H∞ (gamma) da malha generalizada < 1.",
                                "Margem de ganho (GM) > 6 dB e fase (PM) > 45°.",
                                "Robuststab > 0.8 e robustperf > 0.5.",
                                "Singular values plot mostram atenuação adequada em baixas/altas frequências.",
                                "Simulações com incertezas mantêm estabilidade e desempenho especificado.",
                                "Nenhum polo instável na malha fechada incerta."
                              ],
                              "assessmentCriteria": [
                                "Precisão numérica dos cálculos H∞ e margens (erro <1%).",
                                "Correta configuração de pesos e malha generalizada.",
                                "Interpretação qualitativa e quantitativa dos resultados.",
                                "Qualidade dos plots e relatórios gerados.",
                                "Identificação e mitigação de potenciais falhas de robustez.",
                                "Eficiência no uso de toolbox functions."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Álgebra linear (normas, singular values) e análise complexa.",
                                "Programação: Scripting avançado em MATLAB e manipulação de objetos LTI.",
                                "Física: Modelagem dinâmica de sistemas com incertezas paramétricas.",
                                "Estatística: Análise de Monte Carlo para validação probabilística."
                              ],
                              "realWorldApplication": "Na indústria aeroespacial, verifica robustez de controladores de voo autônomo contra variações de vento ou falhas de sensores, garantindo segurança em missões como satélites ou veículos autônomos."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.4.3.3",
                            "name": "Aplicar otimização de parâmetros",
                            "description": "Usar métodos numéricos para otimizar parâmetros dos pesos, minimizando ||Tzw||∞ sujeito a restrições de estabilidade e desempenho.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Formular o Problema de Otimização",
                                  "subSteps": [
                                    "Identifique as variáveis de otimização: parâmetros dos pesos (ex: Wp, Ws, Wu).",
                                    "Defina a função objetivo: minimizar ||Tzw||∞, onde Tzw é a função de transferência generalizada de z para w.",
                                    "Estabeleça restrições: estabilidade (polos no semiplano esquerdo), desempenho (ganhos, margens de estabilidade), e bounds nos pesos.",
                                    "Escreva o problema matematicamente: min γ sujeito a ||Tzw||∞ < γ e outras constraints.",
                                    "Verifique a convexidade ou use reformulações para métodos numéricos."
                                  ],
                                  "verification": "Confirme que a formulação está documentada em um script ou relatório com equações claras e variáveis definidas.",
                                  "estimatedTime": "2 horas",
                                  "materials": "Documentação de controle robusto (livros como Skogestad), MATLAB ou Python notebook.",
                                  "tips": "Comece com pesos iniciais conservadores para garantir viabilidade.",
                                  "learningObjective": "Compreender e articular o problema de otimização em termos de normas H-infinito e restrições.",
                                  "commonMistakes": "Esquecer restrições de estabilidade levando a soluções instáveis; ignorar normalização dos pesos."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Selecionar e Configurar o Método Numérico",
                                  "subSteps": [
                                    "Escolha o solver: para problemas convexos, use CVX (MATLAB/Python) ou YALMIP; para não-convexos, fmincon ou genetic algorithms.",
                                    "Configure opções: tolerâncias (ex: 1e-6), limites de iterações (500), algoritmo (interior-point).",
                                    "Defina variáveis de decisão e funções auxiliares (ex: compute_Tzw via tfdata ou state-space).",
                                    "Implemente as restrições como funções de constraint no solver.",
                                    "Teste o solver com um problema toy simples para validar setup."
                                  ],
                                  "verification": "Execute um teste unitário e verifique se o solver converge para o ótimo conhecido.",
                                  "estimatedTime": "3 horas",
                                  "materials": "MATLAB com Robust Control Toolbox, Python com control e cvxpy libraries.",
                                  "tips": "Use logs de otimização para monitorar convergência; prefira solvers convexos quando possível.",
                                  "learningObjective": "Selecionar e parametrizar solvers numéricos adequados para otimização em controle.",
                                  "commonMistakes": "Configurações padrão inadequadas causando não-convergência; não escalar variáveis."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar e Executar a Otimização",
                                  "subSteps": [
                                    "Codifique a função objetivo e constraints no script do solver.",
                                    "Forneça valores iniciais para os pesos baseados em design manual.",
                                    "Execute a otimização e capture saídas: parâmetros ótimos, valor de γ, tempo de CPU.",
                                    "Plote curvas de Bode de Tzw para visualizar ||Tzw||∞.",
                                    "Salve resultados em workspace ou arquivo para análise posterior."
                                  ],
                                  "verification": "Confirme convergência (status 'Optimal') e γ reduzido comparado a inicial.",
                                  "estimatedTime": "4 horas",
                                  "materials": "MATLAB script com hinfsyn ou custom optimizer, Simulink para modelo do sistema.",
                                  "tips": "Use parallel computing se disponível para aceleração.",
                                  "learningObjective": "Implementar numericamente a otimização e interpretar saídas do solver.",
                                  "commonMistakes": "Erros de indexação em state-space models; overflow em normas devido a modelos mal-condicionados."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Validar e Analisar Resultados",
                                  "subSteps": [
                                    "Verifique estabilidade: pole() ou eig() no controlador fechado.",
                                    "Avalie desempenho: margens de ganho/fase, step response com incertezas.",
                                    "Teste robustez: simule com variações de parâmetros do planta.",
                                    "Compare com baseline (ex: design sem otimização).",
                                    "Documente trade-offs e sugira iterações se necessário."
                                  ],
                                  "verification": "Relatório com plots mostrando cumprimento de todas restrições e melhoria em γ.",
                                  "estimatedTime": "3 horas",
                                  "materials": "Simulink para simulações, MATLAB plotting functions.",
                                  "tips": "Use mu-analysis para robustez estruturada se toolbox disponível.",
                                  "learningObjective": "Validar soluções ótimas contra critérios de engenharia de controle.",
                                  "commonMistakes": "Aceitar soluções sem checar estabilidade; ignorar viés numérico em simulações."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Iterar e Refinar a Otimização",
                                  "subSteps": [
                                    "Analise sensibilidade: perturbe pesos e reavalie γ.",
                                    "Adicione/refine constraints baseadas em validação.",
                                    "Execute múltiplas runs com seeds diferentes para não-convexidade.",
                                    "Integre em malha de controle completa (pré/pós-compensadores).",
                                    "Documente processo final e lições aprendidas."
                                  ],
                                  "verification": "Solução final robusta em pelo menos 3 cenários de variação.",
                                  "estimatedTime": "2 horas",
                                  "materials": "Scripts anteriores, uncertainty models (ureal em MATLAB).",
                                  "tips": "Mantenha um log de iterações para rastrear melhorias.",
                                  "learningObjective": "Refinar otimizações iterativamente para soluções práticas.",
                                  "commonMistakes": "Sobre-otimizar ignorando custo computacional; não testar em hardware simulado."
                                }
                              ],
                              "practicalExample": "Para um sistema de posição de braço robótico monovariável com incertezas de 20% na planta, otimize pesos Wp (performance), Ws (sensibilidade) e Wu (controle effort) para minimizar γ de 2.5 (inicial) para 1.8, garantindo margem de fase >45° e ||u||∞ <1 sob step de referência unitário. Use fmincon no MATLAB com modelo state-space G(s) = 1/(s^2 + s +1).",
                              "finalVerifications": [
                                "||Tzw||∞ ≤ γ ótimo reportado pelo solver.",
                                "Sistema fechado estável para planta nominal e ±20% variações.",
                                "Margens de estabilidade: GM >6dB, PM >45°.",
                                "Resposta no tempo: overshoot <20%, settling time <5s.",
                                "Restrições em u e y atendidas em simulação.",
                                "Convergência confirmada sem warnings numéricos."
                              ],
                              "assessmentCriteria": [
                                "Precisão da formulação matemática (equações corretas: 30%).",
                                "Implementação funcional do solver (convergência: 25%).",
                                "Validação completa com plots e métricas (20%).",
                                "Análise de robustez e trade-offs (15%).",
                                "Documentação clara e reprodutível (10%)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Otimização convexa e programação linear.",
                                "Programação: Numéricos em MATLAB/Python (scipy, cvxpy).",
                                "Física: Modelagem dinâmica de sistemas mecatrônicos.",
                                "Estatística: Análise de sensibilidade e Monte Carlo.",
                                "Engenharia de Software: Versionamento de scripts de otimização."
                              ],
                              "realWorldApplication": "Em design de controladores para drones autônomos, otimizar pesos garante robustez contra ventos variáveis, minimizando erro de trajetória enquanto respeita limites de atuadores, reduzindo falhas em missões reais."
                            },
                            "estimatedTime": "2.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.4.3.4",
                            "name": "Documentar e sintetizar controlador",
                            "description": "Gerar o controlador K(s) estabilizador via parametrização após formatação, e documentar trade-offs entre desempenho e robustez.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar parametrização do controlador após formatação da malha",
                                  "subSteps": [
                                    "Revisar a planta formatada P(s) e os pesos selecionados para robustez (W_p, W_u, etc.).",
                                    "Definir a estrutura parametrizada do controlador K(s, θ) com parâmetros livres θ.",
                                    "Implementar a parametrização em software de simulação, como MATLAB.",
                                    "Testar a parametrização inicial com valores nominais de θ para garantir solvibilidade.",
                                    "Ajustar bounds iniciais para os parâmetros θ baseados em restrições físicas."
                                  ],
                                  "verification": "Verificar se a função K(s, θ) é gerada corretamente e responde a entradas de teste sem erros numéricos.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "MATLAB com Control System Toolbox, arquivo da planta formatada P(s), notas de pesos selecionados.",
                                  "tips": "Use tf() ou zpk() para representar K(s) de forma simbólica em termos de θ.",
                                  "learningObjective": "Entender como parametrizar controladores para otimização em malhas formatadas.",
                                  "commonMistakes": "Esquecer de incluir polos/free integradores na parametrização, levando a controladores impróprios."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Gerar controlador K(s) estabilizador via otimização parametrizada",
                                  "subSteps": [
                                    "Configurar o problema de otimização para minimizar ||T||_∞ ou similar, sujeito a estabilidade.",
                                    "Executar otimização numérica (ex: fmincon) para encontrar θ ótimo estabilizador.",
                                    "Verificar margens de estabilidade (ganho e fase) do loop fechado.",
                                    "Simular resposta transitória e em frequência com o K(s) obtido.",
                                    "Iterar se necessário, refinando bounds ou inicializações."
                                  ],
                                  "verification": "Simulação mostra estabilidade (polos no semiplano esquerdo) e especificações atendidas.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "MATLAB Optimization Toolbox, scripts de simulação de malha fechada.",
                                  "tips": "Monitore o condicionamento da matriz Jacobiana para evitar mínimos locais.",
                                  "learningObjective": "Sintetizar controladores estabilizadores via parametrização otimizada.",
                                  "commonMistakes": "Otimizar sem constraints de robustez, resultando em controladores frágeis a perturbações."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar trade-offs entre desempenho e robustez",
                                  "subSteps": [
                                    "Calcular métricas de desempenho: tempo de estabilização, overshoot, erro estacionário.",
                                    "Avaliar robustez: margens, sensibilidade a variações de planta (±20%).",
                                    "Variação paramétrica: plotar trade-off (ex: desempenho vs. margem de ganho).",
                                    "Comparar com controladores alternativos (PID, LQG).",
                                    "Quantificar trade-offs com índices numéricos (ex: ITSE vs. robustez)."
                                  ],
                                  "verification": "Gráficos de Bode e Nyquist mostram trade-offs claros e quantificados.",
                                  "estimatedTime": "50 minutos",
                                  "materials": "MATLAB plotting functions, uncertain models (ureal, uss).",
                                  "tips": "Use loop-shaping para visualizar trade-offs intuitivamente.",
                                  "learningObjective": "Identificar e quantificar compromissos inerentes em projetos de controle.",
                                  "commonMistakes": "Ignorar não-linearidades ou delays, superestimando robustez."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Documentar e sintetizar o controlador final",
                                  "subSteps": [
                                    "Escrever relatório com K(s) final, parâmetros θ, equações e diagramas.",
                                    "Incluir seção dedicada a trade-offs com tabelas/gráficos.",
                                    "Gerar código embarcado ou função pronta para uso (ex: sisotool export).",
                                    "Revisar documentação por clareza e completude.",
                                    "Arquivar com versão controlada (Git ou similar)."
                                  ],
                                  "verification": "Documento permite reprodução independente do controlador e análise.",
                                  "estimatedTime": "40 minutos",
                                  "materials": "LaTeX ou Word para relatório, MATLAB to PDF export.",
                                  "tips": "Use templates IEEE para padronização profissional.",
                                  "learningObjective": "Comunicar resultados de forma técnica e acessível.",
                                  "commonMistakes": "Omitir unidades ou suposições, tornando documentação ambígua."
                                }
                              ],
                              "practicalExample": "Para um sistema de controle de posição de um braço robótico com planta P(s) = 1/(s^2 + s), após formatação com pré-compensador, parametrizar K(s,θ) = (θ1 s + θ2)/(s (θ3 s + 1)), otimizar para θ = [2.5, 10, 0.5], documentando que overshoot cai de 30% para 10% mas margem de ganho reduz de 12dB para 8dB.",
                              "finalVerifications": [
                                "Controlador K(s) implementado e estabilizador em simulações nominais e robustas.",
                                "Trade-offs documentados com pelo menos 3 métricas quantitativas.",
                                "Relatório inclui equações, gráficos e código reproduzível.",
                                "Margens de estabilidade ≥6dB ganho e 45° fase.",
                                "Simulações mostram desempenho dentro de specs para ±15% variação de planta.",
                                "Documentação permite implementação por terceiros sem consulta adicional."
                              ],
                              "assessmentCriteria": [
                                "Precisão da parametrização e síntese (20%): K(s) correto e estabilizador.",
                                "Profundidade da análise de trade-offs (25%): Quantificação clara com gráficos.",
                                "Qualidade da documentação (25%): Estrutura profissional, legível.",
                                "Validação prática (20%): Simulações robustas e verificações.",
                                "Criatividade em conexões reais (10%): Insights além do básico."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Otimização não-linear e análise de singular values.",
                                "Programação: Scripts MATLAB para automação de síntese.",
                                "Física: Modelagem dinâmica de sistemas mecatrônicos.",
                                "Gestão de Projetos: Documentação técnica para equipes multidisciplinares."
                              ],
                              "realWorldApplication": "Em indústrias aeroespacial e automotiva, como síntese de controladores para flaps de aeronaves ou suspensão ativa de veículos, onde trade-offs entre resposta rápida e robustez a variações de carga são críticos para segurança e performance."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.3.5",
                    "name": "Condições de Robustez",
                    "description": "Análise de máxima sensibilidade, margens de ganho e fase na malha formatada.",
                    "individualConcepts": [
                      {
                        "id": "10.1.3.5.1",
                        "name": "Análise de Máxima Sensibilidade",
                        "description": "Estudo da função de sensibilidade S(jω) na malha formatada, focando na norma infinita ||S||∞ para quantificar a robustez contra perturbações e incertezas aditivas, identificando picos de sensibilidade que indicam limitações de desempenho e estabilidade.",
                        "specificSkills": [
                          {
                            "id": "10.1.3.5.1.1",
                            "name": "Calcular a norma infinita da sensibilidade máxima",
                            "description": "Utilizar diagramas de Bode ou ferramentas computacionais como MATLAB para computar ||S||∞ = sup_ω |S(jω)| na malha formatada, interpretando valores abaixo de 6 dB como indicativo de boa robustez.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Definir e Computar a Função de Sensibilidade S(s)",
                                  "subSteps": [
                                    "Identifique o controlador C(s) e a planta G(s) da malha formatada.",
                                    "Calcule a função de loop L(s) = C(s)G(s).",
                                    "Derive S(s) = 1 / (1 + L(s)) usando álgebra de funções de transferência.",
                                    "Simplifique S(s) para análise em frequência.",
                                    "Verifique estabilidade de S(s) via polos no semiplano esquerdo."
                                  ],
                                  "verification": "Confirme que S(s) está em forma racional própria e estável; teste com valores DC.",
                                  "estimatedTime": "30 minutes",
                                  "materials": [
                                    "MATLAB ou Octave",
                                    "Papel e lápis para cálculos simbólicos",
                                    "Exemplo de sistema monovariável"
                                  ],
                                  "tips": "Use tf() no MATLAB para representar funções de transferência facilmente.",
                                  "learningObjective": "Compreender a origem matemática da sensibilidade máxima na malha fechada.",
                                  "commonMistakes": [
                                    "Esquecer o denominador 1 + L(s)",
                                    "Não cancelar polos/zeros comuns",
                                    "Ignorar normalização da planta"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Gerar o Diagrama de Bode de |S(jω)|",
                                  "subSteps": [
                                    "Abra o MATLAB e defina S(s) usando tf(num, den).",
                                    "Gere o diagrama de Bode com bode(S) ou bodeplot(S).",
                                    "Ajuste o range de frequências de 0.01 a 1000 rad/s para capturar dinâmica relevante.",
                                    "Extraia magnitude em dB com [mag, phase, w] = bode(S).",
                                    "Salve o plot como figura para análise posterior."
                                  ],
                                  "verification": "O plot mostra magnitude de |S(jω)| em dB com eixo log-log; verifique picos visíveis.",
                                  "estimatedTime": "45 minutes",
                                  "materials": [
                                    "MATLAB com Control System Toolbox",
                                    "Script .m com S(s) definido"
                                  ],
                                  "tips": "Use grid on e legend para clareza; zoom no pico máximo.",
                                  "learningObjective": "Dominar ferramentas computacionais para análise em frequência.",
                                  "commonMistakes": [
                                    "Plotar fase em vez de magnitude",
                                    "Escala errada de frequência",
                                    "Não linearizar sistema não-linear"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular a Norma Infinita ||S||∞",
                                  "subSteps": [
                                    "Identifique visualmente o pico máximo no diagrama de Bode de |S(jω)|.",
                                    "Use max(mag) em dB para extrair sup_ω |S(jω)|.",
                                    "Converta para escala linear se necessário: 20*log10(||S||∞).",
                                    "Confirme com norm(S, inf) no MATLAB para precisão numérica.",
                                    "Registre ω no qual ocorre o máximo (frequência crítica)."
                                  ],
                                  "verification": "Valor numérico de ||S||∞ coincide entre plot e função norm(); erro <1%.",
                                  "estimatedTime": "20 minutes",
                                  "materials": [
                                    "Script MATLAB com bode e norm",
                                    "Calculadora para conversões dB"
                                  ],
                                  "tips": "Para sistemas de alta ordem, use sigma(S) para plot de singular values.",
                                  "learningObjective": "Aplicar definição de norma H-infinita em prática computacional.",
                                  "commonMistakes": [
                                    "Confundir com norma 2",
                                    "Ler valor em phase plot",
                                    "Ignorar supremo em baixas frequências"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Interpretar o Resultado para Robustez",
                                  "subSteps": [
                                    "Compare ||S||∞ em dB com threshold de 6 dB (20*log10(2) ≈6dB).",
                                    "Se <6dB, classifique como robusto a perturbações unitárias.",
                                    "Discuta implicações: ganho de perturbação <2 significa boa robustez.",
                                    "Gere relatório com plot, valor e conclusão.",
                                    "Teste sensibilidade a variações de parâmetros (±10% em G(s))."
                                  ],
                                  "verification": "Relatório escrito justifica robustez corretamente com evidências do plot.",
                                  "estimatedTime": "25 minutes",
                                  "materials": [
                                    "Relatório template Word/LaTeX",
                                    "MATLAB para simulações de variação"
                                  ],
                                  "tips": "Lembre: ||S||∞ <1/|Δ| garante estabilidade robusta por small-gain theorem.",
                                  "learningObjective": "Interpretar normas de sensibilidade em contexto de design de controle.",
                                  "commonMistakes": [
                                    "Interpretar >6dB como robusto",
                                    "Esquecer conversão dB para linear",
                                    "Não considerar frequência do pico"
                                  ]
                                }
                              ],
                              "practicalExample": "Considere uma planta G(s) = 1/(s(s+1)) com controlador PI: C(s)=2(s+0.5)/s. Compute L(s)=C G, S(s)=1/(1+L). No MATLAB: s=tf('s'); G=tf(1,[1 1 0]); C=2*(s+0.5)/s; S=1/(1+C*G); norm(S,inf) resulta em ≈5.2 dB <6dB, indicando robustez.",
                              "finalVerifications": [
                                "S(s) computada corretamente e plotada em Bode.",
                                "||S||∞ extraída com precisão numérica e visual.",
                                "Interpretação correta: robustez se <6dB.",
                                "Relatório inclui plot, valor e ω_crítico.",
                                "Teste com variação de parâmetros confirma análise.",
                                "Uso correto de norm(S,inf) no MATLAB."
                              ],
                              "assessmentCriteria": [
                                "Precisão matemática na derivação de S(s) (30%).",
                                "Qualidade e correção do diagrama de Bode (25%).",
                                "Cálculo exato de ||S||∞ e identificação de supremo (20%).",
                                "Interpretação robustez com threshold 6dB (15%).",
                                "Relatório claro com evidências e discussões (10%)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Análise complexa e normas em espaços de Hardy.",
                                "Programação: Scripting em MATLAB para automação de análises.",
                                "Física: Dinâmica de sistemas e perturbações em malhas de feedback.",
                                "Estatística: Análise de incertezas e worst-case scenarios."
                              ],
                              "realWorldApplication": "Em controle de drones, calcular ||S||∞ garante robustez a variações de vento ou massa, evitando instabilidade; usado na NASA para projetos de estabilização de satélites onde perturbações externas são críticas."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.5.1.2",
                            "name": "Identificar e interpretar picos de sensibilidade",
                            "description": "Analisar o diagrama de Bode da sensibilidade S para localizar picos acima de 0 dB, relacionando-os a ressonâncias, incertezas não modeladas e requisitos de robustez via critérios como ||S||∞ < 1/|Δ|.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar e Plotar o Diagrama de Bode da Sensibilidade S",
                                  "subSteps": [
                                    "Obtenha a função de transferência do sistema de malha fechada e compute S(s) = 1 / (1 + G(s)C(s))",
                                    "Use software como MATLAB ou Python (biblioteca control) para gerar o diagrama de Bode de magnitude de S(jω)",
                                    "Ajuste a faixa de frequência para cobrir de 0.1 rad/s até 10 vezes a frequência de corte",
                                    "Marque a linha de 0 dB no gráfico para referência visual",
                                    "Salve o plot com legendas claras indicando |S(jω)| em dB"
                                  ],
                                  "verification": "Confirme que o diagrama mostra magnitude em dB vs. log(ω) e que S(s) está corretamente calculada comparando com fórmula teórica em baixas frequências (|S| → 0 dB)",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Software MATLAB/Python com toolbox control, função de transferência do sistema",
                                  "tips": "Sempre normalize unidades de frequência para rad/s para consistência",
                                  "learningObjective": "Dominar o cálculo e visualização do diagrama de Bode da sensibilidade S",
                                  "commonMistakes": "Confundir S com a função de loop aberto ou plotar fase em vez de magnitude"
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Localizar Picos de Sensibilidade Acima de 0 dB",
                                  "subSteps": [
                                    "Examine o gráfico de magnitude |S(jω)| e identifique todos os picos onde |S| > 0 dB (ganho > 1)",
                                    "Registre a frequência ω_pico de cada pico e sua magnitude máxima em dB",
                                    "Meça a largura da banda do pico (distância entre pontos -3 dB do pico)",
                                    "Compare múltiplos picos se existirem, priorizando o maior",
                                    "Anote se o pico ocorre próximo à frequência de cruzamento ou em altas frequências"
                                  ],
                                  "verification": "Liste pelo menos um pico com ω_pico exata e |S|_max > 0 dB, validado numericamente no software",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Diagrama de Bode plotado, régua digital ou cursor no software para medições precisas",
                                  "tips": "Use zoom no software para precisão; picos estreitos indicam ressonâncias fortes",
                                  "learningObjective": "Desenvolver habilidade em detectar quantitativamente picos de sensibilidade",
                                  "commonMistakes": "Ignorar picos pequenos ou confundir ripple com picos reais"
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Interpretar Causas dos Picos: Ressonâncias e Incertezas",
                                  "subSteps": [
                                    "Relacione picos em baixas frequências a incertezas não modeladas no modelo nominal",
                                    "Associe picos em médias/altas frequências a ressonâncias não capturadas (ex: flexões mecânicas)",
                                    "Calcule o fator de amplificação do pico: 20*log10(|S|_max) indica sensibilidade a perturbações nessa frequência",
                                    "Simule variação de parâmetros (ex: ±20% ganho) para confirmar amplificação do pico",
                                    "Discuta implicações: picos altos violam robustez contra Δ (incertezas aditivas/multiplicativas)"
                                  ],
                                  "verification": "Explique verbalmente ou por escrito como o pico se relaciona a uma ressonância específica, com simulação de suporte",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Software para simulações paramétricas, notas sobre modelo do sistema",
                                  "tips": "Pense em termos físicos: picos = modos vibratórios excitados por ruído/referência",
                                  "learningObjective": "Conectar picos observados a fenômenos físicos e modelagem",
                                  "commonMistakes": "Atribuir todos picos a ressonâncias sem verificar localização de frequência"
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Relacionar Picos a Critérios de Robustez",
                                  "subSteps": [
                                    "Calcule ||S||∞ = sup_ω |S(jω)| (magnitude máxima do pico)",
                                    "Estime o bound de incerteza Δ_max tal que ||S||∞ < 1/|Δ| para estabilidade robusta",
                                    "Verifique se ||S||∞ atende requisitos (ex: < 6 dB para Δ < 50%)",
                                    "Proponha ajustes no controlador (ex: notch filter no pico) para reduzir ||S||∞",
                                    "Documente o trade-off: reduzir picos pode degradar desempenho nominal"
                                  ],
                                  "verification": "Forneça cálculo numérico de ||S||∞ e condição booleana se atende 1/|Δ|",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Calculadora ou software para ||.||∞, especificações de robustez do problema",
                                  "tips": "Use norm(S, inf) no MATLAB para automação",
                                  "learningObjective": "Aplicar critérios quantitativos de robustez como ||S||∞",
                                  "commonMistakes": "Confundir ||S||∞ com ganho DC ou usar picos isolados sem supremo"
                                }
                              ],
                              "practicalExample": "Em um drone com controlador PID, o diagrama de Bode de S mostra pico de 8 dB em 15 rad/s devido a ressonância do motor. Interpretando: amplifica ruído nessa frequência em 3x, violando robustez para Δ=30% (pois 8 dB > 1/0.3 ≈ 10 dB requerido). Solução: adicionar filtro notch em 15 rad/s.",
                              "finalVerifications": [
                                "Diagrama de Bode de S plotado corretamente com picos marcados",
                                "Lista de picos com ω_pico, |S|_max e largura de banda",
                                "Explicação causal (ressonância/incerteza) para cada pico principal",
                                "Cálculo preciso de ||S||∞ e verificação contra 1/|Δ|",
                                "Proposta de mitigação com justificativa",
                                "Simulação confirmando interpretação"
                              ],
                              "assessmentCriteria": [
                                "Precisão na localização de picos (>95% exatidão em ω e magnitude)",
                                "Correta interpretação física (ressonância vs. incerteza modelada)",
                                "Aplicação quantitativa correta de ||S||∞ e critérios de robustez",
                                "Profundidade de substeps (todos 3-5 completos e acionáveis)",
                                "Clareza na documentação e exemplos práticos",
                                "Identificação de trade-offs em robustez vs. desempenho"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Análise de Fourier e normas infinitas (||.||∞)",
                                "Física: Dinâmica de sistemas com ressonâncias e vibrações",
                                "Estatística: Análise de incertezas paramétricas e Monte Carlo",
                                "Programação: Uso de bibliotecas numéricas (MATLAB/Python control)"
                              ],
                              "realWorldApplication": "Em automação industrial, como controle de braços robóticos, picos de sensibilidade identificam ressonâncias flexíveis que causam vibrações perigosas; interpretá-los garante robustez contra variações de carga, evitando falhas em linhas de produção da indústria automotiva."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.5.1.3",
                            "name": "Avaliar robustez via sensibilidade complementar T",
                            "description": "Calcular e analisar ||T||∞ na malha formatada, relacionando-a com rejeição de ruído e robustez multiplicativa, garantindo que max(||S||∞, ||T||∞) < 1 para estabilidade robusta.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender Definições e Propriedades da Sensibilidade Complementar T",
                                  "subSteps": [
                                    "Revise a sensibilidade S(ω) = (I + G K(jω))⁻¹, onde G é a planta e K o controlador.",
                                    "Defina T(ω) = G K (I + G K(jω))⁻¹ = I - S(ω), confirmando a relação complementar.",
                                    "Interprete T como função de transferência de referência para saída e de ruído/distúrbio para erro de rastreamento.",
                                    "Relacione T com robustez multiplicativa: pertubações Δ em G são rejeitadas se ||T Δ||∞ < 1.",
                                    "Discuta o trade-off: alto ganho em baixas frequências aumenta ||T||∞ em altas frequências."
                                  ],
                                  "verification": "Escreva as fórmulas de S e T e explique verbalmente seu significado físico em 3 exemplos.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Livro de Skogestad 'Multivariable Feedback Control'",
                                    "Folhas de cálculo",
                                    "Software MATLAB para plotar S e T"
                                  ],
                                  "tips": "Sempre verifique S(jω) + T(jω) = 1 para todo ω, pois isso valida os cálculos.",
                                  "learningObjective": "Dominar definições matemáticas e interpretações físicas de T.",
                                  "commonMistakes": [
                                    "Confundir T com sensibilidade a ruído de sensor vs. atuador",
                                    "Ignorar a dependência em G e K",
                                    "Esquecer a identidade S + T = I"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Formatar a Malha de Controle e Calcular T(jω)",
                                  "subSteps": [
                                    "Desenhe a malha unitária feedback com planta G(s), controlador K(s) e pontos de injeção de sinais.",
                                    "Compute L(jω) = G(jω) K(jω), a função de loop aberto.",
                                    "Calcule T(jω) = L(jω) / (1 + L(jω)) para cada frequência ω relevante.",
                                    "Gere vetores de frequência ω usando logspace e plote |T(jω)| em diagrama de Bode.",
                                    "Identifique picos e roll-off de T, notando regiões de bom tracking vs. sensibilidade a ruído."
                                  ],
                                  "verification": "Produza um gráfico de Bode de |T(jω)| que corresponda a um exemplo conhecido.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "MATLAB/Simulink",
                                    "Plantilla de malha de controle",
                                    "Exemplos de G(s) estáveis como 1/(s+1)"
                                  ],
                                  "tips": "Use tf() e bode() no MATLAB para automação; evite ω muito altas para evitar numéricos.",
                                  "learningObjective": "Construir e computar T na malha formatada com precisão.",
                                  "commonMistakes": [
                                    "Erro na formatação da malha (ex: feedback positivo)",
                                    "Escala errada em ω levando a picos falsos",
                                    "Não linearizar G se não-linear"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular a Norma Infinita ||T||∞ e ||S||∞",
                                  "subSteps": [
                                    "Defina ||T||∞ = sup_ω |T(jω)|, a máxima magnitude sobre todas as frequências.",
                                    "Use hinfnorm() no MATLAB ou integre numericamente max(|T(jω)|) em grade fina de ω.",
                                    "Calcule similarmente ||S||∞ = sup_ω |S(jω)|.",
                                    "Compare ||S||∞ e ||T||∞, identificando o bottleneck para robustez.",
                                    "Ajuste K iterativamente para minimizar max(||S||∞, ||T||∞) enquanto mantém performance."
                                  ],
                                  "verification": "Informe ||T||∞ com erro <1% comparado a referência analítica.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "MATLAB Control System Toolbox",
                                    "Scripts de exemplo para hinfnorm",
                                    "Calculadora simbólica como SymPy"
                                  ],
                                  "tips": "Refine a grade de ω perto de cruzamentos de ganho para precisão em picos.",
                                  "learningObjective": "Computar normas H∞ de forma precisa e eficiente.",
                                  "commonMistakes": [
                                    "Usar norma 2 em vez de ∞",
                                    "Grid de ω grosseira subestimando sup",
                                    "Confundir ||T||∞ com ganho DC"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar Robustez e Verificar Condições de Estabilidade",
                                  "subSteps": [
                                    "Verifique se max(||S||∞, ||T||∞) < 1 garante estabilidade robusta multiplicativa para ||Δ||∞ < 1/||T||∞.",
                                    "Analise rejeição de ruído: ||T||∞ pequeno em altas ω reduz impacto de ruído de sensor.",
                                    "Interprete robustez: ||T||∞ mede sensibilidade a variações coprimeas em G.",
                                    "Simule pertubações Δ com ||Δ||∞ próximo a 1/||T||∞ e cheque estabilidade fechada.",
                                    "Documente trade-offs e proponha melhorias no projeto K."
                                  ],
                                  "verification": "Conclua corretamente se o sistema é robusto para Δ com ||Δ||∞ = 0.9 / ||T||∞.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Simulink para simulações",
                                    "Relatório template",
                                    "Banco de plantas G(s) perturbadas"
                                  ],
                                  "tips": "Use mu-toolbox para análise estrutural se disponível; foque em cenários reais de Δ.",
                                  "learningObjective": "Relacionar ||T||∞ com métricas de robustez e performance.",
                                  "commonMistakes": [
                                    "Ignorar que max(||S||∞, ||T||∞) <1 é suficiente mas não necessário",
                                    "Não simular para validar teoria",
                                    "Confundir robustez aditiva vs. multiplicativa"
                                  ]
                                }
                              ],
                              "practicalExample": "Para G(s) = 1/(s+1), K(s) = 1 (ganho unitário): L(s)=1/(s+1), T(s)=1/(s+2), ||T||∞ ≈ 0.707 <1. Perturbe G com Δ=0.3, verifique estabilidade com ||T Δ||∞ <1.",
                              "finalVerifications": [
                                "Calcule ||T||∞ corretamente para 3 malhas diferentes.",
                                "Explique por que ||T||∞ alto em altas frequências causa rejeição pobre de ruído.",
                                "Verifique max(||S||∞, ||T||∞) <1 em um projeto e proponha ajuste.",
                                "Simule instabilidade com ||Δ||∞ > 1/||T||∞.",
                                "Relacione T com robustez multiplicativa em relatório escrito.",
                                "Plote S, T e L em Bode mostrando trade-offs."
                              ],
                              "assessmentCriteria": [
                                "Precisão nos cálculos de T(jω) e ||T||∞ (erro <5%).",
                                "Correta interpretação de robustez multiplicativa e condições de estabilidade.",
                                "Uso apropriado de ferramentas como MATLAB para análise.",
                                "Identificação clara de trade-offs entre performance e robustez.",
                                "Qualidade da análise em simulações com pertubações.",
                                "Documentação completa com gráficos e conclusões acionáveis."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria de normas H∞ e espaços de Hardy.",
                                "Programação: Simulação numérica em MATLAB/Python (Control library).",
                                "Física: Modelagem dinâmica de sistemas com ruído e distúrbios.",
                                "Estatística: Análise de incertezas em modelos paramétricos.",
                                "Engenharia de Software: Validação de controladores em loops reais."
                              ],
                              "realWorldApplication": "Em controle de reatores químicos, onde variações no ganho da planta (devido a fouling) são modeladas como Δ multiplicativa; ||T||∞ <1 garante estabilidade apesar de imprecisões no modelo, evitando oscilações perigosas em processos contínuos."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.3.5.2",
                        "name": "Margens de Ganho",
                        "description": "Definição e análise das margens de ganho (GM) na malha formatada L(s), medindo a tolerância a variações paramétricas no ganho, com ênfase em margens condicionais e não condicionais para robustez.",
                        "specificSkills": [
                          {
                            "id": "10.1.3.5.2.1",
                            "name": "Determinar margens de ganho superior e inferior",
                            "description": "Usando o diagrama de Nyquist ou Bode da malha formatada, calcular GM_sup = 1/|L(jω_pc)| e GM_inf = |L(jω_zc)|, visando GM > 2 (6 dB) para robustez.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar e preparar o diagrama de Nyquist ou Bode da malha formatada",
                                  "subSteps": [
                                    "Obtenha o diagrama de Bode (magnitude e fase vs. log ω) ou Nyquist (plano complexo L(jω)) da malha de controle formatada.",
                                    "Identifique as curvas relevantes: magnitude |L(jω)|, fase arg(L(jω)) para Bode; trajetória no plano complexo para Nyquist.",
                                    "Marque os eixos e escalas claramente para facilitar leituras precisas.",
                                    "Confirme que o diagrama está na forma padrão (L(s) = K * G(s)H(s) formatada).",
                                    "Anote as frequências de interesse aproximadas visualmente."
                                  ],
                                  "verification": "Diagrama anotado com eixos identificados e curvas destacadas; capaz de explicar cada parte.",
                                  "estimatedTime": "10-15 minutos",
                                  "materials": [
                                    "Diagrama de Bode ou Nyquist impresso ou digital",
                                    "Lápis e papel para anotações",
                                    "Regra ou cursor para leituras precisas"
                                  ],
                                  "tips": "Use log-log para Bode e verifique unidades de frequência (rad/s ou Hz).",
                                  "learningObjective": "Compreender a representação gráfica da função de malha aberta para análise de estabilidade.",
                                  "commonMistakes": [
                                    "Confundir diagrama de malha aberta com fechada",
                                    "Ignorar a escala logarítmica",
                                    "Não identificar o loop formatado corretamente"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar a frequência de cruzamento de fase ω_pc",
                                  "subSteps": [
                                    "No diagrama de Bode, localize o ponto onde a fase arg(L(jω)) = -180° (ou -π rad).",
                                    "No Nyquist, encontre a interseção da trajetória com o eixo real negativo.",
                                    "Leia o valor de ω_pc no eixo de frequência.",
                                    "Registre a magnitude |L(jω_pc)| correspondente nesse ponto (em valor absoluto ou dB).",
                                    "Confirme interpolando se necessário entre pontos discretos."
                                  ],
                                  "verification": "Valor de ω_pc e |L(jω_pc)| anotados com precisão ±5%; gráfico marcado.",
                                  "estimatedTime": "15-20 minutos",
                                  "materials": [
                                    "Diagrama preparado do Step 1",
                                    "Calculadora para interpolação",
                                    "Software como MATLAB para zoom se digital"
                                  ],
                                  "tips": "Em Bode, fase contínua; em Nyquist, procure o ponto mais próximo de -1.",
                                  "learningObjective": "Localizar precisamente o ponto crítico de fase para cálculo de margem de ganho.",
                                  "commonMistakes": [
                                    "Confundir com cruzamento de ganho",
                                    "Ler magnitude errada (dB vs. linear)",
                                    "Escolher ω errada em múltiplos cruzamentos"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Identificar a frequência de cruzamento de ganho ω_zc",
                                  "subSteps": [
                                    "No diagrama de Bode, localize onde |L(jω)| = 1 (0 dB).",
                                    "No Nyquist, encontre interseção com a unidade imaginária (círculo unitário).",
                                    "Leia ω_zc e a magnitude |L(jω_zc)| nesse ponto (pode não ser exatamente 1 se múltiplo).",
                                    "Registre a fase correspondente se relevante para confirmação.",
                                    "Anote se há múltiplos cruzamentos e selecione o relevante para robustez."
                                  ],
                                  "verification": "ω_zc e |L(jω_zc)| registrados; consistência com definição de cruzamento.",
                                  "estimatedTime": "15-20 minutos",
                                  "materials": [
                                    "Diagrama do Step 1",
                                    "Calculadora",
                                    "Tabela de conversão dB-linear"
                                  ],
                                  "tips": "Converta dB para linear: |L| = 10^(dB/20).",
                                  "learningObjective": "Distinguir e localizar o cruzamento de ganho para margens inferiores.",
                                  "commonMistakes": [
                                    "Assumir |L(jω_zc)|=1 sempre",
                                    "Confundir ordem dos cruzamentos",
                                    "Ler frequência errada"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Calcular margens de ganho superior e inferior e avaliar robustez",
                                  "subSteps": [
                                    "Calcule GM_sup = 1 / |L(jω_pc)| (linear); converta para dB: 20*log10(GM_sup).",
                                    "Calcule GM_inf = |L(jω_zc)| (linear); converta para dB se aplicável.",
                                    "Verifique se GM_sup > 2 (6 dB) e GM_inf > 2 para robustez.",
                                    "Interprete: GM_sup indica fator de ganho antes instabilidade; GM_inf para variações baixas.",
                                    "Documente resultados em tabela com unidades."
                                  ],
                                  "verification": "Cálculos numéricos corretos e interpretação escrita; GM > 2 confirmado.",
                                  "estimatedTime": "20-25 minutos",
                                  "materials": [
                                    "Valores dos Steps 2-3",
                                    "Calculadora ou MATLAB/Simulink",
                                    "Folha de cálculos"
                                  ],
                                  "tips": "Sempre use valores lineares para 1/|L|, dB para relatório.",
                                  "learningObjective": "Executar cálculos precisos de margens e avaliar estabilidade robusta.",
                                  "commonMistakes": [
                                    "Usar dB diretamente em 1/|L|",
                                    "Inverter GM_sup e GM_inf",
                                    "Esquecer conversão para dB"
                                  ]
                                }
                              ],
                              "practicalExample": "Dado diagrama Bode: em ω_pc = 10 rad/s, |L(jω_pc)| = -12 dB (0.25 linear), GM_sup = 1/0.25 = 4 (12 dB). Em ω_zc = 5 rad/s, |L(jω_zc)| = 1.5 (3.5 dB), GM_inf = 1.5. Ambos >2, robusto.",
                              "finalVerifications": [
                                "ω_pc e |L(jω_pc)| identificados corretamente do diagrama.",
                                "ω_zc e |L(jω_zc)| lidos com precisão.",
                                "GM_sup = 1/|L(jω_pc)| calculado em linear e dB.",
                                "GM_inf = |L(jω_zc)| determinado.",
                                "Conclusão sobre robustez (GM > 2) justificada.",
                                "Tabela de resultados completa."
                              ],
                              "assessmentCriteria": [
                                "Precisão nas leituras gráficas (±10% erro máximo).",
                                "Cálculos matemáticos corretos (sem erros aritméticos).",
                                "Interpretação correta de robustez (>6 dB).",
                                "Uso adequado de Bode vs. Nyquist.",
                                "Documentação clara com anotações.",
                                "Identificação de múltiplos cruzamentos se presentes."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Análise de funções complexas e logarítmica.",
                                "Física: Dinâmica de sistemas e estabilidade oscilatória.",
                                "Programação: Simulação em MATLAB/Python para geração de diagramas.",
                                "Estatística: Análise de incertezas em parâmetros de planta."
                              ],
                              "realWorldApplication": "Em projetos de controladores PID para robótica industrial, garante estabilidade apesar de variações de 50% no ganho da planta (ex: motores com desgaste), evitando oscilações em linhas de montagem automáticas."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.5.2.2",
                            "name": "Analisar margens de ganho condicionais",
                            "description": "Avaliar variações de ganho em frequências específicas via diagrama de Bode, verificando estabilidade para ΔK tal que |ΔK| < min(GM_sup, 1/GM_inf), relacionando com incertezas reais.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Diagramas de Bode e Margens de Ganho Convencionais",
                                  "subSteps": [
                                    "Estude a construção de diagramas de Bode para magnitude e fase a partir da função de transferência.",
                                    "Identifique a frequência de ganho unitário (ω_c) e calcule a margem de ganho padrão (GM = 1/|G(jω_c)|).",
                                    "Pratique plotagem manual e com software para sistemas de segunda ordem.",
                                    "Analise como variações de ganho afetam a estabilidade no ponto crítico.",
                                    "Compare diagramas de Bode de sistemas estáveis e instáveis."
                                  ],
                                  "verification": "Plotar corretamente o diagrama de Bode de um sistema dado e calcular GM com erro <5%.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Função de transferência exemplo",
                                    "Software MATLAB ou Python (control library)",
                                    "Papel milimetrado para plotagem manual"
                                  ],
                                  "tips": "Comece com aproximações assintóticas para agilizar o plot.",
                                  "learningObjective": "Compreender a base gráfica para análise de estabilidade via Bode.",
                                  "commonMistakes": [
                                    "Confundir magnitude em dB com valor absoluto",
                                    "Ignorar a fase na determinação de ω_c"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Compreender o Conceito de Margens de Ganho Condicionais",
                                  "subSteps": [
                                    "Defina GM_sup(ω) como o fator máximo de ganho que mantém estabilidade em frequência ω específica.",
                                    "Defina GM_inf(ω) como o fator mínimo de ganho para evitar instabilidade em ω.",
                                    "Estude a condição de robustez: |ΔK| < min(GM_sup(ω), 1/GM_inf(ω)) para uma faixa de frequências.",
                                    "Analise como margens condicionais capturam incertezas não modeladas em pontos críticos.",
                                    "Resolva exercícios teóricos para calcular GM_sup e GM_inf em ω fixa."
                                  ],
                                  "verification": "Explicar verbalmente ou por escrito a diferença entre GM padrão e condicional.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Notas de aula sobre robustez",
                                    "Exemplos de funções de loop aberto",
                                    "Calculadora científica"
                                  ],
                                  "tips": "Visualize GM_sup como distância à -180° fase em magnitude.",
                                  "learningObjective": "Dominar definições e fórmulas de margens condicionais.",
                                  "commonMistakes": [
                                    "Confundir GM_sup com PM (fase)",
                                    "Não considerar o sinal de ΔK"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar Variações de Ganho via Diagrama de Bode em Frequências Específicas",
                                  "subSteps": [
                                    "Selecione frequências de interesse (ex: ω onde fase ≈ -180° ou picos de magnitude).",
                                    "No diagrama de Bode, determine |G(jω)| e arg(G(jω)) para cada ω.",
                                    "Calcule GM_sup(ω) = -20*log10(|G(jω)|) quando fase = -180° aproximada.",
                                    "Compute GM_inf(ω) baseado em cruzamentos de magnitude com 0dB ajustados.",
                                    "Plote curvas de GM_sup e GM_inf sobre o Bode para visualização."
                                  ],
                                  "verification": "Gerar diagrama com GM_sup/GM_inf anotados para um sistema dado.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "MATLAB/Simulink ou Python (matplotlib + control)",
                                    "Sistema exemplo com G(s) dado"
                                  ],
                                  "tips": "Use comandos como bodeplot() no MATLAB para automação.",
                                  "learningObjective": "Aplicar análise gráfica para extrair margens condicionais.",
                                  "commonMistakes": [
                                    "Selecionar ω errada (não crítica)",
                                    "Erro em conversão dB para linear"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificar Estabilidade para ΔK e Relacionar com Incertezas Reais",
                                  "subSteps": [
                                    "Determine o limite de variação: ΔK_max = min(GM_sup(ω), 1/GM_inf(ω)) sobre ω relevantes.",
                                    "Simule sistema com K nominal, K+ΔK e K-ΔK para validar estabilidade.",
                                    "Relacione ΔK com incertezas reais (ex: tolerâncias de amplificadores, variações paramétricas).",
                                    "Avalie robustez quantitativa: percentual de tolerância permitida.",
                                    "Documente relatório com conclusões e recomendações de projeto."
                                  ],
                                  "verification": "Simulação bem-sucedida mostrando estabilidade dentro de ΔK calculado.",
                                  "estimatedTime": "2.5 horas",
                                  "materials": [
                                    "Software de simulação (Simulink ou Python)",
                                    "Dados de incertezas reais de componentes"
                                  ],
                                  "tips": "Teste margens conservadoras: use min sobre múltiplas ω.",
                                  "learningObjective": "Integrar análise teórica com validação prática e contexto real.",
                                  "commonMistakes": [
                                    "Simular apenas step response sem checar Nyquist",
                                    "Ignorar efeitos não-lineares"
                                  ]
                                }
                              ],
                              "practicalExample": "Para um regulador de tensão em uma fonte chaveada com G(s) = K / (s^2 + 2s + 1), plote Bode, identifique ω=5 rad/s como crítica (fase~-170°), calcule GM_sup≈1.5, GM_inf≈0.8, então |ΔK|<0.8 para robustez contra variações de 20% no ganho do amplificador.",
                              "finalVerifications": [
                                "Calcular corretamente GM_sup e GM_inf para pelo menos 3 frequências.",
                                "Determinar ΔK_max com precisão e justificar faixa de ω.",
                                "Simular e confirmar estabilidade para ΔK dentro do limite.",
                                "Relacionar resultados com uma incerteza real (ex: tolerância de resistor).",
                                "Explicar limitações da análise em relatório curto.",
                                "Plotar Bode com anotações de margens condicionais."
                              ],
                              "assessmentCriteria": [
                                "Precisão nos cálculos de magnitude/fase (<2% erro).",
                                "Correta identificação de frequências críticas e min(GM_sup,1/GM_inf).",
                                "Validação via simulação com respostas transitórias estáveis.",
                                "Profundidade na relação com incertezas reais.",
                                "Clareza no diagrama e documentação.",
                                "Criatividade em conexões práticas."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Análise complexa e logaritmos para Bode.",
                                "Física: Modelagem dinâmica de sistemas elétricos/mecânicos.",
                                "Programação: Scripts em MATLAB/Python para automação de plots.",
                                "Estatística: Quantificação de incertezas paramétricas.",
                                "Engenharia de Software: Validação de modelos em Simulink."
                              ],
                              "realWorldApplication": "Em controle de drones, onde variações no ganho do motor devido a bateria descarregada são analisadas via margens condicionais para garantir estabilidade de voo sob ventos variáveis, evitando crashes."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.3.5.3",
                        "name": "Margens de Fase",
                        "description": "Análise das margens de fase (PM) na malha formatada, quantificando a robustez contra variações de fase devido a incertezas não modeladas ou atrasos, integrando com critérios de estabilidade.",
                        "specificSkills": [
                          {
                            "id": "10.1.3.5.3.1",
                            "name": "Calcular a margem de fase na frequência de ganho unitário",
                            "description": "No diagrama de Bode da L(s) formatada, determinar PM = 180° + ∠L(jω_cg) onde |L(jω_cg)|=1, recomendando PM > 45° para boa robustez relativa.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Identificar a frequência de ganho unitário (ω_cg) no diagrama de Bode de magnitude",
                                  "subSteps": [
                                    "Examine o diagrama de magnitude |L(jω)| em dB versus log(ω).",
                                    "Localize o ponto onde a magnitude cruza 0 dB (equivalente a |L(jω)| = 1).",
                                    "Registre o valor de ω correspondente, chamado ω_cg (frequência de crossover de ganho).",
                                    "Confirme interpolando se necessário entre pontos discretos no gráfico.",
                                    "Anote ω_cg com precisão de pelo menos duas casas decimais."
                                  ],
                                  "verification": "ω_cg identificada corretamente coincide com o ponto exato de cruzamento de 0 dB no diagrama.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Diagrama de Bode de magnitude da L(s)",
                                    "Régua ou software de plotagem (ex: MATLAB, Python Matplotlib)",
                                    "Papel e caneta para anotações"
                                  ],
                                  "tips": "Use escala logarítmica para precisão; se o gráfico for digital, utilize ferramentas de zoom.",
                                  "learningObjective": "Compreender e localizar precisamente a frequência onde o ganho unitário ocorre.",
                                  "commonMistakes": [
                                    "Confundir com frequência de corte (-3dB)",
                                    "Ler magnitude em escala linear em vez de dB",
                                    "Ignorar interpolação em gráficos discretos"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Determinar o ângulo de fase ∠L(jω_cg) no diagrama de Bode de fase",
                                  "subSteps": [
                                    "No diagrama de fase ∠L(jω) em graus versus log(ω), marque a frequência ω_cg identificada no Step 1.",
                                    "Leia o valor da fase diretamente na curva em ω_cg.",
                                    "Se necessário, interpole entre pontos próximos para maior precisão.",
                                    "Registre o valor da fase, tipicamente negativo (ex: -120°).",
                                    "Verifique consistência com a magnitude no mesmo ω."
                                  ],
                                  "verification": "Valor de ∠L(jω_cg) lido com precisão ±1° do valor real no diagrama.",
                                  "estimatedTime": "10 minutos",
                                  "materials": [
                                    "Diagrama de Bode de fase da L(s)",
                                    "Marcador para ω_cg no gráfico",
                                    "Calculadora para interpolação"
                                  ],
                                  "tips": "Fase geralmente diminui com ω; preste atenção à escala em graus.",
                                  "learningObjective": "Extrair com precisão o argumento da função de transferência na frequência crítica.",
                                  "commonMistakes": [
                                    "Usar o diagrama errado (magnitude em vez de fase)",
                                    "Ler em ω errada",
                                    "Confundir graus com radianos"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular a Margem de Fase (PM)",
                                  "subSteps": [
                                    "Aplique a fórmula: PM = 180° + ∠L(jω_cg).",
                                    "Substitua o valor de ∠L(jω_cg) obtido no Step 2.",
                                    "Realize a soma aritmética simples.",
                                    "Expresse o resultado em graus, arredondando para uma casa decimal.",
                                    "Documente o cálculo passo a passo."
                                  ],
                                  "verification": "Cálculo matemático correto: PM computado matches 180° + fase lida.",
                                  "estimatedTime": "5 minutos",
                                  "materials": [
                                    "Calculadora ou planilha (Excel/Google Sheets)",
                                    "Papel para equação"
                                  ],
                                  "tips": "Lembre-se: fase é negativa, então PM será positivo se <180°.",
                                  "learningObjective": "Dominar a fórmula padrão de cálculo da margem de fase.",
                                  "commonMistakes": [
                                    "Esquecer o sinal '+' ou usar subtração",
                                    "Usar radianos em vez de graus",
                                    "Arredondar prematuramente"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Interpretar a Margem de Fase para robustez do sistema",
                                  "subSteps": [
                                    "Compare PM com o limiar recomendado: PM > 45° indica boa robustez relativa.",
                                    "Classifique: PM > 60° excelente; 45°-60° boa; <45° risco de instabilidade.",
                                    "Discuta implicações: baixa PM aumenta sensibilidade a variações de ganho.",
                                    "Sugira ações corretivas se PM <45° (ex: adicionar compensador de fase).",
                                    "Registre recomendação final."
                                  ],
                                  "verification": "Interpretação correta alinhada com critérios padrão de robustez.",
                                  "estimatedTime": "10 minutos",
                                  "materials": [
                                    "Tabela de critérios de PM",
                                    "Referência teórica de controle (ex: livro de Ogata)"
                                  ],
                                  "tips": "PM reflete distância à instabilidade (-180°); maior é mais estável.",
                                  "learningObjective": "Avaliar estabilidade relativa e propor melhorias baseadas em PM.",
                                  "commonMistakes": [
                                    "Ignorar o sinal da PM",
                                    "Confundir PM com GM (margem de ganho)",
                                    "Subestimar impacto em robustez"
                                  ]
                                }
                              ],
                              "practicalExample": "Considere L(s) = 10/(s(s+1)(s+10)). No diagrama de Bode, ω_cg ≈ 2.3 rad/s onde |L(jω_cg)|=0dB, e ∠L(jω_cg) ≈ -135°. Então PM = 180° + (-135°) = 45°. Como PM=45°, robustez é marginal; recomende compensador para aumentar PM>60°.",
                              "finalVerifications": [
                                "Identificação precisa de ω_cg no diagrama de magnitude.",
                                "Leitura correta de ∠L(jω_cg) com interpolação se aplicável.",
                                "Cálculo exato de PM usando a fórmula padrão.",
                                "Interpretação adequada da robustez (PM >45° bom).",
                                "Documentação completa com valores numéricos e justificativa.",
                                "Capacidade de repetir em diagrama similar sem erros."
                              ],
                              "assessmentCriteria": [
                                "Precisão na localização de ω_cg (±5% de erro máximo).",
                                "Exatidão na leitura de fase (±2° de erro).",
                                "Correção matemática no cálculo de PM.",
                                "Interpretação qualitativa e quantitativa da robustez.",
                                "Clareza na documentação e justificativas.",
                                "Tempo de execução eficiente dentro dos estimados."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Análise de funções complexas e logaritmos decimais.",
                                "Física: Dinâmica de sistemas e estabilidade oscilatória.",
                                "Programação: Simulação de diagramas de Bode em MATLAB/Python.",
                                "Eletrônica: Projeto de filtros e compensadores analógicos.",
                                "Estatística: Análise de sensibilidade e variância em parâmetros."
                              ],
                              "realWorldApplication": "Em controle de motores elétricos industriais, calcular PM garante estabilidade robusta contra variações de carga, evitando oscilações em linhas de produção automotiva ou robótica, melhorando eficiência e segurança."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.5.3.2",
                            "name": "Interpretar margens de fase condicionais",
                            "description": "Analisar variações de fase em frequências de ganho unitário e cruzamento de fase, usando critérios como PM condicional para garantir estabilidade robusta sob Δφ < PM.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar diagramas de Bode e margens de fase padrão",
                                  "subSteps": [
                                    "Estudar o diagrama de Bode de magnitude e fase para uma função de transferência G(s).",
                                    "Identificar a frequência de ganho unitário (ω_gc), onde |G(jω_gc)| = 1.",
                                    "Identificar a frequência de cruzamento de fase (ω_pc), onde arg(G(jω_pc)) = -180°.",
                                    "Calcular a margem de fase padrão (PM = 180° + arg(G(jω_gc))).",
                                    "Plotar um exemplo simples usando software de simulação."
                                  ],
                                  "verification": "Plotar corretamente o diagrama de Bode e anotar ω_gc, ω_pc e PM com valores numéricos precisos.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Software MATLAB/Simulink ou Python (biblioteca control)",
                                    "Função de transferência exemplo: G(s) = 1/(s(s+1))"
                                  ],
                                  "tips": [
                                    "Use escala logarítmica para frequências; verifique unidades em rad/s."
                                  ],
                                  "learningObjective": "Dominar os elementos básicos do diagrama de Bode necessários para margens condicionais.",
                                  "commonMistakes": [
                                    "Confundir ω_gc com ω_pc",
                                    "Esquecer de converter graus para radianos em cálculos",
                                    "Ignorar o ganho DC na normalização"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Compreender o conceito de margens de fase condicionais (CPM)",
                                  "subSteps": [
                                    "Definir CPM como a margem de fase ajustada para variações de fase Δφ em frequências críticas.",
                                    "Explicar que CPM considera Δφ em ω_gc e ω_pc para estabilidade robusta.",
                                    "Derivar a fórmula condicional: PM_cond = PM - max(Δφ(ω_gc), Δφ(ω_pc)).",
                                    "Discutir o papel de CPM em análise de robustez sob perturbações de fase.",
                                    "Comparar CPM com PM padrão através de um gráfico anotado."
                                  ],
                                  "verification": "Explicar verbalmente ou por escrito a diferença entre PM e CPM, com fórmula correta.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Notas teóricas sobre robustez em controle",
                                    "Ferramenta de plotagem como Bode Plot no MATLAB"
                                  ],
                                  "tips": [
                                    "PM_cond > 0 garante estabilidade; mire PM_cond > 45° para robustez."
                                  ],
                                  "learningObjective": "Entender a definição e importância das margens condicionais para sistemas incertos.",
                                  "commonMistakes": [
                                    "Assumir Δφ constante em todas as frequências",
                                    "Inverter o sinal na subtração de Δφ",
                                    "Negligenciar o pior caso de Δφ"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar variações de fase Δφ nas frequências chave",
                                  "subSteps": [
                                    "Modelar Δφ como perturbação aditiva na fase: arg(G'(jω)) = arg(G(jω)) + Δφ(ω).",
                                    "Avaliar Δφ em ω_gc e ω_pc para diferentes cenários de incerteza (ex: delays, não-linearidades).",
                                    "Calcular o impacto: nova PM' = PM - Δφ(ω_gc).",
                                    "Plotar curvas de fase nominal e perturbada no diagrama de Bode.",
                                    "Quantificar o envelope de incerteza Δφ(ω)."
                                  ],
                                  "verification": "Gerar plots com Δφ = ±10° e identificar mudanças em PM.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Exemplo de sistema com delay: G(s) e G(s)e^{-sT}",
                                    "Simulador numérico"
                                  ],
                                  "tips": [
                                    "Use aproximações lineares para pequenas Δφ; simule Monte Carlo para grandes."
                                  ],
                                  "learningObjective": "Analisar quantitativamente o efeito de variações de fase em margens.",
                                  "commonMistakes": [
                                    "Avaliar Δφ apenas em ω_gc, ignorando ω_pc",
                                    "Usar magnitude em vez de fase nas perturbações",
                                    "Não normalizar o sistema"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar critérios de robustez usando PM condicional",
                                  "subSteps": [
                                    "Estabelecer critério: sistema robusto se Δφ_max < PM_cond.",
                                    "Interpretar resultados: PM_cond > 60° indica alta robustez.",
                                    "Testar estabilidade com Nyquist alterado para Δφ.",
                                    "Recomendar compensadores se PM_cond insuficiente.",
                                    "Documentar conclusões em relatório com plots e valores."
                                  ],
                                  "verification": "Concluir corretamente se um sistema dado é robusto para Δφ < 20°.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Sistema exemplo completo com dados numéricos",
                                    "Templates de relatório"
                                  ],
                                  "tips": [
                                    "Sempre valide com simulações de laço fechado."
                                  ],
                                  "learningObjective": "Interpretar margens condicionais para decisões de design robusto.",
                                  "commonMistakes": [
                                    "Aceitar PM > 0 sem checar condicional",
                                    "Ignorar interações com margem de ganho",
                                    "Superestimar robustez sem simulação"
                                  ]
                                }
                              ],
                              "practicalExample": "Para G(s) = 10/(s(s+1)(s+10)), plote Bode nominal. Adicione Δφ(ω) = 5° para ω<10 rad/s e 15° para ω>10. Calcule PM=55°, Δφ(ω_gc)=8°, PM_cond=47°. Conclua robusto para Δφ<47° simulando step response com perturbação.",
                              "finalVerifications": [
                                "Identificar corretamente ω_gc e ω_pc em um Bode plot dado.",
                                "Calcular PM_cond para Δφ especificada com erro <5%.",
                                "Interpretar se PM_cond >45° garante robustez.",
                                "Plotar fase perturbada e anotar mudanças.",
                                "Explicar verbalmente o critério Δφ < PM para estabilidade.",
                                "Simular laço fechado e verificar overshoot <20% sob Δφ."
                              ],
                              "assessmentCriteria": [
                                "Precisão nos cálculos de frequências e margens (erro <2°).",
                                "Qualidade dos plots e anotações (clareza e legibilidade).",
                                "Correta interpretação de robustez com justificativa quantitativa.",
                                "Identificação de erros comuns e como evitá-los.",
                                "Aplicação correta do critério Δφ < PM em exemplo prático.",
                                "Criatividade em sugestões de melhoria para PM_cond baixa."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Funções complexas e análise em domínio da frequência.",
                                "Física: Dinâmica de sistemas com atrasos e não-linearidades.",
                                "Informática: Programação de simulações em MATLAB/Python.",
                                "Estatística: Análise de Monte Carlo para envelopes de incerteza."
                              ],
                              "realWorldApplication": "Em controle de motores elétricos de veículos autônomos, interpretar PM_cond garante estabilidade robusta apesar de variações de fase causadas por delays de comunicação sem fio variáveis, evitando oscilações perigosas em velocidades altas."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.5.3.3",
                            "name": "Integrar margens de fase com robustez H∞",
                            "description": "Relacionar PM com ||S||∞ via aproximações como PM ≈ 100 / (1 + ||S||∞), aplicando na malha formatada para otimizar trade-offs entre desempenho e robustez.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Fundamentos de Margem de Fase (PM) e Norma H∞",
                                  "subSteps": [
                                    "Definir Margem de Fase (PM) como a diferença entre a fase em -180° na frequência de ganho unitário e -180° no diagrama de Bode.",
                                    "Explicar a função de sensibilidade S(s) = 1/(1 + L(s)) e seu papel na análise de robustez.",
                                    "Introduzir a norma H∞ como ||S||∞ = sup_ω |S(jω)|, representando a amplificação máxima de perturbações.",
                                    "Plotar diagramas de Bode para exemplos simples de malhas de controle monovariáveis.",
                                    "Discutir o significado físico de PM alta indicando maior estabilidade relativa."
                                  ],
                                  "verification": "Plotar diagrama de Bode de um sistema e identificar corretamente PM e ||S||∞ em pelo menos dois exemplos.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Software MATLAB ou Python (Control Systems Toolbox)",
                                    "Livro 'Feedback Control of Dynamic Systems' (Franklin)",
                                    "Diagramas de Bode de exemplos padrão"
                                  ],
                                  "tips": [
                                    "Use unidades consistentes: fase em graus para PM e magnitude em dB para normas.",
                                    "Sempre verifique a frequência de crossover ω_c."
                                  ],
                                  "learningObjective": "Compreender as definições e relações básicas entre PM e normas de sensibilidade H∞.",
                                  "commonMistakes": [
                                    "Confundir PM com Margem de Ganho (GM).",
                                    "Ignorar a relação entre |S(jω_c)| ≈ 1 na frequência de crossover.",
                                    "Usar fase em radianos sem conversão para aproximações."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Compreender a Aproximação PM ≈ 100 / (1 + ||S||∞)",
                                  "subSteps": [
                                    "Derivar a aproximação a partir da relação |S(jω_c)| ≈ 1 / (1 + 20*log10(PM/100)) perto da frequência de crossover.",
                                    "Explicar heurística: PM (em %) ≈ 100 / (1 + ||S||∞) para ||S||∞ próximo de 1.",
                                    "Calcular numericamente para casos teste: PM=60° → ||S||∞ ≈ 2.",
                                    "Analisar limites de validade: válida para sistemas com roll-off suave e ||S||∞ < 10.",
                                    "Comparar com simulações exatas usando svd ou norm em MATLAB."
                                  ],
                                  "verification": "Aplicar a fórmula em 3 exemplos e comparar erro com cálculo exato de ||S||∞ (<5% de erro).",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "MATLAB com funções norm e bode",
                                    "Planilha Excel para cálculos manuais",
                                    "Artigo 'Loop Shaping' de McFarlane e Glover"
                                  ],
                                  "tips": [
                                    "Teste com PM variando de 30° a 90° para observar linearidade aproximada.",
                                    "Use log-log para visualizar ||S||∞ vs PM."
                                  ],
                                  "learningObjective": "Dominar a heurística de ligação quantitativa entre PM clássica e robustez H∞ moderna.",
                                  "commonMistakes": [
                                    "Aplicar fórmula fora do regime ||S||∞ ≈1-3.",
                                    "Esquecer de converter PM de graus para fração decimal.",
                                    "Confundir ||S||∞ com ||T||∞ (sensibilidade complementar)."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Integrar a Aproximação na Malha de Controle Formatada",
                                  "subSteps": [
                                    "Formatar a malha aberta L(s) = K(s) P(s) W(s) para loop shaping H∞.",
                                    "Aplicar a aproximação para especificar PM desejada (ex: 60°) e estimar ||S||∞ alvo.",
                                    "Ajustar pesos W_s para moldar |S(jω)| e atender PM ≈ 100 / (1 + ||S||∞).",
                                    "Simular malha fechada com perturbações e verificar diagrama de Bode.",
                                    "Iterar ajustes em K(s) para alinhar PM e ||S||∞ com especificações."
                                  ],
                                  "verification": "Gerar malha formatada onde PM calculada bate com aproximação H∞ em <10% erro.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Simulink ou MATLAB hinfsyn toolbox",
                                    "Templates de plantas P(s) com incertezas",
                                    "Documentação H∞ Loop Shaping"
                                  ],
                                  "tips": [
                                    "Comece com PM conservadora (50-60°) para robustez.",
                                    "Monitore picos de |S| em baixas e altas frequências."
                                  ],
                                  "learningObjective": "Aplicar a integração prática em formato de malha para síntese de controladores.",
                                  "commonMistakes": [
                                    "Não normalizar planta P(s) para ||P||∞=1.",
                                    "Ignorar peso de desempenho W_p no trade-off.",
                                    "Sobreajustar ganho levando a ||S||∞ >5."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Otimizar Trade-offs entre Desempenho e Robustez",
                                  "subSteps": [
                                    "Definir métricas: tempo de assentamento <2s (desempenho) e ||S||∞ <2 (robustez).",
                                    "Usar aproximação para varrer PM e plotar Pareto de trade-offs.",
                                    "Analisar sensibilidade a ΔP (incertezas) via μ-analysis ou Monte Carlo.",
                                    "Refinar controlador com base em simulações de step response e Bode robusto.",
                                    "Documentar escolhas: 'PM=55° garante ||S||∞=1.8 com overshoot<20%'."
                                  ],
                                  "verification": "Produzir relatório com trade-off otimizado e simulações validadas para 3 cenários de incerteza.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "MATLAB Robust Control Toolbox",
                                    "Scripts de Monte Carlo para ΔP",
                                    "Ferramentas de plotting (bodeplot, stepinfo)"
                                  ],
                                  "tips": [
                                    "Use γ-plot para visualizar trade-offs H∞.",
                                    "Priorize robustez em frequências críticas de perturbação."
                                  ],
                                  "learningObjective": "Avaliar e otimizar quantitativamente os compromissos inerentes ao projeto.",
                                  "commonMistakes": [
                                    "Focar só em PM sem checar ||S||∞ em banda larga.",
                                    "Subestimar incertezas multiplicativas Δ=0.2.",
                                    "Não validar com simulações não-lineares."
                                  ]
                                }
                              ],
                              "practicalExample": "Projeto de controlador para um sistema de levitação magnética (maglev) com incertezas de 20% na massa. Usar aproximação para especificar PM=60° visando ||S||∞<2, formatar malha com W_s=1/s^2 (baixo freq), sintetizar K∞ e verificar step response robusto com overshoot<15% e rejeição de distúrbios.",
                              "finalVerifications": [
                                "Calcular ||S||∞ exato e aproximado via PM com erro <5%.",
                                "Gerar Bode plot de malha formatada atendendo specs de robustez.",
                                "Simular resposta a step com ±20% variação paramétrica estável.",
                                "Interpretar trade-off: PM+10° reduz ||S||∞ em 20% mas dobra tempo de subida.",
                                "Documentar otimização em relatório com figuras.",
                                "Validar com μ-analysis: μ<1 para pacote de incertezas."
                              ],
                              "assessmentCriteria": [
                                "Precisão da aplicação da aproximação PM-H∞ (erro <5%).",
                                "Qualidade da formatação de malha (picos |S|<3dB).",
                                "Análise de trade-offs quantitativa e justificada.",
                                "Validação via simulações robustas (3+ cenários).",
                                "Clareza na documentação e interpretação física.",
                                "Criatividade em otimização dentro de specs conflitantes."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Análise de funções complexas e normas em espaços de Hardy.",
                                "Física: Modelagem dinâmica de sistemas com perturbações estocásticas.",
                                "Computação: Algoritmos numéricos para síntese H∞ (Riccati equations).",
                                "Engenharia Mecânica: Controle de vibrações em estruturas flexíveis.",
                                "Estatística: Análise de sensibilidade e Monte Carlo para robustez."
                              ],
                              "realWorldApplication": "Na indústria aeroespacial, integrar PM com H∞ otimiza controladores de flight envelope protection em aeronaves como o Boeing 787, garantindo estabilidade robusta a variações de aerodinâmica (Mach, altitude) e falhas atuadores, reduzindo risco de flutter e melhorando margem de segurança certificada pela FAA."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.3.6",
                    "name": "Síntese do Controlador",
                    "description": "Construção de controladores estabilizadores via parametrização após formatação da malha.",
                    "individualConcepts": [
                      {
                        "id": "10.1.3.6.1",
                        "name": "Parâmetrização de Controladores Estabilizadores",
                        "description": "Representação da família completa de controladores estabilizadores para uma planta após formatação da malha, utilizando a parametrização de Youla-Kučera com um parâmetro livre Q estável.",
                        "specificSkills": [
                          {
                            "id": "10.1.3.6.1.1",
                            "name": "Calcular fatores de Bezout biproprios",
                            "description": "Determinar os fatores biproprios X, Y, M, N a partir das fatorizações coprimas direita e esquerda da planta P normalizada, resolvendo a equação de Bezout para garantir estabilidade interna.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Normalizar a planta P e obter fatorizações coprimas direita e esquerda",
                                  "subSteps": [
                                    "Normalizar a planta P dividindo numerador e denominador pelo conteúdo de Bezout para garantir que as fatorizações sejam biproprias.",
                                    "Computar a fatorização coprima direita: P = N M^{-1}, onde N e M são coprimos e estáveis.",
                                    "Computar a fatorização coprima esquerda: P = \\tilde{M}^{-1} \\tilde{N}, onde \\tilde{M} e \\tilde{N} são coprimos e estáveis.",
                                    "Verificar coprimaridade usando o algoritmo de Euclides estendido para confirmar gcd(N, M) = 1 e gcd(\\tilde{M}, \\tilde{N}) = 1.",
                                    "Anotar as expressões explícitas de N, M, \\tilde{M}, \\tilde{N}."
                                  ],
                                  "verification": "Confirme que P = N M^{-1} = \\tilde{M}^{-1} \\tilde{N} e que as pares são coprimos via algoritmo de Euclides.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Software de álgebra simbólica (MATLAB Symbolic Toolbox ou Mathematica)",
                                    "Papel e calculadora para exemplos simples"
                                  ],
                                  "tips": "Comece com plantas de baixa ordem (grau 1 ou 2) para praticar; normalize dividindo por leading coefficient.",
                                  "learningObjective": "Dominar a preparação de fatorizações biproprias coprimas para plantas normalizadas.",
                                  "commonMistakes": [
                                    "Esquecer a normalização, levando a identidades de Bezout não unitárias.",
                                    "Confundir fatorizações direita e esquerda.",
                                    "Não verificar coprimaridade."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Formular a equação de Bezout bipropria",
                                  "subSteps": [
                                    "Escrever a equação bipropria: encontrar unimodulares X e Y tais que X \\tilde{M} - Y \\tilde{N} = I.",
                                    "Identificar os anéis apropriados (polinômios estáveis, RH-infinito).",
                                    "Usar propriedades de coprimaridade para garantir existência de X e Y unimodulares.",
                                    "Preparar matrizes ou expressões para resolução (ex: Sylvester matrix para polinômios).",
                                    "Definir os fatores M e N como parte da parametrização, garantindo estabilidade."
                                  ],
                                  "verification": "A equação X \\tilde{M} - Y \\tilde{N} = I está corretamente formulada com símbolos anotados.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Folha de anotações",
                                    "Referência teórica (livro de controle avançado como Zhou ou Vidyasagar)"
                                  ],
                                  "tips": "Lembre-se que para biproprios, det(X) e det(Y) devem ser unidades (constantes de módulo 1).",
                                  "learningObjective": "Entender a formulação teórica da identidade de Bezout bipropria para estabilidade interna.",
                                  "commonMistakes": [
                                    "Confundir o sinal na equação (deve ser X \\tilde{M} - Y \\tilde{N}).",
                                    "Ignorar unimodularidade de X e Y.",
                                    "Usar fatorizações não estáveis."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Resolver a equação de Bezout para X, Y, M e N",
                                  "subSteps": [
                                    "Aplicar o algoritmo de Euclides estendido bivariado para resolver X \\tilde{M} - Y \\tilde{N} = I.",
                                    "Para polinômios, construir a matriz de Sylvester e resolver o sistema linear.",
                                    "Implementar numericamente em software para plantas de ordem superior.",
                                    "Ajustar M e N da fatorização direita usando os resultados, garantindo bipropriedade.",
                                    "Verificar que X e Y são unimodulares (inversos também estáveis)."
                                  ],
                                  "verification": "Calcule X \\tilde{M} - Y \\tilde{N} e confirme que resulta em I (identidade).",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "MATLAB ou Python com Control Systems Library",
                                    "Exemplo numérico impresso"
                                  ],
                                  "tips": "Use sym2poly e poly2sym no MATLAB para manipulação simbólica; teste com P(s) = 1/(s+1).",
                                  "learningObjective": "Executar resolução prática da equação de Bezout bipropria.",
                                  "commonMistakes": [
                                    "Erros aritméticos na resolução estendida de Euclides.",
                                    "Gerar X ou Y não unimodulares.",
                                    "Não escalar corretamente para identidade unitária."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificar estabilidade interna e finalizar fatores biproprios",
                                  "subSteps": [
                                    "Verificar estabilidade de X, Y, M, N no conjunto de estabilidade (pólo no semiplano esquerdo).",
                                    "Confirmar que os controladores Q parametrizados por Youla são estabilizadores.",
                                    "Testar com um controlador simples C = (X - Q Y) (M - N Q)^{-1}.",
                                    "Documentar todos os fatores X, Y, M, N explicitamente.",
                                    "Analisar sensibilidade ou robustez básica dos fatores."
                                  ],
                                  "verification": "Todos os fatores têm pólos estáveis e a equação de Bezout holds; simule resposta em malha fechada.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Simulador (Simulink ou Python control library)",
                                    "Gráficos de pólos e zeros"
                                  ],
                                  "tips": "Use pole() e zero() no MATLAB para verificação rápida de estabilidade.",
                                  "learningObjective": "Garantir que os fatores biproprios suportem parametrização estabilizadora.",
                                  "commonMistakes": [
                                    "Aceitar fatores instáveis.",
                                    "Não testar a identidade Bezout numericamente.",
                                    "Ignorar normalização final."
                                  ]
                                }
                              ],
                              "practicalExample": "Para P(s) = (s+2)/((s+1)(s+3)), normalize e compute fatorizações: direita N(s)=(s+2)/((s+4)), M(s)=(s+1)(s+3)/((s+4)); esquerda similar. Resolva X \\tilde{M} - Y \\tilde{N} = 1 (escalar), obtendo X=0.25(s+3), Y=0.25(s+2), etc. Verifique identidade e estabilidade.",
                              "finalVerifications": [
                                "X \\tilde{M} - Y \\tilde{N} = I exatamente.",
                                "Todos os fatores (X,Y,M,N) são estáveis (pólos no Re(s)<0).",
                                "X e Y são unimodulares (inversos também estáveis).",
                                "P = N M^{-1} = \\tilde{M}^{-1} \\tilde{N} holds.",
                                "Simulação de malha fechada com C estabilizador não oscila.",
                                "Coprimaridade confirmada via gcd=1."
                              ],
                              "assessmentCriteria": [
                                "Precisão na resolução da equação Bezout (erro <1e-6).",
                                "Correta identificação de unimodularidade e estabilidade.",
                                "Eficiência computacional (tempo <2h para ordem 3).",
                                "Documentação clara de todos os fatores.",
                                "Aplicação correta em parametrização Youla.",
                                "Ausência de erros comuns como não-normalização."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Álgebra de polinômios e identidades de Bezout.",
                                "Programação: Implementação numérica em MATLAB/Python para sistemas lineares.",
                                "Física: Modelagem de sistemas dinâmicos lineares invariantes no tempo.",
                                "Engenharia de Software: Verificação e validação de algoritmos de controle."
                              ],
                              "realWorldApplication": "Em controle avançado de plantas industriais como motores elétricos ou processos químicos, os fatores biproprios permitem sintetizar controladores robustos via parametrização Youla, garantindo estabilidade interna apesar de incertezas no modelo da planta."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.6.1.2",
                            "name": "Construir o controlador central C0",
                            "description": "Obter o controlador central estabilizador C0 = (X + D Q)(Y + N Q)^(-1), onde D e N são fatores da planta, e verificar sua estabilidade para sistemas LIT monovariáveis.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Realizar a fatorização coprima estável da planta P",
                                  "subSteps": [
                                    "Identificar a função de transferência da planta P(s) como fração própria P(s) = num(s)/den(s)",
                                    "Escolher uma fatorização coprima direita estável P = N D^{-1}, onde N e D são funções próprias estáveis e bipropriedade de Bezout é satisfeita",
                                    "Normalizar N e D para que sejam bipropriedade com ganho DC unitário, usando multiplicadores de unimodularidade se necessário",
                                    "Verificar estabilidade de N e D usando critérios de Routh-Hurwitz ou simulação de polos",
                                    "Documentar as expressões de N(s) e D(s)"
                                  ],
                                  "verification": "Confirme que todos os polos de N e D estão no semiplano esquerdo e que N D^{-1} = P",
                                  "estimatedTime": "1.5 horas",
                                  "materials": "Papel e lápis, MATLAB/Simulink para plotar polos, tabela de Routh",
                                  "tips": "Para plantas SISO instáveis, use fatorização espectral ou métodos de estabilização interna",
                                  "learningObjective": "Dominar a construção de fatorizações coprima estáveis para plantas LTI SISO",
                                  "commonMistakes": "Esquecer de normalizar para bipropriedade; confundir left e right factorization"
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Resolver a identidade de Bezout para obter X e Y",
                                  "subSteps": [
                                    "Estabelecer a equação de Bezout: encontrar X e Y estáveis tais que X N + Y D = I",
                                    "Para SISO, usar o Algoritmo Estendido de Euclides para resolver X N - Y D = 1 (ajustar sinal)",
                                    "Implementar numericamente no MATLAB usando funções como tf2ss ou resolva manualmente para baixa ordem",
                                    "Verificar a solução multiplicando X N + Y D e confirmando identidade unitária",
                                    "Garantir que X e Y sejam estritamente próprios se necessário para implementação física"
                                  ],
                                  "verification": "Multiplique X*N + Y*D e obtenha matriz identidade (ou 1 para SISO)",
                                  "estimatedTime": "2 horas",
                                  "materials": "MATLAB com Control System Toolbox, calculadora simbólica (Symbolic Math Toolbox)",
                                  "tips": "Comece com plantas de baixa ordem para praticar o algoritmo de Euclides",
                                  "learningObjective": "Aplicar o algoritmo estendido de Euclides em funções racionais para fatorizações coprimas",
                                  "commonMistakes": "Erros de sinal na equação Bezout; não verificar estabilidade de X e Y"
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Sintetizar o controlador central C0",
                                  "subSteps": [
                                    "Aplicar a fórmula C0 = X Y^{-1} (ou (X + D Q)(Y + N Q)^{-1} com Q=0)",
                                    "Simplificar a expressão racional de C0 usando cancelamentos comuns",
                                    "Converter C0 para forma de função de transferência mínima e estável",
                                    "Verificar ordem e estrutura (propriedade estrita se aplicável)",
                                    "Simular resposta em malha aberta de C0 com P para inspeção inicial"
                                  ],
                                  "verification": "Confirme que C0 = X * inv(Y) algebricamente e que é próprio",
                                  "estimatedTime": "1 hora",
                                  "materials": "MATLAB para tf (transfer function), plot de Bode",
                                  "tips": "Use feedback() no MATLAB para checar loop fechado após síntese",
                                  "learningObjective": "Construir o controlador central parametrizado a partir de Bezout factors",
                                  "commonMistakes": "Cancelamentos inválidos levando a não mínima realização; inverter ordem"
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificar a estabilidade do sistema em malha fechada com C0",
                                  "subSteps": [
                                    "Calcular funções sensibilidade S = (I + P C0)^{-1} e complemento T = P C0 (I + P C0)^{-1}",
                                    "Analisar polos do sistema fechado usando characteristic equation det(I + P C0)=0",
                                    "Aplicar Routh-Hurwitz ou Nyquist para confirmar estabilidade",
                                    "Simular step response e plotar polos para visualização",
                                    "Testar robustez variando parâmetros da planta ligeiramente"
                                  ],
                                  "verification": "Todos polos do loop fechado no semiplano esquerdo; step response sem overshoot excessivo",
                                  "estimatedTime": "1.5 horas",
                                  "materials": "MATLAB step(), pole(), nyquist(), rlocus()",
                                  "tips": "Use margin() para ganhos de fase e estabilidade relativa",
                                  "learningObjective": "Validar estabilidade de controladores parametrizados via análise clássica e moderna",
                                  "commonMistakes": "Confundir estabilidade aberta com fechada; ignorar modos não mínimos"
                                }
                              ],
                              "practicalExample": "Para planta P(s) = 1/(s(s+1)), fatorize como N(s)=(s+0.5)/(s+2), D(s)=(s+1.5)/(s+2) (estáveis após normalização). Resolva Bezout para X(s)=1.5/(s+2), Y(s)=(0.5 s +1)/(s+2). Então C0(s) = X/Y = 1.5 / (0.5 s +1) = 3/(s+2). Simule loop fechado: step response estabiliza em 1 sem oscilações.",
                              "finalVerifications": [
                                "C0 estabiliza P: polos fechados no LHP",
                                "X N + Y D = I exatamente",
                                "N D^{-1} = P e ambos estáveis",
                                "C0 é próprio e realizável",
                                "Simulação step confirma rastreamento unitário",
                                "Bode plot mostra margens de estabilidade >6dB/45°"
                              ],
                              "assessmentCriteria": [
                                "Precisão na fatorização coprima (erro <1%)",
                                "Correção da Bezout identity (exata)",
                                "Estabilidade comprovada de C0 (todos testes passados)",
                                "Eficiência: tempo total <6 horas",
                                "Documentação clara com plots e equações",
                                "Robustez: variação 10% em P ainda estável"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Álgebra de frações racionais e algoritmo de Euclides",
                                "Programação: Implementação em MATLAB para análise de sistemas",
                                "Física: Modelagem dinâmica de sistemas mecânicos/elétricos",
                                "Estatística: Análise de robustez via Monte Carlo em parâmetros"
                              ],
                              "realWorldApplication": "Em automação industrial, C0 é usado como base para controladores PID-like em motores DC ou processos químicos, permitindo tuning via Q para performance otimizada enquanto garante estabilidade inerente em plantas instáveis como inversores pendulares."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.6.1.3",
                            "name": "Gerar a família de controladores estabilizadores",
                            "description": "Expressar todos os controladores estabilizadores como C = (X + D Q)(Y + N Q)^(-1) para qualquer Q estável com norma adequada, e demonstrar que estabilizam a malha fechada.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Fatoração Coprima e Identidade de Bezout",
                                  "subSteps": [
                                    "Realizar a fatoração coprima da planta G(s) = N(s)/D(s), onde N e D são fatores estáveis e coprimos no anel de frações estáveis.",
                                    "Identificar soluções X e Y estáveis tais que X N - Y D = 1 (identidade de Bezout).",
                                    "Verificar que X e Y são bezoutianos usando ferramentas simbólicas.",
                                    "Explorar propriedades de estabilidade dos fatores.",
                                    "Discutir normalizações para garantir normas adequadas."
                                  ],
                                  "verification": "Confirmar que X N - Y D = 1 e todos os fatores são estáveis via simulação ou cálculo simbólico.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Livro de Doyle ou Zhou (Feedback Control Theory), MATLAB Symbolic Toolbox ou Python SymPy.",
                                  "tips": "Comece com plantas simples como G(s) = 1/(s+1) para praticar fatoração.",
                                  "learningObjective": "Compreender os blocos fundamentais para parametrização de controladores.",
                                  "commonMistakes": "Esquecer de normalizar fatores para ||N||∞ <1 ou assumir coprimos sem verificar."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Derivar a Forma Parametrizada do Controlador Estabilizador",
                                  "subSteps": [
                                    "Partir do controlador nominal C0 = X Y^{-1} que estabiliza G.",
                                    "Introduzir o parâmetro Q estável e expressar C = (X + D Q)(Y + N Q)^{-1}.",
                                    "Verificar invertibilidade de (Y + N Q) assumindo ||Q||∞ pequeno.",
                                    "Expandir algebricamente para mostrar generalidade.",
                                    "Discutir condições de norma para Q garantir estabilidade."
                                  ],
                                  "verification": "Derivar explicitamente C para um C0 conhecido e comparar.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Papel e lápis para derivação, LaTeX ou notebook Jupyter para documentar.",
                                  "tips": "Use diagramas de bloco para visualizar a inserção de Q no laço de Youla.",
                                  "learningObjective": "Expressar todos os controladores estabilizadores na forma parametrizada.",
                                  "commonMistakes": "Inverter a ordem na expressão ou ignorar a invertibilidade de Y + N Q."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Demonstrar Estabilidade da Malha Fechada",
                                  "subSteps": [
                                    "Calcular as funções de transferência sensíveis: S = (Y + N Q)^{-1}, T = N (X + D Q)^{-1} N, etc.",
                                    "Mostrar que todas as 4 funções de transferência da malha fechada são estáveis pois são combinações estáveis.",
                                    "Verificar estabilidade interna usando o lema de small gain para ||Q||∞ < 1/||N||∞ ||D||∞.",
                                    "Simular respostas em malha fechada para diferentes Q.",
                                    "Analisar robustez variando Q."
                                  ],
                                  "verification": "Plotar polos da malha fechada e confirmar todos no semiplano esquerdo.",
                                  "estimatedTime": "75 minutos",
                                  "materials": "MATLAB Control System Toolbox ou Python Control Library.",
                                  "tips": "Use Q = 0 para recuperar o controlador nominal e validar.",
                                  "learningObjective": "Provar que qualquer Q estável adequado estabiliza a malha.",
                                  "commonMistakes": "Esquecer termos cruzados nas funções sensíveis ou assumir estabilidade sem norma."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar em Exemplo Prático e Generalizar",
                                  "subSteps": [
                                    "Escolher uma planta exemplo e computar fatoração coprima.",
                                    "Gerar família de C variando Q (ex: Q = k / (s+1)^2 para k pequeno).",
                                    "Simular step response para vários C e comparar desempenho.",
                                    "Discutir trade-offs como ganho vs. robustez ao variar Q.",
                                    "Generalizar para MIMO se tempo permitir."
                                  ],
                                  "verification": "Gerar pelo menos 3 controladores diferentes e mostrar estabilidade em simulações.",
                                  "estimatedTime": "90 minutos",
                                  "materials": "MATLAB/Simulink para simulações, exemplos de Zhou's Robust Control book.",
                                  "tips": "Escolha plantas instáveis como G(s)=1/s(s-1) para drama.",
                                  "learningObjective": "Implementar e validar a parametrização em prática.",
                                  "commonMistakes": "Escolher Q não estável ou com norma excessiva causando instabilidade."
                                }
                              ],
                              "practicalExample": "Para a planta G(s) = 1/(s(s+1)), fatorize coprimamente com N=1/(s(s+1)), D=1 (após normalização). Soluções Bezout: X= s+1, Y= s. Então C = (s+1 + Q)(s + 1/(s(s+1)) Q)^{-1}. Para Q=0, recupera C=s+1. Simule step response mostrando estabilidade para ||Q||∞<1.",
                              "finalVerifications": [
                                "Expressão correta de C em termos de X, Y, N, D, Q.",
                                "Prova algébrica ou diagramática de estabilidade para qualquer Q estável adequado.",
                                "Simulações numéricas confirmam estabilidade da malha fechada.",
                                "Identificação de condições de norma para Q.",
                                "Geração de pelo menos dois controladores da família com diferentes desempenhos.",
                                "Verificação de invertibilidade de Y + N Q."
                              ],
                              "assessmentCriteria": [
                                "Precisão na derivação da forma parametrizada (100% correta).",
                                "Correta demonstração de estabilidade com funções sensíveis.",
                                "Uso apropriado de normas para Q e análise de robustez.",
                                "Qualidade das simulações e interpretação de resultados.",
                                "Clareza na documentação e generalização do método.",
                                "Identificação de erros comuns e como evitá-los."
                              ],
                              "crossCurricularConnections": [
                                "Álgebra Linear: Fatorações coprimas e identidade de Bezout como extensão de identidades matriciais.",
                                "Otimização: Escolha de Q para minimizar normas H-infinito ou LQG.",
                                "Processamento de Sinais: Filtragem adaptativa via parâmetros Q.",
                                "Matemática Aplicada: Teoria de anéis e frações estáveis."
                              ],
                              "realWorldApplication": "Em controle de processos industriais como destiladores ou aviões, a parametrização permite sintetizar controladores robustos otimizando Q para rejeição de distúrbios ou incertezas de modelo, usado em sistemas autopilot da Boeing ou controle de reatores nucleares."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.3.6.2",
                        "name": "Síntese do Controlador via Seleção de Q",
                        "description": "Escolha do parâmetro livre Q para construir controladores que atendam especificações de desempenho e robustez após a formatação da malha padrão.",
                        "specificSkills": [
                          {
                            "id": "10.1.3.6.2.1",
                            "name": "Especificar funções de sensibilidade na malha parametrizada",
                            "description": "Expressar as funções de sensibilidade S, T, KS e CS em termos de Q e definir requisitos como ||W_e S||_∞ <1 para rastreamento e rejeição de distúrbios.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar conceitos fundamentais de funções de sensibilidade",
                                  "subSteps": [
                                    "Recordar a definição de S (sensibilidade): S = (I + P K)^{-1}",
                                    "Entender T (função complementar): T = P K S",
                                    "Identificar KS (sensibilidade de entrada): KS = K S",
                                    "Explicar CS (sensibilidade de controle): CS = K (I + P K)^{-1}"
                                  ],
                                  "verification": "Listar corretamente as quatro funções de sensibilidade e suas interpretações físicas (rastreamento, rejeição de distúrbios, ruído, etc.)",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Livro de Controle Avançado (e.g., Zhou, Doyle, Glover)",
                                    "Notas de aula sobre malha de controle padrão",
                                    "Folha de fórmulas de sensibilidade"
                                  ],
                                  "tips": [
                                    "Visualize as funções em diagramas de bloco para melhor compreensão",
                                    "Associe cada função a um sinal específico: referência, distúrbio, ruído"
                                  ],
                                  "learningObjective": "Compreender o significado físico e matemático das funções S, T, KS e CS na malha de controle fechado",
                                  "commonMistakes": [
                                    "Confundir S com T (S + T = I)",
                                    "Esquecer que T é a função de transferência para referência"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Introduzir a parametrização da malha com o parâmetro Q",
                                  "subSteps": [
                                    "Explicar a parametrização de Youla-Kucera: todos os estabilizadores como K = (X + D Q)(Y - N Q)^{-1}",
                                    "Derivar as expressões básicas da malha parametrizada: P K = (V - N Q)(U + M Q)^{-1}",
                                    "Entender as propriedades: todos os controladores estabilizantes são obtidos variando Q estável",
                                    "Verificar estabilidade: ||Q||_∞ < γ garante robustez",
                                    "Discutir o papel de N, D, M, V nos fatores de Bezout"
                                  ],
                                  "verification": "Desenhar o diagrama da malha parametrizada e listar os fatores coprimos (N, D, M, V)",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Artigo original de Youla ou capítulo sobre parametrização",
                                    "Software MATLAB/Simulink para visualização",
                                    "Diagrama de malha parametrizada impresso"
                                  ],
                                  "tips": [
                                    "Comece com um exemplo simples de P mínimo de fase para coprimos",
                                    "Use H-infinito toolbox para simular Q"
                                  ],
                                  "learningObjective": "Dominar a estrutura da malha parametrizada e como Q captura todos os controladores estabilizantes",
                                  "commonMistakes": [
                                    "Confundir N (parte instável de P) com D",
                                    "Esquecer que Q deve ser estável e próprio"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Expressar funções de sensibilidade em termos de Q",
                                  "subSteps": [
                                    "Derivar S = (I + P K)^{-1} = M (U + M Q)^{-1}",
                                    "Obter T = P K S = N Q (U + M Q)^{-1} + V (U + M Q)^{-1}",
                                    "Calcular KS = K S = (X + D Q) (U + M Q)^{-1}",
                                    "Derivar CS = K (I + P K)^{-1} = (X + D Q) M (U + M Q)^{-1}",
                                    "Simplificar assumindo normalização: S = (1 + Q)^{-1}, T = Q (1 + Q)^{-1}"
                                  ],
                                  "verification": "Escrever as quatro expressões exatas em termos de Q, N, D, M, V e validar com um P conhecido",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Caderno para derivações algébricas",
                                    "MATLAB para verificação simbólica com tf e feedback",
                                    "Referência: Skogestad - Multivariable Feedback Control"
                                  ],
                                  "tips": [
                                    "Use identidades de Bezout: M N - D V = 0 para simplificações",
                                    "Teste com Q=0 (controlador nominal)"
                                  ],
                                  "learningObjective": "Derivar precisamente S, T, KS e CS como funções de Q na parametrização",
                                  "commonMistakes": [
                                    "Erro na inversão: esquecer (U + M Q)^{-1}",
                                    "Não considerar o caso normalizado"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Definir e especificar requisitos de performance",
                                  "subSteps": [
                                    "Introduzir pesos de performance: W_e para erro, W_u para controle, W_n para ruído",
                                    "Especificar ||W_e S||_∞ < 1 para bom rastreamento e rejeição de distúrbios",
                                    "Definir ||W_u KS||_∞ < 1 para limitação de esforço de controle",
                                    "Estabelecer ||T||_∞ < 1 para rejeição de ruído em altas frequências",
                                    "Formular o problema como encontrar Q estável tal que ||[W_e S; W_u KS]||_∞ < 1",
                                    "Verificar robustez: ||W_r (I - M S)||_∞ < 1 para incertezas"
                                  ],
                                  "verification": "Especificar um conjunto de requisitos para um exemplo dado e plotar as curvas de Bode das funções ponderadas",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "MATLAB H-infinito toolbox (hinfsyn, sigma)",
                                    "Templates de pesos W_e, W_u",
                                    "Exemplos de plantas industriais"
                                  ],
                                  "tips": [
                                    "Escolha pesos baseados em especificações de banda e margens",
                                    "Use sigma para plotar normas infinitas"
                                  ],
                                  "learningObjective": "Traduzir requisitos de engenharia em condições de norma H-infinito na parametrização Q",
                                  "commonMistakes": [
                                    "Ignorar fase nos pesos W",
                                    "Confundir ||.||_∞ com ganho em DC"
                                  ]
                                }
                              ],
                              "practicalExample": "Considere uma planta P(s) = 1/(s(s+1)) para controle de posição de um carrinho. Normalize coprimos, escolha Q(s) = 0.5 ω_c / (s + ω_c) com ω_c=10 rad/s. Derive S = 1/(1+Q), T = Q/(1+Q), etc. Especifique W_e = 1/(T s +1) com T=0.1s e verifique ||W_e S||_∞ <0.9 via simulação em MATLAB, garantindo erro de rastreamento <10% e rejeição de distúrbio.",
                              "finalVerifications": [
                                "Derivações corretas de S, T, KS, CS em termos de Q confirmadas algebricamente",
                                "Requisitos como ||W_e S||_∞ <1 e ||W_u KS||_∞ <1 explicitamente definidos",
                                "Simulação em Bode plot mostra cumprimento das normas infinitas",
                                "Interpretação física: bom rastreamento em baixas freq., atenuação de ruído em altas",
                                "Q é estável e resulta em controlador próprio",
                                "Teste com perturbação unitária: overshoot <20%, tempo de assentamento <2s"
                              ],
                              "assessmentCriteria": [
                                "Precisão das expressões matemáticas (100% correto)",
                                "Correta interpretação dos requisitos H-infinito",
                                "Qualidade das simulações e plots (Bode, step response)",
                                "Capacidade de escolher pesos adequados ao contexto",
                                "Explicação clara das conexões com performance real",
                                "Identificação de trade-offs (e.g., robustez vs. performance)"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Álgebra de operadores, normas H-infinito e teoria de singular values",
                                "Programação: Simulação em MATLAB/Simulink com toolboxes de controle",
                                "Física: Modelagem dinâmica de sistemas lineares invariantes no tempo",
                                "Otimização: Problemas de minimização de normas para síntese de controladores",
                                "Engenharia de Software: Implementação de algoritmos de controle parametrizado"
                              ],
                              "realWorldApplication": "Em indústrias aeroespacial e automotiva, como no controle de flaps de aviões ou suspensão ativa de veículos, onde se especificam funções de sensibilidade via Q para garantir rastreamento preciso de referências, rejeição de turbulências/distúrbios e robustez a variações de parâmetros, otimizando performance com normas H-infinito para certificação de segurança."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.6.2.2",
                            "name": "Minimizar normas H∞ para síntese de Q",
                            "description": "Resolver o problema de otimização || Fl(P, C(Q)) ||_∞ < γ via equações de Riccati ou métodos numéricos para encontrar Q ótimo que estabiliza e otimiza desempenho.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender fundamentos da norma H∞ e síntese de Q",
                                  "subSteps": [
                                    "Revise a definição da norma H∞ para sistemas lineares: sup_w |T(jw)|.",
                                    "Estude o grafo de malha fechada Fl(P, C(Q)) e seu significado em controle robusto.",
                                    "Analise o papel de Q na parametrização de controladores estabilizantes via Youla.",
                                    "Identifique condições para existência de Q que minimize a norma H∞.",
                                    "Explore exemplos simples de síntese de Q em sistemas monovariáveis."
                                  ],
                                  "verification": "Responda corretamente a 5 perguntas de um quiz sobre normas H∞ e parametrização Q.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Livro 'Feedback Control Theory' de Doyle",
                                    "Notas de aula sobre H∞",
                                    "MATLAB para simulações básicas"
                                  ],
                                  "tips": "Comece com sistemas SISO simples para fixar conceitos antes de generalizar.",
                                  "learningObjective": "Ao final, explicar verbalmente o problema de síntese H∞ via Q e sua relevância para robustez.",
                                  "commonMistakes": [
                                    "Confundir norma H∞ com H2",
                                    "Ignorar estabilidade interna na parametrização",
                                    "Não considerar pesos de desempenho"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Formular o problema de otimização ||Fl(P, C(Q))||_∞ < γ",
                                  "subSteps": [
                                    "Defina a planta P e pesos W_e, W_u para especificações de desempenho.",
                                    "Escreva a expressão explícita de Fl(P, C(Q)) em termos de Q.",
                                    "Formule a desigualdade de Bessel para ||T||_∞ < γ via desigualdades lineares em Q.",
                                    "Estabeleça o problema como inf_γ tal que existe Q estabilizante com norma < γ.",
                                    "Verifique condições iniciais para γ admissível via análise de singular values."
                                  ],
                                  "verification": "Escreva a formulação matemática completa e compute γ inicial para uma planta dada.",
                                  "estimatedTime": "3 horas",
                                  "materials": [
                                    "Paper 'H∞ Control by State-Space Methods'",
                                    "MATLAB Hinfsyn toolbox",
                                    "Folha de papel para derivações"
                                  ],
                                  "tips": "Use blocos de diagrama para visualizar Fl(P, C(Q)) e facilitar a derivação.",
                                  "learningObjective": "Ao final, formular independentemente o problema H∞ para qualquer P monovariável.",
                                  "commonMistakes": [
                                    "Esquecer pesos de entrada/saída",
                                    "Não linearizar corretamente em Q",
                                    "Confundir Fl com loop aberto"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Resolver via equações de Riccati para Q ótimo",
                                  "subSteps": [
                                    "Derive as equações de Riccati diferenciais associadas ao problema H∞ via Hamilton-Jacobi.",
                                    "Converta para equações algébricas de Riccati (ARE) assumindo periodicidade.",
                                    "Resolva as AREs para X, Y usando métodos iterativos (e.g., Kleinman algorithm).",
                                    "Construa Q a partir das soluções X, Y: Q = -K_x (I + G K_y)^{-1} K_y.",
                                    "Verifique se as soluções são estabilizantes e positivas."
                                  ],
                                  "verification": "Implemente e resolva AREs para uma planta exemplo, confirmando estabilidade via eigenvalues.",
                                  "estimatedTime": "4 horas",
                                  "materials": [
                                    "MATLAB CARE/DARE solvers",
                                    "Documentação Control System Toolbox",
                                    "Exemplos numéricos de Skogestad"
                                  ],
                                  "tips": "Inicialize iterações com soluções LQR para convergência rápida nas Riccati.",
                                  "learningObjective": "Ao final, derivar e resolver manualmente equações de Riccati para síntese H∞.",
                                  "commonMistakes": [
                                    "Não checar Hamiltoniano para estabilidade",
                                    "Ignorar condições de contorno nas DRE",
                                    "Erros em inversões matriciais"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Implementar métodos numéricos e validar Q ótimo",
                                  "subSteps": [
                                    "Use solvers numéricos como mu-synthesis ou fixed-point iteration para γ ótimo.",
                                    "Implemente em MATLAB: hinfsyn ou tfloop para computar norma H∞ de Fl(P,C(Q)).",
                                    "Otimize γ via bisection ou gradient descent em Q parametrizado.",
                                    "Simule respostas temporais e frequência para validar desempenho.",
                                    "Compare com controladores LQG ou PID para benchmark."
                                  ],
                                  "verification": "Gere plots de Bode e step response mostrando ||Fl||_∞ < γ e estabilidade.",
                                  "estimatedTime": "3 horas",
                                  "materials": [
                                    "MATLAB Robust Control Toolbox",
                                    "Simulink para simulações",
                                    "Dataset de plantas exemplo"
                                  ],
                                  "tips": "Monitore o gap condition para garantir soluções ótimas em métodos numéricos.",
                                  "learningObjective": "Ao final, implementar numericamente síntese H∞ e interpretar resultados.",
                                  "commonMistakes": [
                                    "Singularidade em solvers numéricos sem preconditioning",
                                    "Não plotar todos os canais de Fl",
                                    "Confundir γ ótimo com γ inicial"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Analisar sensibilidade e refinar síntese de Q",
                                  "subSteps": [
                                    "Avalie robustez de Q a variações em P via structured singular value (μ).",
                                    "Refine Q iterativamente reduzindo γ até o limite de performance.",
                                    "Analise trade-offs entre desempenho e robustez via Pareto front.",
                                    "Documente o processo em relatório com equações, códigos e plots.",
                                    "Teste em Simulink com ruído e perturbações reais."
                                  ],
                                  "verification": "Produza relatório com Q final, γ ótimo e análise de robustez aceitável.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Simulink",
                                    "Mu-toolbox MATLAB",
                                    "Template de relatório LaTeX"
                                  ],
                                  "tips": "Use γ ligeiramente acima do ótimo para evitar il-condicionamento numérico.",
                                  "learningObjective": "Ao final, criticamente analisar e refinar controladores H∞ sintetizados.",
                                  "commonMistakes": [
                                    "Sobre-otimizar γ levando a controladores frágeis",
                                    "Ignorar análise de μ-analysis",
                                    "Não documentar iterações"
                                  ]
                                }
                              ],
                              "practicalExample": "Para a planta P(s) = 1/(s^2 - s + 1) com pesos W_e = 1/(s+1), W_u = 0.1, encontre Q ótimo tal que ||Fl(P, C(Q))||_∞ < 1.5 usando Riccati em MATLAB: resolva AREs, simule step response e verifique norma via sigma plot.",
                              "finalVerifications": [
                                "Q parametrizado estabiliza P internamente.",
                                "Norma H∞ de Fl(P, C(Q)) computada < γ alvo.",
                                "Respostas em frequência atendem margens de ganho/fase.",
                                "Simulação temporal sem overshoot excessivo ou steady-state error.",
                                "Análise de robustez via μ < 1 para Δ = 20% variação em P.",
                                "Código MATLAB reproduzível e comentado."
                              ],
                              "assessmentCriteria": [
                                "Correção matemática na formulação e derivação de Riccati (30%).",
                                "Precisão numérica e convergência de solvers (25%).",
                                "Qualidade de plots e interpretação de resultados (20%).",
                                "Análise de trade-offs e robustez (15%).",
                                "Clareza do relatório e código (10%)."
                              ],
                              "crossCurricularConnections": [
                                "Álgebra Linear: Solução de Equações de Riccati e autovalores.",
                                "Otimização Numérica: Algoritmos de minimização de γ.",
                                "Programação: Implementação em MATLAB/Simulink.",
                                "Matemática Aplicada: Teoria de Sistemas Lineares e Transformadas de Laplace.",
                                "Engenharia de Software: Validação e testes de controladores."
                              ],
                              "realWorldApplication": "Aplicado em controle robusto de turbinas eólicas (contra variações de vento), aviões (estabilização em turbulência) e processos químicos (otimização apesar de incertezas paramétricas), garantindo desempenho ótimo sob perturbações não modeladas."
                            },
                            "estimatedTime": "2.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.6.2.3",
                            "name": "Implementar síntese em MATLAB",
                            "description": "Utilizar funções como mixsyn ou hinfsyn no Robust Control Toolbox para sintetizar o controlador a partir da planta normalizada e pesos de desempenho.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar o ambiente MATLAB e carregar dados necessários",
                                  "subSteps": [
                                    "Inicie o MATLAB e verifique se o Robust Control Toolbox está instalado (use 'ver robustctrl').",
                                    "Carregue a planta normalizada (P) e os pesos de desempenho (W1, W2, etc.) do workspace ou arquivo .mat.",
                                    "Defina variáveis auxiliares como número de estados do controlador (nmeas, npol) com base na estrutura da malha.",
                                    "Crie o modelo generalizado G usando funções como 'augw'.",
                                    "Visualize os modelos com 'bode' ou 'sigma' para confirmação inicial."
                                  ],
                                  "verification": "Confirme que todos os modelos (P, W's, G) estão no workspace sem erros e plots iniciais são exibidos corretamente.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "MATLAB com Robust Control Toolbox",
                                    "Arquivos .mat com planta e pesos",
                                    "Documentação do Robust Control Toolbox"
                                  ],
                                  "tips": "Salve o workspace frequentemente com 'save' para evitar perda de dados.",
                                  "learningObjective": "Configurar corretamente o ambiente e modelos para síntese de controladores robustos.",
                                  "commonMistakes": [
                                    "Esquecer de instalar toolbox",
                                    "Dimensões incompatíveis entre plantas e pesos",
                                    "Não normalizar adequadamente os modelos"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Configurar opções de síntese do controlador",
                                  "subSteps": [
                                    "Crie o objeto de opções com 'synopt = synoptions('H2' ou 'Hinf') dependendo do método.",
                                    "Ajuste parâmetros como tolerância (tol), frequência máxima (freq) e ordem do controlador (ncont).",
                                    "Para mixsyn, especifique o modelo Q se aplicável; para hinfsyn, defina gamma inicial.",
                                    "Valide as opções com 'showoptions(synopt)'.",
                                    "Teste uma síntese simples para verificar configuração."
                                  ],
                                  "verification": "Opções são exibidas corretamente via 'showoptions' sem warnings.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Documentação MATLAB: mixsyn, hinfsyn, synoptions"
                                  ],
                                  "tips": "Comece com opções padrão e ajuste iterativamente para convergência.",
                                  "learningObjective": "Personalizar opções para otimizar a síntese de controladores H2/Hinf.",
                                  "commonMistakes": [
                                    "Valores de gamma muito baixos causando não-convergência",
                                    "Especificar ordem errada do controlador",
                                    "Ignorar warnings de dimensionalidade"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Executar a função de síntese (mixsyn ou hinfsyn)",
                                  "subSteps": [
                                    "Execute [C,CL,GAM] = mixsyn(G, nmeas, npol, synopt) ou [C,CL,GAM] = hinfsyn(G, nmeas, npol, synopt).",
                                    "Analise o valor de GAM (performance achieved) e verifique se está abaixo do desejado.",
                                    "Se não convergir, ajuste gamma ou opções e reexecute.",
                                    "Salve o controlador C em variável e arquivo .mat.",
                                    "Gere plots iniciais de resposta em frequência do loop fechado CL."
                                  ],
                                  "verification": "Controlador C é gerado sem erros, GAM é finito e plots do CL são estáveis.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Funções mixsyn/hinfsyn no Robust Control Toolbox"
                                  ],
                                  "tips": "Use 'try-catch' em script para capturar erros de síntese.",
                                  "learningObjective": "Sintetizar com sucesso controladores robustos via MATLAB.",
                                  "commonMistakes": [
                                    "Argumentos errados na ordem (G primeiro)",
                                    "Não checar estabilidade de CL",
                                    "Ignorar iterações para otimizar GAM"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Validar e analisar o controlador sintetizado",
                                  "subSteps": [
                                    "Verifique margens de robustez com 'robuststab' e 'robustperf' em CL.",
                                    "Analise respostas temporais com 'step' ou 'stepinfo' para entradas de referência e distúrbios.",
                                    "Compare com especificações originais (banda, overshoot, etc.).",
                                    "Reduza ordem se necessário com 'balred' ou 'hinfstruct'.",
                                    "Documente resultados em relatório com figuras."
                                  ],
                                  "verification": "Margens >6dB, desempenho atende pesos, relatório salvo.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Funções robuststab, robustperf, stepinfo"
                                  ],
                                  "tips": "Automatize validações em script para reprodutibilidade.",
                                  "learningObjective": "Avaliar integralmente a qualidade do controlador sintetizado.",
                                  "commonMistakes": [
                                    "Não testar robustez",
                                    "Aceitar controlador instável",
                                    "Esquecer redução de ordem para implementação"
                                  ]
                                }
                              ],
                              "practicalExample": "Para uma planta de motor DC normalizada P(s) = 1/(s+1), com pesos W1=0.1, W2=10/(s+1), use hinfsyn para sintetizar C com npol=1, nmeas=1, gamma<1. Resultado: C(s) estável com margens robustas.",
                              "finalVerifications": [
                                "Controlador C sintetizado e salvo sem erros.",
                                "Valor GAM abaixo do limite especificado.",
                                "Plots de CL mostram estabilidade e bom desempenho.",
                                "Margens de robustez calculadas e satisfatórias.",
                                "Análise temporal confirma especificações.",
                                "Script completo reproduz resultados."
                              ],
                              "assessmentCriteria": [
                                "Correta configuração de modelos e opções (20%)",
                                "Execução bem-sucedida da síntese com convergência (30%)",
                                "Validação completa de robustez e desempenho (30%)",
                                "Documentação clara com plots e métricas (10%)",
                                "Eficiência temporal e ausência de erros comuns (10%)"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria de controle ótimo (H2/Hinf)",
                                "Programação: Scripts MATLAB avançados e toolboxes",
                                "Física: Modelagem dinâmica de sistemas",
                                "Engenharia de Software: Validação e testes automatizados"
                              ],
                              "realWorldApplication": "Síntese de controladores para drones autônomos, garantindo estabilidade robusta apesar de variações de massa e vento, usando MATLAB para prototipagem antes de implementação em hardware embarcado."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.3.6.3",
                        "name": "Avaliação e Robustez do Controlador Sintetizado",
                        "description": "Verificação da estabilidade robusta e desempenho do controlador sintetizado via parametrização, considerando incertezas modeladas.",
                        "specificSkills": [
                          {
                            "id": "10.1.3.6.3.1",
                            "name": "Analisar robustez com μ-síntese básica",
                            "description": "Calcular o valor estruturado μ para o sistema fechado com controlador Q, garantindo robustez contra incertezas coprimas ou normais após síntese.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Modelar o sistema nominal e definir incertezas",
                                  "subSteps": [
                                    "Identifique o sistema nominal G(s) e o controlador Q(s).",
                                    "Defina incertezas como Δ_c (coprimas) ou Δ_n (normais), especificando estrutura (blocos 1x1 ou full).",
                                    "Especifique o conjunto de incertezas: ||Δ||_∞ ≤ 1 para normais ou coprimas.",
                                    "Construa funções de transferência para incertezas parametrizadas.",
                                    "Valide o modelo com dados do sistema real ou simulação."
                                  ],
                                  "verification": "Verifique se o modelo nominal simula corretamente e incertezas alteram resposta em ±20%.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "MATLAB com Robust Control Toolbox",
                                    "Funções de transferência do sistema G(s)",
                                    "Documentação de incertezas"
                                  ],
                                  "tips": "Comece com incertezas simples (ganho e fase) antes de estruturas complexas.",
                                  "learningObjective": "Compreender como incertezas estruturadas afetam o sistema fechado.",
                                  "commonMistakes": [
                                    "Ignorar estrutura de Δ levando a μ superestimado",
                                    "Usar normas erradas (H2 em vez de H∞)",
                                    "Não normalizar incertezas adequadamente"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Construir a estrutura generalizada P",
                                  "subSteps": [
                                    "Conecte blocos de entrada/saída de incerteza: insira Δ em pontos de perturbação.",
                                    "Forme a planta generalizada P = [P11 P12; P21 P22] com Q em feedback.",
                                    "Use sysic para criar estrutura de incertezas no MATLAB.",
                                    "Verifique conexões com LFT (Linear Fractional Transformation).",
                                    "Teste estabilidade nominal com margin(P22, Q)."
                                  ],
                                  "verification": "Simule LFT(P, Δ) para Δ=0 e confirme igual ao loop nominal.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "MATLAB Robust Control Toolbox (unc2str, sysic)",
                                    "Modelos de G(s) e Q(s)"
                                  ],
                                  "tips": "Use plot para visualizar singular values de P12 e P21.",
                                  "learningObjective": "Dominar formulação do framework μ para análise estruturada.",
                                  "commonMistakes": [
                                    "Conexões erradas de blocos Δ invertendo entradas/saídas",
                                    "Esquecer normalização ||Δ||≤1",
                                    "Misturar incertezas coprimas com normais"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Formar o sistema fechado M e computar μ",
                                  "subSteps": [
                                    "Calcule M(jω) = Fl(P, Q)(jω) para grades de frequência.",
                                    "Use mussv(M, []) para lower bound e mu (com opções) para upper bound.",
                                    "Defina tolerância para gap entre bounds (ideal <10%).",
                                    "Plote μ vs ω e identifique picos.",
                                    "Ajuste opções para D-K iteração se necessário (mas foque em análise básica)."
                                  ],
                                  "verification": "μ < 1 em todas as frequências confirma robustez.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "MATLAB functions: mussv, mu, usvplot",
                                    "Estrutura P pronta"
                                  ],
                                  "tips": "Use logspace para frequências cobrindo 10^-2 a 10^3 rad/s.",
                                  "learningObjective": "Executar cálculo numérico de μ estruturado com precisão.",
                                  "commonMistakes": [
                                    "Não usar mussv para lower bound levando a bounds frouxos",
                                    "Grid de ω insuficiente em cruzamentos",
                                    "Ignorar warnings de ill-conditioning"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar e interpretar resultados de robustez",
                                  "subSteps": [
                                    "Verifique se max_ω μ(M(jω)) < 1 para robustez garantida.",
                                    "Calcule robustez margin: 1/max(μ).",
                                    "Analise frequência de pior caso e tipo de incerteza dominante.",
                                    "Compare com análise H∞ (μ ≤ ||Tzw||_∞).",
                                    "Documente conclusões em relatório com plots."
                                  ],
                                  "verification": "Relatório mostra μ-plot com bounds e threshold=1 marcado.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Plots de μ (muplot)",
                                    "Relatório template"
                                  ],
                                  "tips": "Se μ>1, sugira redesign de Q via μ-síntese.",
                                  "learningObjective": "Interpretar μ quantitativamente para decisões de design.",
                                  "commonMistakes": [
                                    "Confundir μ com ||M||_∞",
                                    "Não considerar incertezas reais vs conservadoras",
                                    "Ignorar trade-off performance vs robustez"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Validar com simulações de Monte Carlo",
                                  "subSteps": [
                                    "Gere ensemble de Δ aleatórios com ||Δ||_∞ ≤1.",
                                    "Simule respostas fechadas para cada realização.",
                                    "Calcule estatísticas: taxa de instabilidade, desvios RMS.",
                                    "Compare com predições μ.",
                                    "Ajuste se discrepâncias >5%."
                                  ],
                                  "verification": "Taxa de falha simulada < predita por μ.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "wbmrm, lftdata no MATLAB",
                                    "Monte Carlo scripts"
                                  ],
                                  "tips": "Use 100-500 runs para convergência.",
                                  "learningObjective": "Validar análise teórica com simulações empíricas.",
                                  "commonMistakes": [
                                    "Δ não normalizados causando bias",
                                    "Poucas runs levando a variância alta",
                                    "Não testar em banda crítica"
                                  ]
                                }
                              ],
                              "practicalExample": "Para um drone com controlador Q estabilizando posição x, incertezas Δ_c em ganho de motor (±20%) e Δ_n em atraso (0.01s). Construa P, calcule μ(M), confirme μ_max=0.85 <1 garantindo voo robusto apesar variações.",
                              "finalVerifications": [
                                "μ(M(jω)) <1 para todo ω, com bounds convergentes.",
                                "Simulações Monte Carlo mostram estabilidade >95%.",
                                "Relatório identifica frequência crítica e incerteza dominante.",
                                "Comparação com H∞ analysis mostra superioridade de μ.",
                                "Plots de singular values e μ bem documentados.",
                                "Conclusões corretas sobre robustez do Q."
                              ],
                              "assessmentCriteria": [
                                "Precisão no cálculo μ (erro bounds <5%).",
                                "Correta formulação de P e estrutura Δ.",
                                "Interpretação qualitativa/quantitativa de resultados.",
                                "Qualidade de plots e documentação.",
                                "Validação via simulação alinhada com μ.",
                                "Identificação de erros comuns evitados."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Valores singulares estruturados e otimização convexa.",
                                "Programação: Implementação numérica em MATLAB/Python (control systems).",
                                "Física: Modelagem dinâmica com perturbações reais.",
                                "Estatística: Análise Monte Carlo e bounds probabilísticos.",
                                "Engenharia de Software: Validação e testes automatizados."
                              ],
                              "realWorldApplication": "Em controle de aviões (robustez a variações aerodinâmicas), automóveis autônomos (incertezas em sensores) e processos industriais (variações de planta), garantindo estabilidade apesar de incertezas não-modeladas."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.6.3.2",
                            "name": "Validar especificações de desempenho",
                            "description": "Simular respostas transitórias e verificar normas de sensibilidade para o controlador sintetizado, ajustando Q iterativamente se necessário.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar o ambiente de simulação para respostas transitórias",
                                  "subSteps": [
                                    "Carregar o modelo do sistema monovariável e o controlador sintetizado no simulador (ex: MATLAB/Simulink).",
                                    "Definir condições iniciais e entradas de referência padrão (degrau unitário).",
                                    "Configurar parâmetros de simulação: tempo de simulação (ex: 10x tempo de assentamento esperado), tolerâncias numéricas.",
                                    "Implementar o controlador com matriz Q inicial baseada no design anterior.",
                                    "Salvar configuração baseline para iterações futuras."
                                  ],
                                  "verification": "Verificar se o modelo roda sem erros e gera saídas transitórias visíveis nos gráficos.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "MATLAB/Simulink, script do modelo do sistema, controlador sintetizado",
                                  "tips": "Use scopes para visualizar múltiplas saídas simultaneamente e acelere simulações com solvers fixos.",
                                  "learningObjective": "Configurar simulações precisas para análise transitória em sistemas de controle.",
                                  "commonMistakes": "Ignorar condições iniciais não zero, levando a respostas enviesadas; usar tempos de simulação curtos."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Simular e analisar respostas transitórias",
                                  "subSteps": [
                                    "Executar simulação para entrada em degrau e registrar métricas: tempo de subida, sobressinal, tempo de assentamento.",
                                    "Analisar estabilidade: verificar overshoot < 20%, assentamento < 5% em tempo especificado.",
                                    "Plotar curvas de resposta (Y(t), erro) e comparar com especificações de desempenho desejadas.",
                                    "Documentar desvios quantitativos (ex: sobressinal real vs. limite).",
                                    "Repetir para distúrbios e ruído se aplicável."
                                  ],
                                  "verification": "Gráficos mostram métricas transitórias dentro ou fora das specs; relatório com valores numéricos.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Simulink model, análise de sinal toolbox",
                                  "tips": "Automatize extração de métricas com stepinfo() no MATLAB para precisão.",
                                  "learningObjective": "Interpretar e quantificar desempenho transitório de controladores.",
                                  "commonMistakes": "Confundir sobressinal com pico inicial; não normalizar entradas."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular e verificar normas de sensibilidade",
                                  "subSteps": [
                                    "Computar funções de sensibilidade S(s) = 1/(1 + G K) e complemento T(s) = G K /(1 + G K).",
                                    "Calcular normas: ||S||_infty < gamma_1, ||T||_infty < gamma_2 para robustez.",
                                    "Usar funções como norm() ou hinfnorm() para avaliação em frequência.",
                                    "Plotar Bode de S e T, verificando picos abaixo dos limites especificados.",
                                    "Analisar margens de robustez (ex: KS < 1/mu)."
                                  ],
                                  "verification": "Relatório com valores de norma numéricos e plots Bode confirmando conformidade.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Control System Toolbox (MATLAB), funções de análise H-infinito",
                                  "tips": "Escolha gamma conservador inicialmente; foque em frequências críticas do sistema.",
                                  "learningObjective": "Avaliar robustez via normas de sensibilidade em controladores LQG/H-infinito.",
                                  "commonMistakes": "Usar norma errada (ex: H2 em vez de H-infinito); ignorar wrap-around em Bode."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Ajustar iterativamente Q e validar especificações finais",
                                  "subSteps": [
                                    "Identificar violações (transitória ou robustez) e propor ajustes em Q (aumentar pesos em estados críticos).",
                                    "Re-sintetizar controlador com Q ajustado e repetir simulações/normas.",
                                    "Iterar até 3x ou convergência (desvios < 10%).",
                                    "Documentar trade-offs (ex: robustez vs. desempenho transitório).",
                                    "Arquivar versão final validada."
                                  ],
                                  "verification": "Todas métricas atendem specs em simulação final; log de iterações mostra convergência.",
                                  "estimatedTime": "40 minutos",
                                  "materials": "Scripts de síntese LQR/LQG, histórico de Qs",
                                  "tips": "Ajuste diagonal de Q primeiro; use otimização gradient-free se múltiplas iterações.",
                                  "learningObjective": "Otimizar trade-offs em design de controladores via iteração em Q.",
                                  "commonMistakes": "Ajustes excessivos em Q levando a controladores irreais; parar iterações prematuramente."
                                }
                              ],
                              "practicalExample": "Para um sistema de posição de motor DC (G(s) = 1/(s^2 + s)), sintetize K com Q inicial diag([1,10]). Simule degrau: sobressinal 15% (ok), mas ||S||_infty=2.5 >1.5. Aumente Q(2,2)=50, re-simule: sobressinal 10%, ||S||_infty=1.2 (validado).",
                              "finalVerifications": [
                                "Respostas transitórias atendem specs: sobressinal <20%, assentamento <4s.",
                                "Normas de sensibilidade: ||S||_infty <1.5, ||T||_infty <2.0.",
                                "Margens de robustez KS < limite especificado.",
                                "Simulações com variação paramétrica (±20%) mantêm estabilidade.",
                                "Controlador implementável (ganhos finitos, ordem razoável).",
                                "Documentação completa com plots e métricas."
                              ],
                              "assessmentCriteria": [
                                "Precisão das simulações e cálculos de normas (erro <5%).",
                                "Correta identificação e correção de violações via Q.",
                                "Qualidade dos plots e análise quantitativa.",
                                "Eficiência iterativa (convergência em <4 iterações).",
                                "Documentação clara de trade-offs e justificativas.",
                                "Uso apropriado de ferramentas (sem hacks numéricos)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Análise em frequência e normas de operadores (álgebra linear).",
                                "Programação: Scripts MATLAB para automação e análise numérica.",
                                "Física: Modelagem dinâmica de sistemas reais (equações diferenciais).",
                                "Estatística: Análise de Monte Carlo para robustez estocástica."
                              ],
                              "realWorldApplication": "Em plantas industriais como fornos ou robôs, validação garante que controladores lidem com variações de carga/temperatura sem oscilações perigosas, evitando downtime e danos em linhas de produção automotiva."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      }
                    ]
                  }
                ]
              },
              {
                "id": "10.1.4",
                "name": "Parametrização de Controladores Estabilizadores",
                "description": "Métodos de parametrização para síntese de controladores estabilizadores em sistemas LIT.",
                "totalSkills": 47,
                "atomicTopics": [
                  {
                    "id": "10.1.4.1",
                    "name": "Fatorizações Coprimas",
                    "description": "Representação da planta em termos de fatores coprimos estáveis e instáveis para parametrização.",
                    "individualConcepts": [
                      {
                        "id": "10.1.4.1.1",
                        "name": "Definição de Fatorizações Coprimas",
                        "description": "Conceito fundamental de fatorização coprima de uma planta de transferência, incluindo identidades de Bézout e propriedades algébricas para sistemas lineares invariantes no tempo (LIT).",
                        "specificSkills": [
                          {
                            "id": "10.1.4.1.1.1",
                            "name": "Identificar fatores coprimos de uma planta",
                            "description": "Dado um modelo de planta P(s), decompor em fatores N(s) e D(s) coprimos no anel de funções próprias estáveis RH∞, verificando a identidade de Bézout: existir X, Y tal que XN + YD = I.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar conceitos fundamentais de RH∞ e frações próprias biproprias",
                                  "subSteps": [
                                    "Defina RH∞ como o anel de funções próprias racionais estáveis (polos no semiplano aberto esquerdo).",
                                    "Explique fração própria bipropria: N(s) e D(s) em RH∞ com D(s) inversível em RH∞ (det(D(s)) sem zeros no semiplano fechado direito).",
                                    "Discuta a importância da fatorização coprima para parametrização de Youla-Kučera.",
                                    "Identifique quando dois elementos N(s) e D(s) são coprimos: gcd(N,D)=1 em RH∞.",
                                    "Estude a identidade de Bézout como critério de coprimidade."
                                  ],
                                  "verification": "Resuma em um parágrafo os conceitos chave e forneça um exemplo simples de elemento em RH∞.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Livro de controle avançado (ex: Zhou, Doyle, Glover - Robust Control)",
                                    "Notas de aula sobre RH∞",
                                    "Software MATLAB para plotar polos"
                                  ],
                                  "tips": "Use diagramas de polos e zeros para visualizar estabilidade.",
                                  "learningObjective": "Compreender a estrutura algébrica de RH∞ e suas propriedades para fatorizações.",
                                  "commonMistakes": [
                                    "Confundir RH∞ com H∞ (norma)",
                                    "Ignorar bipropriedade (D(s) deve ser inversível em RH∞)"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Representar a planta P(s) em fração própria inicial",
                                  "subSteps": [
                                    "Escreva P(s) = N_p(s)/D_p(s) em fração própria mínima sobre os racionais.",
                                    "Identifique polos e zeros de P(s) e verifique estabilidade/instabilidade.",
                                    "Ajuste para denominadores comuns estáveis multiplicando numerador e denominador por fatores de Blaschke ou algebricamente estáveis.",
                                    "Normalize para que D(s) tenha norma 1 no infinito ou use convenções padrão.",
                                    "Verifique se a representação é bipropria preliminarmente."
                                  ],
                                  "verification": "Produza a fração própria N_p(s)/D_p(s) e liste polos/zeros com gráfico de Bode ou root locus.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "MATLAB/Simulink para tf() e pole()/zero()",
                                    "Papel e lápis para cálculo simbólico",
                                    "Tabela de identidades trigonométricas para Blaschke"
                                  ],
                                  "tips": "Para plantas instáveis, use fatores de Blaschke para mover polos instáveis para estáveis.",
                                  "learningObjective": "Transformar P(s) em uma forma bipropria inicial em RH∞.",
                                  "commonMistakes": [
                                    "Não cancelar fatores comuns instáveis",
                                    "Esquecer normalização para bipropriedade"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Construir fatores coprimos N(s) e D(s) em RH∞",
                                  "subSteps": [
                                    "Escolha um denominador comum estável Q(s) ∈ RH∞ com zeros não compartilhados.",
                                    "Defina N(s) = N_p(s) Q(s)^{-1} e D(s) = D_p(s) Q(s)^{-1}, garantindo ambos em RH∞.",
                                    "Ajuste Q(s) para minimizar norma ou facilitar Bézout (ex: Q(s) = (s+1)^n para estabilidade).",
                                    "Verifique que N(s) e D(s) têm os mesmos zeros/polos relevantes de P(s).",
                                    "Confirme bipropriedade: D(s) inversível em RH∞."
                                  ],
                                  "verification": "Mostre que N(s)/D(s) = P(s) e ambos estão em RH∞ via análise de polos/zeros.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "MATLAB com Robust Control Toolbox para rct() e isstable()",
                                    "SymPy ou Mathematica para manipulação simbólica"
                                  ],
                                  "tips": "Comece com Q(s) simples como produto de (s + a_i) com a_i > 0.",
                                  "learningObjective": "Gerar uma fatorização bipropria estável para P(s).",
                                  "commonMistakes": [
                                    "Escolher Q(s) com zeros em comum com N_p ou D_p",
                                    "Não verificar inversibilidade de D(s)"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificar coprimidade usando identidade de Bézout",
                                  "subSteps": [
                                    "Encontre X(s), Y(s) ∈ RH∞ tais que X(s) N(s) + Y(s) D(s) = I.",
                                    "Use algoritmo estendido de Euclides adaptado para RH∞ (divisão polinomial em s).",
                                    "Resolva para X e Y explicitamente ou numericamente.",
                                    "Verifique a equação Bezout computando o lado esquerdo e confirmando =1.",
                                    "Se falhar, ajuste a fatorização e repita."
                                  ],
                                  "verification": "Exiba X, Y explícitos e comprove XN + YD = I em pontos de teste e simbolicamente.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "MATLAB para sysic (interpolação de controladores)",
                                    "Algoritmo de Euclides em script customizado"
                                  ],
                                  "tips": "Para sistemas de ordem baixa, resolva analiticamente; para altos, use métodos numéricos.",
                                  "learningObjective": "Validar coprimidade via existência de bezoutianos estáveis.",
                                  "commonMistakes": [
                                    "X ou Y saindo de RH∞ (não estável)",
                                    "Erro aritmético em divisão polinomial"
                                  ]
                                }
                              ],
                              "practicalExample": "Para P(s) = 1/(s^2 - s), uma fatorização coprima é N(s) = (s+1)/((s+1)(s+2)), D(s) = (s^2 - s)/((s+1)(s+2)) = (s(s-1))/((s+1)(s+2)). Bezout: X(s) = (s+2)/(s+1), Y(s) = 1/(s+1), pois XN + YD = I. Verifique em MATLAB com tf e conv.",
                              "finalVerifications": [
                                "P(s) = N(s)/D(s) exatamente.",
                                "N(s), D(s) ∈ RH∞ (todos polos no Re(s)<0).",
                                "D(s) biproprio (inversível em RH∞).",
                                "XN + YD = I com X,Y ∈ RH∞.",
                                "Sem fatores comuns entre N e D.",
                                "Fatorização mínima (ordem mínima possível)."
                              ],
                              "assessmentCriteria": [
                                "Precisão na construção de N(s) e D(s) (equivalência a P(s)).",
                                "Correta verificação de estabilidade (todos elementos em RH∞).",
                                "Existência e estabilidade de X,Y na identidade de Bézout.",
                                "Eficiência da escolha de Q(s) (ordem baixa).",
                                "Explicação clara dos passos e justificativas teóricas.",
                                "Tratamento de casos edge (plantas instáveis ou singulares)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Álgebra comutativa e teoria de domínios euclidianos em anéis de Bezout.",
                                "Programação: Implementação numérica em MATLAB/Simulink para validação.",
                                "Física: Modelagem de sistemas dinâmicos lineares invariantes no tempo.",
                                "Engenharia de Software: Verificação formal de propriedades algébricas."
                              ],
                              "realWorldApplication": "Em design de controladores robustos para aviões (ex: estabilização de flight control systems) ou robótica industrial, onde fatorizações coprimas permitem parametrização de todos os estabilizadores via Youla, garantindo estabilidade apesar de incertezas no modelo da planta."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.4.1.1.2",
                            "name": "Verificar coprimaridade via identidade de Bézout",
                            "description": "Resolver para matrizes X(s) e Y(s) bezoutianas que satisfazem a equação matricial para pares biproprios (N, D), usando ferramentas como MATLAB para validação.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os Pares Biproprios e a Identidade de Bézout",
                                  "subSteps": [
                                    "Revise a definição de pares biproprios (N(s), D(s)) em sistemas de controle monovariáveis.",
                                    "Estude a identidade de Bézout: existência de X(s) e Y(s) tais que X(s)N(s) + Y(s)D(s) = 1.",
                                    "Identifique condições para coprimaridade em anéis de polinômios ou funções de Laplace.",
                                    "Analise exemplos simples de polinômios coprimos e não coprimos.",
                                    "Documente as propriedades algébricas relevantes, como divisibilidade."
                                  ],
                                  "verification": "Resuma em um parágrafo as condições da identidade de Bézout e liste 2 exemplos válidos.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Livro de Controle Avançado (ex: Zhou ou Francis)",
                                    "Notas de aula sobre fatorizações coprimas"
                                  ],
                                  "tips": "Use diagramas de Venn para visualizar coprimaridade como ausência de fatores comuns.",
                                  "learningObjective": "Dominar a teoria teórica da identidade de Bézout para pares biproprios.",
                                  "commonMistakes": "Confundir coprimaridade com MDC=1 sem considerar o anel euclidiano apropriado."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Preparar e Configurar a Equação Matricial de Bézout",
                                  "subSteps": [
                                    "Defina os pares biproprios N(s) e D(s) para um controlador estabilizador específico.",
                                    "Escreva a equação matricial X(s)N(s) + Y(s)D(s) = I (para matrizes, ou 1 para escalares).",
                                    "Verifique se N(s) e D(s) são próprios e estáveis usando análise de polos.",
                                    "Selecione um exemplo concreto, como N(s) = s+1, D(s) = s^2 + 2s + 2.",
                                    "Estruture a equação em forma matricial para ferramentas computacionais."
                                  ],
                                  "verification": "Escreva a equação de Bézout explicitamente para o exemplo escolhido e confirme formato matricial.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Papel e lápis ou editor LaTeX",
                                    "Software simbólico como SymPy ou Mathematica"
                                  ],
                                  "tips": "Comece com casos escalares antes de matrizes para construir intuição.",
                                  "learningObjective": "Configurar corretamente a equação de Bézout para validação numérica.",
                                  "commonMistakes": "Esquecer normalização para que o resultado seja a identidade unitária."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Resolver para Matrizes X(s) e Y(s) Bezoutianas",
                                  "subSteps": [
                                    "Aplique o algoritmo estendido de Euclides para polinômios: encontre bezoutianos via divisões sucessivas.",
                                    "Para matrizes, use fatorização de Smith ou métodos de Sylvester para resolver o sistema.",
                                    "Implemente em MATLAB: use funções como gcd, xgcd ou solve para equações diofantinas.",
                                    "Itere soluções se houver múltiplas, selecionando as de grau mínimo.",
                                    "Simplifique X(s) e Y(s) removendo fatores comuns desnecessários."
                                  ],
                                  "verification": "Calcule X(s)N(s) + Y(s)D(s) manualmente ou simbolicamente e confirme igual a 1.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "MATLAB com toolbox de controle",
                                    "Código-fonte exemplo para xgcd em polinômios"
                                  ],
                                  "tips": "Use conv e deconv no MATLAB para operações polinomiais eficientes.",
                                  "learningObjective": "Executar resolução algébrica e computacional de bezoutianos.",
                                  "commonMistakes": "Ignorar graus dos polinômios, levando a soluções instáveis ou de alto grau."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Validar Coprimaridade e Analisar Resultados",
                                  "subSteps": [
                                    "Execute simulação no MATLAB: plote X(s)N(s) + Y(s)D(s) e verifique unidade em todo o plano s.",
                                    "Teste robustez variando parâmetros em N(s) e D(s).",
                                    "Calcule o MDC usando funções built-in e compare com bezoutianos.",
                                    "Documente singularidades ou regiões onde a identidade falha.",
                                    "Gere relatório com gráficos de validação (Bode, Nyquist)."
                                  ],
                                  "verification": "Produza output MATLAB mostrando erro < 1e-10 na identidade de Bézout.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "MATLAB scripts personalizados",
                                    "Ferramentas de plot como bode() e nyquist()"
                                  ],
                                  "tips": "Valide em frequências críticas (0, inf, imaginário puro) primeiro.",
                                  "learningObjective": "Validar computacionalmente a coprimaridade em contextos de controle.",
                                  "commonMistakes": "Confiar apenas em cálculos simbólicos sem verificação numérica."
                                }
                              ],
                              "practicalExample": "Para N(s) = s + 1 e D(s) = s^2 + 3s + 2, aplique Euclides estendido: MDC=1, X(s) = -1.5 + 0.5s, Y(s) = 0.5s + 1. Valide no MATLAB: conv(X, N) + conv(Y, D) == 1.",
                              "finalVerifications": [
                                "X(s)N(s) + Y(s)D(s) = 1 para todo s (simbólico e numérico).",
                                "Graus de X e Y são mínimos possíveis.",
                                "N(s) e D(s) são biproprios (próprios e estáveis).",
                                "Validação em MATLAB com erro residual < 1e-12.",
                                "Teste de sensibilidade a perturbações numéricas.",
                                "Compatibilidade com parametrização de Youla-Kucera."
                              ],
                              "assessmentCriteria": [
                                "Precisão da identidade de Bézout (erro zero simbólico).",
                                "Eficiência computacional (tempo de execução < 5s no MATLAB).",
                                "Correção teórica na escolha de bezoutianos mínimos.",
                                "Qualidade da documentação e gráficos de validação.",
                                "Capacidade de generalizar para matrizes 2x2.",
                                "Identificação correta de casos não coprimos."
                              ],
                              "crossCurricularConnections": [
                                "Álgebra Linear: Resolução de sistemas diofantinos matriciais.",
                                "Programação Numérica: Uso de MATLAB/Simulink para análise de sistemas.",
                                "Teoria dos Números: Algoritmo estendido de Euclides em anéis euclidianos.",
                                "Processamento de Sinais: Análise em domínio da frequência para validação."
                              ],
                              "realWorldApplication": "Em design de controladores robustos para aviões ou robôs, verifica-se coprimaridade de fatorizações de plantas para garantir todos os estabilizadores via parametrização de Youla, evitando instabilidades em loops de feedback."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.4.1.1.3",
                            "name": "Construir fatorizações biproprias",
                            "description": "Aplicar normalização bipropria para obter representações únicas de N e D, garantindo que sejam biproprias e estáveis em RH∞.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar conceitos fundamentais de fatorizações coprimas e biproprias",
                                  "subSteps": [
                                    "Defina fatorização coprima: P = N D^{-1} onde N, D ∈ RH∞ e existem U, V ∈ RH∞ tal que U N + V D = I.",
                                    "Explique bipropria: N e D satisfazem N(∞) N(∞)^* + D(∞) D(∞)^* = I (para SISO, normalização unitária no infinito).",
                                    "Identifique pré-requisitos: planta P estável ou instável, mas fatorizável em RH∞.",
                                    "Estude estabilidade em RH∞: funções holomórficas no semiplano direito.",
                                    "Revise Bezout identity para coprimidade."
                                  ],
                                  "verification": "Resuma definições em um parágrafo coerente e liste 3 exemplos de RH∞.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Livro de controle avançado (e.g., Zhou H∞ Control), MATLAB/Simulink para RH∞"
                                  ],
                                  "tips": "Use diagramas de Nyquist para visualizar estabilidade.",
                                  "learningObjective": "Compreender as propriedades matemáticas necessárias para bipropria.",
                                  "commonMistakes": [
                                    "Confundir coprima com coprimo polinomial",
                                    "Ignorar conjugação hermitiana na normalização"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Obter uma fatorização coprima inicial de P",
                                  "subSteps": [
                                    "Represente a planta P(s) como fração própria mínima.",
                                    "Coprime factorize usando estado-espacial: encontre realizações mínimas estáveis para N e D.",
                                    "Para SISO, use fatorização de McMillan ou algoritmo de pole-zero cancellation.",
                                    "Verifique coprimidade resolvendo para U, V via Sylvester equation.",
                                    "Ajuste para RH∞ usando spectral factorization se necessário."
                                  ],
                                  "verification": "Confirme U N + V D = I numericamente em MATLAB.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "MATLAB Control System Toolbox, notas de aula sobre state-space realizations"
                                  ],
                                  "tips": "Comece com sistemas de baixa ordem para testar.",
                                  "learningObjective": "Construir N e D coprimos em RH∞ a partir de P.",
                                  "commonMistakes": [
                                    "Manter polos instáveis em N ou D",
                                    "Esquecer minimalidade da realização"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Aplicar normalização bipropria",
                                  "subSteps": [
                                    "Calcule os valores limites em ∞: N(∞) e D(∞).",
                                    "Encontre fator de normalização all-pass Q(s) tal que N' = Q N, D' = Q D satisfaça normalização bipropria.",
                                    "Para SISO: resolva para Q com |Q(iω)|=1 e lim_{s→∞} |N'(s)|^2 + |D'(s)|^2 =1.",
                                    "Use Blaschke products para zeros em RH∞ se aplicável.",
                                    "Atualize Bezout: encontre novos U', V' para N', D'."
                                  ],
                                  "verification": "Verifique |N'(∞)|^2 + |D'(∞)|^2 =1 e estabilidade de Q.",
                                  "estimatedTime": "3 horas",
                                  "materials": [
                                    "Software como MuPAD ou Symbolic Toolbox, exemplos resolvidos de fatorizações"
                                  ],
                                  "tips": "Itere numericamente para aproximação de Q.",
                                  "learningObjective": "Transformar fatorização coprima em bipropria única.",
                                  "commonMistakes": [
                                    "Escolher Q não all-pass",
                                    "Violar estabilidade em RH∞"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Validar e estabilizar a fatorização bipropria",
                                  "subSteps": [
                                    "Teste estabilidade: poles de N' e D' em Re(s)<0.",
                                    "Verifique bipropria em s=0 e s=∞.",
                                    "Simule resposta em frequência: Bode plot de N' e D'.",
                                    "Confirme unicidade: compare com outra normalização.",
                                    "Documente a fatorização final."
                                  ],
                                  "verification": "Plots mostram margens estáveis e normalização unitária.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Simulink para simulação, LMI Toolbox para verificação robusta"
                                  ],
                                  "tips": "Use logspace para frequências amplas.",
                                  "learningObjective": "Garantir robustez e unicidade da representação bipropria.",
                                  "commonMistakes": [
                                    "Ignorar comportamento em baixa frequência",
                                    "Não testar em todo eixo imaginário"
                                  ]
                                }
                              ],
                              "practicalExample": "Para P(s) = 1/(s+1)(s-0.5), obtenha coprima N(s)=1/((s+1)(s+2)), D(s)=(s+1.5)/((s+1)(s+2)), então normalize com Q(s) = (s+0.5)/(s+0.5 + ε) ajustado para bipropria, resultando em N' e D' com |N'(iω)|^2 + |D'(iω)|^2 ≈1.",
                              "finalVerifications": [
                                "N e D ∈ RH∞ confirmados.",
                                "Bezout identity U N + V D = I holds.",
                                "|N(∞)|^2 + |D(∞)|^2 =1.",
                                "Coplimites em s=0 biproprios.",
                                "Bode plots mostram fase e ganho estáveis.",
                                "Simulação step response de controlador estabilizador."
                              ],
                              "assessmentCriteria": [
                                "Precisão na coprimidade (erro <1e-6).",
                                "Correta normalização bipropria (desvio <0.01).",
                                "Estabilidade verificada em todo espectro.",
                                "Documentação clara com equações e plots.",
                                "Tempo de execução eficiente em simulação.",
                                "Tratamento de casos edge (polos no imaginário)."
                              ],
                              "crossCurricularConnections": [
                                "Álgebra linear: Equações de Sylvester para Bezout.",
                                "Análise complexa: Funções holomórficas em RH∞.",
                                "Programação numérica: MATLAB para spectral factorization.",
                                "Otimização: LMIs para robustez H∞."
                              ],
                              "realWorldApplication": "Em design de controladores H∞ para aeronaves, onde fatorizações biproprias permitem parametrização Youla para tuning robusto contra incertezas, garantindo estabilidade em plantas com não-mínimo fase."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.4.1.2",
                        "name": "Fatores Estáveis e Instáveis",
                        "description": "Separação da planta em componentes estáveis (RH∞) e instáveis para análise de robustez e estabilização em controle avançado.",
                        "specificSkills": [
                          {
                            "id": "10.1.4.1.2.1",
                            "name": "Decompor planta em fatores estáveis e instáveis",
                            "description": "Representar P(s) = N_u M_u^{-1} = M_s^{-1} N_s, onde subscritos u e s denotam partes instáveis e estáveis, respectivamente, para parametrização.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Obter representação em fração coprima da planta P(s)",
                                  "subSteps": [
                                    "Identifique os numerador e denominador de P(s) em domínio de Laplace.",
                                    "Realize a fatorização em fatores lineares ou de Jordan para polos e zeros.",
                                    "Normalize para que os fatores sejam biproprios (det M(∞)=1).",
                                    "Encontre matrizes unimodulares U e V tais que N = U N_coprima e M = V M_coprima.",
                                    "Verifique coprimidade via identidade de Bezout: existam X, Y tais que X N + Y M = I."
                                  ],
                                  "verification": "Confirme que existe X, Y com X N + Y M = I usando resolução de Sylvester.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Software MATLAB ou Python (Control Systems Library), papel e calculadora.",
                                  "tips": "Comece com plantas de baixa ordem para praticar normalização.",
                                  "learningObjective": "Compreender a representação coprima biproria como base para decomposições.",
                                  "commonMistakes": "Esquecer de normalizar os fatores biproprios ou ignorar multiplicadores unimodulares."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Decompor em fatores instáveis (direita): P(s) = N_u M_u^{-1}",
                                  "subSteps": [
                                    "Separe os fatores de N(s) em estáveis (N_s) e instáveis (N_u), com N = N_s N_u.",
                                    "Separe os fatores de M(s) em estáveis (M_s) e instáveis (M_u), com M = M_s M_u.",
                                    "Ajuste para coprimidade: encontre unimodulares para que N_u e M_u sejam coprimos.",
                                    "Defina N_u como numerador instável ajustado e M_u como denominador instável.",
                                    "Escreva P(s) = N_u M_u^{-1} explicitamente."
                                  ],
                                  "verification": "Verifique se todos os polos/zeros instáveis estão em N_u e M_u, e M_u^{-1} cancela instabilidades adequadamente.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "MATLAB (funções coprime, minreal), exemplos numéricos impressos.",
                                  "tips": "Use diagrama de polos/zeros para visualizar separação.",
                                  "learningObjective": "Aprender a isolar componentes instáveis na representação direita.",
                                  "commonMistakes": "Colocar fatores estáveis em partes instáveis ou violar coprimidade."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Decompor em fatores estáveis (esquerda): P(s) = M_s^{-1} N_s",
                                  "subSteps": [
                                    "Reorganize separando fatores estáveis de N e M: N = N_u N_s, M = M_u M_s.",
                                    "Garanta que M_s e N_s contenham apenas fatores estáveis e sejam coprimos.",
                                    "Ajuste unimodulares para bipropriedade na representação esquerda.",
                                    "Escreva explicitamente P(s) = M_s^{-1} N_s.",
                                    "Confirme equivalência com a representação original."
                                  ],
                                  "verification": "Teste se M_s^{-1} N_s = P(s) numericamente em pontos de teste.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Software de simulação (Simulink ou Python), gráficos de Bode.",
                                  "tips": "Verifique estabilidade plotando polos de M_s e N_s.",
                                  "learningObjective": "Dominar a representação esquerda com fatores estáveis para parametrização.",
                                  "commonMistakes": "Confundir ordem de separação esquerda vs. direita."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificar e validar as decomposições",
                                  "subSteps": [
                                    "Confirme P(s) = N_u M_u^{-1} = M_s^{-1} N_s algebricamente.",
                                    "Verifique estabilidade: polos instáveis apenas em M_u e N_u; estáveis em M_s e N_s.",
                                    "Teste coprimidade das duplas (N_u, M_u) e (M_s, N_s).",
                                    "Avalie numericamente com simulação de resposta em malha aberta.",
                                    "Documente as matrizes para uso em parametrização Youla."
                                  ],
                                  "verification": "Simule e compare respostas de P(s) original vs. decomposições.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "MATLAB/Simulink para simulações, tabela de verificação.",
                                  "tips": "Use função 'poldiag' no MATLAB para decomposição em Jordan.",
                                  "learningObjective": "Garantir robustez das decomposições para design de controladores.",
                                  "commonMistakes": "Ignorar normalização infinita ou falhar em coprimidade."
                                }
                              ],
                              "practicalExample": "Para P(s) = (s+1)/((s-1)(s+2)) , polo instável em s=1. Decomposição direita: N_u = 1, M_u = s-1 (instável), N_s = s+1, M_s = s+2. Assim P = N_u M_u^{-1}. Esquerda: M_s^{-1} = 1/(s+2), N_s = (s+1)/(s-1) ajustado para estabilidade.",
                              "finalVerifications": [
                                "P(s) equivale exatamente às duas representações.",
                                "Fatores u contêm todas instabilidades; s apenas estabilidades.",
                                "Coprimidade confirmada por Bezout em ambas duplas.",
                                "Normalização biproria preservada (det=1 no infinito).",
                                "Simulação numérica coincide em resposta ao degrau.",
                                "Nenhuma cancelamento impróprio de instabilidades."
                              ],
                              "assessmentCriteria": [
                                "Precisão na separação de fatores estáveis/instáveis (100% correto).",
                                "Correta aplicação de unimodulares para coprimidade.",
                                "Verificação algébrica e numérica sem erros.",
                                "Tempo de execução dentro do estimado com qualidade.",
                                "Explicação clara das propriedades em relatório.",
                                "Uso adequado de ferramentas computacionais."
                              ],
                              "crossCurricularConnections": [
                                "Álgebra Linear: Identidade de Bezout e unimodulares.",
                                "Análise de Sistemas: Diagrama de polos/zeros e estabilidade.",
                                "Programação Numérica: Implementação em MATLAB/Python.",
                                "Matemática Aplicada: Fatorização de polinômios racionais."
                              ],
                              "realWorldApplication": "Essencial na parametrização Youla para sintetizar controladores estabilizantes robustos em plantas instáveis, como em drones (controle de atitude com polos instáveis) ou processos químicos com atrasos, permitindo todos os controladores estabilizantes via Q(s) estável."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.4.1.1.1"
                            ]
                          },
                          {
                            "id": "10.1.4.1.2.2",
                            "name": "Normalizar fatores para estabilidade",
                            "description": "Ajustar escalas e fases para que fatores estejam em RH∞, utilizando transformações biproprias e verificando pólos e zeros.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender conceitos fundamentais de RH∞ e transformações biproprias",
                                  "subSteps": [
                                    "Defina RH∞ como o conjunto de funções transferências holomorfas e limitadas no semiplano aberto direito (Re(s) > 0).",
                                    "Explique bipropriedade: funções com lim_{s→∞} G(s) finito e não-zero, graus de numerador e denominador iguais.",
                                    "Estude produtos Blaschke para RHP: para polo p real >0, b(s) = (s - p)/(s + p).",
                                    "Revise como transformações biproprias preservam estrutura de fatorização coprima.",
                                    "Discuta papel na parametrização de controladores estabilizadores."
                                  ],
                                  "verification": "Resuma em um parágrafo os conceitos e dê um exemplo simples de função em RH∞.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Livro de controle avançado (ex: Zhou, Doyle - Robust Control)",
                                    "Notas de aula sobre RH∞",
                                    "Calculadora simbólica (Mathematica ou SymPy)"
                                  ],
                                  "tips": "Lembre-se que RH∞ permite zeros no RHP, mas não pólos.",
                                  "learningObjective": "Dominar definições e propriedades essenciais para normalização.",
                                  "commonMistakes": [
                                    "Confundir RH∞ com RH2 ou H2.",
                                    "Ignorar a condição de boundedness (|G(s)| < γ para Re(s)>0).",
                                    "Esquecer que biproprio requer lim ∞ ≠ 0, ∞."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar o fator dado: localizar pólos, zeros e propriedades",
                                  "subSteps": [
                                    "Escreva a função de transferência do fator N(s) em forma racional.",
                                    "Calcule e plote pólos e zeros usando diagrama de pólo-zero.",
                                    "Determine lim_{s→∞} N(s) para verificar bipropriedade inicial.",
                                    "Identifique todos os pólos no RHP (Re(p) > 0) e zeros relevantes.",
                                    "Calcule a norma H∞ preliminar via plot de Bode."
                                  ],
                                  "verification": "Crie um diagrama de pólos-zeros rotulado corretamente e liste singularidades instáveis.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Software MATLAB (pzmap, bode) ou Python (control library)",
                                    "Papel gráfico",
                                    "Tabela de valores de s teste"
                                  ],
                                  "tips": "Use fatoração parcial para funções de alta ordem.",
                                  "learningObjective": "Identificar componentes instáveis com precisão.",
                                  "commonMistakes": [
                                    "Erro em raízes de polinômios (use fórmula quadrática corretamente).",
                                    "Confundir zeros com pólos.",
                                    "Esquecer multiplicidades ou pólos em infinito."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Aplicar transformações biproprias para estabilizar pólos",
                                  "subSteps": [
                                    "Para cada polo p_k no RHP (real), construa b_k(s) = (s - p_k)/(s + p_k). Para complexo, use conjugado.",
                                    "Multiplique N(s) por ∏ b_k(s), cancelando pólos instáveis e introduzindo pólos em -p_k.",
                                    "Ajuste constante de escala c = 1 / lim_{s→∞} [N(s) ∏ b_k(s)] para lim=1.",
                                    "Simplifique a expressão racional resultante.",
                                    "Confirme graus num/den iguais."
                                  ],
                                  "verification": "A nova N_norm(s) tem todos pólos com Re < 0.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "MATLAB Symbolic Toolbox ou SymPy para simplificação algébrica",
                                    "Folha de cálculos",
                                    "Exemplos resolvidos de fatorizações"
                                  ],
                                  "tips": "Para múltiplos pólos, aplique produto sequencial e verifique cancelamentos exatos.",
                                  "learningObjective": "Executar normalização bipropria corretamente.",
                                  "commonMistakes": [
                                    "Escolha errada do Blaschke (inverter num/den).",
                                    "Não escalar para gain unitário em ∞.",
                                    "Falhar em cancelamento devido a aproximações numéricas."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificar e finalizar a normalização",
                                  "subSteps": [
                                    "Re-plote pólos e zeros da N_norm(s).",
                                    "Gere plots de Bode e Nyquist para confirmar boundedness em jω.",
                                    "Verifique norma H∞ < ∞ e bipropriedade.",
                                    "Teste estabilidade fechada simulando com controlador unitário.",
                                    "Documente o processo com equações antes/depois."
                                  ],
                                  "verification": "Plots mostram ausência de pólos RHP e magnitude limitada.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "MATLAB (bode, nyquist, norm) ou Octave",
                                    "Simulador de sistemas lineares"
                                  ],
                                  "tips": "Use gridsearch em ω para max |G(jω)|.",
                                  "learningObjective": "Validar a estabilidade e propriedades da fatorização normalizada.",
                                  "commonMistakes": [
                                    "Aceitar aproximações sem verificação analítica.",
                                    "Ignorar picos em Bode indicando instabilidade residual.",
                                    "Esquecer ajuste de fase para all-pass."
                                  ]
                                }
                              ],
                              "practicalExample": "Dado N(s) = 3 (s + 1)/(s - 2), polo instável em s=2. Multiplicador b(s) = (s - 2)/(s + 2). Então N_norm(s) = 3 (s + 1)/(s - 2) * (s - 2)/(s + 2) = 3 (s + 1)/(s + 2). Ajuste escala: lim_{s→∞} = 3, então divida por 3: N_norm(s) = (s + 1)/(s + 2). Agora em RH∞, biproprio com lim=1, polo em -2.",
                              "finalVerifications": [
                                "Todos pólos de N_norm(s) têm Re(p) ≤ 0.",
                                "lim_{s→∞} N_norm(s) = 1 (ou constante desejada).",
                                "Plot de Bode mostra magnitude limitada em todo jω.",
                                "Nenhum zero ou polo cancelado inadequadamente.",
                                "Fatorização preserva o comportamento assintótico original.",
                                "Simulação passo confirma bounded response."
                              ],
                              "assessmentCriteria": [
                                "Correta identificação e localização de singularidades instáveis (20%).",
                                "Construção precisa dos multiplicadores biproprios (30%).",
                                "Cálculo e simplificação da N_norm(s) sem erros algébricos (20%).",
                                "Verificações completas com plots e normas (20%).",
                                "Explicação clara do processo e justificativas (10%)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Análise complexa e espaços de Hardy (RH∞).",
                                "Física: Dinâmica de sistemas lineares invariantes no tempo.",
                                "Computação: Algoritmos numéricos para análise de sistemas (MATLAB Control System Toolbox).",
                                "Engenharia Mecânica: Controle de plantas instáveis como inversores pendulares.",
                                "Economia: Modelagem robusta de sistemas econômicos com incertezas."
                              ],
                              "realWorldApplication": "Na estabilização de plantas instáveis como aviões (controle de voo) ou reatores químicos, onde fatores normalizados em RH∞ permitem síntese de controladores Q-parameter otimizados para robustez via LMI ou μ-síntese, garantindo performance apesar de perturbações."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.4.1.1.2"
                            ]
                          },
                          {
                            "id": "10.1.4.1.2.3",
                            "name": "Analisar estabilidade dos fatores",
                            "description": "Verificar localização de pólos e zeros nos fatores estáveis e instáveis usando diagramas de Bode ou Nyquist para sistemas monovariáveis.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Identificar e extrair fatores estáveis e instáveis da fatorização coprima",
                                  "subSteps": [
                                    "Obtenha a função de transferência do sistema monovariável G(s).",
                                    "Realize a fatorização coprima em fatores estáveis N_s(s), D_s(s) e instáveis N_u(s), D_u(s) usando decomposição em frações parciais ou métodos algébricos.",
                                    "Verifique que N_s e D_s têm todos os pólos e zeros no semiplano esquerdo (Re < 0).",
                                    "Confirme que N_u e D_u têm pólos ou zeros no semiplano direito (Re > 0) ou no eixo imaginário.",
                                    "Documente a separação com equações claras."
                                  ],
                                  "verification": "Todos os fatores estão explicitamente listados com suas expressões polinomiais e confirmados como estáveis/instáveis.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Função de transferência G(s), software MATLAB/Simulink ou Python (Control Systems Library), papel e calculadora.",
                                  "tips": "Use o comando 'tf2zp' no MATLAB para auxiliar na extração inicial de pólos/zeros.",
                                  "learningObjective": "Compreender a decomposição coprima e classificar fatores por estabilidade.",
                                  "commonMistakes": "Confundir fatores estáveis com instáveis ao ignorar o semiplano direito; não normalizar os fatores adequadamente."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Localizar pólos e zeros de cada fator no plano complexo",
                                  "subSteps": [
                                    "Calcule as raízes dos numeradores e denominadores de N_s, D_s, N_u, D_u.",
                                    "Plote os pólos (raízes do denominador) e zeros (raízes do numerador) no plano s.",
                                    "Classifique cada polo/zero: estável (Re < 0), instável (Re > 0) ou marginal (Re = 0).",
                                    "Anote as localizações exatas (ex: -2 + 3j).",
                                    "Valide cálculos com ferramentas numéricas."
                                  ],
                                  "verification": "Diagrama de pólos e zeros plotado corretamente para todos os fatores, com classificações anotadas.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "MATLAB (pzmap), Python (matplotlib e control), papel quadriculado.",
                                  "tips": "Sempre verifique multiplicidades de pólos/zeros para fatores repetidos.",
                                  "learningObjective": "Mapear localizações de pólos/zeros e relacioná-las à estabilidade inerente.",
                                  "commonMistakes": "Erro em cálculos de raízes complexas; plotar zeros como pólos."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Construir e analisar diagramas de Bode para os fatores",
                                  "subSteps": [
                                    "Gere os diagramas de magnitude e fase para N_s, D_s, N_u, D_u usando frequências de 10^-2 a 10^2 rad/s.",
                                    "Identifique cortes de frequência, inclinações assintóticas e picos indicativos de instabilidade.",
                                    "Analise a fase em baixas e altas frequências para confirmar estabilidade (fase entre -90° e 90° para estáveis).",
                                    "Marque regiões onde a magnitude cruza 0 dB com fase crítica.",
                                    "Compare com critérios de estabilidade (ganho e fase)."
                                  ],
                                  "verification": "Diagramas de Bode gerados e anotados com análises de estabilidade para cada fator.",
                                  "estimatedTime": "40 minutos",
                                  "materials": "MATLAB (bode), Python (bode_plot), osciloscópio virtual se disponível.",
                                  "tips": "Use escalas logarítmicas para melhor visualização de comportamentos assintóticos.",
                                  "learningObjective": "Interpretar diagramas de Bode para diagnosticar estabilidade de fatores.",
                                  "commonMistakes": "Ignorar a fase em altas frequências; confundir magnitude com estabilidade absoluta."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Construir e analisar diagramas de Nyquist para verificação final de estabilidade",
                                  "subSteps": [
                                    "Gere curvas de Nyquist para os fatores instáveis N_u e D_u.",
                                    "Verifique se a curva encerccla o ponto crítico (-1,0) no sentido horário (instável).",
                                    "Conte o número de encirclements (N = P - Z, onde P são pólos abertos instáveis).",
                                    "Confirme estabilidade: nenhum encirclement para fatores estáveis.",
                                    "Sintetize resultados em um relatório de estabilidade geral."
                                  ],
                                  "verification": "Curvas de Nyquist plotadas com contagem de encirclements e conclusão de estabilidade.",
                                  "estimatedTime": "35 minutos",
                                  "materials": "MATLAB (nyquist), Python (nyquist_plot), software de controle avançado.",
                                  "tips": "Amplie o contorno para incluir pólos no eixo imaginário se necessário.",
                                  "learningObjective": "Aplicar critério de Nyquist para validar estabilidade via localização de pólos/zeros.",
                                  "commonMistakes": "Contagem errada de encirclements; não considerar indentação em pólos imaginários."
                                }
                              ],
                              "practicalExample": "Para G(s) = 1 / (s^2 - s + 1), fatorize em N_s(s) = 1/(s+0.5), D_s(s)=1, N_u(s)=(s-0.5), D_u(s)=1. Plote pólos/zeros: polo estável em -0.5, zero instável em 0.5. Bode mostra fase ok para N_s, Nyquist sem encirclement para estável.",
                              "finalVerifications": [
                                "Todos pólos/zeros localizados corretamente no plano s.",
                                "Diagramas de Bode mostram margens de ganho/fase adequadas para fatores estáveis.",
                                "Nyquist confirma ausência de encirclements para fatores estáveis.",
                                "Relatório resume estabilidade de cada fator (estável/instável).",
                                "Validação numérica com simulação de resposta ao degrau sem oscilações divergentes.",
                                "Comparação com software padrão (ex: MATLAB) bate 100%."
                              ],
                              "assessmentCriteria": [
                                "Precisão na fatorização coprima (sem erros algébricos).",
                                "Correta classificação de estabilidade baseada em Re(polo/zero).",
                                "Interpretação precisa de diagramas Bode/Nyquist.",
                                "Relatório claro com plots e conclusões.",
                                "Tempo de execução dentro do estimado com qualidade.",
                                "Identificação de pelo menos 2 erros comuns evitados."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Análise de funções complexas e raízes polinomiais.",
                                "Programação: Uso de bibliotecas de controle (MATLAB/Python) para automação.",
                                "Física: Dinâmica de sistemas e estabilidade oscilatória.",
                                "Estatística: Análise de margens de estabilidade probabilística."
                              ],
                              "realWorldApplication": "Em automação industrial, analisar estabilidade de fatores em controladores PID para plantas químicas, evitando oscilações em reatores que poderiam causar falhas de segurança ou perda de produção."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.4.1.3",
                        "name": "Aplicação na Parametrização de Controladores",
                        "description": "Uso das fatorizações coprimas para gerar todos os controladores estabilizadores via parâmetro Q estável.",
                        "specificSkills": [
                          {
                            "id": "10.1.4.1.3.1",
                            "name": "Parametrizar controladores estabilizadores",
                            "description": "Expressar C(s) = (X + D Q)(Y - N Q)^{-1} para Q ∈ RH∞, garantindo estabilização da planta P(s).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Realizar Fatorização Coprima da Planta P(s)",
                                  "subSteps": [
                                    "Identifique a planta P(s) e represente-a como fração própria N(s)/D(s) em anéis de frações estáveis (RH∞).",
                                    "Verifique coprimidade à direita: encontre U(s), V(s) estáveis tais que U N + V D = 1 (identidade de Bézout).",
                                    "Normalize as fatorizações para garantir que sejam biproprias se necessário.",
                                    "Confirme estabilidade de N e D no domínio apropriado.",
                                    "Documente as matrizes ou funções N(s) e D(s)."
                                  ],
                                  "verification": "Verifique se U N + V D = 1 calculando o produto e confirmando unidade.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Software de controle como MATLAB/Simulink, papel e lápis para cálculos simbólicos, tabela de identidades de Bézout.",
                                  "tips": "Comece com plantas simples para praticar; use ferramentas simbólicas como MuPAD no MATLAB.",
                                  "learningObjective": "Compreender e aplicar fatorizações coprimas biproprias para plantas lineares.",
                                  "commonMistakes": "Esquecer de verificar coprimidade, levando a soluções não generalizáveis; confundir coprimidade à esquerda/direita."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Encontrar Estabilizadores X(s) e Y(s)",
                                  "subSteps": [
                                    "Resolva a equação de Bézout: encontre X(s) e Y(s) em RH∞ tais que X(s) N(s) - Y(s) D(s) = I (identidade).",
                                    "Use métodos iterativos ou decomposição de Sylvester se multivariável.",
                                    "Valide a solução multiplicando e confirmando igualdade à identidade.",
                                    "Ajuste para garantir que X e Y sejam próprios e estáveis.",
                                    "Salve X(s) e Y(s) como base para parametrização."
                                  ],
                                  "verification": "Multiplique X N - Y D e confirme resultado identidade; pole MATLAB para estabilidade.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "MATLAB Control System Toolbox, equações simbólicas, referências como Doyle ou Zhou.",
                                  "tips": "Particularize soluções iniciais de controladores conhecidos para acelerar.",
                                  "learningObjective": "Resolver equações diofantinas para obter estabilizadores bezoutianos.",
                                  "commonMistakes": "Ignorar condições de propriedadade, resultando em controladores impraticáveis; erros aritméticos em frações racionais."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Selecionar Parâmetro Q(s) em RH∞",
                                  "subSteps": [
                                    "Escolha Q(s) estável e próprio (ex: Q=0 para controlador nominal).",
                                    "Garante que Y - N Q seja invertível em RH∞ (verifique det(Y - N Q) ≠ 0 nos polos).",
                                    "Considere Q para otimizar desempenho (ex: minimizar H∞ norm).",
                                    "Teste múltiplos Q para diferentes trade-offs estabilidade/desempenho.",
                                    "Documente escolha de Q e razões."
                                  ],
                                  "verification": "Confirme polos de Y - N Q no semiplano esquerdo; use nyquist ou bode para análise.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Ferramentas de síntese H∞ como hinfsyn no MATLAB.",
                                  "tips": "Inicie com Q baixo ordem; evite cancelamentos frágeis.",
                                  "learningObjective": "Selecionar parâmetros livres que preservam estabilidade fechada.",
                                  "commonMistakes": "Escolher Q que torna denominador singular; sobreestimar complexidade de Q desnecessariamente."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Construir Controlador C(s) = (X + D Q)(Y - N Q)^{-1}",
                                  "subSteps": [
                                    "Calcule numerador: X(s) + D(s) Q(s).",
                                    "Calcule denominador: Y(s) - N(s) Q(s) e inverta-o.",
                                    "Forme C(s) como fração e simplifique cancelamentos comuns.",
                                    "Verifique propriedadade de C(s) (lim s→∞ C(s) finito).",
                                    "Implemente em simulador para laço fechado."
                                  ],
                                  "verification": "Simule T(s) = P C (I + P C)^{-1} e confirme ausência de polos instáveis.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Simulink para diagrama de laço fechado, funções tf/ss no MATLAB.",
                                  "tips": "Use feedback() no MATLAB para automação.",
                                  "learningObjective": "Aplicar fórmula de parametrização Youla-Kucera para gerar família de controladores.",
                                  "commonMistakes": "Erros na inversão (não em RH∞); esquecer simplificação de pólos/zeros comuns."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Verificar Estabilização da Planta P(s)",
                                  "subSteps": [
                                    "Analise função de transferência fechada para estabilidade (Routh-Hurwitz ou Nyquist).",
                                    "Teste robustez variando parâmetros de P(s).",
                                    "Simule resposta a entradas (step, ramp) e distúrbios.",
                                    "Compare com controlador nominal (Q=0).",
                                    "Registre métricas: tempo de assentamento, overshoot."
                                  ],
                                  "verification": "Todos polos em semiplano esquerdo; margem de ganho/fase >6dB/45°.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Stepinfo(), margin() no MATLAB, osciloscópio virtual.",
                                  "tips": "Use loop analysis para margens.",
                                  "learningObjective": "Validar que todo C parametrizado estabiliza P para Q estável.",
                                  "commonMistakes": "Confundir estabilidade interna/externa; ignorar distúrbios."
                                }
                              ],
                              "practicalExample": "Para P(s) = 1/(s-1) (integrador instável), fatorize N=1/(s+1), D=(s-1)/(s+1) coprima. Encontre X=(s+2)/(s+1), Y=1/(s+1). Escolha Q=0.1/(s+0.1), então C(s) = [X + D Q] [Y - N Q]^{-1}. Simule laço fechado estável com step response assentando em 2s.",
                              "finalVerifications": [
                                "Fatorizações N/D biproprias com Bézout verificado.",
                                "X, Y estáveis resolvendo equação diofantina.",
                                "Y - N Q invertível em RH∞.",
                                "C(s) próprio e estável em laço aberto.",
                                "Sistema fechado P/(1+P C) com todos polos estáveis.",
                                "Margens de estabilidade adequadas (>6dB ganho, >45° fase)."
                              ],
                              "assessmentCriteria": [
                                "Precisão na fatorização coprima (100% match Bézout).",
                                "Corretude da fórmula C(s) sem erros algébricos.",
                                "Escolha adequada de Q preservando invertibilidade.",
                                "Simulações mostram estabilidade e bom desempenho.",
                                "Documentação completa com justificativas.",
                                "Análise de robustez para variações em P(s)."
                              ],
                              "crossCurricularConnections": [
                                "Álgebra Linear: Decomposição de Sylvester para equações diofantinas.",
                                "Otimização: Síntese H∞ para escolha ótima de Q.",
                                "Processos Industriais: Aplicação em PLCs e SCADA.",
                                "Matemática Avançada: Teoria de anéis euclidianos em RH∞."
                              ],
                              "realWorldApplication": "Em automação industrial, parametrizar controladores para estabilizar reatores químicos instáveis, ajustando Q para trade-offs entre velocidade de resposta e robustez a variações de temperatura, usado em plantas Petrobras ou refinarias."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.4.1.1.1",
                              "10.1.4.1.2.1"
                            ]
                          },
                          {
                            "id": "10.1.4.1.3.2",
                            "name": "Implementar em MATLAB",
                            "description": "Usar funções do Robust Control Toolbox para computar fatorizações coprimas e gerar banco de controladores estabilizadores.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar o ambiente MATLAB e definir o modelo da planta",
                                  "subSteps": [
                                    "Verificar se o Robust Control Toolbox está instalado executando 'vertoolbx robustctrl'.",
                                    "Definir o modelo da planta G(s) como um sistema de transferência usando tf(num, den).",
                                    "Criar um script MATLAB novo e adicionar comentários explicativos sobre o sistema.",
                                    "Testar a simulação básica da planta com step(G) para validar o modelo.",
                                    "Salvar o script com nome descritivo como 'fatorizacoes_coprimas_planta.m'."
                                  ],
                                  "verification": "O plot de resposta ao degrau da planta é exibido corretamente sem erros.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "MATLAB R2020a ou superior",
                                    "Robust Control Toolbox",
                                    "Script editor do MATLAB"
                                  ],
                                  "tips": "Use variáveis simbólicas para num e den para facilitar mudanças no modelo.",
                                  "learningObjective": "Configurar corretamente o ambiente e modelar sistemas lineares em MATLAB.",
                                  "commonMistakes": "Esquecer de instalar o toolbox ou usar sintaxe errada em tf, causando erros de dimensão."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Computar as fatorizações coprimas da planta",
                                  "subSteps": [
                                    "Executar a função coprime(G) para obter [N, M, X, Y] onde N e M são fatores coprimos.",
                                    "Verificar as propriedades das fatorizações com norm(N*M - eye(size(G))) < tol.",
                                    "Plotar os polos e zeros de N e M usando pzmap para análise visual.",
                                    "Armazenar as matrizes Bezout X e Y e exibir suas dimensões.",
                                    "Adicionar validação de estabilidade com isstable(N) e isstable(M)."
                                  ],
                                  "verification": "As normas de validação são menores que 1e-10 e gráficos de polos/zeros são exibidos.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Script MATLAB anterior",
                                    "Documentação do coprime no help"
                                  ],
                                  "tips": "Use uma tolerância pequena (tol=1e-10) para verificações numéricas em sistemas reais.",
                                  "learningObjective": "Aplicar a função coprime para fatorizar plantas em fatores estáveis coprimos.",
                                  "commonMistakes": "Não especificar opções de tolerância, levando a fatorizações imprecisas em sistemas mal condicionados."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar a parametrização de Youla-Kucera para controladores",
                                  "subSteps": [
                                    "Definir um parâmetro Q estável, como Q = 0.5 * tf(1, [1 0.5 1]), usando tf.",
                                    "Computar o controlador C = (X + M*Q) / (Y - N*Q) com feedback ou lft.",
                                    "Verificar estabilidade interna do laço fechado com feedback(G*C,1).",
                                    "Simular respostas ao degrau do sistema fechado e plotar com step.",
                                    "Salvar a função C em workspace para uso posterior."
                                  ],
                                  "verification": "O sistema em laço fechado é estável (todos polos no semiplano esquerdo) e step response converge.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Scripts anteriores",
                                    "Funções feedback e step do Control System Toolbox"
                                  ],
                                  "tips": "Garanta que Q tenha grau relativo adequado para evitar cancelamentos instáveis.",
                                  "learningObjective": "Construir controladores estabilizadores via parametrização usando fatores coprimos.",
                                  "commonMistakes": "Inverter a fórmula de C ou esquecer de estabilizar Q, causando controladores instáveis."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Gerar e analisar um banco de controladores estabilizadores",
                                  "subSteps": [
                                    "Criar um loop for variando parâmetros de Q (ex: k de 0.1 a 1.0 em passos de 0.1).",
                                    "Para cada Q, computar C_k, simular laço fechado e coletar métricas (tempo de estabilização, overshoot).",
                                    "Plotar conjunto de respostas step para todos C_k usando hold on.",
                                    "Exportar tabela de métricas em array ou table para análise.",
                                    "Analisar trade-offs e selecionar o melhor C baseado em critérios como menor overshoot."
                                  ],
                                  "verification": "Banco de pelo menos 10 controladores gerados, todos estáveis, com gráficos comparativos.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Scripts completos",
                                    "Funções loop for e table"
                                  ],
                                  "tips": "Vetorize computações quando possível para eficiência em bancos grandes.",
                                  "learningObjective": "Gerar famílias de controladores e avaliar desempenho paramétrico.",
                                  "commonMistakes": "Passos muito grandes em k causando Q não estável ou loops infinitos por falta de break."
                                }
                              ],
                              "practicalExample": "Para uma planta G(s) = 1/(s^2 + 0.2s + 1), compute coprimes, defina Q(s) = k/(s+1)^2 com k=0.1:1, gere 10 controladores C_k, simule steps e compare overshoots menores que 10%.",
                              "finalVerifications": [
                                "Script completo executa sem erros numéricos ou warnings.",
                                "Todos controladores no banco estabilizam a planta (isstable(feedback(G*C,1)) == true).",
                                "Fatorizações coprimas satisfazem N*M + X*G*Y ≈ I (norma < 1e-8).",
                                "Gráficos de step responses mostram variedade de desempenhos.",
                                "Tabela de métricas exportada com stepinfo para cada C.",
                                "Código comentado e modular para reutilização."
                              ],
                              "assessmentCriteria": [
                                "Precisão numérica das fatorizações e parametrização (erros < 1e-6).",
                                "Correção da estabilidade de todos controladores gerados.",
                                "Eficiência e legibilidade do código MATLAB (uso de vetores/loops otimizados).",
                                "Análise qualitativa dos trade-offs no banco (ex: robustez vs. velocidade).",
                                "Validações implementadas e documentadas no script.",
                                "Capacidade de generalizar para outra planta G."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria de sistemas lineares e álgebra de frações coprimas.",
                                "Programação: Scripting avançado em MATLAB com loops e visualizações.",
                                "Física: Modelagem dinâmica de sistemas mecânicos/elétricos.",
                                "Engenharia de Software: Modularidade e documentação de código.",
                                "Estatística: Análise paramétrica e métricas de desempenho."
                              ],
                              "realWorldApplication": "Design de controladores robustos em indústrias aeroespacial e automotiva, como estabilização de drones ou veículos autônomos sob incertezas paramétricas, permitindo bancos de controladores para tuning adaptativo."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.4.1.1.3",
                              "10.1.4.1.2.2"
                            ]
                          },
                          {
                            "id": "10.1.4.1.3.3",
                            "name": "Avaliar robustez via parametrização",
                            "description": "Analisar o conjunto de plantas estabilizadas e margens de robustez usando o gráfico de Youla-Kucera.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Fatorizações Coprimas e Parametrização Básica de Controladores",
                                  "subSteps": [
                                    "Realize a fatorização coprima dupla de Bezout da planta nominal P(s) em N_p(s)M_p^{-1}(s) = M_p^{-1}(s)N_p(s).",
                                    "Construa as fatorizações coprimas do controlador estabilizador C(s) como N_c(s)M_c^{-1}(s).",
                                    "Verifique a equação de Bezout: M_p M_c - N_p N_c = X para algum X unimodular.",
                                    "Introduza o parâmetro Q(s) estável com norma ||Q||_∞ < 1/γ para robustez inicial.",
                                    "Expresse todos os controladores estabilizantes como C_q(s) = (Y - M_p Q)(X + N_p Q)^{-1}."
                                  ],
                                  "verification": "Confirme que as fatorizações satisfazem a equação de Bezout e que Q(s) é estável com ||Q||_∞ calculado corretamente.",
                                  "estimatedTime": "1.5 hours",
                                  "materials": [
                                    "Livro de controle avançado (ex: Zhou, Doyle, Glover)",
                                    "Software MATLAB/Simulink para fatorizações",
                                    "Plantas nominais de exemplo (ex: P(s) = 1/(s^2 + s + 1))"
                                  ],
                                  "tips": "Use o comando coprime em toolboxes de controle do MATLAB para automatizar fatorizações.",
                                  "learningObjective": "Dominar as bases matemáticas para parametrização de controladores estabilizantes.",
                                  "commonMistakes": [
                                    "Escolher fatorizações não coprimas levando a soluções incompletas.",
                                    "Ignorar a estabilidade de Q(s), causando controladores instáveis."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Construir o Gráfico de Youla-Kucera",
                                  "subSteps": [
                                    "Desenhe o plano Q-H_∞ com Q estável e ||Q||_∞ < γ.",
                                    "Mapeie o conjunto de plantas estabilizadas como P_q(s) = (N_p + M_p Q)(X + N_p Q)^{-1}.",
                                    "Identifique as fronteiras do conjunto de plantas usando variações de Q na borda do disco unitário.",
                                    "Plote o gráfico no plano de Nyquist ou disco de estabilidade para visualização.",
                                    "Calcule o mapeamento para perturbações multiplicativas ou aditivas."
                                  ],
                                  "verification": "Gere o gráfico e confirme que plantas no conjunto são estabilizadas pelo controlador nominal.",
                                  "estimatedTime": "2 hours",
                                  "materials": [
                                    "MATLAB com toolbox Robust Control",
                                    "Papel milimetrado para esboços manuais",
                                    "Tutoriais sobre Youla parametrization"
                                  ],
                                  "tips": "Normalizar plantas para facilitar cálculos de norma H_∞.",
                                  "learningObjective": "Visualizar e parametrizar o conjunto completo de plantas estabilizáveis.",
                                  "commonMistakes": [
                                    "Confundir parametrização de controladores com plantas.",
                                    "Não escalar adequadamente Q levando a gráficos distorcidos."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar o Conjunto de Plantas Estabilizadas",
                                  "subSteps": [
                                    "Varra Q na borda do disco ||Q||_∞ = γ e compute P_q(s) para múltiplos pontos.",
                                    "Avalie a distância do conjunto à instabilidade usando o raio do disco mapeado.",
                                    "Calcule a margem de robustez multiplicativa como inf |1 + Δ_m(jω) L(jω)| onde L é o loop aberto.",
                                    "Use o teorema máximo de H_∞ para determinar o conjunto máximo estabilizado.",
                                    "Simule respostas em malha fechada para plantas extremas do conjunto."
                                  ],
                                  "verification": "Simulações mostram estabilidade para todas plantas no conjunto gerado.",
                                  "estimatedTime": "2.5 hours",
                                  "materials": [
                                    "Simulink para simulações dinâmicas",
                                    "Scripts MATLAB para varredura de Q",
                                    "Dados de plantas perturbadas"
                                  ],
                                  "tips": "Use grid de pontos finos na borda de Q para precisão no conjunto.",
                                  "learningObjective": "Quantificar o tamanho e forma do conjunto de plantas estabilizadas.",
                                  "commonMistakes": [
                                    "Usar Q não estável, invalidando o conjunto.",
                                    "Ignorar frequência, focando só em ganho DC."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Avaliar Margens de Robustez e Interpretar Resultados",
                                  "subSteps": [
                                    "Compute γ_rob = 1 / ||T||_∞ onde T é a função de transferência de complemento de sensibilidade.",
                                    "Compare margens com critérios clássicos (ganho/fase) para validação.",
                                    "Analise sensibilidade a perturbações não modeladas via diâmetro do conjunto.",
                                    "Gere relatório com gráficos de margens vs. frequência.",
                                    "Otimize Q para maximizar margens se necessário."
                                  ],
                                  "verification": "Relatório final mostra γ_rob > 1 e estabilidade robusta confirmada por simulações.",
                                  "estimatedTime": "1.5 hours",
                                  "materials": [
                                    "Relatórios em LaTeX ou Word",
                                    "Gráficos gerados no MATLAB",
                                    "Benchmarks de robustez padrão"
                                  ],
                                  "tips": "Sempre cheque com simulações de Monte Carlo para perturbações reais.",
                                  "learningObjective": "Interpretar margens de robustez quantitativamente via parametrização.",
                                  "commonMistakes": [
                                    "Confundir margem de estabilidade com robustez a incertezas.",
                                    "Sobreestimar robustez sem validação simulada."
                                  ]
                                }
                              ],
                              "practicalExample": "Para a planta nominal P(s) = 1/(s^2 + 0.2s + 1), com controlador C(s) estabilizador obtido via LQR. Varie Q(s) = k/(s+1)^2 com ||Q||_∞ < 0.5. Plote o conjunto de plantas estabilizadas no plano Nyquist e confirme que perturbações de 40% em ganho mantêm estabilidade.",
                              "finalVerifications": [
                                "Gráfico de Youla-Kucera corretamente desenhado com conjunto de plantas fechado.",
                                "Margens de robustez γ_rob calculadas e >1 para o exemplo.",
                                "Simulações de malha fechada estáveis para plantas extremas.",
                                "Relatório interpreta corretamente o impacto de Q nas margens.",
                                "Comparação com métodos clássicos (ex: Bode) consistente.",
                                "Otimização de Q aumenta margens em pelo menos 10%."
                              ],
                              "assessmentCriteria": [
                                "Precisão matemática nas fatorizações e mapeamentos (90%+ correção).",
                                "Completude do gráfico e análise do conjunto (todos elementos presentes).",
                                "Qualidade das simulações e visualizações (claras e legíveis).",
                                "Interpretação correta de robustez vs. estabilidade nominal.",
                                "Criatividade na otimização de Q para cenários reais.",
                                "Documentação detalhada com fórmulas e justificativas."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria de funções analíticas e normas H_∞.",
                                "Programação: Implementação em MATLAB para automação de gráficos.",
                                "Física: Modelagem dinâmica de sistemas reais (ex: motores).",
                                "Estatística: Análise de Monte Carlo para incertezas.",
                                "Design de Sistemas: Integração com otimização multiobjetivo."
                              ],
                              "realWorldApplication": "Em controle de aviões não tripulados (drones), avalia robustez a variações de massa/payload usando parametrização para garantir estabilidade sob ventos variáveis, evitando crashes em missões autônomas."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.4.1.3.1"
                            ]
                          },
                          {
                            "id": "10.1.4.1.3.4",
                            "name": "Projetar Q para desempenho",
                            "description": "Escolher Q(s) estável para otimizar desempenho, como minimizar sensibilidade ||S||∞ ou ||T||∞ na forma padrão.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Fundamentos da Parametrização com Fatorizações Coprimas",
                                  "subSteps": [
                                    "Relembrar as fatorizações coprimas N, M para a planta P = N M^{-1}.",
                                    "Derivar as expressões da forma padrão: S = (I + Q P)^{-1}, T = Q P S.",
                                    "Entender o papel de Q na estabilidade e desempenho: Q estável implica controlador C = Q (I - P Q)^{-1} estável.",
                                    "Calcular ||S||∞ e ||T||∞ para um Q simples usando ferramentas numéricas.",
                                    "Identificar trade-offs: pequeno ||S||∞ para rejeição de distúrbios, pequeno ||T||∞ para ruído."
                                  ],
                                  "verification": "Derivação correta de S e T em termos de Q; plotar respostas em frequência mostrando impacto de Q.",
                                  "estimatedTime": "2 horas",
                                  "materials": "Livro de controle avançado (e.g., Zhou's Robust Control); MATLAB/Simulink com toolbox Control System.",
                                  "tips": "Use blocos de diagrama de Youla para visualizar Q na forma padrão.",
                                  "learningObjective": "Compreender matematicamente como Q afeta sensibilidade e complementaridade.",
                                  "commonMistakes": "Confundir S com T; esquecer que Q deve ser estável para todos os controladores estáveis."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Definir Objetivos de Desempenho Quantitativos",
                                  "subSteps": [
                                    "Especificar γ_S e γ_T como limites superiores para ||S||∞ e ||T||∞ baseados em requisitos (e.g., γ_S < 0.1 para rejeição rápida).",
                                    "Analisar a planta P em frequência para identificar bandas críticas (baixa freq para S, alta para T).",
                                    "Estabelecer restrições adicionais: ganho de Q em DC ≈1 para tracking, roll-off suave.",
                                    "Criar template de frequência desejada para S e T usando Bode plots.",
                                    "Verificar compatibilidade: ||S||∞ + ||T||∞ ≥1 pela desigualdade de normas."
                                  ],
                                  "verification": "Documentar specs com plots de magnitude desejada para S e T.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": "MATLAB (bode, norm funções); exemplos de plantas como massa-mola ou motor DC.",
                                  "tips": "Comece com specs conservadoras para evitar infeasibilidade.",
                                  "learningObjective": "Traduzir requisitos de desempenho em normas H∞ mensuráveis.",
                                  "commonMistakes": "Ignorar trade-offs entre S e T; specs muito ambiciosas sem análise de P."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Estruturar e Projetar Q Inicial Estável",
                                  "subSteps": [
                                    "Escolher ordem de Q (e.g., 2-4 para plantas de ordem 2); preferir FIR para simplicidade ou IIR para eficiência.",
                                    "Inicializar coeficientes: Q(s) = k / (τ s +1)^n com k≈1, τ ajustado para roll-off.",
                                    "Garantir estabilidade: todos polos no semiplano esquerdo; usar rlocfind ou sisotool.",
                                    "Sintetizar Q para aproximar template: minimizar erro em pontos de frequência chave.",
                                    "Testar estabilidade fechada: margens de ganho/fase >6dB/45°."
                                  ],
                                  "verification": "Q Hurwitz (polos reais negativos); simulação step/distúrbio sem instabilidade.",
                                  "estimatedTime": "3 horas",
                                  "materials": "MATLAB Control System Toolbox (tf, feedback, rlocus); Simulink para modelagem.",
                                  "tips": "Use Q low-pass para reduzir ||T||∞ em altas frequências.",
                                  "learningObjective": "Construir Q estável que satisfaça specs iniciais de desempenho.",
                                  "commonMistakes": "Q instável levando a C instável; ordem muito alta causando overfitting."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Otimizar Q para Minimizar Normas de Desempenho",
                                  "subSteps": [
                                    "Formular problema: min ||S||∞ ou ||T||∞ sujeito a Q estável e ||Q||∞ < γ_Q.",
                                    "Usar otimização numérica: hinfsyn ou loopshaping para refinar Q.",
                                    "Iterar: ajustar parâmetros e recomputar normas até specs atendidas.",
                                    "Analisar robustez: variar parâmetros de P e checar variação em ||S||∞/||T||∞.",
                                    "Exportar controlador C final e linearizar para verificação."
                                  ],
                                  "verification": "||S||∞ < γ_S e ||T||∞ < γ_T confirmados via hinfnorm.",
                                  "estimatedTime": "4 horas",
                                  "materials": "MATLAB Robust Control Toolbox (hinfsyn, musyn); otimização fmincon.",
                                  "tips": "Monitore cond number de M para evitar il-condicionamento.",
                                  "learningObjective": "Aplicar ferramentas de otimização H∞ para refinar Q.",
                                  "commonMistakes": "Otimização local sem bom inicial; ignorar constraints de estabilidade."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Validar e Refinar o Design de Q",
                                  "subSteps": [
                                    "Simular respostas transitórias: step, ramp, distúrbio para S e T.",
                                    "Checar em tempo real ou hardware-in-loop se possível.",
                                    "Sensibilidade a incertezas: Monte Carlo com variações em P.",
                                    "Documentar trade-offs e justificar escolhas de Q.",
                                    "Preparar relatório com plots de Bode, step responses e normas."
                                  ],
                                  "verification": "Todas simulações atendem specs; relatório completo.",
                                  "estimatedTime": "2 horas",
                                  "materials": "Simulink; hardware opcional (e.g., dSPACE).",
                                  "tips": "Use nichols plot para margens robustas.",
                                  "learningObjective": "Validar integralmente o design de Q no contexto real.",
                                  "commonMistakes": "Validação só em nominal; subestimar não-linearidades."
                                }
                              ],
                              "practicalExample": "Para um motor DC de posição (P(s) = 1/(s(s+1))), defina γ_S=0.2, γ_T=0.5. Projete Q(s) = 2.5 / (0.5s+1)^2, otimize para ||S||∞=0.18 via hinfsyn, resultando em tracking sem overshoot >5% e rejeição de distúrbio em <0.5s.",
                              "finalVerifications": [
                                "Q é estável (todos polos Re<0).",
                                "||S||∞ ≤ γ_S especificado.",
                                "||T||∞ ≤ γ_T especificado.",
                                "Controlador C = Q(I-PQ)^{-1} estável com margens adequadas.",
                                "Simulações transitórias atendem requisitos de tempo/overshoot.",
                                "Design robusto a ±20% variação em P."
                              ],
                              "assessmentCriteria": [
                                "Precisão na minimização de ||S||∞/||T||∞ (erro <10%).",
                                "Estabilidade comprovada de Q e laço fechado.",
                                "Eficiência computacional (ordem Q razoável).",
                                "Documentação clara com derivações e plots.",
                                "Capacidade de generalizar para novas plantas.",
                                "Integração de trade-offs em specs realistas."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria de normas H∞ e otimização convexa.",
                                "Programação: Implementação em MATLAB para análise em frequência.",
                                "Física: Modelagem dinâmica de sistemas mecatrônicos.",
                                "Engenharia de Software: Validação e testes unitários em Simulink."
                              ],
                              "realWorldApplication": "Em automação industrial, projetar Q otimiza controladores para robôs manipuladores, minimizando sensibilidade a cargas variáveis (S) e ruído de sensores (T), garantindo precisão submilimétrica em linhas de montagem."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.4.1.3.1"
                            ]
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.4.2",
                    "name": "Identidade de Bezout",
                    "description": "Condição algébrica que garante a existência de controladores estabilizadores.",
                    "individualConcepts": [
                      {
                        "id": "76.1.1",
                        "name": "Fração Bipropria e Coprimidade",
                        "description": "Representação da função de transferência da planta P(s) como fração bipropria coprima P(s) = N(s) M^{-1}(s), onde N(s) e M(s) pertencem ao anel de funções harmônicas estáveis RH∞, e são coprimos pela direita.",
                        "specificSkills": [
                          {
                            "id": "76.1.1.1",
                            "name": "Identificar frações biproprias",
                            "description": "Determinar se uma fração racional própria é bipropria, verificando que o grau do numerador é menor ou igual ao do denominador, e que ambos são próprios assintoticamente.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar definições de frações racionais próprias e biproprias",
                                  "subSteps": [
                                    "Defina uma fração racional como N(s)/D(s), onde N(s) e D(s) são polinômios em s.",
                                    "Lembre que uma fração é própria se deg(N) ≤ deg(D).",
                                    "Entenda 'próprios assintoticamente' como lim_{s→∞} |N(s)| / |s|^{deg(N)} finito (coeficiente líder não zero) e similar para D(s).",
                                    "Confirme que bipropria requer propriedade + ambos N e D próprios assintoticamente.",
                                    "Anote as condições em um papel para referência."
                                  ],
                                  "verification": "Liste corretamente as 3 condições principais para uma fração bipropria.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Livro ou notas de controle avançado"
                                  ],
                                  "tips": "Use exemplos simples como N(s)=1, D(s)=s para fixar conceitos iniciais.",
                                  "learningObjective": "Compreender precisamente os termos próprios e bipropria no contexto de controle.",
                                  "commonMistakes": [
                                    "Confundir 'própria' (deg N < deg D) com bipropria.",
                                    "Ignorar a parte assintótica dos polinômios."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar e analisar graus dos polinômios numerador e denominador",
                                  "subSteps": [
                                    "Escreva explicitamente N(s) e D(s) da fração dada.",
                                    "Calcule deg(N) contando o maior expoente com coeficiente não zero.",
                                    "Calcule deg(D) da mesma forma.",
                                    "Compare: verifique se deg(N) ≤ deg(D).",
                                    "Se não, classifique como não própria imediatamente."
                                  ],
                                  "verification": "Mostre cálculos de graus e comparação escrita.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Calculadora para polinômios complexos"
                                  ],
                                  "tips": "Sempre expanda polinômios para identificar termos líderes claramente.",
                                  "learningObjective": "Dominar cálculo e comparação de graus de polinômios.",
                                  "commonMistakes": [
                                    "Esquecer coeficientes zero em graus.",
                                    "Confundir numerador com denominador."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Verificar propriedades assintóticas de N(s) e D(s)",
                                  "subSteps": [
                                    "Para N(s): compute lim_{s→∞} N(s)/s^{deg(N)} = coeficiente líder de N.",
                                    "Confirme que é finito e não zero.",
                                    "Repita para D(s): lim_{s→∞} D(s)/s^{deg(D)} finito e não zero.",
                                    "Se ambos satisfazem, prossiga; caso contrário, não é bipropria.",
                                    "Opcionalmente, verifique estabilidade ou zeros em infinito."
                                  ],
                                  "verification": "Registre os limites computados e confirme finitude/não-zero.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Software simbólico como SymPy ou MATLAB (opcional)"
                                  ],
                                  "tips": "Divida polinômio por s^{deg} para visualizar limite facilmente.",
                                  "learningObjective": "Aplicar análise assintótica a polinômios.",
                                  "commonMistakes": [
                                    "Assumir limite zero se deg >0.",
                                    "Não verificar coeficiente líder !=0."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Concluir classificação e documentar raciocínio",
                                  "subSteps": [
                                    "Reúna resultados: graus OK? Assintóticos OK?",
                                    "Se todas condições atendidas, classifique como bipropria.",
                                    "Escreva justificativa completa passo a passo.",
                                    "Teste com variação: altere um coeficiente e reavalie.",
                                    "Registre em formato estruturado para revisão."
                                  ],
                                  "verification": "Produza declaração final com todas verificações listadas.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Papel e caneta"
                                  ],
                                  "tips": "Use tabela para resumir: Grau N, Grau D, Lim N, Lim D.",
                                  "learningObjective": "Sintetizar análise em conclusão precisa.",
                                  "commonMistakes": [
                                    "Pular verificação assintótica se graus OK.",
                                    "Não documentar passos."
                                  ]
                                }
                              ],
                              "practicalExample": "Dada G(s) = (2s + 1)/(s^2 + 3s + 2): deg N=1, deg D=2 (1≤2 OK). Lim s→∞ N/s^1=2 (finito ≠0), D/s^2=1 (finito ≠0). Logo, bipropria. Contraexemplo: (s^2 +1)/(s+1), deg N=2>1=deg D, não própria.",
                              "finalVerifications": [
                                "deg(N) ≤ deg(D) confirmado numericamente.",
                                "Lim s→∞ N(s)/s^{deg N} finito e ≠0.",
                                "Lim s→∞ D(s)/s^{deg D} finito e ≠0.",
                                "Todas condições integradas em conclusão escrita.",
                                "Teste com pelo menos um contraexemplo falha corretamente.",
                                "Documentação passo a passo completa."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de graus (100% correto).",
                                "Cálculo correto de limites assintóticos.",
                                "Classificação final alinhada com definições.",
                                "Justificativa lógica e sequencial.",
                                "Identificação de erros comuns evitados.",
                                "Uso adequado de notação matemática."
                              ],
                              "crossCurricularConnections": [
                                "Engenharia de Controle: Essencial para parametrização de controladores via Bezout.",
                                "Álgebra Linear: Análise de graus similar a ranks de matrizes.",
                                "Programação: Implementar em Python/SymPy para automação.",
                                "Física: Comportamento assintótico em sistemas dinâmicos."
                              ],
                              "realWorldApplication": "Em design de controladores estabilizadores (ex: Youla-Kucera), frações biproprias garantem que funções de transferência de controladores sejam realizáveis fisicamente, evitando amplificação excessiva em baixas/altas frequências em robótica e automação industrial."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "76.1.1.2",
                            "name": "Construir fatorização coprima bipropria",
                            "description": "Dado uma planta P(s) estável ou instável, realizar uma fatorização coprima dupla em RH∞ utilizando métodos como o de estado-espaço ou coprimação espectral para SISO.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Obter representação mínima em espaço de estados da planta P(s)",
                                  "subSteps": [
                                    "Analisar P(s) e convertê-la para função de transferência normalizada se necessário",
                                    "Construir matrizes A, B, C, D usando forma canônica de controllabilidade ou observabilidade",
                                    "Verificar minimalidade computando as matrizes de controllabilidade [B AB ...] e observabilidade [C; CA; ...] e confirmando rank total igual à ordem n",
                                    "Simular resposta em passo para validar que o modelo reproduz P(s)",
                                    "Simplificar se D=0 para plantas estritamente próprias"
                                  ],
                                  "verification": "Rank das matrizes de controllability/observability = n e simulação coincide com P(s)",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "MATLAB ou Python (biblioteca control-systems)",
                                    "Folha de cálculos ou Wolfram Alpha para formas canônicas"
                                  ],
                                  "tips": "Use tf2ss() no MATLAB para automação rápida; prefira forma de controllabilidade para SISO.",
                                  "learningObjective": "Construir e validar realizações mínimas em espaço de estados para funções de transferência SISO.",
                                  "commonMistakes": "Não verificar minimalidade, resultando em cancelamentos desnecessários nas fatorizações."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Projetar ganhos estabilizantes K (realimentação de estado) e L (injeção de saída)",
                                  "subSteps": [
                                    "Selecionar polos desejados no semiplano esquerdo (ex: 2-5x mais rápidos que polos dominantes de P)",
                                    "Calcular K usando pole placement: K = place(A, B, polos_desejados)",
                                    "Calcular L como dual: L = place(A', C', polos_desejados)'",
                                    "Verificar estabilidade: todos autovalores de (A + B K) e (A + L C) têm Re < 0",
                                    "Ajustar polos se necessário para evitar sensibilidade numérica"
                                  ],
                                  "verification": "eig(A + B*K) e eig(A + L*C) todos com parte real negativa",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "MATLAB Control System Toolbox (funções place, eig)",
                                    "Livro de referência: 'Robust and Optimal Control' de Zhou"
                                  ],
                                  "tips": "Use LQR para ganhos ótimos se pole placement falhar numericamente.",
                                  "learningObjective": "Aplicar técnicas de colocação de polos para estabilizar sistemas lineares.",
                                  "commonMistakes": "Escolher polos muito próximos do imaginário, causando instabilidade ou vibrações."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Construir fatorização coprima à direita N(s) M^{-1}(s)",
                                  "subSteps": [
                                    "Definir A_o = A + L * C",
                                    "Construir N(s) = C * (sI - A_o)^{-1} * B",
                                    "Construir M(s) = 1 + K * (sI - A_o)^{-1} * B",
                                    "Converter para função de transferência usando ss2tf",
                                    "Verificar identidade: N(s) == P(s) * M(s)"
                                  ],
                                  "verification": "N(s) e M(s) estáveis (polos de A_o), biproprios (grau num=den) e P M = N",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "MATLAB (ss, tf, feedback)",
                                    "Ferramenta de plotagem de Bode para inspeção"
                                  ],
                                  "tips": "Normalize M(inf)=1; use minreal para cancelar modos estáveis triviais.",
                                  "learningObjective": "Implementar construção explícita de fatorização coprima à direita via estado-espaço.",
                                  "commonMistakes": "Erro na definição de A_o, levando a M não unimodular em infinito."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Construir fatorização coprima à esquerda \\tilde{M}^{-1}(s) \\tilde{N}(s) e verificar bipropriedade",
                                  "subSteps": [
                                    "Definir A_k = A + B * K",
                                    "Construir \\tilde{N}(s) = C * (sI - A_k)^{-1} * B",
                                    "Construir \\tilde{M}(s) = 1 + C * (sI - A_k)^{-1} * L",
                                    "Verificar identidade: \\tilde{M}(s) * P(s) = \\tilde{N}(s)",
                                    "Confirmar coprimidade via identidade de Bezout: encontrar X, Y em RH∞ s.t. X N + Y M = I (ex: testar gcd(N,M)=1 ou bezout explícito)"
                                  ],
                                  "verification": "\\tilde{M}, \\tilde{N} em RH∞, biproprios e bezout identity satisfeita para ambas direções",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "MATLAB (ss2tf, gcd para tf)",
                                    "Documentação RH∞ (Francis 'Feedback Control Theory')"
                                  ],
                                  "tips": "Para bezout, use X = -K * (sI-A_o)^{-1} * B para aproximação; verifique numericamente.",
                                  "learningObjective": "Completar fatorização bipropria e validar coprimidade em RH∞.",
                                  "commonMistakes": "Confundir right/left, resultando em P != fatores; ignorar bipropriedade em s=∞."
                                }
                              ],
                              "practicalExample": "Para P(s) = 1/(s² - s - 2) (polos em s=2, s=-1), A = [[0,1],[2,1]], B = [0;1], C = [1,0]. Escolha polos [-3,-4]. K = place(A,B,[-3,-4]) ≈ [-11.0, -7.0], L = place(A',C',[-3,-4])' ≈ [-11.0; -7.0]. A_o = A + L*C ≈ [[-11,1],[-6, -6]]. Construa N(s) = C(sI-A_o)^{-1}B ≈ 1/(s²+17s+28), M(s)=1 + K(sI-A_o)^{-1}B ≈ (s²+16s+20)/(s²+17s+28). Verifique P = N/M. Repita para left com A_k.",
                              "finalVerifications": [
                                "N, M, \\tilde{M}, \\tilde{N} ∈ RH∞ (estáveis e próprios estritamente)",
                                "P(s) = N(s) M(s)^{-1} = \\tilde{M}(s)^{-1} \\tilde{N}(s)",
                                "Fatores biproprios: lim_{s→∞} M(s) = 1, lim_{s→0} finito e não-zero",
                                "Coprimidade confirmada: não há zeros/polos comuns no semiplano direito fechado",
                                "Identidade de Bezout: ∃ X,Y ∈ RH∞ tal que X N + Y M = I (e dual para left)",
                                "Simulação: respostas coincidem sem discrepâncias >1%"
                              ],
                              "assessmentCriteria": [
                                "Precisão da realização mínima (erro <0.1% em simulação)",
                                "Estabilidade comprovada dos sistemas fechados (todos Re(eig)< -0.5)",
                                "Correção das identidades P M = N e \\tilde{M} P = \\tilde{N} (erro numérico <1e-6)",
                                "Bipropriedade verificada em s=∞ e DC gain finito",
                                "Validação de coprimidade via bezout ou ausência de cancelamentos instáveis",
                                "Relatório inclui plots de Bode/Pole-zero sem anomalias"
                              ],
                              "crossCurricularConnections": [
                                "Álgebra Linear: análise espectral, decomposições canônicas",
                                "Programação Computacional: simulação numérica em MATLAB/Python",
                                "Análise de Sistemas: estabilidade, realizações mínimas",
                                "Otimização: LQR como alternativa à colocação de polos",
                                "Física Aplicada: modelagem de sistemas dinâmicos reais"
                              ],
                              "realWorldApplication": "Fundamental para a parametrização Youla-Kučera de todos os controladores estabilizantes, usada em controle robusto H∞ para sistemas com incertezas como drones, robótica industrial e processos químicos instáveis, permitindo síntese de controladores ótimos via LMIs."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "76.1.1.3",
                            "name": "Verificar coprimidade de N(s) e M(s)",
                            "description": "Usar o algoritmo de Euclides estendido em RH∞ para confirmar que N(s) e M(s) são coprimos, computando o MDC e verificando se é unimodular (constante).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar e Normalizar N(s) e M(s)",
                                  "subSteps": [
                                    "Identifique N(s) e M(s) como frações biproprias em RH∞ (racionais próprias estritas estáveis).",
                                    "Normalize as frações: escreva N(s) = numN(s)/denN(s) e M(s) = numM(s)/denM(s), com denominadores monicos.",
                                    "Verifique graus: assegure deg(numN) < deg(denN) e similar para M; se necessário, execute divisão polinomial para properidade.",
                                    "Confirme estabilidade: verifique que todos polos estão no semiplano esquerdo.",
                                    "Documente as representações nominais e denominais."
                                  ],
                                  "verification": "N(s) e M(s) estão normalizadas, próprias estritas e estáveis, com graus corretos confirmados.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e caneta ou editor de texto",
                                    "Software simbólico como MATLAB Symbolic Toolbox ou Mathematica"
                                  ],
                                  "tips": "Sempre assuma denominadores comuns se possível para simplificar divisões futuras.",
                                  "learningObjective": "Compreender a representação padrão de frações biproprias em RH∞.",
                                  "commonMistakes": [
                                    "Esquecer de tornar as frações próprias estritas",
                                    "Ignorar a estabilidade dos polos"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Aplicar Algoritmo de Euclides Básico",
                                  "subSteps": [
                                    "Ordene N(s) e M(s) por grau do denominador: suponha deg(denM) >= deg(denN).",
                                    "Execute divisão: compute Q1(s) = N(s)/M(s) e R1(s) = N(s) - Q1(s)M(s), com deg(R1) < deg(M).",
                                    "Continue iterativamente: R_{k}(s) = R_{k-2}(s) - Q_k(s) R_{k-1}(s), até R_k ser constante ou zero.",
                                    "Registre todos os quocientes Q_i(s) e restos R_i(s).",
                                    "Pare quando o resto for unimodular (constante não-zero)."
                                  ],
                                  "verification": "Sequência de restos diminui em grau até alcançar um MDC candidato constante.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Calculadora simbólica ou MATLAB/Simulink",
                                    "Folha de cálculo para rastrear divisões"
                                  ],
                                  "tips": "Use divisão polinomial longa para frações racionais; foque em numeradores e denominadores separadamente.",
                                  "learningObjective": "Executar o algoritmo de Euclides adaptado para RH∞.",
                                  "commonMistakes": [
                                    "Erros em divisões polinomiais",
                                    "Não manter properidade nos restos"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Aplicar Algoritmo de Euclides Estendido",
                                  "subSteps": [
                                    "Inicialize: MDC = R_final, S0 = 1, T0 = 0 para N; S1 = 0, T1 = 1 para M.",
                                    "Back-substitua iterativamente: para cada passo k, S_k = S_{k-2} - Q_k S_{k-1}, T_k = T_{k-2} - Q_k T_{k-1}.",
                                    "Continue até expressar MDC = S_final N(s) + T_final M(s).",
                                    "Verifique a identidade Bezout: compute S_final N + T_final M e confirme igual a MDC.",
                                    "Simplifique S_final e T_final se necessário."
                                  ],
                                  "verification": "S_final N(s) + T_final M(s) = MDC constante (ex: 1).",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "MATLAB com Control System Toolbox",
                                    "Tabela para rastrear coeficientes S e T"
                                  ],
                                  "tips": "Mantenha rastreamento tabular de S_k e T_k para evitar confusão.",
                                  "learningObjective": "Construir coeficientes Bezout via back-substitution.",
                                  "commonMistakes": [
                                    "Sinais errados nas subtrações",
                                    "Perder o rastreamento de índices"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificar Coprimidade e Unimodularidade",
                                  "subSteps": [
                                    "Confirme que MDC é constante unimodular (ex: MDC = c, |c|=1 ou normalizado para 1).",
                                    "Verifique se S_final e T_final pertencem a RH∞ (estáveis e próprias).",
                                    "Teste numericamente: avalie em pontos do semiplano direito para estabilidade.",
                                    "Se MDC não constante, conclua não coprimos e identifique fator comum.",
                                    "Documente conclusão: coprimos se MDC unimodular."
                                  ],
                                  "verification": "MDC é constante e S N + T M = MDC com S,T em RH∞.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Software de plotagem como MATLAB bode() ou nyquist()",
                                    "Valores de teste s=jω"
                                  ],
                                  "tips": "Normalize MDC dividindo por sua constante para padronizar.",
                                  "learningObjective": "Distinguir coprimidade via MDC unimodular em RH∞.",
                                  "commonMistakes": [
                                    "Confundir constante com polinomial de grau zero",
                                    "Ignorar estabilidade de S e T"
                                  ]
                                }
                              ],
                              "practicalExample": "Dado N(s) = 1/(s+1), M(s) = (s+2)/((s+1)(s+3)). Aplicar Euclides: Q1 = (s+2)/(s+3), R1 = 1/(s+3). Então Q2 = (s+3)/(s+1) wait, prosseguir até MDC=1/(s+1)(s+3) ajustado, mas normalizando denominadores comuns, revela coprimidade com Bezout X= (s+3), Y= -1 ajustados.",
                              "finalVerifications": [
                                "MDC computado é uma constante unimodular.",
                                "Identidade Bezout X N + Y M = 1 holds em RH∞.",
                                "Todos coeficientes X e Y são estáveis e próprios estritas.",
                                "Testes numéricos em jω confirmam igualdade.",
                                "Sem fatores comuns nos numeradores/denominadores.",
                                "Graus preservados em todas divisões."
                              ],
                              "assessmentCriteria": [
                                "Precisão na execução do Euclides básico e estendido (sem erros algébricos).",
                                "Correta identificação de coprimidade (MDC unimodular).",
                                "Validação completa da identidade Bezout.",
                                "Eficiência no número de iterações (mínimo necessário).",
                                "Documentação clara de todos passos e coeficientes.",
                                "Tratamento de casos edge (ex: graus iguais)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Álgebra de Polinômios e Teoria dos Números (Euclides).",
                                "Programação: Implementação em Python/MATLAB para automação.",
                                "Física: Modelagem de sistemas dinâmicos lineares.",
                                "Computação Científica: Análise simbólica e numérica."
                              ],
                              "realWorldApplication": "Em engenharia de controle, verificar coprimidade de N(s)/M(s) é essencial para parametrização de controladores estabilizadores via Youla-Kucera, garantindo estabilidade robusta em sistemas como drones ou processos industriais."
                            },
                            "estimatedTime": "0.75 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "76.1.1.1"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "76.1.2",
                        "name": "Identidade de Bezout",
                        "description": "Condição algébrica fundamental: existem funções estáveis X(s), Y(s) ∈ RH∞ tais que X(s) N(s) + Y(s) M(s) = 1, para fatorizações coprimas biproprias.",
                        "specificSkills": [
                          {
                            "id": "76.1.2.1",
                            "name": "Enunciar a identidade de Bezout",
                            "description": "Formular precisamente a identidade de Bezout para sistemas LIT monovariáveis, destacando o papel das funções bezoutianas X e Y no anel RH∞.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Fundamentos de Sistemas LIT Monovariáveis e o Anel RH∞",
                                  "subSteps": [
                                    "Defina sistemas LIT monovariáveis como sistemas lineares invariantes no tempo com uma entrada e uma saída.",
                                    "Explique RH∞ como o anel de funções racionais próprias, estáveis estritamente adequadas (SPAF) em s.",
                                    "Discuta propriedades de RH∞: é um anel euclidiano, principal ideal (PID) e behaviorista.",
                                    "Identifique exemplos de funções em RH∞, como 1/(s+1), e não em RH∞, como 1/s.",
                                    "Compare RH∞ com RH (funções racionais estáveis holomorfas no semiplano direito)."
                                  ],
                                  "verification": "Escreva definições precisas de LIT monovariável e RH∞ e liste 3 propriedades chave de RH∞.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Livro de controle avançado (e.g., Zhou 'Robust Control'), notas de aula sobre RH∞, calculadora simbólica (MATLAB/SymPy).",
                                  "tips": "Use diagramas de polos-zero para visualizar estabilidade em RH∞.",
                                  "learningObjective": "Compreender o contexto algébrico onde a identidade de Bézout é aplicada.",
                                  "commonMistakes": "Confundir RH∞ com H∞ (espaço de Hardy); lembrar que RH∞ requer adequação estrita (lim s->∞ F(s)=0)."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Entender Coprimidade em RH∞",
                                  "subSteps": [
                                    "Defina coprimidade bezoutiana: P, M ∈ RH∞ são coprimos se ∃ X,Y ∈ RH∞ tal que P X + M Y = 1.",
                                    "Diferencie de coprimidade unimodular (geradores comuns de ideais triviais).",
                                    "Aprenda teste de coprimidade via fatorização em fatores irreducíveis ou algoritmo euclidiano em RH∞.",
                                    "Estude o lema de coprimidade dupla: [P;M] tem posto completo se e só se P,M coprimos.",
                                    "Pratique com exemplo: Verifique se P(s)=1/(s+1), M(s)=1/(s+2) são coprimos."
                                  ],
                                  "verification": "Aplique algoritmo euclidiano a um par P,M e conclua coprimidade corretamente.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Software MATLAB (Robust Control Toolbox), exemplos resolvidos de Vidyasagar ou Francis.",
                                  "tips": "Visualize graficamente os zeros de P e M para intuir coprimidade.",
                                  "learningObjective": "Dominar pré-condição para existência das bezoutianas.",
                                  "commonMistakes": "Ignorar normalização; bezoutianas devem ser em RH∞, não apenas polinômios."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Enunciar Precisamente a Identidade de Bézout",
                                  "subSteps": [
                                    "Enuncie: Para P,M ∈ RH∞ coprimos bezoutianamente, ∃! X,Y ∈ RH∞ (até unimodular) tal que P X + M Y = 1.",
                                    "Destaque unicidade modular: X' = X + M T, Y' = Y - P T para T unimodular em RH∞.",
                                    "Conecte à parametrização de Youla: Controladores C = (X + M Q)/(-Y + P Q), Q ∈ RH∞.",
                                    "Escreva em forma matricial: Existe [X Y] bezoutiana esquerda para [P M].",
                                    "Memorize notação padrão: Identidade P X + M Y = 1."
                                  ],
                                  "verification": "Escreva o enunciado completo da identidade, incluindo condições e papéis de X,Y.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Folha de referência com teoremas de controle robusto, quadro branco para escrita.",
                                  "tips": "Repita o enunciado em voz alta 5 vezes, variando contexto (planta P, modelo M).",
                                  "learningObjective": "Formular o teorema exato com precisão matemática.",
                                  "commonMistakes": "Esquecer 'coprimos' ou domínio RH∞; confundir com identidade de Bézout em Z."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Explorar o Papel das Funções Bezoutianas X e Y",
                                  "subSteps": [
                                    "Descreva X como 'filtro de estabilização da planta' P e Y para o modelo M.",
                                    "Entenda uso em Q-parametrização: Todos estabilizadores são C = X + M Q / Y - P Q.",
                                    "Discuta estabilidade: Como P,M estáveis implicam C estável para Q ∈ RH∞.",
                                    "Analise propriedades: ||X||∞, ||Y||∞ relacionam-se a robustez.",
                                    "Pratique computando X,Y via Sylvester ou divisão euclidiana para exemplo simples."
                                  ],
                                  "verification": "Explique verbalmente o papel de X,Y em um diagrama de laço fechado.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "MATLAB para resolver equações de Bezout, paper sobre Youla-Kucera.",
                                  "tips": "Desenhe bloco de feedback mostrando inserção de Q via X,Y.",
                                  "learningObjective": "Destacar aplicações práticas das bezoutianas em controle.",
                                  "commonMistakes": "Confundir X,Y com controladores; são bezoutianas, não C diretamente."
                                }
                              ],
                              "practicalExample": "Considere P(s) = 1/(s+1), M(s) = (s+2)/((s+1)(s+3)). São coprimos em RH∞. Resolva P X + M Y = 1 usando divisão euclidiana: X(s) = (s+3)/(s+2), Y(s) = -1/(s+2). Verifique: P X + M Y = [1/(s+1)]*(s+3)/(s+2) + [(s+2)/((s+1)(s+3))] * [-1/(s+2)] = 1.",
                              "finalVerifications": [
                                "Enuncie corretamente a identidade sem consultar notas.",
                                "Identifique corretamente se um par P,M dado é coprimo.",
                                "Compute bezoutianas X,Y para um exemplo simples.",
                                "Explique o papel de X,Y na parametrização de controladores.",
                                "Diferencie RH∞ de outros anéis em controle.",
                                "Aplique identidade a um diagrama de laço unitário."
                              ],
                              "assessmentCriteria": [
                                "Precisão no enunciado: inclui coprimidade, RH∞ e forma P X + M Y =1 (peso 30%).",
                                "Compreensão de X,Y: explica unicidade e uso em Youla (peso 25%).",
                                "Exemplo prático: resolve corretamente com verificação (peso 20%).",
                                "Conexões contextuais: liga a estabilização LIT monovariável (peso 15%).",
                                "Clareza e formalidade matemática: usa notação padrão (peso 10%)."
                              ],
                              "crossCurricularConnections": [
                                "Álgebra Comutativa: Anéis euclidianos e identidades de Bézout clássicas.",
                                "Análise Complexa: Estabilidade via semiplano direito e funções holomorfas.",
                                "Teoria de Controle Clássico: Transição de Nyquist para robusto via RH∞.",
                                "Programação Numérica: Implementação em MATLAB para divisão em frações racionais."
                              ],
                              "realWorldApplication": "Na parametrização de controladores estabilizadores para plantas incertas em automação industrial, como motores DC ou processos químicos, onde X e Y garantem todos os controladores robustos via Q ∈ RH∞, otimizando desempenho em face de perturbações."
                            },
                            "estimatedTime": "0.25 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "76.1.1.2"
                            ]
                          },
                          {
                            "id": "76.1.2.2",
                            "name": "Demonstrar existência dos bezoutians",
                            "description": "Provar a existência de X e Y usando o lema de coprimidade em RH∞, ou via realização de estado-espaço mínima e observador.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Conceitos Fundamentais de Coprimidade em RH∞",
                                  "subSteps": [
                                    "Defina RH∞ como o espaço de funções racionais próprias e estáveis estritamente.",
                                    "Explique coprimidade à direita (right coprimidade): N e M não compartilham zeros comuns em RH∞.",
                                    "Enuncie o lema de coprimidade: Se N, M são right coprime em RH∞, existem X, Y em RH∞ tais que X N + Y M = 1.",
                                    "Discuta implicações para parametrização de controladores estabilizadores.",
                                    "Resolva um exercício simples de verificação de coprimidade."
                                  ],
                                  "verification": "Escreva definições precisas e prove coprimidade para um par N(s), M(s) exemplo.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": "Livro de controle avançado (e.g., Zhou 'Robust Control'), notas de aula, MATLAB para plotar polos/zeros.",
                                  "tips": "Use fatorização de Bezout genérica para visualizar; foque em SISO primeiro.",
                                  "learningObjective": "Compreender a base teórica da existência de bezoutians via coprimidade.",
                                  "commonMistakes": "Confundir coprimidade à esquerda/direita; ignorar estabilidade em RH∞."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Provar Existência de Bezoutians Usando o Lema de Coprimidade",
                                  "subSteps": [
                                    "Assuma N, M right coprime em RH∞.",
                                    "Construa sequências de Bézout aproximadas via extensão do algoritmo de Euclides em RH∞.",
                                    "Mostre convergência para X, Y em RH∞ satisfazendo X N + Y M = 1.",
                                    "Verifique estabilidade de X e Y explicitamente.",
                                    "Generalize para o caso monovariável com exemplo numérico."
                                  ],
                                  "verification": "Derive X e Y para N(s)=1/(s+1), M(s)=s/(s+1) e confirme X N + Y M =1.",
                                  "estimatedTime": "2 horas",
                                  "materials": "Papel e lápis para derivações, software simbólico como Mathematica ou SymPy.",
                                  "tips": "Comece com graus baixos para insight; normalize para ganhar 1.",
                                  "learningObjective": "Aplicar lema de coprimidade para construir bezoutians explicitamente.",
                                  "commonMistakes": "Esquecer de garantir X,Y em RH∞; erros em divisões polinomiais."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Demonstrar Existência via Realização de Estado-Espaço Mínima e Observador",
                                  "subSteps": [
                                    "Dada realização mínima de estado-espaço para N: (A,B,C,0), assuma detectável/estabilizável.",
                                    "Construa observador de Luenberger para estimar estado.",
                                    "Sintetize controlador baseado em observador que estabiliza o loop fechado.",
                                    "Extraia bezoutians X, Y das equações do controlador/observador.",
                                    "Prove que X N + Y M =1 segue da minimalidade."
                                  ],
                                  "verification": "Implemente em MATLAB para um sistema de ordem 2 e verifique identidade de Bézout.",
                                  "estimatedTime": "2.5 horas",
                                  "materials": "MATLAB/Simulink com Control System Toolbox, exemplos de state-space de livros.",
                                  "tips": "Use 'ss' para realizations; resolva LMIs para ganhos se necessário.",
                                  "learningObjective": "Conectar teoria state-space à existência algébrica de bezoutians.",
                                  "commonMistakes": "Não verificar minimalidade (controle/observabilidade); instabilidade do observador."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificar e Sintetizar Bezoutians em Contextos Práticos",
                                  "subSteps": [
                                    "Compare bezoutians dos dois métodos para o mesmo par N,M.",
                                    "Teste estabilidade e performance em simulações de laço fechado.",
                                    "Discuta unicidade e parametrização geral (Youla).",
                                    "Resolva problema inverso: dado X,Y, recupere N,M.",
                                    "Documente prova completa em relatório curto."
                                  ],
                                  "verification": "Simule estabilização com Q arbitrário e confirme robustez.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": "MATLAB para simulações, template de relatório LaTeX.",
                                  "tips": "Use 'feedback' command no MATLAB para validação rápida.",
                                  "learningObjective": "Integrar métodos e validar existência em aplicações.",
                                  "commonMistakes": "Ignorar normalizações de coprimidade; sobrecarga computacional em altos graus."
                                }
                              ],
                              "practicalExample": "Para N(s) = 1/(s^2 + 2s + 2), M(s) = (s+1)/(s^2 + 2s + 2), right coprime. Usando lema: X(s) = s+1, Y(s) = 1 - (s+1)/(s^2 + 2s + 2) * N(s), mas ajuste para RH∞. State-space: A = [-2, -1; 1, 0], etc., derive observer para X,Y e verifique XN + YM =1 em Simulink.",
                              "finalVerifications": [
                                "Conseguiu derivar X,Y analiticamente para par coprime dado.",
                                "Simulação em MATLAB confirma XN + YM =1 para todas frequências.",
                                "Bezoutians X,Y são próprios e estáveis (polos em RH-).",
                                "Aplicou em controlador estabilizador Q=0.",
                                "Comparou resultados dos dois métodos sem discrepâncias.",
                                "Identificou erros comuns em provas alternativas."
                              ],
                              "assessmentCriteria": [
                                "Precisão matemática na derivação (sem erros algébricos).",
                                "Correta verificação de estabilidade em RH∞.",
                                "Profundidade em substeps (mínimo 4 por step).",
                                "Uso efetivo de ferramentas computacionais.",
                                "Clareza na conexão entre métodos teóricos e state-space.",
                                "Criatividade em exemplos práticos."
                              ],
                              "crossCurricularConnections": [
                                "Álgebra Linear: Realizações de state-space e observadores.",
                                "Teoria de Controle Básica: Estabilidade e laços fechados.",
                                "Matemática Computacional: Algoritmo de Euclides em anéis de polinômios.",
                                "Processamento de Sinais: Fatorizações em domínio de Laplace."
                              ],
                              "realWorldApplication": "Em design de controladores robustos para plantas incertas (e.g., aeronaves, robótica), bezoutians garantem todos estabilizadores via Q em RH∞, usado em sistemas aeroespaciais como F-16 autopilot para estabilidade apesar de delays."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "76.1.1.3"
                            ]
                          },
                          {
                            "id": "76.1.2.3",
                            "name": "Calcular bezoutians para exemplo simples",
                            "description": "Para uma planta P(s) = 1/(s-1), encontrar explicitamente N, M, X, Y satisfazendo X N + Y M = 1 usando MATLAB ou cálculo manual.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Definir N(s) e M(s) para a planta P(s)",
                                  "subSteps": [
                                    "Analise a planta dada P(s) = 1/(s-1)",
                                    "Identifique o numerador N(s) = 1 e o denominador M(s) = s - 1",
                                    "Escreva P(s) = N(s)/M(s) em forma coprima fracionária",
                                    "Confirme os graus: deg(N) = 0, deg(M) = 1",
                                    "Documente as expressões polinomiais explicitamente"
                                  ],
                                  "verification": "N(s) e M(s) corretamente extraídos e P(s) = N(s)/M(s) confirmado",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Papel e caneta ou editor de texto",
                                    "Software simbólico como MATLAB Symbolic Toolbox (opcional)"
                                  ],
                                  "tips": "Sempre normalize para que o denominador seja monico (coeficiente líder 1)",
                                  "learningObjective": "Compreender a decomposição de plantas em fatores coprimos N e M",
                                  "commonMistakes": [
                                    "Confundir numerador e denominador",
                                    "Esquecer de normalizar polinômios",
                                    "Ignorar graus dos polinômios"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Aplicar o Algoritmo Euclidiano para verificar coprimidade",
                                  "subSteps": [
                                    "Inicie com r0(s) = M(s) = s - 1, r1(s) = N(s) = 1",
                                    "Compute r0 = q1 * r1 + r2: q1(s) = s - 1, r2(s) = 0",
                                    "Conclua que gcd(N, M) = 1 (coprimos) pois resto final é constante não-zero",
                                    "Registre todos os quocientes e restos da divisão polinomial",
                                    "Anote a sequência de divisões para back-substitution"
                                  ],
                                  "verification": "Sequência euclidiana termina com resto 1 ou constante, confirmando gcd=1",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Calculadora simbólica ou MATLAB (syms s; euclid([s-1  -1], [1]) )"
                                  ],
                                  "tips": "Use divisão polinomial sintética para polinômios de baixo grau",
                                  "learningObjective": "Dominar o algoritmo euclidiano para polinômios e verificar coprimidade",
                                  "commonMistakes": [
                                    "Erro em divisão polinomial (ex: esquecer termo constante)",
                                    "Parar prematuramente sem resto zero",
                                    "Confundir ordem de r0 e r1"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Realizar substituição retroativa para encontrar X(s) e Y(s)",
                                  "subSteps": [
                                    "Da equação final: 1 = r1(s) = 1 * N(s) + 0 * M(s)",
                                    "Back-substitua: como r2=0, diretamente X(s) = 1, Y(s) = 0",
                                    "Gere expressões gerais: X(s) N(s) + Y(s) M(s) = 1",
                                    "Verifique graus: deg(X) < deg(M)=1, deg(Y) < deg(N)=0 (Y constante)",
                                    "Escreva explicitamente: 1*1 + 0*(s-1) = 1"
                                  ],
                                  "verification": "Substituir X e Y na identidade resulta em 1 identicamente",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Papel para rastrear coeficientes",
                                    "MATLAB para syms e simplify"
                                  ],
                                  "tips": "Mantenha rastreamento tabular de coeficientes bezout durante back-substitution",
                                  "learningObjective": "Aplicar back-substitution euclidiana para coeficientes bezoutianos",
                                  "commonMistakes": [
                                    "Sinais errados em back-substitution",
                                    "Esquecer unimodularidade (det=±1)",
                                    "Gerar X ou Y de grau excessivo"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificar identidade e implementar em MATLAB",
                                  "subSteps": [
                                    "Compute X N + Y M manualmente e simplifique para 1",
                                    "Abra MATLAB: syms s; N=1; M=s-1; X=1; Y=0; simplify(X*N + Y*M)",
                                    "Teste estabilidade se aplicável (polos de X,Y dentro do círculo unitário)",
                                    "Gere plot ou tabela de valores numéricos para validação",
                                    "Documente código e resultados para relatório"
                                  ],
                                  "verification": "MATLAB retorna 1 e verificação manual confirma identidade",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "MATLAB com Symbolic Math Toolbox",
                                    "Script .m pronto para execução"
                                  ],
                                  "tips": "Use 'collect' ou 'simplify' no MATLAB para polinômios simbólicos",
                                  "learningObjective": "Validar bezoutians analiticamente e numericamente com software",
                                  "commonMistakes": [
                                    "Erros de sintaxe no MATLAB syms",
                                    "Não simplificar expressões simbólicas",
                                    "Ignorar verificação de graus"
                                  ]
                                }
                              ],
                              "practicalExample": "Para P(s) = 1/(s-1), N(s)=1, M(s)=s-1. Aplicando euclidiano: X(s)=1, Y(s)=0 satisfaz 1*1 + 0*(s-1) = 1. Em MATLAB: syms s; simplify(1*1 + 0*(s-1)) retorna 1.",
                              "finalVerifications": [
                                "XN(s) + YM(s) = 1 identicamente para todo s",
                                "N(s) e M(s) corretamente extraídos de P(s)",
                                "gcd(N,M)=1 confirmado pelo euclidiano",
                                "deg(X) < deg(M) e deg(Y) < deg(N)",
                                "Código MATLAB executa sem erros e retorna 1",
                                "Solução é unimodular (adequada para parametrização)"
                              ],
                              "assessmentCriteria": [
                                "Precisão da decomposição N/M",
                                "Correção do algoritmo euclidiano e back-substitution",
                                "Validação da identidade Bézout",
                                "Eficiência e clareza da implementação MATLAB",
                                "Atendimento a restrições de grau dos bezoutians",
                                "Documentação completa dos passos"
                              ],
                              "crossCurricularConnections": [
                                "Álgebra Computacional (gcd polinomial)",
                                "Programação Numérica/Simbólica (MATLAB)",
                                "Teoria dos Números (identidade de Bézout estendida)",
                                "Análise de Sistemas Lineares"
                              ],
                              "realWorldApplication": "Cálculo de bezoutians é fundamental para a parametrização de Youla-Kucera de todos os controladores estabilizantes, usada no design robusto de controladores para plantas instáveis como motores ou processos químicos."
                            },
                            "estimatedTime": "0.75 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "76.1.2.1"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "76.1.3",
                        "name": "Existência de Controladores Estabilizadores",
                        "description": "A identidade de Bezout garante a existência de todos os controladores estabilizantes via parametrização C(s) = (X + M Q)(Y - N Q)^{-1}, para Q ∈ RH∞ estável.",
                        "specificSkills": [
                          {
                            "id": "76.1.3.1",
                            "name": "Relacionar Bezout à estabilização",
                            "description": "Explicar como a identidade implica que o controlador C = X Y^{-1} estabiliza P, e generaliza para todos Q estáveis.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar a Identidade de Bézout para Coprimos Biproprios",
                                  "subSteps": [
                                    "Defina coprimos biproprios M e N para a planta P = N M^{-1}.",
                                    "Enuncie a identidade de Bézout: existe X e Y biproprios tais que M Y - N X = 1.",
                                    "Verifique a existência usando o lema de Bezout em anéis de polinômios próprios estáveis.",
                                    "Discuta as propriedades biproprias de X e Y.",
                                    "Esboce a prova básica da existência via extensão de Bezout."
                                  ],
                                  "verification": "Construa X e Y para um exemplo simples de P e confirme que M Y - N X = 1.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Livro de controle avançado (e.g., Zhou 'Robust Control'), MATLAB/Simulink para simulações, notas de aula sobre frações próprias.",
                                  "tips": "Use frações de Smith-McMillan para decompor P e identificar M, N.",
                                  "learningObjective": "Compreender a base algébrica da identidade de Bézout em sistemas lineares.",
                                  "commonMistakes": "Confundir biproprio com unimodular; ignorar estabilidade própria."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Demonstrar que C = X Y^{-1} Estabiliza a Planta P",
                                  "subSteps": [
                                    "Expresse o laço fechado T = (P C)(1 + P C)^{-1} usando P = N M^{-1} e C = X Y^{-1}.",
                                    "Substitua na identidade de Bézout para mostrar que 1 + P C = M Y^{-1}.",
                                    "Prove que T = N X^{-1}, assumindo inversos próprios estáveis.",
                                    "Verifique estabilidade: denominadores e numeradores biproprios implicam estabilidade.",
                                    "Simule numericamente para validar."
                                  ],
                                  "verification": "Calcule os polos do laço fechado e confirme todos no semiplano esquerdo.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "MATLAB com Control System Toolbox, exemplos numéricos de P estável.",
                                  "tips": "Fatore tudo em termos de M, N para simplificar álgebra.",
                                  "learningObjective": "Provar analiticamente a estabilização pelo controlador de Bézout básico.",
                                  "commonMistakes": "Esquecer inversibilidade própria de Y; não cancelar termos biproprios corretamente."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Introduzir a Parametrização Geral com Q Estável",
                                  "subSteps": [
                                    "Defina o controlador geral C_Q = (X + M Q)(Y - N Q)^{-1} para Q estável biproprio.",
                                    "Use a identidade de Bézout para mostrar que C_Q estabiliza P para qualquer Q estável.",
                                    "Prove que o laço fechado é T_Q = (N + M Q)(X + M Q)^{-1}.",
                                    "Discuta liberdade de Q para tuning de performance.",
                                    "Compare C = X Y^{-1} como caso Q=0."
                                  ],
                                  "verification": "Para um Q específico, compute T_Q e verifique estabilidade.",
                                  "estimatedTime": "50 minutos",
                                  "materials": "Folhas de cálculo simbólica (SymPy ou MATLAB Symbolic), diagramas de blocos.",
                                  "tips": "Visualize com diagramas de Youla para intuição geométrica.",
                                  "learningObjective": "Entender como Bézout parametrizes todos controladores estabilizadores.",
                                  "commonMistakes": "Assumir Q qualquer; não garantir bipropriedade de Y - N Q."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Generalizar e Verificar a Completude da Parametrização",
                                  "subSteps": [
                                    "Prove que todo controlador estabilizador é da forma C_Q para algum Q estável.",
                                    "Discuta condições para Y - N Q ser invertível próprio.",
                                    "Explore implicações para robustez e síntese ótima.",
                                    "Resolva um problema inverso: dado C estabilizador, encontre Q.",
                                    "Resuma a relação Bézout-estabilização."
                                  ],
                                  "verification": "Dado um C estabilizador exemplo, derive Q e confirme.",
                                  "estimatedTime": "40 minutos",
                                  "materials": "Exercícios resolvidos de parametrização Youla-Kučera.",
                                  "tips": "Use feedback negativo padrão para representar parametrização.",
                                  "learningObjective": "Generalizar Bézout para o conjunto completo de estabilizadores.",
                                  "commonMistakes": "Ignorar singularidades quando det(Y - N Q)=0; confundir com LQG."
                                }
                              ],
                              "practicalExample": "Para P(s) = 1/(s+1), encontre M=1, N=1/(s+1) coprimos. Resolva Bézout para X= s+2, Y=1. Então C = (s+2)/1 estabiliza P. Para Q=1/(s+2), C_Q = (s+3)/(s+1), verifique laço fechado estável via nyquist ou root locus no MATLAB.",
                              "finalVerifications": [
                                "Derive analiticamente 1 + P C = M Y^{-1} a partir de Bézout.",
                                "Mostre estabilidade de T para C_Q com Q estável arbitrário.",
                                "Encontre Q para um C estabilizador dado.",
                                "Simule step response estável para C e C_Q.",
                                "Explique verbalmente a generalização em 2 minutos.",
                                "Identifique erro em uma prova incompleta de estabilização."
                              ],
                              "assessmentCriteria": [
                                "Precisão na derivação da identidade de Bézout (correta manipulação algébrica).",
                                "Correta prova de estabilidade para C = X Y^{-1} (uso de bipropriedade).",
                                "Compreensão da parametrização geral (livre Q estável).",
                                "Aplicação numérica válida em exemplo (polos estáveis confirmados).",
                                "Explicação clara da generalização (verbal e escrita).",
                                "Identificação de erros comuns em provas relacionadas."
                              ],
                              "crossCurricularConnections": [
                                "Álgebra Linear: Inversos em anéis euclidianos e identidades de Bezout.",
                                "Teoria de Sistemas: Diagrama de Youla e parametrização de feedback.",
                                "Matemática Aplicada: Frações de Smith-McMillan e coprimidade.",
                                "Otimização: Tuning de Q para controle ótimo (LQR/LQG)."
                              ],
                              "realWorldApplication": "Em design de controladores para aviões (e.g., estabilização de flight envelope) ou processos industriais (e.g., destiladores), a parametrização via Bézout permite sintetizar famílias de controladores robustos a variações de planta, garantindo estabilidade em bancos de controladores adaptativos."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "76.1.2.2"
                            ]
                          },
                          {
                            "id": "76.1.3.2",
                            "name": "Construir controlador estabilizante básico",
                            "description": "Usando bezoutians computados, montar o controlador central Q=0 e verificar estabilidade do laço fechado via funções de transferência fechadas.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Recuperar e validar Bezoutians computados",
                                  "subSteps": [
                                    "Identifique a fatoração coprima da planta P(s) = N(s)/D(s).",
                                    "Recupere os Bezoutians X(s) e Y(s) tal que X(s)N(s) - Y(s)D(s) = 1.",
                                    "Valide a identidade de Bezout computando XN - YD e confirmando que resulta em 1.",
                                    "Verifique que N, D, X, Y são próprios e estáveis.",
                                    "Documente os polinômios ou funções de transferência envolvidos."
                                  ],
                                  "verification": "A identidade de Bezout é satisfeita: XN - YD = 1 em todo o domínio.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Software de álgebra simbólica (MATLAB Symbolic Toolbox ou Mathematica)",
                                    "Notas da computação prévia dos Bezoutians",
                                    "Planta P(s) definida"
                                  ],
                                  "tips": "Use funções simbólicas para evitar erros numéricos; armazene em variáveis claras como N, D, X, Y.",
                                  "learningObjective": "Garantir compreensão da identidade de Bezout como base para parametrização.",
                                  "commonMistakes": [
                                    "Confundir fatoração esquerda/direita",
                                    "Esquecer normalização para identidade =1",
                                    "Usar aproximações numéricas prematuras"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Montar o controlador central Q=0",
                                  "subSteps": [
                                    "Defina Q(s) = 0.",
                                    "Construa C(s) = X(s) / Y(s), o controlador central da parametrização de Youla.",
                                    "Simplifique C(s) cancelando fatores comuns, se houver.",
                                    "Verifique que C(s) é próprio (grau numerador ≤ grau denominador).",
                                    "Expresse C(s) em forma de transferência ou polinomial."
                                  ],
                                  "verification": "C(s) = X/Y é próprio e matches a fórmula para Q=0.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "MATLAB/Simulink ou Python (Control Systems Library)",
                                    "Bezoutians do Step 1"
                                  ],
                                  "tips": "Garanta que Y(s) ≠ 0; use tf() no MATLAB para criar objeto de transferência.",
                                  "learningObjective": "Construir explicitamente o controlador estabilizante central.",
                                  "commonMistakes": [
                                    "Inverter incorretamente X/Y",
                                    "Ignorar propriedadade",
                                    "Não simplificar frações"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Formar e computar funções de transferência do laço fechado",
                                  "subSteps": [
                                    "Monte o diagrama de laço fechado: T(s) = P(s)C(s) / (1 + P(s)C(s)).",
                                    "Compute o denominador do laço fechado: 1 + N(s)X(s), usando Bezout.",
                                    "Calcule numerador e denominador de T(s).",
                                    "Confirme que denominador é Y(s)D(s), estável por construção.",
                                    "Gere representações simbólicas ou numéricas de T(s)."
                                  ],
                                  "verification": "Função de transferência fechada T(s) possui denominador estável.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "MATLAB Control System Toolbox",
                                    "Funções tf e feedback",
                                    "P(s) e C(s) prontos"
                                  ],
                                  "tips": "Use feedback(P*C, 1) no MATLAB para laço unitário; plote polos.",
                                  "learningObjective": "Analisar estrutura do laço fechado na parametrização.",
                                  "commonMistakes": [
                                    "Erro no sinal do laço (feedback negativo)",
                                    "Confundir T(s) com S(s)",
                                    "Não expandir frações corretamente"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificar estabilidade do laço fechado",
                                  "subSteps": [
                                    "Extraia polos do denominador do laço fechado.",
                                    "Confirme que todos os polos estão no semiplano esquerdo (Re(p) < 0).",
                                    "Plote diagrama de polos e zeros.",
                                    "Simule resposta ao degrau para validar estabilidade prática.",
                                    "Compare com laço aberto para evidenciar estabilização."
                                  ],
                                  "verification": "100% dos polos têm parte real negativa; simulação converge sem oscilações crescentes.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "MATLAB (pole(), step(), pzmap())",
                                    "Sistema Simulink opcional"
                                  ],
                                  "tips": "Use rlist = roots(denom) e verifique real(rlist) < 0; tolerância numérica 1e-10.",
                                  "learningObjective": "Validar estabilidade teórica e prática do controlador.",
                                  "commonMistakes": [
                                    "Ignorar polos no eixo imaginário",
                                    "Confundir zeros com polos",
                                    "Simulações com tempo insuficiente"
                                  ]
                                }
                              ],
                              "practicalExample": "Para P(s) = 1/(s^2 + s + 1) (instável), fatoração coprima N(s)=1, D(s)=s^2+s+1. Bezout: X(s)=(s+2)/(s+1), Y(s)=(s^2+2s+3)/(s+1). C(s)=X/Y simplifica para estabilizante. Laço fechado T(s) tem polos em -1, -2 (estável). Simule step response no MATLAB.",
                              "finalVerifications": [
                                "Identidade de Bezout validada numericamente.",
                                "Controlador C(s) é próprio e central (Q=0).",
                                "Denominador do laço fechado é estável por construção.",
                                "Todos polos do laço fechado no semiplano esquerdo.",
                                "Simulação de resposta ao degrau converge ao valor final.",
                                "Diagrama de polos/zeros confirma ausência de instabilidades."
                              ],
                              "assessmentCriteria": [
                                "Precisão na construção de C(s) (sem erros algébricos).",
                                "Correta aplicação da identidade de Bezout.",
                                "Validação completa de estabilidade (polos + simulação).",
                                "Documentação clara de funções de transferência.",
                                "Eficiência temporal (dentro de estimados).",
                                "Identificação e correção de erros comuns."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Álgebra de polinômios e identidades diofantinas.",
                                "Programação: Manipulação simbólica e numérica (MATLAB/Python).",
                                "Física: Modelagem dinâmica de sistemas lineares.",
                                "Engenharia de Software: Validação e testes de controladores."
                              ],
                              "realWorldApplication": "Em automação industrial, como estabilizar um motor DC instável em um braço robótico, usando parametrização para sintetizar controladores robustos que garantem operação segura sem oscilações destrutivas."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "76.1.2.3"
                            ]
                          },
                          {
                            "id": "76.1.3.3",
                            "name": "Parametrizar família de estabilizadores",
                            "description": "Introduzir a parametrização de Youla-Kučera para SISO, mostrando que todo estabilizador é obtido variando Q ∈ RH∞ com ||Q||∞ < 1/||T||∞ para robustez básica.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Pré-requisitos: Identidade de Bezout e Fatoração Coprima",
                                  "subSteps": [
                                    "Relembrar a identidade de Bezout: para fatorizações coprimas N/M e X/Y de P e C0, NX + MY = 1.",
                                    "Verificar existência de estabilizadores usando fatoração coprima de direita e esquerda.",
                                    "Construir matriz de Bezout dupla para SISO: [[N, M], [-V, X]] com det = 1.",
                                    "Praticar com um exemplo simples de P(s) estável/instável.",
                                    "Confirmar que C0 estabiliza P via laço unitário."
                                  ],
                                  "verification": "Resolver um exercício onde você constrói a identidade de Bezout para um P(s) dado e verifica estabilidade.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Livro 'Feedback Control Theory' de Doyle ou 'Robust and Optimal Control' de Zhou",
                                    "MATLAB/Simulink para simulações",
                                    "Folha de exercícios sobre coprime factorization"
                                  ],
                                  "tips": "Sempre normalize as fatorizações para det(Bezout) = 1 para simplificar cálculos.",
                                  "learningObjective": "Compreender as bases algébricas para a parametrização de estabilizadores.",
                                  "commonMistakes": [
                                    "Confundir fatoração de direita com esquerda",
                                    "Esquecer normalização da Bezout",
                                    "Ignorar estabilidade de N, M em RH∞"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Introduzir Parametrização de Youla-Kučera para SISO",
                                  "subSteps": [
                                    "Derivar a forma geral: C(Q) = (X + D Q)(Y + N Q)^{-1}, onde Q ∈ RH∞.",
                                    "Explicar que todos os estabilizadores são obtidos variando Q estável.",
                                    "Verificar que para Q=0, recupera C0.",
                                    "Demonstrar estabilidade do laço fechado para qualquer Q ∈ RH∞.",
                                    "Simular em MATLAB o diagrama de bloco com Q inserido."
                                  ],
                                  "verification": "Implementar C(Q) em MATLAB para Q=0 e Q constante, plotar respostas ao degrau e confirmar estabilidade.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Acesso a MATLAB Control System Toolbox",
                                    "Notas de aula sobre Youla parametrization",
                                    "Exemplo numérico de P(s) = 1/(s^2 + s + 1)"
                                  ],
                                  "tips": "Use a forma de Youla para evitar inversões numéricas instáveis; prefira simulações simbólicas iniciais.",
                                  "learningObjective": "Dominar a fórmula parametrizada e sua interpretação em diagramas de bloco.",
                                  "commonMistakes": [
                                    "Esquecer que Q deve ser em RH∞",
                                    "Invertar (Y + N Q) sem verificar invertibilidade",
                                    "Confundir D com numerador de C0"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Gerar e Explorar a Família de Estabilizadores",
                                  "subSteps": [
                                    "Variar Q como constantes, delays ou filtros low-pass em RH∞.",
                                    "Calcular ganho de fase e magnitude de C(Q) para diferentes Q.",
                                    "Analisar sensibilidade S = (I + P C)^{-1} em função de Q.",
                                    "Plotar Nyquist de T = P C (I + P C)^{-1} para múltiplos Q.",
                                    "Comparar desempenho (overshoot, settling time) via simulações."
                                  ],
                                  "verification": "Gerar 3 estabilizadores diferentes variando Q e comparar step responses em um gráfico único.",
                                  "estimatedTime": "2.5 horas",
                                  "materials": [
                                    "MATLAB com rlocus e nyquist",
                                    "Tabela de Q candidatos: Q=0, Q=0.5/(s+1), Q=0.1 e^{-s}"
                                  ],
                                  "tips": "Comece com Q pequenos para manter estabilidade; use bodeplot para insights rápidos.",
                                  "learningObjective": "Explorar como Q parametrizar todo o conjunto de estabilizadores.",
                                  "commonMistakes": [
                                    "Escolher Q não estável",
                                    "Ignorar singularidades em Y + N Q",
                                    "Não normalizar ganhos de Q"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Incorporar Robustez Básica via Limite de Norma Infinita",
                                  "subSteps": [
                                    "Introduzir ||Q||∞ < 1/||T||∞ onde T é o complementar de sensibilidade nominal.",
                                    "Calcular ||T||∞ para o par nominal P C0.",
                                    "Restringir Q para garantir robustez a perturbações ΔP com ||ΔP||∞ < 1/||T||∞.",
                                    "Verificar robustez simulando P + ΔP com ΔP = 0.1 P.",
                                    "Discutir trade-offs: Q pequeno para robustez, Q otimizado para performance."
                                  ],
                                  "verification": "Computar limite superior para ||Q||∞ e testar com Q no limite; confirmar estabilidade para ΔP = 0.9 / ||T||∞ * P.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Função norm de MATLAB para H∞",
                                    "Exemplo com P nominal instável como 1/(s-1)",
                                    "Artigos sobre robust control basics"
                                  ],
                                  "tips": "Use hinfnorm() no MATLAB para calcular normas exatas; evite aproximações discretas iniciais.",
                                  "learningObjective": "Aplicar restrições de norma para robustez na parametrização.",
                                  "commonMistakes": [
                                    "Confundir ||Q||∞ com ||q||∞ em tempo discreto",
                                    "Subestimar ||T||∞ ignorando picos",
                                    "Não testar com perturbações reais"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Síntese e Verificação Final da Parametrização",
                                  "subSteps": [
                                    "Sintetizar C(Q) completo para um P dado com robustez.",
                                    "Validar todos os C(Q) estabilizam P via root locus ou Routh-Hurwitz.",
                                    "Analisar impacto de Q em margens de ganho/fase.",
                                    "Documentar família em relatório com plots.",
                                    "Explorar extensões para MIMO brevemente."
                                  ],
                                  "verification": "Produzir um relatório com 2 C(Q) robustos e suas análises de estabilidade/performance.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Template de relatório LaTeX ou Word",
                                    "MATLAB scripts consolidados"
                                  ],
                                  "tips": "Automatize plots com loops em Q para eficiência.",
                                  "learningObjective": "Integrar a parametrização em um workflow completo de design.",
                                  "commonMistakes": [
                                    "Não verificar invertibilidade final",
                                    "Overfitting Q sem robustez",
                                    "Ignorar computacionalidade em simulações"
                                  ]
                                }
                              ],
                              "practicalExample": "Para P(s) = 1/(s-1) (instável), encontre C0(s) = (s+2)/(s+0.5), compute Bezout, então gere C(Q) com Q(s) = 0.2/(s+1), restrinja ||Q||∞ < 1/||T0||∞ ≈ 1.5, simule step response para P + 0.1P e confirme estabilidade com margem.",
                              "finalVerifications": [
                                "Derivar corretamente C(Q) a partir de Bezout para um P dado.",
                                "Gerar pelo menos 3 estabilizadores variando Q ∈ RH∞.",
                                "Calcular ||T||∞ e impor ||Q||∞ < 1/||T||∞ corretamente.",
                                "Simular e plotar respostas para nominal e perturbado, confirmando robustez.",
                                "Explicar verbalmente por que todo estabilizador é capturado por Q.",
                                "Identificar Q=0 como caso nominal."
                              ],
                              "assessmentCriteria": [
                                "Precisão na derivação da parametrização (fórmula exata).",
                                "Correção das normas H∞ e limites de robustez.",
                                "Qualidade das simulações (plots claros, múltiplos Q testados).",
                                "Compreensão conceitual (explicação de Youla-Kučera).",
                                "Aplicação prática (exemplo funcional com robustez demonstrada).",
                                "Identificação de erros comuns e trade-offs."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Espaços de Hardy (RH∞) e normas H∞.",
                                "Programação: Implementação em MATLAB/Simulink para controle digital.",
                                "Física: Modelagem de plantas SISO em processos industriais.",
                                "Otimização: Escolha de Q via H∞ synthesis ou LMI.",
                                "Eletrônica: Implementação de C(Q) em hardware FPGA."
                              ],
                              "realWorldApplication": "Em automação industrial, parametrizar controladores para reatores químicos instáveis, permitindo retuning robusto ante variações de parâmetros (ex: temperatura), garantindo estabilidade em plantas da Petrobras ou indústrias farmacêuticas."
                            },
                            "estimatedTime": "0.75 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "76.1.3.1"
                            ]
                          },
                          {
                            "id": "76.1.3.4",
                            "name": "Verificar estabilidade via Bezout",
                            "description": "Dado P e C parametrizado, usar a identidade para provar que todas as funções de transferência fechadas são estáveis.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a Identidade de Bézout no Contexto de Controle",
                                  "subSteps": [
                                    "Revise a definição de fatoração coprima de uma planta P em fatores N e D bezoutianos estáveis.",
                                    "Estude a equação de Bézout: X N + Y D = 1, onde X e Y são bezoutianos estáveis.",
                                    "Identifique como isso garante a existência de controladores estabilizadores parametrizados.",
                                    "Analise o parametrizador de Youla: C = (X + D Q)(Y - N Q)^{-1} para Q estável.",
                                    "Discuta as funções de transferência fechadas: T = P C (1 + P C)^{-1}, etc."
                                  ],
                                  "verification": "Explique verbalmente ou por escrito como a identidade implica estabilidade fechada.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Livro de controle avançado (e.g., Zhou 'Robust Control'), notas de aula sobre Youla parametrization",
                                    "Software MATLAB para visualização de polos"
                                  ],
                                  "tips": "Comece com exemplos simples de plantas SISO para intuitivamente entender a coprimidade.",
                                  "learningObjective": "Entender o papel fundamental da identidade de Bézout na estabilização.",
                                  "commonMistakes": [
                                    "Confundir fatores bezoutianos com fatoração padrão",
                                    "Ignorar a estabilidade dos bezoutianos X e Y"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Realizar Fatoração Coprima da Planta P",
                                  "subSteps": [
                                    "Dada P(s), compute uma fatoração coprima N(s)/D(s) em anéis de Hardy H_infty ou Rh.",
                                    "Verifique a coprimidade usando o índice de McMillan ou testando bezoutianos.",
                                    "Encontre bezoutianos X e Y resolvendo X N + Y D = 1 via extensão euclidiana ou métodos numéricos.",
                                    "Confirme que N, D, X, Y são todos estáveis (polos no semiplano esquerdo).",
                                    "Documente a fatoração em forma simbólica ou numérica."
                                  ],
                                  "verification": "Mostre que X N + Y D = 1 computacionalmente em MATLAB/Simulink.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "MATLAB com Control System Toolbox",
                                    "Wolfram Alpha para fatoração simbólica"
                                  ],
                                  "tips": "Use normalização para |N|_infty <=1 e |D|_infty <=1 para simplificar.",
                                  "learningObjective": "Dominar a construção de fatorizações coprimas bezoutianas.",
                                  "commonMistakes": [
                                    "Escolher fatores não estáveis",
                                    "Falhar na verificação de coprimidade"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Parametrizar o Controlador C e Derivar Funções de Transferência Fechadas",
                                  "subSteps": [
                                    "Escolha um parâmetro Q estável estável com norma <1/gama para estabilidade.",
                                    "Construa C = (X + D Q)(Y - N Q)^{-1}.",
                                    "Calcule as FT fechadas: S = (Y - N Q), T = N (X + D Q), etc.",
                                    "Expresse as FT em termos da identidade de Bézout para mostrar fatoração estável.",
                                    "Verifique invertibilidade de (Y - N Q) pela máxima princípio."
                                  ],
                                  "verification": "Implemente em MATLAB e plote respostas em frequência para confirmar estabilidade.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "MATLAB/Simulink para simulação",
                                    "Papel e lápis para derivações simbólicas"
                                  ],
                                  "tips": "Comece com Q=0 para recuperar o controlador central Q=0.",
                                  "learningObjective": "Aplicar parametrizador de Youla para gerar família de estabilizadores.",
                                  "commonMistakes": [
                                    "Esquecer a invertibilidade de Y - N Q",
                                    "Não garantir ||Q|| < 1/||N||"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Provar Estabilidade das Funções de Transferência Fechadas",
                                  "subSteps": [
                                    "Use a identidade X N + Y D = 1 para fatorar numerador e denominador das FT.",
                                    "Mostre que todas as FT fechadas (S, T, CS, etc.) são produtos de fatores estáveis.",
                                    "Argumente que como N,D,X,Y,Q estáveis e Y-NQ invertível estável, todas são estáveis.",
                                    "Verifique numericamente os polos ou use critério de Nyquist/Mimo para confirmação.",
                                    "Generalize para o conjunto completo de C parametrizados."
                                  ],
                                  "verification": "Escreva uma prova formal de 1 página e valide com simulação.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Folha de papel para prova",
                                    "MATLAB pole() para checar polos"
                                  ],
                                  "tips": "Lembre-se: estabilidade segue diretamente da bezoutiana dupla estabilidade.",
                                  "learningObjective": "Provar rigorosamente estabilidade usando teoria bezoutiana.",
                                  "commonMistakes": [
                                    "Não fatorar corretamente as FT",
                                    "Ignorar estabilidade de Q"
                                  ]
                                }
                              ],
                              "practicalExample": "Para P(s) = 1/(s^2 - s + 1), fatorize como N/D com N=1/(s+2), D=(s^2 - s +1)/(s+2). Encontre X,Y bezoutianos. Escolha Q=0.1/(s+1), construa C, compute T(s) = P C /(1+P C) e mostre todos polos em Re(s)<0 via MATLAB.",
                              "finalVerifications": [
                                "Pode fatorar coprimamente uma P instável?",
                                "Resolve corretamente X N + Y D =1?",
                                "Parametriza C para Q arbitrário estável?",
                                "Deriva todas 4 FT fechadas principais?",
                                "Prova estabilidade sem simulação?",
                                "Valida com exemplo numérico em software?"
                              ],
                              "assessmentCriteria": [
                                "Precisão na fatoração coprima (100% verificación bezoutiana)",
                                "Correção na parametrizacão de C (invertibilidade garantida)",
                                "Prova formal completa de estabilidade (lógica impecável)",
                                "Exemplo prático funcional com simulação",
                                "Generalização para família de controladores",
                                "Clareza na documentação e derivações"
                              ],
                              "crossCurricularConnections": [
                                "Álgebra Linear: Extensão euclidiana em anéis de funções racionais",
                                "Análise Complexa: Estabilidade via semiplano esquerdo e Hardy spaces",
                                "Programação Numérica: Implementação em MATLAB para Rhp/infty",
                                "Física de Sistemas: Modelagem dinâmica de plantas industriais",
                                "Otimização: Escolha de Q para robustez H-infty"
                              ],
                              "realWorldApplication": "Em design de controladores para aviões (e.g., estabilização de flight control systems da Boeing), onde P é instável, usa-se Bézout/Youla para parametrizar todos estabilizadores robustos a variações paramétricas, garantindo segurança em tempo real."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "76.1.3.2"
                            ]
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.4.3",
                    "name": "Parametrização de Youla-Kučera",
                    "description": "Método para descrever todos os controladores estabilizadores via parâmetro Q estável.",
                    "individualConcepts": [
                      {
                        "id": "76.6.4.4.1",
                        "name": "Fatores Coprimos Estáveis",
                        "description": "Entender a decomposição do modelo de planta em fatores coprimos estáveis (left e right coprime factorization - LCF/RCF) como base para a parametrização.",
                        "specificSkills": [
                          {
                            "id": "76.6.4.4.1.1",
                            "name": "Realizar Fatoração Coprima Direita (RCF)",
                            "description": "Dado um modelo de planta P(s) estável ou instável, computar a fatoração coprima direita N(s)M^{-1}(s) onde N e M são estáveis e coprimos, usando métodos como o de Silverman ou estado-espaço.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Obter e validar a realização em espaço de estados da planta P(s)",
                                  "subSteps": [
                                    "Converta a função de transferência P(s) para uma realização em espaço de estados mínima usando métodos como 'tf2ss' no MATLAB ou cálculo manual para sistemas de baixa ordem.",
                                    "Verifique a minimalidade da realização computando os índices de controllabilidade e observabilidade.",
                                    "Confirme as dimensões: A (n x n), B (n x m), C (p x n), D (p x m), onde n é a ordem do sistema.",
                                    "Analise a estabilidade inicial de P(s) plotando polos ou computando autovalores de A.",
                                    "Documente os parâmetros A, B, C, D para uso posterior."
                                  ],
                                  "verification": "Realização é mínima se rank do observability gramian e controllability gramian for n; polos corretos coincidem com os de P(s).",
                                  "estimatedTime": "45 minutos",
                                  "materials": "MATLAB/Octave com Control System Toolbox, papel e calculadora para exemplos simples.",
                                  "tips": "Para SISO monovariável, use funções prontas como ss(tf(P)) para simplicidade.",
                                  "learningObjective": "Dominar a representação em espaço de estados e suas propriedades fundamentais para análise de sistemas.",
                                  "commonMistakes": "Usar realizações não mínimas levando a fatores não coprimos; ignorar D em funções impróprias."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Projetar o ganho de realimentação de estado F para estabilizar o sistema",
                                  "subSteps": [
                                    "Verifique a controlabilidade da dupla (A, B) computando a matriz de controllability e seu rank.",
                                    "Escolha polos desejados estáveis (parte real negativa) para o sistema fechado.",
                                    "Calcule F usando colocação de polos (acker ou place no MATLAB) tal que autovalores de A + B F sejam os polos escolhidos.",
                                    "Valide a estabilidade simulando ou computando autovalores de A + B F.",
                                    "Ajuste F se necessário usando métodos ótimos como LQR para robustez."
                                  ],
                                  "verification": "Todos autovalores de A + B F têm parte real < 0; resposta simulada ao degrau é estável.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "MATLAB com funções place/acker/lqr, simulador de sistemas lineares.",
                                  "tips": "Escolha polos 2-3 vezes mais rápidos que os originais para boa margem.",
                                  "learningObjective": "Aprender a estabilizar sistemas lineares via realimentação de estado e colocação de polos.",
                                  "commonMistakes": "Não verificar controlabilidade levando a F inexistente; polos mal escolhidos causando oscilações."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Construir as realizações em espaço de estados para os fatores N(s) e M(s)",
                                  "subSteps": [
                                    "Defina ṀA = A + B F (matriz estável comum).",
                                    "Construa N(s) com matrizes: (ṀA, B, C, D).",
                                    "Construa M(s) com matrizes: (ṀA, B, F, 1) para SISO (ou I para MIMO).",
                                    "Confirme que ambas as realizações compartilham o mesmo ṀA estável.",
                                    "Salve os modelos como objetos ss no MATLAB para uso posterior."
                                  ],
                                  "verification": "Ambos modelos têm a mesma matriz A estável; dimensões corretas para right factorization.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "MATLAB Control System Toolbox (ss, tf2ss).",
                                  "tips": "Use D=0 se P própria; generalize para D≠0 mantendo consistência.",
                                  "learningObjective": "Entender como as realizações state-space garantem estabilidade nos fatores coprimos.",
                                  "commonMistakes": "Erro no D de M(s) (deve ser 1, não D); inverter C e F nas matrizes de saída."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Extrair funções de transferência, verificar fatoração e coprimidade",
                                  "subSteps": [
                                    "Converta os modelos ss de N e M para tf usando tf() e minreal() para cancelamentos.",
                                    "Compute P_verif = N / M e compare com P original (erro < 1e-6).",
                                    "Verifique estabilidade: polos de N e M todos com Re < 0.",
                                    "Confirme coprimidade: para SISO, gcd(num_N*den_M, den_N*num_M)=1; ou verifique existência de Bézout.",
                                    "Opcional: encontre U,V estáveis tal que U N + V M =1."
                                  ],
                                  "verification": "P_verif == P, polos estáveis em N e M, grau mínimo sem cancelamentos desnecessários.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "MATLAB (tf, minreal, pole, feedback).",
                                  "tips": "Use feedback(N, M, +1) para verificar se retorna P.",
                                  "learningObjective": "Validar matematicamente a RCF e suas propriedades essenciais.",
                                  "commonMistakes": "Ignorar cancelamentos levando a fatores não mínimos; não normalizar para monic denominators."
                                }
                              ],
                              "practicalExample": "Para P(s) = 1/(s-2) instável: Realização A=[2], B=[1], C=[1], D=[0]. Escolha F=[-4], ṀA=[-2]. Então N(s) ~ (-2,1,1,0) → N(s)=1/(s+2); M(s) ~ (-2,1,-4,1) → M(s)=(s-2)/(s+2). Verifique: N/M = 1/(s-2)=P, ambos estáveis.",
                              "finalVerifications": [
                                "N(s)M^{-1}(s) = P(s) com erro numérico desprezível.",
                                "Todos polos de N(s) e M(s) têm parte real negativa.",
                                "Realizações mínimas sem cancelamentos polares excessivos.",
                                "Coprimidade confirmada por identidade de Bézout ou gcd=1.",
                                "Fatores próprios e biproprios se aplicável.",
                                "Simulação do sistema fechado com F é estável."
                              ],
                              "assessmentCriteria": [
                                "Precisão na computação de F (autovalores corretos).",
                                "Corretude das realizações state-space para N e M.",
                                "Validação exata de P = N M^{-1}.",
                                "Identificação correta de estabilidade e coprimidade.",
                                "Eficiência computacional (uso de ferramentas apropriadas).",
                                "Documentação clara dos passos e resultados."
                              ],
                              "crossCurricularConnections": [
                                "Álgebra Linear: Autovalores, controllability gramian, colocação de polos.",
                                "Programação Numérica: Uso de MATLAB/Octave para modelagem e simulação.",
                                "Matemática Aplicada: Teoria de sistemas lineares invariantes no tempo.",
                                "Otimização: LQR para design robusto de F."
                              ],
                              "realWorldApplication": "Na parametrização de Youla-Kučera para design de controladores estabilizadores robustos em processos industriais como motores, aviões ou plantas químicas, permitindo sintetizar todos os controladores estabilizantes a partir de uma RCF estável."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "76.6.4.4.1.2",
                            "name": "Realizar Fatoração Coprima Esquerda (LCF)",
                            "description": "Computar a fatoração coprima esquerda \tilde{M}^{-1}(s)\tilde{N}(s) para o mesmo modelo P(s), garantindo Bezout identity com funções estáveis X e Y.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar e Normalizar a Representação de P(s)",
                                  "subSteps": [
                                    "Escreva P(s) como uma fração própria N_p(s)/D_p(s), onde N_p e D_p são coprimos.",
                                    "Normalize a fração para que seja biproper: lim_{s->∞} P(s) = 1 e lim_{s->0} P(s) finito.",
                                    "Verifique a realizabilidade mínima do modelo usando ordem de McMillan ou diagramas de pólo-zero.",
                                    "Identifique os pólos instáveis de P(s) para planejamento da estabilização.",
                                    "Documente os coeficientes polinomiais ou estados espaciais equivalentes."
                                  ],
                                  "verification": "Confirme que det([N_p D_p]) = 1 (ou constante unimodular) e que a fração é mínima via algoritmo de Euclides.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Papel e lápis ou MATLAB/Simulink para simbólico",
                                    "Livro: 'Feedback Control Theory' de Doyle et al.",
                                    "Control System Toolbox"
                                  ],
                                  "tips": "Use expansão em frações parciais para simplificar; sempre verifique bipropriedade multiplicando por constantes.",
                                  "learningObjective": "Entender a representação canônica de sistemas lineares para fatorações coprimas.",
                                  "commonMistakes": [
                                    "Esquecer normalização biproper",
                                    "Não verificar coprimidade inicial",
                                    "Confundir pólos com zeros"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Computar Fatoração Coprima Inicial (Não-Estável)",
                                  "subSteps": [
                                    "Aplique o algoritmo de Euclides estendido para encontrar bezoutians U(s), V(s) tais que U N_p - V D_p = 1.",
                                    "Defina fatores iniciais: \\tilde{N}_0(s) = U(s)^{-1} N_p(s), \\tilde{M}_0(s) = U(s)^{-1} D_p(s).",
                                    "Verifique P(s) = \\tilde{M}_0^{-1} \\tilde{N}_0.",
                                    "Extraia os fatores instáveis de \\tilde{N}_0 e \\tilde{M}_0 (polos fora do semiplano esquerdo).",
                                    "Registre os fatores all-pass necessários para estabilização."
                                  ],
                                  "verification": "Teste se \\tilde{M}_0^{-1} \\tilde{N}_0 = P(s) algebricamente ou numericamente em pontos de teste.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "MATLAB Symbolic Math Toolbox",
                                    "Software como Mathematica para polinômios",
                                    "Folhas de cálculo para Euclides"
                                  ],
                                  "tips": "Implemente o algoritmo de Euclides em loop para graus altos; prefira representações matriciais para MIMO.",
                                  "learningObjective": "Dominar o algoritmo de bezout para coprimidade em anéis de polinômios.",
                                  "commonMistakes": [
                                    "Erro no sinal da identidade de Bezout",
                                    "Não inverter corretamente U(s)",
                                    "Ignorar graus não mínimos"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Estabilizar os Fatores Coprimos",
                                  "subSteps": [
                                    "Identifique os fatores all-pass blaschke produtos para pólos instáveis: F_N(s) e F_M(s).",
                                    "Defina \\tilde{N}(s) = F_N(s) \\tilde{N}_0(s), \\tilde{M}(s) = F_M(s) \\tilde{M}_0(s).",
                                    "Ajuste para manter coprimidade: resolva para novos X, Y estáveis satisfazendo X \\tilde{N} - Y \\tilde{M} = I.",
                                    "Use iteração de Youla ou Lyapunov para encontrar X, Y se necessário.",
                                    "Confirme estabilidade: todos pólos em Re(s) < 0 usando Routh-Hurwitz."
                                  ],
                                  "verification": "Avalie normas H∞ de \\tilde{N}, \\tilde{M}, X, Y < ∞ e pólos estáveis.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "MATLAB Robust Control Toolbox (sisotool, norm)",
                                    "'Essentials of Robust Control' de Zhou",
                                    "Python Control Systems Library"
                                  ],
                                  "tips": "Para sistemas discretos, use disco unitário; teste com simulações de Bode para estabilidade.",
                                  "learningObjective": "Aplicar fatores all-pass para estabilização preservando coprimidade.",
                                  "commonMistakes": [
                                    "Fatores all-pass incorretos (não unitários)",
                                    "Perder coprimidade pós-estabilização",
                                    "Não atualizar Bezoutians"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificar Fatoração Final e Identidade de Bezout",
                                  "subSteps": [
                                    "Compute explicitamente \\tilde{M}^{-1}(s) \\tilde{N}(s) e compare com P(s).",
                                    "Resolva o sistema de Bezout: encontre X, Y estáveis via convolução ou estados espaciais.",
                                    "Verifique numericamente em frequências chave e simule resposta em malha aberta.",
                                    "Confirme invertibilidade de \\tilde{M} na esfera de Riemann (H∞ invertível).",
                                    "Documente todos os fatores e gere relatório com plots."
                                  ],
                                  "verification": "X \\tilde{N} - Y \\tilde{M} = I exata e todos fatores estáveis via análise de pólos.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Simulink para simulação",
                                    "Gráficos de Nyquist/Bode",
                                    "Relatório LaTeX template"
                                  ],
                                  "tips": "Use validação cruzada com RCF para consistência; automatize com scripts MATLAB.",
                                  "learningObjective": "Validar rigorosamente a LCF para uso em parametrização de controladores.",
                                  "commonMistakes": [
                                    "Verificação apenas pontual sem identidade global",
                                    "Esquecer estabilidade de X,Y",
                                    "Erro numérico em simulações"
                                  ]
                                }
                              ],
                              "practicalExample": "Para P(s) = (s-1)/((s+1)(s+2)), normalize biproper. Fatoração inicial leva a pólos instáveis; aplique Blaschke F(s) = (s-1)/(s+1) para estabilizar, resultando em \\tilde{N}(s) = 1/(s+2), \\tilde{M}(s) = 1/(s+1), com X=1, Y=0 satisfazendo Bezout.",
                              "finalVerifications": [
                                "\\tilde{M}^{-1} \\tilde{N} = P(s) identicamente",
                                "Existência de X, Y estáveis com X \\tilde{N} - Y \\tilde{M} = I",
                                "Todos pólos de \\tilde{N}, \\tilde{M}, X, Y no semiplano esquerdo",
                                "Coprimidade confirmada por det([\\tilde{N} \\tilde{M}]) unimodular",
                                "Norma H∞ finita para todos fatores",
                                "Simulação em malha aberta matches P(s)"
                              ],
                              "assessmentCriteria": [
                                "Precisão algébrica da fatoração (erro < 1e-6)",
                                "Correta identificação e estabilização de pólos instáveis",
                                "Validade da identidade de Bezout com fatores estáveis",
                                "Eficiência computacional (graus mínimos preservados)",
                                "Documentação clara com verificações numéricas",
                                "Tratamento de casos edge (pólos em imaginário)"
                              ],
                              "crossCurricularConnections": [
                                "Álgebra Linear: Soluções de Sylvester para Bezout",
                                "Programação Numérica: Implementação em MATLAB/Python para automação",
                                "Física: Modelagem de sistemas dinâmicos instáveis (ex: inverso de pêndulo)",
                                "Otimização: Minimização de normas H∞ nos fatores",
                                "Processamento de Sinais: Filtros all-pass em DSP"
                              ],
                              "realWorldApplication": "Usado em design de controladores robustos via Youla-Kučera para sistemas aeroespaciais instáveis, como estabilização de aeronaves com centros de gravidade variáveis, permitindo todos os controladores Q estáveis."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "76.6.4.4.1.1"
                            ]
                          },
                          {
                            "id": "76.6.4.4.1.3",
                            "name": "Verificar Identidade de Bezout",
                            "description": "Confirmar que existem X e Y estáveis tais que \tilde{M}M - \tilde{N}N = I, essencial para a existência de controladores estabilizadores.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar e Normalizar os Fatores Coprimos M e N",
                                  "subSteps": [
                                    "Identifique os fatores M(s) e N(s) do sistema dado no contexto da parametrização de Youla-Kučera.",
                                    "Normalize M e N para que sejam próprios e estáveis, com denominador comum D(s) onde numeradores são coprimos.",
                                    "Verifique as pólos de M e N para confirmar estabilidade (raízes de Hurwitz).",
                                    "Registre as expressões racionais de M(s) e N(s) em forma de fração irredutível.",
                                    "Documente qualquer pré-condição assumida, como normalização unimodular."
                                  ],
                                  "verification": "Confirme que M e N estão em forma normalizada e estáveis plotando polos ou usando Routh-Hurwitz.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Software MATLAB/Simulink ou Python (Control library)",
                                    "Papel e calculadora para polinômios manuais"
                                  ],
                                  "tips": "Sempre fatorize numeradores e denominadores para visualizar coprimidade.",
                                  "learningObjective": "Compreender a representação normalizada de fatores coprimos estáveis.",
                                  "commonMistakes": "Ignorar normalização própria, levando a bezoutianos instáveis."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Confirmar Coprimidade via Algoritmo Euclidiano Estendido",
                                  "subSteps": [
                                    "Aplique o algoritmo euclidiano aos numeradores de M e N para verificar MDC=1.",
                                    "Use a extensão euclidiana para encontrar coeficientes u(s), v(s) tais que u Num_M + v Num_N = 1.",
                                    "Construa bezoutianos iniciais X0 = u/D, Y0 = -v/D, onde D é denominador comum.",
                                    "Verifique se X0 e Y0 satisfazem X0 M - Y0 N = I aproximadamente.",
                                    "Ajuste para estabilidade se necessário, confirmando que resíduos são zero."
                                  ],
                                  "verification": "O resultado do euclidiano deve dar MDC=1 e identidade unitária.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "MATLAB Symbolic Toolbox ou SymPy para manipulação polinomial",
                                    "Folha de cálculo para divisões polinomiais"
                                  ],
                                  "tips": "Implemente função recursiva para euclidiano em código para automação.",
                                  "learningObjective": "Dominar o algoritmo euclidiano estendido em funções de transferência.",
                                  "commonMistakes": "Confundir sinal na identidade (deve ser X M - Y N = I)."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Construir e Estabilizar Bezoutianos X e Y",
                                  "subSteps": [
                                    "Estenda bezoutianos para serem estáveis resolvendo para alvos Hurwitz.",
                                    "Use iteração ou método de Youla para refinar X = X0 + M Q, Y = Y0 + N Q com Q estável.",
                                    "Para SISO, resolva diretamente equação de Bézout em domínio de Laplace.",
                                    "Teste estabilidade de X e Y via critérios de Routh ou Nyquist.",
                                    "Itere Q até que X e Y sejam mínimos em fase ou estáveis."
                                  ],
                                  "verification": "Pole(X) e Pole(Y) devem ter partes reais negativas.",
                                  "estimatedTime": "75 minutos",
                                  "materials": [
                                    "MATLAB Control System Toolbox para rlocus ou nyquist",
                                    "Documentação de Youla-Kučera"
                                  ],
                                  "tips": "Comece com Q=0 e verifique; ajuste Q baixo grau para simplicidade.",
                                  "learningObjective": "Aplicar parametrização para garantir estabilidade de bezoutianos.",
                                  "commonMistakes": "Escolher Q instável, propagando instabilidade."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificar a Identidade de Bézout e Conclusão",
                                  "subSteps": [
                                    "Compute explicitamente \tilde{M} M - \tilde{N} N e simplifique.",
                                    "Confirme que resulta em I (identidade, 1 em SISO).",
                                    "Valide numericamente em pontos de frequência ou simulação temporal.",
                                    "Documente X e Y finais e sua estabilidade.",
                                    "Registre prova formal ou simulação de fechamento para estabilização."
                                  ],
                                  "verification": "Simplificação algébrica ou simulação deve dar exatamente I.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "MATLAB para simplify() ou evalfr()",
                                    "Gráficos de Bode para validação"
                                  ],
                                  "tips": "Use cancelamento de pólos/numeradores para verificação rápida.",
                                  "learningObjective": "Validar identidade de Bézout como base para controladores.",
                                  "commonMistakes": "Erros de sinal ou não simplificar frações completamente."
                                }
                              ],
                              "practicalExample": "Para M(s) = (s+2)/((s+1)(s+3)), N(s) = 1/((s+1)(s+3)), aplique euclidiano em num_M=s+2, num_N=1: MDC=1. Bezoutianos: X(s)=1, Y(s)=(s+1)/((s+1)(s+3)) ajustado para estável. Verifique: X M - Y N = [1*(s+2) - (s+1)*1]/denom = (s+2 - s -1)/denom = 1/denom * denom = I.",
                              "finalVerifications": [
                                "X e Y são estáveis (pólos Hurwitz).",
                                "\tilde{M} M - \tilde{N} N = I exatamente após simplificação.",
                                "Coprimidade confirmada por MDC(num_M, num_N)=1.",
                                "Simulação de controlador Q=0 estabiliza planta.",
                                "Gráficos de Bode mostram margem infinita em crossover.",
                                "Validação numérica em 10+ pontos de ω coincide com I."
                              ],
                              "assessmentCriteria": [
                                "Preparação correta de M/N: 20%",
                                "Coprimidade via euclidiano precisa: 25%",
                                "Bezoutianos estáveis construídos: 25%",
                                "Verificação da identidade exata: 20%",
                                "Documentação e estabilidade comprovada: 10%"
                              ],
                              "crossCurricularConnections": [
                                "Álgebra Linear: Analogia com identidade de Bézout em módulos.",
                                "Teoria dos Números: Algoritmo euclidiano estendido para polinômios.",
                                "Matemática Computacional: Manipulação simbólica em CAS.",
                                "Sistemas Dinâmicos: Estabilidade via critérios de Routh-Hurwitz."
                              ],
                              "realWorldApplication": "Na engenharia de controle aeroespacial, verifica se fatores coprimos de um modelo de míssil permitem parametrizar todos controladores estabilizadores via Youla, garantindo robustez contra perturbações em voo."
                            },
                            "estimatedTime": "0.5 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "76.6.4.4.1.1"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "76.6.4.4.2",
                        "name": "Parametrização do Conjunto de Controladores Estabilizadores",
                        "description": "Derivação da forma geral de todos os controladores C(q) que estabilizam a planta via parâmetro Q estável.",
                        "specificSkills": [
                          {
                            "id": "76.6.4.4.2.1",
                            "name": "Derivar a Forma de Youla-Kučera",
                            "description": "A partir de um controlador nominal C_0 estabilizador, expressar C(q) = (Y - M Q)(\tilde{X} - \tilde{N} Q)^{-1} ou forma dupla, garantindo estabilidade para ||Q||_∞ <1 em casos robustos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Fundamentos de Fatorização Coprima e Identidade de Bézout",
                                  "subSteps": [
                                    "Defina fatorizações coprimas direita (RCP) e esquerda (LCP) para a planta G e controlador nominal C₀.",
                                    "Estabeleça a identidade de Bézout: encontre X, Y, M, N tais que X N - Y M = I.",
                                    "Verifique que C₀ estabiliza G, garantindo que as fatorizações sejam bezoutianas.",
                                    "Pratique com um exemplo simples de G(s) = 1/(s+1).",
                                    "Anote as representações normalizadas das fatorizações."
                                  ],
                                  "verification": "Construa as matrizes de dupla Bezout e confirme que o produto resulta na identidade.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Livro 'Robust and Optimal Control' de Zhou et al.",
                                    "Papel e caneta para cálculos simbólicos",
                                    "Software MATLAB/Simulink para validação numérica"
                                  ],
                                  "tips": "Use fatorizações bipropria para simplificar cálculos em sistemas discretos ou contínuos.",
                                  "learningObjective": "Compreender as bases algébricas para parametrização de controladores estabilizadores.",
                                  "commonMistakes": [
                                    "Confundir RCP com LCP",
                                    "Esquecer normalização das fatorizações",
                                    "Ignorar o anel de estabilidade (RH∞)"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Construir o Controlador Nominal C₀ e suas Fatorações Associadas",
                                  "subSteps": [
                                    "Escolha ou derive um C₀ estabilizador para G, usando métodos como PID ou LQG.",
                                    "Calcule as fatorações coprimas de C₀: C₀ = V⁻¹ U (RCP) e C₀ = Ũ Ṽ⁻¹ (LCP).",
                                    "Construa as matrizes de Youla: [V -U; N -M] e sua inversa dupla.",
                                    "Valide estabilidade interna usando o teorema de estabilização.",
                                    "Expresse C₀ na forma inicial de Youla com Q=0."
                                  ],
                                  "verification": "Simule o laço fechado com C₀ e confirme polos no semiplano esquerdo.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "MATLAB Control System Toolbox",
                                    "Folhas de exercícios com plantas de segunda ordem",
                                    "Referência: Capítulo 8 de Doyle et al. 'Feedback Control Theory'"
                                  ],
                                  "tips": "Comece com sistemas SISO monovariáveis para evitar complexidade matricial inicial.",
                                  "learningObjective": "Dominar a construção de fatorações para um estabilizador nominal.",
                                  "commonMistakes": [
                                    "Escolher C₀ instabilizador",
                                    "Erros em inversas de Bezout",
                                    "Misturar convenções de RCP/LCP"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Derivar a Forma Parametrizada de Youla-Kučera",
                                  "subSteps": [
                                    "Introduza o parâmetro Q estável e baixo-passagem: C(q) = (Y - M Q)(X̃ - Ñ Q)⁻¹.",
                                    "Prove que todos os C(q) estabilizam G derivando a dupla Bezout generalizada.",
                                    "Escreva a forma dupla alternativa: C(q) = (V - Q N)⁻¹ (U + Q M).",
                                    "Verifique independência de Q na estabilidade interna.",
                                    "Discuta a unicidade da parametrização."
                                  ],
                                  "verification": "Substitua Q arbitrário estável e confirme estabilidade do laço fechado.",
                                  "estimatedTime": "2.5 horas",
                                  "materials": [
                                    "Blackboard ou tablet para derivações simbólicas",
                                    "Script MATLAB para plotar Q admissíveis",
                                    "Artigo original de Youla (1976)"
                                  ],
                                  "tips": "Use diagramas de bloco para visualizar a inserção de Q no caminho de retorno.",
                                  "learningObjective": "Derivar analiticamente a família completa de controladores estabilizadores.",
                                  "commonMistakes": [
                                    "Esquecer invertibilidade de (X̃ - Ñ Q)",
                                    "Confundir formas left/right",
                                    "Assumir Q instável"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Garantir Estabilidade Robusta e Aplicar Condições de Norma",
                                  "subSteps": [
                                    "Analise o conjunto de plantas perturbadas: G = (N + Δ N) (D + Δ D)⁻¹ com ||Δ||_∞ < ε.",
                                    "Estabeleça a condição ||Q||_∞ < 1/γ para estabilidade robusta, onde γ é o gap de estabilidade.",
                                    "Otimize Q minimizando sensibilidade ou custo quadrático.",
                                    "Teste com perturbações: simule falhas e verifique estabilização.",
                                    "Documente a forma final C(Q) com restrições."
                                  ],
                                  "verification": "Use μ-síntese ou loop-shaping para validar robustez numérica.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "MATLAB Robust Control Toolbox",
                                    "Exemplos de plantas com incertezas (e.g., DC motor com variação de carga)",
                                    "Tutorial de Skogestad 'Multivariable Feedback Control'"
                                  ],
                                  "tips": "Escolha Q = K * (s/ω_c +1)^n para roll-off em altas frequências.",
                                  "learningObjective": "Aplicar parametrização em contextos robustos com limites de norma H∞.",
                                  "commonMistakes": [
                                    "Ignorar gap estrutural",
                                    "Usar ||Q||_∞ >1",
                                    "Negligenciar singularidades"
                                  ]
                                }
                              ],
                              "practicalExample": "Para G(s) = 1/(s² + s + 1), derive C₀(s) = (s+2)/(s+0.5). Calcule fatorações coprimas biproprias, encontre Bezout e expresse C(Q) = [Y - M Q][X̃ - Ñ Q]⁻¹. Teste com Q(s) = 0.5/(s+1), simulando resposta a degrau com ruído aditivo ΔN = 0.1 sin(ωt).",
                              "finalVerifications": [
                                "Escreve corretamente a forma de Youla-Kučera para um G dado.",
                                "Constrói matrizes Bezout sem erros algébricos.",
                                "Valida estabilidade para Q estável arbitrário via simulação.",
                                "Aplica condição ||Q||_∞ <1 em cenário robusto.",
                                "Explica unicidade da parametrização em termos de Q.",
                                "Deriva forma dupla independentemente."
                              ],
                              "assessmentCriteria": [
                                "Precisão na derivação simbólica (90% correto).",
                                "Correta identificação de RCP/LCP e Bezout.",
                                "Validação numérica de estabilidade (polos estáveis).",
                                "Tratamento adequado de robustez com normas H∞.",
                                "Clareza na explicação de passos intermediários.",
                                "Criatividade em escolha de Q para otimização."
                              ],
                              "crossCurricularConnections": [
                                "Álgebra Linear: Fatorizações coprimas e identidades matriciais.",
                                "Análise Funcional: Espaços de Hardy RH∞ e normas induzidas.",
                                "Otimização: Minimização H∞ via Q ótimo.",
                                "Processos Estocásticos: Integração com LQG para ruído.",
                                "Física Aplicada: Modelagem de plantas dinâmicas em automação."
                              ],
                              "realWorldApplication": "Em controle robusto de motores elétricos em veículos autônomos, onde perturbações como variação de carga são comuns; permite sintetizar bancos de controladores estabilizadores para falhas, usado em aeroespacial (NASA) e processos químicos (refinarias)."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "76.6.4.4.1.3"
                            ]
                          },
                          {
                            "id": "76.6.4.4.2.2",
                            "name": "Construir Controlador Nominal Estabilizador",
                            "description": "Usar métodos clássicos (como PID ou LQG) para obter C_0 inicial e computar X,Y via equações de Diophantine.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Projetar o Controlador Inicial C_0 Usando Métodos Clássicos",
                                  "subSteps": [
                                    "Selecionar o método apropriado (PID para sistemas simples ou LQG para ótimo em presença de ruído).",
                                    "Modelar a planta G(s) em espaço de estados ou função de transferência.",
                                    "Tunar os parâmetros do controlador (Kp, Ki, Kd para PID; matrizes Q e R para LQG).",
                                    "Simular a resposta em malha fechada para entrada degrau e ruído.",
                                    "Ajustar parâmetros iterativamente para atender especificações de desempenho (overshoot < 10%, tempo de estabilização < 5s)."
                                  ],
                                  "verification": "Simulação mostra resposta estável e com bom desempenho (sem oscilações divergentes).",
                                  "estimatedTime": "2-3 horas",
                                  "materials": [
                                    "Software MATLAB/Simulink",
                                    "Modelo da planta G(s)",
                                    "Documentação de PID/LQG"
                                  ],
                                  "tips": "Comece com PID para simplicidade; use auto-tune se disponível no software.",
                                  "learningObjective": "Compreender e aplicar métodos clássicos para obter um controlador estabilizador inicial.",
                                  "commonMistakes": [
                                    "Ignorar limites atuador",
                                    "Não considerar incertezas no modelo",
                                    "Tunar sem simulação"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Verificar Estabilidade do Sistema em Malha Fechada com C_0",
                                  "subSteps": [
                                    "Computar a função de transferência em malha fechada T(s) = C_0 G / (1 + C_0 G).",
                                    "Analisar critérios de estabilidade: polos no semiplano esquerdo, diagrama de Nyquist sem encirclement.",
                                    "Verificar robustez com margens de ganho e fase (>6dB e >45°).",
                                    "Testar sensibilidade a variações paramétricas (±20%).",
                                    "Documentar métricas de desempenho (ITAE, ISE)."
                                  ],
                                  "verification": "Todos polos têm parte real negativa e margens de estabilidade atendidas.",
                                  "estimatedTime": "1-2 horas",
                                  "materials": [
                                    "MATLAB Control System Toolbox",
                                    "Função de transferência G(s) e C_0(s)"
                                  ],
                                  "tips": "Use rlocus() ou nyquist() para visualização rápida.",
                                  "learningObjective": "Avaliar estabilidade e desempenho do par planta-controlador.",
                                  "commonMistakes": [
                                    "Confundir estabilidade com bom desempenho",
                                    "Não testar com ruído",
                                    "Esquecer normalização"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Realizar Fatorização Coprima Dupla da Planta G e Controlador C_0",
                                  "subSteps": [
                                    "Normalizar G = N/D e C_0 = X_0/Y_0 com fatorizações biproprias (unimodulares).",
                                    "Verificar coprimidade usando algoritmo de Euclides estendido para polinômios ou estados.",
                                    "Computar os bezoutians iniciais se necessário.",
                                    "Confirmar que N e D são estáveis ou instáveis adequadamente.",
                                    "Armazenar fatorizações em formato adequado para Diophantine."
                                  ],
                                  "verification": "N D^{-1} = G e X_0 Y_0^{-1} = C_0 com fatores biproprios.",
                                  "estimatedTime": "1-2 horas",
                                  "materials": [
                                    "MATLAB Robust Control Toolbox",
                                    "Funções coprime() ou gcd()"
                                  ],
                                  "tips": "Use normalize() para evitar numéricos; prefira espaço de estados para alta ordem.",
                                  "learningObjective": "Dominar fatorizações coprimas duplas essenciais para parametrização.",
                                  "commonMistakes": [
                                    "Fatorizações não biproprias",
                                    "Erro numérico em alta frequência",
                                    "Não verificar coprimidade"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Resolver Equações de Diophantine para Obter X e Y",
                                  "subSteps": [
                                    "Formular a equação de Bezout: X N - Y D = V (com V unimodular, ex: I).",
                                    "Aplicar algoritmo de Euclides estendido para resolver por X e Y.",
                                    "Para C_0 dado: resolver X N + Y D = C_0^{-1} ou forma equivalente na Youla.",
                                    "Verificar solução: computar X N - Y D e confirmar igualdade.",
                                    "Estabilizar soluções se necessário via feedback."
                                  ],
                                  "verification": "X N - Y D = V exato (erro < 1e-6) e Y estável.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "MATLAB Symbolic Toolbox ou diophantine solvers",
                                    "Fatorizações N,D"
                                  ],
                                  "tips": "Use polinômios discretos para simplicidade; resolva em z ou s-domínio.",
                                  "learningObjective": "Resolver equações de Diophantine para bezoutians na parametrização.",
                                  "commonMistakes": [
                                    "Sinal errado na equação",
                                    "Soluções não estáveis",
                                    "Não unimodular V"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Construir e Validar o Controlador Nominal Estabilizador",
                                  "subSteps": [
                                    "Construir C_0 = X Y^{-1} (ou forma Youla Q=0).",
                                    "Simular malha fechada com novo C_0 e comparar com inicial.",
                                    "Verificar todas as propriedades: estabilidade, desempenho idêntico.",
                                    "Exportar controlador para implementação.",
                                    "Documentar o processo completo."
                                  ],
                                  "verification": "Resposta em simulação idêntica à de C_0 inicial e estável.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Simulink para validação",
                                    "Código MATLAB"
                                  ],
                                  "tips": "Teste com perturbações para robustez.",
                                  "learningObjective": "Integrar todos os elementos para um controlador nominal pronto.",
                                  "commonMistakes": [
                                    "Inversão errada Y^{-1}",
                                    "Perda de estabilidade na reconstrução",
                                    "Não comparar"
                                  ]
                                }
                              ],
                              "practicalExample": "Para um motor DC com G(s) = 1/(s(s+1)), projete PID C_0(s) = Kp + Ki/s + Kd s tunado para overshoot 5%. Verifique estabilidade (polos em -2±j1). Fatore G = N/D coprime, resolva X N - Y D = 1 obtendo X=1, Y=s+1. Reconstrua C_0 = X/Y^{-1} e valide em Simulink com entrada rampa.",
                              "finalVerifications": [
                                "C_0 estabiliza G em malha fechada (polos LHP).",
                                "X e Y satisfazem equação de Diophantine com erro numérico mínimo.",
                                "Margens de ganho/fase iguais às do C_0 inicial.",
                                "Simulação reproduz desempenho original.",
                                "Fatorizações são biproprias e coprimas.",
                                "Controlador implementável (ordem razoável)."
                              ],
                              "assessmentCriteria": [
                                "Precisão na solução Diophantine (>99% exatidão).",
                                "Tempo total de execução <10 horas.",
                                "Desempenho: settling time < especificado, overshoot <10%.",
                                "Relatório documenta todos passos e verificações.",
                                "Robustez a ±10% variação em G.",
                                "Uso correto de ferramentas numéricas sem singularidades."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Álgebra de polinômios e Euclides estendido.",
                                "Programação: Implementação em MATLAB para simulações e solvers.",
                                "Física: Modelagem dinâmica de sistemas mecatrônicos.",
                                "Otimização: LQG como introdução a controle ótimo.",
                                "Estatística: Análise de ruído e robustez."
                              ],
                              "realWorldApplication": "Desenvolvimento de controladores para drones autônomos, onde PID inicial é refinado via Youla para robustez a ventos variáveis, permitindo estabilidade em missões reais de vigilância."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "76.6.4.4.1.1"
                            ]
                          },
                          {
                            "id": "76.6.4.4.2.3",
                            "name": "Parametrizar com Q Estável",
                            "description": "Escolher Q(s) estável de grau adequado e verificar que o sistema fechado T = T_{11} + T_{12} Q T_{21} é estável.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar os blocos nominais T11, T12 e T21",
                                  "subSteps": [
                                    "Revise a planta nominal G(s) e o controlador nominal C(s) estabilizante.",
                                    "Calcule T11 = (I + G C)^{-1} G, T12 = (I + G C)^{-1} G N_c, T21 = M_p (I + N_c C)^{-1}, onde N_c e M_p são fatores de Bezout.",
                                    "Verifique que T11, T12 e T21 são funções de transferência estáveis biproprias.",
                                    "Represente-os em forma de fração de polo-zero ou coeficientes.",
                                    "Anote os graus de T12 e T21 para determinar o grau máximo permitido de Q."
                                  ],
                                  "verification": "Confirme que T11(∞)=0, T12 e T21 biproprios estáveis via polos no semiplano esquerdo ou simulação de resposta ao degrau.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "MATLAB/Simulink ou Python (Control Systems Library)",
                                    "Papel e calculadora para cálculos manuais",
                                    "Notas de aula sobre fatorização de Bezout"
                                  ],
                                  "tips": "Use comandos como tf() e pole() no MATLAB para análise rápida de estabilidade.",
                                  "learningObjective": "Compreender a estrutura dos blocos na parametrização de Youla-Kučera.",
                                  "commonMistakes": [
                                    "Ignorar bipropriedade de T12/T21",
                                    "Erro na inversão (I + GC)^{-1}",
                                    "Não verificar estabilidade inicial de T11"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Selecionar e construir Q(s) estável de grau adequado",
                                  "subSteps": [
                                    "Determine o grau máximo de Q como deg(T12) + deg(T21) - 1 para manter o grau próprio estrito.",
                                    "Escolha uma forma inicial para Q(s), como Q(s) = K / (s + a)^n com a > 0 para estabilidade.",
                                    "Ajuste parâmetros K, a, n para atender especificações de desempenho (ex: ganho baixo em altas frequências).",
                                    "Verifique estabilidade de Q: todos polos no semiplano esquerdo.",
                                    "Teste bipropriedade se necessário: ||Q||_∞ < 1 para robustez."
                                  ],
                                  "verification": "Plote polos de Q e confirme norma H-infinito < γ desejado usando hinfnorm() no MATLAB.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Software de controle (MATLAB, Octave)",
                                    "Tabelas de funções de transferência estáveis",
                                    "Referência: Doyle et al. Feedback Control Theory"
                                  ],
                                  "tips": "Comece com Q=0 (controlador nominal) e incremente complexidade gradualmente.",
                                  "learningObjective": "Dominar seleção de Q estável que preserva estabilidade e performance.",
                                  "commonMistakes": [
                                    "Exceder grau máximo levando a controlador impróprio",
                                    "Polos no semiplano direito",
                                    "Ignorar atenuação em alta frequência"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Construir o sistema fechado T = T11 + T12 Q T21",
                                  "subSteps": [
                                    "Implemente a multiplicação matricial/funções: T(s) = T11(s) + T12(s) * Q(s) * T21(s).",
                                    "Realize simplificação algébrica para forma mínima.",
                                    "Conecte em diagrama de blocos para visualização.",
                                    "Simule resposta em frequência (Bode) e tempo (degrau).",
                                    "Compare com sistema nominal (Q=0)."
                                  ],
                                  "verification": "Obtenha função de transferência mínima e confirme ausência de cancelamentos instáveis.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "MATLAB (series(), feedback(), bode())",
                                    "Python (control library, matplotlib)",
                                    "Diagrama de blocos impresso"
                                  ],
                                  "tips": "Use append() ou series() para conexões em cascade no MATLAB.",
                                  "learningObjective": "Aplicar a fórmula de parametrização para gerar todos estabilizadores.",
                                  "commonMistakes": [
                                    "Cancelamentos polos-zero instáveis",
                                    "Erro na ordem de multiplicação T12 Q T21",
                                    "Não simplificar fração"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificar estabilidade do sistema fechado T",
                                  "subSteps": [
                                    "Analise polos de T: todos no semiplano esquerdo.",
                                    "Plote diagrama de Bode: fase > -180° em |G|=1, ganho <0 dB em fase=-180° (Nyquist).",
                                    "Aplique critério de Routh-Hurwitz para sistemas de baixa ordem.",
                                    "Simule perturbações e verifique ausência de oscilações crescentes.",
                                    "Calcule margens de ganho/fase para robustez."
                                  ],
                                  "verification": "Critério de Nyquist satisfeito e simulação estável por >5x tempo de assentamento.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Ferramentas de análise: MATLAB margin(), nyquist()",
                                    "Osciloscópio virtual em Simulink"
                                  ],
                                  "tips": "Sempre verifique com simulação numérica além de análise analítica.",
                                  "learningObjective": "Validar estabilidade usando múltiplos métodos teóricos e práticos.",
                                  "commonMistakes": [
                                    "Confundir estabilidade de T com Q isolado",
                                    "Ignorar encruzilhadas de Nyquist",
                                    "Simulações com tempo insuficiente"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Validar e otimizar a parametrização",
                                  "subSteps": [
                                    "Teste sensibilidade a variações em Q (ex: ±10% em parâmetros).",
                                    "Otimize Q para minimizar ||T - T_d|| onde T_d é desejado.",
                                    "Documente o controlador C = (T21 Q + M_c) (T12 Q + N_c)^{-1}.",
                                    "Compare performance com outros Q (ex: FIR vs IIR).",
                                    "Registre lições aprendidas."
                                  ],
                                  "verification": "Sistema permanece estável sob perturbações e atende specs de performance.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Otimização: fmincon() no MATLAB",
                                    "Relatório template"
                                  ],
                                  "tips": "Use Q com delay allpass para trade-offs fase-ganho.",
                                  "learningObjective": "Integrar parametrização em design robusto de controladores.",
                                  "commonMistakes": [
                                    "Não inverter corretamente para C",
                                    "Otimização sem constraints de estabilidade",
                                    "Ignorar computacionalidade"
                                  ]
                                }
                              ],
                              "practicalExample": "Para um motor DC com G(s) = 1/(s(s+1)), controlador nominal PID estabilizante. Escolha Q(s) = 0.5/(s+2), deg(Q)=1 adequado. Compute T11, T12, T21 via Bezout, forme T e verifique polos em -1.5, -0.8 (estáveis). Simule em MATLAB: resposta degrau com overshoot <10%.",
                              "finalVerifications": [
                                "Todos polos de T no semiplano esquerdo.",
                                "Critério de Nyquist satisfeito sem encruzilhadas instáveis.",
                                "Margens de ganho >6dB e fase >45°.",
                                "Simulação temporal estável sem divergência.",
                                "Controlador C derivado correto e realizável.",
                                "Q biproprio com ||Q||_∞ <1."
                              ],
                              "assessmentCriteria": [
                                "Correta preparação de T11/T12/T21 (90% precisão nos cálculos).",
                                "Q estável de grau ≤ deg(T12)+deg(T21)-1 com verificação explícita.",
                                "Construção exata de T sem erros algébricos.",
                                "Verificação de estabilidade via 2+ métodos independentes.",
                                "Exemplo prático simulado com plots Bode/degrau corretos.",
                                "Documentação completa com justificativas."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Análise complexa (polos/zeros), álgebra linear (fatorização).",
                                "Programação: Implementação em MATLAB/Python para simulações numéricas.",
                                "Física: Modelagem dinâmica de sistemas lineares invariantes no tempo.",
                                "Engenharia de Software: Validação e testes unitários em controle.",
                                "Otimização: Minimização H-infinito e robustez."
                              ],
                              "realWorldApplication": "Em automação industrial, parametrizar Q estável para retuning de controladores PID em plantas com incertezas (ex: reatores químicos), garantindo estabilidade sob variações de parâmetros e falhas, como em PLCs da Siemens ou DCS da Honeywell."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "76.6.4.4.2.1"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "76.6.4.4.3",
                        "name": "Aplicações e Propriedades da Parametrização",
                        "description": "Exploração de robustez, otimização via Q e ligação com síntese H∞.",
                        "specificSkills": [
                          {
                            "id": "76.6.4.4.3.1",
                            "name": "Analisar Robustez via Q",
                            "description": "Avaliar estabilidade robusta para perturbações Δ com ||T_{12} Δ T_{21}||_∞ <1, otimizando Q para minimizar ||T||_∞.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Fundamentos da Parametrização de Youla-Kučera e Identificar T12 e T21",
                                  "subSteps": [
                                    "Revise as coprimas bezoutianas N, D, X, Y da planta G.",
                                    "Expresse o controlador C(q) = (X + D Q)(Y - N Q)^{-1} para Q estável.",
                                    "Derive as matrizes de transferência T12 e T21 do framework de robustez: T12 envolve o caminho de Q para a saída sensível às perturbações, T21 o caminho inverso.",
                                    "Confirme que a estabilidade robusta requer ||T_{12} Δ T_{21}||_∞ < 1 para perturbação Δ.",
                                    "Anote as expressões explícitas de T12 e T21 em termos de N, D, Q."
                                  ],
                                  "verification": "Liste corretamente as expressões de T12 e T21 e verifique se satisfazem a identidade de estabilidade nominal.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Livro de referência em controle avançado (e.g., Zhou's Robust Control), MATLAB para coprimas, papel e lápis.",
                                  "tips": "Use a dupla de Bezout para validar: N X - M Y = I.",
                                  "learningObjective": "Compreender como Q parametriza todos os controladores estabilizadores e seu papel em T12/T21.",
                                  "commonMistakes": "Confundir T12 com o complemento sensibilidade; ignorar estabilidade de Q."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Modelar a Perturbação Δ e Calcular a Norma de Robustez",
                                  "subSteps": [
                                    "Defina o modelo de incerteza Δ (e.g., Δ multiplicativa com ||Δ||_∞ ≤ γ).",
                                    "Calcule T_{12} Δ T_{21} usando convolução ou multiplicação em frequência.",
                                    "Compute a norma H-infinito: sup_ω σ_max(T_{12}(jω) Δ(jω) T_{21}(jω)) < 1.",
                                    "Use ferramentas numéricas para plotar singular values de T_{12} Δ T_{21}.",
                                    "Avalie o pico da norma para quantificar o grau de robustez."
                                  ],
                                  "verification": "Gere gráfico de σ_max(T_{12} Δ T_{21})(jω) e confirme se máximo <1.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "MATLAB com toolbox Control System ou Robust Control, planta G exemplo.",
                                  "tips": "Aproxime Δ por modelo de ordem baixa para simulações iniciais.",
                                  "learningObjective": "Modelar incertezas e calcular normas H-infinito para análise de robustez.",
                                  "commonMistakes": "Usar norma 2 em vez de ∞; esquecer phase de Δ."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Verificar Condição de Estabilidade Robusta",
                                  "subSteps": [
                                    "Teste ||T_{12} Δ T_{21}||_∞ <1 para Δ nominais e piores casos.",
                                    "Simule respostas ao degrau com Δ aplicada e observe estabilidade.",
                                    "Analise margens de robustez: compute μ (structured singular value) se aplicável.",
                                    "Compare com condição pequena ganho: ||T_{12}||_∞ ||T_{21}||_∞ < 1/||Δ||_∞.",
                                    "Documente cenários onde robustez falha (e.g., ω alta)."
                                  ],
                                  "verification": "Simulações mostram sistema estável para ||Δ||_∞ = 0.9 * 1/||T12 T21||_∞.",
                                  "estimatedTime": "50 minutos",
                                  "materials": "MATLAB Simulink para simulações, scripts de norma H∞.",
                                  "tips": "Use hinfnorm() no MATLAB para cálculo rápido.",
                                  "learningObjective": "Aplicar teorema pequeno ganho para garantir estabilidade robusta.",
                                  "commonMistakes": "Testar apenas Δ escalar; ignorar dinâmicas de Δ."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Otimizar Q para Minimizar ||T||_∞",
                                  "subSteps": [
                                    "Defina T como função de Q (e.g., T = T11 + T12 Q T21, onde T11=0 nominal).",
                                    "Formule problema: min_Q ||T_{12} Q T_{21}||_∞ sujeito a estabilidade.",
                                    "Use iteração fixa-ponto ou otimização H∞ (e.g., hinfsyn).",
                                    "Avalie trade-off: redução de ||T||_∞ vs. desempenho nominal.",
                                    "Valide nova robustez com Δ otimizado."
                                  ],
                                  "verification": "||T||_∞ reduzido em pelo menos 20% com robustez mantida.",
                                  "estimatedTime": "90 minutos",
                                  "materials": "MATLAB Robust Control Toolbox, solver de otimização.",
                                  "tips": "Comece com Q=0 (controle central) e perturbe iterativamente.",
                                  "learningObjective": "Otimizar parâmetro Q para robustez ótima via normas H∞.",
                                  "commonMistakes": "Violar estabilidade de Q novo; otimizar sem constraint de performance."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Sintetizar Análise e Relatar Resultados",
                                  "subSteps": [
                                    "Compile gráficos de normas antes/depois otimização.",
                                    "Resuma margens de robustez e sensibilidade a Δ.",
                                    "Discuta limitações (e.g., conservadorismo do ||.||_∞).",
                                    "Proponha melhorias (e.g., Q não-causal para benchmark).",
                                    "Prepare relatório com equações chave e conclusões."
                                  ],
                                  "verification": "Relatório explica claramente por que robustez melhorou/falhou.",
                                  "estimatedTime": "40 minutos",
                                  "materials": "LaTeX ou Word para relatório, MATLAB figures.",
                                  "tips": "Use Bode plots para visualização intuitiva.",
                                  "learningObjective": "Comunicar análise de robustez de forma técnica e clara.",
                                  "commonMistakes": "Omitir unidades de frequência; generalizar demais."
                                }
                              ],
                              "practicalExample": "Considere uma planta G(s) = 1/(s^2 + 0.2s +1) com Δ multiplicativa ||Δ||_∞=0.2. Compute T12, T21 para Q=0, verifique ||T12 Δ T21||_∞=0.85<1, otimize Q para min ||Tzw||_∞ onde z/w são sinais de performance/perturbação, alcançando redução de 25% na norma.",
                              "finalVerifications": [
                                "||T_{12} Δ T_{21}||_∞ calculado corretamente <1.",
                                "Simulações confirmam estabilidade para Δ com norma limite.",
                                "Otimização de Q reduz ||T||_∞ sem perda de robustez.",
                                "Gráficos de singular values mostram picos controlados.",
                                "Relatório identifica trade-offs corretamente.",
                                "Condições de pequeno ganho derivadas analyticamente."
                              ],
                              "assessmentCriteria": [
                                "Precisão nos cálculos de normas H∞ (90%+ exatidão).",
                                "Compreensão conceitual de parametrização Q (explicação clara).",
                                "Qualidade das simulações e otimizações (convergência demonstrada).",
                                "Análise de erros comuns e limitações abordada.",
                                "Relatório estruturado com visualizações eficazes.",
                                "Aplicação correta do teorema pequeno ganho."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria de operadores lineares e normas em espaços de Hardy.",
                                "Programação: Implementação numérica em MATLAB para análise em frequência.",
                                "Física: Modelagem de dinâmicas reais com incertezas (e.g., amortecimento variável).",
                                "Otimização: Algoritmos de minimização convexa não-linear.",
                                "Estatística: Análise de Monte Carlo para Δ estocásticas."
                              ],
                              "realWorldApplication": "Em controle de drones, otimizar Q garante estabilidade robusta contra variações de vento (Δ aerodinâmica), minimizando desvios de trajetória e evitando crashes em missões autônomas."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "76.6.4.4.2.3"
                            ]
                          },
                          {
                            "id": "76.6.4.4.3.2",
                            "name": "Implementar em MATLAB",
                            "description": "Usar funções como sysic ou hinfsyn para gerar parametrização e simular respostas em malha fechada com diferentes Q.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar o ambiente MATLAB e definir o sistema planta e controlador nominal",
                                  "subSteps": [
                                    "Instalar toolboxes necessárias: Control System Toolbox e Robust Control Toolbox.",
                                    "Definir matrizes A, B, C, D do sistema linear (planta G) em espaço de estados.",
                                    "Criar o controlador nominal K usando função ss() ou tf().",
                                    "Verificar estabilidade do par (A,B) e observabilidade com funções como ctrb() e obsv().",
                                    "Computar o estabilizador central C usando sysic() com opções iniciais."
                                  ],
                                  "verification": "Sistema e controlador definidos corretamente; comandos ctrb() e obsv() retornam ranks completos sem erros.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "MATLAB com Control System Toolbox",
                                    "Robust Control Toolbox",
                                    "Documentação MATLAB para sysic()"
                                  ],
                                  "tips": "Use variáveis claras como 'sys' para planta e 'K' para controlador; teste com um sistema simples primeiro.",
                                  "learningObjective": "Configurar modelos de sistemas lineares e estabilizadores em MATLAB para parametrização Youla-Kučera.",
                                  "commonMistakes": [
                                    "Esquecer de instalar toolboxes",
                                    "Definir dimensões erradas em A,B,C,D",
                                    "Não verificar controllability/observability"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Gerar a parametrização Youla-Kučera usando sysic() ou hinfsyn()",
                                  "subSteps": [
                                    "Chamar sysic(sys, K) para obter os estabilizadores Q=0, J, M, V iniciais.",
                                    "Alternativamente, usar hinfsyn() para sintetizar um controlador H-infinito como nominal K.",
                                    "Armazenar os sistemas parametrizados: controlador Q-filter como C_Q = (V - M Q)(J - N Q)^-1.",
                                    "Definir estrutura de Q estável com ordem apropriada (e.g., tf([]) para Q=0 inicialmente).",
                                    "Validar que todos os sistemas são estáveis com isstable()."
                                  ],
                                  "verification": "sysic() retorna sistemas estáveis; isstable(C_Q) é true para Q=0.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Função sysic() ou hinfsyn()",
                                    "Exemplos de documentação MATLAB para Youla parametrization"
                                  ],
                                  "tips": "Comece com sysic para simplicidade; use feedback() para validar malha aberta inicialmente.",
                                  "learningObjective": "Implementar funções de parametrização para gerar família de controladores estabilizadores.",
                                  "commonMistakes": [
                                    "Não garantir estabilidade de Q",
                                    "Invertar ordem errada em C_Q",
                                    "Ignorar warnings de singularidade"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Definir e aplicar diferentes filtros Q para parametrização",
                                  "subSteps": [
                                    "Criar 3-5 Q diferentes: e.g., low-pass filter (tf(1,[1 1])), high-pass, notch filter.",
                                    "Para cada Q, computar controlador parametrizado C_Q usando fórmula Youla.",
                                    "Verificar norma de Q <1 para estabilidade via norm(Q,inf).",
                                    "Armazenar lista de C_Q em cell array para iteração.",
                                    "Plotar respostas em frequência de Q com bode() para inspeção."
                                  ],
                                  "verification": "Todos C_Q estáveis; norm(Q,inf) <1 para cada filtro Q.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Funções tf(), norm()",
                                    "Templates de filtros Butterworth ou Chebyshev"
                                  ],
                                  "tips": "Use rlocus() para ajudar na escolha de Q que melhore robustez; limite ordem de Q para evitar complexidade.",
                                  "learningObjective": "Explorar impacto de diferentes Q na performance do controlador parametrizado.",
                                  "commonMistakes": [
                                    "Q instável ou norma >1",
                                    "Fórmula de C_Q invertida",
                                    "Pouca variedade em Q testados"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Simular respostas em malha fechada e analisar performance",
                                  "subSteps": [
                                    "Para cada C_Q, formar malha fechada T = feedback(G * C_Q, 1).",
                                    "Simular step response com step(T) e salvar dados em estrutura.",
                                    "Plotar step responses comparativas com diferentes Q usando subplot().",
                                    "Computar métricas: tempo de assentamento, overshoot com stepinfo().",
                                    "Analisar sensibilidade a perturbações variando G em ±10%."
                                  ],
                                  "verification": "Plots gerados sem erros; todas respostas estáveis (sem divergência).",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Funções feedback(), step(), stepinfo()",
                                    "Simulink opcional para simulação não-linear"
                                  ],
                                  "tips": "Use hold on para sobrepor curvas; exporte figuras com saveas() para relatório.",
                                  "learningObjective": "Simular e comparar dinâmicas em malha fechada para validar trade-offs de design.",
                                  "commonMistakes": [
                                    "Malha fechada unitária errada (use +1 para negative feedback)",
                                    "Escalas de plot inadequadas",
                                    "Ignorar stepinfo() para quantificação"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Validar e otimizar a implementação",
                                  "subSteps": [
                                    "Testar com ruído e distúrbios usando lsim() ou Simulink.",
                                    "Otimizar Q minimizando custo H2 ou Hinf com função hinfsyn sobre Q.",
                                    "Gerar relatório com métricas tabulares usando table().",
                                    "Salvar workspace e script completo como .m funcional.",
                                    "Compartilhar código via GitHub para revisão."
                                  ],
                                  "verification": "Script roda end-to-end sem erros; métricas dentro de specs desejadas.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "lsim()",
                                    "table()",
                                    "Git para versionamento"
                                  ],
                                  "tips": "Automatize loops com for sobre Q; documente código com % comments.",
                                  "learningObjective": "Finalizar implementação robusta com validação e documentação.",
                                  "commonMistakes": [
                                    "Não salvar workspace",
                                    "Omitir testes de robustez",
                                    "Código não reproduzível"
                                  ]
                                }
                              ],
                              "practicalExample": "Considere uma planta de motor DC com G(s) = 1/(s^2 + 2s + 1). Use K nominal PI. Gere Q1=lowpass(1/(s+0.1)), Q2=notch. Simule step responses mostrando como Q1 reduz overshoot mas aumenta tempo de subida.",
                              "finalVerifications": [
                                "Todas simulações em malha fechada estáveis para Q variados.",
                                "Métricas stepinfo() melhoradas ou trade-offs claros vs. nominal.",
                                "Código MATLAB reproduzível sem erros em máquina limpa.",
                                "Plots comparativos legíveis com legendas.",
                                "Norma H-inf de sensibilidade reduzida com Q ótimo.",
                                "Testes de robustez passam com G perturbado."
                              ],
                              "assessmentCriteria": [
                                "Correção na implementação de sysic/hinfsyn (20%)",
                                "Variedade e estabilidade de Q testados (20%)",
                                "Qualidade das simulações e plots (20%)",
                                "Análise quantitativa com stepinfo/norm (20%)",
                                "Documentação e reproduzibilidade do código (10%)",
                                "Insights sobre trade-offs de performance (10%)"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Álgebra linear (espaço de estados), teoria de controle ótimo.",
                                "Programação: Scripting MATLAB, automação de simulações.",
                                "Física: Dinâmica de sistemas mecatrônicos.",
                                "Engenharia de Software: Versionamento e testes unitários.",
                                "Otimização: Problemas H2/H-inf."
                              ],
                              "realWorldApplication": "Design de controladores robustos para drones (estabilização com Q adaptando a vento), processos químicos (regulação de temperatura com Q para rejeição de distúrbios) ou automotivo (controle de suspensão ativa)."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "76.6.4.4.2.1"
                            ]
                          },
                          {
                            "id": "76.6.4.4.3.3",
                            "name": "Otimizar Desempenho com Q",
                            "description": "Projetar Q via otimização (ex: H∞) para atender especificações de desempenho como rejeição de distúrbios e ruído.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Definir Especificações de Desempenho",
                                  "subSteps": [
                                    "Identificar tipos de distúrbios e ruídos relevantes para o sistema (ex: ruído de sensores, distúrbios de entrada).",
                                    "Especificar métricas de desempenho como norma H∞ para sensibilidade S e T (função de complemento).",
                                    "Definir limites quantitativos (ex: ||S||_∞ < 0.1 para rejeição de distúrbios).",
                                    "Documentar as especificações em termos da parametrização Youla-Kučera: C = (X + D Q)/(Y - N Q)."
                                  ],
                                  "verification": "Lista de especificações documentada com valores numéricos e justificativa física.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Folha de papel ou editor de texto",
                                    "Referências teóricas sobre normas H∞",
                                    "Exemplos de sistemas de controle"
                                  ],
                                  "tips": "Priorize especificações realistas baseadas no modelo do sistema para evitar soluções inviáveis.",
                                  "learningObjective": "Compreender como traduzir requisitos de engenharia em métricas matemáticas para otimização.",
                                  "commonMistakes": [
                                    "Ignorar trade-offs entre rejeição de distúrbios e robustez",
                                    "Definir especificações muito ambiciosas sem análise de viabilidade"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Modelar o Problema de Otimização",
                                  "subSteps": [
                                    "Representar o sistema fechado em termos de Q usando a parametrização Youla-Kučera.",
                                    "Expressar funções de sensibilidade: S = (Y - N Q)^{-1}, T = N (Y - N Q)^{-1}.",
                                    "Formular o problema como min_||Q||_∞ γ tal que ||W_d S||_∞ < γ e ||W_n T||_∞ < γ, com pesos W_d e W_n.",
                                    "Linearizar ou preparar para solução numérica se necessário.",
                                    "Verificar estabilidade inerente da parametrização (Q estável implica C estável)."
                                  ],
                                  "verification": "Modelo matemático escrito com equações de sensibilidade e função custo definida.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Software MATLAB ou Python (Control Systems Toolbox)",
                                    "Livro de controle avançado (ex: Zhou - Robust Control)"
                                  ],
                                  "tips": "Use pesos de frequência (W_d alta em baixas freq., W_n alta em altas freq.) para moldar o desempenho.",
                                  "learningObjective": "Modelar o trade-off entre desempenho e robustez na parametrização Q.",
                                  "commonMistakes": [
                                    "Esquecer a inversibilidade de (Y - N Q)",
                                    "Não considerar o suporte de frequência do sistema"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Resolver a Otimização para Q",
                                  "subSteps": [
                                    "Implementar algoritmo de otimização H∞ (ex: função hinfsyn ou iteração padrão).",
                                    "Inicializar Q=0 (controlador nominal) e iterar para minimizar γ.",
                                    "Aplicar condições de optimalidade (equações de Riccati se analítico).",
                                    "Resolver numericamente usando solvers como MATLAB hinfnorm ou lmi toolbox.",
                                    "Ajustar pesos se γ mínimo for alto."
                                  ],
                                  "verification": "Q otimizado obtido com γ < especificado e plots de Bode das sensibilidades.",
                                  "estimatedTime": "3 horas",
                                  "materials": [
                                    "MATLAB com Robust Control Toolbox",
                                    "Scripts de exemplo para H∞ synthesis"
                                  ],
                                  "tips": "Monitore o valor de γ em cada iteração e use escalonamento de modelos para convergência.",
                                  "learningObjective": "Aplicar ferramentas computacionais para síntese ótima de Q.",
                                  "commonMistakes": [
                                    "Não estabilizar Q adequadamente",
                                    "Ignorar singularidades numéricas em altas frequências"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Validar e Implementar o Controlador",
                                  "subSteps": [
                                    "Calcular controlador C a partir de Q otimizado.",
                                    "Simular resposta a distúrbios e ruído no Simulink.",
                                    "Verificar margens de estabilidade e desempenho em malha fechada.",
                                    "Comparar com controlador nominal (Q=0).",
                                    "Ajustar Q se necessário para trade-offs adicionais."
                                  ],
                                  "verification": "Simulações mostram atendimento às especificações com margens adequadas.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Simulink para simulações",
                                    "Ferramentas de análise de step/distúrbio"
                                  ],
                                  "tips": "Teste com cenários reais de ruído colorido para robustez.",
                                  "learningObjective": "Validar otimizações em simulações realistas.",
                                  "commonMistakes": [
                                    "Não testar com ruído realista",
                                    "Esquecer análise de sensibilidade a variações de planta"
                                  ]
                                }
                              ],
                              "practicalExample": "Otimize Q para um sistema de controle de posição de um braço robótico, usando H∞ para rejeitar distúrbios de carga (até 20% da massa nominal) e ruído de encoder (SNR=40dB), garantindo erro de rastreamento < 1% em frequências < 1Hz.",
                              "finalVerifications": [
                                "||W_d S||_∞ < γ alvo",
                                "||W_n T||_∞ < γ alvo",
                                "Margem de ganho > 6dB e fase > 45°",
                                "Resposta transitória a distúrbio: assentamento < 5s",
                                "Simulação com ruído confirma especificações",
                                "Q é estável e próprio"
                              ],
                              "assessmentCriteria": [
                                "Precisão na formulação das sensibilidades em termos de Q (100%)",
                                "Convergência da otimização com γ mínimo (90% do ótimo)",
                                "Validação via simulações com métricas quantitativas",
                                "Análise de trade-offs documentada",
                                "Código limpo e reproduzível",
                                "Conexão clara com parametrização Youla-Kučera"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Otimização convexa e normas induzidas",
                                "Programação: Implementação numérica em MATLAB/Python",
                                "Física: Dinâmica de sistemas mecatrônicos",
                                "Estatística: Análise de ruído e Monte Carlo simulations",
                                "Engenharia de Software: Validação de modelos de controle"
                              ],
                              "realWorldApplication": "Em aviões não tripulados (drones) para controle de atitude, otimizando Q para rejeitar turbulências (distúrbios) e ruído de giroscópios, garantindo estabilidade e precisão em missões autônomas."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "76.6.4.4.3.1"
                            ]
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.4.4",
                    "name": "Síntese de Controladores Estabilizadores",
                    "description": "Aplicação da parametrização para projetar controladores com especificações de desempenho e robustez.",
                    "individualConcepts": [
                      {
                        "id": "76.6.4.4.1",
                        "name": "Fundamentos da Parametrização de Controladores Estabilizadores",
                        "description": "Apresentação da parametrização de Youla-Kucera para representar todos os controladores estabilizadores de sistemas lineares invariantes no tempo (LIT) monovariáveis, incluindo a estrutura básica com planta nominal e funções de Bezout.",
                        "specificSkills": [
                          {
                            "id": "76.6.4.4.1.1",
                            "name": "Representar controladores estabilizadores via parametrização Q",
                            "description": "Derivar a forma parametrizada do controlador C(s) = (X + M Q)/(Y - N Q), onde Q(s) é estável, a partir das fatorizações coprimas da planta P(s) = N/M, e verificar estabilidade interna para qualquer Q estável.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender as Fatorizações Coprimas da Planta P(s)",
                                  "subSteps": [
                                    "Defina a planta P(s) = N(s)/M(s), onde N(s) e M(s) são fatorizações coprimas em um anel de frações estáveis (RH_infty).",
                                    "Verifique a coprimaridade usando o conceito de maior divisor comum (GCD) sendo 1.",
                                    "Estenda para o domínio de Youla-Kucera usando fatorizações biproprias D_l^{-1}N_l = D_r^{-1}N_r.",
                                    "Pratique identificando N e M para exemplos simples como P(s) = 1/(s+1).",
                                    "Desenhe o diagrama de blocos da planta destacando entradas e saídas."
                                  ],
                                  "verification": "Construa as matrizes de Bezout biproprias e confirme que N Mtilde - M Ntilde = I.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Livro de Doyle 'Feedback Control Theory'",
                                    "MATLAB com toolbox de controle",
                                    "Papel e lápis para diagramas"
                                  ],
                                  "tips": "Sempre normalize as fatorizações para que sejam biproprias (unidades à esquerda e direita).",
                                  "learningObjective": "Identificar e representar corretamente as fatorizações coprimas de P(s).",
                                  "commonMistakes": [
                                    "Confundir coprimaridade com estabilidade",
                                    "Esquecer normalização bipropria"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Estabelecer as Equações de Bezout",
                                  "subSteps": [
                                    "Enuncie as identidades de Bezout: Existem X, Y estáveis tais que X N - Y M = 0 (lado duplo) e M Xtilde - N Ytilde = I.",
                                    "Derive as soluções para X e Y usando convolução ou divisão polinomial.",
                                    "Construa os complementos estáveis Mtilde e Ntilde biproprios.",
                                    "Resolva numericamente para um P(s) exemplo usando MATLAB.",
                                    "Verifique a invertibilidade das matrizes resultantes."
                                  ],
                                  "verification": "Confirme que M Xtilde - N Ytilde = I multiplicando as matrizes.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Software MATLAB/Simulink",
                                    "Notas de aula sobre teoria de Youla",
                                    "Calculadora simbólica como SymPy"
                                  ],
                                  "tips": "Use a fatorização de Smith-McMillan para sistemas não próprios se necessário.",
                                  "learningObjective": "Dominar as identidades de Bezout para fatorizações coprimas.",
                                  "commonMistakes": [
                                    "Ignorar a estabilidade de X e Y",
                                    "Confundir identidades esquerdas e direitas"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Derivar a Parametrização do Controlador C(s)",
                                  "subSteps": [
                                    "Introduza o parâmetro livre Q(s) estável e derive C(s) = (X + M Q)/(Y - N Q).",
                                    "Mostre que todo controlador estabilizante pode ser escrito nesta forma.",
                                    "Substitua nas equações de loop fechado: S = (Y - N Q)/M, T = (X + M Q)/N.",
                                    "Implemente em MATLAB para um P(s) = 1/s(s+1).",
                                    "Varie Q(s) e plote respostas em frequência."
                                  ],
                                  "verification": "Confirme que o controlador fecha o loop com P(s) e é estável para Q estável.",
                                  "estimatedTime": "2.5 horas",
                                  "materials": [
                                    "MATLAB Control System Toolbox",
                                    "Exemplos de Francis 'A Course in H-infinity Control'",
                                    "Folha de exercícios"
                                  ],
                                  "tips": "Escolha Q(s) de baixa ordem inicialmente para simplicidade.",
                                  "learningObjective": "Derivar explicitamente a forma parametrizada C(s) a partir de N, M, X, Y.",
                                  "commonMistakes": [
                                    "Denominador invertido como Y + N Q",
                                    "Esquecer que Q deve ser estável"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificar Estabilidade Interna para Qualquer Q Estável",
                                  "subSteps": [
                                    "Analise os sinais internos: u = -Q y, onde y = P u + r.",
                                    "Mostre que todos os sinais fechados são estáveis: [I -Q P; P I - P Q] estável.",
                                    "Use o lema de estabilidade interna: estabilidade se Q estável devido a coprimaridade.",
                                    "Simule com Q instável e observe divergência.",
                                    "Calcule margens de estabilidade variando Q."
                                  ],
                                  "verification": "Simule step response para múltiplos Q estáveis e confirme ausência de picos ou oscilações.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Simulink para simulações",
                                    "Artigos sobre parametrização Youla",
                                    "Gráficos de Bode"
                                  ],
                                  "tips": "Use nyquistplot para visualização rápida de estabilidade.",
                                  "learningObjective": "Provar e verificar que a parametrização garante estabilidade interna.",
                                  "commonMistakes": [
                                    "Confundir estabilidade interna com estabilidade do loop fechado",
                                    "Não testar Q no limite de estabilidade"
                                  ]
                                }
                              ],
                              "practicalExample": "Para uma planta de motor DC P(s) = K/(s(Js+B)), fatorize coprimamente, derive C(s) com Q(s)=1/(s+2), implemente em Simulink e verifique step response estável com overshoot <10%.",
                              "finalVerifications": [
                                "Derivação correta de C(s) = (X + M Q)/(Y - N Q) para P(s) dado.",
                                "Verificação numérica das identidades de Bezout.",
                                "Simulação em MATLAB mostrando estabilidade para 3 Q(s) estáveis diferentes.",
                                "Análise de sinais internos sem divergência.",
                                "Plot de respostas em frequência confirmando estabilidade.",
                                "Explicação verbal da parametrização para um colega."
                              ],
                              "assessmentCriteria": [
                                "Precisão na derivação da parametrização (100% correto).",
                                "Correta identificação de fatorizações coprimas e Bezout.",
                                "Simulações funcionais com estabilidade demonstrada.",
                                "Explicação clara de por que qualquer Q estável estabiliza.",
                                "Identificação de erros comuns e correções.",
                                "Tempo de conclusão dentro do estimado com qualidade."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Álgebra de frações estáveis e teoria de anéis (RH_infty).",
                                "Física: Modelagem dinâmica de sistemas lineares invariantes no tempo.",
                                "Computação: Programação numérica em MATLAB para análise de controle.",
                                "Engenharia de Software: Implementação de algoritmos de síntese de controladores."
                              ],
                              "realWorldApplication": "Usado em síntese de controladores robustos para aviões (controle de flight envelope), processos químicos (controle de reatores) e robótica (estabilização de braços manipuladores), permitindo tunagem via Q(s) sem perda de estabilidade."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "76.6.4.4.1.2",
                            "name": "Construir fatorizações coprimas duplas",
                            "description": "Calcular as fatorizações coprimas direita (N, M) e esquerda (V~, W~) da planta nominal P, utilizando estabilizadores conhecidos ou métodos numéricos em MATLAB, e resolver as equações de Bezout para X, Y.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar a planta nominal P e selecionar estabilizador",
                                  "subSteps": [
                                    "Identifique a planta nominal P(s) no domínio de Laplace ou z.",
                                    "Escolha um estabilizador conhecido C(s) que estabilize P(s), verificando estabilidade fechada.",
                                    "Implemente P e C em MATLAB usando tf ou ss.",
                                    "Calcule a função de transferência fechada T = P C / (1 + P C).",
                                    "Confirme que todos os polos de T estão no semiplano esquerdo (contínuo) ou dentro do círculo unitário (discreto)."
                                  ],
                                  "verification": "Pole-zero plot no MATLAB mostra estabilidade; nyquist ou bode confirma margens positivas.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "MATLAB com Control System Toolbox, documentação de Youla-Kucera parametrization.",
                                  "tips": "Use stabilizadores simples como PID para plantas de baixa ordem inicialmente.",
                                  "learningObjective": "Compreender a relação entre planta e estabilizador para fatorizações coprimas.",
                                  "commonMistakes": "Escolher C instável ou não estabilizador de P; ignorar domínio (contínuo/discreto)."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Construir fatorização coprima direita (N, M)",
                                  "subSteps": [
                                    "Defina a matriz de Bezout direita: encontre N e M unimodulares tais que [N; M] = [P; I] * U^{-1}, onde U estabiliza.",
                                    "Calcule D = (I + P C)^{-1} em MATLAB.",
                                    "Defina N = P D e M = C D (ou M = D para normalização).",
                                    "Normalize para que M(infinito) = I usando funções de divisão polinomial.",
                                    "Verifique coprimidade: existe X, Y tais que X N + Y M = I."
                                  ],
                                  "verification": "Execute sys = [N; M]; rank(sys) == ordem total e existe Bezout com resíduo identidade.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "MATLAB scripts para coprime_factor (coprime toolbox ou custom).",
                                  "tips": "Use comando coprime em Control Toolbox para automação inicial, depois manual.",
                                  "learningObjective": "Dominar construção algébrica e numérica de RCF.",
                                  "commonMistakes": "Não normalizar M; erros numéricos em alta frequência devido a cancelamentos."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Construir fatorização coprima esquerda (V~, W~)",
                                  "subSteps": [
                                    "Use dualidade: para LCF, encontre V~ e W~ tais que [V~, W~] * [P; I] = U~^{-1}.",
                                    "Calcule D~ = (I + C P)^{-1}.",
                                    "Defina V~ = D~ P e W~ = D~ (ou ajustes para esquerda).",
                                    "Normalize W~(0) = I ou similar.",
                                    "Confirme simetria com RCF via propriedades de coprimidade."
                                  ],
                                  "verification": "Bode plot de V~ e W~ mostra estabilidade; produto com P recupera planta.",
                                  "estimatedTime": "50 minutos",
                                  "materials": "MATLAB, funções left_coprime ou inversas.",
                                  "tips": "LCF é transposição da RCF em alguns casos; valide com feedback loop.",
                                  "learningObjective": "Entender diferenças e simetrias entre RCF e LCF.",
                                  "commonMistakes": "Confundir ordem de multiplicação matricial; não verificar estabilidade de fatores."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Resolver equações de Bezout para X e Y",
                                  "subSteps": [
                                    "Para RCF: resolva X N + Y M = I usando método de Sylvester ou numérico.",
                                    "Em MATLAB, use função bezout ou minphase para soluções estáveis.",
                                    "Para LCF: V~ X~ + W~ Y~ = I.",
                                    "Valide: compute X*N + Y*M e cheque identidade no domínio de frequência.",
                                    "Armazene coeficientes para parametrização futura."
                                  ],
                                  "verification": "Erro normado ||X N + Y M - I|| < 1e-6 em bode magnitude.",
                                  "estimatedTime": "40 minutos",
                                  "materials": "MATLAB Symbolic Toolbox para exato, ou numérico com conv.",
                                  "tips": "Priorize soluções biproprias estáveis para robustez.",
                                  "learningObjective": "Aplicar identidades de Bezout em contextos de controle.",
                                  "commonMistakes": "Soluções instáveis; overflow numérico em polos próximos."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Verificar e validar fatorizações coprimas duplas",
                                  "subSteps": [
                                    "Confirme N P^{-1} M = I aproximadamente.",
                                    "Teste estabilidade de todos fatores: pole(N), pole(M), etc.",
                                    "Simule loop unitário com Q=0: deve recuperar P.",
                                    "Compare RCF e LCF em simulações de passo.",
                                    "Documente todos os fatores em workspace MATLAB."
                                  ],
                                  "verification": "Simulações step response coincidem com P original; todos fatores estáveis.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "MATLAB plot commands (bode, step, nyquist).",
                                  "tips": "Use tol=1e-8 para checks numéricos.",
                                  "learningObjective": "Garantir integridade das fatorizações para síntese.",
                                  "commonMistakes": "Ignorar ruído numérico como instabilidade falsa."
                                }
                              ],
                              "practicalExample": "Para P(s) = 1/(s^2 + s + 1), use C(s) = (s+2)/(s+1). Compute D(s) = 1/(1+P C), N=P D, M=C D. Resolva Bezout numéricamente em MATLAB: sys = [N;M], [X,Y] = bezout(sys). Verifique X*N + Y*M ≈ 1.",
                              "finalVerifications": [
                                "Todos fatores N, M, V~, W~ são estáveis (polos no LHP).",
                                "X N + Y M = I (erro < 1e-6).",
                                "V~ P = N e W~ = M aproximadamente.",
                                "Reconstrução de P via N M^{-1} coincide com original.",
                                "Nyquist de fatores mostra encirclamento zero.",
                                "Simulação fechada com Q=0 recupera resposta de P."
                              ],
                              "assessmentCriteria": [
                                "Precisão numérica das fatorizações (erro < 1e-5).",
                                "Estabilidade comprovada de todos os fatores.",
                                "Correta resolução de Bezout com soluções biproprias.",
                                "Validação via simulações em MATLAB.",
                                "Documentação clara de passos e scripts.",
                                "Eficiência computacional (tempo de execução razoável)."
                              ],
                              "crossCurricularConnections": [
                                "Álgebra Linear: Matrizes unimodulares e identidades de Bezout.",
                                "Programação Numérica: Implementação em MATLAB/Simulink.",
                                "Teoria de Controle Clássico: Estabilizadores e margens.",
                                "Matemática Computacional: Divisão polinomial e normalização."
                              ],
                              "realWorldApplication": "Essencial na parametrização de Youla-Kucera para síntese de controladores robustos em plantas incertas, como em aeroespacial (controle de drones) ou automotivo (suspensão ativa), permitindo tuning de Q para performance ótima."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "76.6.4.4.1.3",
                            "name": "Verificar estabilidade interna parametrizada",
                            "description": "Analisar as funções de transferência fechadas Tzw, S, T e CS, expressas em termos de Q, e confirmar que são estáveis para Q ∈ RH∞, garantindo estabilidade robusta à variação de Q.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Fundamentos da Parametrização de Controladores Estabilizadores",
                                  "subSteps": [
                                    "Recordar a identidade de Bezout e fatorizações coprimes left/right da planta P = N/M.",
                                    "Derivar a forma parametrizada do controlador C = (X + D Q)(Y - N Q)^{-1}, onde Q ∈ RH∞.",
                                    "Entender que todos os controladores estabilizadores são obtidos variando Q estável.",
                                    "Identificar as funções de transferência básicas: J = [T; S] = [N; M] para o sistema nominal."
                                  ],
                                  "verification": "Derivar corretamente a expressão parametrizada de C e listar as premissas de estabilidade nominal.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Livro de Controle Avançado (e.g., Zhou, Doyle, Glover)",
                                    "Notas de aula sobre Youla-Kucera",
                                    "Software MATLAB/Simulink para visualização"
                                  ],
                                  "tips": "Comece com um exemplo simples de planta estável para fixar as ideias antes de generalizar.",
                                  "learningObjective": "Compreender a estrutura parametrizada e sua relação com estabilidade nominal.",
                                  "commonMistakes": [
                                    "Confundir fatorizações left e right coprimes",
                                    "Esquecer que Q deve ser em RH∞ para estabilidade",
                                    "Ignorar invertibilidade de Y - N Q"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Expressar Funções de Transferência Fechadas em Termos de Q",
                                  "subSteps": [
                                    "Derivar Tzw = T11 + T12 Q T21 (forma geral da parametrização).",
                                    "Calcular S = (I + P C)^{-1} = M (Y - N Q)^{-1}.",
                                    "Obter T = P C (I + P C)^{-1} = N (X + D Q) (Y - N Q)^{-1}.",
                                    "Derivar CS = C (I + P C)^{-1} = (X + D Q) (Y - N Q)^{-1}.",
                                    "Verificar consistência: T + S = I."
                                  ],
                                  "verification": "Escrever explicitamente as quatro funções Tzw, S, T e CS em termos de Q e componentes coprimes.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Folha de derivações simbólicas",
                                    "MATLAB Symbolic Toolbox",
                                    "Referência: Skogestad & Postlethwaite"
                                  ],
                                  "tips": "Use a forma de coprimes right para simplificar cálculos; desenhe blocos de sinal para visualizar.",
                                  "learningObjective": "Expressar analiticamente as respostas fechadas parametrizadas.",
                                  "commonMistakes": [
                                    "Erro na propagação de Q nas expressões",
                                    "Confundir T (complementary sensitivity) com Tzw",
                                    "Omitir termos de denominação compartilhada"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar Estabilidade Individual das Funções em Termos de Q",
                                  "subSteps": [
                                    "Verificar que cada função é produto de fatores nominais estáveis (em RH∞) e Q ∈ RH∞.",
                                    "Confirmar para S: M estável, (Y - N Q)^{-1} estável pois Y - N Q é unitário em RH∞.",
                                    "Analisar T: N estável, (X + D Q) estável, denominação estável.",
                                    "Estender para Tzw e CS, notando que numeradores e denominadores permanecem estáveis.",
                                    "Usar propriedades de RH∞: soma/produto de estáveis é estável."
                                  ],
                                  "verification": "Provar que poles e zeros de cada função estão no semiplano esquerdo para qualquer Q estável.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Teorema de estabilidade de sistemas em RH∞",
                                    "Exemplos numéricos em MATLAB (bode plots)"
                                  ],
                                  "tips": "Lembre-se: estabilidade interna requer todas as funções estáveis, não só a de loop fechado.",
                                  "learningObjective": "Demonstrar que estabilidade é preservada para todo Q ∈ RH∞.",
                                  "commonMistakes": [
                                    "Assumir estabilidade só pela função principal",
                                    "Ignorar cancelamentos instáveis potenciais",
                                    "Confundir estabilidade nominal com parametrizada"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Confirmar Estabilidade Interna Robusta e Realizar Verificações Finais",
                                  "subSteps": [
                                    "Definir estabilidade interna: todas as funções Tzw, S, T, CS estáveis.",
                                    "Provar robustez: variação de Q em RH∞ mantém todas estáveis.",
                                    "Simular numericamente com diferentes Q para validar.",
                                    "Discutir implicações: conjunto completo de controladores estabilizadores.",
                                    "Documentar prova em relatório curto."
                                  ],
                                  "verification": "Gerar plots de Bode para 3 Q diferentes mostrando ausência de polos instáveis.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "MATLAB Control System Toolbox",
                                    "Templates de simulação Youla"
                                  ],
                                  "tips": "Teste com Q=0 (controlador nominal) primeiro para benchmark.",
                                  "learningObjective": "Garantir e validar estabilidade robusta parametrizada.",
                                  "commonMistakes": [
                                    "Focar só em ganho, ignorar fase/polos",
                                    "Usar Q não-estável acidentalmente",
                                    "Não verificar todas as quatro funções"
                                  ]
                                }
                              ],
                              "practicalExample": "Para P(s) = 1/(s+1), fatorizações coprimes right: N=1/(s+1), M=1. Escolha X=1, D=0, Y=1/s+1 (aprox.). Então C = (1)/(1/s+1 - (1/(s+1))Q). Compute S, T, etc., e mostre estabilidade para Q(s)=1/(s+2) ∈ RH∞ via simulação MATLAB: todos os plots Bode sem cruzamentos de fase crítica.",
                              "finalVerifications": [
                                "Lista corretamente as expressões de Tzw, S, T, CS em termos de Q.",
                                "Prova analiticamente estabilidade para Q genérico em RH∞.",
                                "Simula com pelo menos 2 Q diferentes sem instabilidades.",
                                "Explica robustez à variação de Q.",
                                "Identifica corretamente estabilidade interna vs. saída-estabilidade."
                              ],
                              "assessmentCriteria": [
                                "Precisão e completude das derivações (30%)",
                                "Correta análise de estabilidade usando RH∞ (25%)",
                                "Qualidade das simulações e plots (20%)",
                                "Clareza na explicação de robustez (15%)",
                                "Identificação de erros comuns evitados (10%)"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria de Funções Analíticas e RH∞",
                                "Programação: Simulações em MATLAB/Simulink para validação",
                                "Otimização: Escolha de Q para desempenho ótimo",
                                "Física: Modelagem de sistemas dinâmicos lineares"
                              ],
                              "realWorldApplication": "Em controle de aeronaves (e.g., fly-by-wire), garante que famílias de controladores parametrizados permaneçam estáveis apesar de variações em ganhos ou perturbações, permitindo design robusto sem revalidação completa."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "76.6.4.4.2",
                        "name": "Síntese de Controladores com Especificações de Desempenho",
                        "description": "Aplicação da parametrização para atender especificações de desempenho como rastreamento de referências, rejeição de distúrbios e ruído, via escolha de pesos de desempenho e otimização de Q.",
                        "specificSkills": [
                          {
                            "id": "76.6.4.4.2.1",
                            "name": "Definir pesos de desempenho na forma padrão",
                            "description": "Especificar os pesos Wp para erro de rastreamento, We para rejeição de distúrbios e Wu para esforço de controle na estrutura de forma padrão, traduzindo requisitos temporais e frequenciais em normas H∞.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar e documentar requisitos de desempenho temporais e frequenciais",
                                  "subSteps": [
                                    "Identifique os requisitos de rastreamento (ex.: overshoot < 10%, tempo de estabilização < 2s).",
                                    "Liste especificações de rejeição de distúrbios (ex.: atenuação > 20dB em baixas frequências).",
                                    "Defina limites para esforço de controle (ex.: |u| < 1 em regime permanente).",
                                    "Registre requisitos em domínio da frequência (crossover frequency ω_c, roll-off).",
                                    "Crie um diagrama de Bode preliminar para visualizar specs."
                                  ],
                                  "verification": "Lista completa de requisitos documentada e alinhada com especificações do sistema.",
                                  "estimatedTime": "1 hora",
                                  "materials": "Folha de papel ou software como MATLAB para diagramas de Bode; referência de requisitos do problema.",
                                  "tips": "Priorize requisitos críticos do cliente; use templates padrão de specs H∞.",
                                  "learningObjective": "Compreender como specs tempo-frequência guiam o design de pesos.",
                                  "commonMistakes": "Ignorar trade-offs entre requisitos ou confundir domínio tempo com frequência."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Especificar peso Wp para erro de rastreamento",
                                  "subSteps": [
                                    "Escolha forma de Wp (ex.: ordem 1 ou 2) baseada em ω_c e overshoot desejado.",
                                    "Defina ganho em baixa frequência para minimizar erro DC: |Wp(0)| = 1/erro_max.",
                                    "Ajuste polo/zero para matching temporal: ω_p ≈ 1/tempo_estab.",
                                    "Valide com plot de magnitude: |Wp(jω)| alto em ω < ω_c, baixo em ω > ω_c.",
                                    "Simule sensibilidade S = 1/(1 + P C) e verifique ||Wp S||_∞ < 1."
                                  ],
                                  "verification": "Gráfico de Bode de Wp mostra amplificação adequada do erro em banda de interesse.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": "MATLAB/Simulink com toolbox Control System; funções bode(), tf().",
                                  "tips": "Comece com Wp(s) = (s/M + ω_b)/(s + ω_b A), onde M=2, A=1/1000.",
                                  "learningObjective": "Traduzir specs de tracking em peso H∞ que penaliza erro em banda.",
                                  "commonMistakes": "Wp com ganho muito alto causando instabilidade ou muito baixo ignorando erro."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Especificar peso We para rejeição de distúrbios",
                                  "subSteps": [
                                    "Analise modelo de distúrbio (ex.: passo em entrada, ruído em saída).",
                                    "Defina We alto em baixas frequências: |We(0)| = 1/dist_max.",
                                    "Coloque zeros/polos para roll-off: ω_z ≈ ω_c / 10 para rejeição em DC.",
                                    "Garanta |We(jω)| decrescente em altas frequências para evitar amplificação de ruído.",
                                    "Verifique KS = P/(1 + P C) com ||We KS||_∞ < 1 via simulação."
                                  ],
                                  "verification": "Simulação mostra atenuação de distúrbio conforme specs em domínio tempo/freq.",
                                  "estimatedTime": "1 hora",
                                  "materials": "MATLAB com sysic toolbox para análise de sensibilidade; exemplos de plantas P(s).",
                                  "tips": "Use We(s) = k / (s/ω_l + 1) para distúrbios lentos.",
                                  "learningObjective": "Modelar rejeição de distúrbios via peso que molda KS.",
                                  "commonMistakes": "We muito agressivo em altas freq., amplificando ruído de sensor."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Especificar peso Wu para esforço de controle",
                                  "subSteps": [
                                    "Estime magnitude máxima de u baseada em atuador (ex.: |u|_max = 10V).",
                                    "Defina Wu = w_u / (τ_u s + 1) com w_u = 1/|u|_max, τ_u pequeno para suavidade.",
                                    "Ajuste para penalizar alto ganho em baixas freq.: |Wu(jω)| constante em banda.",
                                    "Verifique T = C P / (1 + C P) e ||Wu T||_∞ < 1.",
                                    "Balance trade-offs com Wp/We ajustando escalas."
                                  ],
                                  "verification": "Resposta em malha fechada mostra u dentro de limites em simulações.",
                                  "estimatedTime": "1 hora",
                                  "materials": "MATLAB; funções norm(), sigma() para normas H∞.",
                                  "tips": "wu pequeno permite controle agressivo; teste com step responses.",
                                  "learningObjective": "Limitar esforço via peso que normaliza sinal de controle.",
                                  "commonMistakes": "Wu muito baixo levando a saturação ou muito alto subdesempenho."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Montar estrutura padrão e validar pesos",
                                  "subSteps": [
                                    "Monte G = [Wp 0; We P; Wu K] no framework padrão H∞.",
                                    "Compute normas H∞: max |Wp S|_∞, |We KS|_∞, |Wu T|_∞ devem ser <1.",
                                    "Ajuste iterativamente pesos para γ <1.",
                                    "Simule sistema fechado com controladores sintetizados.",
                                    "Documente justificativas e plots finais."
                                  ],
                                  "verification": "Todas normas H∞ <1 e specs tempo atendidas em simulações.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": "MATLAB Robust Control Toolbox; hinfsyn() para síntese.",
                                  "tips": "Use mu-toolbox se disponível para análise μ; itere com scaling.",
                                  "learningObjective": "Integrar pesos em síntese H∞ e validar estrutura completa.",
                                  "commonMistakes": "Esquecer normalização ou inconsistências de fase nos pesos."
                                }
                              ],
                              "practicalExample": "Para um sistema massa-mola-amortecedor P(s)=1/(s^2 + 0.1s +1), defina Wp para tracking com ω_c=10 rad/s, We para rejeição de distúrbio em ω<1 rad/s, Wu para |u|<5. Simule step response mostrando overshoot<5%, settling<1s, u sem saturação.",
                              "finalVerifications": [
                                "Normas H∞ de Wp S_∞ <1, We KS_∞ <1, Wu T_∞ <1.",
                                "Respostas temporais atendem todas specs (overshoot, settling, steady-state).",
                                "Gráficos de Bode mostram shaping correto de sensibilidade.",
                                "Simulações com distúrbios/ruído reais performam bem.",
                                "Trade-offs balanceados: bom tracking sem esforço excessivo.",
                                "Documentação inclui equações, plots e justificativas."
                              ],
                              "assessmentCriteria": [
                                "Precisão na tradução de specs tempo-freq. para pesos (90% match).",
                                "Justificativa teórica clara para formas e parâmetros de cada peso.",
                                "Validação numérica via normas H∞ e simulações (γ<1).",
                                "Identificação correta de trade-offs e ajustes iterativos.",
                                "Qualidade dos plots e documentação (legíveis, anotados).",
                                "Criatividade em exemplos práticos e conexões reais."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Análise de funções de transferência e normas em espaços de Hardy.",
                                "Programação: Implementação em MATLAB para síntese e análise robusta.",
                                "Física: Modelagem dinâmica de sistemas mecatrônicos.",
                                "Estatística: Análise de robustez a incertezas paramétricas."
                              ],
                              "realWorldApplication": "Em automação industrial, como controle de posição de robôs (ex.: ABB IRB), onde Wp garante precisão de tracking, We rejeita vibrações de fábrica, e Wu evita desgaste de motores, otimizando produção em linhas de montagem automotiva."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "76.6.4.4.2.2",
                            "name": "Projetar Q via otimização de loop shaping",
                            "description": "Usar técnicas de loop shaping para moldar a função de malha aberta L(s) = P C(s), selecionando Q de baixa ordem para minimizar ||Tzw||∞ < γ, com iterações manuais ou algorítmicas em MATLAB.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar o modelo do sistema e definir especificações de desempenho",
                                  "subSteps": [
                                    "Identificar e modelar a planta P(s) a partir de dados experimentais ou equações diferenciais.",
                                    "Definir as funções de peso W_e(s) para erro de rastreamento e W_u(s) para esforço de controle.",
                                    "Estabelecer o valor alvo γ para a norma H-infinito ||Tzw||∞ < γ.",
                                    "Verificar a estabilidade e analisabilidade do modelo P(s) usando ferramentas como bode plot.",
                                    "Documentar as especificações de desempenho desejadas (ex.: overshoot < 10%, tempo de assentamento < 2s)."
                                  ],
                                  "verification": "Modelo P(s) simulado no MATLAB responde corretamente a entradas unitárias e γ inicial estimado.",
                                  "estimatedTime": "1-2 horas",
                                  "materials": [
                                    "MATLAB",
                                    "Control System Toolbox",
                                    "Documentação do sistema físico"
                                  ],
                                  "tips": "Comece com um modelo de baixa ordem para simplificar; use tf() ou ss() para representar P(s).",
                                  "learningObjective": "Compreender a modelagem do sistema e especificações para síntese robusta.",
                                  "commonMistakes": [
                                    "Ignorar não-linearidades iniciais",
                                    "Escolher pesos inadequados sem justificativa",
                                    "Não normalizar entradas/saídas"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Projetar filtros de loop shaping para moldar L(s) = P(s)K(s)",
                                  "subSteps": [
                                    "Escolher pré-compensador W1(s) para aumentar ganhos em baixas frequências (rastreamento).",
                                    "Selecionar pós-compensador W2(s) para rolar off em altas frequências (rejeição de ruído).",
                                    "Plotar o diagrama de Nichols ou singular values de L_shaped(s) = W1 P W2.",
                                    "Ajustar manualmente os filtros até que |L(jω)| ≈ 1 na banda de crossover desejada.",
                                    "Verificar margens de ganho e fase no loop shaped."
                                  ],
                                  "verification": "Diagrama de Nichols mostra loop shaping com margens adequadas (>6dB ganho, >45° fase).",
                                  "estimatedTime": "2-3 horas",
                                  "materials": [
                                    "MATLAB Robust Control Toolbox",
                                    "Funções nichols(), sigma()"
                                  ],
                                  "tips": "Use plantas integradoras para W1 e filtros passa-baixa para W2; itere com loopgain().",
                                  "learningObjective": "Dominar técnicas de loop shaping para especificações de desempenho.",
                                  "commonMistakes": [
                                    "Filtros de ordem alta desnecessária",
                                    "Ignorar picos de ressonância",
                                    "Não centralizar o crossover"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Parametrizar o controlador com Q de baixa ordem",
                                  "subSteps": [
                                    "Calcular o controlador central K_s = W2 inv(P) W1 para o loop shaped.",
                                    "Normalizar o sistema: definir G = [W_e P; I K_s] e J = [-K_s I].",
                                    "Inicializar Q(s) como polinômio de ordem baixa (ex.: 2-4) via hankel singular values.",
                                    "Formar o sistema generalizado para otimização: Tzw = F_l(G, Q).",
                                    "Implementar em MATLAB com uss() ou lti para estruturas."
                                  ],
                                  "verification": "Q inicial estabiliza o loop e ||Tzw||∞ computado < 2γ.",
                                  "estimatedTime": "1-2 horas",
                                  "materials": [
                                    "MATLAB Robust Control Toolbox",
                                    "hinfsyn(), lft()"
                                  ],
                                  "tips": "Mantenha ordem(Q) baixa para viabilidade computacional; use balreal() para redução.",
                                  "learningObjective": "Entender parametrização Q-parameter e sistemas lineares fracionados.",
                                  "commonMistakes": [
                                    "Q de ordem alta levando a controladores irreais",
                                    "Normalização incorreta de G/J",
                                    "Esquecer normalização γ=1"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Otimizar Q minimizando ||Tzw||∞ via iterações em MATLAB",
                                  "subSteps": [
                                    "Executar otimização H-infinito com hinfsyn() ou loop manual com invfreqs().",
                                    "Iterar: ajustar coeficientes de Q para reduzir gamma via fmincon() ou grid search.",
                                    "Simular respostas temporais do sistema fechado com step(), lsim().",
                                    "Verificar robustez com variações em P(s) (±20% parâmetros).",
                                    "Refinar Q até ||Tzw||∞ < γ alvo."
                                  ],
                                  "verification": "norm(hinf(Tzw), inf) < γ e simulações mostram bom desempenho.",
                                  "estimatedTime": "2-4 horas",
                                  "materials": [
                                    "MATLAB Optimization Toolbox",
                                    "hinfsyn(), hinfstruct()"
                                  ],
                                  "tips": "Use gamma iteration automático; monitore cond number para numerics.",
                                  "learningObjective": "Aplicar algoritmos de otimização para síntese de controladores robustos.",
                                  "commonMistakes": [
                                    "Convergência local em mínimos ruins",
                                    "Não testar robustez",
                                    "Ignorar violações de saturação"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Validar, iterar e implementar o controlador Q otimizado",
                                  "subSteps": [
                                    "Analisar sensibilidade e complementaridade: plot T, S, KS.",
                                    "Simular em Simulink com atuadores reais e ruído.",
                                    "Comparar com baseline (ex.: PID) em métricas de desempenho.",
                                    "Ajustar iterações se γ excedido ou desempenho ruim.",
                                    "Gerar código embarcado ou relatório final."
                                  ],
                                  "verification": "Sistema fechado atende todas specs em simulação e análise de robustez.",
                                  "estimatedTime": "1-2 horas",
                                  "materials": [
                                    "Simulink",
                                    "Control System Tuner"
                                  ],
                                  "tips": "Sempre valide em tempo real se possível; documente trade-offs.",
                                  "learningObjective": "Avaliar e refinar controladores para aplicações práticas.",
                                  "commonMistakes": [
                                    "Sobre-otimização para nominal ignorando robustez",
                                    "Esquecer delays ou não-minimum phase"
                                  ]
                                }
                              ],
                              "practicalExample": "Para um motor DC de velocidade (P(s) = 1/(s+1)), defina W_e=1/(s+0.1), W_u=0.1, γ=1.5. Shape L com crossover em 1 rad/s, otimize Q ordem 2 até γ<1.2, simulando rastreamento de rampa com ruído.",
                              "finalVerifications": [
                                "||Tzw||∞ < γ especificado",
                                "Margens de estabilidade >6dB ganho e >45° fase",
                                "Respostas temporais: overshoot <15%, settling time <3s",
                                "Robustez: desempenho mantido com ±20% variação em P(s)",
                                "Q de ordem baixa (≤4) e implementável",
                                "Esforço de controle u(t) dentro de limites físicos"
                              ],
                              "assessmentCriteria": [
                                "Precisão na modelagem e shaping do loop (singular values adequados)",
                                "Eficiência na otimização (γ reduzido em <10 iterações)",
                                "Baixa ordem de Q e controller C(s)",
                                "Análises completas: tempo/freq/domínio robustez",
                                "Documentação clara com plots e justificativas",
                                "Capacidade de iterar para specs mais rigorosas"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria de normas H-infinito e otimização convexa",
                                "Programação: Algoritmos numéricos em MATLAB/Simulink",
                                "Física: Modelagem dinâmica de sistemas mecatrônicos",
                                "Engenharia de Software: Validação e testes unitários",
                                "Estatística: Análise de Monte Carlo para robustez"
                              ],
                              "realWorldApplication": "Aplicado em controle robusto de drones (estabilização apesar de vento), veículos autônomos (rejeição de distúrbios) e processos químicos (controle de nível com incertezas de modelo), garantindo desempenho sob variações paramétricas."
                            },
                            "estimatedTime": "2.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "76.6.4.4.2.3",
                            "name": "Avaliar desempenho do controlador sintetizado",
                            "description": "Simular respostas temporais e diagramas de Bode do sistema fechado para validar margens de ganho/fase, tempo de assentamento e overshoot, ajustando Q iterativamente para atender specs.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar o modelo do sistema fechado com controlador sintetizado",
                                  "subSteps": [
                                    "Definir o modelo do laço fechado combinando planta G(s) e controlador C(s).",
                                    "Implementar o controlador usando os parâmetros Q otimizados da síntese anterior.",
                                    "Configurar entradas de simulação (degrau unitário para resposta temporal).",
                                    "Verificar estabilidade inicial via pólo-zero ou root locus.",
                                    "Salvar o modelo para reutilização em simulações."
                                  ],
                                  "verification": "Modelo simula sem erros e mostra resposta estável para entrada degrau.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "MATLAB/Simulink ou Python (biblioteca control-systems), funções tf/sys.",
                                  "tips": "Use feedback() no MATLAB para laço fechado rápido.",
                                  "learningObjective": "Construir e validar modelo de sistema fechado corretamente.",
                                  "commonMistakes": "Esquecer sinal negativo no realimentação ou unidades inconsistentes."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Simular e analisar respostas temporais",
                                  "subSteps": [
                                    "Executar simulação de resposta ao degrau com tempo de simulação adequado (5x tempo de assentamento estimado).",
                                    "Extrair métricas: tempo de assentamento (2% ou 5%), overshoot percentual, tempo de subida.",
                                    "Plotar resposta temporal com grid e rótulos claros.",
                                    "Comparar métricas com especificações de desempenho (ex: overshoot < 10%).",
                                    "Anotar discrepâncias iniciais."
                                  ],
                                  "verification": "Gráficos mostram métricas extraídas corretamente e comparadas às specs.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "step() ou lsim() no MATLAB/Python, funções stepinfo().",
                                  "tips": "Aumente precisão numérica com RelTol=1e-6 para simulações precisas.",
                                  "learningObjective": "Interpretar e quantificar desempenho temporal do sistema.",
                                  "commonMistakes": "Usar critério errado para assentamento (ex: 1% vs 2%) ou escala inadequada no plot."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Gerar e analisar diagramas de Bode do sistema fechado",
                                  "subSteps": [
                                    "Calcular funções de transferência de malha aberta e fechada.",
                                    "Plotar diagramas de Bode (magnitude e fase) para laço aberto e sensibilidade.",
                                    "Medir margens de ganho (GM) e fase (PM) automaticamente.",
                                    "Identificar frequências de cruzamento e picos de ressonância.",
                                    "Verificar se GM > 6dB e PM > 45° conforme specs típicas."
                                  ],
                                  "verification": "Diagramas Bode plotados com margens anotadas e valores numéricos corretos.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "bode() ou bode_plot() no MATLAB/Python.",
                                  "tips": "Use margin() para extração automática de GM/PM.",
                                  "learningObjective": "Avaliar robustez via análise em frequência.",
                                  "commonMistakes": "Confundir Bode de laço aberto com fechado ou ignorar fase wrap-around."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Ajustar Q iterativamente e validar desempenho final",
                                  "subSteps": [
                                    "Identificar violações de specs (ex: overshoot alto → aumentar penalidade em Q para damping).",
                                    "Modificar matriz Q (ex: escalar elementos de estado de erro/derivada).",
                                    "Re-sintetizar controlador LQR e repetir simulações 2-3 iterações.",
                                    "Documentar mudanças em Q e melhorias nas métricas.",
                                    "Confirmar todas specs atendidas (temporal + frequência)."
                                  ],
                                  "verification": "Relatório final com tabelas comparativas pré/pós-ajuste mostrando conformidade.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "lqr() função, planilhas para tracking de iterações.",
                                  "tips": "Comece com ajustes pequenos (fator 1.5-2x) para convergência rápida.",
                                  "learningObjective": "Otimizar trade-offs de desempenho via iteração em Q.",
                                  "commonMistakes": "Ajustes drásticos em Q levando a instabilidade ou oscilações."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Documentar avaliação e gerar relatório",
                                  "subSteps": [
                                    "Compilar gráficos, tabelas de métricas e valores de Q final.",
                                    "Escrever conclusões sobre adequação às specs.",
                                    "Exportar simulações para PDF ou notebook Jupyter.",
                                    "Arquivar modelo validado para uso futuro.",
                                    "Preparar apresentação resumida (1 slide por análise)."
                                  ],
                                  "verification": "Relatório completo com evidências visuais e numéricas de sucesso.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "publish() MATLAB ou Jupyter notebook.",
                                  "tips": "Use legendas descritivas e units consistentes em todos plots.",
                                  "learningObjective": "Comunicar resultados de avaliação de forma profissional.",
                                  "commonMistakes": "Omitir unidades ou baselines de comparação."
                                }
                              ],
                              "practicalExample": "Para um servo-motor DC com G(s) = 1/(s(s+1)), specs: overshoot <10%, assentamento <2s, PM>50°. Síntese inicial com Q=diag([1,1]) dá overshoot=15%; ajuste Q=[10,1] reduz para 8%, GM=8dB.",
                              "finalVerifications": [
                                "Resposta temporal atende tempo de assentamento e overshoot specs.",
                                "Margens de ganho e fase excedem mínimos requeridos.",
                                "Nenhuma instabilidade ou oscilação persistente observada.",
                                "Métricas consistentes em múltiplas simulações (ruído/entradas).",
                                "Q final documentado com justificativa de ajustes.",
                                "Gráficos legíveis com anotações precisas."
                              ],
                              "assessmentCriteria": [
                                "Precisão das simulações e extração de métricas (90%+ correção).",
                                "Qualidade da análise e interpretação de resultados.",
                                "Eficácia dos ajustes iterativos em Q para specs.",
                                "Completude da documentação e relatórios.",
                                "Uso correto de ferramentas e avoidance de erros comuns.",
                                "Criatividade em conexões com aplicações reais."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Análise de sistemas lineares e transformadas de Laplace.",
                                "Programação: Scripts de automação em MATLAB/Python para simulações.",
                                "Física: Dinâmica de sistemas mecânicos/elétricos.",
                                "Estatística: Análise de variância em simulações com ruído."
                              ],
                              "realWorldApplication": "Em automação industrial, validar controladores LQR para robôs industriais garantindo precisão em posicionamento sem overshoot excessivo, evitando colisões e otimizando ciclos de produção."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "76.6.4.4.2.4",
                            "name": "Implementar síntese em MATLAB",
                            "description": "Utilizar funções como coprime, lcf, selectyula do Robust Control Toolbox para gerar e refinar Q, computando o controlador C e analisando o γ ótimo.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar o modelo do sistema e realizar fatoração coprime",
                                  "subSteps": [
                                    "Carregue o modelo da planta G no MATLAB usando tf ou ss.",
                                    "Execute a função coprime(G) para obter as fatorações coprime M, N, V, U.",
                                    "Verifique as propriedades das fatorações com norm(M*V - N*U) ≈ 0.",
                                    "Salve as matrizes em variáveis workspace.",
                                    "Plote as respostas em frequência de G, M, N para inspeção inicial."
                                  ],
                                  "verification": "Confirme que coprime() retorna M, N estáveis e bezout identity holds (norm(M*V - N*U) < 1e-10).",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "MATLAB com Robust Control Toolbox",
                                    "Modelo exemplo de planta G (ex: tf([1 1],[1 2 1]))"
                                  ],
                                  "tips": "Use opções de coprime como 'facname','right' para fatoração direita se necessário.",
                                  "learningObjective": "Entender e aplicar fatoração coprime para parametrização de controladores estabilizadores.",
                                  "commonMistakes": [
                                    "Não verificar estabilidade de M,N",
                                    "Usar modelo instável sem estabilização prévia",
                                    "Ignorar tipo de fatoração (left/right)"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Configurar a identidade de Bezout usando lcf",
                                  "subSteps": [
                                    "Use lcf para construir o sistema linear fracionário que representa a parametrização.",
                                    "Defina o sistema P = [M; V] e J = [-N U] ou configuração apropriada.",
                                    "Execute lcf(P, Q) para obter a planta parametrizada.",
                                    "Teste com Q=0 para recuperar o controlador central inicial.",
                                    "Verifique estabilidade fechada com feedback."
                                  ],
                                  "verification": "Com Q=0, o loop fechado deve ser estável e coincidir com o controlador central.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Função lcf do Robust Control Toolbox",
                                    "Variáveis M,N,V,U do step anterior"
                                  ],
                                  "tips": "lcf é útil para encapsular a parametrização; especifique entradas/saídas corretamente.",
                                  "learningObjective": "Dominar o uso de lcf para estruturar a parametrização Youla-Kucera.",
                                  "commonMistakes": [
                                    "Configuração errada de portas em lcf",
                                    "Não normalizar pesos para γ=1 inicialmente",
                                    "Esquecer de definir Q como sistema estável"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Projetar e refinar Q usando selectyula",
                                  "subSteps": [
                                    "Defina pesos de desempenho Wp e robustez Wu.",
                                    "Execute selectyula para sintetizar Q ótimo minimizando γ.",
                                    "Analise o γ inicial e itere refinando ordens de Q ou pesos.",
                                    "Plote singular values de Tzw para visualizar trade-offs.",
                                    "Salve o Q ótimo selecionado."
                                  ],
                                  "verification": "γ deve ser próximo de 1 ou especificação desejada; verifique convergence de selectyula.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Função selectyula",
                                    "Pesos Wp, Wu como tf/ss"
                                  ],
                                  "tips": "Comece com Q baixo ordem; use musyn para H-infinity se selectyula não convergir.",
                                  "learningObjective": "Aplicar selectyula para otimização de Q na síntese H-infinity via Youla.",
                                  "commonMistakes": [
                                    "Pesos mal escalados levando a γ>>1",
                                    "Q de ordem alta causando il-condicionamento",
                                    "Não plotar para validar trade-offs"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Computar o controlador C a partir de Q",
                                  "subSteps": [
                                    "Use fórmula C = (U + M*Q) / (V + N*Q) com rdiv/ldiv para evitar inversão numérica.",
                                    "Ou use lcf invertido: C = lcf([U M], Q, [V N], 'type','feedback').",
                                    "Verifique ordem de C e reduza com balred se necessário.",
                                    "Teste estabilidade fechada com feedback(G*C,1).",
                                    "Exporte C para Simulink ou código."
                                  ],
                                  "verification": "Loop fechado estável, margens de ganho/fase >6dB/45°.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Funções rdiv, ldiv ou lcf",
                                    "Q ótimo, M,N,U,V"
                                  ],
                                  "tips": "Use rdiv para divisão pela direita estável; prefira formas normalizadas.",
                                  "learningObjective": "Calcular C explicitamente da parametrização e validar.",
                                  "commonMistakes": [
                                    "Inversão direta causando numérica instabilidade",
                                    "Fórmula errada de C",
                                    "Não checar ordem excessiva"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Analisar o γ ótimo e desempenho do controlador",
                                  "subSteps": [
                                    "Compute γ = hinfnorm(Tzw) com Tzw do lcf.",
                                    "Gere step responses, Bode plots para G*C.",
                                    "Compare com especificações: overshoot <20%, settling <5s.",
                                    "Sensitize com usample para robustez.",
                                    "Documente resultados em relatório com figures."
                                  ],
                                  "verification": "γ ≤1.2, todos plots atendem specs.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "hinfnorm, step, bode, sigma do Control System Toolbox"
                                  ],
                                  "tips": "Use grid para plots claros; salve figures com saveas.",
                                  "learningObjective": "Interpretar γ e validar desempenho global.",
                                  "commonMistakes": [
                                    "Analisar só G*C sem Tzw",
                                    "Ignorar γ em frequência crítica",
                                    "Escalas erradas em plots"
                                  ]
                                }
                              ],
                              "practicalExample": "Para um sistema de posição de motor DC modelado como G = tf(1000,[1 100 10000]), defina Wp = tf(1,[1 10]), Wu = 0.1. Use coprime para fatorar, selectyula para Q com γ<1.1, compute C e verifique step response com settling time <0.5s.",
                              "finalVerifications": [
                                "Fatorações coprime corretas com bezout identity.",
                                "Q sintetizado via selectyula com γ ótimo documentado.",
                                "Controlador C estabiliza G com margens adequadas.",
                                "Análise de Tzw confirma ||Tzw||∞ = γ.",
                                "Plots de resposta temporal e frequência atendem specs.",
                                "Código MATLAB reproduzível e comentado."
                              ],
                              "assessmentCriteria": [
                                "Precisão na fatoração coprime e uso de lcf (30%).",
                                "Qualidade da síntese Q com selectyula e γ mínimo (25%).",
                                "Correção no cálculo de C e estabilidade (20%).",
                                "Análise completa de desempenho e γ (15%).",
                                "Clareza de código, plots e documentação (10%)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Álgebra linear (fatorizações, normas) e otimização convexa.",
                                "Programação: MATLAB scripting, toolboxes e debugging numérico.",
                                "Física: Dinâmica de sistemas e controle de plantas reais.",
                                "Engenharia de Software: Validação e testes unitários em simulações."
                              ],
                              "realWorldApplication": "Síntese de controladores H-infinity para drones (controle de atitude robusto a ventos), automação industrial (servomotores com variações de carga) e veículos autônomos (controle de trajetória com incertezas de modelo)."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "76.6.4.4.3",
                        "name": "Síntese para Robustez frente a Incertezas",
                        "description": "Incorporação de modelos de incerteza na parametrização para garantir robustez, utilizando normas estruturadas e síntese H∞ em sistemas LIT escalares.",
                        "specificSkills": [
                          {
                            "id": "76.6.4.4.3.1",
                            "name": "Modelar incertezas aditivas e multiplicativas",
                            "description": "Representar incertezas na planta como Δadd ou Δmul, normalizando com pesos Wr e Wi para formar a estrutura padrão de robustez, e verificar estabilidade robusta via pequeno ganho.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender e Identificar Incertezas Aditivas e Multiplicativas",
                                  "subSteps": [
                                    "Defina incerteza aditiva (Δadd) como perturbação absoluta na planta P(s), representada como P(s) + Δadd(s).",
                                    "Defina incerteza multiplicativa (Δmul) como variação relativa, representada como P(s)(1 + Δmul(s)).",
                                    "Identifique exemplos em sistemas reais: Δadd para ruído de sensor, Δmul para variação de parâmetros como ganho ou tempo morto.",
                                    "Diferencie Δadd (não afeta DC gain) de Δmul (afeta DC gain).",
                                    "Esboce diagramas de bloco para ambas as incertezas na planta nominal P(s)."
                                  ],
                                  "verification": "Crie diagramas de bloco corretos para um sistema dado com ambas as incertezas e explique diferenças.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Livro de controle avançado (ex: Skogestad), MATLAB/Simulink para esboços",
                                    "Folhas de papel e caneta para diagramas"
                                  ],
                                  "tips": "Sempre comece com a planta nominal e adicione setas para Δadd e Δmul para visualizar impacto.",
                                  "learningObjective": "Distinguir e representar conceitualmente incertezas aditivas e multiplicativas em plantas de transferência.",
                                  "commonMistakes": [
                                    "Confundir Δadd com Δmul invertendo representações",
                                    "Ignorar que Δmul escala com P(s)",
                                    "Não considerar frequência em exemplos"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Selecionar e Projetar Pesos de Normalização Wr e Wi",
                                  "subSteps": [
                                    "Escolha Wr(s) para normalizar Δmul: |Wr(jω)| deve upper-bound |Δmul(jω)| em todas as frequências.",
                                    "Escolha Wi(s) para normalizar Δadd: |Wi(jω) P(jω)| deve upper-bound |Δadd(jω)|.",
                                    "Use dados experimentais ou bounds conhecidos para moldar Wr e Wi (ex: 1º ordem para roll-off).",
                                    "Verifique normalização plotando |Δmul Wr| < 1 e |Δadd Wi P| < 1 em Bode plot.",
                                    "Ajuste pesos iterativamente para cobrir pior caso sem conservadorismo excessivo."
                                  ],
                                  "verification": "Gere plots de Bode mostrando que as incertezas normalizadas ficam dentro do disco unitário.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "MATLAB com Control System Toolbox",
                                    "Dados de incerteza simulados ou reais"
                                  ],
                                  "tips": "Comece com pesos simples (constantes ou 1º ordem) e refine baseado em simulações de Monte Carlo.",
                                  "learningObjective": "Projetar pesos Wr e Wi que normalizem adequadamente as incertezas para análise de robustez.",
                                  "commonMistakes": [
                                    "Escolher pesos muito conservadores levando a controladores ruins",
                                    "Esquecer de multiplicar Wi por P para Δadd",
                                    "Não checar em todas as frequências"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Formar a Estrutura Padrão de Robustez (MΔN)",
                                  "subSteps": [
                                    "Monte a estrutura padrão: interconexão com bloco Δ = [Δmul; Δadd] normalizado.",
                                    "Defina M(s) como função de transferência da planta nominal para Δmul e Δadd, e N(s) como complemento.",
                                    "Use convenção padrão: para multiplicativa, M = -K(I+PK)^-1 P Wr; para aditiva, ajuste accordingly.",
                                    "Implemente em MATLAB usando funções como lft ou mussv para formar MΔN.",
                                    "Valide a estrutura plotando singular values de M e N."
                                  ],
                                  "verification": "Construa o modelo lft(M, Delta, N) no MATLAB sem erros e plote respostas.",
                                  "estimatedTime": "2.5 horas",
                                  "materials": [
                                    "MATLAB Robust Control Toolbox",
                                    "Templates de código para lft"
                                  ],
                                  "tips": "Padronize sinais: entrada para Δ é saída de M, saída de Δ é entrada para N.",
                                  "learningObjective": "Construir a interconexão linear fracionária (LFT) para análise de robustez.",
                                  "commonMistakes": [
                                    "Erros de sinal na definição de M (sinal negativo para feedback)",
                                    "Confundir ordem de blocos Δmul vs Δadd",
                                    "Não normalizar antes de formar LFT"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificar Estabilidade Robusta com Critério de Pequeno Ganho",
                                  "subSteps": [
                                    "Lembre o teorema: sistema estável para todo Δ com ||Δ||∞ < 1 se μ(M(jω)) < 1 para todo ω.",
                                    "Calcule structured singular value μ(M) ou use upper bound via mussv.",
                                    "Plote μ(M(jω)) e verifique se max < 1 (estável) ou identifique frequências críticas.",
                                    "Se μ > 1, ajuste pesos ou controlador e reavalie.",
                                    "Simule com Δ reais no limite para validar."
                                  ],
                                  "verification": "Gere plot de μ(M) com μ_max < 1 e simule estabilidade para Δ = 0.9 * worst-case.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "MATLAB com Robust Control Toolbox (mussv)",
                                    "Computador com licença"
                                  ],
                                  "tips": "Use mu-analysis tools; para Δ escalar, μ = \bar{σ}(M).",
                                  "learningObjective": "Aplicar critério de pequeno ganho para certificar robustez.",
                                  "commonMistakes": [
                                    "Usar σ_max em vez de μ para Δ estruturado",
                                    "Ignorar fase em plots de μ",
                                    "Não testar com simulações de pior caso"
                                  ]
                                }
                              ],
                              "practicalExample": "Considere um motor DC com planta nominal P(s) = 1/(s+1), incerteza multiplicativa Δmul = 0.2 * 1/(1 + 0.1s) (variação de ganho/tempo), e aditiva Δadd = 0.1/(s+10) (ruído). Normalize com Wr(s) = 1.5/(0.01s+1), Wi(s) = 1.2/(s+5)/P(s), forme LFT e verifique μ(M) < 1 para controlador estabilizador.",
                              "finalVerifications": [
                                "Pode representar corretamente Δadd e Δmul em diagrama de bloco para qualquer planta dada.",
                                "Gera pesos Wr/Wi que boundam incertezas normalizadas em Bode plot.",
                                "Constrói LFT MΔN sem erros no MATLAB.",
                                "Calcula e interpreta μ(M) corretamente, confirmando robustez.",
                                "Simula sistema com incertezas extremas e verifica estabilidade.",
                                "Identifica e corrige violações de robustez ajustando pesos."
                              ],
                              "assessmentCriteria": [
                                "Precisão na representação matemática de incertezas (100% correto).",
                                "Qualidade dos pesos: cobertura sem conservadorismo excessivo (μ_max próximo de 1).",
                                "Correção na formação da LFT (sem erros de sinal ou ordem).",
                                "Interpretação precisa de μ(M): identificação de frequências críticas.",
                                "Profundidade em simulações: pelo menos 3 casos de Δ testados.",
                                "Clareza em relatórios/plots: legendas e explicações completas."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Análise de valores singulares estruturados (μ-synthesis).",
                                "Probabilidade: Modelagem de incertezas estocásticas vs determinísticas.",
                                "Física: Dinâmica de sistemas com perturbações paramétricas.",
                                "Computação: Otimização numérica em Robust Control Toolbox.",
                                "Economia/Finanças: Análise de risco e robustez em modelos econômicos."
                              ],
                              "realWorldApplication": "Em controle de aviões (incertezas aerodinâmicas Δmul), processos químicos (variações de catalisador Δadd), ou robótica industrial, garantindo estabilidade apesar de variações de fabricação ou envelhecimento, evitando falhas catastróficas."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "76.6.4.4.3.2",
                            "name": "Sintetizar controlador H∞ via parametrização",
                            "description": "Resolver o problema padrão H∞ minimizando ||Tzw||∞ com Q estável de ordem mínima, usando algoritmos riccati ou LMIs para garantir robustez e desempenho simultâneos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Modelar o Sistema e Definir o Problema Padrão H∞",
                                  "subSteps": [
                                    "Identifique a planta nominal G(s) e incertezas Δ(s) representadas em forma multiplicativa ou aditiva.",
                                    "Defina as entradas exógenas w (referências, distúrbios, ruído) e saídas de performance z (erros de rastreamento, controle u).",
                                    "Construa a planta generalizada P = [P11 P12; P21 P22] interconectando G, pesos de performance Wp, robustez Wu e sensibilidade.",
                                    "Especifique o γ alvo para ||Tzw||∞ < γ, garantindo robustez e desempenho."
                                  ],
                                  "verification": "Verifique se P está corretamente interconectada e se as dimensões de w e z são compatíveis com o problema padrão.",
                                  "estimatedTime": "1-2 horas",
                                  "materials": [
                                    "MATLAB/Simulink",
                                    "Documentação da planta física",
                                    "Livro de controle H∞ como Zhou et al."
                                  ],
                                  "tips": "Use blocos de incerteza no Simulink para visualização; priorize pesos de frequência para modelar especificações.",
                                  "learningObjective": "Compreender e formular o problema padrão H∞ para síntese de controladores robustos.",
                                  "commonMistakes": [
                                    "Esquecer de normalizar incertezas para ||Δ||∞ ≤1",
                                    "Invertar dimensões de P11, P12 etc."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Obter Parametrização de Controladores Estabilizadores via Youla-Kučera",
                                  "subSteps": [
                                    "Calcule um controlador central estabilizador C0 resolvendo Riccati para LQG ou H2.",
                                    "Coprime fatorize P22 = N/M e C0 = X/Y com fatores biproprios estáveis (use hankel singular values).",
                                    "Construa a parametrização: todos C estabilizadores são C = (Y - MQ)^{-1}(X + NQ) para Q estável.",
                                    "Expresse Tzw em termos de Q: Tzw = T1 + T2 Q T3, onde T1,T2,T3 são transfer functions estáveis."
                                  ],
                                  "verification": "Confirme que C0 estabiliza P22 e que a inversa (Y - MQ) é própria via simulação de step response.",
                                  "estimatedTime": "2-3 horas",
                                  "materials": [
                                    "MATLAB Control System Toolbox (coprime, hankel)",
                                    "Python Control Library alternativa"
                                  ],
                                  "tips": "Escolha fatores de coprime minimamente próprios para ordem mínima; normalize para evitar il-condicionamento.",
                                  "learningObjective": "Dominar a parametrização Youla para banco de controladores estabilizadores.",
                                  "commonMistakes": [
                                    "Usar fatorizações não biproprias levando a Q não livre",
                                    "Ignorar ordem de C0 impactando mínima ordem de Q"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Formular e Resolver Síntese de Q Ótimo via Algoritmos Riccati ou LMIs",
                                  "subSteps": [
                                    "Formule o problema: min_γ ||T1 + T2 Q T3||∞ < γ com Q estável de ordem mínima.",
                                    "Use equações de Riccati diferenciais (DRE) para γ ótimo: resolva Riccati para X∞, Y∞, Hamiltonianos.",
                                    "Alternativa LMI: formule como SDP min γ s.t. [γI -Z; -Z* He(A-B2K)] >0 com Y = K + jωC.",
                                    "Extraia Q de soluções state-space: Q = Fl(T2, Qhat) onde Qhat da solução Riccati.",
                                    "Verifique γ ótimo via norma H∞ computacional (hinfnorm)."
                                  ],
                                  "verification": "Calcule ||Tzw||∞ < γ e plote singular values de Tzw para pico <γ.",
                                  "estimatedTime": "3-4 horas",
                                  "materials": [
                                    "MATLAB Robust Control Toolbox (hinfsyn)",
                                    "YALMIP para LMIs",
                                    "CVX em Python"
                                  ],
                                  "tips": "Inicie com γ=1 e bisseção para convergência; prefira Riccati para ordem baixa, LMI para constraints extras.",
                                  "learningObjective": "Aplicar métodos numéricos Riccati/LMI para síntese ótima H∞ via Q.",
                                  "commonMistakes": [
                                    "Não garantir Q estável pós-síntese",
                                    "Escolha errada de pesos levando a γ irrealista"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Construir Controlador C, Simular e Validar Robustez",
                                  "subSteps": [
                                    "Monte C = (Y - M Q)^{-1} (X + N Q) em espaço de estados ou tf.",
                                    "Simule malha fechada com perturbações: step, bode para Tzw, sensibilidade.",
                                    "Teste robustez: varie Δ em ||Δ||∞=1, verifique estabilidade via small-gain theorem.",
                                    "Analise desempenho: overshoot <10%, banda > wc, rejeição de distúrbios.",
                                    "Reduza ordem de C/Q se necessário via balanced realization."
                                  ],
                                  "verification": "Simulações mostram ||Tzw||∞ < γ, estabilidade μ<1 para Δ estruturadas.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Simulink para simulações não-lineares",
                                    "Mu-Toolbox para análise estrutural"
                                  ],
                                  "tips": "Use loopshaping em bode para debug; compare com PID para benchmark.",
                                  "learningObjective": "Implementar e validar controlador H∞ parametrizado em cenários reais.",
                                  "commonMistakes": [
                                    "Controlador impróprio causando zeros RHP espúrios",
                                    "Não testar com Δ reais do modelo"
                                  ]
                                }
                              ],
                              "practicalExample": "Para um sistema massa-mola com incerteza de 20% em massa: G(s)=1/(m s^2 + c s + k), use Wp=1/(s+0.1) para rastreamento, Wu=0.1 para u limitado. Sintetize C H∞ com γ=1.2, simulando rejeição de distúrbio sinusoidal em 1Hz com overshoot <5%.",
                              "finalVerifications": [
                                "Computar ||Tzw||∞ < γ especificado.",
                                "C estabiliza P nominal e perturbado (||Δ||∞=1).",
                                "Bode plot de Tzw com pico <γ em todas frequências.",
                                "Simulação temporal atende specs: settling <2s, overshoot <10%.",
                                "Ordem de C mínima (rank hankel < ordem original).",
                                "Q estável com polos no LHP."
                              ],
                              "assessmentCriteria": [
                                "Precisão na formulação de P e Tzw (90% correto).",
                                "Convergência de Riccati/LMI para γ ótimo (erro <1%).",
                                "Validação robusta via simulações (μ-analysis <1).",
                                "Eficiência computacional (tempo <10min em PC padrão).",
                                "Relatório com plots e justificativas teóricas.",
                                "Capacidade de reduzir ordem mantendo γ<1.1 γ_opt."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Álgebra linear (Riccati, LMIs, SVD para coprime).",
                                "Programação: MATLAB/Python para síntese numérica e otimização.",
                                "Física: Modelagem dinâmica de sistemas mecatrônicos com incertezas.",
                                "Estatística: Análise de Monte Carlo para validação robusta.",
                                "Engenharia de Software: Versionamento de modelos em Git para iterações."
                              ],
                              "realWorldApplication": "Síntese de controladores para drones em ventos turbulentos (incertezas aerodinâmicas), garantindo estabilidade e rastreamento de trajetória apesar de variações de payload, usado em entregas autônomas da Amazon ou inspeção de linhas de energia."
                            },
                            "estimatedTime": "2.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "76.6.4.4.3.3",
                            "name": "Analisar robustez com μ e condições estruturadas",
                            "description": "Introduzir análise μ para incertezas estruturadas em escalares, verificando estabilidade robusta com upper/lower bounds e ajustando pesos para μ(Tzw, Δ) < 1.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender Conceitos Fundamentais de Análise μ e Incertezas Estruturadas",
                                  "subSteps": [
                                    "Estudar a definição de structured singular value (μ) para incertezas estruturadas em escalares.",
                                    "Revisar o teorema básico de robustez: estabilidade se μ(Tzw, Δ) < 1 para ||Δ|| ≤ 1.",
                                    "Diferenciar incertezas normais (||Δ||_2) de estruturadas (blocos repetidos ou escalares).",
                                    "Explorar upper e lower bounds para μ usando métodos como μ-tools ou LMI.",
                                    "Analisar exemplos simples de sistemas com Δ diagonal para incertezas paramétricas."
                                  ],
                                  "verification": "Resumir em um diagrama os componentes de Tzw e Δ, explicando μ < 1.",
                                  "estimatedTime": "2 horas",
                                  "materials": "Livro 'Robust and Optimal Control' de Zhou; MATLAB Robust Control Toolbox; Notas de aula sobre μ-analysis.",
                                  "tips": "Comece com casos 1x1 para intuitivamente entender μ como 1/σ_min invertido.",
                                  "learningObjective": "Dominar a teoria por trás da análise μ para incertezas estruturadas.",
                                  "commonMistakes": "Confundir μ com singular values gerais; ignorar estrutura de Δ."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Modelar o Sistema com Blocos de Incerteza Estruturada",
                                  "subSteps": [
                                    "Construir o generalized plant P com entradas w (incertezas) e saídas z (performance).",
                                    "Identificar incertezas Δ como blocos escalares ou full blocks no feedback loop.",
                                    "Definir o closed-loop transfer Tzw = F_u(P, K) conectando controlador K.",
                                    "Escalonar incertezas com pesos W_Δ para normalizar ||Δ|| ≤ 1.",
                                    "Validar o modelo plotando singular values de Tzw em frequências chave."
                                  ],
                                  "verification": "Gerar diagrama LFT (Linear Fractional Transformation) e confirmar conexões.",
                                  "estimatedTime": "3 horas",
                                  "materials": "MATLAB/Simulink; Toolbox mu-analysis; Exemplos de plantas como inverted pendulum.",
                                  "tips": "Use sysic para interconectar blocos automaticamente no MATLAB.",
                                  "learningObjective": "Criar modelos precisos de sistemas com incertezas para análise μ.",
                                  "commonMistakes": "Escolha inadequada de pesos W_Δ levando a bounds conservadores."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular Upper e Lower Bounds para μ(Tzw)",
                                  "subSteps": [
                                    "Implementar cálculo de lower bound via singular values maximizadas sobre estruturas.",
                                    "Usar método de upper bound com otimização (ex: mu upper bound via Wasserstein).",
                                    "Plotar μ-bounds vs. frequência usando musv ou musyn no MATLAB.",
                                    "Interpretar picos de μ >1 indicando falta de robustez.",
                                    "Comparar bounds para avaliar gap e confiabilidade da análise."
                                  ],
                                  "verification": "Gerar plot de μ upper/lower bounds com μ_max <1 em todo o espectro.",
                                  "estimatedTime": "4 horas",
                                  "materials": "MATLAB Robust Control Toolbox (funções musv, mu); Jupyter notebook para plots.",
                                  "tips": "Aumente tolerância numérica para sistemas de alta ordem com 'options.Tol' ajustado.",
                                  "learningObjective": "Computar e interpretar bounds de μ para diagnóstico de robustez.",
                                  "commonMistakes": "Não lidar com D-K iteração prematura; ignorar frequência DC ou Nyquist."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificar Estabilidade Robusta e Ajustar Pesos",
                                  "subSteps": [
                                    "Verificar condição μ(Tzw, Δ) <1 para todos os blocos Δ estruturados.",
                                    "Identificar frequências críticas onde μ >1 e propor ajustes em pesos W_p ou W_Δ.",
                                    "Iterar com scaling D-K para tightar bounds e confirmar robustez.",
                                    "Simular com Δ reais (ex: ±20% variação paramétrica) para validar.",
                                    "Documentar trade-offs entre performance e robustez."
                                  ],
                                  "verification": "Relatório com plots finais mostrando μ <1 e simulações estáveis.",
                                  "estimatedTime": "3 horas",
                                  "materials": "MATLAB (mussv, dkitools); Casos de teste com plantas SISO como DC motor.",
                                  "tips": "Use loop shaping em controladores para reduzir picos de μ em bandas críticas.",
                                  "learningObjective": "Aplicar ajustes iterativos para garantir robustez μ-baseada.",
                                  "commonMistakes": "Overfitting pesos sem validação em incertezas reais."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Interpretar Resultados e Aplicar em Cenários Complexos",
                                  "subSteps": [
                                    "Analisar sensibilidade de μ a mudanças em estrutura de Δ.",
                                    "Comparar μ-analysis com métodos conservadores como small-gain theorem.",
                                    "Estender para μ-lower bounds em LMI para otimização.",
                                    "Preparar relatório com conclusões sobre estabilidade robusta.",
                                    "Testar em benchmark como o de robust control problems."
                                  ],
                                  "verification": "Apresentar case study completo com antes/depois de ajustes.",
                                  "estimatedTime": "2 horas",
                                  "materials": "Referências COMPILE toolbox; Artigos IEEE sobre μ-synthesis.",
                                  "tips": "Salve sessões MATLAB com 'save' para reprodutibilidade.",
                                  "learningObjective": "Sintetizar análise μ em decisões de design de controladores.",
                                  "commonMistakes": "Generalizar resultados sem considerar limitações computacionais."
                                }
                              ],
                              "practicalExample": "Em um controlador PID para um motor DC com incertezas ±30% em ganho e tempo constante, modele Δ como blocos escalares 2x2. Compute μ(Tzw) revelando pico em 10 rad/s >1. Ajuste peso W_Δ alto-frequência e reescalone para μ<0.9, confirmando estabilidade em simulações com variações reais.",
                              "finalVerifications": [
                                "μ upper bound <1 em todas as frequências para Δ nominais.",
                                "Lower bound próximo ao upper, indicando análise precisa.",
                                "Simulações com Δ extremas mantêm estabilidade e performance.",
                                "Pesos ajustados documentados com justificativa.",
                                "Relatório com plots de μ-bounds e singular values.",
                                "Comparação com small-gain: μ menos conservador."
                              ],
                              "assessmentCriteria": [
                                "Precisão no modelado de Tzw e Δ (90% correto).",
                                "Qualidade dos bounds μ (gap <20%).",
                                "Correta interpretação de violações μ>1.",
                                "Eficácia dos ajustes iterativos.",
                                "Clareza em plots e documentação.",
                                "Validação via simulação (sem instabilidades)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Álgebra linear (singular values, LMIs).",
                                "Programação: MATLAB/Simulink para análise numérica.",
                                "Física: Modelagem dinâmica de sistemas reais.",
                                "Otimização: D-K iteração como problema de síntese."
                              ],
                              "realWorldApplication": "Na indústria aeroespacial, análise μ garante robustez de controladores de flight em face de incertezas aerodinâmicas variáveis com Mach, evitando falhas como no caso de flaps deployment em aviões comerciais."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.4.5",
                    "name": "Relação com a Forma Padrão",
                    "description": "Integração da parametrização na forma padrão do problema de controle LIT.",
                    "individualConcepts": [
                      {
                        "id": "76.4.4.1",
                        "name": "Forma Padrão do Problema de Controle LIT",
                        "description": "Representação unificada do problema de controle de laço fechado para sistemas lineares invariantes no tempo (LIT), composta por um bloco generalizado M conectado em paralelo com incertezas Δ, permitindo análise de estabilidade e robustez via norma H∞.",
                        "specificSkills": [
                          {
                            "id": "76.4.4.1.1",
                            "name": "Identificar componentes da forma padrão",
                            "description": "Reconhecer e descrever os blocos P (planta), K (controlador), sinais exógenos w, desempenho z, controle u e medida y, além da estrutura M = Fl(P, K) e Δ.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar a definição e diagrama da Forma Padrão do Problema de Controle LIT",
                                  "subSteps": [
                                    "Estude a definição formal da forma padrão, que representa o problema de controle como uma interconexão linear envolvendo planta P e controlador K.",
                                    "Analise o diagrama padrão, identificando as entradas e saídas principais: sinais exógenos w, sinal de desempenho z, sinal de controle u e medida y.",
                                    "Memorize a notação: M = Fl(P, K) como o sistema fechado e Δ como a perturbação ou incerteza.",
                                    "Desenhe o diagrama básico à mão para fixar a visualização.",
                                    "Compare com exemplos de livros-texto para confirmar compreensão inicial."
                                  ],
                                  "verification": "Reproduzir o diagrama da forma padrão corretamente de memória, rotulando todos os blocos e sinais.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Diagrama da forma padrão (impresso ou digital), livro-texto de controle avançado (ex: Zhou, Doyle, Glover), caderno para desenhos.",
                                  "tips": "Use cores diferentes para blocos (P em azul, K em verde) e setas para sinais para facilitar a visualização.",
                                  "learningObjective": "Compreender a estrutura global da forma padrão LIT e suas componentes principais.",
                                  "commonMistakes": "Confundir sinais exógenos w com perturbações Δ; ignorar a direção das setas nos sinais."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar e descrever o bloco da Planta P e Controlador K",
                                  "subSteps": [
                                    "Localize o bloco P no diagrama: representa o sistema físico a ser controlado, com entradas u (controle) e saídas y (medida).",
                                    "Descreva funções de P: modela dinâmicas do processo, frequentemente como função de transferência ou espaço de estados.",
                                    "Identifique o bloco K: controlador, que recebe y e produz u para estabilizar o sistema.",
                                    "Explique como P e K se conectam em laço fechado via feedback.",
                                    "Diferencie P (aberto) de M (fechado)."
                                  ],
                                  "verification": "Explicar verbalmente ou por escrito o papel de P e K, apontando-os em um diagrama dado.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Diagrama anotado da forma padrão, simulador MATLAB/Simulink opcional para visualizar P e K.",
                                  "tips": "Pense em P como 'o carro' e K como 'o motorista' para analogia intuitiva.",
                                  "learningObjective": "Reconhecer e descrever precisamente os blocos P e K na estrutura.",
                                  "commonMistakes": "Trocar P por K; assumir que P inclui o controlador."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Mapear os sinais exógenos w, desempenho z, controle u e medida y",
                                  "subSteps": [
                                    "Identifique w: sinais exógenos ou referências externas que afetam o sistema.",
                                    "Localize z: sinal de desempenho, saída desejada a ser regulada (generalização de erro).",
                                    "Descreva u: sinal de controle gerado por K, aplicado a P.",
                                    "Explique y: medida ou saída observada de P, alimentada de volta a K.",
                                    "Trace o fluxo: w → z via P/K, com y → K → u → P."
                                  ],
                                  "verification": "Rastrear o caminho de cada sinal em um diagrama, listando entradas/saídas corretas.",
                                  "estimatedTime": "40 minutos",
                                  "materials": "Diagrama com setas destacadas, tabela de sinais (w, z, u, y) para preencher.",
                                  "tips": "Use setas numeradas para seguir o fluxo de sinais passo a passo.",
                                  "learningObjective": "Associar cada sinal à sua função e localização no diagrama.",
                                  "commonMistakes": "Confundir u (controle) com w (exógeno); inverter y e z."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Compreender a estrutura M = Fl(P, K) e a perturbação Δ",
                                  "subSteps": [
                                    "Defina Fl(P, K): interconexão linear feedback, sistema fechado completo.",
                                    "Explique Δ: bloco de incerteza ou perturbação, tipicamente após P, representando não-linearidades ou variações.",
                                    "Descreva como M captura o problema de robustez: ||Fl(P, K)|| < 1/||Δ|| para estabilidade.",
                                    "Integre todos componentes: P, K, sinais e Δ em um todo coeso.",
                                    "Analise um diagrama completo com Δ incluído."
                                  ],
                                  "verification": "Escrever a equação M = Fl(P, K) e descrever o impacto de Δ em um relatório curto.",
                                  "estimatedTime": "35 minutos",
                                  "materials": "Referência teórica (artigo ou capítulo sobre H-infinito), software para plotar Fl.",
                                  "tips": "Lembre: Δ é 'o vilão' que testa a robustez do controle.",
                                  "learningObjective": "Integrar M e Δ à identificação de componentes.",
                                  "commonMistakes": "Omitir Δ; confundir Fl com multiplicação simples."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Aplicar identificação em um exemplo prático e autoavaliar",
                                  "subSteps": [
                                    "Selecione um diagrama de exemplo (ex: controle de temperatura).",
                                    "Rotule todos componentes: P, K, w, z, u, y, M, Δ.",
                                    "Descreva cada um em contexto do exemplo.",
                                    "Simule pequenas mudanças (ex: adicionar Δ) e observe efeitos.",
                                    "Autoavalie usando verificações finais."
                                  ],
                                  "verification": "Apresentar diagrama rotulado completo com descrições corretas.",
                                  "estimatedTime": "50 minutos",
                                  "materials": "Exemplo específico (diagrama de controle de motor DC), simulador (MATLAB).",
                                  "tips": "Comece com exemplos familiares para reforçar confiança.",
                                  "learningObjective": "Aplicar identificação de componentes em cenários reais.",
                                  "commonMistakes": "Ignorar contexto do exemplo; rotular incorretamente em diagramas não-padrão."
                                }
                              ],
                              "practicalExample": "Em um sistema de controle de temperatura de um forno industrial: P é o modelo térmico do forno (entrada u: potência do aquecedor, saída y: temperatura medida); K é o PID ou H-infinito que ajusta u baseado em y; w é a referência de temperatura desejada; z é o erro de rastreamento/performance; Δ representa variações no isolamento térmico. M = Fl(P, K) garante que a temperatura siga w apesar de Δ.",
                              "finalVerifications": [
                                "Rastrear corretamente o fluxo de todos sinais (w, z, u, y) em um diagrama dado.",
                                "Identificar P e K em 100% dos diagramas de forma padrão apresentados.",
                                "Explicar o papel de Δ e sua posição relativa a M.",
                                "Reproduzir a notação M = Fl(P, K) com definição precisa.",
                                "Descrever diferenças entre sinal de desempenho z e medida y.",
                                "Aplicar identificação em um novo diagrama sem erros."
                              ],
                              "assessmentCriteria": [
                                "Precisão na localização de P, K e sinais (90-100% correto: excelente).",
                                "Descrições claras e completas de cada componente (incluindo funções).",
                                "Compreensão de interconexões e fluxo de sinais demonstrada.",
                                "Integração correta de M e Δ no contexto geral.",
                                "Aplicação prática em exemplo sem omissões.",
                                "Uso de terminologia técnica apropriada (LIT, Fl, exógenos)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Sistemas lineares invariantes no tempo (LIT) e funções de transferência.",
                                "Física: Modelagem dinâmica de sistemas (equações diferenciais para P).",
                                "Programação: Simulação em MATLAB/Simulink de diagramas de blocos.",
                                "Engenharia de Software: Diagramação UML similar a estruturas de controle."
                              ],
                              "realWorldApplication": "Essa identificação é essencial em design de controladores robustos para aviões (controle de voo), robótica (posicionamento preciso) e processos industriais (controle de pH em reatores químicos), garantindo estabilidade apesar de perturbações reais como variações climáticas ou desgaste de componentes."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "76.4.4.1.2",
                            "name": "Explicar o papel das incertezas na forma padrão",
                            "description": "Descrever como as perturbações normais Δ modelam incertezas aditivas, multiplicativas ou de entrada/saída, e a condição de robustez ||M||∞ < 1/||Δ||^{-1}.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a estrutura da Forma Padrão do Problema de Controle LTI",
                                  "subSteps": [
                                    "Revise a representação da Forma Padrão com o sistema generalizado P e o controlador K formando M.",
                                    "Identifique os blocos de incerteza Δ conectados em paralelo ou série ao sistema nominal.",
                                    "Estude diagramas de bloco da Forma Padrão, destacando entradas w, saídas z e sinais de controle u/y.",
                                    "Explique como Δ captura desvios do modelo nominal em sistemas LTI.",
                                    "Desenhe um diagrama simples da Forma Padrão usando ferramentas como MATLAB ou papel."
                                  ],
                                  "verification": "Desenhe corretamente o diagrama da Forma Padrão e rotule todos os sinais principais.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Livro-texto de Controle Avançado (ex: Zhou, Doyle, Glover)",
                                    "Software de diagramação (Visio ou draw.io)",
                                    "Notas de aula sobre H-infinito"
                                  ],
                                  "tips": "Comece com um sistema SISO simples para visualizar melhor as conexões.",
                                  "learningObjective": "Entender a arquitetura da Forma Padrão e o papel dos blocos Δ como modeladores de incerteza.",
                                  "commonMistakes": [
                                    "Confundir entradas de performance w com perturbações Δ",
                                    "Ignorar a interconexão feedback entre M e Δ"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Modelar diferentes tipos de incertezas usando perturbações Δ",
                                  "subSteps": [
                                    "Defina incertezas aditivas: Δ_add em saídas ou entradas do sistema.",
                                    "Descreva incertezas multiplicativas: Δ_mult = (P_pert - P_nom)/P_nom, normalizadas.",
                                    "Explique incertezas de entrada/saída: atuadores Δ_act e sensores Δ_sens.",
                                    "Discuta normalização de Δ para ||Δ||∞ ≤ 1, usando pesos de incerteza W.",
                                    "Classifique exemplos: ganho variável (multiplicativa), ruído de sensor (aditiva)."
                                  ],
                                  "verification": "Classifique corretamente 3 tipos de incertezas e escreva suas representações em diagrama de bloco.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Exemplos de plantas reais (motor DC, inversor de pendulo)",
                                    "MATLAB/Simulink para simular Δ",
                                    "Folhas de exercícios sobre modelagem"
                                  ],
                                  "tips": "Use frações relativas para multiplicativas para capturar variações percentuais.",
                                  "learningObjective": "Dominar como Δ modela incertezas aditivas, multiplicativas e de I/O de forma unificada.",
                                  "commonMistakes": [
                                    "Não normalizar Δ, levando a condições de robustez incorretas",
                                    "Confundir aditiva com multiplicativa em plantas com ganho nominal não unitário"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar a condição de robustez interna usando normas H-infinito",
                                  "subSteps": [
                                    "Lembre que estabilidade robusta requer ausência de interpolação unitária M(s)Δ(s) = I.",
                                    "Introduza a norma H-infinito: ||M||∞ = sup_ω |M(jω)|.",
                                    "Derive a condição suficiente: ||M||∞ < 1/||Δ||∞ para ||Δ||∞ ≤1 implica robustez.",
                                    "Explique ||Δ||^{-1} como o 'raio' de incerteza tolerável.",
                                    "Calcule ||M||∞ numericamente para um sistema dado."
                                  ],
                                  "verification": "Derive e justifique a desigualdade ||M||∞ < 1/||Δ||^{-1} em um exemplo numérico.",
                                  "estimatedTime": "1 hora 15 minutos",
                                  "materials": [
                                    "MATLAB Robust Control Toolbox",
                                    "Tabelas de normas H-infinito",
                                    "Artigo seminal de Doyle et al. sobre μ-síntese"
                                  ],
                                  "tips": "Use singular values σ_bar(M(jω)) para computar ||M||∞ eficientemente.",
                                  "learningObjective": "Compreender matematicamente como normas quantificam robustez contra Δ.",
                                  "commonMistakes": [
                                    "Inverter incorretamente a condição: usar ||M||∞ > 1/||Δ||",
                                    "Confundir norma H2 com H-infinito"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Interpretar e validar o papel das incertezas na síntese de controladores",
                                  "subSteps": [
                                    "Discuta como projetar K para minimizar ||M||∞ dado um conjunto Δ.",
                                    "Simule violações: aumente ||Δ|| até falha de robustez.",
                                    "Compare com análise small-gain theorem.",
                                    "Avalie trade-offs: robustez vs performance.",
                                    "Documente insights em um relatório curto."
                                  ],
                                  "verification": "Simule um sistema onde robustez falha se ||M||∞ ≥ 1/||Δ||^{-1}.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Simulink para simulação fechada-loop",
                                    "Templates de relatório LaTeX",
                                    "Dados de plantas experimentais"
                                  ],
                                  "tips": "Teste com Bode plots de M para visualizar picos que violam robustez.",
                                  "learningObjective": "Aplicar o conceito para validar controladores robustos na prática.",
                                  "commonMistakes": [
                                    "Ignorar fase em análises de norma, focando só em magnitude",
                                    "Sobreestimar robustez sem simulações dinâmicas"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um controlador para um motor DC, modele incerteza multiplicativa Δ_mult no ganho da planta P(s) = K/(s(τs+1)), com |Δ_mult|∞ ≤ 0.2 (20% variação). Compute ||M||∞ < 5 para garantir robustez, simulando step responses com Δ = 0.2 e Δ = -0.2.",
                              "finalVerifications": [
                                "Descreve corretamente os tipos de Δ e suas posições na Forma Padrão.",
                                "Deriva a condição ||M||∞ < 1/||Δ||^{-1} sem erros.",
                                "Identifica em um diagrama onde Δ modela incertezas específicas.",
                                "Explica o small-gain theorem como base da robustez.",
                                "Simula um caso de falha de robustez.",
                                "Discute normalização de Δ."
                              ],
                              "assessmentCriteria": [
                                "Precisão conceitual na modelagem de incertezas (aditiva/multiplicativa).",
                                "Correção matemática da condição de robustez.",
                                "Clareza na interpretação de ||M||∞ e ||Δ||^{-1}.",
                                "Uso adequado de exemplos e simulações.",
                                "Profundidade na discussão de trade-offs robustez/performance.",
                                "Capacidade de generalizar para MIMO."
                              ],
                              "crossCurricularConnections": [
                                "Matemática Avançada: Teoria de Normas em Espaços de Hardy (H-infinito).",
                                "Probabilidade e Estatística: Modelagem estocástica de incertezas como alternativas a Δ determinísticos.",
                                "Engenharia de Sistemas: Integração com análise de confiabilidade e fault-tolerance.",
                                "Física: Dinâmica de sistemas reais com não-linearidades aproximadas por Δ LTI."
                              ],
                              "realWorldApplication": "No controle de voo de aeronaves, Δ modela variações aerodinâmicas devido a turbulência ou danos estruturais; a condição garante estabilidade mesmo com 15-30% de desvios, essencial para certificação FAA."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "76.4.4.1.1"
                            ]
                          },
                          {
                            "id": "76.4.4.1.3",
                            "name": "Derivar funções de transferência na forma padrão",
                            "description": "Calcular as funções Tzw, Tzu, Tzw via interconexão lower/upper linear fractional transformation (LFT) para sistemas escalares LIT.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a estrutura da forma padrão e interconexões LFT",
                                  "subSteps": [
                                    "Definir a matriz partitionada G = [G11 G12; G21 G22] para sistemas LIT escalares.",
                                    "Identificar os sinais: w (referência/distúrbio), z (saída controlada), u (controle), y (medida).",
                                    "Desenhar o diagrama de blocos da interconexão entre G e o controlador K.",
                                    "Explicar a conexão lower LFT (Fl(G,K)) e upper LFT (Fu(G,K)).",
                                    "Verificar a causalidade e bem-posedness da interconexão."
                                  ],
                                  "verification": "Desenhar corretamente o diagrama de interconexão e rotular todos os sinais e partições de G.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Livro de Controle Avançado (ex: Zhou, Doyle, Glover)",
                                    "Papel milimetrado ou software de diagrama (Draw.io)",
                                    "Notas de aula sobre LFT"
                                  ],
                                  "tips": [
                                    "Sempre comece pelo diagrama de blocos para visualizar as conexões.",
                                    "Lembre-se: lower LFT usa K na parte inferior, upper na superior."
                                  ],
                                  "learningObjective": "Dominar a configuração topológica da forma padrão para derivações subsequentes.",
                                  "commonMistakes": [
                                    "Confundir as partições G11/G12/G21/G22.",
                                    "Ignorar a direção dos sinais w->z e u->y.",
                                    "Esquecer de verificar se I - G22 K é invertível."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Recordar e derivar as fórmulas gerais de LFT lower e upper",
                                  "subSteps": [
                                    "Derivar a fórmula de Fl(G,K) = G11 + G12 K (I - G22 K)^{-1} G21.",
                                    "Derivar a fórmula de Fu(G,K) = (I - G11 K)^{-1} (G12 + G11 K G22).",
                                    "Simplificar para o caso escalar (sistemas monovariáveis).",
                                    "Identificar Tzw = Fl(G,K), Tzu = Fu(G,K) ou variações como Tzw e Tyd.",
                                    "Praticar manipulação algébrica com funções de transferência simbólicas."
                                  ],
                                  "verification": "Escrever corretamente as fórmulas Fl e Fu em um caderno e derivá-las de memória.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Calculadora simbólica (MATLAB Symbolic ou Mathematica)",
                                    "Folhas de derivadas matriciais",
                                    "Referência: Skogestad Postlethwaite"
                                  ],
                                  "tips": [
                                    "Use a regra de Schur para inversas: (I - G22 K)^{-1} = I + G22 K (I - G22 K)^{-1} se necessário.",
                                    "Mantenha tudo em termos de funções de transferência racionais."
                                  ],
                                  "learningObjective": "Aplicar fórmulas LFT padrão para funções closed-loop.",
                                  "commonMistakes": [
                                    "Erro na ordem da multiplicação matricial.",
                                    "Confundir Fl com Fu.",
                                    "Não cancelar polos/fundos corretamente em escalares."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular as funções específicas Tzw, Tzu e Tzw (ou Tyw)",
                                  "subSteps": [
                                    "Substituir as partições específicas na fórmula Fl para obter Tzw.",
                                    "Calcular Tzu usando Fu ou combinação: Tzu = K (I - G22 K)^{-1} G21.",
                                    "Derivar Tzw ou Tyw = (I - G11 K)^{-1} G12 para completude.",
                                    "Simplificar expressões algébricas e fatorar comuns denominadores.",
                                    "Analisar pólos e zeros das funções derivadas."
                                  ],
                                  "verification": "Obter expressões simplificadas idênticas a um exemplo resolvido manualmente.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Software de controle (MATLAB Control Toolbox)",
                                    "Exemplos resolvidos de aulas",
                                    "Caderno para cálculos à mão"
                                  ],
                                  "tips": [
                                    "Comece com G22 = 0 para casos simples, depois generalize.",
                                    "Verifique simetria: Tzw deve mapear w para z independentemente de K em alguns casos."
                                  ],
                                  "learningObjective": "Derivar com precisão as transfer functions closed-loop chave.",
                                  "commonMistakes": [
                                    "Erro de sinal em (I - G22 K).",
                                    "Não simplificar frações racionais.",
                                    "Confundir Tzu com Tuw."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificar, simular e analisar as derivações",
                                  "subSteps": [
                                    "Implementar as funções em software e plotar respostas em frequência.",
                                    "Comparar derivações manuais com simulações numéricas.",
                                    "Analisar estabilidade via pólos ou Nyquist das funções T.",
                                    "Testar sensibilidade a variações em K.",
                                    "Documentar o processo em um relatório curto."
                                  ],
                                  "verification": "Simulação reproduz exatamente as expressões analíticas derivadas.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "MATLAB/Simulink ou Python (Control library)",
                                    "Dados numéricos para G e K",
                                    "Templates de relatório"
                                  ],
                                  "tips": [
                                    "Use tf() no MATLAB para transfer functions e step/bode plots.",
                                    "Sempre valide com limites DC e alta frequência."
                                  ],
                                  "learningObjective": "Validar derivações teóricas com ferramentas computacionais.",
                                  "commonMistakes": [
                                    "Bugs em código (unidades erradas).",
                                    "Ignorar instabilidades numéricas.",
                                    "Não checar consistência com diagrama original."
                                  ]
                                }
                              ],
                              "practicalExample": "Considere G(s) = [0, 1/W(s); Z(s), P(s)] com W(s)=1, Z(s)=s/(s+1), P(s)=1/(s+1)^2. Para K(s)=k/(s+1), derive Tzw(s) = Fl(G,K) = Z + P K / (1 - P K), Tzu(s) = K / (1 - P K), e Tzw(s) ≈ T_yw(s) = 1/(1 - P K). Simplifique e plote Bode.",
                              "finalVerifications": [
                                "Derivações coincidem com fórmulas padrão para exemplo dado.",
                                "Diagrama de interconexão está correto e causal.",
                                "Simulações numéricas validam expressões analíticas.",
                                "Identifica corretamente Tzw como sensibilidade a w.",
                                "Analisa pólos para estabilidade closed-loop.",
                                "Simplificações algébricas estão livres de erros."
                              ],
                              "assessmentCriteria": [
                                "Precisão das fórmulas LFT lower/upper (100% correto).",
                                "Correta identificação e cálculo de Tzw, Tzu, Tzw.",
                                "Qualidade do diagrama e substeps detalhados.",
                                "Validação via simulação (plots coincidem).",
                                "Análise de erros comuns evitados.",
                                "Clareza na documentação e simplificações."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Álgebra linear e funções racionais (teoria de campos racionais).",
                                "Programação: Simulação de sistemas dinâmicos em MATLAB/Python.",
                                "Física: Modelagem de sistemas dinâmicos lineares (equações diferenciais).",
                                "Engenharia de Software: Verificação formal de algoritmos de controle.",
                                "Economia: Otimização em controle ótimo (H2/H-infinity)."
                              ],
                              "realWorldApplication": "Em automação industrial, como controle robusto de velocidade em motores DC apesar de variações paramétricas, usando a forma padrão para sintetizar controladores H-infinity que minimizam ||Tzw||_infty para rejeição de distúrbios."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "76.4.4.1.1"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "76.4.4.2",
                        "name": "Parametrização de Controladores Estabilizadores",
                        "description": "Conjunto de todos os controladores que estabilizam uma planta LIT dada, parametrizado por Q estável usando fatorizações coprimes de Youla-Kucera.",
                        "specificSkills": [
                          {
                            "id": "76.4.4.2.1",
                            "name": "Derivar a parametrização de Youla",
                            "description": "Obter C(Q) = (X + D Q)(Y + N Q)^{-1} a partir da identidade de Bezout para fatorizações coprimes direita/esquerda da planta N/M.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Estabelecer a fatorização coprime da planta e a identidade de Bezout",
                                  "subSteps": [
                                    "Defina a planta P como fatorização direita coprime P = N M^{-1}, onde N e M são estáveis e coprimes direita.",
                                    "Recorde que coprimes direita significa que existe um unimodular U tal que [M -N] U = [V X] com V, X estáveis e det(V) ≠ 0.",
                                    "Estabeleça a identidade de Bezout: existem X e Y estáveis tais que X N + Y M = I (ou forma equivalente Y M - X N = I dependendo da convenção).",
                                    "Verifique a identidade multiplicando pela planta: mostre que Y - X P é invertível.",
                                    "Discuta fatorizações esquerda se necessário para contexto completo."
                                  ],
                                  "verification": "Escreva a identidade de Bezout corretamente e verifique multiplicando por [N; M] para obter I.",
                                  "estimatedTime": "1 hora",
                                  "materials": "Livro de controle avançado (ex: Zhou, Doyle), caderno, calculadora simbólica (MATLAB/SymPy)",
                                  "tips": "Comece com uma planta simples como P(s) = 1/(s+1) para fatorizar e testar.",
                                  "learningObjective": "Compreender e aplicar a identidade de Bezout para fatorizações coprimes.",
                                  "commonMistakes": "Confundir fatorização direita (N M^{-1}) com esquerda (M^{-1} N); ignorar estabilidade de X e Y."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Construir um controlador estabilizador inicial usando Bezout",
                                  "subSteps": [
                                    "A partir de Bezout X N + Y M = I, defina o controlador básico C_0 = X Y^{-1}.",
                                    "Verifique estabilidade do laço fechado: mostre que T = P C_0 (I + P C_0)^{-1} = N X é estável.",
                                    "Mostre que S = (I + C_0 P)^{-1} C_0 = Y^{-1} é estável.",
                                    "Confirme que o laço unitário é estável para entrada de referência e rejeição de distúrbio.",
                                    "Introduza D como o denominador dual, frequentemente D = M para consistência."
                                  ],
                                  "verification": "Calcule as funções de transferência fechadas e confirme que todas são estáveis.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": "Software de controle (MATLAB Control System Toolbox), exemplos de plantas LTI",
                                  "tips": "Use a convenção onde Bezout é Y M - X N = I para alinhar com C_0 = -X Y^{-1}.",
                                  "learningObjective": "Derivar um controlador estabilizador básico a partir de Bezout.",
                                  "commonMistakes": "Esquecer o sinal negativo em algumas convenções; não verificar invertibilidade de Y."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Introduzir o parâmetro Q estável e generalizar o controlador",
                                  "subSteps": [
                                    "Assuma Q estável e construa C(Q) = (X + D Q) (Y + N Q)^{-1}, onde D é o complemento (ex: M).",
                                    "Mostre que para Q=0, recupera C_0.",
                                    "Verifique estabilidade do novo laço: T(Q) = N (X + D Q) estável pois produto de estáveis.",
                                    "Mostre que S(Q) = (Y + N Q)^{-1} estável.",
                                    "Prove que todos os estabilizadores são obtidos assim (completude via bijeção Q ↔ C)."
                                  ],
                                  "verification": "Substitua Q=0 e confirme C(0)=C_0; verifique estabilidade para Q arbitrário estável.",
                                  "estimatedTime": "1 hora",
                                  "materials": "Papel para álgebra simbólica, referências teóricas (Youla 1976 paper)",
                                  "tips": "Mantenha Q estável no anel de Hardy ou RH_infty para robustez.",
                                  "learningObjective": "Parametrizar a família de todos os controladores estabilizadores com Q.",
                                  "commonMistakes": "Usar Q não estável levando a instabilidade; confundir D com N ou M."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Derivar e verificar a forma final C(Q)",
                                  "subSteps": [
                                    "Combine os passos: partindo de Bezout, manipule C(Q) = (X + M Q)(Y + N Q)^{-1} assumindo D=M.",
                                    "Mostre equivalência com outras formas como C(Q) = C_0 + (I - C_0 P) Q (I + P C_0)^{-1} C_0.",
                                    "Teste com uma planta exemplo: compute Bezout via MATLAB riccati ou coprime factorization.",
                                    "Verifique completude: dado qualquer C estabilizador, resolva para Q = - (Y + C N)^{-1} C M.",
                                    "Discuta singularidades quando Y + N Q não invertível."
                                  ],
                                  "verification": "Escreva explicitamente C(Q) e derive para uma planta de 1ª ordem.",
                                  "estimatedTime": "1 hora",
                                  "materials": "MATLAB com comandos coprime, sys = tf([1],[1 1]); [N,M,X,Y]=coprime(sys)",
                                  "tips": "Use comando coprime() no MATLAB para X,Y,N,M automáticos.",
                                  "learningObjective": "Obter a expressão final e entender sua generalidade.",
                                  "commonMistakes": "Inverter a ordem em (Y + N Q); ignorar coprimidade necessária para Q único."
                                }
                              ],
                              "practicalExample": "Para P(s) = 1/(s+1), fatorização coprime N=1/(s+1), M=1, Bezout X= -s, Y= s+1 (ajustado). Então C(Q) = (-s + Q)(s+1 + Q)^{-1}. Teste estabilidade com Q=0.5 constante.",
                              "finalVerifications": [
                                "Escreve corretamente C(Q) = (X + D Q)(Y + N Q)^{-1}.",
                                "Deriva Bezout para uma planta dada.",
                                "Verifica estabilidade do laço para Q estável arbitrário.",
                                "Mostra que recupera C_0 com Q=0.",
                                "Explica completude da parametrização.",
                                "Identifica Q a partir de um C estabilizador dado."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identidade de Bezout (correta forma e estabilidade).",
                                "Correção na derivação de C(Q) e verificação de estabilidade.",
                                "Compreensão de coprimidade e papel de Q estável.",
                                "Habilidade em aplicar a um exemplo numérico simples.",
                                "Explicação clara da completude (todos os C estabilizadores).",
                                "Identificação de erros comuns como instabilidade por Q inadequado."
                              ],
                              "crossCurricularConnections": [
                                "Álgebra linear: fatorizações coprimes análogas a decomposições matriciais.",
                                "Matemática avançada: teoria de anéis e RH_infty spaces.",
                                "Processos estocásticos: ligação com filtros de Kalman e H2/Hinfty.",
                                "Programação: implementação em MATLAB/Simulink para simulações."
                              ],
                              "realWorldApplication": "Design de controladores robustos em aeroespacial (ex: estabilização de aeronaves com incertezas), automação industrial (tuning adaptativo de PID via Youla), e sistemas de controle H-infinity para rejeição de perturbações em plantas com modelo impreciso."
                            },
                            "estimatedTime": "0.75 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "76.4.4.1.2"
                            ]
                          },
                          {
                            "id": "76.4.4.2.2",
                            "name": "Verificar propriedades de estabilidade",
                            "description": "Demonstrar que todo C(Q) com Q ∈ RH∞ estabiliza P, e que todos os estabilizadores são obtidos assim, via estabilidade interna do sistema fechado.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar o Setup da Parametrização de Youla-Kučera",
                                  "subSteps": [
                                    "Recordar a fatoração coprima direita de P = N M^{-1} e esquerda de um estabilizador C_0 = X Y^{-1}, com identidade de Bézout: X N + Y M = I.",
                                    "Derivar a forma geral dos estabilizadores: C(Q) = (X + M Q)(Y - N Q)^{-1} para Q ∈ RH_∞.",
                                    "Explicar o significado de RH_∞ como funções analíticas próprias estritamente causais e estáveis no semiplano direito.",
                                    "Desenhar o diagrama de blocos do laço fechado com C(Q) e P.",
                                    "Verificar que Q pertence a RH_∞ garante estabilidade das transferências envolvidas."
                                  ],
                                  "verification": "Escrever as expressões de C(Q) e confirmar a identidade de Bézout no papel ou software simbólico.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Livro de teoria de controle (e.g., Zhou, Doyle, Glover), papel e lápis, MATLAB Symbolic Toolbox",
                                  "tips": "Comece sempre pela fatoração coprima; memorize a identidade de Bézout como base.",
                                  "learningObjective": "Compreender a estrutura paramétrica dos controladores estabilizadores.",
                                  "commonMistakes": "Confundir fatoração direita/esquerda ou esquecer a invertibilidade em RH_∞."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Demonstrar Estabilização de P por C(Q) com Q ∈ RH_∞",
                                  "subSteps": [
                                    "Calcular as funções de transferência do sistema fechado: T_{zw} = P C(Q) (I + P C(Q))^{-1}, etc.",
                                    "Mostrar que todas as transferências fechadas são combinações lineares de N, M, Q estáveis.",
                                    "Usar a identidade de Bézout para provar que (Y - N Q)^{-1} = M + P (X + M Q), estável.",
                                    "Verificar estabilidade interna: todas as 4 transferências (de w,u a z,v) em RH_∞.",
                                    "Simular numericamente para um P simples."
                                  ],
                                  "verification": "Listar as 4 transferências fechadas e confirmar que são em RH_∞.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "MATLAB/Simulink para simulação, exemplos de plantas SISO estáveis/instáveis",
                                  "tips": "Expresse tudo em termos de N,M,X,Y,Q para ver a estabilidade diretamente.",
                                  "learningObjective": "Provar que a parametrização gera controladores estabilizadores.",
                                  "commonMistakes": "Ignorar estabilidade interna vs. saída-feito; assumir causalidade sem Q próprio."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Provar que Todos os Estabilizadores São da Forma C(Q)",
                                  "subSteps": [
                                    "Assumir C arbitrário estabilizador de P; mostrar existência de Q tal que C = C(Q).",
                                    "Derivar Q = (C^{-1} - Y) N^{-1} ou equivalentemente Q = M^{-1} (C X^{-1} - I), ajustando.",
                                    "Usar estabilidade interna para provar Q ∈ RH_∞.",
                                    "Verificar invertibilidade e causalidade usando propriedades coprimas.",
                                    "Testar com C = C_0 (Q=0) e outro estabilizador conhecido."
                                  ],
                                  "verification": "Para um C dado estabilizador, computar Q e checar se C(Q) = C e Q estável.",
                                  "estimatedTime": "75 minutos",
                                  "materials": "Software simbólico (Mathematica ou MATLAB), exemplos numéricos de P e C",
                                  "tips": "Use a fórmula Q = (Y - C^{-1})^{-1} M^{-1} C X^{-1}; resolva algebricamente.",
                                  "learningObjective": "Estabelecer completude da parametrização.",
                                  "commonMistakes": "Esquecer de provar Q ∈ RH_∞; lidar mal com singularidades."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificar Estabilidade Interna do Sistema Fechado",
                                  "subSteps": [
                                    "Definir estabilidade interna: todas transferências de entradas exógenas e iniciais em RH_∞.",
                                    "Listar explicitamente as matrizes de transferência fechadas para o framework padrão.",
                                    "Confirmar que para Q ∈ RH_∞, T = [P; I] [ -C(Q); I ] é estável.",
                                    "Discutir implicações para robustez e design.",
                                    "Aplicar a um exemplo com ruído e perturbações."
                                  ],
                                  "verification": "Simular respostas a entradas unitárias e checar ausência de modos instáveis.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Simulink para laço fechado, osciloscópio virtual",
                                  "tips": "Sempre cheque as 4 blocos da matriz T; foque em estados internos.",
                                  "learningObjective": "Ligar parametrização à estabilidade interna formal.",
                                  "commonMistakes": "Confundir estabilidade BIBO com interna; ignorar estados não acessíveis."
                                }
                              ],
                              "practicalExample": "Considere P(s) = 1/(s-1) (instável). Tome fatoração coprima N(s)=1/(s+1), M(s)=(s)/(s+1), C0(s)=1 com X=1, Y=(s+2)/(s+1). Então C(Q)= (1 + s Q/(s+1) ) / ( (s+2)/(s+1) - Q/(s+1) ) para Q(s)=0.5/(s+1) ∈ RH∞. Simule em MATLAB: o laço fecha estável, e resolva para Q dado outro C estabilizador.",
                              "finalVerifications": [
                                "Prova escrita que C(Q) estabiliza P para qualquer Q ∈ RH∞.",
                                "Construção explícita de Q para um estabilizador arbitrário.",
                                "Simulação numérica confirmando estabilidade interna (polos no esquerdo).",
                                "Verificação das 4 transferências fechadas em RH∞.",
                                "Teste com Q no limite da estabilidade (e.g., polo imaginário).",
                                "Comparação com estabilizador não paramétrico falhando."
                              ],
                              "assessmentCriteria": [
                                "Correção matemática da derivação de C(Q) (30%).",
                                "Prova completa de completude e estabilidade (30%).",
                                "Exemplo prático com cálculos/simulações verificáveis (20%).",
                                "Clareza na ligação com estabilidade interna (10%).",
                                "Identificação de erros comuns e dicas (5%).",
                                "Uso adequado de RH∞ e coprimidade (5%)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Álgebra de Hardy spaces e funções analíticas (RH∞).",
                                "Física: Dinâmica de sistemas lineares invariantes no tempo.",
                                "Computação: Simulação numérica em MATLAB/Simulink para validação.",
                                "Engenharia de Software: Verificação formal de propriedades em controle embarcado."
                              ],
                              "realWorldApplication": "Em aviões autônomos (e.g., drones), parametrização garante todos os controladores estabilizadores para plantas com atrasos/aerodinâmica incerta, permitindo design robusto via otimização de Q para desempenho (e.g., rejeição de turbulência)."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "76.4.4.2.1"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "76.4.4.3",
                        "name": "Integração da Parametrização na Forma Padrão",
                        "description": "Incorporação do parâmetro Q na estrutura M da forma padrão, permitindo síntese ótima de controladores robustos via otimização de Q estável.",
                        "specificSkills": [
                          {
                            "id": "76.4.4.3.1",
                            "name": "Expressar M em termos de Q",
                            "description": "Mostrar que as entradas de M dependem linearmente/afim de Q, como Tzw(Q) = T11 + T12 Q (I - T22 Q)^{-1} T21, ligando parametrização à forma padrão.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar a Forma Padrão e Definições dos Blocos Tij",
                                  "subSteps": [
                                    "Recordar a configuração da planta generalizada (G) com entradas w, z e u, y.",
                                    "Identificar os blocos T11, T12, T21, T22 da partição da planta: T = [[T11, T12], [T21, T22]].",
                                    "Entender o laço fechado nominal Tzw(0) = T11 + T12 K (I - T22 K)^{-1} T21 com controlador nominal K.",
                                    "Verificar suposições de estabilidade: planta internamente estável ou coprime factorization."
                                  ],
                                  "verification": "Lista dos blocos Tij extraída corretamente de um diagrama de blocos ou matriz de transferência.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Livro-texto de Controle Avançado (e.g., Zhou, Doyle, Glover)",
                                    "Papel e caneta ou software como MATLAB/Simulink para diagramas"
                                  ],
                                  "tips": "Desenhe o diagrama de blocos para visualizar as conexões entre w, z, u, y.",
                                  "learningObjective": "Compreender a estrutura LFT (Linear Fractional Transformation) da planta generalizada.",
                                  "commonMistakes": "Confundir T12 com T21 ou ignorar a direção das setas no diagrama."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Introduzir o Parâmetro Q e a Parametrização do Controlador",
                                  "subSteps": [
                                    "Definir Q como uma função de transferência estável (parte do conjunto de estabilizadores).",
                                    "Escrever o controlador parametrizado: C(Q) = (X + D Q)(Y - N Q)^{-1}, onde (N,M) e (D,X) são fatores coprimos da planta e nominal.",
                                    "Mostrar que todos os controladores estabilizadores são obtidos variando Q estável."
                                  ],
                                  "verification": "Escrever a expressão C(Q) corretamente e listar propriedades de estabilidade.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Notas de aula sobre parametrização de Youla-Kucera",
                                    "Calculadora simbólica como Mathematica ou SymPy"
                                  ],
                                  "tips": "Lembre-se: Q pertence a RH_infty para garantir estabilidade interna.",
                                  "learningObjective": "Dominar a parametrização Q que gera todos os controladores estabilizadores.",
                                  "commonMistakes": "Usar Q instável ou esquecer a inversão (Y - N Q)."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Derivar a Expressão de Tzw(Q) em Termos de Q",
                                  "subSteps": [
                                    "Substituir C(Q) na fórmula do laço fechado Tzw.",
                                    "Aplicar a fórmula de transformação fracionária linear: Tzw(Q) = T11 + T12 Q (I - T22 Q)^{-1} T21.",
                                    "Expandir algebricamente para mostrar dependência afim em Q (termo constante + termo linear em Q resolvido)."
                                  ],
                                  "verification": "Derivação passo-a-passo matches a fórmula padrão sem erros algébricos.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Folha de derivações matriciais",
                                    "MATLAB para manipulação simbólica de tfdata"
                                  ],
                                  "tips": "Use identidades de feedback: Fl(T, Q) = T11 + T12 Q (I - T22 Q)^{-1} T21.",
                                  "learningObjective": "Derivar explicitamente como M (Tzw) depende linearmente/afim de Q.",
                                  "commonMistakes": "Erro na ordem de multiplicação matricial ou esquecer o denominador (I - T22 Q)."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificar Linearidade/Afinidade e Ligar à Forma Padrão",
                                  "subSteps": [
                                    "Mostrar que Tzw(Q) = A + B Q (I - C Q)^{-1} D, onde A=T11, B=T12, C=T22, D=T21 (afinidade).",
                                    "Verificar para Q=0: recupera Tzw nominal.",
                                    "Discutir implicações: conjunto de M estável é {Tzw(Q) | Q estável} e convexo.",
                                    "Aplicar em um sistema SISO simples para confirmação numérica."
                                  ],
                                  "verification": "Gráfico ou tabela mostrando Tzw(Q) vs Q linear/afim.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Exemplo numérico em MATLAB (sys = tf(...))",
                                    "Simulador de resposta em frequência (bode plot)"
                                  ],
                                  "tips": "Teste com Q escalar pequeno para validar numericamente.",
                                  "learningObjective": "Interpretar a relação parametrização-forma padrão e sua utilidade em síntese ótima.",
                                  "commonMistakes": "Assumir linearidade estrita ignorando o termo resolvido; é afim."
                                }
                              ],
                              "practicalExample": "Para P(s)=1/(s+1), controlador nominal K=1, compute T11=[0 1; 0 0], etc., e mostre Tzw(Q)= Q / (1 + Q) para entrada-saída simples, variando Q(s)=k/(s+1).",
                              "finalVerifications": [
                                "Expressão Tzw(Q) matches exatamente T11 + T12 Q (I - T22 Q)^{-1} T21.",
                                "Para Q=0, recupera mapa nominal correto.",
                                "Inverso (I - T22 Q) bem-definido para Q estável pequeno.",
                                "Simulação numérica confirma dependência afim em ganho de Q.",
                                "Estabilidade preservada para ||Q||_infty < 1/||T22||."
                              ],
                              "assessmentCriteria": [
                                "Precisão algébrica na derivação (sem erros de sinal ou ordem).",
                                "Compreensão conceitual: explicar por que é afim em Q.",
                                "Aplicação correta em exemplo SISO/MIMO simples.",
                                "Análise de estabilidade via RH_infty.",
                                "Criatividade em extensão para otimização H2/Hinfty."
                              ],
                              "crossCurricularConnections": [
                                "Álgebra Linear: Manipulação de blocos matriciais e inversas de Schur.",
                                "Análise Funcional: Espaços de Hardy RH_infty para estabilidade.",
                                "Programação Numérica: Implementação em MATLAB Control Toolbox.",
                                "Otimização: Convexidade do conjunto de M para síntese ótima.",
                                "Processos Industriais: Aplicação em tuning adaptativo de PIDs."
                              ],
                              "realWorldApplication": "Em design de controladores robustos para aviões (e.g., Boeing fly-by-wire), onde Q parametrizes trade-offs entre performance e robustez a incertezas de modelo, permitindo otimização online sem perda de estabilidade."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "76.4.4.2.1",
                              "76.4.4.1.3"
                            ]
                          },
                          {
                            "id": "76.4.4.3.2",
                            "name": "Analisar robustez via parametrização",
                            "description": "Interpretar condições de robustez ||Fl(M,Δ)||∞ <1 como restrições sobre Q, e introduzir síntese H∞ como min_Q ||M(Q)||∞.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Parametrização de Controladores e Forma Padrão",
                                  "subSteps": [
                                    "Relembre a estrutura da parametrização de todos os estabilizadores: C = Q / (1 - M Q), onde M é o nominal.",
                                    "Desenhe o diagrama de blocos da forma padrão com planta P, controlador K e sinais de entrada/saída.",
                                    "Identifique os blocos M, Δ (incerteza) e o sistema interconectado Fl(M, Δ).",
                                    "Calcule a norma H∞ de Fl(M, Δ) para um caso simples sem controlador.",
                                    "Verifique estabilidade nominal com Q estabilizador."
                                  ],
                                  "verification": "Desenhe corretamente o diagrama da forma padrão e compute ||M||∞ < 1 para estabilidade.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Livro de controle avançado (ex: Zhou, Doyle), MATLAB/Simulink para diagramas.",
                                  "tips": "Use blocos de sinal para visualizar conexões em Simulink.",
                                  "learningObjective": "Compreender a base da parametrização para análise de robustez.",
                                  "commonMistakes": "Confundir M com a planta nominal P; sempre diferencie."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Interpretar a Condição de Robustez ||Fl(M, Δ)||∞ < 1",
                                  "subSteps": [
                                    "Defina Fl(M, Δ) = M11 + M12 Δ (I - M22 Δ)^(-1) M21.",
                                    "Explique por que ||Fl(M, Δ)||∞ < 1 garante robustez para ||Δ||∞ < 1.",
                                    "Derive a pequena ganho teorema: se ||M||∞ < 1, então estável para qualquer ||Δ||∞ < 1.",
                                    "Simule um Δ escalar e plote resposta de Fl(M, Δ).",
                                    "Discuta implicações para incertezas aditivas/multiplicativas."
                                  ],
                                  "verification": "Prove que ||Fl(M, Δ)||∞ < 1 implica estabilidade robusta via cálculo manual.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Notas de aula sobre H∞, MATLAB para simulação de normas.",
                                  "tips": "Use svd ou hinfnorm no MATLAB para computar normas rapidamente.",
                                  "learningObjective": "Dominar a interpretação da condição de robustez na forma padrão.",
                                  "commonMistakes": "Ignorar inversibilidade de (I - M22 Δ); assuma sempre pertubações pequenas."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Traduzir Condição de Robustez em Restrições sobre Q",
                                  "subSteps": [
                                    "Expresse M(Q) explicitamente: M11, M12, M21, M22 em termos de Q.",
                                    "Substitua na condição: ||M11 + M12 Δ (I - M22 Δ)^(-1) M21||∞ < 1.",
                                    "Simplifique para Δ conhecido: derive bound superior sobre ||Q|| ou similar.",
                                    "Para robustez estruturada, isole termos dependentes de Q.",
                                    "Resolva para condições em Q via desigualdades lineares ou LMIs."
                                  ],
                                  "verification": "Escreva M(Q) para um sistema SISO e isole restrições em Q.",
                                  "estimatedTime": "75 minutos",
                                  "materials": "Papel e lápis para derivações, YALMIP/MATLAB para LMIs iniciais.",
                                  "tips": "Comece com Δ diagonal para simplificar cálculos.",
                                  "learningObjective": "Converter análise de robustez em constraints acionáveis sobre Q.",
                                  "commonMistakes": "Esquecer dependência de Q em todos os blocos Mij."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Introduzir Síntese H∞ como min_Q ||M(Q)||∞",
                                  "subSteps": [
                                    "Formule o problema: encontrar Q estabilizador minimizando γ = ||M(Q)||∞.",
                                    "Discuta interpretação: γ ótimo é o limite de robustez máxima.",
                                    "Revise solução via LMIs ou métodos de riccati para H∞.",
                                    "Implemente um solver simples em MATLAB para um exemplo.",
                                    "Compare Q ótimo com Q nominal em simulações."
                                  ],
                                  "verification": "Resolva min ||M(Q)||∞ para um sistema de segunda ordem e verifique γ < 1.",
                                  "estimatedTime": "90 minutos",
                                  "materials": "MATLAB Robust Control Toolbox, tutoriais H∞ synthesis.",
                                  "tips": "Use hinfsyn() para protótipo rápido antes de teoria.",
                                  "learningObjective": "Entender síntese ótima de robustez via parametrização.",
                                  "commonMistakes": "Não garantir que Q estabilize o loop fechado."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Aplicar e Validar Análise em um Caso Prático",
                                  "subSteps": [
                                    "Escolha um sistema com incerteza (ex: planta com ganho variável).",
                                    "Compute restrições em Q e sintetize controlador H∞.",
                                    "Simule robustez para múltiplos Δ.",
                                    "Analise trade-offs entre performance e robustez.",
                                    "Documente relatório com gráficos de Bode e step responses."
                                  ],
                                  "verification": "Demonstre estabilidade para ||Δ||∞ = 0.9 γ em simulação.",
                                  "estimatedTime": "120 minutos",
                                  "materials": "Simulink para simulações, LaTeX para relatório.",
                                  "tips": "Varie Δ em malha para visualizar margens de robustez.",
                                  "learningObjective": "Integrar análise em workflow de design de controladores.",
                                  "commonMistakes": "Sobreestimar robustez sem validar com Monte Carlo."
                                }
                              ],
                              "practicalExample": "Para uma planta de motor DC com incerteza de 20% no ganho (Δ multiplicativo), compute M(Q), derive ||Fl(M,Δ)||∞ <1 como |Q(jω)| < 1/(1 + |P(jω)|) para todos ω, e sintetize Q via H∞ minimizando γ=1.2, simulando step responses robustas.",
                              "finalVerifications": [
                                "Pode derivar M(Q) explicitamente para um sistema dado.",
                                "Interpreta corretamente ||Fl(M,Δ)||∞ <1 como bound em Q.",
                                "Formula min_Q ||M(Q)||∞ e resolve via software.",
                                "Valida robustez em simulação com Δ randômicos.",
                                "Explica trade-offs com performance nominal.",
                                "Documenta análise com normas e gráficos."
                              ],
                              "assessmentCriteria": [
                                "Precisão na derivação de restrições sobre Q (90% correto).",
                                "Corretude da síntese H∞ com γ < threshold dado.",
                                "Qualidade das simulações (estabilidade para 95% dos Δ testados).",
                                "Clareza na explicação verbal da condição de robustez.",
                                "Integração correta com forma padrão sem erros algébricos.",
                                "Criatividade em extensão para robustez estruturada."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Otimização convexa e LMIs.",
                                "Programação: Implementação numérica em MATLAB/Python (Control Systems Library).",
                                "Física: Modelagem de sistemas dinâmicos com incertezas reais.",
                                "Estatística: Análise de Monte Carlo para validação probabilística."
                              ],
                              "realWorldApplication": "Em aviões autônomos, analisar robustez de controladores de voo contra variações de massa/vento via parametrização, sintetizando Q H∞ para garantir estabilidade em turbulências, usado em certificação FAA."
                            },
                            "estimatedTime": "0.75 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "76.4.4.3.1"
                            ]
                          },
                          {
                            "id": "76.4.4.3.3",
                            "name": "Aplicar em exemplo escalar",
                            "description": "Resolver um problema simples de robustez usando parametrização na forma padrão, computando Q ótimo via MATLAB ou analiticamente.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Configurar o exemplo escalar e definir a planta nominal",
                                  "subSteps": [
                                    "Escolha uma planta escalar simples estável ou instável, ex: P(s) = 1/(s - 1).",
                                    "Defina o modelo de incerteza, ex: perturbação aditiva Δ(s) com ||Δ||∞ ≤ w.",
                                    "Especifique os requisitos de robustez, como estabilidade para todas as plantas perturbadas.",
                                    "Documente os dados iniciais em um script MATLAB ou papel.",
                                    "Verifique se a planta é coprime fatorizável."
                                  ],
                                  "verification": "Planta P(s) e incerteza Δ definida com gráficos de Bode ou polos/zeros plotados.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "MATLAB com Control System Toolbox, papel e lápis para esboços analíticos.",
                                  "tips": "Comece com plantas de primeira ou segunda ordem para simplicidade.",
                                  "learningObjective": "Entender a configuração de um problema de robustez escalar.",
                                  "commonMistakes": "Escolher plantas muito complexas no início; ignorar normalização da incerteza."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Obter fatorizações coprime e Bezout identity",
                                  "subSteps": [
                                    "Realize fatorização coprime direita: P = N/M com N, M estáveis e coprime.",
                                    "Encontre X, Y estáveis tais que X M - Y N = 1 (identidade de Bezout).",
                                    "Use MATLAB: [N,M,X,Y] = coprime(P) ou resolva analiticamente para exemplos simples.",
                                    "Valide a identidade Bezout computando X*M - Y*N.",
                                    "Plote os fatores para inspeção visual."
                                  ],
                                  "verification": "Identidade Bezout verificada numericamente (erro < 1e-10) e fatores estáveis (polos no semiplano esquerdo).",
                                  "estimatedTime": "45 minutos",
                                  "materials": "MATLAB (funções coprime, tf, bode), calculadora simbólica opcional.",
                                  "tips": "Para analítico, use frações parciais; MATLAB acelera para casos gerais.",
                                  "learningObjective": "Dominar fatorizações coprime na parametrização padrão.",
                                  "commonMistakes": "Fatorizações não coprime (verifique gcd); confundir esquerda/direita."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Formular a parametrização do controlador e o problema de robustez",
                                  "subSteps": [
                                    "Escreva C = (X + M Q)/(Y - N Q) para Q estável.",
                                    "Expresse a condição de robustez: ||T||∞ < 1/||Δ||∞ onde T é o closed-loop transfer function.",
                                    "Para aditiva: T = -P K (I + P K)^(-1) = N (Y - N Q) em termos de Q.",
                                    "Defina o objetivo: min ||Φ(Q)||∞ onde Φ é função afim em Q.",
                                    "Simplifique para escalar: encontre Q que minimiza a norma H∞."
                                  ],
                                  "verification": "Expressões de T e Φ(Q) derivadas corretamente e coincidem com referências teóricas.",
                                  "estimatedTime": "40 minutos",
                                  "materials": "Folha de derivações, MATLAB para simular loops fechados iniciais.",
                                  "tips": "Use blocos de diagrama para visualizar a estrutura padrão.",
                                  "learningObjective": "Conectar parametrização à análise de robustez.",
                                  "commonMistakes": "Erro no sinal de T; esquecer estabilidade bem-posedness (det(I+P C)≠0)."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Computar Q ótimo analiticamente ou via MATLAB",
                                  "subSteps": [
                                    "Analítico: Resolva min_||Q||∞ s.t. ||Φ(Q)||∞ < γ via otimização escalar.",
                                    "Para escalar simples, Q(s) = constante ou low-pass filter ajustado.",
                                    "MATLAB: Use hinfsyn ou loop manual com hinfnorm e otimização (fminsearch).",
                                    "Itere γ até mínimo viável (γ_opt).",
                                    "Compute C final e verifique estabilidade."
                                  ],
                                  "verification": "||Φ(Q_opt)||∞ minimizado e < γ desejado; simulação step response estável.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "MATLAB (hinfsyn, hinfnorm, robust-control toolbox), equações simbólicas.",
                                  "tips": "Comece analítico para entendimento, valide com MATLAB.",
                                  "learningObjective": "Aplicar otimização H∞ na parametrização.",
                                  "commonMistakes": "Q não estável; otimização converge para γ inválido."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Simular e validar a solução robusta",
                                  "subSteps": [
                                    "Implemente C em simulação closed-loop com P nominal e perturbada.",
                                    "Plote respostas ao degrau para nominal e worst-case Δ.",
                                    "Verifique margens de ganho/fase e robustez via mu-analysis se possível.",
                                    "Compare com controlador não robusto (ex: PID).",
                                    "Documente resultados em relatório curto."
                                  ],
                                  "verification": "Sistema estável para ||Δ||∞=1; overshoot <20%, settling time <5s.",
                                  "estimatedTime": "35 minutos",
                                  "materials": "MATLAB Simulink ou lsim/stepinfo, gráficos de robustez.",
                                  "tips": "Use wcgain para análise de worst-case.",
                                  "learningObjective": "Validar numericamente a robustez computada.",
                                  "commonMistakes": "Simular apenas nominal; ignorar perturbações de alta frequência."
                                }
                              ],
                              "practicalExample": "Planta P(s) = 1/(s-1), incerteza aditiva |Δ(jω)| ≤ 0.5/|P(jω)|. Fatorize P=N/M com N=1/(s+1), M=(s)/(s+1). Bezout X=1/(s+1), Y=1/(s+1). Para robustez aditiva, Φ(Q) = M Q. Q_opt = k/(s+1) com k escolhido para ||Φ||∞ < 2. Simule em MATLAB: step(feedback(P*C,1)) e com P+Δ.",
                              "finalVerifications": [
                                "Controlador C estabiliza P nominal e todas P+Δ com ||Δ||∞≤1.",
                                "||Φ(Q_opt)||∞ é mínimo possível e satisfaz γ < 1/||wΔ||∞.",
                                "Resposta ao degrau: rise time <2s, overshoot <15% para casos perturbados.",
                                "Margens de robustez: GM>6dB, PM>45° para planta nominal.",
                                "Código MATLAB reproduzível gera mesmos resultados.",
                                "Derivações analíticas coincidem com simulações numéricas."
                              ],
                              "assessmentCriteria": [
                                "Corretude das fatorizações coprime e identidade Bezout (20%).",
                                "Formulação precisa do problema H∞ em termos de Q (25%).",
                                "Computação de Q_opt viável e ótimo (analítico ou numérico, 25%).",
                                "Validação via simulações robustas com plots (20%).",
                                "Clareza da documentação e interpretação dos resultados (10%)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Otimização convexa e normas de Hardy (H∞).",
                                "Programação: Uso avançado de MATLAB para sistemas lineares.",
                                "Física: Modelagem dinâmica de sistemas reais (ex: motores DC).",
                                "Estatística: Análise de worst-case e Monte Carlo para robustez."
                              ],
                              "realWorldApplication": "Projeto de controladores robustos para drones em ventos variáveis (P= modelo aerodinâmico, Δ= turbulência), garantindo estabilidade sem re-tuning manual em produção industrial."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "76.4.4.3.2"
                            ]
                          }
                        ]
                      }
                    ]
                  }
                ]
              },
              {
                "id": "10.1.5",
                "name": "Projeto H∞ e μ-Síntese",
                "description": "Técnicas de projeto H∞ e μ-síntese para controle robusto avançado em sistemas escalares.",
                "totalSkills": 39,
                "atomicTopics": [
                  {
                    "id": "10.1.5.1",
                    "name": "Formatação de Malha",
                    "description": "Técnica de modelagem em malha fechada para preparar o sistema para síntese de controladores robustos em LIT escalares.",
                    "individualConcepts": [
                      {
                        "id": "10.1.5.1.1",
                        "name": "Fundamentos da Formatação de Malha",
                        "description": "Introdução aos princípios básicos da formatação de malha como técnica para moldar a resposta em frequência da malha aberta, preparando o sistema para síntese de controladores H∞ robustos em sistemas LIT escalares.",
                        "specificSkills": [
                          {
                            "id": "10.1.5.1.1.1",
                            "name": "Definir formatação de malha em controle robusto",
                            "description": "Explicar o conceito de formatação de malha como modificação da planta nominal através de pesos de desempenho e robustez para alcançar especificações desejadas em termos de valores singulares da malha aberta.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender valores singulares e planta nominal em controle robusto",
                                  "subSteps": [
                                    "Estudar a definição de valores singulares de uma matriz de transferência.",
                                    "Revisar o conceito de planta nominal em síntese H∞.",
                                    "Analisar o papel da malha aberta na especificação de desempenho.",
                                    "Explorar funções de singular value σ̄(G(jω)) e σ̲(G(jω)).",
                                    "Praticar cálculo de singular values para plantas simples."
                                  ],
                                  "verification": "Calcular corretamente os valores singulares de uma planta exemplo e plotar seu gráfico de Bode.",
                                  "estimatedTime": "1-2 horas",
                                  "materials": [
                                    "Livro de Skogestad e Postlethwaite 'Multivariable Feedback Control'",
                                    "MATLAB com toolbox Control System",
                                    "Notas de aula sobre álgebra linear"
                                  ],
                                  "tips": "Use o comando svd no MATLAB para visualizar singular values rapidamente.",
                                  "learningObjective": "Dominar os fundamentos matemáticos de valores singulares aplicados a sistemas dinâmicos multivariáveis.",
                                  "commonMistakes": [
                                    "Confundir singular values com autovalores.",
                                    "Ignorar a dependência em frequência ω.",
                                    "Não normalizar a planta adequadamente."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Introduzir o conceito de formatação de malha (Loop Shaping)",
                                  "subSteps": [
                                    "Definir formatação de malha como modificação da planta P_nominal com pesos W_p e W_r.",
                                    "Explicar a planta shaped: P_s = W_p * P_nominal * W_r.",
                                    "Discutir o objetivo de moldar a malha aberta L = K * P_s para atender specs.",
                                    "Estudar o teorema de maximização da distância de estabilidade.",
                                    "Visualizar diagramas de loop shaping em gráficos de singular values.",
                                    "Comparar com métodos clássicos de design de controladores."
                                  ]
                                },
                                "verification`: "
                              ]
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.1.1.2",
                            "name": "Identificar objetivos da formatação de malha",
                            "description": "Descrever os objetivos principais, como maximizar a distância de estabilidade, otimizar desempenho (crossover frequency, margens de fase e ganho) e acomodar incertezas multiplicativas ou aditivas.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os fundamentos da formatação de malha",
                                  "subSteps": [
                                    "Defina formatação de malha (loop shaping) como o processo de moldar a função de malha aberta para atender objetivos de controle.",
                                    "Revise a estrutura típica de uma malha de controle: planta P(s), controlador K(s), função de malha L(s) = P(s)K(s).",
                                    "Identifique o papel da formatação de malha no contexto H∞ e μ-Síntese.",
                                    "Estude diagramas de Bode para visualizar a malha.",
                                    "Discuta por que a formatação é iterativa e baseada em trade-offs."
                                  ],
                                  "verification": "Resuma em 3 frases os fundamentos e desenhe um diagrama simples de malha.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Notas de aula sobre controle avançado, software MATLAB/Simulink, diagrama de Bode de exemplo.",
                                  "tips": "Comece sempre pelo diagrama de blocos para visualizar a malha antes de mergulhar em equações.",
                                  "learningObjective": "Entender o conceito base e a estrutura da formatação de malha.",
                                  "commonMistakes": "Confundir malha aberta com malha fechada; ignorar a importância da visualização gráfica."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar o objetivo de maximizar a distância de estabilidade",
                                  "subSteps": [
                                    "Defina distância de estabilidade como a distância mínima de L(jω) ao ponto crítico -1 no plano complexo.",
                                    "Aprenda a medir via diagrama de Nyquist: distância ao -1 + j0.",
                                    "Relacione com norma H∞: ||L||∞ pequeno implica boa estabilidade.",
                                    "Calcule exemplos numéricos simples de distância para malhas diferentes.",
                                    "Discuta como maximizar essa distância evita instabilidade."
                                  ],
                                  "verification": "Calcule a distância de estabilidade para uma L(s) dada e confirme > 0.5.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "MATLAB para plot Nyquist, exemplos de funções de transferência.",
                                  "tips": "Use o comando 'nyquist' no MATLAB para visualização rápida; foque em baixas frequências.",
                                  "learningObjective": "Dominar a métrica de estabilidade e sua maximização.",
                                  "commonMistakes": "Medir distância errada (ex: ao invés de módulo); confundir com margens de ganho."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Otimizar métricas de desempenho: frequência de crossover, margens de fase e ganho",
                                  "subSteps": [
                                    "Defina frequência de crossover ω_c como onde |L(jω_c)| = 1.",
                                    "Explique margens: ganho (até |L| crescer 6dB), fase (até -180° + 45° típico).",
                                    "Estabeleça objetivos: ω_c alta para resposta rápida, margens >6dB/45° para robustez.",
                                    "Analise trade-offs: alta ω_c reduz margens.",
                                    "Pratique ajuste via filtros lead/lag em diagramas de Bode."
                                  ],
                                  "verification": "Ajuste uma malha para ω_c = 10 rad/s com margens >8dB/60° e verifique.",
                                  "estimatedTime": "75 minutos",
                                  "materials": "Simulink para simulações de Bode, templates de controladores.",
                                  "tips": "Aumente ω_c gradualmente e monitore margens simultaneamente.",
                                  "learningObjective": "Identificar e otimizar métricas de desempenho na formatação.",
                                  "commonMistakes": "Priorizar apenas velocidade sem checar margens; ignorar picos de ressonância."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Acomodar incertezas multiplicativas e aditivas na formatação",
                                  "subSteps": [
                                    "Defina incertezas: multiplicativas Δ_m (variação relativa em P), aditivas Δ_a (ruído/distúrbios).",
                                    "Incorpore em modelo: P_pert = P(1 + W_m Δ_m) + W_a Δ_a, com ||Δ||∞ ≤1.",
                                    "Ajuste pesos W_m, W_a para cobrir faixa de operação.",
                                    "Verifique robustez via μ-análise ou simulações com variações.",
                                    "Integre todos objetivos: estabilidade, desempenho e robustez."
                                  ],
                                  "verification": "Simule malha com ±20% variação em P e confirme estabilidade e desempenho.",
                                  "estimatedTime": "90 minutos",
                                  "materials": "MATLAB Robust Control Toolbox, exemplos de plantas com incertezas.",
                                  "tips": "Escolha pesos W baseados em dados reais de variação; teste extremos.",
                                  "learningObjective": "Incorporar robustez contra incertezas nos objetivos.",
                                  "commonMistakes": "Subestimar incertezas reais; não normalizar pesos adequadamente."
                                }
                              ],
                              "practicalExample": "Em um sistema de controle de velocidade de um motor DC (P(s) = 1/(s+1)), formate a malha para: distância de estabilidade >0.6, ω_c=5 rad/s, margens>10dB/60°, robusto a ±15% variação no ganho (incerteza multiplicativa). Use K(s) com lead compensador e simule step response no Simulink.",
                              "finalVerifications": [
                                "Liste e explique os 4 objetivos principais da formatação de malha.",
                                "Calcule distância de estabilidade e margens para uma L(s) exemplo.",
                                "Descreva trade-offs entre ω_c alta e robustez.",
                                "Simule impacto de incerteza aditiva em uma malha formatada.",
                                "Crie um checklist pessoal para formatação futura.",
                                "Explique diferença entre incertezas multiplicativas e aditivas com exemplo."
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição de distância de estabilidade (90% correto).",
                                "Correta identificação de trade-offs em desempenho (ex: ω_c vs margens).",
                                "Demonstração prática via simulação com resultados quantificados.",
                                "Integração completa de incertezas nos objetivos.",
                                "Clareza na explicação oral/escrita dos 4 objetivos principais.",
                                "Criatividade em exemplos reais aplicados."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Análise complexa e normas H∞.",
                                "Física: Dinâmica de sistemas e modelagem de plantas.",
                                "Programação: Simulações em MATLAB/Simulink e Robust Control Toolbox.",
                                "Estatística: Análise de incertezas e modelagem estocástica."
                              ],
                              "realWorldApplication": "Na aviação, formatação de malha em controladores de flight para maximizar estabilidade apesar de variações aerodinâmicas (incertezas), alta frequência de resposta para manobras rápidas e margens robustas contra turbulências."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.1.1.3",
                            "name": "Revisar ferramentas clássicas para formatação",
                            "description": "Aplicar técnicas clássicas como diagramas de Bode e Nyquist para avaliar e ajustar inicialmente a malha aberta antes da síntese avançada.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar conceitos e construção do Diagrama de Bode",
                                  "subSteps": [
                                    "Recordar a definição do diagrama de Bode como representação em frequência do módulo e fase da função de transferência.",
                                    "Aprender a converter a função de transferência em termos de frequência angular ω.",
                                    "Plotar o diagrama de magnitude (em dB) e fase (em graus) manualmente para polos e zeros simples.",
                                    "Identificar margens de ganho e fase a partir do diagrama.",
                                    "Praticar com software para validar plots manuais."
                                  ],
                                  "verification": "Plotar corretamente o diagrama de Bode para uma função de transferência simples e identificar margens.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Função de transferência exemplo, papel milimetrado, MATLAB ou Python (control library), calculadora.",
                                  "tips": "Use aproximações assintóticas para agilizar o plot manual; verifique com log-log para magnitude.",
                                  "learningObjective": "Compreender a construção e interpretação básica do diagrama de Bode para análise em frequência.",
                                  "commonMistakes": "Esquecer o fator -20 dB/década por polo; confundir magnitude com fase."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Aplicar Diagrama de Bode para avaliação inicial da malha aberta",
                                  "subSteps": [
                                    "Obter a função de transferência da malha aberta G(s).",
                                    "Analisar cruzamentos de 0 dB e -180° para estabilidade.",
                                    "Calcular margens de ganho (GM) e fase (PM) usando o diagrama.",
                                    "Avaliar desempenho: banda passante, picos de ressonância.",
                                    "Propor ajustes simples como ganho proporcional para melhorar margens."
                                  ],
                                  "verification": "Relatório com GM, PM e sugestões de ajuste para um sistema dado.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "MATLAB/Simulink, exemplos de plantas industriais, template de relatório.",
                                  "tips": "PM > 45° e GM > 6 dB são bons iniciais; amplie escala de frequência para detalhes.",
                                  "learningObjective": "Usar Bode para avaliar estabilidade e desempenho da malha aberta.",
                                  "commonMistakes": "Ignorar atrasos de fase em altas frequências; superestimar estabilidade sem múltiplos cruzamentos."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Revisar conceitos e construção do Diagrama de Nyquist",
                                  "subSteps": [
                                    "Entender o critério de Nyquist para estabilidade via contorno no plano complexo.",
                                    "Mapear a função de transferência G(jω) de ω = 0 a ∞.",
                                    "Identificar encirclements do ponto crítico (-1,0).",
                                    "Plotar manualmente para sistemas de baixa ordem e validar com software.",
                                    "Analisar estabilidade absoluta e relativa."
                                  ],
                                  "verification": "Plotar Nyquist e determinar número de polos instáveis do laço fechado.",
                                  "estimatedTime": "50 minutos",
                                  "materials": "Plano complexo (papel), MATLAB (nyquist()), exemplos com polos conhecidos.",
                                  "tips": "Comece por ω baixa (ganho alto) e vá para alta; use simetria para ω negativa.",
                                  "learningObjective": "Dominar a construção e interpretação do diagrama de Nyquist.",
                                  "commonMistakes": "Errar o sentido do contorno (horário vs anti-horário); esquecer indentação em jω=0."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Integrar Bode e Nyquist para ajustes iniciais da malha aberta",
                                  "subSteps": [
                                    "Comparar análises de Bode e Nyquist para o mesmo sistema.",
                                    "Ajustar parâmetros (ex: ganho K) para margens desejadas em ambos.",
                                    "Simular laço fechado e verificar estabilidade.",
                                    "Documentar trade-offs entre robustez e desempenho.",
                                    "Preparar para transição à síntese avançada H∞."
                                  ],
                                  "verification": "Sistema ajustado com margens aceitáveis e simulação estável.",
                                  "estimatedTime": "75 minutos",
                                  "materials": "Simulink para simulação, folhas de cálculo para margens.",
                                  "tips": "Priorize Nyquist para estabilidade condicional; Bode para desempenho.",
                                  "learningObjective": "Combinar ferramentas clássicas para formatação inicial robusta da malha.",
                                  "commonMistakes": "Ajustar apenas ganho sem verificar não-minimum phase; ignorar ruído em altas frequências."
                                }
                              ],
                              "practicalExample": "Para um motor DC com planta G(s) = 100 / (s(s+10)), plote Bode e Nyquist da malha aberta. Identifique PM=30° baixa no Bode, confirme encirclement zero no Nyquist, e ajuste K=0.5 para PM>50° e GM>8dB antes de H∞.",
                              "finalVerifications": [
                                "Diagrama de Bode plotado com margens GM e PM corretas.",
                                "Diagrama de Nyquist mostra estabilidade sem encirclements indesejados.",
                                "Ajustes iniciais melhoram margens em pelo menos 20%.",
                                "Simulação do laço fechado confirma overshoot <20% e tempo de estabilização <5s.",
                                "Relatório compara análises de Bode e Nyquist.",
                                "Preparação documentada para síntese H∞."
                              ],
                              "assessmentCriteria": [
                                "Precisão na plotagem de diagramas (±5% em margens).",
                                "Correta interpretação de estabilidade e desempenho.",
                                "Ajustes propostos viáveis e justificados.",
                                "Integração coerente de Bode e Nyquist.",
                                "Uso adequado de ferramentas de software.",
                                "Clareza no relatório com trade-offs."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Transformada de Fourier e funções complexas.",
                                "Programação: Scripts MATLAB para automação de plots.",
                                "Física: Modelagem dinâmica de sistemas mecânicos/elétricos.",
                                "Estatística: Análise de robustez via margens probabilísticas."
                              ],
                              "realWorldApplication": "Na indústria automotiva, usa-se Bode/Nyquist para tuning inicial de controladores de suspensão ativa ou ABS, garantindo estabilidade antes de métodos avançados como H∞ em veículos autônomos."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.5.1.2",
                        "name": "Modelagem de Incertezas e Forma Padrão",
                        "description": "Técnicas para modelar incertezas no sistema e estruturar o problema na forma padrão geral (GPD) necessária para síntese de controladores robustos via H∞.",
                        "specificSkills": [
                          {
                            "id": "10.1.5.1.2.1",
                            "name": "Modelar incertezas em sistemas LIT escalares",
                            "description": "Representar incertezas como perturbações normais, multiplicativas ou inversas na planta, utilizando blocos Δ para capturar variações paramétricas e dinâmicas não modeladas.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Identificar e classificar fontes de incerteza na planta nominal",
                                  "subSteps": [
                                    "Revise a planta nominal LIT escalar G(s) e liste parâmetros incertos (ex.: ganho, tempo constante).",
                                    "Classifique incertezas em paramétricas (variações em coeficientes) e dinâmicas (não modeladas).",
                                    "Defina limites de incerteza usando normas (ex.: ||Δ||∞ ≤ 1).",
                                    "Desenhe diagrama de bloco da planta nominal.",
                                    "Documente suposições sobre distribuições (ex.: normal para ruído)."
                                  ],
                                  "verification": "Lista completa de incertezas classificadas com limites quantitativos documentada.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Papel e lápis, MATLAB para plotar respostas nominais, livro de controle robusto (ex.: Zhou et al.).",
                                  "tips": "Comece com incertezas paramétricas simples antes de dinâmicas complexas.",
                                  "learningObjective": "Classificar corretamente tipos de incertezas e quantificá-las.",
                                  "commonMistakes": "Ignorar incertezas dinâmicas ou superestimar limites sem base física."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Modelar perturbações normais como blocos aditivos Δ",
                                  "subSteps": [
                                    "Represente perturbação normal como Δ_n(s) adicionada à saída: G_Δ(s) = G(s) + W_n(s) Δ_n(s), com ||Δ_n||∞ ≤ 1.",
                                    "Escolha peso W_n(s) para capturar frequência e magnitude da incerteza.",
                                    "Implemente em diagrama de bloco com entrada w_n e saída z_n.",
                                    "Simule resposta com Δ_n = 1 em banda crítica.",
                                    "Ajuste W_n comparando com dados reais ou simulações Monte Carlo."
                                  ],
                                  "verification": "Diagrama de bloco com Δ_n integrado e simulação mostrando pior caso.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "MATLAB/Simulink, funções tf() e norm().",
                                  "tips": "Use Bode plot para moldar W_n intuitivamente.",
                                  "learningObjective": "Construir modelo de incerteza aditiva normalizada.",
                                  "commonMistakes": "Escolher W_n muito larga, violando conservadorismo."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Incorporar incertezas multiplicativas e inversas com blocos Δ",
                                  "subSteps": [
                                    "Para multiplicativa: G_Δ(s) = G(s) (I + W_m(s) Δ_m(s)), ||Δ_m||∞ ≤ 1.",
                                    "Para inversa: G_Δ(s) = G(s) / (I + W_i(s) Δ_i(s) G(s)), normalizando adequadamente.",
                                    "Conecte blocos Δ_m e Δ_i em entradas/saídas da planta.",
                                    "Crie pesos W_m(s) e W_i(s) baseados em variação relativa (ex.: 20% ganho).",
                                    "Valide estabilidade com Δ = 1 via root locus ou Nyquist."
                                  ],
                                  "verification": "Modelos completos para Δ_m e Δ_i com pesos e simulações de estabilidade.",
                                  "estimatedTime": "75 minutos",
                                  "materials": "Simulink para blocos personalizados, toolbox Robust Control.",
                                  "tips": "Inverta G(s) para modelar atuador/sensor em Δ_i.",
                                  "learningObjective": "Representar incertezas relativas usando blocos normalizados.",
                                  "commonMistakes": "Confundir multiplicativa com aditiva ou esquecer normalização."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Integrar modelo em forma padrão para análise H∞/μ",
                                  "subSteps": [
                                    "Monte malha fechada com controlador K(s): z = P [w; u], onde P inclui G_Δ e Δ.",
                                    "Reorganize em forma padrão: [z; y] = [M; N] [w; Δ], com ||Δ||∞ ≤ 1.",
                                    "Gere matrizes M e N explicitamente para sistema escalar.",
                                    "Teste com usys = lft(P, Δ) no MATLAB.",
                                    "Documente o modelo final com todos blocos Δ."
                                  ],
                                  "verification": "Matriz de forma padrão gerada e verificada com lft() sem erros.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "MATLAB Robust Control Toolbox, funções lft() e usample().",
                                  "tips": "Use sysic para interconexões automáticas.",
                                  "learningObjective": "Transformar modelo em configuração padrão para síntese robusta.",
                                  "commonMistakes": "Erros de sinal em conexões de feedback."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Validar e refinar o modelo de incertezas",
                                  "subSteps": [
                                    "Simule Monte Carlo com Δ aleatórios (normais unitárias).",
                                    "Compare ||Tzw||∞ nominal vs. incerto para conservadorismo.",
                                    "Ajuste pesos se μ >1 indicar modelagem insuficiente.",
                                    "Teste robustez com variações reais (ex.: ±10% parâmetros).",
                                    "Gere relatório com plots de singular values."
                                  ],
                                  "verification": "Relatório com simulações mostrando robustez (||Tzw||∞ <1).",
                                  "estimatedTime": "45 minutos",
                                  "materials": "MATLAB, funções wcgain() e musyn().",
                                  "tips": "Limite simulações a 100 runs para eficiência.",
                                  "learningObjective": "Avaliar e iterar modelo para precisão.",
                                  "commonMistakes": "Não checar conservadorismo, levando a controladores pobres."
                                }
                              ],
                              "practicalExample": "Para um sistema de controle de posição de motor DC com G(s) = 1/(s(s+1)), modele incerteza multiplicativa de 15% no ganho (W_m=0.15) e aditiva de ruído de sensor (W_n=0.01/s+1). Integre Δ_m e Δ_n, simule com lft() e verifique ||Tzw||∞ <1.",
                              "finalVerifications": [
                                "Diagrama de blocos completo com todos Δ normalizados.",
                                "Pesos W(s) com justificativa física e Bode plots.",
                                "Simulações Monte Carlo mostram variação <20% na performance.",
                                "Forma padrão P(s) válida para μ-síntese.",
                                "Estabilidade garantida para ||Δ||∞=1.",
                                "Relatório documenta limites e suposições."
                              ],
                              "assessmentCriteria": [
                                "Precisão na classificação e normalização de Δ (90% correto).",
                                "Qualidade dos pesos W(s) (matching com dados reais).",
                                "Correção da forma padrão (sem erros em lft()).",
                                "Validação quantitativa (||μ||∞ ≤1).",
                                "Clareza da documentação e plots.",
                                "Criatividade em refinar modelo iterativamente."
                              ],
                              "crossCurricularConnections": [
                                "Probabilidade e Estatística: Distribuições normais para Δ.",
                                "Otimização: Escolha de pesos via minimização de erro.",
                                "Física: Modelagem paramétrica de sistemas reais.",
                                "Programação: Implementação em MATLAB/Simulink.",
                                "Análise Numérica: Cálculo de normas e singular values."
                              ],
                              "realWorldApplication": "Em controle de voo de aeronaves, modela variações aerodinâmicas (Δ_m) e sensores ruidosos (Δ_n) para sintetizar controladores H∞ que mantêm estabilidade apesar de turbulências ou desgaste."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.5.1.1.1"
                            ]
                          },
                          {
                            "id": "10.1.5.1.2.2",
                            "name": "Construir a forma padrão do problema",
                            "description": "Estruturar o sistema em malha fechada na configuração GPD com planta P, controlador K, pesos W_e (desempenho) e W_u (controle), garantindo normalização adequada das incertezas.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Definir a Planta Nominal P e suas Entradas/Saídas",
                                  "subSteps": [
                                    "Identifique as entradas (u: controle, d: distúrbio, w: ruído) e saídas (y: medida, z: performance) do sistema.",
                                    "Modele a planta nominal P(s) usando funções de transferência ou estados-espaciais baseados nas especificações do problema.",
                                    "Especifique as dimensões das entradas e saídas para compatibilidade com o controlador K.",
                                    "Desenhe o diagrama de blocos inicial da planta P.",
                                    "Salve o modelo em formato compatível (ex: MATLAB .m ou Simulink)"
                                  ],
                                  "verification": "Verifique se o diagrama de blocos tem entradas/saídas corretamente rotuladas e dimensões compatíveis.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "MATLAB/Simulink, papel e lápis para diagrama, especificações do sistema",
                                  "tips": "Comece com um sistema SISO simples para validar antes de MIMO.",
                                  "learningObjective": "Compreender a estrutura básica da planta em controle H∞.",
                                  "commonMistakes": "Confundir entradas de performance (z) com saídas de medida (y); ignorar dimensões MIMO."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Incorporar Incertezas na Planta Generalizada",
                                  "subSteps": [
                                    "Modele incertezas aditivas/multiplicativas (Δ) como blocos normais (||Δ||∞ ≤1).",
                                    "Conecte incertezas às entradas/saídas relevantes da planta P (ex: Δ_p em P, Δ_m em sensor).",
                                    "Crie a configuração GPD inicial com P, entradas de incerteza e saídas generalizadas.",
                                    "Verifique conexões: entradas [w; d; u] → P → saídas [z; y].",
                                    "Implemente em software para simulação preliminar."
                                  ],
                                  "verification": "Simule com Δ=0 e confirme que o sinal flui corretamente sem erros dimensionais.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "MATLAB Control System Toolbox, Simulink para blocos de incerteza",
                                  "tips": "Use blocos 'ureal' no MATLAB para representar incertezas paramétricas.",
                                  "learningObjective": "Modelar incertezas de forma robusta na estrutura GPD.",
                                  "commonMistakes": "Colocar incertezas em pontos errados (ex: após controlador); não normalizar inicialmente."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Selecionar e Aplicar Pesos W_e e W_u",
                                  "subSteps": [
                                    "Escolha W_e para especificações de desempenho (ex: rastreamento, rejeição de distúrbio) baseado em ||Tzw||∞ <1.",
                                    "Defina W_u para limitação de esforço de controle (ex: ||Ku||∞ <1).",
                                    "Conecte W_e na saída de performance z e W_u na entrada de controle u.",
                                    "Ajuste ordens e ganhos iniciais dos pesos via análise de frequência (Bode).",
                                    "Atualize o diagrama GPD com pesos integrados."
                                  ],
                                  "verification": "Plote diagramas de Bode de W_e e W_u para confirmar roll-off adequado.",
                                  "estimatedTime": "50 minutos",
                                  "materials": "MATLAB (bode(), tf()), especificações de performance do problema",
                                  "tips": "W_e deve amplificar erros em baixas frequências; comece com templates padrão.",
                                  "learningObjective": "Usar pesos para moldar especificações em frequência.",
                                  "commonMistakes": "Pesos com fase errada; não inverter normalização de P."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Estruturar a Malha Fechada e Normalizar Incertezas",
                                  "subSteps": [
                                    "Insira o ponto de conexão do controlador K entre u e y na GPD.",
                                    "Normalize incertezas: escale Δ para ||Δ||∞ ≤1 ajustando ganhos.",
                                    "Confirme a forma padrão: entradas [w; Δ entradas] → GPD → saídas [z; y; Δ saídas].",
                                    "Implemente a função genplant() no MATLAB para gerar a GPD final.",
                                    "Teste estabilidade com K=0 (loop aberto)."
                                  ],
                                  "verification": "Execute sysic() no MATLAB e confirme matriz de interconexão válida.",
                                  "estimatedTime": "40 minutos",
                                  "materials": "MATLAB Robust Control Toolbox (genplant(), sysic())",
                                  "tips": "Sempre normalize P primeiro: divida por ||P||∞ se necessário.",
                                  "learningObjective": "Construir a forma padrão completa para síntese H∞.",
                                  "commonMistakes": "Esquecer normalização levando a ||Δ||∞ >1; erros em interconexões."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Validar a Forma Padrão Completa",
                                  "subSteps": [
                                    "Simule malha fechada com controlador fictício (ex: K=1).",
                                    "Verifique normas: ||W_e S||∞, ||W_u K S||∞ aproximadas.",
                                    "Analise sensibilidade a incertezas via μ-analysis preliminar.",
                                    "Documente equações da forma padrão: M = [M11 M12; M21 M22].",
                                    "Exporte modelo para síntese posterior."
                                  ],
                                  "verification": "Confirme que o problema está pronto para hinfsyn() sem warnings.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "MATLAB (hinfsyn(), musyn()), relatórios de simulação",
                                  "tips": "Use lft() para linear fractional transformation em validações.",
                                  "learningObjective": "Garantir robustez e prontidão para síntese.",
                                  "commonMistakes": "Ignorar singularidades; não checar estabilidade loop aberto."
                                }
                              ],
                              "practicalExample": "Para um motor DC com incerteza paramétrica de 20% no ganho, defina P(s)=1/(s(0.1s+1)), adicione Δ multiplicativa em P, W_e=1/(S(s)+1) para rastreamento, W_u=0.1 para limite u<10V. Construa GPD e normalize Δ para ||Δ||∞=0.2.",
                              "finalVerifications": [
                                "Diagrama GPD tem todas entradas/saídas corretas e conexões fechadas.",
                                "Pesos W_e e W_u estão conectados adequadamente em z e u.",
                                "Incertezas normalizadas: ||Δ||∞ ≤1 confirmado via simulação.",
                                "MATLAB genplant() gera sistema sem erros dimensionais.",
                                "Loop aberto estável com normas finitas.",
                                "Documentação inclui equações M11, M12, etc."
                              ],
                              "assessmentCriteria": [
                                "Precisão na modelagem de incertezas e normalização (peso 25%).",
                                "Seleção adequada de pesos com justificativa em frequência (peso 25%).",
                                "Correção da estrutura GPD e interconexões (peso 20%).",
                                "Validações via simulação e normas (peso 15%).",
                                "Clareza na documentação e diagramas (peso 10%).",
                                "Eficiência temporal e avoidance de erros comuns (peso 5%)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Álgebra linear para estados-espaciais e normas ∞.",
                                "Programação: Implementação em MATLAB/Simulink para automação.",
                                "Física: Modelagem dinâmica de sistemas reais (ex: motores, processos).",
                                "Análise de Sistemas: Teoria de controle clássico para pesos iniciais.",
                                "Otimização: Preparação para síntese H∞/μ como problema LMIs."
                              ],
                              "realWorldApplication": "Em controle de voo de aeronaves, constrói-se a GPD para sintetizar controladores robustos contra variações aerodinâmicas (Δ), com W_e para estabilidade/manobrabilidade e W_u para limites atuadores, usado em F-16 fighters e drones autônomos."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.5.1.1.2"
                            ]
                          },
                          {
                            "id": "10.1.5.1.2.3",
                            "name": "Avaliar robustez via normas H∞",
                            "description": "Calcular e interpretar a norma H∞ da função de transferência fechada para quantificar níveis de robustez e desempenho na configuração formatada.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Configuração da Malha Fechada e Forma Padrão para Robustez",
                                  "subSteps": [
                                    "Identificar os blocos principais da malha: planta nominal P, incertezas Δ, controlador K e entradas/saídas de interesse (w para perturbações, z para erros).",
                                    "Desenhar o diagrama de blocos da configuração generalizada (forma padrão) onde M = [Tzw; Tzu] representa a função de transferência de w para z.",
                                    "Verificar que a função de transferência fechada Tzw é a relevante para análise de robustez H∞.",
                                    "Definir os sinais de performance z (ex: erro de rastreamento) e perturbações w (ex: ruído, distúrbios).",
                                    "Confirmar unidades e escalas consistentes nos sinais para interpretação física."
                                  ],
                                  "verification": "Diagrama de blocos desenhado corretamente com legendas e funções de transferência anotadas; equação de Tzw derivada manualmente.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Folha de papel ou software de diagramação (Draw.io)",
                                    "Referência: Livro de Skogestad 'Multivariable Feedback Control' Capítulo 9",
                                    "MATLAB para simulação inicial"
                                  ],
                                  "tips": "Sempre rotule entradas e saídas com setas direcionais claras para evitar confusão em loops.",
                                  "learningObjective": "Compreender a estrutura da malha fechada em forma padrão para análise de robustez.",
                                  "commonMistakes": [
                                    "Confundir Tzw com Tzw (planta aberta)",
                                    "Ignorar normalização de sinais, levando a normas sem significado físico"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Modelar a Função de Transferência Fechada Tzw",
                                  "subSteps": [
                                    "Obter as funções de transferência da planta P(s) e controlador K(s) em forma mínima realizada.",
                                    "Derivar analiticamente ou computacionalmente Tzw(s) = P11 + P12 K (I - P22 K)^(-1) P21 usando fórmula de malha fechada.",
                                    "Implementar o modelo em MATLAB usando tf() ou ss() para sistemas contínuos.",
                                    "Validar o modelo com step response ou bode plot comparando com simulações nominais.",
                                    "Incorporar pesos de performance Wp e robustez Wu para formar o sistema generalizado."
                                  ],
                                  "verification": "Script MATLAB gera Bode plot de Tzw com margens de ganho/fase acima de especificações mínimas.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "MATLAB com Control System Toolbox",
                                    "Funções de transferência exemplo do contexto PS-76"
                                  ],
                                  "tips": "Use feedback() e connect() no MATLAB para automação da conexão de blocos.",
                                  "learningObjective": "Construir e validar o modelo matemático da função de transferência fechada para robustez.",
                                  "commonMistakes": [
                                    "Erro na inversão de loop: usar (I + GK)^(-1) em vez de (I - P22 K)^(-1)",
                                    "Não cancelar polos/zeros instáveis"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular a Norma H∞ de Tzw",
                                  "subSteps": [
                                    "Executar norm(sys, inf) no MATLAB para obter ||Tzw||_∞ e frequência de pico.",
                                    "Verificar manualmente via plot de singular values: σ_max(ω) ao longo do espectro.",
                                    "Analisar picos de ressonância e garantir que ||Tzw||_∞ < 1/||Δ|| para robustez.",
                                    "Comparar com norma H2 para contexto de desempenho RMS.",
                                    "Exportar resultados em tabela: valor da norma, ω_peak, margem de robustez."
                                  ],
                                  "verification": "Valor de ||Tzw||_∞ calculado e plot de sigma exibem máximo < γ desejado (ex: 1.2).",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "MATLAB script com sigma() e norm()",
                                    "Documentação MATLAB: hinfnorm"
                                  ],
                                  "tips": "Balance o sistema com balreal() antes para precisão numérica.",
                                  "learningObjective": "Computar quantitativamente a norma H∞ usando ferramentas padrão.",
                                  "commonMistakes": [
                                    "Usar norm() sem especificar 'inf'",
                                    "Interpretar sigma plot sem log scale"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Interpretar Resultados e Quantificar Robustez e Desempenho",
                                  "subSteps": [
                                    "Avaliar se ||Tzw||_∞ <1 garante estabilidade robusta para ||Δ||_∞ <1.",
                                    "Calcular margens: robustez = 1/||Tzw||_∞; desempenho via pesos.",
                                    "Simular cenários com incertezas para validar (loop shifting ou μ-tools).",
                                    "Documentar trade-offs: reduzir ||Tzw||_∞ pode degradar resposta transitória.",
                                    "Recomendar iterações no sintetizador H∞ se norma > limite."
                                  ],
                                  "verification": "Relatório escrito com interpretação: 'Norma 0.85 implica 17% margem de incerteza'; simulações confirmam.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Relatório template em LaTeX/Word",
                                    "Simulink para Monte Carlo com incertezas"
                                  ],
                                  "tips": "Sempre relacione norma de volta às especificações físicas (ex: erro <5%).",
                                  "learningObjective": "Interpretar a norma H∞ em termos de robustez e desempenho práticos.",
                                  "commonMistakes": [
                                    "Confundir robustez com estabilidade nominal",
                                    "Ignorar frequência de pico para tuning"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um controlador H∞ para um motor DC com incerteza de 20% no ganho (planta P(s)=1/(s+1)), sintetize K(s), compute ||Tzw||_∞=0.92 no MATLAB, confirmando robustez para Δ até 8.7% além da nominal, com erro de rastreamento <10% em simulação com ruído.",
                              "finalVerifications": [
                                "||Tzw||_∞ calculado corretamente e < γ especificado.",
                                "Plot de valores singulares mostra pico claro e frequência associada.",
                                "Simulação com incerteza máxima mantém estabilidade (polos Re<0).",
                                "Margem de robustez quantificada: 1/||Tzw||_∞ >1.1.",
                                "Relatório interpreta norma em contexto de desempenho físico.",
                                "Comparação com caso nominal destaca ganho de robustez."
                              ],
                              "assessmentCriteria": [
                                "Precisão no cálculo da norma H∞ (erro <1%).",
                                "Correta identificação e modelagem de Tzw na forma padrão.",
                                "Interpretação qualitativa/quantitativa da robustez.",
                                "Uso adequado de ferramentas MATLAB sem erros numéricos.",
                                "Documentação clara com plots e conclusões acionáveis.",
                                "Identificação de trade-offs entre robustez e desempenho."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Análise de operadores em espaços de Hardy (H∞).",
                                "Programação: Implementação numérica em MATLAB/Python (control library).",
                                "Física: Dinâmica de sistemas com perturbações estocásticas.",
                                "Estatística: Análise de pior-caso vs. RMS (H∞ vs. H2)."
                              ],
                              "realWorldApplication": "Em aviação, avalia robustez de autothrottle contra variações de arrasto/vento, garantindo estabilidade em turbulência; norma H∞ <1 assegura que perturbações não amplificam erros de velocidade além de 5%."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.5.1.2.1"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "10.1.5.1.3",
                        "name": "Procedimentos Práticos de Formatação",
                        "description": "Passos algorítmicos e iterativos para formatar a malha utilizando ferramentas computacionais como MATLAB, visando preparar para síntese H∞ e μ-síntese.",
                        "specificSkills": [
                          {
                            "id": "10.1.5.1.3.1",
                            "name": "Selecionar e projetar pesos de formatação",
                            "description": "Escolher pesos W_s, W_p e W_r baseados em especificações de desempenho (rastreamento, rejeição de distúrbios) e robustez, ajustando curvas de valores singulares desejadas.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Analisar Especificações de Desempenho e Robustez",
                                  "subSteps": [
                                    "Identifique requisitos de rastreamento (ex.: erro de regime zero para entradas de referência passo e rampa).",
                                    "Defina bandas de frequência para rejeição de distúrbios (ex.: atenuação >40dB em baixas frequências).",
                                    "Especifique margens de robustez (ex.: incerteza multiplicativa |Δ| < 1/|W_r|).",
                                    "Desenhe curvas desejadas de valores singulares para sensibilidade S e complementar T.",
                                    "Documente trade-offs entre desempenho e robustez."
                                  ],
                                  "verification": "Verifique se todas especificações estão mapeadas em curvas de magnitude desejadas no plano de Bode.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Diagrama de Bode do planta nominal, especificações do problema, software MATLAB/Simulink.",
                                  "tips": "Comece com especificações qualitativas e refine para quantitativas usando magnitudes em dB.",
                                  "learningObjective": "Mapear requisitos de controle para curvas de valores singulares desejadas.",
                                  "commonMistakes": "Ignorar trade-offs de frequência, como alto ganho em altas frequências levando a instabilidade."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Projetar Peso de Sensibilidade W_s",
                                  "subSteps": [
                                    "Escolha ordem inicial do peso (ex.: W_s = (s/M_s + ω_b)/(s + ω_b A_s) para limite em baixa frequência).",
                                    "Ajuste parâmetros: M_s (pico de sensibilidade ~1.3-2), ω_b (banda de crossover desejada).",
                                    "Garanta σ_bar(W_s) >>1 em baixas frequências para bom rastreamento/rejeição.",
                                    "Plote σ_bar(W_s S) e itere até <1 para todas frequências.",
                                    "Valide com simulações de passo/rampa."
                                  ],
                                  "verification": "Confirme que σ_bar(W_s S(jω)) <1 ∀ω e atende specs de erro em regime.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Função sigma() no MATLAB, modelo da planta G(s), toolbox Robust Control.",
                                  "tips": "Use formas padrão de pesos para acelerar; evite sobreajuste inicial.",
                                  "learningObjective": "Construir W_s que force S a seguir 1/W_s.",
                                  "commonMistakes": "Escolher ω_b muito alto, violando limitações da planta."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Projetar Pesos de Performance W_p e Robustez W_r",
                                  "subSteps": [
                                    "Para W_p: Modele como peso em KS (controle + sensibilidade) para atenuar erros de modelagem.",
                                    "Defina W_p com alto ganho em banda de interesse (ex.: ordem 1 com polo em ω_p).",
                                    "Para W_r: Escolha baseado em modelo de incerteza (ex.: W_r = |Δ_hat| / (1-|Δ_hat|) em altas frequências).",
                                    "Ajuste para σ_bar(W_p KS) <1 e σ_bar(W_r T) <1.",
                                    "Integre todos pesos na função generalizada P."
                                  ],
                                  "verification": "Gere loops σ_bar(W_i * canal) <1 para i=p,r.",
                                  "estimatedTime": "75 minutos",
                                  "materials": "Modelos de incerteza Δ, funções augw() e sel() no MATLAB.",
                                  "tips": "Comece com W_p baixo e aumente gradualmente; normalize W_r para |W_r(∞)|=1.",
                                  "learningObjective": "Balancear performance e robustez via pesos em canais complementares.",
                                  "commonMistakes": "Subestimar incertezas, levando a controladores frágeis."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Validar e Ajustar Pesos Integrados",
                                  "subSteps": [
                                    "Sintetize controlador K via hinfsyn() ou musyn().",
                                    "Analise curvas de singular values para todos canais.",
                                    "Simule respostas temporais com distúrbios e incertezas.",
                                    "Ajuste pesos iterativamente se specs não atendidas.",
                                    "Documente justificativas finais."
                                  ],
                                  "verification": "Todas curvas σ_bar <1 e simulações atendem specs originais.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Scripts MATLAB para síntese H∞/μ, Simulink para simulações.",
                                  "tips": "Use gridsearch para otimizar parâmetros dos pesos.",
                                  "learningObjective": "Iterar pesos para fechamento bem-sucedido do loop H∞.",
                                  "commonMistakes": "Não validar com incertezas reais, causando falha em robustez."
                                }
                              ],
                              "practicalExample": "Para um servo-motor de posição com planta G(s)=1/(s(s+1)), especifique ω_b=10 rad/s, rejeição >30dB abaixo 1 rad/s, robustez para Δ=0.2|s|/10. Projetar W_s=(s/10+10)/(s+10*0.1), W_p=0.01, W_r=0.2 s/10, resultando em K estabilizador com γ<1.2.",
                              "finalVerifications": [
                                "σ_bar(W_s S(jω)) <1 para todas ω.",
                                "σ_bar(W_p KS(jω)) <1 e atenua erros em banda.",
                                "σ_bar(W_r T(jω)) <1 garantindo robustez.",
                                "Simulações de rastreamento com erro <5% em regime.",
                                "Margens de ganho/fase >6dB/45°.",
                                "γ_H∞ <1.5 após síntese."
                              ],
                              "assessmentCriteria": [
                                "Precisão na modelagem de specs como curvas desejadas.",
                                "Escolha adequada de formas e parâmetros dos pesos.",
                                "Balanceamento efetivo de trade-offs desempenho-robustez.",
                                "Validação quantitativa via sigma plots e simulações.",
                                "Documentação clara de iterações e justificativas.",
                                "Eficiência temporal no processo de design."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Valores singulares e decomposição SVD.",
                                "Programação: Scripts MATLAB para análise de robustez.",
                                "Física: Dinâmica de sistemas lineares e incertezas.",
                                "Estatística: Análise de Monte Carlo para validação robusta."
                              ],
                              "realWorldApplication": "Projeto de controladores para drones, onde W_s garante rastreamento preciso de trajetória apesar de ventos (distúrbios), W_p minimiza vibrações e W_r lida com variações de massa de carga."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.5.1.2.2"
                            ]
                          },
                          {
                            "id": "10.1.5.1.3.2",
                            "name": "Implementar formatação em MATLAB",
                            "description": "Utilizar funções do Robust Control Toolbox (como loopshaping, augw) para modelar a planta ponderada e validar a formatação via gráficos de Bode e singular values.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Modelar a planta e definir pesos de ponderação",
                                  "subSteps": [
                                    "Identificar o modelo da planta G(s) a partir de dados ou equações diferenciais.",
                                    "Definir pesos de performance Wp(s) para rastreamento e distúrbios, e pesos de robustez Wr(s) para incertezas.",
                                    "Criar os modelos em MATLAB usando tf() ou ss() para funções de transferência ou espaço de estados.",
                                    "Verificar estabilidade e propriedades iniciais da planta com pole() e zero().",
                                    "Ajustar ordens dos pesos para manter simplicidade computacional."
                                  ],
                                  "verification": "Executar nyquist(G) ou bode(G) para visualizar resposta em frequência da planta e pesos.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "MATLAB com Robust Control Toolbox",
                                    "Documentação da planta (equações ou dados)"
                                  ],
                                  "tips": "Escolha pesos com roll-off adequado: alto ganho em baixas frequências para performance.",
                                  "learningObjective": "Compreender como pesos moldam especificações de controle H∞.",
                                  "commonMistakes": [
                                    "Ignorar unidades de ganho nos pesos",
                                    "Usar pesos de ordem muito alta causando ill-conditioning",
                                    "Não normalizar a planta para ganho unitário"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Construir o sistema aumentado usando augw",
                                  "subSteps": [
                                    "Definir entradas e saídas do sistema generalizado: referências, erros, controles e medidas.",
                                    "Chamar a função augw(P, Wp, Wr, 'type') onde P é a planta nominal.",
                                    "Verificar dimensões do sistema aumentado com size(augP).",
                                    "Analisar singular values iniciais com sigma(augP).",
                                    "Salvar o sistema aumentado em variável para síntese."
                                  ],
                                  "verification": "sigma(augP) mostra valores singulares com limite superior <1 para estabilidade.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "MATLAB com Robust Control Toolbox",
                                    "Modelos da planta e pesos do Step 1"
                                  ],
                                  "tips": "Use 'true' para incluir ruído de sensor se aplicável; teste com augw_demo para familiarizar.",
                                  "learningObjective": "Dominar a função augw para preparar plantas ponderadas em H∞.",
                                  "commonMistakes": [
                                    "Erro na ordem dos pesos (Wp antes de Wr)",
                                    "Confundir entradas de performance com robustez",
                                    "Não especificar tipo de configuração ('P')"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Sintetizar o controlador H∞ com loopshaping",
                                  "subSteps": [
                                    "Aplicar loopshaping à planta ponderada usando lsgamma ou diretamente hinfsyn(augP).",
                                    "Especificar gamma desejado ou iterar para encontrar o menor gamma estável.",
                                    "Extrair o controlador K do resultado [K,CL,GAM] = hinfsyn(augP,nmeas,ncont).",
                                    "Fechar a malha com feedback e verificar estabilidade com isstable(lft(augP,K)).",
                                    "Analisar condições com gamma_plot se disponível."
                                  ],
                                  "verification": "GAM < 1 confirma síntese bem-sucedida e robustez.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "MATLAB com Robust Control Toolbox",
                                    "Sistema aumentado do Step 2"
                                  ],
                                  "tips": "Comece com gamma=1 e reduza iterativamente; use sel_loop para shaping manual.",
                                  "learningObjective": "Implementar síntese H∞ via loopshaping para controle robusto.",
                                  "commonMistakes": [
                                    "Número errado de medidas/controles em hinfsyn",
                                    "Não reduzir ordem do controlador com balred",
                                    "Ignorar warnings de condição numérica"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Validar a formatação com gráficos de Bode e singular values",
                                  "subSteps": [
                                    "Plotar Bode do loop aberto L = G*K e margens com margin(L).",
                                    "Gerar sigma(L) e sigma_inv(Wp*L) para verificar especificações H∞.",
                                    "Analisar resposta em malha fechada T = feedback(G*K,1) com step() ou bode(T).",
                                    "Verificar robustez com sigma(lft(Gamma, Delta)) para Delta unitário.",
                                    "Documentar resultados em figure com legend e grid."
                                  ],
                                  "verification": "Bode mostra crossover adequado; sigma <1 em todas as frequências relevantes.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "MATLAB com Control System Toolbox",
                                    "Controlador K e planta do Step 3"
                                  ],
                                  "tips": "Use logspace para frequências e semilogx para clareza; compare com specs originais.",
                                  "learningObjective": "Interpretar gráficos para validar desempenho e robustez H∞.",
                                  "commonMistakes": [
                                    "Plotar Bode da planta ao invés do loop",
                                    "Escalas erradas em sigma hiding violações",
                                    "Esquecer de plotar sigma(1/Wr * S) para robustez"
                                  ]
                                }
                              ],
                              "practicalExample": "Para uma planta de motor DC G(s) = 1000/(s(s+100)), defina Wp=0.1*(1/s+10)/ (1+s/100), Wr=(s/10+1)/(s/1000+1). Use augw para sistema aumentado, sintetize K com hinfsyn e valide Bode com |L(jω)| cruzando 0dB em ωc=10 rad/s e sigma(L)<1.",
                              "finalVerifications": [
                                "Sistema aumentado augP tem dimensões corretas e sigma(augP)<1.",
                                "Controlador K estabiliza a malha fechada com gamma<1.",
                                "Gráficos de Bode mostram margens de ganho/fase >6dB/45°.",
                                "Singular values confirmam |T|<|Wp| e |S|<|Wr| em todo o espectro.",
                                "Resposta ao degrau em malha fechada tem overshoot <20% e tempo de assentamento <1s.",
                                "Robustez testada com variação ±20% em parâmetros da planta."
                              ],
                              "assessmentCriteria": [
                                "Correta definição e implementação de pesos Wp e Wr alinhados às specs.",
                                "Uso preciso de augw sem erros dimensionais.",
                                "Síntese H∞ converge com gamma otimizado.",
                                "Gráficos de validação claros, com interpretações corretas.",
                                "Análise de robustez quantitativa via singular values.",
                                "Código MATLAB limpo, comentado e reproduzível."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Análise em frequência e valores singulares (álgebra linear).",
                                "Programação: Scripting avançado em MATLAB e manipulação de objetos LTI.",
                                "Física: Modelagem dinâmica de sistemas mecatrônicos.",
                                "Estatística: Análise de incertezas e simulações Monte Carlo para robustez.",
                                "Design de Engenharia: Trade-offs entre performance e robustez."
                              ],
                              "realWorldApplication": "Em controle de flight actuators em aviões (Boeing usa H∞ para flaps), robótica industrial (ABB robots com loopshaping para precisão apesar de cargas variáveis) e processos químicos (controle de reatores com incertezas paramétricas), garantindo estabilidade e performance sob variações reais."
                            },
                            "estimatedTime": "2.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.5.1.1.3",
                              "10.1.5.1.2.2"
                            ]
                          },
                          {
                            "id": "10.1.5.1.3.3",
                            "name": "Iterar e otimizar a formatação de malha",
                            "description": "Realizar iterações manuais ou algorítmicas para minimizar γ (nível H∞) e satisfazer critérios de robustez, verificando estabilidade e desempenho.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Avaliar configuração inicial e definir critérios de otimização",
                                  "subSteps": [
                                    "Analisar a formatação de malha inicial, identificando o valor atual de γ (nível H∞).",
                                    "Definir critérios de robustez: limites para γ, margens de estabilidade e desempenho desejado.",
                                    "Modelar incertezas e perturbações relevantes para o sistema.",
                                    "Estabelecer métricas de desempenho como overshoot, tempo de assentamento e robustez a variações.",
                                    "Documentar baseline para comparação futura."
                                  ],
                                  "verification": "Verificar se baseline de γ e critérios estão documentados e consistentes com especificações do problema.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Software MATLAB/Simulink com toolbox Robust Control",
                                    "Modelo do sistema em formato .slx ou .m",
                                    "Documentação de referência H∞"
                                  ],
                                  "tips": "Use gráficos de Bode iniciais para visualizar problemas de robustez.",
                                  "learningObjective": "Compreender e quantificar o estado inicial da formatação para guiar iterações.",
                                  "commonMistakes": "Ignorar incertezas reais do sistema, levando a otimizações irrelevantes."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Realizar iterações manuais de ajuste",
                                  "subSteps": [
                                    "Ajustar pesos de desempenho e robustez manualmente no modelo H∞.",
                                    "Simular respostas em malha fechada para diferentes cenários de perturbação.",
                                    "Analisar singular values e γ após cada ajuste.",
                                    "Refinar pesos iterativamente até redução inicial de γ.",
                                    "Registrar variações de γ e desempenho em tabela comparativa."
                                  ],
                                  "verification": "γ reduzido em pelo menos 10-20% em relação ao baseline, com simulações estáveis.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "MATLAB Robust Control Toolbox",
                                    "Scripts de simulação personalizados",
                                    "Planilha para tracking de iterações"
                                  ],
                                  "tips": "Comece ajustando pesos de robustez conservadoramente para evitar instabilidade.",
                                  "learningObjective": "Dominar ajustes manuais intuitivos para ganhos rápidos em otimização H∞.",
                                  "commonMistakes": "Ajustes excessivos em um peso só, causando trade-offs ruins em desempenho."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar otimização algorítmica",
                                  "subSteps": [
                                    "Configurar algoritmo de otimização como hinfsyn ou musyn para minimizar γ.",
                                    "Definir bounds e constraints para variáveis de projeto.",
                                    "Executar iterações algorítmicas com tolerâncias apropriadas.",
                                    "Monitorar convergência e ajustar parâmetros do solver se necessário.",
                                    "Comparar resultados algorítmicos com iterações manuais."
                                  ],
                                  "verification": "Algoritmo converge com γ mínimo satisfazendo critérios, sem warnings de falha.",
                                  "estimatedTime": "2-3 horas",
                                  "materials": [
                                    "MATLAB com hinfsyn/musyn functions",
                                    "Computador com bom desempenho para simulações",
                                    "Documentação de solvers H∞"
                                  ],
                                  "tips": "Use opções de solver como 'Display' para monitorar progresso em tempo real.",
                                  "learningObjective": "Aplicar ferramentas algorítmicas para otimização eficiente e automatizada.",
                                  "commonMistakes": "Parâmetros iniciais ruins levando a não-convergência; sempre teste com baseline manual."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificar estabilidade, desempenho e refinar",
                                  "subSteps": [
                                    "Realizar análises de estabilidade: Nyquist, root locus e μ-analysis.",
                                    "Testar robustez com Monte Carlo simulations para variações paramétricas.",
                                    "Avaliar desempenho em malha fechada sob condições nominais e perturbadas.",
                                    "Refinar iterações se critérios não atendidos, combinando manual e algorítmico.",
                                    "Documentar configuração final otimizada."
                                  ],
                                  "verification": "Todos critérios de robustez e desempenho satisfeitos, com relatórios gráficos.",
                                  "estimatedTime": "1-2 horas",
                                  "materials": [
                                    "Ferramentas de análise: bode, nyquist, sigma no MATLAB",
                                    "Scripts de Monte Carlo",
                                    "Relatório template"
                                  ],
                                  "tips": "Sempre valide com simulações time-domain para capturar não-linearidades.",
                                  "learningObjective": "Garantir que otimizações sejam robustas e performáticas no contexto real.",
                                  "commonMistakes": "Focar só em γ sem checar estabilidade dinâmica."
                                }
                              ],
                              "practicalExample": "Em um sistema de controle de posição de um braço robótico, inicie com γ=3.2; itere manualmente pesos para γ=2.1, otimize com hinfsyn para γ=1.45, verifique estabilidade com μ<1 sob ±20% variação de massa, resultando em erro de rastreamento <5% em rampas.",
                              "finalVerifications": [
                                "γ otimizado abaixo do threshold especificado (ex: <2).",
                                "Margens de estabilidade (GM, PM) >6dB/45° em todos cenários.",
                                "Desempenho em simulações time-domain atende specs (overshoot<10%, settling<2s).",
                                "Análise μ confirma robustez a incertezas estruturadas.",
                                "Configuração final reproduzível e documentada.",
                                "Nenhuma violação em testes de sensibilidade."
                              ],
                              "assessmentCriteria": [
                                "Precisão na minimização de γ com evidência de iterações (redução >30%).",
                                "Correta aplicação de ferramentas algorítmicas com convergência demonstrada.",
                                "Análises completas de estabilidade e robustez com gráficos apropriados.",
                                "Trade-offs bem justificados entre desempenho e robustez.",
                                "Documentação clara de processo e resultados finais.",
                                "Capacidade de refinar baseado em verificações falhas."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Otimização convexa e análise de singular values.",
                                "Programação: Implementação de loops de otimização em MATLAB/Python.",
                                "Física: Modelagem dinâmica de sistemas com incertezas.",
                                "Estatística: Simulações Monte Carlo para análise probabilística."
                              ],
                              "realWorldApplication": "Otimização de controladores H∞ em aviões para estabilidade em turbulências, reduzindo fadiga estrutural e melhorando precisão de voo autônomo."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.5.1.3.1"
                            ]
                          },
                          {
                            "id": "10.1.5.1.3.4",
                            "name": "Analisar trade-offs na formatação",
                            "description": "Identificar e discutir compromissos entre desempenho ótimo, robustez e simplicidade do controlador resultante da síntese.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Definir critérios de avaliação para os trade-offs",
                                  "subSteps": [
                                    "Identificar métricas de desempenho ótimo: tempo de assentamento, overshoot, erro em regime permanente.",
                                    "Listar indicadores de robustez: margens de ganho e fase, sensibilidade a perturbações e incertezas.",
                                    "Especificar medidas de simplicidade: ordem do controlador, número de estados, complexidade computacional.",
                                    "Priorizar critérios com base no contexto da aplicação (ex.: robustez > desempenho em sistemas críticos).",
                                    "Documentar em tabela comparativa os pesos relativos de cada critério."
                                  ],
                                  "verification": "Tabela de critérios completa com pelo menos 3 métricas por categoria e pesos atribuídos.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Documentação do problema de controle",
                                    "Planilha Excel ou MATLAB para tabelas",
                                    "Referências teóricas de H∞/μ-síntese"
                                  ],
                                  "tips": "Use escalas normalizadas (0-1) para facilitar comparações posteriores.",
                                  "learningObjective": "Compreender e quantificar os componentes fundamentais dos trade-offs em síntese de controladores.",
                                  "commonMistakes": [
                                    "Ignorar simplicidade em favor apenas de desempenho",
                                    "Não contextualizar pesos dos critérios",
                                    "Listar métricas irrelevantes para o domínio"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar configurações alternativas de formatação de malha",
                                  "subSteps": [
                                    "Mapear opções de formatação: pesos de desempenho P, robustez R e generalizado G.",
                                    "Gerar 3-5 configurações variadas (ex.: alta ênfase em P baixa em R; equilibrada; alta simplicidade).",
                                    "Realizar síntese inicial de cada configuração usando software (MATLAB Robust Control Toolbox).",
                                    "Calcular métricas preliminares para cada configuração.",
                                    "Registrar impactos iniciais em gráfico de radar ou Pareto frontal."
                                  ],
                                  "verification": "Relatório com sínteses de pelo menos 3 configurações e métricas iniciais plotadas.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "MATLAB com Robust Control Toolbox",
                                    "Plantas modelo do sistema",
                                    "Templates de scripts para síntese H∞/μ"
                                  ],
                                  "tips": "Varie pesos de forma sistemática (ex.: grid search simples) para cobrir o espaço de trade-offs.",
                                  "learningObjective": "Explorar o espaço de soluções gerado por diferentes formatações de malha.",
                                  "commonMistakes": [
                                    "Gerar poucas configurações (menos de 3)",
                                    "Não sintetizar controladores válidos",
                                    "Ignorar viabilidade da síntese (ex.: sem solução ótima)"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar quantitativamente os trade-offs",
                                  "subSteps": [
                                    "Comparar métricas numéricas entre configurações usando tabelas e gráficos (bode, nyquist, step response).",
                                    "Construir fronteira de Pareto para visualizar compromissos (desempenho vs robustez vs simplicidade).",
                                    "Calcular índices compostos: score ponderado = w1*desempenho + w2*robustez + w3*simplicidade.",
                                    "Simular cenários de pior caso para robustez (uncertainties modeladas).",
                                    "Identificar configurações dominantes (não pareto-otimizadas)."
                                  ],
                                  "verification": "Gráficos de Pareto e tabela de scores para todas configurações, com análise numérica.",
                                  "estimatedTime": "2.5 horas",
                                  "materials": [
                                    "MATLAB para simulações e plots",
                                    "Ferramentas de otimização multiobjetivo (gamultiobj)",
                                    "Dados de simulação de incertezas"
                                  ],
                                  "tips": "Normalize todas as métricas para evitar escalas desbalanceadas nos scores.",
                                  "learningObjective": "Quantificar e visualizar trade-offs de forma objetiva e reprodutível.",
                                  "commonMistakes": [
                                    "Não normalizar métricas",
                                    "Usar gráficos inadequados (ex.: lineares para logs)",
                                    "Omitir simulações de robustez"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Discutir qualitativamente e propor recomendações",
                                  "subSteps": [
                                    "Avaliar impactos práticos: custo de implementação, tempo de computação em tempo real.",
                                    "Discutir trade-offs em termos de aplicação: ex. simplicidade para embedded systems.",
                                    "Propor configuração ótima com justificativa baseada em análise quantitativa/qualitativa.",
                                    "Sugerir iterações futuras para refinar formatação.",
                                    "Redigir relatório executivo resumindo análise."
                                  ],
                                  "verification": "Relatório final com recomendação clara, justificativas e lições aprendidas.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Modelos de relatório LaTeX/Word",
                                    "Gráficos gerados anteriormente"
                                  ],
                                  "tips": "Inclua sensibilidade: como pequenas mudanças afetam trade-offs.",
                                  "learningObjective": "Integrar análise quantitativa com julgamento qualitativo para decisões informadas.",
                                  "commonMistakes": [
                                    "Focar só em números sem contexto prático",
                                    "Não justificar escolha final",
                                    "Relatório prolixo sem resumo"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um sistema de controle de drone para estabilização de altitude com incertezas aerodinâmicas: Configuração 1 prioriza desempenho (resposta rápida, mas controlador ordem 12, frágil); Configuração 2 equilibra robustez (margens >60°, ordem 6); Configuração 3 simples (ordem 4, mas overshoot 20%). Trade-off: escolher eq.2 para missões reais.",
                              "finalVerifications": [
                                "Pode listar e justificar 3 métricas por categoria de trade-off.",
                                "Gera fronteira de Pareto correta para 3 configurações.",
                                "Explica impacto de aumentar peso de robustez na ordem do controlador.",
                                "Identifica configuração pareto-ótima em exemplo dado.",
                                "Discute limitação prática de alta simplicidade em sistemas incertos.",
                                "Calcula score ponderado corretamente com pesos dados."
                              ],
                              "assessmentCriteria": [
                                "Precisão e completude das métricas definidas (30%)",
                                "Qualidade das simulações e visualizações (25%)",
                                "Profundidade da análise quantitativa/qualitativa (20%)",
                                "Justificativa coerente da recomendação final (15%)",
                                "Clareza e organização do relatório (10%)"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Otimização multiobjetivo e análise de Pareto",
                                "Programação: Scripts MATLAB para síntese e simulação",
                                "Economia/Engenharia: Análise custo-benefício em design",
                                "Física: Modelagem de incertezas dinâmicas",
                                "Gestão de Projetos: Tomada de decisão sob trade-offs"
                              ],
                              "realWorldApplication": "No design de controladores para aviões comerciais (ex.: Boeing 787), onde trade-offs garantem performance em voo suave, robustez a turbulências e simplicidade para certificação FAA, reduzindo custos de manutenção e tempo de desenvolvimento."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.5.1.3.2"
                            ]
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.5.2",
                    "name": "Parametrização de Controladores Estabilizadores",
                    "description": "Representação paramétrica de todos os controladores estabilizantes usando parametrização de Youla-Kucera.",
                    "individualConcepts": [
                      {
                        "id": "10.1.5.2.1",
                        "name": "Fatorizações Coprimas de Bezout",
                        "description": "Fatorizações coprimas esquerda e direita da função de transferência da planta nominal, e a identidade de Bezout que garante a existência de controladores estabilizantes para sistemas lineares invariantes no tempo (LIT) monovariáveis.",
                        "specificSkills": [
                          {
                            "id": "10.1.5.2.1.1",
                            "name": "Definir fatorizações coprimas dupla",
                            "description": "Explicar e calcular fatorizações coprimas esquerda [N, D] e direita [Ñ, D̃] de uma planta P(s), garantindo que existam matrizes X, Y tais que a identidade de Bezout [X, -Ñ; D, N] = I seja satisfeita em um anel de estabilidade (RH∞).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Conceitos Fundamentais de Anéis e Fatorizações Coprimas",
                                  "subSteps": [
                                    "Estude o anel RH∞: conjunto de funções de transferência analíticas e limitadas no semiplano direito.",
                                    "Aprenda definições de bezoutian: pares [N,D] tais que existam X,Y com XN + YD = I.",
                                    "Diferencie coprimalidade esquerda (row coprime) e direita (column coprime).",
                                    "Revise normalização: det(D(jω)) = 1 para todos ω.",
                                    "Entenda unimodulares: matrizes invertíveis em RH∞."
                                  ],
                                  "verification": "Resuma em um parágrafo as diferenças entre coprimalidade esquerda e direita, citando exemplos simples.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Livro 'Feedback Control Theory' de Doyle",
                                    "Notas de aula sobre RH∞",
                                    "MATLAB para plotar funções de transferência"
                                  ],
                                  "tips": "Use diagramas de Venn para visualizar coprimalidade esquerda vs. direita.",
                                  "learningObjective": "Compreender os blocos algébricos necessários para fatorizações coprimas em RH∞.",
                                  "commonMistakes": [
                                    "Confundir RH∞ com H2",
                                    "Ignorar normalização de D",
                                    "Esquecer que bezoutians são sobre identidades matriciais"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Construir Fatorização Coprima Esquerda [N, D] para Planta P(s)",
                                  "subSteps": [
                                    "Escolha uma coprimação mínima de P(s) = N(s)D(s)^{-1} com N, D ∈ RH∞.",
                                    "Realize uma decomposição de Youla-Kucera ou use estado-espaco para obter realizações estáveis.",
                                    "Normalize D para que ||D||∞ = 1 ou det(D(jω))=1.",
                                    "Verifique coprimalidade: resolva para X,Y tais que [X, Y] [N; D] = I.",
                                    "Teste estabilidade: poles de N e D no semiplano esquerdo."
                                  ],
                                  "verification": "Implemente em MATLAB e plote singular values de [N,D] para confirmar coprimalidade.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "MATLAB Control System Toolbox",
                                    "Artigo 'Coprime Factorization' de Vidyasagar",
                                    "Exemplos de plantas como P(s)=1/(s+1)"
                                  ],
                                  "tips": "Comece com plantas SISO simples para intuição antes de MIMO.",
                                  "learningObjective": "Dominar a construção de fatorizações coprimas esquerdas normalizadas.",
                                  "commonMistakes": [
                                    "Não minimizar McMillan degree",
                                    "Usar fatorizações não estáveis",
                                    "Esquecer normalização"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Construir Fatorização Coprima Direita [Ñ, D̃] para a Mesma Planta",
                                  "subSteps": [
                                    "Defina P(s) = D̃(s)^{-1} Ñ(s) com D̃, Ñ ∈ RH∞.",
                                    "Use dual da fatorização esquerda ou algoritmos de estado-espaco duais.",
                                    "Normalize D̃ similarmente.",
                                    "Confirme coprimalidade direita: [Ñ, D̃] [X; Y] = I.",
                                    "Compare com a esquerda para consistência."
                                  ],
                                  "verification": "Calcule e verifique graficamente as normas H∞ de Ñ e D̃.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "MATLAB com sys = tf([1],[1 1]) para P(s)",
                                    "Referência Nett-Anderson para duais"
                                  ],
                                  "tips": "Aproveite simetrias: muitas vezes D̃ = D* ou similar para reais.",
                                  "learningObjective": "Construir e validar fatorizações coprimas duplas.",
                                  "commonMistakes": [
                                    "Confundir ordem esquerda/direita",
                                    "Não garantir dupla coprimalidade",
                                    "Ignorar conjugados para reais"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificar Identidade de Bezout Dupla",
                                  "subSteps": [
                                    "Forme a matriz Bezout: B = [X, -Ñ; D, N].",
                                    "Resolva o sistema para X,Y usando equações de Diophantus em RH∞.",
                                    "Confirme det(B) = 1 ou B unimodular.",
                                    "Teste numericamente: multiplique e verifique ||B - I|| < ε.",
                                    "Analise estabilidade: todos elementos em RH∞."
                                  ],
                                  "verification": "Execute simulação em MATLAB mostrando B * I = I com erro residual.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "MATLAB Symbolic Toolbox para bezoutians",
                                    "Paper 'Youla Parameterization Revisited'"
                                  ],
                                  "tips": "Use LFTs (linear fractional transformations) para automatizar.",
                                  "learningObjective": "Validar a dupla fatorização via identidade de Bezout.",
                                  "commonMistakes": [
                                    "Erros de sinal em -Ñ",
                                    "Não checar unimodularidade",
                                    "Soluções não-estáveis para X,Y"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Aplicar e Testar em Contexto de Estabilidade RH∞",
                                  "subSteps": [
                                    "Integre em parametrização de controladores: Q ∈ RH∞ estabiliza via (I - QÑ)D^{-1}.",
                                    "Simule estabilidade fechada para Q=0 (controlador zero).",
                                    "Teste robustez com perturbações em P.",
                                    "Documente o processo completo para uma planta exemplo.",
                                    "Discuta extensões para μ-síntese."
                                  ],
                                  "verification": "Gere diagrama de Bode mostrando estabilidade para o loop.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Simulink para simulações",
                                    "Exemplo P(s) = 1/(s^2 + s + 1)"
                                  ],
                                  "tips": "Sempre plote step responses para intuição física.",
                                  "learningObjective": "Aplicar fatorizações em design de controladores estabilizadores.",
                                  "commonMistakes": [
                                    "Esquecer Q pertence RH∞",
                                    "Não testar com delays ou incertezas",
                                    "Overfitting de normalização"
                                  ]
                                }
                              ],
                              "practicalExample": "Para P(s) = 1/(s+1), fatorize esquerda: N(s)=0.5/(s/2+1), D(s)=(s/2+0.5)/(s/2+1) normalizado. Direita similar dual. Resolva Bezout: encontre X,Y tal que [X,-Ñ;D,N]=I, verificando em MATLAB com norm(B-I)<1e-10.",
                              "finalVerifications": [
                                "Construir [N,D] e [Ñ,D̃] para P(s) dado e confirmar coprimalidade.",
                                "Exibir matriz Bezout unimodular explicitamente.",
                                "Simular controlador Q=0 e mostrar estabilidade.",
                                "Calcular normas H∞ de todos fatores <1.",
                                "Explicar verbalmente o papel em H∞ loop-shaping.",
                                "Adaptar para planta MIMO 2x2 simples."
                              ],
                              "assessmentCriteria": [
                                "Precisão na construção de fatorizações (90% match com soluções padrão).",
                                "Correta verificação de Bezout (erro <1e-8).",
                                "Uso apropriado de RH∞ (sem poles instáveis).",
                                "Documentação clara com plots e equações.",
                                "Criatividade em exemplo próprio (além do dado).",
                                "Tempo de conclusão dentro do estimado (±20%)."
                              ],
                              "crossCurricularConnections": [
                                "Álgebra Comutativa: Ideais e bezoutians em anéis PID.",
                                "Análise Complexa: Funções holomórficas no semiplano direito.",
                                "Programação Numérica: Implementação em Python (control library) ou MATLAB.",
                                "Otimização: Minimização de γ em H∞ via riccati.",
                                "Física: Modelagem de sistemas dinâmicos lineares."
                              ],
                              "realWorldApplication": "Em controle de aviões (ex: F-16 via H∞), fatorizações coprimas duplas permitem design de controladores robustos a incertezas, garantindo estabilidade apesar de variações em aerodinâmica, usados em autopilotos da NASA e indústrias aeroespaciais."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.2.1.2",
                            "name": "Verificar coprimidade",
                            "description": "Aplicar o teorema de coprimidade de Vinnicombe ou métodos de divisão polinomial para verificar se pares de funções de transferência são coprimos em RH∞, incluindo exemplos numéricos com MATLAB.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender Conceitos Fundamentais de Coprimidade em RH∞",
                                  "subSteps": [
                                    "Revise o espaço RH∞ e funções de transferência estáveis racionais.",
                                    "Defina coprimidade para pares (N, D) em RH∞: não existem Q1, Q2 em RH∞, não nulos, tal que Q1 N + Q2 D = 0.",
                                    "Estude identidades de Bezout para fatorizações coprimas.",
                                    "Analise exemplos simples de pares coprimos e não coprimos.",
                                    "Explore propriedades de coprimidade em sistemas de controle."
                                  ],
                                  "verification": "Resuma em um parágrafo as definições e forneça um exemplo de par não coprimo.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Livro de Doyle ou Zhou sobre controle robusto; notas de aula sobre RH∞.",
                                  "tips": "Use diagramas de grafos para visualizar dependências entre polos e zeros.",
                                  "learningObjective": "Compreender a definição e importância da coprimidade em RH∞.",
                                  "commonMistakes": "Confundir coprimidade em RH∞ com coprimidade polinomial finita."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Aplicar o Teorema de Coprimidade de Vinnicombe",
                                  "subSteps": [
                                    "Estude a declaração do teorema: γ_v(N, D) < 1 implica coprimidade.",
                                    "Calcule o ganho de Vinnicombe γ_v para pares dados.",
                                    "Implemente a fórmula γ_v = sup_ω || [N(jω) - D(jω) M(jω)] || / (1 + ||M(jω)||^2)^{1/2} para M estável.",
                                    "Verifique com exemplos analíticos se γ_v < 1 confirma coprimidade.",
                                    "Discuta limitações e condições do teorema."
                                  ],
                                  "verification": "Compute γ_v para um par dado e conclua corretamente sobre coprimidade.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Artigo de Vinnicombe; MATLAB para plots de frequência.",
                                  "tips": "Comece com funções de baixa ordem para validar intuitivamente.",
                                  "learningObjective": "Dominar o uso do teorema de Vinnicombe para verificação prática.",
                                  "commonMistakes": "Ignorar a normalização ||M||_∞ = 1 ou erros em singular values."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar Métodos de Divisão Polinomial para Verificação",
                                  "subSteps": [
                                    "Realize divisão polinomial em domínio de Laplace para N(s)/D(s).",
                                    "Verifique se o resto da divisão é zero para coprimidade.",
                                    "Estenda para RH∞ usando fatorizações biproprias.",
                                    "Teste com pares numéricos, computando resíduos.",
                                    "Compare resultados com o teorema de Vinnicombe."
                                  ],
                                  "verification": "Execute divisão para um exemplo e mostre resto zero ou não.",
                                  "estimatedTime": "50 minutos",
                                  "materials": "MATLAB Symbolic Toolbox; exemplos de funções de transferência.",
                                  "tips": "Use tf2zp para zeros e polos iniciais como verificação rápida.",
                                  "learningObjective": "Aplicar divisão polinomial estendida a RH∞.",
                                  "commonMistakes": "Esquecer multiplicadores biproprios em RH∞."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Implementar e Verificar em MATLAB com Exemplos Numéricos",
                                  "subSteps": [
                                    "Defina pares de funções de transferência em MATLAB usando tf().",
                                    "Implemente função para γ_v usando sigma e freqresp.",
                                    "Crie script para divisão polinomial com residuez ou conv.",
                                    "Teste múltiplos exemplos: coprimos e não coprimos.",
                                    "Gere plots e relatórios de verificação."
                                  ],
                                  "verification": "Execute script MATLAB e interprete resultados corretamente.",
                                  "estimatedTime": "90 minutos",
                                  "materials": "MATLAB com Control System Toolbox; scripts de exemplo.",
                                  "tips": "Vetorize computações para eficiência em múltiplas frequências.",
                                  "learningObjective": "Desenvolver código MATLAB robusto para verificação automática.",
                                  "commonMistakes": "Erros de indexação em loops de frequência ou normalização incorreta."
                                }
                              ],
                              "practicalExample": "Considere N(s) = 1/(s+1), D(s) = 1/(s+2). Compute γ_v em MATLAB: defina sysN = tf(1,[1 1]), sysD = tf(1,[1 2]); use freqresp e sigma para γ_v ≈ 0.8 <1, confirmando coprimidade. Para não coprimo, N(s)=1/(s+1), D(s)=2/(s+1), γ_v >1.",
                              "finalVerifications": [
                                "Explica corretamente o teorema de Vinnicombe e suas condições.",
                                "Implementa γ_v em MATLAB sem erros numéricos.",
                                "Realiza divisão polinomial e interpreta resíduos.",
                                "Identifica coprimidade em 3 exemplos numéricos variados.",
                                "Discute diferenças entre métodos de Vinnicombe e divisão.",
                                "Gera plots de frequência validados."
                              ],
                              "assessmentCriteria": [
                                "Precisão na computação de γ_v (erro <1%).",
                                "Correta interpretação de resultados (coprimidade confirmada/invalidada).",
                                "Eficiência e legibilidade do código MATLAB.",
                                "Profundidade na análise de exemplos (incluindo edge cases).",
                                "Integração de ambos métodos com validação cruzada.",
                                "Clareza em relatórios e plots."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Análise funcional e valores singulares.",
                                "Programação: Desenvolvimento de scripts numéricos em MATLAB.",
                                "Física: Modelagem de sistemas dinâmicos lineares.",
                                "Engenharia de Software: Validação e testes automatizados."
                              ],
                              "realWorldApplication": "Em projeto de controladores H∞, verificar coprimidade garante estabilidade parametrizada; usado em aeroespacial para síntese de controladores robustos em aeronaves, evitando instabilidades devido a zeros/polos comuns não detectados."
                            },
                            "estimatedTime": "0.5 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.2.1.3",
                            "name": "Construir soluções Bezout",
                            "description": "Resolver a equação de Bezout para encontrar X e Y iniciais que estabilizam a planta nominal, utilizando algoritmos como o de Youla ou solvers lineares em MATLAB.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os Fundamentos da Equação de Bézout e Fatorizações Coprimas",
                                  "subSteps": [
                                    "Estude a definição da equação de Bézout: para polinômios coprimos N(s) e M(s), existem X(s) e Y(s) tais que X(s)N(s) + Y(s)M(s) = 1.",
                                    "Revise o conceito de fatorizações coprimas duplas de uma planta nominal G(s) = N(s)M⁻¹(s).",
                                    "Analise o papel de X e Y na parametrização de controladores estabilizadores.",
                                    "Explore a relação com o algoritmo estendido de Euclides para anéis de polinômios.",
                                    "Identifique condições de coprimidade usando testes de Rouché ou espectrais."
                                  ],
                                  "verification": "Escreva um resumo de 200 palavras explicando como X e Y estabilizam G(s), com um diagrama de blocos.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Livro 'Feedback Control Theory' de Doyle",
                                    "Notas de aula sobre H∞",
                                    "Software MATLAB com toolbox Control System"
                                  ],
                                  "tips": "Use representações em fração de Smith para visualizar coprimidade.",
                                  "learningObjective": "Explicar matematicamente o teorema de Bézout e sua aplicação em controle.",
                                  "commonMistakes": [
                                    "Confundir coprimidade bezoutiana com coprimidade comum.",
                                    "Ignorar a necessidade de estabilidade interna."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar e Construir Fatorizações Coprimas da Planta Nominal",
                                  "subSteps": [
                                    "Escolha uma planta nominal G(s), como G(s) = 1/(s² + s + 1).",
                                    "Realize a fatorização em N(s) e M(s) usando decomposição em frações parciais ou estados espaciais.",
                                    "Verifique coprimidade computando o índice de McMillan ou usando o teste de Popov-Belevitch-Hautus (PBH).",
                                    "Construa extensões biproprias estáveis se necessário.",
                                    "Documente as matrizes de Bezout iniciais."
                                  ],
                                  "verification": "Confirme coprimidade simulando gcd(N,M) = 1 no MATLAB.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "MATLAB com funções tf2ss e minreal",
                                    "Artigo sobre fatorizações coprimas de Vidyasagar"
                                  ],
                                  "tips": "Prefira normalizações para |N|_∞ ≤1 e |M|_∞ ≤1 para otimização posterior.",
                                  "learningObjective": "Construir representações coprimas estáveis para uma dada planta.",
                                  "commonMistakes": [
                                    "Escolher fatorizações não estáveis.",
                                    "Não normalizar adequadamente."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Resolver a Equação de Bézout Usando o Algoritmo Estendido de Euclides",
                                  "subSteps": [
                                    "Aplique o algoritmo estendido de Euclides para polinômios: divida M por N, rastreie coeficientes.",
                                    "Back-substitua para expressar 1 como combinação linear de N e M.",
                                    "Obtenha X(s) e Y(s) iniciais.",
                                    "Verifique a identidade XN + YM = 1 analiticamente.",
                                    "Ajuste para estabilidade se necessário."
                                  ],
                                  "verification": "Substitua e simplifique XN + YM para obter 1.",
                                  "estimatedTime": "2.5 horas",
                                  "materials": [
                                    "Pseudocódigo do algoritmo em Python/MATLAB",
                                    "Ferramenta simbólica como MuPAD ou Symbolic Toolbox"
                                  ],
                                  "tips": "Use convolução para multiplicação polinomial em implementações numéricas.",
                                  "learningObjective": "Implementar o solver analítico de Bézout para polinômios.",
                                  "commonMistakes": [
                                    "Erros em back-substituição.",
                                    "Tratar polinômios como inteiros sem considerar graus."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Implementar Solução Numérica em MATLAB com Algoritmo de Youla ou Solvers Lineares",
                                  "subSteps": [
                                    "Defina N, M como tf ou ss no MATLAB.",
                                    "Use o comando youla(G, C0) ou resolva via lmiquad para H∞ inicial.",
                                    "Implemente solver linear: discretize polinômios e resolva AX + BY =1.",
                                    "Extraia X e Y do resultado.",
                                    "Teste estabilidade com feedback(G, X*inv(Y))."
                                  ],
                                  "verification": "Execute simulação de resposta ao degrau no loop fechado; deve ser estável.",
                                  "estimatedTime": "3 horas",
                                  "materials": [
                                    "MATLAB Robust Control Toolbox",
                                    "Funções: coprime, youla, feedback"
                                  ],
                                  "tips": "Use hinfsyn para inicialização se Youla não convergir.",
                                  "learningObjective": "Desenvolver código MATLAB funcional para soluções Bézout.",
                                  "commonMistakes": [
                                    "Não lidar com singularidades numéricas.",
                                    "Esquecer de validar estabilidade."
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Validar e Refinar a Solução Bézout",
                                  "subSteps": [
                                    "Simule o controlador C0 = X inv(M) com G.",
                                    "Analise margens de ganho/fase e robustez.",
                                    "Compare com solução analítica.",
                                    "Refine usando Q-parametrização básica.",
                                    "Documente o processo completo."
                                  ],
                                  "verification": "Loop fechado assintoticamente estável com erro de rastreamento <5%.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Simulink para simulações",
                                    "Bode plots via margin()"
                                  ],
                                  "tips": "Monitore cond number das matrizes para numérica.",
                                  "learningObjective": "Garantir que X e Y estabilizem efetivamente a planta.",
                                  "commonMistakes": [
                                    "Validar apenas DC gain, ignorando dinâmica.",
                                    "Não testar perturbações."
                                  ]
                                }
                              ],
                              "practicalExample": "Para a planta G(s) = 1/(s(s+1)), fatorize como N(s)=1/(s(s+1)), M(s)=1 (coprimos). Usando Euclides: X(s) = s+1, Y(s) = -s, pois (s+1)*1 + (-s)/(s(s+1)) ajustado =1. Em MATLAB: [X,Y] = youla(tf(1,[1 1 0]), tf(1)); simule feedback(G, X*inv(tf(1))).",
                              "finalVerifications": [
                                "XN + YM = 1 identicamente.",
                                "Controlador C0 = X M⁻¹ estabiliza G internamente.",
                                "Margens de estabilidade >6dB/45°.",
                                "Simulação sem overshoot excessivo ou oscilações.",
                                "Solução numérica converge em <10 iterações.",
                                "Coprimidade confirmada por gcd=1."
                              ],
                              "assessmentCriteria": [
                                "Correção matemática da identidade Bézout (100%).",
                                "Estabilidade comprovada via simulação (bode/pole-zero).",
                                "Eficiência computacional em MATLAB (<5s execução).",
                                "Documentação clara com código comentado.",
                                "Robustez a variações de 10% em parâmetros.",
                                "Criatividade na escolha de planta de teste."
                              ],
                              "crossCurricularConnections": [
                                "Álgebra Linear: Solução de sistemas lineares para discretizações.",
                                "Teoria dos Números: Algoritmo de Euclides generalizado.",
                                "Programação: Otimização numérica em MATLAB/Python.",
                                "Engenharia de Software: Validação e testes unitários.",
                                "Matemática Computacional: Manipulação simbólica de frações racionais."
                              ],
                              "realWorldApplication": "Em controle robusto de aeronaves (e.g., estabilização de flaps via H∞), onde X e Y iniciais parametrizam bancos de controladores para lidar com incertezas aerodinâmicas, reduzindo tempo de design em 30% em indústrias como Boeing ou Embraer."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.5.2.2",
                        "name": "Parametrização de Youla-Kucera",
                        "description": "Representação paramétrica de todos os controladores estabilizantes da planta nominal utilizando um parâmetro Q estável arbitrário.",
                        "specificSkills": [
                          {
                            "id": "10.1.5.2.2.1",
                            "name": "Formular o controlador paramétrico",
                            "description": "Derivar e escrever a forma geral do controlador C(Q) = (X + D Q)(Y - N Q)^{-1}, onde Q ∈ RH∞, e demonstrar que estabiliza P para qualquer Q estável com norma adequada.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar a fatorização coprima da planta P e identidades de Bezout",
                                  "subSteps": [
                                    "Identificar a planta P(s) e realizar sua fatorização coprima em N/M (para representação de entrada-saída) ou D/N (para estado-espaco).",
                                    "Verificar que N e M (ou D e N) são estáveis e coprimos à direita (ou esquerda).",
                                    "Derivar as identidades de Bezout: encontrar X, Y tais que X M - Y N = I (ou similares para estabilização)."
                                  ],
                                  "verification": "Confirme que a fatorização é coprima calculando o índice de McMillan ou verificando que não há zeros comuns; escreva explicitamente X e Y.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Livro de Doyle ou Zhou sobre controle robusto",
                                    "Software MATLAB/Simulink para fatorização"
                                  ],
                                  "tips": "Use a função 'copfac' no MATLAB para automatizar a fatorização coprima.",
                                  "learningObjective": "Compreender a base para parametrização de todos os estabilizadores.",
                                  "commonMistakes": "Esquecer de normalizar as fatorizações para ||N||∞ <1 ou assumir coprimidade sem verificação."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Definir os controladores centrais e parâmetros auxiliares",
                                  "subSteps": [
                                    "Escolher controladores centrais estabilizadores: C1 = -Y1 X1^{-1} e C2 = X2^{-1} Y2.",
                                    "Derivar os parâmetros D = X1 X2^{-1} e N = -Y1 X2^{-1} (ou equivalentes na parametrização de Youla-Kucera).",
                                    "Verificar que [D N; -M X] ou similar satisfaz as identidades de Bezout."
                                  ],
                                  "verification": "Teste se D M + N X = I e similares, substituindo em uma simulação simples.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Notas de aula sobre Youla-Kucera",
                                    "Folha de cálculos simbólicos ou SymPy"
                                  ],
                                  "tips": "Lembre-se que X1, X2 são invertíveis em RH∞; use decomposição espectral se necessário.",
                                  "learningObjective": "Estabelecer os blocos fundamentais para a parametrização geral.",
                                  "commonMistakes": "Confundir as direções da coprimidade (direita vs esquerda) levando a fórmulas erradas."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Formular a expressão geral do controlador paramétrico C(Q)",
                                  "subSteps": [
                                    "Introduzir Q ∈ RH∞ estável com ||Q||∞ < γ adequado.",
                                    "Escrever C(Q) = (X + D Q) (Y - N Q)^{-1}, garantindo invertibilidade de (Y - N Q).",
                                    "Simplificar ou reescrever em formas alternativas como (X + Q D') (Y - Q N')^{-1} se aplicável."
                                  ],
                                  "verification": "Escreva C(Q) para um Q específico e verifique se é próprio e estável via plot de polos.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "MATLAB Control System Toolbox",
                                    "Exemplos numéricos de plantas como P(s)=1/(s-1)"
                                  ],
                                  "tips": "Garanta que Q seja estável e de norma limitada para evitar controladores impróprios.",
                                  "learningObjective": "Derivar a forma paramétrica universal de todos os estabilizadores.",
                                  "commonMistakes": "Esquecer o inverso ou inverter a ordem na multiplicação matricial."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Demonstrar estabilização de P por C(Q) e condições em Q",
                                  "subSteps": [
                                    "Substituir C(Q) na função de laço fechado T = P C (I + P C)^{-1} e mostrar que todos os blocos são estáveis.",
                                    "Provar usando identidades de Bezout que (I + P C(Q))^{-1} = Y - N Q estável para Q estável.",
                                    "Discutir normas: ||Q||∞ < 1/||N||∞ ou γ para desempenho H∞."
                                  ],
                                  "verification": "Simule o laço fechado em MATLAB e confirme ausência de polos instáveis; calcule ||T||∞.",
                                  "estimatedTime": "50 minutos",
                                  "materials": [
                                    "Simulink para simulação de laço fechado",
                                    "Gráficos de Bode/Nyquist"
                                  ],
                                  "tips": "Use a propriedade de que todos os estabilizadores são obtidos varrendo Q em RH∞.",
                                  "learningObjective": "Provar rigorosamente a estabilização e condições de robustez.",
                                  "commonMistakes": "Não considerar Q estável levando a contra-exemplos instáveis; ignorar normas para convergência."
                                }
                              ],
                              "practicalExample": "Para P(s) = 1/(s-1) (instável), fatorize como N=1/(s+1), M=(s)/(s+1). Encontre X,Y Bezout. Tome Q=0.5/(s+1), compute C(Q) e simule step response estável.",
                              "finalVerifications": [
                                "Escreve corretamente C(Q) = (X + D Q)(Y - N Q)^{-1}.",
                                "Demonstra via Bezout que I + P C(Q) é unimodular.",
                                "Verifica estabilidade para Q estável com ||Q||∞ <1.",
                                "Implementa em MATLAB e plota resposta estável.",
                                "Explica papel de RH∞ em Q."
                              ],
                              "assessmentCriteria": [
                                "Precisão na derivação de Bezout (100% correto).",
                                "Correção da prova de estabilização (lógica irrefutável).",
                                "Exemplo numérico funcional sem erros de simulação.",
                                "Compreensão de normas H∞ (define γ adequadamente).",
                                "Capacidade de generalizar para plantas MIMO."
                              ],
                              "crossCurricularConnections": [
                                "Álgebra Linear: Fatorizações coprimas e identidades matriciais.",
                                "Análise Funcional: Espaços de Hardy RH∞ e normas ∞.",
                                "Programação Numérica: Implementação em MATLAB/Simulink.",
                                "Otimização: Síntese de Q para desempenho μ ou H∞.",
                                "Física: Modelagem de sistemas dinâmicos lineares."
                              ],
                              "realWorldApplication": "Em controle de aeronaves (e.g., estabilização de flight control systems via H∞), onde Q parametriza trade-offs entre robustez a incertezas e desempenho, usado em F-16 fighters ou drones autônomos."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.5.2.1"
                            ]
                          },
                          {
                            "id": "10.1.5.2.2.2",
                            "name": "Implementar parametrização em software",
                            "description": "Usar funções do Robust Control Toolbox no MATLAB para computar N, D, X, Y e gerar famílias de controladores C(Q) para uma planta dada, plotando respostas em malha fechada.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Configurar o ambiente MATLAB e definir o modelo da planta",
                                  "subSteps": [
                                    "Inicie o MATLAB e verifique se o Robust Control Toolbox está instalado com o comando 'ver'.",
                                    "Defina o sistema da planta G(s) usando tf() ou ss() para representar o modelo dinâmico, por exemplo, G = tf(1, [1 1]) para uma planta simples.",
                                    "Especifique condições de estabilidade, como polo dominante ou ganho DC, para garantir que a planta seja estabilizável.",
                                    "Crie um controlador nominal C0 que estabilize G, usando sisotool ou funções como pidtune.",
                                    "Salve o workspace com save('planta_workspace.mat') para reutilização."
                                  ],
                                  "verification": "Execute 'whos' para confirmar que G e C0 estão definidos e plot(G) para visualizar a resposta em frequência.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "MATLAB com Robust Control Toolbox, documentação do toolbox (doc robustsys).",
                                  "tips": "Use modelos de baixa ordem inicialmente para depuração rápida.",
                                  "learningObjective": "Preparar modelos precisos da planta e controlador nominal para parametrização.",
                                  "commonMistakes": "Esquecer de verificar estabilidade de C0 com feedback(G*C0); planta instável leva a erros posteriores."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Computar fatores de fatoração coprime N, D, X, Y usando coprime",
                                  "subSteps": [
                                    "Use a função coprime(G, C0) para obter [N, D, X, Y] = coprime(G, C0).",
                                    "Verifique as propriedades de Bezout: N*X - D*Y ≈ 0 e D*X + G*Y ≈ I com norm() < 1e-10.",
                                    "Analise os fatores: plot bode de N, D, X, Y para entender comportamento em frequência.",
                                    "Ajuste pesos ou normalizações se necessário para fatores próprios mínimos.",
                                    "Documente os valores DC ou polos/zeros principais dos fatores."
                                  ],
                                  "verification": "Confirme que norm(N*X - D*Y) < 1e-10 e norm(D*X + G*Y - eye(size(G))) < 1e-10.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Função coprime do Robust Control Toolbox, exemplos da doc em robust-control.",
                                  "tips": "Escolha C0 com boa margem de fase para fatores bem condicionados.",
                                  "learningObjective": "Dominar o cálculo da fatoração coprime de Youla-Kucera para uma planta estabilizada.",
                                  "commonMistakes": "Usar G instável sem C0 estabilizador; resulta em fatores incorretos."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Gerar famílias de controladores C(Q) parametrizados",
                                  "subSteps": [
                                    "Defina o parâmetro Q como um sistema estável com norma H∞ <1, ex: Q = 0.5*tf(1,[1 0.1 1]).",
                                    "Calcule C(Q) = (X + G*Q)*(Y - N*Q)^(-1) ou use a fórmula invertida para estabilidade.",
                                    "Gere múltiplos Q: loop for com diferentes ordens ou parâmetros, salvando em cell array.",
                                    "Verifique estabilidade de cada C(Q) com pole(feedback(G*Cq)).",
                                    "Compare Q=0 (recupera C0) com outros Q para trade-offs."
                                  ],
                                  "verification": "Todos C(Q) estabilizam G: stepinfo(feedback(G*Cq)) sem overshoot excessivo.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Funções inv(), feedback(), funções de plot bode/step.",
                                  "tips": "Use padé para aproximações se Q for delay; mantenha ordem baixa para simulação rápida.",
                                  "learningObjective": "Implementar a parametrização Q para gerar todos os controladores estabilizadores.",
                                  "commonMistakes": "Inverter matrizes singulares; sempre cheque cond(Y - N*Q) > 1e-10."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Simular e plotar respostas em malha fechada para análise",
                                  "subSteps": [
                                    "Para cada C(Q), compute T = feedback(G*Cq/(1+G*Cq)) ou S = feedback(1,G*Cq).",
                                    "Gere plots: step(T), bode(T), nyquist(G*Cq) em subplots.",
                                    "Compare métricas: rise time, settling time, ||T||∞ com robuststab().",
                                    "Salve figuras com saveas(gcf, 'respostas_param.png').",
                                    "Gere relatório com métricas em tabela usando table() e disp()."
                                  ],
                                  "verification": "Plots mostram estabilidade (sem polos RHP) e trade-offs visíveis entre controladores.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Funções step(), bode(), robuststab(), exportgraphics().",
                                  "tips": "Use sgtitle() para legendas claras em múltiplos plots.",
                                  "learningObjective": "Avaliar performance de famílias de controladores via simulações.",
                                  "commonMistakes": "Plotar malha aberta em vez de fechada; sempre use feedback()."
                                }
                              ],
                              "practicalExample": "Para planta G(s) = 1/(s^2 + 0.2s + 1), use C0 = pidtune(G,'PID'). Compute N,D,X,Y. Defina Q1=0 (nominal), Q2=0.3/(s/10+1)^2. Plote step responses: Q2 reduz overshoot mas aumenta tempo de assentamento.",
                              "finalVerifications": [
                                "Fatores N,D,X,Y satisfazem equação de Bezout com erro <1e-10.",
                                "Todos C(Q) estabilizam G (polos em LHP confirmados).",
                                "Plots de step/bode mostram trade-offs claros (ex: robustez vs performance).",
                                "Métricas como ||T||∞ <2 para todos controladores.",
                                "Código reproduzível sem erros em workspace salvo.",
                                "Relatório com tabela de comparações gerado."
                              ],
                              "assessmentCriteria": [
                                "Precisão numérica nos fatores coprime (erro Bezout <1e-12).",
                                "Diversidade de Q testados (pelo menos 3, com ordens variadas).",
                                "Qualidade dos plots: legendas, escalas adequadas, múltiplas curvas comparadas.",
                                "Análise quantitativa: stepinfo() e robuststab() aplicados corretamente.",
                                "Eficiência do código: loops otimizados, sem warnings MATLAB.",
                                "Documentação inline no script com % comentários."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Álgebra linear (inversas, normas matriciais) e teoria de funções de transferência.",
                                "Programação: Scripting avançado em MATLAB, vetores cell e loops.",
                                "Física/Engenharia: Modelagem de sistemas dinâmicos e análise de estabilidade.",
                                "Estatística: Análise de sensibilidade via normas H∞."
                              ],
                              "realWorldApplication": "Em indústrias aeroespacial e automotiva, parametrização Youla permite tunar controladores para trade-offs entre performance e robustez em plantas incertas, como suspensão de veículos ou estabilização de drones sob variações de carga."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.5.2.1"
                            ]
                          },
                          {
                            "id": "10.1.5.2.2.3",
                            "name": "Escolher parâmetro Q inicial",
                            "description": "Selecionar Q=0 para recuperar o controlador nominal C0 = X Y^{-1} e explorar variações lineares de Q para ajustar desempenho mantendo estabilidade.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender e recuperar o controlador nominal C0 com Q=0",
                                  "subSteps": [
                                    "Revisar a parametrização de Youla-Kucera: todos os controladores estabilizadores são C = (X + D Q)(Y - N Q)^{-1}, onde Q é estável.",
                                    "Identificar os fatores de Bezout: X, Y, D, N para a planta G = N M^{-1}.",
                                    "Definir Q = 0 e calcular C0 = X Y^{-1}.",
                                    "Verificar se C0 estabiliza a planta nominal.",
                                    "Implementar em software para confirmação simbólica ou numérica."
                                  ],
                                  "verification": "Comparar C(Q=0) com o controlador nominal conhecido e confirmar estabilidade via margens ou simulação.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "MATLAB/Simulink com toolbox Control System",
                                    "Notas teóricas de H∞/Youla",
                                    "Planta modelo G(s)"
                                  ],
                                  "tips": "Use a função 'c2d' ou simbólica para evitar erros numéricos em Q=0.",
                                  "learningObjective": "Entender como Q=0 recupera o controlador base e sua importância como ponto de partida.",
                                  "commonMistakes": "Confundir os fatores Bezout (X,Y com D,N) ou falhar na verificação de coprimidade."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Avaliar desempenho e estabilidade do controlador nominal C0",
                                  "subSteps": [
                                    "Simular a malha fechada com C0 na planta nominal.",
                                    "Calcular métricas de desempenho: tempo de subida, overshoot, erro estacionário.",
                                    "Analisar robustez: margens de ganho/fase e sensibilidade.",
                                    "Identificar limitações de desempenho do C0 (ex.: overshoot alto ou resposta lenta).",
                                    "Documentar resultados em gráficos de resposta temporal e Bode."
                                  ],
                                  "verification": "Gerar plots confirmando estabilidade (polos no semiplano esquerdo) e métricas dentro de specs iniciais.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "MATLAB com funções stepinfo, margin, bode",
                                    "Dados da planta G(s)"
                                  ],
                                  "tips": "Use stepinfo() para métricas automáticas e compare com requisitos de design.",
                                  "learningObjective": "Avaliar quantitativamente o baseline C0 para guiar ajustes via Q.",
                                  "commonMistakes": "Ignorar não-linearidades ou perturbações na avaliação inicial."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explorar variações lineares pequenas de Q",
                                  "subSteps": [
                                    "Escolher Q inicial como perturbação linear: Q = ε * Q_base, com ε pequeno (ex.: 0.01-0.1).",
                                    "Selecionar Q_base estável, como filtro low-pass ou constante.",
                                    "Calcular novos controladores C(Q) para diferentes ε.",
                                    "Simular respostas para cada variação e plotar sensibilidade.",
                                    "Verificar manutenção de estabilidade via norma H∞ ou simulação."
                                  ],
                                  "verification": "Confirmar que ||Tzw(Q)||_∞ permanece abaixo do limite para estabilidade robusta.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "MATLAB hinfsyn ou tf para Q",
                                    "Scripts de simulação personalizados"
                                  ],
                                  "tips": "Comece com ε positivo e negativo para explorar trade-offs simétricos.",
                                  "learningObjective": "Explorar o espaço linear de Q próximo a zero para entender impactos locais.",
                                  "commonMistakes": "Escolher ε muito grande, violando lineariedade ou estabilidade."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Selecionar e validar Q inicial ótimo",
                                  "subSteps": [
                                    "Comparar métricas de desempenho entre variações de Q.",
                                    "Escolher Q que melhore desempenho (ex.: reduzir overshoot) sem perder estabilidade.",
                                    "Otimizar ε via grid search ou gradiente simples.",
                                    "Validar em simulações com incertezas na planta.",
                                    "Documentar Q selecionado e razões da escolha."
                                  ],
                                  "verification": "Teste final: resposta da malha fechada atende specs melhoradas e robustas.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Ferramentas de otimização MATLAB (fminsearch)",
                                    "Modelos com incertezas"
                                  ],
                                  "tips": "Priorize trade-off desempenho/robustez usando Pareto frontal simples.",
                                  "learningObjective": "Selecionar Q inicial que equilibre desempenho e estabilidade para iterações futuras.",
                                  "commonMistakes": "Overfitting a planta nominal sem testar robustez."
                                }
                              ],
                              "practicalExample": "Para uma planta de motor DC G(s) = 1/(s(s+1)), com C0 = [1 2; 0.5 1] Y^{-1} (fatores Bezout dados), defina Q=0.05*(1/(s+2)) e simule: reduz overshoot de 25% para 10% mantendo PM>45°.",
                              "finalVerifications": [
                                "C(Q=0) recupera exatamente C0 nominal.",
                                "Variações lineares de Q mantêm estabilidade (polos LHP).",
                                "Desempenho melhorado em pelo menos uma métrica chave.",
                                "Robustez confirmada via simulação com ±10% variação em G.",
                                "Documentação inclui plots e justificativa de Q escolhido."
                              ],
                              "assessmentCriteria": [
                                "Precisão no cálculo de C0 e fatores Bezout (erro <1%).",
                                "Análise correta de sensibilidade linear em Q.",
                                "Seleção de Q com trade-off explícito e quantificado.",
                                "Verificações de estabilidade e robustez completas.",
                                "Relatório claro com plots e conclusões acionáveis."
                              ],
                              "crossCurricularConnections": [
                                "Álgebra Linear: Inversas de matrizes de transferência e Bezout.",
                                "Otimização Numérica: Busca paramétrica em ε.",
                                "Programação Computacional: Scripts MATLAB para automação.",
                                "Teoria de Sistemas Dinâmicos: Análise de estabilidade H∞."
                              ],
                              "realWorldApplication": "Em automação industrial, como controle de velocidade de motores em linhas de produção, onde Q inicial ajusta resposta rápida sem oscilações, permitindo escalabilidade para μ-síntese robusta contra variações de carga."
                            },
                            "estimatedTime": "0.5 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.5.2.2.1"
                            ]
                          },
                          {
                            "id": "10.1.5.2.2.4",
                            "name": "Provar completude da parametrização",
                            "description": "Demonstrar que todo controlador estabilizante C pode ser escrito como C(Q) para algum Q único em RH∞, usando a bijeção com o teorema de Youla.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Fatorização Coprima e Identidade de Bezout",
                                  "subSteps": [
                                    "Defina a fatorização coprima à direita (RCP) da planta G: G = N D⁻¹, onde N, D ∈ RH∞ e coprimos.",
                                    "Estabeleça a identidade de Bezout: existem X, Y ∈ RH∞ tais que X N - Y M = I, onde M é a fatorização do inverso estabilizado.",
                                    "Verifique que [X Y] [ -M ; N ] = I, confirmando a existência de controladores estabilizantes básicos.",
                                    "Discuta a dupla coprima para fatorizações left e right em sistemas monovariáveis.",
                                    "Esboce graficamente o loop unitário feedback com os fatores."
                                  ],
                                  "verification": "Escreva corretamente as equações da RCP e Bezout, sem erros de notação.",
                                  "estimatedTime": "30 minutes",
                                  "materials": [
                                    "Notas de aula sobre fatorizações coprimas",
                                    "Zhou, Doyle, Glover - Robust and Optimal Control (Capítulo 5)",
                                    "MATLAB para plotar fatores"
                                  ],
                                  "tips": "Use notação consistente: sempre especifique se é left ou right coprime para evitar confusões.",
                                  "learningObjective": "Compreender as fundações algébricas necessárias para a parametrização.",
                                  "commonMistakes": [
                                    "Confundir fatores N e M",
                                    "Esquecer que X, Y devem ser em RH∞",
                                    "Ignorar a coprimidade"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Enunciar a Parametrização de Youla-Kučera",
                                  "subSteps": [
                                    "Escreva a fórmula geral: todo C estabilizante é C(Q) = (X + D Q) (Y - N Q)⁻¹ para Q ∈ RH∞.",
                                    "Explique que Y - N Q é invertível em RH∞ se Q ∈ RH∞.",
                                    "Mostre que C(0) = X Y⁻¹ é um controlador estabilizante básico.",
                                    "Verifique estabilidade: insira C(Q) no loop e use Bezout para provar ||T||_∞ < ∞.",
                                    "Discuta o mapeamento Q → C(Q) como bijeção."
                                  ],
                                  "verification": "Derive a fórmula C(Q) a partir do diagrama de Youla e confira estabilidade.",
                                  "estimatedTime": "45 minutes",
                                  "materials": [
                                    "Diagrama de Youla-Kučera impresso",
                                    "Software como MATLAB Control Toolbox para simular Q=0"
                                  ],
                                  "tips": "Desenhe o diagrama Q-parameterization para visualizar a injeção de Q.",
                                  "learningObjective": "Dominar a expressão parametrizada de controladores estabilizantes.",
                                  "commonMistakes": [
                                    "Escrever C(Q) = (Y + M Q)(X - N Q)⁻¹ incorretamente",
                                    "Não justificar invertibilidade de Y - N Q"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Expressar Controlador Arbitrário C em Fatores Coprimos",
                                  "subSteps": [
                                    "Dado C estabilizante qualquer, escreva sua RCP: C = V U⁻¹ com V, U ∈ RH∞ coprimos.",
                                    "Como C estabiliza G, existe identidade de Bezout dupla: [U V] [-D ; N] = I.",
                                    "Use estabilidade do loop fechado para garantir coprimidade de V, U.",
                                    "Confirme que o par (V, U) satisfaz as condições de estabilidade com G.",
                                    "Esboce a relação entre fatores de C e de G."
                                  ],
                                  "verification": "Construa V e U para um C dado e verifique a identidade de Bezout.",
                                  "estimatedTime": "40 minutes",
                                  "materials": [
                                    "Folha de exercícios com exemplos numéricos",
                                    "Livro de Vidyasagar - Control System Synthesis"
                                  ],
                                  "tips": "Comece com um C simples como proporcional para praticar.",
                                  "learningObjective": "Saber representar qualquer estabilizante em forma coprima.",
                                  "commonMistakes": [
                                    "Assumir fatores left em vez de right",
                                    "Não provar coprimidade usando estabilidade"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Derivar Q a Partir da Fórmula de Parametrização",
                                  "subSteps": [
                                    "Iguale C = V U⁻¹ = (X + D Q)(Y - N Q)⁻¹.",
                                    "Multiplique ambos os lados por denominadores: V (Y - N Q) = U (X + D Q).",
                                    "Expanda e isole Q: V Y - V N Q = U X + U D Q.",
                                    "Agrupe termos: -V N Q - U D Q = U X - V Y → Q = (V N - U D)⁻¹ (V Y - U X), mas use Bezout.",
                                    "Use [U V] [-D N]^T = I para simplificar: Q = U M + V N? Não, derive Q = V (-M) + U N ajustando."
                                  ],
                                  "verification": "Resolva algebricamente para Q e simplifique usando Bezout para Q = U M + V (-N)? Corrija para Q padrão.",
                                  "estimatedTime": "60 minutes",
                                  "materials": [
                                    "Lápis e papel para álgebra simbólica",
                                    "SymPy ou Mathematica para verificação algébrica"
                                  ],
                                  "tips": "Substitua sistematicamente e cancele termos usando Bezout desde o início.",
                                  "learningObjective": "Extrair Q explicitamente de C arbitrário.",
                                  "commonMistakes": [
                                    "Erro na expansão algébrica",
                                    "Não usar Bezout para simplificar Q = -U M + V N"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Provar que Q ∈ RH∞ e Unicidade",
                                  "subSteps": [
                                    "Mostre Q ∈ RH∞: como combinação linear de fatores estáveis V, U, N, M, D.",
                                    "Explicitamente: da derivação, Q = U M - V N (ajustar sinal pela Bezout).",
                                    "Unicidade: suponha dois Q1, Q2 dando mesmo C → (X + D Q1)(Y - N Q1)⁻¹ = (X + D Q2)... → Q1 = Q2 por invertibilidade.",
                                    "Confirme bijeção: mapeamento Q ↔ C é linear fracionário invertível em RH∞.",
                                    "Conclua completude: todo C coberto."
                                  ],
                                  "verification": "Escreva prova formal de Q estável e injetividade do mapeamento.",
                                  "estimatedTime": "45 minutes",
                                  "materials": [
                                    "Resumo do teorema de Youla",
                                    "Artigo original de Youla (opcional)"
                                  ],
                                  "tips": "Use propriedades de RH∞ (fechado sob soma, produto) para estabilidade.",
                                  "learningObjective": "Completar a prova de completude e bijeção.",
                                  "commonMistakes": [
                                    "Não provar estabilidade de Q",
                                    "Confundir unicidade com existência"
                                  ]
                                }
                              ],
                              "practicalExample": "Para G(s) = 1/(s-1) (instável), RCP: N=1/(s+1), D=(s-1)/(s+1)^2 ajustada. C(s)=1 estabiliza. Derive Q: fatorize C=1/1, aplique fórmula → Q(s)=2s/(s+1)^2 ∈ RH∞. Verifique C(Q)=1.",
                              "finalVerifications": [
                                "Pode derivar Q para C arbitrário usando Bezout?",
                                "Explica por que Y - N Q é invertível?",
                                "Mostra estabilidade de C(Q) para qualquer Q ∈ RH∞?",
                                "Identifica Q único para dado C?",
                                "Aplica em exemplo numérico simples?",
                                "Discute implicações para síntese H∞?"
                              ],
                              "assessmentCriteria": [
                                "Correção algébrica na derivação de Q (100%)",
                                "Uso apropriado da identidade de Bezout em todos steps",
                                "Clareza na prova de Q ∈ RH∞ e unicidade",
                                "Notação consistente e precisa",
                                "Profundidade nos substeps (mínimo 4 por step)",
                                "Conexão explícita entre steps na conclusão"
                              ],
                              "crossCurricularConnections": [
                                "Álgebra Linear: Espaços de soluções de equações lineares em anéis (RH∞)",
                                "Análise Funcional: Espaços de Hardy (RH∞) e normas H∞",
                                "Teoria de Sistemas: Realizações mínimas e coprimidade",
                                "Otimização: Parametrização para problemas convexos em H∞-síntese"
                              ],
                              "realWorldApplication": "Em design de controladores robustos para aviões (e.g., F-16 via H∞), garante que todos candidatos estabilizantes sejam parametrizados por Q, permitindo otimização convexa de performance via Q ótimo em RH∞."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.5.2.2.1"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "10.1.5.2.3",
                        "name": "Propriedades e Aplicações da Parametrização",
                        "description": "Propriedades chave da parametrização para otimização em H∞ e μ-síntese, incluindo linearidade em Q e facilidades para robustez.",
                        "specificSkills": [
                          {
                            "id": "10.1.5.2.3.1",
                            "name": "Expressar funções de malha fechada",
                            "description": "Reescrever sensibilidade S = (I + P C)^{-1} = (Y - N Q)^{-1}, complementar T = P C (I + P C)^{-1} = N (Y - N Q)^{-1} e funções de robustez em termos lineares de Q.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar funções de malha fechada padrão",
                                  "subSteps": [
                                    "Identificar as funções principais: sensibilidade S = (I + P C)^{-1}, função complementar T = P C (I + P C)^{-1}.",
                                    "Explicar o significado físico: S mede rejeição de distúrbios, T segue referências.",
                                    "Listar funções de robustez: ||S||∞ para estabilidade, ||T||∞ para desempenho.",
                                    "Derivar relações básicas: S + T = I.",
                                    "Praticar com diagrama de malha fechada unitária feedback."
                                  ],
                                  "verification": "Reescrever corretamente S e T em termos de P e C, e listar 3 funções de robustez.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Diagrama de malha fechada impresso",
                                    "Livro de Controle Clássico (cap. malha fechada)",
                                    "Caderno para anotações"
                                  ],
                                  "tips": "Desenhe o diagrama de sinal para visualizar fluxos de erro e saída.",
                                  "learningObjective": "Compreender as expressões canônicas e seu significado em controle.",
                                  "commonMistakes": [
                                    "Confundir S com T",
                                    "Esquecer que S + T = I",
                                    "Ignorar normalizações em ||.||∞"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Introduzir parametrização de estabilizadores com Youla",
                                  "subSteps": [
                                    "Explicar fatorização coprima bipropia: P = N M^{-1} = \tilde{M}^{-1} \tilde{N}.",
                                    "Definir todos os estabilizadores: C = (Y - M Q)(X - N Q)^{-1}, com Q estável.",
                                    "Apresentar Y, N, X, M como soluções de Bezout: X N - Y M = -I.",
                                    "Verificar que todos C estabilizam P para Q estável arbitrário.",
                                    "Discutir linearidade em Q para funções de malha fechada."
                                  ],
                                  "verification": "Escrever a forma geral de C em termos de Q e listar condições para estabilidade.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Artigo ou capítulo sobre Youla-Kucera",
                                    "Software simbólico como Mathematica ou MATLAB Symbolic Toolbox",
                                    "Folhas com equações de Bezout"
                                  ],
                                  "tips": "Lembre-se: Q é o parâmetro livre que lineariza as expressões.",
                                  "learningObjective": "Dominar a parametrização e sua flexibilidade para design.",
                                  "commonMistakes": [
                                    "Confundir fatorizações left/right",
                                    "Esquecer invertibilidade de M e X - N Q",
                                    "Achar que Q deve estabilizar P"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Derivar expressão da sensibilidade S em termos de Q",
                                  "subSteps": [
                                    "Substituir C na fórmula de S: S = (I + P C)^{-1}.",
                                    "Usar P = N M^{-1} e C = (Y - M Q)(X - N Q)^{-1}.",
                                    "Simplificar usando identidade de Bezout: chegar a S = (Y - N Q)^{-1}.",
                                    "Verificar com expansão: multiplicar por (Y - N Q) para obter I + P C.",
                                    "Normalizar unidades e discutir estabilidade: ||S||∞ depende linearmente de Q."
                                  ],
                                  "verification": "Derivar algebricamente S = (Y - N Q)^{-1} a partir de P e C parametrizados.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "MATLAB para manipulação simbólica",
                                    "Papel quadriculado para álgebra matricial",
                                    "Referência: Doyle et al. 'Feedback Control Theory'"
                                  ],
                                  "tips": "Use identidades matriciais passo a passo; evite saltos na derivação.",
                                  "learningObjective": "Executar a derivação exata de S linear em Q.",
                                  "commonMistakes": [
                                    "Erro na substituição de C",
                                    "Não inverter corretamente",
                                    "Esquecer fatorização coprima"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Derivar T e funções de robustez lineares em Q",
                                  "subSteps": [
                                    "Derivar T = P C (I + P C)^{-1} = N (Y - N Q)^{-1}, usando S derivada.",
                                    "Verificar consistência: S + T = (Y - N Q)^{-1} + N (Y - N Q)^{-1} = (I + N M^{-1} ? wait, usar Bezout).",
                                    "Expressar robustez: e.g., KS = C S = (X - N Q) (Y - N Q)^{-1}, linear em Q.",
                                    "Discutir KS, KS\tilde{} para μ-síntese e H∞.",
                                    "Aplicar a um exemplo numérico simples para validar."
                                  ],
                                  "verification": "Obter T = N (Y - N Q)^{-1} e pelo menos duas funções de robustez lineares em Q.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "MATLAB Simulink para simulação",
                                    "Exemplo numérico de planta de 1ª ordem",
                                    "Calculadora matricial"
                                  ],
                                  "tips": "Sempre verifique S + T = I após derivação para sanity check.",
                                  "learningObjective": "Completar o conjunto de expressões lineares para design otimizado.",
                                  "commonMistakes": [
                                    "Erro em T = I - S",
                                    "Não linearizar corretamente KS",
                                    "Ignorar dualidades left/right"
                                  ]
                                }
                              ],
                              "practicalExample": "Para P(s) = 1/(s+1), fatorize coprimamente N(s)=1/(s+1), M(s)=1, Y(s)=0, X(s)=s+1. Escolha Q(s)=k/(s+2), compute S=( -k/(s+2) )^{-1} wait, derive S=(Y-NQ)^{-1}, T=N(Y-NQ)^{-1}, e otimize k para minimizar ||S||∞ <1.",
                              "finalVerifications": [
                                "Derivação correta de S = (Y - N Q)^{-1}.",
                                "Expressão exata de T = N (Y - N Q)^{-1}.",
                                "Pelo menos duas funções de robustez lineares em Q (ex: KS, T).",
                                "Verificação S + T = I.",
                                "Aplicação numérica em planta simples com erro <1%.",
                                "Explicação verbal das implicações para design H∞."
                              ],
                              "assessmentCriteria": [
                                "Precisão algébrica nas derivações (sem erros de sinal ou inversão).",
                                "Compreensão conceitual: explicar linearidade em Q para otimização.",
                                "Capacidade de aplicar a exemplo concreto com cálculos numéricos.",
                                "Identificação correta de funções de robustez relevantes.",
                                "Uso apropriado de Bezout e coprimidade.",
                                "Clareza na verificação de estabilidade e desempenho."
                              ],
                              "crossCurricularConnections": [
                                "Álgebra Linear: manipulação de frações matriciais e identidades.",
                                "Otimização: formular problemas H∞ como min ||Tzw||∞ via Q.",
                                "Sistemas Dinâmicos: análise de estabilidade paramétrica.",
                                "Processamento de Sinais: filtros lineares e normas ∞.",
                                "Programação Numérica: uso de toolboxes para síntese."
                              ],
                              "realWorldApplication": "No design de controladores robustos para drones, onde perturbações (vento) são modeladas via S, e desempenho de rastreamento via T; otimizar Q minimiza picos de ||S||∞, garantindo estabilidade sob variações de massa em ±20%."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.5.2.2"
                            ]
                          },
                          {
                            "id": "10.1.5.2.3.2",
                            "name": "Analisar robustez paramétrica",
                            "description": "Avaliar o impacto de perturbações na planta ΔP na estabilidade usando small gain theorem na parametrização, preparando para H∞.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Fundamentos da Parametrização de Controladores Estabilizadores",
                                  "subSteps": [
                                    "Relembrar a parametrização de Youla-Kučera: Q(s) parametrizando todos os controladores C(s) estabilizadores para uma planta nominal P(s).",
                                    "Derivar as expressões para o sistema fechado: T(zw) = (I + P K)^{-1} P e S(zw) = (I + K P)^{-1}.",
                                    "Identificar a estrutura coprima: fatorar P = N/M onde N e M são coprimos estáveis.",
                                    "Verificar estabilidade nominal usando equações de entrada-saída na parametrização.",
                                    "Esboçar diagrama de blocos da parametrização com Q(s)."
                                  ],
                                  "verification": "Capacidade de reproduzir a fórmula do controlador estabilizador C = (X + D Q)(Y + N Q)^{-1} sem consulta.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Livro de controle avançado (e.g., Zhou 'Robust and Optimal Control'), MATLAB para plotar respostas nominais.",
                                  "tips": "Use fatorização coprima dupla para evitar confusões entre fatorizações esquerda e direita.",
                                  "learningObjective": "Compreender a base paramétrica para análise de robustez.",
                                  "commonMistakes": "Confundir Q(s) estável com controlador instável; assumir estabilidade sem verificar coprimidade."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Modelar Perturbações Paramétricas na Planta ΔP",
                                  "subSteps": [
                                    "Definir a planta perturbada como P_Δ = P (I + ΔP), onde ΔP representa variações paramétricas (e.g., ganho, tempo morto).",
                                    "Classificar tipos de ΔP: aditivas, multiplicativas paramétricas, normadas em norma H∞.",
                                    "Computar normas relevantes: ||ΔP||_∞ < 1/||T||_∞ para garantia de estabilidade.",
                                    "Simular ΔP em um modelo simples, como P(s) = 1/(s+1) com variação de polo.",
                                    "Plotar singular values de P e P_Δ para visualizar impacto."
                                  ],
                                  "verification": "Gerar plot de singular values mostrando ||ΔP||_∞ e confirmar limite para estabilidade.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "MATLAB/Simulink com toolbox Robust Control, exemplos de plantas SISO.",
                                  "tips": "Norme ΔP adequadamente; use svd para valores singulares.",
                                  "learningObjective": "Modelar realisticamente perturbações paramétricas em plantas.",
                                  "commonMistakes": "Usar norma L2 em vez de H∞ para teorema small-gain; ignorar fase em perturbações."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Aplicar o Teorema Small-Gain para Análise de Estabilidade",
                                  "subSteps": [
                                    "Enunciar small-gain theorem: Sistema estável se ||G1||_∞ * ||G2||_∞ < 1, onde G1 = T_{zw}(Q), G2 = ΔP.",
                                    "Derivar condição de robustez: estabilidade se ||ΔP||_∞ < 1/||M (I - Q N)^{-1}||_∞ na parametrização.",
                                    "Calcular ||T||_∞ e margem de robustez para Q nominal.",
                                    "Testar violações: Escolha ΔP com ||ΔP||_∞ > limite e simule instabilidade.",
                                    "Usar mu-toolbox para análise estrutural se ΔP for paramétrica."
                                  ],
                                  "verification": "Demonstrar que para ||ΔP||_∞ = 0.9 * limite, sistema estável; acima, instável via simulação.",
                                  "estimatedTime": "75 minutos",
                                  "materials": "MATLAB Robust Control Toolbox (usdiag, mussv), notas de aula sobre small-gain.",
                                  "tips": "Linearize small-gain para perturbações pequenas; verifique com loop-shaping.",
                                  "learningObjective": "Aplicar small-gain quantitativamente na parametrização.",
                                  "commonMistakes": "Aplicar small-gain sem norma indutiva; confundir com small perturbation theorem."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Avaliar Impacto e Preparar para Síntese H∞",
                                  "subSteps": [
                                    "Quantificar sensibilidade: Plotar ||T (I + ΔP)||_∞ vs. ||ΔP||_∞.",
                                    "Analisar trade-offs: Margem robusta vs. desempenho nominal.",
                                    "Conectar a H∞: Reformular como min ||T||_∞ s.t. robustez, levando a síntese H∞.",
                                    "Simular exemplo completo: Controlador Q otimizado para robustez paramétrica.",
                                    "Documentar relatório com gráficos de Bode e steps de Nyquist."
                                  ],
                                  "verification": "Relatório mostrando cálculo de margem e transição para problema H∞ padrão.",
                                  "estimatedTime": "90 minutos",
                                  "materials": "MATLAB hinfsyn, exemplos de Doyle-McFarlane ou Glover.",
                                  "tips": "Use gamma iteration para preview de H∞; foque em picos de ||T||_∞.",
                                  "learningObjective": "Ligar análise paramétrica à síntese ótima robusta.",
                                  "commonMistakes": "Ignorar conservadorismo do small-gain; não normalizar pesos."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Validar e Sintetizar Resultados",
                                  "subSteps": [
                                    "Realizar Monte Carlo com ΔP aleatórias dentro do limite.",
                                    "Comparar com métodos alternativos (e.g., robustez real paramétrica).",
                                    "Preparar transição: Definir pesos Wp, Wt para H∞ setup.",
                                    "Arquivar código e plots para reutilização.",
                                    "Discutir limitações: Small-gain é conservador para ΔP estruturadas."
                                  ],
                                  "verification": "Simulações Monte Carlo com 100 runs mostrando 95% estabilidade dentro limite.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "MATLAB com wcgain, usim para worst-case gain.",
                                  "tips": "Automatize simulações com for-loops para eficiência.",
                                  "learningObjective": "Validar análise e pavimentar para métodos avançados.",
                                  "commonMistakes": "Sobreestimar robustez sem validação numérica; esquecer normalização."
                                }
                              ],
                              "practicalExample": "Considere uma planta nominal P(s) = 1/(s^2 + 0.2s + 1) (oscilador massa-mola). Perturbe com ΔP multiplicativo variando rigidez em ±20%. Use Q(s) = K/(s+1) e aplique small-gain para verificar ||ΔP||_∞ < 1/||T_{PΔ→y}||_∞ ≈ 1.2. Simule instabilidade para ΔP=0.3.",
                              "finalVerifications": [
                                "Cálculo correto de ||T||_∞ e limite de ||ΔP||_∞.",
                                "Simulações confirmam estabilidade/ instabilidade conforme small-gain.",
                                "Plots de singular values mostram margens claras.",
                                "Condições derivadas alinham com parametrização coprima.",
                                "Transição explícita para setup H∞ com pesos.",
                                "Relatório quantifica impacto paramétrico em desempenho."
                              ],
                              "assessmentCriteria": [
                                "Precisão matemática na aplicação de small-gain (derivadas corretas).",
                                "Qualidade das simulações (plots legíveis, cenários variados).",
                                "Profundidade da análise de impacto (sensibilidade, trade-offs).",
                                "Conexão clara com H∞ síntese.",
                                "Identificação de erros comuns e limitações.",
                                "Eficiência temporal e uso de ferramentas."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria de operadores em espaços de Hardy (H∞).",
                                "Programação: Simulações numéricas em MATLAB para análise de robustez.",
                                "Física: Modelagem de sistemas dinâmicos com incertezas paramétricas.",
                                "Otimização: Preparação para problemas de minimização H∞."
                              ],
                              "realWorldApplication": "Em controle de drones com variações de massa/carga (ΔP paramétrica), análise small-gain garante estabilidade em voo autônomo apesar de payloads variáveis, pavimentando para controladores H∞ em UAVs comerciais."
                            },
                            "estimatedTime": "0.5 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.5.2.2"
                            ]
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.5.3",
                    "name": "Projeto de Controladores H∞",
                    "description": "Síntese de controladores que minimizam a norma H∞ para garantir desempenho e robustez em sistemas escalares.",
                    "individualConcepts": [
                      {
                        "id": "10.1.5.3.1",
                        "name": "Norma H∞ em Sistemas LIT Escalares",
                        "description": "Definição e interpretação da norma H∞ como o ganho máximo supraremo de uma função de transferência em frequência, fundamental para especificar limites de desempenho e robustez em sistemas lineares invariantes no tempo (LIT) monovariáveis.",
                        "specificSkills": [
                          {
                            "id": "10.1.5.3.1.1",
                            "name": "Calcular a norma H∞ de funções de transferência",
                            "description": "Dado um sistema LIT escalar representado por função de transferência G(s), computar ||G||_∞ = sup_ω |G(jω)| utilizando métodos analíticos ou numéricos como plotagem de diagrama de Bode e identificação de picos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Representar o sistema LIT escalar e formular |G(jω)|",
                                  "subSteps": [
                                    "Escreva a função de transferência G(s) no formato polinomial num/den.",
                                    "Substitua s = jω para obter G(jω).",
                                    "Calcule a magnitude |G(jω)| = sqrt( G(jω) * conj(G(jω)) ) ou |num(jω)| / |den(jω)|.",
                                    "Identifique os pólos e zeros para prever comportamento em frequência.",
                                    "Simplifique expressões para baixas e altas frequências (lim ω→0 e ω→∞)."
                                  ],
                                  "verification": "Verifique se |G(jω)| está corretamente expresso e limites assintóticos coincidem com teoria.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Função de transferência G(s)",
                                    "Papel e caneta ou editor de texto",
                                    "Calculadora simbólica (opcional)"
                                  ],
                                  "tips": "Use sympy ou MATLAB Symbolic para simplificação algébrica inicial.",
                                  "learningObjective": "Formular a resposta em frequência de G(s) de forma precisa.",
                                  "commonMistakes": [
                                    "Esquecer de normalizar por grau de denominador em limites.",
                                    "Confundir fase com magnitude na expressão."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Análise analítica para encontrar o pico máximo",
                                  "subSteps": [
                                    "Defina M(ω) = |G(jω)|^2 para facilitar derivação.",
                                    "Compute dM/dω = 0 e resolva para ω crítico.",
                                    "Verifique segunda derivada ou sinal para confirmar máximo local.",
                                    "Avalie |G(jω_c)| nos ω críticos encontrados.",
                                    "Compare com limites para confirmar supremo global."
                                  ],
                                  "verification": "Resolva equação derivada e confirme que |G(jω_c)| > limites assintóticos.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Software simbólico como MATLAB Symbolic ou SymPy (Python)",
                                    "Papel para derivações manuais"
                                  ],
                                  "tips": "Para sistemas de ordem 2, use fórmula fechada de ressonância ω_r = sqrt(ω_n^2 - ζ^2 ω_n^2).",
                                  "learningObjective": "Aplicar otimização univariada para encontrar máximo de |G(jω)|.",
                                  "commonMistakes": [
                                    "Erros em derivadas de senos/cossenos em |num| e |den|.",
                                    "Ignorar múltiplos máximos locais."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar plotagem numérica do diagrama de Bode",
                                  "subSteps": [
                                    "Gere vetor de frequências ω log-espalhado (ex: logspace(-2,2,10000)).",
                                    "Compute G(jω) numericamente usando freqresp ou bode em MATLAB/Python.",
                                    "Plote magnitude em dB vs log(ω) e fase vs log(ω).",
                                    "Identifique visualmente o pico máximo na curva de magnitude.",
                                    "Extraia valor numérico preciso do pico usando max() ou interp1()."
                                  ],
                                  "verification": "Plot deve mostrar assíntotas corretas (±20 dB/dec) e pico coincide com análise analítica.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "MATLAB ou Python (control/matlab libraries)",
                                    "GNU Octave (alternativa gratuita)"
                                  ],
                                  "tips": "Use grid e zoom no plot para precisão; evite ω muito baixos/altos para numérica estável.",
                                  "learningObjective": "Gerar e interpretar diagramas de Bode para análise de normas.",
                                  "commonMistakes": [
                                    "Escala linear em ω em vez de log.",
                                    "Não converter dB para linear: ||G||_∞ = 10^(peak_dB/20)."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Validar e reportar a norma H∞",
                                  "subSteps": [
                                    "Compare valores analítico e numérico; diferença <1%.",
                                    "Confirme sup_ω |G(jω)| é o maior pico ou limite.",
                                    "Reporte ||G||_∞ com precisão (ex: 2 casas decimais).",
                                    "Discuta sensibilidade a perturbações em parâmetros.",
                                    "Salve plot e cálculos em relatório."
                                  ],
                                  "verification": "Valor reportado bate com ambos métodos e justificativa escrita.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Plots gerados",
                                    "Relatório em LaTeX ou Word"
                                  ],
                                  "tips": "Para ||G||_∞=1, cheque se G é unimodular ou normalizado.",
                                  "learningObjective": "Integrar métodos analíticos/numéricos para norma robusta.",
                                  "commonMistakes": [
                                    "Confundir norma H2 (RMS) com H∞ (pico).",
                                    "Reportar em dB em vez de linear."
                                  ]
                                }
                              ],
                              "practicalExample": "Para G(s) = 1 / (s^2 + 0.2s + 1), analiticamente ω_c ≈ 0.98 rad/s, |G(jω_c)| ≈ 2.5; Bode confirma pico em 8 dB (10^{0.4}≈2.51).",
                              "finalVerifications": [
                                "Fórmula |G(jω)| correta e plot Bode assintótico preciso.",
                                "Pico máximo identificado em ω correto (±5%).",
                                "Valor ||G||_∞ coincide entre analítico/numérico.",
                                "Relatório inclui plot, cálculos e discussão.",
                                "Limites ω→0/∞ corretos.",
                                "Sensibilidade a parâmetros avaliada."
                              ],
                              "assessmentCriteria": [
                                "Precisão do cálculo de ||G||_∞ (<1% erro).",
                                "Correção na derivação analítica ou código numérico.",
                                "Interpretação adequada do diagrama de Bode.",
                                "Relatório claro com evidências visuais.",
                                "Tratamento de casos edge (sem picos).",
                                "Eficiência computacional no código."
                              ],
                              "crossCurricularConnections": [
                                "Análise de Sinais: Transformada de Fourier e respostas frequenciais.",
                                "Programação Numérica: Otimização e plotting em MATLAB/Python.",
                                "Matemática Aplicada: Cálculo variacional e otimização.",
                                "Física: Ressonância em osciladores harmônicos."
                              ],
                              "realWorldApplication": "Em controle de drones, ||G||_∞ < γ garante atenuação de distúrbios (vento) abaixo de γ; usado em síntese H∞ para especificações de performance robusta em automação industrial."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.3.1.2",
                            "name": "Interpretar o valor γ ótimo em termos de robustez",
                            "description": "Analisar o significado físico do nível de desempenho γ em problemas H∞, relacionando-o com margens de estabilidade, rejeição de distúrbios e atenuação de ruído em sistemas escalares com incertezas aditivas ou multiplicativas.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Fundamentos da Norma H∞ e Definição de γ",
                                  "subSteps": [
                                    "Relembrar a definição da norma H∞ para sistemas lineares invariantes no tempo (LIT): supremo do ganho de pico sobre todas as frequências.",
                                    "Entender que γ representa o limite superior do ganho ||Tzw||∞ em problemas de controle H∞, onde Tzw é o operador de distúrbio w para erro z.",
                                    "Estudar a condição γ ótimo como o menor γ tal que existe um controlador estabilizante com ||Tzw||∞ < γ.",
                                    "Analisar o problema padrão H∞ para sistemas escalares: planta P com incertezas Δ.",
                                    "Derivar intuitivamente por que minimizar γ otimiza o trade-off entre desempenho e robustez."
                                  ],
                                  "verification": "Resumir em 3 frases o que é γ e sua relação com o ganho H∞; conferir com referência padrão.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Livro 'Multivariable Feedback Control' de Skogestad (cap. 10)",
                                    "Notas de aula sobre H∞",
                                    "Software MATLAB para plotar respostas em frequência"
                                  ],
                                  "tips": "Use diagramas de bloco para visualizar Tzw; foque em interpretação física antes de matemática pesada.",
                                  "learningObjective": "Compreender a definição matemática e o papel de γ como métrica de desempenho worst-case.",
                                  "commonMistakes": [
                                    "Confundir norma H∞ com norma H2 (RMS vs. pico)",
                                    "Ignorar que γ é uma cota superior, não o ganho exato"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Interpretar γ em Termos de Margens de Estabilidade e Robustez",
                                  "subSteps": [
                                    "Relacionar γ com a margem de ganho: para sistemas escalares, γ ≈ 1 / |margem de fase| em frequências críticas.",
                                    "Explicar que γ pequeno implica maior distância ao limite de instabilidade (Nyquist).",
                                    "Analisar robustez a variações paramétricas: γ ótimo garante estabilidade para |Δ| < 1/γ.",
                                    "Discutir o teorema pequeno ganho: estabilidade se ||T||∞ * ||Δ||∞ < 1.",
                                    "Plotar curvas de Bode do sistema fechado e identificar como γ afeta picos de ganho."
                                  ],
                                  "verification": "Calcular γ para um exemplo simples e verificar se γ < 1 implica robustez; plotar gráfico.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "MATLAB/Simulink para simulações H∞",
                                    "Artigo 'H∞ Control Tutorial' de Doyle",
                                    "Folha de papel para esboços de Nyquist"
                                  ],
                                  "tips": "Pense em γ como 'espaço de manobra' contra incertezas; use loops unitários para simplificar.",
                                  "learningObjective": "Associar γ quantitativamente a margens de estabilidade e estabilidade robusta.",
                                  "commonMistakes": [
                                    "Achar que γ pequeno sempre significa estabilidade (ignora controle inadequado)",
                                    "Confundir robustez de desempenho com robustez de estabilidade"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Relacionar γ com Rejeição de Distúrbios e Atenuação de Ruído",
                                  "subSteps": [
                                    "Interpretar γ como amplificação máxima de distúrbios w (ruído, cargas) no erro z.",
                                    "Para sistemas escalares, γ = sup_ω |Tzw(jω)|, significando atenuação se γ < 1.",
                                    "Analisar rejeição em banda passante vs. rejeição fora de banda.",
                                    "Simular resposta a distúrbios unitários e medir ||z||∞ / ||w||∞ ≈ γ.",
                                    "Discutir trade-offs: γ pequeno melhora rejeição mas pode degradar robustez."
                                  ],
                                  "verification": "Simular um sistema com ruído e confirmar que γ prediz o pior erro amplificado.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Simulink para modelagem de planta escalar com ruído",
                                    "Ferramenta hinfsyn do MATLAB",
                                    "Exemplos de código H∞ online"
                                  ],
                                  "tips": "Use sinais de teste como steps ou senos para visualizar atenuação prática.",
                                  "learningObjective": "Conectar γ fisicamente a supressão de perturbações no mundo real.",
                                  "commonMistakes": [
                                    "Interpretar γ como ganho DC (é worst-case em frequência)",
                                    "Esquecer normalização de w e z"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar Interpretação a Incertezas Aditivas e Multiplicativas",
                                  "subSteps": [
                                    "Modelar incertezas aditivas: Δ_add na entrada/saída, γ garante ||T Δ_add||∞ < 1.",
                                    "Para multiplicativas: Δ_mult * P, onde γ relaciona com robustez relativa.",
                                    "Comparar: aditiva afeta alto ganho, multiplicativa afeta cruzamentos.",
                                    "Resolver um problema numérico: encontrar γ ótimo para P(s) = 1/(s+1) com Δ_mult.",
                                    "Generalizar: γ ótimo quantifica tolerância a Δ para qualquer estrutura."
                                  ],
                                  "verification": "Derivar condição de robustez para ambos tipos e testar com variação de 20% em parâmetros.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "MATLAB Robust Control Toolbox",
                                    "Paper 'Robust Control of Uncertain Systems' de Zhou",
                                    "Planilha Excel para cálculos manuais"
                                  ],
                                  "tips": "Comece com escalar para intuição; normalize incertezas para ||Δ||∞=1.",
                                  "learningObjective": "Diferenciar e interpretar γ para diferentes modelos de incerteza.",
                                  "commonMistakes": [
                                    "Tratar aditiva e multiplicativa como idênticas",
                                    "Subestimar impacto em frequências específicas"
                                  ]
                                }
                              ],
                              "practicalExample": "Considere um sistema de controle de posição de um motor DC com planta P(s) = 1/(s(s+1)) e incerteza multiplicativa Δ_mult = 0.2. O γ ótimo encontrado é 1.2. Isso significa que o controlador rejeita distúrbios com amplificação máxima de 1.2 e garante estabilidade para |Δ_mult| < 1/1.2 ≈ 0.83, permitindo 20% de variação na planta sem perda de robustez. Simule ruído senoidal em 1 rad/s e observe erro <1.2 vezes o ruído.",
                              "finalVerifications": [
                                "Explicar verbalmente: 'γ=0.8 significa que distúrbios são atenuados em 20% no pior caso'.",
                                "Plotar Tzw e confirmar sup |Tzw| = γ.",
                                "Alterar parâmetros em 1/γ e verificar transição para instabilidade.",
                                "Calcular margem de estabilidade e relacionar com γ.",
                                "Discutir limitações: γ ignora desempenho nominal se não ponderado."
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição de γ e norma H∞ (20%)",
                                "Profundidade na interpretação física de robustez e rejeição (30%)",
                                "Correta distinção entre incertezas aditivas/multiplicativas (20%)",
                                "Uso de exemplos/simulações para ilustrar conceitos (15%)",
                                "Identificação de trade-offs e limitações (10%)",
                                "Clareza e estrutura na explicação (5%)"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Análise funcional e normas em espaços de Hardy",
                                "Física: Dinâmica de sistemas com perturbações estocásticas",
                                "Estatística: Interpretação probabilística de worst-case via bounds",
                                "Informática: Implementação numérica em otimizadores (LMIs)"
                              ],
                              "realWorldApplication": "Em controle de drones, γ ótimo garante que ventos turbulentos (distúrbios) sejam rejeitados com erro máximo previsível, mantendo estabilidade apesar de variações no modelo aerodinâmico (incertezas multiplicativas), permitindo voos autônomos seguros em condições reais."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.3.1.3",
                            "name": "Relacionar norma H∞ com especificações clássicas",
                            "description": "Comparar a norma H∞ com métricas clássicas como ganho DC, largura de banda e fatores de pico em malha fechada, demonstrando superioridade para robustez em presença de incertezas não modeladas.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Especificações Clássicas em Controle",
                                  "subSteps": [
                                    "Defina ganho DC como o valor em frequência zero da função de transferência em malha fechada.",
                                    "Explique largura de banda como a frequência onde a magnitude cai para -3dB.",
                                    "Descreva fatores de pico como overshoot (Mp) e ressonância em malha fechada.",
                                    "Liste especificações típicas: tempo de estabilização, erro estacionário e margens de estabilidade.",
                                    "Calcule exemplos numéricos para um sistema de segunda ordem padrão."
                                  ],
                                  "verification": "Resuma em um diagrama de Bode as specs clássicas e identifique picos e ganhos.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Livro de Ogata ou Franklin (capítulos de análise em frequência)",
                                    "MATLAB para plotar respostas em frequência"
                                  ],
                                  "tips": "Sempre relacione specs de tempo com domínio de frequência usando aproximações como BW ≈ 2.2/ ts para sistemas de segunda ordem.",
                                  "learningObjective": "Compreender e quantificar especificações clássicas de desempenho em malha fechada.",
                                  "commonMistakes": [
                                    "Confundir ganho DC com ganho em malha aberta",
                                    "Ignorar efeitos de fase nas specs de tempo",
                                    "Não normalizar unidades de frequência"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Introduzir Conceitos da Norma H∞",
                                  "subSteps": [
                                    "Defina a norma H∞ como o valor supremo dos valores singulares da função de transferência ao longo do jω.",
                                    "Interprete ||T||∞ < γ como supressão de energia máxima em qualquer frequência.",
                                    "Compare com norma H2 (RMS) destacando foco em pior-caso para H∞.",
                                    "Calcule norma H∞ para sistemas simples usando svd ou rim2hinf no MATLAB.",
                                    "Discuta interpretação geométrica: pico da curva de valores singulares."
                                  ],
                                  "verification": "Compute ||T||∞ para um filtro passa-baixa e confirme γ como altura máxima do σ-bar.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Documentação MATLAB Robust Control Toolbox",
                                    "Artigo tutorial sobre normas H∞"
                                  ],
                                  "tips": "Use logspace para varrer frequências e plotar sigma para visualização clara.",
                                  "learningObjective": "Dominar definição e cálculo da norma H∞ em sistemas LIT.",
                                  "commonMistakes": [
                                    "Confundir H∞ com máximo de |T(jω)| ao invés de σ_max",
                                    "Esquecer de considerar MIMO mesmo em SISO",
                                    "Não usar unidades consistentes em γ"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Estabelecer Comparações Diretas",
                                  "subSteps": [
                                    "Mapeie ganho DC ≈ |T(0)| ≤ ||T||∞.",
                                    "Relacione largura de banda com frequência onde σ(T) cai, mas destaque limitação clássica.",
                                    "Mostre Mp ≈ (||T||∞ -1)/2 para sistemas de segunda ordem.",
                                    "Compare estabilidade: margens clássicas vs robustez implícita em H∞.",
                                    "Derive bounds: ||T||∞ ≥ max specs clássicas em frequências relevantes."
                                  ],
                                  "verification": "Crie tabela comparativa com fórmulas e valores numéricos para um controlador PID.",
                                  "estimatedTime": "2.5 horas",
                                  "materials": [
                                    "Folha de cálculos derivados",
                                    "Simulink para modelar planta nominal"
                                  ],
                                  "tips": "Use desigualdades como ||T||∞ ≥ sup |T(jω)| para provar superioridade.",
                                  "learningObjective": "Quantificar relações matemáticas entre H∞ e métricas clássicas.",
                                  "commonMistakes": [
                                    "Ignorar que H∞ é conservadora mas global",
                                    "Achar equivalência exata onde só há bounds",
                                    "Não considerar trade-offs em baixa frequência"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Demonstrar Superioridade em Robustez",
                                  "subSteps": [
                                    "Introduza incertezas não modeladas como Δ aditiva ou multiplicativa.",
                                    "Simule desempenho clássico falhando com Δ vs H∞ estável se ||T||∞ * ||Δ||∞ <1.",
                                    "Compare curvas de σ para nominal e perturbado.",
                                    "Analise μ como extensão para robustez estruturada.",
                                    "Conclua guidelines: use H∞ quando incertezas >10% do modelo."
                                  ],
                                  "verification": "Simule loop com Δ=20% variação e mostre estabilidade só com H∞.",
                                  "estimatedTime": "3 horas",
                                  "materials": [
                                    "MATLAB Robust Control Toolbox (hinfstruct, usim)",
                                    "Exemplo de planta com incerteza (e.g., flexível)"
                                  ],
                                  "tips": "Estruture incertezas como blocos LFT para análise geral.",
                                  "learningObjective": "Aplicar comparações em cenários de robustez real.",
                                  "commonMistakes": [
                                    "Testar só nominal sem perturbações",
                                    "Usar specs clássicas sem margens robustas",
                                    "Subestimar conservadorismo de H∞"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um sistema de controle de velocidade de motor DC com variação de 15% na constante de tempo devido a temperatura, specs clássicas (BW=10Hz, Mp<20%) falham com overshoot >50%, mas controlador H∞ com ||T||∞=1.5 garante estabilidade e Mp<15% em todas as condições.",
                              "finalVerifications": [
                                "Explique verbalmente como ||T||∞ engloba ganho DC e Mp.",
                                "Compute norma H∞ e compare com specs clássicas de um sistema dado.",
                                "Identifique falha de specs clássicas em presença de incerteza Δ.",
                                "Desenhe curvas σ vs Bode mostrando superioridade H∞.",
                                "Proponha quando preferir H∞ sobre PID clássico.",
                                "Simule exemplo simples com perturbação e verifique robustez."
                              ],
                              "assessmentCriteria": [
                                "Precisão matemática nas relações derivadas (90% correto).",
                                "Capacidade de simular e interpretar plots de robustez.",
                                "Clareza na distinção de pior-caso (H∞) vs médio (clássico/H2).",
                                "Uso correto de toolbox para cálculos.",
                                "Identificação de trade-offs e limitações.",
                                "Explicação qualitativa e quantitativa integrada."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria de operadores e valores singulares.",
                                "Física: Modelagem de sistemas dinâmicos com incertezas.",
                                "Programação: Uso de MATLAB/Simulink para análise numérica.",
                                "Estatística: Análise de pior-caso vs probabilística.",
                                "Engenharia de Software: Validação de controladores em loops reais."
                              ],
                              "realWorldApplication": "No controle de flaps de aeronaves, onde variações aerodinâmicas não modeladas (turbulência) exigem robustez; H∞ garante estabilidade vs falhas de controladores clássicos em condições off-nominal."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.5.3.2",
                        "name": "Formatação do Problema Padrão H∞",
                        "description": "Configuração do plantão generalizado P e do controlador K na forma padrão para síntese H∞, incorporando pesos de desempenho Wp, robustez Wu e modelo de incertezas em sistemas monovariáveis.",
                        "specificSkills": [
                          {
                            "id": "10.1.5.3.2.1",
                            "name": "Construir o plantão generalizado P(s)",
                            "description": "Montar a estrutura em forma padrão com blocos de referência r, saída y, controle u, distúrbio w e saída de performance z, utilizando funções de transferência escalares para sistemas LIT.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Definir os sinais e variáveis do problema padrão H∞",
                                  "subSteps": [
                                    "Identifique a referência r como entrada desejada para o sistema.",
                                    "Defina a saída medida y como feedback do sensor.",
                                    "Especifique o sinal de controle u gerado pelo controlador.",
                                    "Identifique o distúrbio w atuando no sistema.",
                                    "Determine a saída de performance z que captura os erros de rastreamento e controle."
                                  ],
                                  "verification": "Lista completa de sinais r, y, u, w, z com descrições claras documentadas em um diagrama esquemático inicial.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Papel e lápis ou software de diagramação como Draw.io; referência teórica de H∞ (livro ou notas de aula).",
                                  "tips": "Use setas direcionadas para indicar fluxo de sinais no esboço inicial.",
                                  "learningObjective": "Compreender o papel de cada sinal no framework H∞ para sistemas LTI monovariáveis.",
                                  "commonMistakes": "Confundir y (saída medida) com z (saída de performance); sempre diferencie medição de especificação de performance."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Modelar a planta e os pesos de performance usando funções de transferência",
                                  "subSteps": [
                                    "Obtenha ou derive a função de transferência da planta G(s) do sistema físico.",
                                    "Inclua o sensor H(s) e atuador K(s) nas funções de transferência relevantes.",
                                    "Defina os pesos W_e(s) para erro de rastreamento, W_u(s) para esforço de controle e W_n(s) para ruído.",
                                    "Verifique que todas as funções são escalares para sistemas monovariáveis.",
                                    "Esboce blocos individuais com suas TFs."
                                  ],
                                  "verification": "Funções de transferência G(s), H(s), K(s) e pesos W(s) anotadas com numerador e denominador explícitos.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "MATLAB ou Octave para plotar polos/raízes; calculadora simbólica como SymPy.",
                                  "tips": "Padronize a forma G(s) = num(s)/den(s) para facilitar a manipulação matricial posterior.",
                                  "learningObjective": "Modelar componentes do sistema como funções de transferência escalares LTI.",
                                  "commonMistakes": "Ignorar inversibilidade de H(s) ou K(s); teste com step response para validar."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Montar o diagrama de blocos generalizado",
                                  "subSteps": [
                                    "Conecte r a um somador com y para formar erro e.",
                                    "Ligue u através do atuador K(s) à planta G(s), adicionando distúrbio w.",
                                    "Forme z combinando erro ponderado W_e*e, controle ponderado W_u*u e saída ponderada.",
                                    "Inclua ruído ou distúrbio no sensor se aplicável.",
                                    "Desenhe o laço fechado com todas as conexões."
                                  ],
                                  "verification": "Diagrama de blocos completo com 5 entradas (r, w) e 1 saída medida (y), mas z como múltiplas saídas de performance.",
                                  "estimatedTime": "40 minutos",
                                  "materials": "Software de simulação como Simulink ou papel milimetrado.",
                                  "tips": "Use convenções padrão: somadores como círculos, blocos retangulares para TFs.",
                                  "learningObjective": "Construir visualmente a estrutura P(s) integrando planta, pesos e sinais.",
                                  "commonMistakes": "Conexões erradas de w (deve entrar após atuador); valide fluxo de sinal."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Derivar a função de transferência generalizada P(s)",
                                  "subSteps": [
                                    "Particione P(s) como matriz [z; y] = P(s) [w; u], com P11, P12, P21, P22.",
                                    "Calcule P11(s) (de w para z), P12(s) (de u para z), etc., usando regras de diagrama de blocos.",
                                    "Simplifique expressões algébricas para forma padrão H∞.",
                                    "Implemente em MATLAB para tfdata(P).",
                                    "Valide estabilidade e propriedades causais."
                                  ],
                                  "verification": "Matriz P(s) 2x2 explícita com funções de transferência corretas, simulada sem erros.",
                                  "estimatedTime": "50 minutos",
                                  "materials": "MATLAB Control System Toolbox; script para sysic ou connect.",
                                  "tips": "Use função connect() no MATLAB para automação: P = connect(sys1,sys2,...,sum1,sum2).",
                                  "learningObjective": "Obter P(s) em forma matricial padrão para síntese H∞.",
                                  "commonMistakes": "Erros em P22(s) = G(s)K(s); sempre isole o caminho de u para y."
                                }
                              ],
                              "practicalExample": "Para um sistema massa-mola-amortecedor (G(s) = 1/(s^2 + s + 1)), defina r como posição desejada, w como força externa, y posição medida, u tensão no atuador, z = [W_e (r-y); W_u u]. Monte P(s) e simule step response no MATLAB.",
                              "finalVerifications": [
                                "P(s) tem entradas [w; u] e saídas [z; y] na partição correta.",
                                "Todas funções de transferência são próprias e estáveis.",
                                "Simulação no MATLAB reproduz diagrama sem discrepâncias.",
                                "Pesos W(s) afetam corretamente z (ex: alto ganho em baixas frequências para rastreamento).",
                                "Dimensões matriciais: P11 (dim z x dim w), P12 (dim z x 1), etc.",
                                "Causalidade preservada: nenhum caminho de futuro para passado."
                              ],
                              "assessmentCriteria": [
                                "Precisão das funções de transferência derivadas (erro <5% em ganho DC).",
                                "Correção do diagrama de blocos (todas conexões válidas).",
                                "Inclusão completa de pesos e sinais (r, y, u, w, z).",
                                "Validação via simulação (bode plot de P12 coincide com esperado).",
                                "Clareza na documentação (equações legíveis, comentários).",
                                "Eficiência algébrica (simplificações corretas sem cancelamentos indevidos)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Álgebra linear para manipulação matricial de sistemas LTI.",
                                "Programação: Implementação em MATLAB/Simulink para análise e síntese.",
                                "Física: Modelagem dinâmica de sistemas mecânicos/elétricos como plantas.",
                                "Estatística: Análise de robustez via normas H∞ e simulações Monte Carlo."
                              ],
                              "realWorldApplication": "Em controle de drones, P(s) modela perturbações de vento (w), comando piloto (r), giroscópio (y), motor PWM (u), com z penalizando erro de atitude e consumo de bateria, permitindo controladores H∞ robustos a variações de massa."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.5.3.1.1"
                            ]
                          },
                          {
                            "id": "10.1.5.3.2.2",
                            "name": "Selecionar pesos de desempenho e robustez",
                            "description": "Escolher funções de transferência Wp(s) para especificar erro de rastreamento e largura de banda, e Wu(s) para limite de esforço de controle e robustez, com base em requisitos do problema escalar.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os requisitos de desempenho e robustez do problema",
                                  "subSteps": [
                                    "Analise as especificações do problema escalar, identificando requisitos de erro de rastreamento (ex.: máximo 10% em regime permanente) e largura de banda desejada (ex.: 10 rad/s).",
                                    "Identifique limites de esforço de controle (ex.: amplitude máxima do sinal de controle) e margens de robustez (ex.: estabilidade frente a variações de 20% nos parâmetros).",
                                    "Revise a planta nominal G(s) e modele incertezas aditivas ou multiplicativas.",
                                    "Documente os requisitos em uma tabela comparativa entre desejado e atual.",
                                    "Discuta trade-offs entre desempenho e robustez."
                                  ],
                                  "verification": "Criar um documento com tabela de requisitos assinada por um tutor ou autoavaliação com checklist completo.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Especificações do problema",
                                    "Planta G(s)",
                                    "Folha de cálculo ou MATLAB para modelagem"
                                  ],
                                  "tips": "Priorize requisitos críticos; use gráficos de Bode iniciais para visualizar.",
                                  "learningObjective": "Identificar e quantificar requisitos de desempenho e robustez para formatação H∞.",
                                  "commonMistakes": [
                                    "Ignorar trade-offs entre desempenho e robustez",
                                    "Não quantificar requisitos numericamente",
                                    "Confundir erro de rastreamento com overshoot"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Projetar o peso de desempenho Wp(s)",
                                  "subSteps": [
                                    "Escolha a forma de Wp(s) como função de transferência de 1ª ou 2ª ordem: Wp(s) = (s/M + ω_b)/(s + ω_b A), onde M é pico de sensibilidade, ω_b largura de banda.",
                                    "Ajuste parâmetros: M para erro de rastreamento (1/M ≈ erro), ω_b para largura de banda.",
                                    "Simule |Wp(jω)| em diagrama de Bode e compare com requisitos.",
                                    "Itere ajustes até satisfazer specs de desempenho.",
                                    "Verifique sensibilidade S = 1/(1 + GK) ≈ 1/Wp em baixas frequências."
                                  ],
                                  "verification": "Gerar gráfico de Bode de |Wp| e |S| mostrando conformidade com specs.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "MATLAB/Simulink ou Python (Control library)",
                                    "Templates de pesos H∞"
                                  ],
                                  "tips": "Comece com M=2 (erro 50%), refine para specs reais; evite ω_b muito alta para evitar alto esforço.",
                                  "learningObjective": "Construir Wp(s) que imponha specs de erro e banda no problema H∞.",
                                  "commonMistakes": [
                                    "Escolher ω_b maior que crossover desejado",
                                    "Não normalizar Wp para ganho unitário em DC",
                                    "Ignorar fase em altas frequências"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Projetar o peso de robustez e esforço Wu(s)",
                                  "subSteps": [
                                    "Defina Wu(s) = w_u / (s/ω_c + 1), onde w_u limita esforço (||u|| < w_u), ω_c filtro alto-passagem.",
                                    "Estime w_u do sinal de controle open-loop ou simulações iniciais.",
                                    "Inclua robustez com peso multiplicativo Wm(s) se necessário, combinando em Wu.",
                                    "Plote |Wu(jω)| e verifique roll-off suave.",
                                    "Ajuste para balancear com Wp, simulando KS e KS/T."
                                  ],
                                  "verification": "Simulação mostrando ||Wu u||_∞ < 1 e estabilidade robusta.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Ferramentas de simulação (MATLAB hinfsyn ou robustctl)",
                                    "Dados de incertezas da planta"
                                  ],
                                  "tips": "w_u pequeno aumenta robustez mas degrada desempenho; teste com ±20% variação.",
                                  "learningObjective": "Criar Wu(s) que limite esforço e garanta robustez no loop H∞.",
                                  "commonMistakes": [
                                    "Wu constante (sem filtro alto-passagem)",
                                    "w_u muito baixo causando saturação",
                                    "Não testar com incertezas reais"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Validar e integrar os pesos no problema padrão H∞",
                                  "subSteps": [
                                    "Monte o problema generalizado P(s) com Wp, Wu, G(s) e incertezas.",
                                    "Execute síntese H∞ para obter K(s) e verifique γ < 1.",
                                    "Analise respostas: tempo, overshoot, robustez via μ-analysis se aplicável.",
                                    "Ajuste pesos iterativamente se γ >1 ou specs falharem.",
                                    "Documente justificativa final dos pesos escolhidos."
                                  ],
                                  "verification": "Relatório com γ, gráficos de step response e robustez plots aprovados.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "MATLAB Robust Control Toolbox",
                                    "Relatórios anteriores"
                                  ],
                                  "tips": "Use loop-shaping intuitivo antes de síntese; mire γ ≈ 1-2.",
                                  "learningObjective": "Integrar pesos em P(s) e validar solução H∞ completa.",
                                  "commonMistakes": [
                                    "Esquecer normalização das plantas",
                                    "Não iterar após síntese",
                                    "Ignorar condicionamento numérico"
                                  ]
                                }
                              ],
                              "practicalExample": "Para um servo motor de posição G(s) = 1/(s(s+1)), especifique erro <5% e ω_b=5 rad/s, esforço u<10V. Wp(s)=(s/5 +1)/(10(s/50 +1)), Wu(s)=10/(s/0.1 +1). Síntese dá K(s) com γ=1.2, response com settling 0.5s.",
                              "finalVerifications": [
                                "Wp(s) impõe |S|<1/erro_DC e |S| cai após ω_b.",
                                "Wu(s) garante ||u||_∞ <1 em simulação nominal.",
                                "Síntese H∞ converge com γ≤2.",
                                "Resposta em malha fechada atende specs de tempo/overshoot.",
                                "Simulação com ±20% variação em G mantém estabilidade.",
                                "Trade-offs documentados entre desempenho e robustez."
                              ],
                              "assessmentCriteria": [
                                "Precisão na escolha de parâmetros de Wp/Wu baseada em specs (80%).",
                                "Qualidade dos gráficos de Bode e simulações (90%).",
                                "Convergência e γ da síntese H∞ (<2).",
                                "Análise de robustez com incertezas (margem >6dB).",
                                "Documentação clara de iterações e justificativas.",
                                "Identificação correta de erros comuns evitados."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Análise de funções de transferência e normas H∞.",
                                "Programação: Implementação em MATLAB/Python para síntese e simulação.",
                                "Física: Modelagem dinâmica de sistemas massa-mola ou elétricos.",
                                "Estatística: Análise de incertezas e análise de sensibilidade.",
                                "Engenharia de Software: Documentação e versionamento de controladores."
                              ],
                              "realWorldApplication": "Em drones, selecionar pesos para Wp garantir rastreamento de trajetória com erro<1cm e Wu limitar torque de motores, assegurando robustez a ventos variáveis e falhas de sensores."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.5.3.1.2"
                            ]
                          },
                          {
                            "id": "10.1.5.3.2.3",
                            "name": "Incorporar modelos de incerteza na forma padrão",
                            "description": "Modelar incertezas normais ou multiplicativas Δ como blocos normalizados e integrá-las ao plantão P para garantir robustez via minimização de ||Tzw||_∞ < γ.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Identificar e Modelar Incertezas no Sistema",
                                  "subSteps": [
                                    "Analise o sistema físico e identifique fontes de incerteza, como variações paramétricas ou não-lineares.",
                                    "Classifique as incertezas como aditivas (normais) ou multiplicativas baseadas na estrutura do modelo.",
                                    "Represente matematicamente cada incerteza Δ como uma função de transferência ou bloco dinâmico.",
                                    "Defina os sinais de entrada w (exógenos) e saída z (de performance) associados às incertezas.",
                                    "Documente o modelo nominal G e as perturbações Δ."
                                  ],
                                  "verification": "Confirme que todos os modelos de incerteza estão explicitamente definidos e associados a entradas/saídas corretas no diagrama.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Diagrama do sistema, MATLAB/Simulink, notas de aula sobre modelagem de sistemas lineares.",
                                  "tips": "Comece com incertezas simples (ex: ganho variável) para validar o entendimento antes de complexas.",
                                  "learningObjective": "Compreender como mapear incertezas reais para blocos matemáticos normalizados.",
                                  "commonMistakes": "Confundir incertezas aditivas com multiplicativas; ignorar dinâmicas de alta frequência."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Normalizar os Blocos de Incerteza",
                                  "subSteps": [
                                    "Calcule a norma ∞ do bloco de incerteza Δ para garantir ||Δ||_∞ ≤ 1.",
                                    "Aplique escalonamento: Δ_norm = W_Δ * Δ * M_Δ^{-1}, onde pesos normalizam o bloco.",
                                    "Verifique a normalização simulando respostas em frequência e confirmando picos unitários.",
                                    "Integre blocos normalizados em um conjunto estruturado Δ_total.",
                                    "Teste estabilidade do conjunto Δ com o sistema nominal."
                                  ],
                                  "verification": "Simule ||Δ_norm(jω)||_∞ ≤ 1 para todas as frequências relevantes usando bode plot.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "MATLAB Control System Toolbox, função norm(inf, sys), gráficos de Bode.",
                                  "tips": "Use pesos de frequência W_Δ para capturar incertezas em bandas específicas (baixa/alta freq.).",
                                  "learningObjective": "Dominar a normalização para compatibilidade com síntese H∞.",
                                  "commonMistakes": "Escalonamento incorreto levando a ||Δ||_∞ > 1; negligenciar inversibilidade de M_Δ."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Integrar Incertezas à Planta P na Forma Padrão H∞",
                                  "subSteps": [
                                    "Construa a planta generalizada P com entradas [w; u] e saídas [z; y], incorporando Δ.",
                                    "Conecte Δ entre pontos de injeção: z_Δ → Δ → w_Δ no loop de incerteza.",
                                    "Forme o sistema interconectado Tzw = F_u(P, K) incluindo controlador K e Δ.",
                                    "Defina pesos de performance W_p, W_u para saídas z = [z_perf; z_Δ].",
                                    "Valide a estrutura da forma padrão via diagrama de blocos."
                                  ],
                                  "verification": "Gere o modelo P em MATLAB e confirme conexões com tfconnect ou feedback.",
                                  "estimatedTime": "75 minutos",
                                  "materials": "Simulink ou sysic toolbox no MATLAB, templates de forma padrão H∞.",
                                  "tips": "Mantenha a planta quadrada (dimensões compatíveis) para síntese viável.",
                                  "learningObjective": "Construir corretamente a forma padrão P para análise de robustez.",
                                  "commonMistakes": "Conexões erradas de Δ causando loops instáveis; dimensões incompatíveis em z/w."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Configurar e Verificar Robustez via Minimização ||Tzw||_∞ < γ",
                                  "subSteps": [
                                    "Defina o problema de síntese: encontrar K tal que ||F_u(P, K)||_∞ < γ com Δ estável.",
                                    "Execute simulação inicial de ||Tzw||_∞ sem K para baseline.",
                                    "Ajuste γ inicial baseado em simulações de Monte Carlo com Δ variando.",
                                    "Prepare para síntese H∞ usando hinfsyn ou mu-síntese.",
                                    "Documente o setup completo para iterações futuras."
                                  ],
                                  "verification": "Confirme γ > peak de singular values de Tzw nominal e estrutura pronta para solver.",
                                  "estimatedTime": "50 minutos",
                                  "materials": "MATLAB Robust Control Toolbox (hinfsyn), sigma plots para normas ∞.",
                                  "tips": "Comece com γ conservador (ex: 2-5) e refine iterativamente.",
                                  "learningObjective": "Garantir que a integração suporte análise/otimização de robustez H∞.",
                                  "commonMistakes": "Esquecer pesos de performance levando a controladores não práticos; γ muito baixo causando inviabilidade."
                                }
                              ],
                              "practicalExample": "Em um sistema de controle de posição de um motor DC com incerteza multiplicativa de 20% no ganho da planta (Δ_mult), normalize Δ = 0.2 * (s+1)/(s+10), integre à planta P(s) = 1/(s(s+1)), adicione pesos W_p = 1/(s+1), e verifique ||Tzw||_∞ < 1.5 após síntese.",
                              "finalVerifications": [
                                "Todos os blocos Δ estão normalizados com ||Δ||_∞ ≤ 1.",
                                "Forma padrão P tem entradas/saídas corretamente dimensionadas.",
                                "Simulação de Bode confirma normalização e conexões.",
                                "||Tzw nominal||_∞ < γ inicial viável.",
                                "Diagrama de blocos é consistente com literatura H∞.",
                                "Teste de estabilidade com Δ extremos passa."
                              ],
                              "assessmentCriteria": [
                                "Precisão na modelagem e normalização de Δ (nota 1-5).",
                                "Corretude da estrutura P e conexões (verificação visual/simulada).",
                                "Adequação de pesos e γ para robustez.",
                                "Documentação clara de steps e justificativas.",
                                "Capacidade de simular e interpretar ||Tzw||_∞.",
                                "Identificação de erros comuns evitados."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Análise de normas em espaços de Hardy (H∞).",
                                "Programação: Uso avançado de toolboxes MATLAB para sistemas lineares.",
                                "Física: Modelagem de dinâmicas reais com perturbações.",
                                "Estatística: Simulações Monte Carlo para validação de incertezas."
                              ],
                              "realWorldApplication": "Desenvolvimento de controladores robustos para drones em ventos variáveis, onde incertezas multiplicativas na aerodinâmica são modeladas e minimizadas para garantir estabilidade em missões autônomas."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.5.3.3",
                        "name": "Síntese e Verificação de Controladores H∞",
                        "description": "Algoritmos para síntese de controladores minimizando a norma H∞, incluindo equações diferenciais de Riccati para sistemas escalares, e validação de propriedades de estabilidade e desempenho.",
                        "specificSkills": [
                          {
                            "id": "10.1.5.3.3.1",
                            "name": "Sintetizar controlador via equações de Riccati",
                            "description": "Resolver as equações de Riccati algébricas X∞ e Y∞ para o plantão P escalar, construindo o controlador central K(s) = (X∞(I + Y∞X∞)^(-1) H_k ou forma similar, garantindo ||Tzw||_∞ < γ.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Formular o problema de síntese H∞ e definir dados iniciais",
                                  "subSteps": [
                                    "Identificar o plantão generalizado P(s) escalar com entradas de controle u e perturbações w, saídas z e y.",
                                    "Especificar o nível de performance γ > 0 e representar P em termos de matrizes A, B1, B2, C1, C2, D11, D12, D21, D22.",
                                    "Verificar assumições padrão: D12 e D21 com propriedades ortogonais, D11=0 para simplificação.",
                                    "Implementar o plantão em software como MATLAB usando função hinfsyn ou manualmente.",
                                    "Linearizar o sistema se necessário e escalonar entradas/saídas."
                                  ],
                                  "verification": "Confirme que as matrizes de P estão corretamente definidas e que o diagrama de blocos H∞ está desenhado.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "MATLAB ou Python com Control Systems Library",
                                    "Papel e lápis para diagramas",
                                    "Referência: Doyle et al. 'State-space solutions to standard H2 and H∞ control problems'"
                                  ],
                                  "tips": "Sempre normalize γ inicialmente alto e reduza iterativamente para convergência.",
                                  "learningObjective": "Entender a estrutura do problema H∞ padrão e preparar dados para Riccati.",
                                  "commonMistakes": [
                                    "Ignorar ortogonalidade de D12/D21",
                                    "Não escalonar matrizes",
                                    "Confundir entradas w/u com y/z"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Resolver a equação de Riccati algébrica para X∞",
                                  "subSteps": [
                                    "Escrever a equação X∞ = A'X∞ + X∞A + C1'C1 - (X∞B1 + A'B2)(D12'D12)^{-1}(B1'X∞ + B2'A) < 0.",
                                    "Usar solver numérico como care() no MATLAB para resolver ARE (Algebraic Riccati Equation).",
                                    "Verificar se X∞ é estabilizante (A + B2 F com autovalores no semiplano esquerdo) e positivo definida.",
                                    "Analisar o espectro de autovalores para estabilidade.",
                                    "Ajustar γ se não convergir."
                                  ],
                                  "verification": "X∞ > 0 e espectro de A + B2 (D12'D12)^{-1} D12'C1 está estável.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "MATLAB Control Toolbox (care)",
                                    "Documentação de hinfsyn",
                                    "Calculadora matricial"
                                  ],
                                  "tips": "Use opção 'iter' no care para monitorar convergência; comece com X0=0.",
                                  "learningObjective": "Dominar resolução numérica de ARE e interpretação de soluções estabilizantes.",
                                  "commonMistakes": [
                                    "Não verificar X∞ > 0",
                                    "Escolha errada de γ levando a não-convergência",
                                    "Erro em transposições de matrizes"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Resolver a equação de Riccati algébrica para Y∞",
                                  "subSteps": [
                                    "Definir o hamiltoniano filtrante com Ã = A - B2 (D12'D12)^{-1} D12'C1, etc.",
                                    "Escrever Y∞ = Ã Y∞ + Y∞ Ã' + B1 B1' - Y∞ C2' (D21 D21')^{-1} C2 Y∞ < 0.",
                                    "Resolver com care no sistema dual.",
                                    "Verificar Y∞ > 0 e condição espectral para o observer gain.",
                                    "Checar se I - Y∞ X∞ > 0 (condição de acoplamento)."
                                  ],
                                  "verification": "Y∞ > 0, estabilizante e I - X∞ Y∞ > 0.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "MATLAB (care para sistema dual)",
                                    "Notas de aula sobre dualidade em controle"
                                  ],
                                  "tips": "Dualize o sistema de X∞ para Y∞ trocando papéis de (B,C) com (C',B').",
                                  "learningObjective": "Compreender dualidade em Riccati e condições de acoplamento para central controller.",
                                  "commonMistakes": [
                                    "Confundir sistema primal/dual",
                                    "Ignorar I - X∞ Y∞ > 0",
                                    "Não checar estabilidade do filtro"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Construir o controlador central K(s)",
                                  "subSteps": [
                                    "Calcular F = -(D12'D12)^{-1} (B1' X∞ + D12' C1) e L = -(D21 D21')^{-1} (B1 Y∞ + D21 C2).",
                                    "Definir A_K = A + B1 L + B2 F - Z F onde Z = (I - Y∞ X∞)^{-1} Y∞ C2.",
                                    "Montar K(s) = [A_K, Z; -F, I] ou forma similar: K(s) = C_K (sI - A_K)^{-1} B_K + D_K.",
                                    "Implementar em tf ou ss no MATLAB.",
                                    "Simplificar se possível."
                                  ],
                                  "verification": "K(s) é próprio e estável internamente.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "MATLAB ss() para state-space",
                                    "Ferramenta de simplificação minreal()"
                                  ],
                                  "tips": "Use variáveis simbólicas para derivar antes de numérico.",
                                  "learningObjective": "Sintetizar K∞ central a partir de soluções Riccati.",
                                  "commonMistakes": [
                                    "Erro no sinal de F ou L",
                                    "Esquecer Z no A_K",
                                    "Não inverter (I + Y∞ X∞) corretamente"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Verificar a norma H∞ do sistema fechado",
                                  "subSteps": [
                                    "Conectar Tzw = Fl(P, K) usando feedback ou connect no MATLAB.",
                                    "Computar norma H∞ com hinfnorm(Tzw, ω) ou sigma(Tzw(jω)).",
                                    "Confirmar ||Tzw||∞ < γ plotando singular values.",
                                    "Analisar step response e robustez a perturbações.",
                                    "Iterar γ se necessário."
                                  ],
                                  "verification": "hinfnorm(Tzw) < γ e plots mostram atenuação.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "MATLAB Robust Control Toolbox (hinfnorm, sigma)",
                                    "Grid de frequências ω"
                                  ],
                                  "tips": "Plote bode e singular values para insight qualitativo.",
                                  "learningObjective": "Validar performance H∞ e interpretar resultados.",
                                  "commonMistakes": [
                                    "Conexão errada de feedback",
                                    "Não checar DC gain",
                                    "Ignorar picos em altas frequências"
                                  ]
                                }
                              ],
                              "practicalExample": "Para P(s) = [1/s; 1] / [s+1, 1] (simplificado massa-mola com perturbação), γ=2, resolva Riccati obtendo X∞≈0.5, Y∞≈1.2, construa K(s)≈ -1.5/(s+2), verifique ||Tzw||∞=1.8<2 via sigma plot.",
                              "finalVerifications": [
                                "X∞ e Y∞ resolvidas com X∞>0, Y∞>0, I-X∞Y∞>0.",
                                "K(s) internamente estável.",
                                "||Tzw||∞ < γ confirmado numericamente.",
                                "Autovalores de A_cl no semiplano esquerdo.",
                                "Simulação step mostra rejeição de perturbações.",
                                "Nenhum NaN ou Inf em cálculos."
                              ],
                              "assessmentCriteria": [
                                "Correção das equações Riccati (20%)",
                                "Validade das soluções X∞, Y∞ (25%)",
                                "Construção precisa de K(s) (20%)",
                                "Verificação H∞ rigorosa (20%)",
                                "Clareza em plots e explicações (10%)",
                                "Eficiência computacional (5%)"
                              ],
                              "crossCurricularConnections": [
                                "Álgebra Linear: Resolução de ARE e autovalores.",
                                "Otimização Numérica: Solvers iterativos para Riccati.",
                                "Programação: Implementação em MATLAB/Python.",
                                "Física: Modelagem dinâmica de sistemas.",
                                "Estatística: Análise de robustez a incertezas."
                              ],
                              "realWorldApplication": "Síntese de controladores robustos para drones em ventos variáveis, garantindo estabilidade apesar de modelo impreciso, ou estabilização de satélites com perturbações orbitais."
                            },
                            "estimatedTime": "3 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.5.3.2.1",
                              "10.1.5.3.2.2"
                            ]
                          },
                          {
                            "id": "10.1.5.3.3.2",
                            "name": "Implementar síntese H∞ com MATLAB",
                            "description": "Utilizar funções como hinfsyn() do Robust Control Toolbox para sintetizar controladores H∞ em sistemas escalares, ajustando opções de tolerância e γ inicial.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Configurar o ambiente MATLAB e preparar o modelo do sistema",
                                  "subSteps": [
                                    "Instale e carregue o Robust Control Toolbox no MATLAB.",
                                    "Defina o modelo da planta G(s) como um sistema SISO linear (ex: tf ou ss).",
                                    "Especifique pesos de desempenho Wp(s), robustez Wu(s) e referência Wr(s).",
                                    "Crie o diagrama de blocos para o problema padrão H∞.",
                                    "Verifique a estabilidade e propriedades do modelo com funções como pole() e bode()."
                                  ],
                                  "verification": "Execute comandos para plotar respostas em frequência e confirme ausência de erros de toolbox.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "MATLAB com Robust Control Toolbox",
                                    "Documentação hinfsyn no MathWorks",
                                    "Modelo exemplo em .m file"
                                  ],
                                  "tips": "Use sysic para interconexões iniciais; teste modelos simples primeiro.",
                                  "learningObjective": "Configurar corretamente o ambiente e modelo para síntese H∞.",
                                  "commonMistakes": [
                                    "Esquecer de instalar toolbox",
                                    "Modelos instáveis ou mal condicionados",
                                    "Pesos inadequados sem justificativa"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Construir a planta generalizada P para síntese H∞",
                                  "subSteps": [
                                    "Monte a planta P com entradas [w; u; y; z] e saídas [z; y] usando sysic ou connect.",
                                    "Inclua pesos Wp para rastreamento, Wu para esforço de controle e sensor noise.",
                                    "Ajuste estruturas para minimizar γ inicial (ex: gamma inicial ~1-10).",
                                    "Valide P com size(P) e plot de singular values (sigma(P)).",
                                    "Defina opções de tolerância: opt = hinfstruct('Display','on', 'TolGam',1e-3)."
                                  ],
                                  "verification": "Confirme dimensões corretas de P (ny x nu para controlador) e singular values decrescentes.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Funções sysic, connect, sigma",
                                    "Exemplos de plantas H∞ da documentação MATLAB"
                                  ],
                                  "tips": "Padronize Wr=1 para simplicidade em SISO; normalize plantas para ganho 1.",
                                  "learningObjective": "Criar uma planta generalizada P válida para hinfsyn().",
                                  "commonMistakes": [
                                    "Dimensões erradas em P",
                                    "Pesos sem crossover frequencies adequados",
                                    "Não normalizar sinais"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Executar a síntese do controlador com hinfsyn()",
                                  "subSteps": [
                                    "[K,gamma] = hinfsyn(P,ny,nu,opt); onde ny/nu são saídas/entradas de controle.",
                                    "Ajuste γ inicial se gamma>1: use bisection manual ou iterar opt.Gamma.",
                                    "Analise info = hinfstruct(K) para detalhes de síntese.",
                                    "Converta K para tf/ss se necessário e verifique ordem.",
                                    "Salve K e gamma em workspace para próximos passos."
                                  ],
                                  "verification": "gamma <1 ou próximo, sem warnings de não-convergência, K estabiliza loop fechado.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Função hinfsyn()",
                                    "hinfstruct para opções avançadas"
                                  ],
                                  "tips": "Comece com γ alto e reduza; use 'Robust' para trade-offs.",
                                  "learningObjective": "Sintetizar controlador H∞ otimizado com ajustes de tolerância.",
                                  "commonMistakes": [
                                    "ny/nu trocados",
                                    "γ inicial muito baixo causando falha",
                                    "Ignorar warnings de rank deficiency"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificar e analisar o controlador sintetizado",
                                  "subSteps": [
                                    "Feche o loop: T = feedback(P*K,1); compute normas H∞ com hinfnorm(T).",
                                    "Plote Bode de sensibilidade S, complementar T, effort KS.",
                                    "Simule step/response com lsim() ou step() para validação temporal.",
                                    "Tune pesos se γ alto ou desempenho ruim, re-sintetize.",
                                    "Compare com LQG ou PID para benchmark."
                                  ],
                                  "verification": "||T||∞ < gamma, margens de estabilidade >6dB, overshoot <20%.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "feedback, hinfnorm, bode, step",
                                    "Simulink para simulações não-lineares opcionais"
                                  ],
                                  "tips": "Use grid() em plots; exporte para report com publish().",
                                  "learningObjective": "Validar robustez e desempenho do controlador H∞.",
                                  "commonMistakes": [
                                    "Analisar loop aberto em vez de fechado",
                                    "Ignorar picos em altas frequências",
                                    "Não checar simulações temporais"
                                  ]
                                }
                              ],
                              "practicalExample": "Para um sistema de posição de braço robótico (G(s) = 1/(s^2 + 0.1s)), defina Wp=0.1/(s/10+1), Wu=0.1, sintetize K com hinfsyn para γ<1.2, verificando rastreamento rápido com rejeição de distúrbios.",
                              "finalVerifications": [
                                "hinfsyn() converge com γ otimizado <1.5",
                                "Controlador K estabiliza planta com margens de fase/ganho adequadas",
                                "Norma H∞ da closed-loop < gamma reportado",
                                "Simulações mostram bom rastreamento e robustez a ±20% variação de parâmetros",
                                "Código MATLAB reproduzível sem erros",
                                "Plots de Bode/Singular values confirmam especificações de pesos"
                              ],
                              "assessmentCriteria": [
                                "Correta construção de P com dimensões e pesos apropriados (30%)",
                                "Sucesso na síntese com γ baixo e sem falhas (25%)",
                                "Análises completas: frequência, tempo e robustez (20%)",
                                "Ajustes de opções/tolerâncias demonstrados (15%)",
                                "Código limpo, comentado e documentado (10%)"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Otimização convexa e funções de transferência",
                                "Programação: Scripting avançado em MATLAB e análise numérica",
                                "Física: Dinâmica linear e controle de sistemas mecânicos/elétricos",
                                "Engenharia de Software: Validação e testes unitários de modelos",
                                "Estatística: Análise de incertezas e worst-case performance"
                              ],
                              "realWorldApplication": "Em controle de flight de aeronaves (ex: F-16), síntese H∞ garante estabilidade robusta contra variações aerodinâmicas e atuadores falhos, usada pela NASA e indústrias aeroespaciais."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.5.3.2.3"
                            ]
                          },
                          {
                            "id": "10.1.5.3.3.3",
                            "name": "Verificar robustez e desempenho do controlador",
                            "description": "Analisar singular values, diagramas de Bode e simulações em malha fechada para validar γ ótimo, estabilidade robusta e satisfação de especificações em presença de incertezas escalares.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Calcular e analisar valores singulares para validar γ ótimo",
                                  "subSteps": [
                                    "Importe o modelo do sistema generalizado P e o controlador K no MATLAB usando Robust Control Toolbox.",
                                    "Compute a função γ usando a função hinfsyn ou uss para obter o valor ótimo γ.",
                                    "Plote os valores singulares máximos σ_max da função H∞ ao longo das frequências.",
                                    "Verifique se γ < limite desejado (ex: 1.2) e identifique frequências críticas.",
                                    "Documente o valor de γ e compare com especificações iniciais."
                                  ],
                                  "verification": "γ está abaixo do limite especificado e gráfico de σ_max mostra platô baixo em baixas frequências.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "MATLAB com Robust Control Toolbox",
                                    "Modelo P (uncertainty-weighted plant)",
                                    "Script .m para análise H∞"
                                  ],
                                  "tips": "Use sigma(P) para plotar singular values; foque em σ_max(P11) para performance e σ_max(P12) para robustez.",
                                  "learningObjective": "Compreender como valores singulares quantificam o trade-off entre desempenho e robustez em síntese H∞.",
                                  "commonMistakes": [
                                    "Confundir γ com o valor singular máximo em DC",
                                    "Não normalizar pesos de performance adequadamente",
                                    "Ignorar o impacto de escalas de frequência"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Gerar e interpretar diagramas de Bode para estabilidade e desempenho nominal",
                                  "subSteps": [
                                    "Forme o sistema em malha aberta L = P11 + P12*K*P21.",
                                    "Gere diagramas de Bode para magnitude e fase de L(s), sensibilidade S e complementar T.",
                                    "Analise margens de ganho (GM) e fase (PM), crossover frequencies e picos de ressonância.",
                                    "Verifique roll-off em altas frequências e atenuação em baixas para ruído e perturbações.",
                                    "Compare com especificações: GM > 6dB, PM > 45°, ||S||∞ < 1/γ."
                                  ],
                                  "verification": "Diagramas mostram GM > 6dB, PM > 45° e ausência de picos excessivos (>3dB).",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "MATLAB Bode plots (bode()), Robust Control Toolbox",
                                    "Sistema L(s) do Step 1"
                                  ],
                                  "tips": "Use bodeoptions para grids log e zoom em frequências de interesse; superponha S, KS, T.",
                                  "learningObjective": "Interpretar diagramas de Bode para validar estabilidade e bandwidth do loop.",
                                  "commonMistakes": [
                                    "Interpretar magnitude errada como linear ao invés de dB",
                                    "Ignorar fase wrap-around",
                                    "Confundir S com T em trade-offs"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Realizar simulações em malha fechada para desempenho nominal",
                                  "subSteps": [
                                    "Forme o sistema fechado G = feedback(P*K,1) no Simulink ou LTI.",
                                    "Simule respostas a referências unitárias, steps de perturbação e ruído.",
                                    "Meça overshoot (<20%), tempo de estabilização (<5s), erro steady-state (<1%).",
                                    "Plote respostas no tempo e compare com métricas H∞ (||T||∞, ||S||∞).",
                                    "Gere relatórios com métricas quantitativas."
                                  ],
                                  "verification": "Simulações mostram overshoot <20%, settling time <5s e tracking sem bias.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Simulink ou step/response funções MATLAB",
                                    "Modelo P nominal",
                                    "Scripts de simulação .m"
                                  ],
                                  "tips": "Use lsim para entradas personalizadas; adicione scopes para múltiplas saídas.",
                                  "learningObjective": "Conectar análise em frequência com desempenho temporal em malha fechada.",
                                  "commonMistakes": [
                                    "Simular apenas nominal sem escalas realistas",
                                    "Não incluir delays ou saturações",
                                    "Medir settling time visualmente ao invés de quantitativamente"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar robustez com incertezas escalares",
                                  "subSteps": [
                                    "Defina incertezas escalares Δ (ex: Δ_p para plant, Δ_a para atuador) como blocos reais ou complexos.",
                                    "Forme o sistema μ: use mussv ou mu para calcular μ_upper/lower bounds.",
                                    "Verifique estabilidade robusta: μ <1 para todas frequências.",
                                    "Teste desempenho robusto com loops μ para Tzw sob Δ.",
                                    "Simule Monte Carlo com variações paramétricas (±20% em parâmetros)."
                                  ],
                                  "verification": "μ_max <1 e simulações robustas mantêm specs dentro de 10% de degradação.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "MATLAB Mu-Analysis Toolbox",
                                    "Modelos com blocos de incerteza (ureal, ultidyn)"
                                  ],
                                  "tips": "Use musyn para bounds D-K; plote μ vs ω em loglog.",
                                  "learningObjective": "Avaliar estabilidade e desempenho sob incertezas estruturadas via síntese μ.",
                                  "commonMistakes": [
                                    "Usar apenas análise worst-case sem bounds",
                                    "Definir Δ como não-normalizadas",
                                    "Ignorar incertezas em múltiplos canais"
                                  ]
                                }
                              ],
                              "practicalExample": "Para um controlador H∞ de um drone quadrotor estabilizando altitude, com P incluindo pesos Wp para tracking e Wu para controle effort: compute γ=1.1, Bode mostra PM=60°, simulações com step referência sob vento (perturbação), e robustez a ±15% variação de massa via μ<0.9.",
                              "finalVerifications": [
                                "γ ótimo < limite especificado (ex: 1.5)",
                                "Margens de estabilidade GM>6dB, PM>45° em Bode plots",
                                "Respostas em malha fechada atendem overshoot<20%, settling<5s",
                                "μ bounds <1 para estabilidade robusta",
                                "Desempenho sob incertezas mantém specs dentro de 10%",
                                "Relatório documenta todas métricas com plots"
                              ],
                              "assessmentCriteria": [
                                "Precisão na computação de γ e interpretação de singular values (correta se γ<1.5)",
                                "Análise qualitativa/quantitativa correta de Bode (margens identificadas)",
                                "Simulações reproduzíveis com métricas exatas",
                                "Uso apropriado de ferramentas μ para robustez",
                                "Conexão clara entre análises e specs iniciais",
                                "Ausência de erros comuns em plots e interpretações"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Decomposição em valores singulares (SVD) e análise matricial",
                                "Programação: Scripts MATLAB avançados e toolbox-specific functions",
                                "Física: Dinâmica de sistemas lineares e efeitos de perturbações",
                                "Estatística: Análise de Monte Carlo para variabilidade",
                                "Engenharia de Software: Documentação de resultados e versionamento de modelos"
                              ],
                              "realWorldApplication": "Em controle de aeronaves autônomas, verifica se o controlador H∞ mantém estabilidade e precisão de trajetória apesar de variações em aerodinâmica ou falhas parciais de atuadores, evitando crashes em missões reais."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.5.3.3.1"
                            ]
                          },
                          {
                            "id": "10.1.5.3.3.4",
                            "name": "Aplicar parametrização de Youla para ajustes",
                            "description": "Usar a parametrização Q(s) estável para gerar família de controladores H∞ otimizados, ajustando trade-offs entre desempenho e robustez em sistemas monovariáveis.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Controlador Nominal e Planta do Sistema",
                                  "subSteps": [
                                    "Identifique a planta G(s) monovariável e o controlador nominal K(s) estabilizador.",
                                    "Calcule os fatores de Bezout: encontre X(s) e Y(s) tais que X(s)G(s) - Y(s)N(s) = 1, onde N(s)/D(s) é a decomposição de coprimos de G(s).",
                                    "Verifique estabilidade do par (G(s), K(s)) usando critérios como Nyquist ou Routh-Hurwitz.",
                                    "Defina as especificações H∞ iniciais: γ nominal para ||Tzw||∞.",
                                    "Documente trade-offs atuais: desempenho (riso, settling time) vs. robustez (margens de ganho/fase)."
                                  ],
                                  "verification": "Confirme que o laço fechado é estável e γ < 1 via simulação em MATLAB/Simulink.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "MATLAB com Robust Control Toolbox",
                                    "Diagrama de blocos da planta",
                                    "Funções coprime_factorization() e feedback()"
                                  ],
                                  "tips": "Use normalize() para fatorar G(s) em N/D com ||N||∞ = ||D||∞ = 1, facilitando normalização.",
                                  "learningObjective": "Compreender a base para parametrização: controlador nominal estável gera família estável.",
                                  "commonMistakes": [
                                    "Ignorar normalização de coprimos, levando a Q(s) instáveis",
                                    "Não verificar estabilidade nominal antes de parametrizar"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar Parametrização de Youla",
                                  "subSteps": [
                                    "Expresse K(s) na forma de Youla: K(s) = (X(s) + D(s)Q(s)) / (Y(s) - N(s)Q(s)), onde Q(s) é estável.",
                                    "Gere a família de controladores para Q(s) = 0 (nominal) e teste estabilidade.",
                                    "Implemente em software: use youla() ou funções equivalentes no Robust Control Toolbox.",
                                    "Escolha Q(s) inicial como filtro low-pass (ex: 1/(τs+1)) para manter alto ganho em baixas frequências.",
                                    "Simule o laço fechado T(s) = [I + G(s)K(s)]^{-1} para diferentes Q(s)."
                                  ],
                                  "verification": "Todos os K_q(s) gerados mantêm estabilidade para ||Q||∞ pequeno (ex: <0.5).",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "MATLAB script com coprime factors",
                                    "Função youla(K, G)",
                                    "Bode plots para análise"
                                  ],
                                  "tips": "Comece com Q(s)=0 para validar; incremente ||Q|| gradualmente para evitar instabilidade.",
                                  "learningObjective": "Dominar a fórmula de Youla para gerar controladores estáveis parametrizados.",
                                  "commonMistakes": [
                                    "Usar Q(s) não estável ou com ||Q||∞ >1, desestabilizando o sistema",
                                    "Confundir ordem de N/D em G(s)"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Otimizar Q(s) para Trade-offs H∞",
                                  "subSteps": [
                                    "Defina o problema H∞: minimize γ sujeito a ||Tzw(Q)||∞ < γ com peso Wp(s) para desempenho e Wu(s) para robustez.",
                                    "Use otimização: hinfsyn() ou loop com musyn() para ajustar Q(s) via iterações.",
                                    "Ajuste parâmetros: aumente ordem de Q(s) para mais flexibilidade (ex: Q2(s) = ωc^2 / (s^2 + 2ζωc s + ωc^2)).",
                                    "Avalie trade-offs: plote γ vs. robustez (||S||∞) e desempenho (||T||∞ em banda de crossover).",
                                    "Itere: reduza γ otimizando Q(s) com restrições em margens de robustez."
                                  ],
                                  "verification": "γ final < γ_nominal em pelo menos 10%, com margens de fase >45° mantidas.",
                                  "estimatedTime": "2.5 horas",
                                  "materials": [
                                    "Robust Control Toolbox: hinfsyn(), sigma() para plots H∞",
                                    "Pesos Wp/Wu pré-definidos"
                                  ],
                                  "tips": "Use grid search inicial em parâmetros de Q(s) antes de otimização não-linear.",
                                  "learningObjective": "Ajustar Q(s) para equilibrar desempenho (rápido tracking) e robustez (contra perturbações).",
                                  "commonMistakes": [
                                    "Sobrepasar ||Q||∞=1, perdendo estabilidade",
                                    "Ignorar picos em altas frequências no Tzw"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificar e Validar Controlador Otimizado",
                                  "subSteps": [
                                    "Simule respostas temporais: step(), lsim() para referências e distúrbios.",
                                    "Analise robustez: adicione incertezas Δ em G(s) e verifique estabilidade com μ-analysis.",
                                    "Compare com nominal: tabelas de γ, overshoot, settling time.",
                                    "Teste sensibilidade: varie parâmetros da planta em ±20% e meça desempenho.",
                                    "Documente Q(s) final e K(s) ajustado para relatório."
                                  ],
                                  "verification": "Sistema robusto: desempenho dentro de specs para 3 cenários de incerteza.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Simulink model da planta",
                                    "Funções robuststab(), usim()"
                                  ],
                                  "tips": "Sempre plote Nichols/Bode do loop aberto para margens visuais.",
                                  "learningObjective": "Validar que ajustes via Youla melhoram trade-offs sem comprometer estabilidade.",
                                  "commonMistakes": [
                                    "Não testar com incertezas reais, superestimando robustez",
                                    "Esquecer normalização em simulações"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Documentar e Iterar Ajustes Finais",
                                  "subSteps": [
                                    "Compile relatório: fórmulas, plots de Bode/Sigma, tabelas de performance.",
                                    "Identifique trade-offs residuais e sugira Q(s) alternativos (ex: notch filter).",
                                    "Realize sensibilidade final: ∂γ/∂p para parâmetros críticos.",
                                    "Salve modelo parametrizado para reutilização em μ-síntese.",
                                    "Discuta limitações: monovariável vs. multivariável."
                                  ],
                                  "verification": "Relatório completo com pelo menos 5 plots e 3 métricas quantificadas.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "LaTeX/MATLAB publish para relatório",
                                    "Git para versionamento"
                                  ],
                                  "tips": "Use figure() com legend para comparações claras nominal vs. otimizado.",
                                  "learningObjective": "Sintetizar conhecimentos em documentação acionável para engenharia.",
                                  "commonMistakes": [
                                    "Focar só em γ, ignorando tempo de settling prático",
                                    "Não versionar iterações de Q(s)"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um sistema de posicionamento de motor DC (G(s) = 1/(s(s+1))), com controlador nominal PID, use Youla para ajustar Q(s) low-pass, reduzindo γ de 1.2 para 0.9, melhorando tracking de rampa em 20% enquanto mantém robustez a variações de inércia em ±15%. Simule em MATLAB: planta com ruído, valide step response.",
                              "finalVerifications": [
                                "Laço fechado estável para Q(s) otimizado (polos no semiplano esquerdo).",
                                "||Tzw||∞ < γ alvo com redução >10% vs. nominal.",
                                "Margens de ganho >6dB e fase >45° no crossover.",
                                "Resposta temporal: overshoot <20%, settling <3s para step unitário.",
                                "Robustez: estável para Δ = 0.2 G(s) aditiva.",
                                "Q(s) Hurwitz e ||Q||∞ <1."
                              ],
                              "assessmentCriteria": [
                                "Precisão na parametrização de Youla (fórmula correta implementada).",
                                "Eficácia da otimização: γ reduzida com trade-offs quantificados.",
                                "Qualidade das simulações: plots completos com análises.",
                                "Correção de verificações: estabilidade e robustez comprovadas.",
                                "Documentação: clara, com objetivos e lições aprendidas.",
                                "Criatividade em Q(s): pelo menos 2 iterações testadas."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Álgebra de Frações Coprímicas e Teoria de Youla-Kucera.",
                                "Programação: Implementação numérica em MATLAB (SISO Tools).",
                                "Física: Modelagem dinâmica de sistemas mecânicos/elétricos.",
                                "Otimização: Algoritmos H∞ como LMI ou gradient descent.",
                                "Engenharia de Software: Versionamento e relatórios automatizados."
                              ],
                              "realWorldApplication": "Na indústria aeroespacial, ajusta controladores de flaps em aeronaves para equilibrar resposta rápida a comandos com robustez a variações aerodinâmicas; na automotiva, otimiza suspensão ativa reduzindo vibrações em 15% sem sacrificar estabilidade em curvas."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.5.3.1.3"
                            ]
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.5.4",
                    "name": "μ-Síntese",
                    "description": "Método iterativo D-K para síntese de controladores robustos considerando incertezas estruturadas via valor singular μ.",
                    "individualConcepts": [
                      {
                        "id": "76.4.4.1",
                        "name": "Valor Singular Estruturado μ",
                        "description": "O valor singular estruturado μ é uma medida de robustez para sistemas com incertezas estruturadas, definida como o inverso do menor norma de uma matriz de incerteza Δ que destrói a estabilidade ou desempenho do sistema fechado.",
                        "specificSkills": [
                          {
                            "id": "76.4.4.1.1",
                            "name": "Calcular o valor μ inferior e superior",
                            "description": "Aplicar algoritmos computacionais para estimar o valor μ inferior via decomposição SVD e o superior via escalonamento D, utilizando ferramentas como MATLAB para matrizes complexas com estrutura de incertezas especificada.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Fundamentos Teóricos de μ Inferior e Superior",
                                  "subSteps": [
                                    "Estude a definição de valor singular estruturado μ para matrizes com estrutura de incertezas especificada.",
                                    "Revise a relação entre μ e o raio de robustez em síntese H∞/μ.",
                                    "Entenda μ inferior como lower bound via maximização de valores singulares após scalings admissíveis.",
                                    "Aprenda μ superior como upper bound via métodos de escalonamento diagonal (D-scale).",
                                    "Analise exemplos teóricos de matrizes complexas com blocos de incerteza normais e hiperbólicos."
                                  ],
                                  "verification": "Resuma em um parágrafo as diferenças entre μ inferior e superior, citando fórmulas chave.",
                                  "estimatedTime": "1.5 hours",
                                  "materials": [
                                    "Livro 'Multivariable Feedback Control' de Skogestad",
                                    "Documentação MATLAB Mu-Analysis Toolbox",
                                    "Notas de aula sobre μ-Síntese"
                                  ],
                                  "tips": "Use diagramas de blocos para visualizar a estrutura de incertezas Δ.",
                                  "learningObjective": "Compreender conceitualmente os bounds de μ e sua importância em análise de robustez.",
                                  "commonMistakes": [
                                    "Confundir μ com σ (valor singular padrão)",
                                    "Ignorar a estrutura específica das incertezas"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Preparar Matriz de Incertezas e Sistema Nominal",
                                  "subSteps": [
                                    "Defina a estrutura de incertezas: blocos normais (Δ_n) e hiperbólicos (Δ_μ) com dimensões especificadas.",
                                    "Construa a matriz complexa M(jω) do sistema interconectado no MATLAB usando ss ou tf models.",
                                    "Implemente a lista de blocos L (estrutura) com comandos como muspec.",
                                    "Gere uma matriz de exemplo com ruído e incertezas paramétricas realistas.",
                                    "Valide a dimensionalidade: compatibilidade entre M e Δ."
                                  ],
                                  "verification": "Execute código MATLAB e confirme que muspec(M, L) retorna estrutura válida sem erros.",
                                  "estimatedTime": "2 hours",
                                  "materials": [
                                    "MATLAB com Robust Control Toolbox",
                                    "Mu-Tools ou sys robust toolbox",
                                    "Script template para μ-calc"
                                  ],
                                  "tips": "Comece com frequências discretas ω para evitar computação intensiva.",
                                  "learningObjective": "Preparar dados de entrada corretos para algoritmos de μ.",
                                  "commonMistakes": [
                                    "Dimensões incompatíveis entre M e L",
                                    "Esquecer phase em matrizes complexas"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular μ Inferior via Decomposição SVD",
                                  "subSteps": [
                                    "Implemente scalings admissíveis D e J para estrutura L usando otimização (e.g., loop over scalings).",
                                    "Aplique SVD em D*M*conj(D) para cada scaling: [U,S,V] = svd(D*M*conj(D)).",
                                    "Extraia lower bound como max(σ_max / scalefactor) sobre scalings.",
                                    "Use função built-in como musv(M, L, 'lower') no MATLAB.",
                                    "Plote μ_lower vs. frequência para inspeção visual."
                                  ],
                                  "verification": "Compare resultado com valor singular padrão σ(M); μ_lower ≤ σ(M).",
                                  "estimatedTime": "2.5 hours",
                                  "materials": [
                                    "MATLAB script para SVD loop",
                                    "Função musv.m",
                                    "Gráficos freqresp"
                                  ],
                                  "tips": "Limite número de scalings iniciais para protótipo rápido (e.g., 10-20).",
                                  "learningObjective": "Dominar algoritmo SVD-based para lower bound de μ estruturado.",
                                  "commonMistakes": [
                                    "Não normalizar scalings corretamente",
                                    "Usar SVD em M sem scaling"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Calcular μ Superior via Escalonamento D e Validação",
                                  "subSteps": [
                                    "Implemente escalonamento diagonal iterativo: otimize D para minimizar ||D*M*inv(D)||_2.",
                                    "Use power iteration ou gradient descent para upper bound: μ_upper = 1 / min_λ (onde λ é eigenvalue).",
                                    "Aplique função musv(M, L, 'upper') ou mu upper bound algorithms.",
                                    "Compare μ_lower e μ_upper; gap deve ser pequeno para convergência.",
                                    "Valide com simulações de Monte Carlo em incertezas aleatórias."
                                  ],
                                  "verification": "Confirme μ_lower ≤ μ_upper e gap < 10% em frequências críticas.",
                                  "estimatedTime": "2 hours",
                                  "materials": [
                                    "MATLAB Optimization Toolbox",
                                    "Custom mu_upper.m function",
                                    "Benchmark examples from literature"
                                  ],
                                  "tips": "Monitore tempo de CPU; use parallel computing para scalings.",
                                  "learningObjective": "Implementar e interpretar upper bound via D-scaling para bounds tight.",
                                  "commonMistakes": [
                                    "Divergência em iterações sem damping",
                                    "Ignorar blocos hiperbólicos em scaling"
                                  ]
                                }
                              ],
                              "practicalExample": "Considere um sistema de controle de motor DC com incertezas: M(jω) = [1/(s+1) + δ1, δ2; δ3, 1/(s+2)], onde δ1 normal full-block 1x1, δ2,δ3 escalares. Use ω = logspace(-1,2,100); compute μ bounds e plote para verificar robustez em ganho de 20%.",
                              "finalVerifications": [
                                "μ_lower e μ_upper calculados corretamente para exemplo padrão com gap <5%.",
                                "Código MATLAB roda sem erros e reproduz resultados de benchmark.",
                                "Interpretação: frequência onde μ>1 indica instabilidade robusta.",
                                "Plots mostram bounds vs. ω com legendas claras.",
                                "Validação cruzada com σ(M) e simulações de pior-caso."
                              ],
                              "assessmentCriteria": [
                                "Precisão numérica: bounds dentro de 1% de referências.",
                                "Eficiência computacional: tempo <5min para 100 freqs.",
                                "Correção conceitual: explicação escrita de diferenças lower/upper.",
                                "Qualidade de código: comentado, modular e reutilizável.",
                                "Análise de resultados: identificação de picos e implicações de design.",
                                "Tratamento de edge cases: singularidades ou Δ vazias."
                              ],
                              "crossCurricularConnections": [
                                "Álgebra Linear: SVD e eigen-decomposição avançada.",
                                "Programação Numérica: Otimização não-linear no MATLAB/Python.",
                                "Engenharia de Controle: Integração com H∞ loop-shaping.",
                                "Processamento de Sinais: Análise frequência e FFT para M(jω).",
                                "Estatística: Modelagem de incertezas estocásticas."
                              ],
                              "realWorldApplication": "Em design de controladores robustos para aeronaves (e.g., F-16 μ-synthesis pela NASA), onde incertezas em aerodinâmica e atuadores são modeladas; μ bounds garantem estabilidade apesar de variações de 20% em parâmetros, evitando falhas catastróficas."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "76.4.4.1.2",
                            "name": "Interpretar condições de robustez via μ",
                            "description": "Analisar se μ(M) < 1 implica robustez estável para incertezas Δ com ||Δ|| ≤ 1, e estender para desempenho com pesos de performance em problemas de análise H∞ generalizados.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a Definição e Interpretação Básica de μ(M)",
                                  "subSteps": [
                                    "Revise a definição de valor singular estruturado μ para uma matriz M e estrutura de incerteza especificada.",
                                    "Estude a relação entre μ(M), o menor δ tal que existe Δ estruturado com ||Δ|| = δ tornando (I - MΔ) singular.",
                                    "Aprenda que μ(M) < 1 garante ausência de Δ com ||Δ|| ≤ 1 que desestabiliza o laço.",
                                    "Explore upper e lower bounds computacionais para μ via algoritmos como μ-Tools.",
                                    "Pratique com exemplos simples de matrizes 2x2 com incertezas escalares."
                                  ],
                                  "verification": "Resuma em suas palavras o significado de μ(M) < 1 e resolva um exemplo numérico simples onde μ(M) = 0.8.",
                                  "estimatedTime": "45 minutes",
                                  "materials": [
                                    "Livro 'Robust and Optimal Control' de Zhou et al.",
                                    "MATLAB com Robust Control Toolbox",
                                    "Notas de aula sobre μ-síntese"
                                  ],
                                  "tips": "Comece com incertezas reais (Δ diagonal) para intuição antes de complexas.",
                                  "learningObjective": "Dominar a interpretação fundamental de μ como métrica de robustez.",
                                  "commonMistakes": "Confundir μ com σ (valor singular padrão); lembrar que μ considera estrutura."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar Robustez Estável sob Condição μ(M) < 1",
                                  "subSteps": [
                                    "Modele o laço de feedback fechado como M com incerteza Δ no ponto de injeção.",
                                    "Prove que μ(M) < 1 implica estabilidade robusta para todos Δ com ||Δ|| ≤ 1 (norma spectral ou estruturada).",
                                    "Simule um sistema nominal estável e adicione Δ com ||Δ|| = 1.1 * 1/μ para demonstrar instabilidade.",
                                    "Calcule μ(M) para um sistema de controle monovariável simples com ganho variável.",
                                    "Interprete o 'margem de robustez' como 1/μ(M)."
                                  ],
                                  "verification": "Demonstre via simulação que o sistema permanece estável para ||Δ|| ≤ 0.9 quando μ(M) = 0.8.",
                                  "estimatedTime": "60 minutes",
                                  "materials": [
                                    "MATLAB/Simulink para simulações",
                                    "Exemplos de código μ-Tools",
                                    "Paper 'Structured Singular Value' de Doyle"
                                  ],
                                  "tips": "Use LFT (Linear Fractional Transformation) para modelar Δ corretamente.",
                                  "learningObjective": "Aplicar μ(M) < 1 para verificar estabilidade robusta contra incertezas unitárias.",
                                  "commonMistakes": "Ignorar a estrutura de Δ; sempre especifique blocos de incerteza."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explorar Incertezas Estruturas Δ com ||Δ|| ≤ 1",
                                  "subSteps": [
                                    "Classifique tipos de Δ: reais/complexas, escalares/blocos completos, paramétricas/dinâmicas.",
                                    "Compute μ para diferentes estruturas usando funções como mussv() no MATLAB.",
                                    "Analise como μ penaliza direções sensíveis às incertezas estruturadas vs. não-estruturadas.",
                                    "Compare μ com γ (H∞ norm) em casos onde σ_max(M) >1 mas μ <1.",
                                    "Teste sensibilidade: varie estrutura de Δ e observe mudanças em μ."
                                  ],
                                  "verification": "Gere um relatório comparando μ para Δ estruturado vs. não-estruturado em um M dado.",
                                  "estimatedTime": "50 minutes",
                                  "materials": [
                                    "Robust Control Toolbox MATLAB",
                                    "Tutoriais online de μ-analysis",
                                    "Planilhas de cálculo manual para casos pequenos"
                                  ],
                                  "tips": "Visualize com Bode plots de M para entender picos relacionados a μ.",
                                  "learningObjective": "Diferenciar e quantificar impacto de estruturas de incerteza via μ.",
                                  "commonMistakes": "Assumir Δ não-estruturada quando o problema é estruturado; isso subestima risco."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Estender para Análise de Desempenho em Problemas H∞ Generalizados",
                                  "subSteps": [
                                    "Incorpore pesos de performance Wp e robustez Wu no framework H∞ loop-shaping.",
                                    "Formule o problema generalizado: μ do sistema aumentado M = [Wp M Wu; ...] para robustez e desempenho.",
                                    "Verifique se μ(M) <1 garante ||Tzw||∞ <1 (desempenho) e estabilidade robusta.",
                                    "Aplique em um exemplo: controlador para planta com incerteza aditiva e especificação de rastreamento.",
                                    "Avalie trade-offs: como pesos afetam μ e o design do controlador."
                                  ],
                                  "verification": "Projete pesos simples e confirme μ <1 com bom desempenho via simulação.",
                                  "estimatedTime": "75 minutes",
                                  "materials": [
                                    "MATLAB hinfsyn() e musyn()",
                                    "Exemplo de pendulo invertido com incertezas",
                                    "Referência 'Essentials of Robust Control' de Maciejowski"
                                  ],
                                  "tips": "Escolha pesos iniciais conservadores e itere com loop-shaping.",
                                  "learningObjective": "Integrar μ em síntese H∞ para robustez e desempenho conjuntos.",
                                  "commonMistakes": "Pesar incorretamente performance vs. robustez, levando a μ >1."
                                }
                              ],
                              "practicalExample": "Considere um controlador para um motor DC com incerteza paramétrica de 20% no ganho (Δ real escalar). Modele como LFT, compute μ(M) para o sistema loop-shaping com Wp para erro de rastreamento <10% e Wu para robustez. Verifique μ(M) = 0.75 <1, simulando estabilidade para Δ = ±0.2 e desempenho em rampa.",
                              "finalVerifications": [
                                "Explique verbalmente por que μ(M) <1 previne instabilidade para ||Δ|| ≤1.",
                                "Resolva um problema numérico: dado M, compute μ e interprete robustez.",
                                "Simule um laço com Δ randômico ||Δ||<1 e confirme estabilidade.",
                                "Estenda a um caso H∞: adicione pesos e verifique ||Tzw||∞ <1 quando μ<1.",
                                "Identifique em um plot de μ se há frequências críticas de robustez.",
                                "Compare μ com margens clássicas (ganho/fase) em um exemplo."
                              ],
                              "assessmentCriteria": [
                                "Precisão na interpretação de μ(M) <1 (100% correto).",
                                "Capacidade de modelar Δ corretamente em LFT (sem erros estruturais).",
                                "Resultados de simulação consistentes com teoria (estabilidade/desempenho).",
                                "Análise qualitativa de trade-offs em H∞ generalizado.",
                                "Uso correto de ferramentas computacionais (μ bounds precisos).",
                                "Criatividade em exemplos reais e conexões interdisciplinares."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria de valores singulares estruturados e normas de matrizes.",
                                "Programação: Implementação numérica em MATLAB para otimização e simulação.",
                                "Física: Modelagem dinâmica de sistemas com incertezas paramétricas.",
                                "Estatística: Análise de sensibilidade e Monte Carlo para validação de μ."
                              ],
                              "realWorldApplication": "No design de controladores fly-by-wire para aeronaves, μ garante estabilidade robusta contra variações aerodinâmicas (Δ modeladas como blocos dinâmicos), enquanto pesos H∞ asseguram manobrabilidade precisa sob turbulência, usado em sistemas como o Boeing 787."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "76.4.4.1.3",
                            "name": "Identificar estruturas de blocos para μ",
                            "description": "Definir e classificar blocos de incerteza Δ como escalares, cheios ou repetidos, e configurar o conjunto Δ para cálculo de μ em problemas multivariáveis.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os Fundamentos do Valor Singular Estruturado μ",
                                  "subSteps": [
                                    "Revise o conceito de valor singular H∞ e sua extensão para μ em síntese robusta.",
                                    "Estude a definição de μ como o valor singular estruturado de uma matriz M sob uma estrutura de incerteza Δ.",
                                    "Analise a fórmula μ(M, Δ) = 1 / min{σ_bar(Δ) : det(I - MΔ) = 0}.",
                                    "Identifique o papel dos blocos de incerteza na estrutura de Δ.",
                                    "Explore exemplos iniciais de problemas monovariáveis vs. multivariáveis."
                                  ],
                                  "verification": "Resuma em um parágrafo os conceitos chave de μ e liste 3 diferenças para H∞.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Livro 'Multivariable Feedback Control' de Skogestad",
                                    "Tutorial MATLAB Robust Control Toolbox",
                                    "Notas de aula sobre μ-Síntese"
                                  ],
                                  "tips": "Use diagramas de blocos para visualizar M e Δ.",
                                  "learningObjective": "Entender a base teórica de μ e sua dependência na estrutura de Δ.",
                                  "commonMistakes": [
                                    "Confundir μ com σ_bar(H∞)",
                                    "Ignorar a estrutura específica de Δ"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Classificar Tipos de Blocos de Incerteza Δ",
                                  "subSteps": [
                                    "Defina blocos escalares: Δ escalar (1x1) representando incerteza normativa simples.",
                                    "Descreva blocos cheios (full blocks): Matrizes Δ_ij de tamanho completo sem estrutura repetida.",
                                    "Explique blocos repetidos: Colunas ou linhas idênticas em Δ para reduzir conservadorismo.",
                                    "Compare as três classes com exemplos matriciais.",
                                    "Pratique classificação manual de 5 exemplos de estruturas Δ dadas."
                                  ],
                                  "verification": "Classifique corretamente 5 estruturas de Δ fornecidas como escalar, cheio ou repetido.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Paper 'Structured Singular Value' de Doyle",
                                    "Exercícios em PDF sobre blocos Δ",
                                    "MATLAB para plotar estruturas"
                                  ],
                                  "tips": "Lembre-se: repetidos usam o mesmo bloco em múltiplas posições para modelar incertezas correlacionadas.",
                                  "learningObjective": "Dominar a classificação precisa de blocos de incerteza.",
                                  "commonMistakes": [
                                    "Confundir full blocks com diagonais",
                                    "Subestimar o impacto de repetições no cálculo de μ"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Definir e Configurar a Estrutura Geral de Blocos para Δ",
                                  "subSteps": [
                                    "Construa a estrutura de Δ como bloco diagonal com blocos escalares, cheios e repetidos.",
                                    "Especifique dimensões: n_Δ escalares, p×q full blocks, r repetições.",
                                    "Use notação padrão: Δ = diag(Δ_1, ..., Δ_f, Δ_r I_k).",
                                    "Valide compatibilidade dimensional com M (Δ pertence a conjunto com norma ≤1).",
                                    "Crie uma estrutura de exemplo para um sistema MIMO 2x2 com incertezas mistas."
                                  ],
                                  "verification": "Desenhe e descreva a estrutura Δ para um M 3x3 dado.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "MATLAB mu toolbox ou Robust Control Toolbox",
                                    "Folha de exercícios com matrizes M",
                                    "Referência: 'μ-Analysis and Synthesis Toolbox User’s Guide'"
                                  ],
                                  "tips": "Sempre verifique se a estrutura respeita as repetições para evitar erros de dimensão.",
                                  "learningObjective": "Configurar estruturas de blocos Δ compatíveis com problemas multivariáveis.",
                                  "commonMistakes": [
                                    "Erro de dimensão em repetições",
                                    "Não normalizar Δ adequadamente"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar Estruturas de Blocos no Cálculo de μ",
                                  "subSteps": [
                                    "Implemente o cálculo de μ usando upper/lower bounds em MATLAB (musv função).",
                                    "Teste com estruturas variadas: só escalares, full + repeated.",
                                    "Analise como a estrutura afeta o valor de μ (ex: repetições reduzem μ).",
                                    "Resolva um problema completo: identifique estrutura e compute μ.",
                                    "Compare resultados com H∞ para validar."
                                  ],
                                  "verification": "Compute μ corretamente para 3 matrizes M com estruturas Δ diferentes.",
                                  "estimatedTime": "2.5 horas",
                                  "materials": [
                                    "MATLAB com Robust Control Toolbox instalado",
                                    "Scripts de exemplo para musv",
                                    "Datasets de problemas de controle robusto"
                                  ],
                                  "tips": "Use power algorithm para bounds precisos em problemas pequenos.",
                                  "learningObjective": "Integrar identificação de estruturas ao fluxo de cálculo de μ.",
                                  "commonMistakes": [
                                    "Especificar estrutura errada no mu toolbox",
                                    "Interpretar bounds como exato"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Verificar e Refinar Configurações de Δ",
                                  "subSteps": [
                                    "Realize testes de sensibilidade alterando tipos de blocos.",
                                    "Verifique conservadorismo: full vs. repeated.",
                                    "Documente a configuração final de Δ para um caso estudo.",
                                    "Discuta limitações computacionais para estruturas complexas.",
                                    "Crie um checklist para identificação futura."
                                  ],
                                  "verification": "Gere relatório com μ para configurações alternativas e justifique a escolhida.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Template de relatório em LaTeX ou Word",
                                    "Gráficos MATLAB de μ vs. estrutura"
                                  ],
                                  "tips": "Sempre priorize estruturas realistas baseadas no modelo físico.",
                                  "learningObjective": "Refinar e validar estruturas de Δ para robustez.",
                                  "commonMistakes": [
                                    "Overfitting estrutura sem base física",
                                    "Ignorar bounds power vs. real μ"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um sistema de controle de asa flexível (aeroespacial), identifique incertezas: ganho escalar no atuador (Δ1 escalar), matriz de incerteza dinâmica cheia 2x2 no modelo aerodinâmico (Δ2 full), e incertezas de massa repetidas em 3 modos (Δ3 repeated scalar x3). Configure Δ = diag(Δ1, Δ2, Δ3, Δ3, Δ3) e compute μ(M(jω)) para estabilidade robusta em banda de frequência.",
                              "finalVerifications": [
                                "Classificar corretamente 90% dos blocos em um teste de 10 estruturas mistas.",
                                "Configurar Δ válida dimensionalmente para 5 matrizes M multivariáveis.",
                                "Calcular μ com erro <5% entre upper/lower bounds em MATLAB.",
                                "Explicar impacto de mudar escalar para repeated em um exemplo.",
                                "Gerar diagrama de estrutura Δ precisa para um problema dado.",
                                "Identificar conservadorismo em pelo menos 2 casos."
                              ],
                              "assessmentCriteria": [
                                "Precisão na classificação de blocos (escalar/full/repeated): 40%.",
                                "Correção na configuração dimensional de Δ: 20%.",
                                "Implementação e interpretação de cálculo μ: 20%.",
                                "Análise qualitativa de impactos estruturais: 10%.",
                                "Clareza em exemplos e verificações: 10%."
                              ],
                              "crossCurricularConnections": [
                                "Álgebra Linear: Decomposições singulares e normas matriciais.",
                                "Programação Numérica: Uso de toolboxes MATLAB para otimização.",
                                "Modelagem de Sistemas: Identificação de incertezas físicas em dinâmica.",
                                "Otimização: Bounds e algoritmos para μ-computação."
                              ],
                              "realWorldApplication": "Na indústria aeroespacial (ex: Boeing), estruturas de blocos Δ modelam incertezas em controladores de voo para garantir estabilidade robusta apesar de variações em aerodinâmica e atuadores, permitindo certificação FAA com análise μ."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "76.4.4.2",
                        "name": "Modelagem de Incertezas Estruturadas",
                        "description": "Representação de incertezas paramétricas e dinâmicas não estruturadas em forma de transformações lineares fracionárias (LFTs) para integração na forma padrão do problema de controle robusto.",
                        "specificSkills": [
                          {
                            "id": "76.4.4.2.1",
                            "name": "Construir LFTs para incertezas estruturadas",
                            "description": "Modelar incertezas como blocos Δ em uma LFT [M* Δ](I - Δ M)^(-1), conectando plantas nominais com perturbações em entradas e saídas para análise μ.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Identificar e Classificar Incertezas Estruturadas",
                                  "subSteps": [
                                    "Analise o sistema nominal para identificar fontes de incerteza, como variações paramétricas, não-linearidades ou perturbações em entradas/saídas.",
                                    "Classifique as incertezas em blocos Δ normados (ex.: Δ ∈ ℝ^{k×k} com ||Δ||_∞ ≤ 1).",
                                    "Defina os pontos de injeção: entradas perturbadas (δu) e saídas perturbadas (δy).",
                                    "Esboce um diagrama de blocos mostrando a planta G nominal e os pontos de conexão para Δ.",
                                    "Documente as dimensões de cada bloco Δ para garantir compatibilidade matricial."
                                  ],
                                  "verification": "Verifique se todas incertezas foram mapeadas em um diagrama claro com dimensões corretas e normas definidas.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Papel e lápis ou software de diagramação (Draw.io), notas do sistema nominal.",
                                  "tips": "Comece com incertezas reais do sistema; evite abstrair demais no início.",
                                  "learningObjective": "Compreender como mapear incertezas físicas para blocos Δ estruturados.",
                                  "commonMistakes": "Ignorar normas das incertezas (ex.: assumir ||Δ||_∞ >1 sem escalar) ou incompatibilidade de dimensões."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Construir a Interconexão M",
                                  "subSteps": [
                                    "Particione a matriz M em [M11 M12; M21 M22] baseada nos sinais de entrada/saída para Δ.",
                                    "Incorpore a planta nominal G em M22, com entradas de controle u e referências r em M11/M12/M21.",
                                    "Adicione pesos W para normalizar sinais (ex.: W_u para entradas, W_y para saídas).",
                                    "Implemente M como um sistema LTI em software (ex.: ss em MATLAB).",
                                    "Valide a interconexão resolvendo manualmente para um caso escalar simples."
                                  ],
                                  "verification": "Simule M sem Δ e confirme que reproduz o comportamento nominal do sistema.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "MATLAB/Simulink ou Python (Control Systems Library), equações do sistema G.",
                                  "tips": "Use funções como 'lft' no Robust Control Toolbox para automação inicial.",
                                  "learningObjective": "Dominar a construção da matriz de interconexão M para LFTs.",
                                  "commonMistakes": "Erros de particionamento (ex.: inverter M12 e M21) ou esquecimento de pesos de normalização."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Formar a LFT e Verificar Bem-Posedness",
                                  "subSteps": [
                                    "Monte a LFT na forma [M* Δ] (I - Δ M)^{-1}, onde M* é a parte relevante de M.",
                                    "Implemente a fórmula algébrica: F_Δ(M, Δ) = M11 + M12 Δ (I - M22 Δ)^{-1} M21 para validação.",
                                    "Verifique bem-posedness: det(I - Δ M22) ≠ 0 para todos Δ admissíveis.",
                                    "Teste com Δ = 0 para recuperar o sistema nominal.",
                                    "Simule com Δ pequeno para observar efeitos de incerteza."
                                  ],
                                  "verification": "Confirme que F_Δ(M, 0) = G nominal e que a inversa existe numericamente.",
                                  "estimatedTime": "50 minutos",
                                  "materials": "MATLAB Robust Control Toolbox (funções lft, musyn), exemplos de Δ gerados aleatoriamente.",
                                  "tips": "Use mu-analysis tools para checar singularidades iniciais.",
                                  "learningObjective": "Aplicar a fórmula LFT corretamente e garantir estabilidade estrutural.",
                                  "commonMistakes": "Confundir upper LFT (F_u) com lower LFT (F_l); sempre especifique a forma."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar Robustez com μ-Síntese",
                                  "subSteps": [
                                    "Calcule o valor μ de M(ω) sobre frequências para quantificar robustez.",
                                    "Gere bounds inferiores/superiores de μ usando algoritmos D-K.",
                                    "Interprete picos de μ como indicações de fragilidades.",
                                    "Ajuste pesos ou estrutura Δ se μ >1 em bandas críticas.",
                                    "Documente o modelo LFT final com gráficos de μ."
                                  ],
                                  "verification": "Gere plot de μ(M(jω)) mostrando robustez (μ ≤1) nas frequências de interesse.",
                                  "estimatedTime": "75 minutos",
                                  "materials": "MATLAB (mussv, muplot), banco de dados de simulações.",
                                  "tips": "Escalone Δ adequadamente para μ ≈1 no limite de incerteza máxima.",
                                  "learningObjective": "Conectar LFT à análise μ para síntese robusta.",
                                  "commonMistakes": "Não linearizar corretamente ou ignorar fase em análises de frequência."
                                }
                              ],
                              "practicalExample": "Considere um motor DC com incerteza paramétrica no ganho K (20% variação) e perturbação em torque de carga. Modele como Δ_k em ganho e Δ_load em saída. Construa M com G = 1/(s(Js+B)), injete Δ_k em entrada de tensão e Δ_load em torque. Forme LFT e compute μ para verificar estabilidade robusta sob variação.",
                              "finalVerifications": [
                                "Diagrama LFT reproduz sistema nominal com Δ=0.",
                                "Dimensões de M e Δ são compatíveis.",
                                "Bem-posedness confirmada: det(I - Δ M22) ≠0.",
                                "μ(M(jω)) ≤1 nas bandas de operação.",
                                "Simulação com Δ máximo mantém estabilidade.",
                                "Documentação inclui pesos, normas e plots."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação e normalização de Δ (90% corretude).",
                                "Correta construção de M e LFT (verificação algébrica/simulada).",
                                "Interpretação válida de μ e bounds D-K.",
                                "Uso apropriado de ferramentas (sem erros de código).",
                                "Clareza na documentação e diagramas.",
                                "Capacidade de ajustar modelo para μ≤1."
                              ],
                              "crossCurricularConnections": [
                                "Álgebra Linear: Particionamento matricial e inversas.",
                                "Análise de Sistemas: Diagrama de blocos e transformadas de Laplace.",
                                "Otimização: Síntese μ via D-K iteration.",
                                "Probabilidade: Modelagem estocástica de perturbações como Δ.",
                                "Programação Numérica: Implementação em MATLAB/Python."
                              ],
                              "realWorldApplication": "Em controle de voo de aeronaves, modela incertezas aerodinâmicas (variações de ângulo de ataque) como Δ estruturados em LFTs para síntese de controladores μ-robustos, garantindo estabilidade sob turbulências e falhas de atuadores."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "76.4.4.2.2",
                            "name": "Configurar a forma padrão para μ-análise",
                            "description": "Organizar o sistema generalizado com planta P, controlador K, pesos W_e, W_u e blocos Δ em configuração que permite análise de robustez via μ da matriz M.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Identificar e modelar os componentes básicos do sistema",
                                  "subSteps": [
                                    "Descreva a planta nominal P(s) com entradas (referência r, perturbação d, medição y) e saídas (erro e, controle u).",
                                    "Defina os pesos de performance: We(s) para erro de rastreamento e robustez de performance, Wu(s) para limitação de esforço de controle.",
                                    "Especifique as incertezas estruturadas Δ, como blocos normais Δ ∈ ℂ^{m×m} com ||Δ||_μ ≤ 1.",
                                    "Verifique as dimensões das matrizes para compatibilidade (ex: dim(We) = dim(e), dim(Wu) = dim(u)).",
                                    "Crie diagramas de bloco iniciais no papel ou software."
                                  ],
                                  "verification": "Componentes modelados com dimensões compatíveis e diagramas de bloco desenhados corretamente.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "MATLAB/Simulink",
                                    "Livro 'Multivariable Feedback Control' de Skogestad",
                                    "Papel e lápis para diagramas"
                                  ],
                                  "tips": "Comece com um sistema SISO simples para validar dimensões antes de MIMO.",
                                  "learningObjective": "Compreender os blocos fundamentais P, We, Wu e Δ na configuração μ.",
                                  "commonMistakes": [
                                    "Ignorar dimensões de entrada/saída",
                                    "Confundir We com Wu",
                                    "Esquecer normalização das incertezas"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Incorporar os pesos de performance e o controlador K",
                                  "subSteps": [
                                    "Conecte We na saída de erro: e_w = We * e.",
                                    "Conecte Wu no sinal de controle: u_w = Wu * u.",
                                    "Insira o controlador K no laço de feedback: u = K * y.",
                                    "Forme o sistema generalizado inicial G(s) = [[We, 0]; [-Wu*K*P, I]] * P * [[K]; [I]].",
                                    "Simplifique a expressão para o formato upper linear fractional transformation (ULFT)."
                                  ],
                                  "verification": "Sistema generalizado G(s) formado com pesos e K integrados, sem erros de conexão.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "MATLAB Robust Control Toolbox (sysic, lft)",
                                    "Documentação MATLAB μ-tools"
                                  ],
                                  "tips": "Use funções como 'augw' no MATLAB para automação de pesos.",
                                  "learningObjective": "Construir o sistema interconectado com pesos e controlador para análise de performance.",
                                  "commonMistakes": [
                                    "Conexão errada do sinal de feedback",
                                    "Não inverter o sinal de erro",
                                    "Esquecer o bloco identidade I"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Inserir blocos de incerteza Δ e formar a estrutura LFT",
                                  "subSteps": [
                                    "Identifique pontos de injeção das incertezas (ex: Δ em atuadores, sensores ou planta).",
                                    "Crie entradas/saídas de incerteza: w_Δ para entradas Δ, z_Δ para saídas Δ.",
                                    "Forme o sistema M(s) como upper LFT: M = Fl(G, Δ), onde Δ atua nas incertezas.",
                                    "Ajuste G para incluir portas de incerteza: expanda P com P_Δ.",
                                    "Valide a estrutura: o sistema fechado deve ser T = Fl(M, Δ)."
                                  ],
                                  "verification": "Matriz M(s) configurada como LFT com Δ corretamente posicionado e compatível.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "MATLAB (lft, mussv)",
                                    "Exemplos de μ-síntese do Robust Control Toolbox"
                                  ],
                                  "tips": "Use 'lft(G, Delta)' para construir automaticamente e visualizar com 'view(lftsys)'.",
                                  "learningObjective": "Configurar incertezas estruturadas na forma padrão para μ-análise.",
                                  "commonMistakes": [
                                    "Posição incorreta de Δ (ex: em vez de após Wu)",
                                    "Dimensões incompatíveis em w_Δ/z_Δ",
                                    "Confundir LFT upper com lower"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificar e preparar para análise μ",
                                  "subSteps": [
                                    "Calcule o μ upper/lower bound inicial em M(jω) usando mussv.",
                                    "Verifique estabilidade nominal (sem Δ) com nyquist ou pole.",
                                    "Ajuste pesos se μ >1 em frequências críticas.",
                                    "Gere plots de singular values de M e μ bounds.",
                                    "Documente a configuração final com equações e código."
                                  ],
                                  "verification": "μ(M) computado sem erros, com plots gerados e estabilidade confirmada.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "MATLAB (mussv, sigma)",
                                    "Notebook Jupyter ou relatório LaTeX"
                                  ],
                                  "tips": "Sempre normalize Δ para ||Δ||_μ=1 e compare com 1/μ para robustez.",
                                  "learningObjective": "Validar a configuração para análise de robustez μ.",
                                  "commonMistakes": [
                                    "Não linearizar em jω",
                                    "Ignorar D-K iteration para bounds",
                                    "Esquecer scaling de pesos"
                                  ]
                                }
                              ],
                              "practicalExample": "Para um sistema massa-mola-amortecedor com incerteza de 20% na massa: P(s) = 1/(m s^2 + c s + k), We=1/(s+1) para rastreamento, Wu=0.1 para controle saturado, Δ bloco 1x1 diagonal na massa. Configure M tal que μ(M)<1 garanta robustez.",
                              "finalVerifications": [
                                "Dimensões de todas matrizes compatíveis (p x m para Δ).",
                                "Sistema nominal estável e performante (||Tzw||_∞ <1 sem Δ).",
                                "μ upper bound ≤1 em todo o intervalo de frequência.",
                                "Plots de σ(M) e μ bounds gerados e interpretados.",
                                "Código MATLAB reproduzível sem erros.",
                                "Documentação com diagramas de bloco completa."
                              ],
                              "assessmentCriteria": [
                                "Correção na formação da LFT M(s) com todos blocos (P, K, We, Wu, Δ).",
                                "Precisão nas dimensões e conexões de portas de incerteza.",
                                "Validação computacional com μ bounds <1.",
                                "Clareza nos diagramas e explicações teóricas.",
                                "Identificação de erros comuns evitados.",
                                "Eficiência temporal dentro dos estimados."
                              ],
                              "crossCurricularConnections": [
                                "Álgebra Linear: Decomposição de valores singulares (σ) e normas estruturadas μ.",
                                "Programação: Uso de toolboxes MATLAB para automação de LFT.",
                                "Matemática Aplicada: Análise de frequência e transformações fracionárias lineares.",
                                "Física/Engenharia Mecânica: Modelagem de plantas com incertezas paramétricas."
                              ],
                              "realWorldApplication": "Em controle de voo de aeronaves, configura-se μ-análise para lidar com incertezas aerodinâmicas (variações de ângulo de ataque), garantindo estabilidade robusta sob condições variáveis de vento e configuração de asas."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "76.4.4.1.1"
                            ]
                          },
                          {
                            "id": "76.4.4.2.3",
                            "name": "Avaliar gaps de robustez com μ",
                            "description": "Interpretar discrepâncias entre bounds de μ para diagnosticar limitações conservadoras e propor refinamentos na estrutura de Δ.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender Fundamentos de Bounds de μ",
                                  "subSteps": [
                                    "Revise a definição de μ como structured singular value para incertezas estruturadas Δ.",
                                    "Estude upper bound (μ̂ via D-K iteration ou scalings) e lower bound (via potência ou relaxações).",
                                    "Aprenda que gap = upper - lower bound indica conservadorismo.",
                                    "Analise equação μ(Δ) ≤ μ̂(Δ) e condições de convergência.",
                                    "Explore exemplos simples com Δ diagonal."
                                  ],
                                  "verification": "Explique verbalmente ou por escrito a diferença entre upper e lower bounds com um diagrama.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Livro 'Multivariable Feedback Control' de Skogestad",
                                    "Tutorial MATLAB Robust Control Toolbox",
                                    "Notas de aula sobre μ-síntese"
                                  ],
                                  "tips": "Use analogia: upper bound é limite pessimista, lower é otimista; gap mede incerteza na análise.",
                                  "learningObjective": "Dominar definições e interpretações básicas de bounds de μ.",
                                  "commonMistakes": [
                                    "Confundir μ com σ (singular value)",
                                    "Ignorar estrutura de Δ no cálculo",
                                    "Assumir gap zero sempre significa robustez perfeita"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Calcular e Visualizar Bounds de μ",
                                  "subSteps": [
                                    "Configure modelo nominal G e estrutura de Δ no MATLAB (usar mussv ou mu toolbox).",
                                    "Compute upper e lower bounds para frequências ω relevantes.",
                                    "Plote μ lower, upper e |T| (closed-loop) em gráfico Bode-like.",
                                    "Identifique frequências onde gap é máximo.",
                                    "Teste sensibilidade variando escalares D."
                                  ],
                                  "verification": "Gere e interprete plot com gap destacado; exporte figura com anotações.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "MATLAB com Robust Control Toolbox",
                                    "Exemplo .mat de sistema monovariável com incertezas",
                                    "Script template para μ-calculation"
                                  ],
                                  "tips": "Sempre normalize Δ para ||Δ||≤1; use logscale para frequências.",
                                  "learningObjective": "Executar computação prática de bounds e visualização de gaps.",
                                  "commonMistakes": [
                                    "Escolha errada de grid de frequências",
                                    "Não verificar convergência D-K",
                                    "Plot sem normalização"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Interpretar Discrepâncias e Diagnosticar Conservadorismo",
                                  "subSteps": [
                                    "Classifique gaps: pequeno (<10%) indica análise precisa; grande (>50%) sugere conservadorismo.",
                                    "Identifique causas: estrutura Δ muito geral, incertezas correlacionadas não capturadas.",
                                    "Compare μ vs. σ para Δ full block para quantificar impacto estrutural.",
                                    "Avalie estabilidade robusta: se lower >1, instável para alguma Δ.",
                                    "Documente diagnóstico em tabela (freq, gap, implicações)."
                                  ],
                                  "verification": "Produza relatório de 1 página diagnosticando um caso com evidências numéricas.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Plots gerados no Step 2",
                                    "Tabela Excel para gaps",
                                    "Referências: Packwood notes on μ-gaps"
                                  ],
                                  "tips": "Foco em crossover frequency onde robustez é crítica.",
                                  "learningObjective": "Diagnosticar limitações conservadoras a partir de discrepâncias.",
                                  "commonMistakes": [
                                    "Ignorar fase vs. magnitude",
                                    "Sobre-generalizar gap pequeno como 'perfeito'",
                                    "Não considerar trade-offs performance vs. robustez"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Propor e Validar Refinamentos na Estrutura de Δ",
                                  "subSteps": [
                                    "Proponha Δ refinada: adicione blocos reais/complexos baseados em física do sistema.",
                                    "Recompute bounds com nova Δ e compare gaps.",
                                    "Teste redução de conservadorismo via μ̂ menor ou gap reduzido.",
                                    "Simule worst-case Δ via wcgain ou lplmi.",
                                    "Valide ganho de performance (e.g., menor ||T||∞)."
                                  ],
                                  "verification": "Demonstre redução de gap >20% com plots before/after.",
                                  "estimatedTime": "2.5 horas",
                                  "materials": [
                                    "MATLAB scripts atualizados",
                                    "Documentação de incertezas físicas do sistema exemplo",
                                    "Ferramenta YALMIP para LMI se necessário"
                                  ],
                                  "tips": "Comece com Δ mais estruturada (e.g., repeated scalars); itere incrementalmente.",
                                  "learningObjective": "Propor melhorias acionáveis na modelagem de incertezas.",
                                  "commonMistakes": [
                                    "Refinamento Δ muito complexo sem justificativa",
                                    "Não revalidar estabilidade",
                                    "Ignorar custo computacional"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um controlador para um atuador hidráulico em robótica industrial, onde Δ modela variações paramétricas (ganho Kp, tempo morto τ), compute bounds de μ em [0.1,10] rad/s. Gap de 40% em ω=1 rad/s indica conservadorismo; refine Δ adicionando bloco real para τ correlacionado com Kp, reduzindo gap para 15% e permitindo tuning mais agressivo.",
                              "finalVerifications": [
                                "Explicar corretamente gap zero vs. gap grande com exemplo numérico.",
                                "Gerar plots de μ bounds para sistema dado com gap quantificado.",
                                "Diagnosticar causa de gap em caso real e propor refinamento específico.",
                                "Comparar μ antes/depois de Δ refinada mostrando melhoria.",
                                "Simular perturbação Δ worst-case e verificar robustez.",
                                "Discutir trade-offs conservadorismo vs. performance."
                              ],
                              "assessmentCriteria": [
                                "Precisão na interpretação de bounds (90%+ correção conceitual).",
                                "Qualidade de plots e cálculos MATLAB (sem erros numéricos).",
                                "Profundidade do diagnóstico (identifica ≥2 causas válidas).",
                                "Criatividade e validade das propostas de refinamento Δ.",
                                "Redução mensurável de gap (>15%) em exemplo prático.",
                                "Clareza no relatório final com evidências."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Álgebra linear (singular values), otimização (D-scalings).",
                                "Programação: MATLAB/Simulink para análise numérica robusta.",
                                "Física/Engenharia: Modelagem de incertezas paramétricas reais.",
                                "Estatística: Análise de sensibilidade e Monte Carlo para validação."
                              ],
                              "realWorldApplication": "Na indústria aeroespacial, avaliar gaps de μ em controladores de flight envelope protection para F-35, refinando Δ para incertezas aerodinâmicas estruturadas, reduzindo conservadorismo e permitindo margens de performance maiores em missões críticas."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "76.4.4.1.2"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "76.4.4.3",
                        "name": "Algoritmo D-K Iterativo para μ-Síntese",
                        "description": "Método iterativo que alterna escalonamento D (otimização de matrizes constantes para minimizar μ) e síntese H∞ de controladores para alcançar desempenho robusto ótimo em termos de μ.",
                        "specificSkills": [
                          {
                            "id": "76.4.4.3.1",
                            "name": "Descrever os passos do algoritmo D-K",
                            "description": "Explicar a iteração: fixar D → sintetizar K via H∞ → fixar K → otimizar D novo, com critérios de convergência e condições de estabilidade local.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os componentes fundamentais do algoritmo D-K",
                                  "subSteps": [
                                    "Defina o que é o escalador D (matriz de escalonamento diagonal complexa não singular) e sua função em reduzir o μ para 1.",
                                    "Explique o controlador K como o resultado da síntese H∞ no sistema escalado.",
                                    "Descreva o papel da norma estruturada μ na análise de robustez do laço fechado.",
                                    "Identifique a estrutura geral da iteração D-K como alternância entre fixar D e otimizar K, e vice-versa.",
                                    "Revise as premissas: sistema G com incertezas estruturadas e objetivo de min μ."
                                  ],
                                  "verification": "Escreva um parágrafo resumindo D, K e μ, e confirme com um colega ou autoavaliação se cobre os conceitos chave.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Livro de controle robusto (ex: Zhou, Doyle, Glover), notas de aula sobre H∞ e μ-síntese, MATLAB Robust Control Toolbox.",
                                  "tips": "Use diagramas de blocos para visualizar o laço P-K com Δ e escaladores D.",
                                  "learningObjective": "Dominar a terminologia e papéis de D e K no contexto de μ-síntese.",
                                  "commonMistakes": "Confundir D com escaladores reais (D é complexo); ignorar que D é diagonal por bloco para estrutura de Δ."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Descrever a fase de inicialização do algoritmo",
                                  "subSteps": [
                                    "Inicie com D₀ = I (identidade), assumindo convergência inicial.",
                                    "Defina o sistema generalizado P (planta com incertezas) e o conjunto de incertezas Δ estruturadas.",
                                    "Especifique tolerâncias: ε para convergência em μ, limite máximo de iterações (ex: 20).",
                                    "Verifique condições iniciais: estabilidade de P e pertubabilidade de Δ.",
                                    "Documente hiperparâmetros como γ inicial para H∞."
                                  ],
                                  "verification": "Liste os itens de inicialização em um fluxograma e simule D₀ em um exemplo simples no MATLAB.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "MATLAB com comandos como 'musyn' ou 'dksyn', paper sobre μ-síntese (ex: Packwood).",
                                  "tips": "Sempre normalize incertezas para ||Δ||_μ ≤ 1 para facilitar convergência.",
                                  "learningObjective": "Saber configurar o algoritmo desde o início para garantir viabilidade.",
                                  "commonMistakes": "Escolher D₀ arbitrário sem identidade, levando a não-convergência; omitir verificação de estabilidade de P."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Detalhar o passo de síntese do controlador K fixando D",
                                  "subSteps": [
                                    "Com D fixo, forme o sistema escalado: minimize ||D * Fl(P,K) * inv(D)||_∞ < γ via síntese H∞.",
                                    "Use solver H∞ (ex: hinf_syn no MATLAB) para computar K novo.",
                                    "Atualize γ via bissecção se necessário para encontrar o ótimo local.",
                                    "Verifique se o K sintetizado estabiliza o laço escalado.",
                                    "Registre μ_upper = γ obtido."
                                  ],
                                  "verification": "Implemente em código MATLAB e plote o singular value plot do sistema escalado para confirmar γ.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "MATLAB Robust Control Toolbox (hinfgs, musyn), exemplos de sistemas SISO/MIMO.",
                                  "tips": "Monitore o conditioning de D para evitar numéricos ruins; use D full-block se aplicável.",
                                  "learningObjective": "Executar e descrever a síntese H∞ escalada com precisão.",
                                  "commonMistakes": "Esquecer de escalar corretamente com D e inv(D); não iterar γ adequadamente."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Explicar a otimização de D fixando K",
                                  "subSteps": [
                                    "Com K fixo, compute o laço fechado Fl(P,K) e encontre D que minimiza ||D * M * inv(D)||_∞ onde M=Fl(P,K).",
                                    "Use otimização convexa por bloco: otimizar cada bloco diagonal de D separadamente via SDP ou algoritmos iterativos.",
                                    "Atualize D novo e compute μ_lower aproximado.",
                                    "Verifique monotonicidade: μ deve diminuir ou estabilizar.",
                                    "Registre mudança |μ_upper - μ_lower|."
                                  ],
                                  "verification": "Rode uma iteração em MATLAB e compare μ antes/depois; deve haver redução.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "MATLAB com mu-tools ou YALMIP para otimização, documentação de dkgamma.",
                                  "tips": "Para Δ repetitiva, use frequências constantes iniciais e refine; paralelize blocos.",
                                  "learningObjective": "Compreender a otimização não-convexa aproximada via convexidade por frequência.",
                                  "commonMistakes": "Otimizar D globalmente sem por bloco, causando ineficiência; ignorar fase complexa."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Definir critérios de convergência e condições de estabilidade local",
                                  "subSteps": [
                                    "Pare se |μ^{k+1} - μ^k| < ε (ex: 0.01) ou iterações > max_it.",
                                    "Verifique convergência: μ_upper ≈ μ_lower e D converge.",
                                    "Confirme estabilidade local: eigenvalues do Hamiltoniano ou análise de Lyapunov para K.",
                                    "Avalie robustez final: simule com Δ nominais e perturbados.",
                                    "Documente o par (D*, K*) final e performance γ."
                                  ],
                                  "verification": "Aplique critérios a um log de iterações simuladas e escreva relatório de parada.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Scripts MATLAB para log de iterações, toolbox para análise de estabilidade (sel toolbox).",
                                  "tips": "Use μ_upper bound conservador; se não converge, ajuste estrutura de Δ ou γ.",
                                  "learningObjective": "Garantir que a iteração termine com solução robusta e verificável.",
                                  "commonMistakes": "Parar cedo sem checar estabilidade; confundir convergência numérica com global."
                                }
                              ],
                              "practicalExample": "Considere um sistema de missile com incertezas em massa e aerodinâmica (Δ estruturada 2x2). Inicialize D=I, sintetize K via H∞ reduzindo γ de 2.5 para 1.8, otimize D reduzindo μ de 1.9 para 1.2 após 5 iterações. Converge com μ≈1.15, estável para ||Δ||_μ<1.1. Simule step response com/ sem incertezas no MATLAB.",
                              "finalVerifications": [
                                "Descreva verbalmente os 4 passos principais da iteração D-K sem consultar notas.",
                                "Implemente o algoritmo em MATLAB para um sistema benchmark e obtenha convergência.",
                                "Explique diferenças entre D-K e síntese H∞ pura.",
                                "Identifique quando o algoritmo falha (ex: ill-conditioned D).",
                                "Compare μ final com análise upper-bound.",
                                "Simule estabilidade com perturbações Δ aleatórias."
                              ],
                              "assessmentCriteria": [
                                "Precisão na descrição da alternância D-K (obrigatório).",
                                "Correta inclusão de escalonamento complexo e por bloco.",
                                "Detalhamento de convergência com ε quantitativo.",
                                "Menção explícita a estabilidade local via H∞.",
                                "Uso de terminologia técnica sem erros (μ, Fl, etc.).",
                                "Capacidade de ligar a robustez prática."
                              ],
                              "crossCurricularConnections": [
                                "Otimização convexa (Engenharia de Otimização).",
                                "Álgebra linear numérica (para conditioning de D).",
                                "Teoria de controle ótimo (H∞ como LMI).",
                                "Processamento de sinais (análise por frequência).",
                                "Programação numérica (MATLAB/SDPs)."
                              ],
                              "realWorldApplication": "No design de controladores para aeronaves (ex: F-16 via μ-síntese), lidando com incertezas em modelos aerodinâmicos e atuadores, garantindo estabilidade robusta sob variações de 20% em parâmetros, usado pela NASA e indústrias aeroespaciais."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "76.4.4.2.1"
                            ]
                          },
                          {
                            "id": "76.4.4.3.2",
                            "name": "Implementar iteração D-K em MATLAB",
                            "description": "Usar funções como mussv, dksyn ou hinfsyn com escalonamento para gerar controladores robustos, analisando evolução de μ ao longo das iterações.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Configurar o ambiente MATLAB e definir o modelo do sistema com incertezas",
                                  "subSteps": [
                                    "Instalar e carregar o Robust Control Toolbox no MATLAB.",
                                    "Definir a planta nominal P(s) usando tf ou ss (ex: sistema de segundo ordem).",
                                    "Modelar blocos de incerteza Δ (uncertainty blocks) como uncs ou ultidyn para incertezas normais ou paramétricas.",
                                    "Construir o sistema generalizado M usando starprod ou connect para interconectar P e Δ.",
                                    "Computar o valor estrutural μ inicial de M usando musstv."
                                  ],
                                  "verification": "Verificar se μ inicial é finito e o modelo M é criado sem erros via muplot ou spy(M).",
                                  "estimatedTime": "1.5 hours",
                                  "materials": [
                                    "MATLAB com Robust Control Toolbox",
                                    "Documentação MATLAB: robustsys, musstv",
                                    "Exemplo de planta: sys = tf([1],[1 2 1])"
                                  ],
                                  "tips": "Use sysic para incertezas em entradas/saídas; sempre normalize incertezas para ||Δ||∞ ≤1.",
                                  "learningObjective": "Entender modelagem de sistemas com incertezas estruturadas para μ-síntese.",
                                  "commonMistakes": [
                                    "Esquecer de linearizar o modelo não-linear",
                                    "Não normalizar incertezas adequadamente",
                                    "Ignorar dimensões incompatíveis em starprod"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Configurar o problema de síntese e inicializar a iteração D-K",
                                  "subSteps": [
                                    "Definir pesos de performance Wp, robustez Wu e sensibilidade Ws para o sistema generalizado.",
                                    "Estruturar o problema μ usando mussv com opções para iteração D-K (DksynMethod='mussv').",
                                    "Inicializar D0 como identidade ou resultado de musstv em frequência única.",
                                    "Executar uma síntese inicial de K usando dksyn ou hinfsyn com D fixo.",
                                    "Plotar singular values de Tzw para verificar configuração inicial."
                                  ],
                                  "verification": "Confirmar que o controlador inicial K estabiliza o loop fechado via sigma(Tzw) <1 em todas as frequências.",
                                  "estimatedTime": "2 hours",
                                  "materials": [
                                    "Funções: mussv, dksyn, hinfsyn",
                                    "Tutoriais MATLAB: rcddemo1",
                                    "Pesos exemplo: Wp = tf(1,[0.0001 0.1 1])"
                                  ],
                                  "tips": "Escolha γ inicial conservador (ex: 2-5x μ upper bound); use logspace para análise em frequências.",
                                  "learningObjective": "Configurar corretamente pesos e estrutura para síntese robusta μ.",
                                  "commonMistakes": [
                                    "Pesos mal escalados levando a μ=∞",
                                    "Não especificar estrutura de Δ corretamente",
                                    "Ignorar fase em pesos de performance"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar o loop iterativo D-K até convergência",
                                  "subSteps": [
                                    "Criar um loop while com critério de parada: mudança em μ < tol (ex: 1e-2) ou max_iter=20.",
                                    "No loop: computar D ótimo via musstv(M,K_prev); sintetizar K novo via dksyn(M,D).",
                                    "Atualizar μ upper/lower bounds e armazenar histórico de μ(D,K).",
                                    "Monitorar convergência plotando evolução de μ vs iterações.",
                                    "Parar se μ_upper <1 ou divergência detectada."
                                  ],
                                  "verification": "Loop converge com μ_final <1 e diferença |μ_upper - μ_lower| < tol; plot de μ mostra platô.",
                                  "estimatedTime": "3 hours",
                                  "materials": [
                                    "Script template: for i=1:max_iter; D=mussv(...); [K,CL,GAM]=dksyn(...); end",
                                    "Opções: mussvOptions('Display','on')"
                                  ],
                                  "tips": "Use tol=1e-3 e max_iter=15; acelere com 'mu' analysis em frequências logspace.",
                                  "learningObjective": "Dominar o algoritmo iterativo D-K para síntese de controladores μ-ótimos.",
                                  "commonMistakes": [
                                    "Loop infinito por tol muito pequeno",
                                    "Não atualizar D corretamente entre iterações",
                                    "Ignorar warnings de ill-conditioning"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar e validar o controlador robusto gerado",
                                  "subSteps": [
                                    "Simular resposta em malha fechada com planta nominal e perturbada.",
                                    "Plotar evolução de μ ao longo das iterações e Bode de K final.",
                                    "Verificar robustez via usim ou lsim com Δ aleatórios (wcgain).",
                                    "Comparar performance com H∞ puro via hinfsyn.",
                                    "Exportar K para Simulink e testar em simulação real-time."
                                  ],
                                  "verification": "μ<1 para Δ admissíveis; overshoot <20%, settling time <5s em simulações.",
                                  "estimatedTime": "2 hours",
                                  "materials": [
                                    "Funções: stepinfo, wcgain, usample",
                                    "Simulink para validação",
                                    "Histórico μ armazenado em arrays"
                                  ],
                                  "tips": "Gere 100 Monte Carlo runs para estatísticas de robustez; use grid para análise paramétrica.",
                                  "learningObjective": "Avaliar e validar controladores μ-síntese em cenários reais.",
                                  "commonMistakes": [
                                    "Não testar com Δ full-block",
                                    "Confundir μ structured com H∞",
                                    "Controlador instável por numérica"
                                  ]
                                }
                              ],
                              "practicalExample": "Implemente iteração D-K para um motor DC com incerteza paramétrica de 20% no ganho (Δp=ultidyn('p',[1 1])), peso Wp para rastreamento rampa, Wu para ruído. Converja em 8 iterações com μ=0.85, validando step response com overshoot 10%.",
                              "finalVerifications": [
                                "Código roda sem erros e converge em <20 iterações com μ<1.",
                                "Plots mostram evolução decrescente de μ até platô estável.",
                                "Controlador estabiliza sistema com ||Δ||∞=1.2 (margem >20%).",
                                "Simulação em malha fechada atende specs: rise time <2s, erro steady-state <1%.",
                                "Código comentado e reproduzível em MATLAB script.",
                                "Comparação com H∞ mostra melhoria em robustez."
                              ],
                              "assessmentCriteria": [
                                "Precisão na modelagem de incertezas (estrutura correta, normalização).",
                                "Convergência do loop D-K (μ<1, <15 iterações).",
                                "Qualidade do controlador (performance specs atendidas, robustez via wcgain).",
                                "Análise completa (plots de μ, Bode, step responses).",
                                "Eficiência computacional (tempo <10min, numérica estável).",
                                "Documentação e reproducibilidade do código."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Otimização não-convexa e análise de valores singulares estruturados.",
                                "Programação: Loops iterativos, vetores de histórico e visualização em MATLAB.",
                                "Engenharia Mecânica: Controle robusto em atuadores com variações paramétricas.",
                                "Física: Dinâmica de sistemas lineares invariantes no tempo com perturbações.",
                                "Ciência de Dados: Análise de convergência e validação Monte Carlo."
                              ],
                              "realWorldApplication": "Desenvolvimento de controladores para drones em ventos variáveis (incertezas aerodinâmicas), garantindo estabilidade robusta em missões autônomas, como usado na NASA para veículos espaciais com tolerância a falhas."
                            },
                            "estimatedTime": "3 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "76.4.4.1.1",
                              "76.4.4.2.2"
                            ]
                          },
                          {
                            "id": "76.4.4.3.3",
                            "name": "Avaliar convergência e limitações da μ-síntese",
                            "description": "Diagnosticar falhas de convergência, conservadorismo inerente e estratégias de melhoria como μ-síntese adaptativa ou combinações com LMI.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar fundamentos do algoritmo D-K iterativo e métricas de convergência",
                                  "subSteps": [
                                    "Estude a estrutura do D-K iteration: alternância entre otimização D (escala de incertezas) e K (síntese H∞).",
                                    "Identifique métricas chave: μ upper bound (μ̂), μ lower bound (μ), e critério de convergência (|μ̂ - μ| < ε).",
                                    "Analise condições de parada: número máximo de iterações, tolerância relativa, ou divergência detectada.",
                                    "Revise teoremas de robustez: upper bound garante performance robusta se convergido.",
                                    "Compile uma checklist de logs de convergência gerados por ferramentas como MATLAB hinfsyn ou mucsyn."
                                  ],
                                  "verification": "Crie um diagrama de fluxo do D-K iteration com métricas anotadas e valide com documentação oficial.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Documentação MATLAB Robust Control Toolbox",
                                    "Livro 'Robust and Optimal Control' de Zhou et al.",
                                    "Notebook Jupyter ou MATLAB script básico"
                                  ],
                                  "tips": "Sempre normalize o problema para ganhos unitários iniciais para acelerar convergência.",
                                  "learningObjective": "Compreender as dinâmicas matemáticas e computacionais da convergência no D-K iteration.",
                                  "commonMistakes": [
                                    "Ignorar o papel do escalonamento D em reduzir conservadorismo.",
                                    "Confundir convergência local com global."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Diagnosticar falhas de convergência comuns",
                                  "subSteps": [
                                    "Simule um sistema nominal com incertezas estruturadas usando MATLAB robust-control models.",
                                    "Execute D-K iteration e monitore logs: oscilação de bounds, estagnação, ou NaN/infinito.",
                                    "Identifique causas: ill-conditioning da matriz de incertezas, escalonamento D pobre, ou modelo de planta inadequado.",
                                    "Aplique diagnósticos: plote evolução de μ upper/lower bounds e conditioning numbers ao longo das iterações.",
                                    "Registre padrões de falha em uma tabela (causa, sintoma, evidência)."
                                  ],
                                  "verification": "Gere plots de bounds não convergentes para 2 cenários e explique falhas em relatório curto.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "MATLAB com Robust Control Toolbox (mucsyn, musyn)",
                                    "Sistema de exemplo: planta com incertezas normais (Δ = blkdiag(Δ1,Δ2))"
                                  ],
                                  "tips": "Use log-scale para plots de bounds para visualizar oscilações sutis.",
                                  "learningObjective": "Diagnosticar e categorizar falhas de convergência com base em evidências numéricas.",
                                  "commonMistakes": [
                                    "Atribuir falha apenas ao modelo sem checar escalonamento inicial.",
                                    "Não monitorar múltiplas sementes randômicas para D-scales."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar limitações inerentes como conservadorismo",
                                  "subSteps": [
                                    "Defina conservadorismo: gap persistente entre μ upper e lower bounds mesmo após convergência.",
                                    "Quantifique: compute (μ̂ - μ)/μ * 100% e compare com benchmarks de literatura.",
                                    "Explore causas: aproximações no lemma de small-gain, não-convexidade do problema μ.",
                                    "Teste sensibilidade: varie peso de performance γ e observe impacto no gap.",
                                    "Documente trade-offs: robustez vs. performance em casos conservadores."
                                  ],
                                  "verification": "Relatório com tabela de gaps para 3 níveis de incerteza e interpretação qualitativa.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Scripts MATLAB para análise de gap (mu_upper, mu_lower)",
                                    "Exemplos de benchmarks como East-West benchmark"
                                  ],
                                  "tips": "Inicie com incertezas pequenas para baseline e escale gradualmente.",
                                  "learningObjective": "Quantificar e interpretar conservadorismo como limitação fundamental da μ-síntese.",
                                  "commonMistakes": [
                                    "Interpretar gap pequeno como ausência de conservadorismo sem validação worst-case.",
                                    "Ignorar dependência em estrutura de Δ."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Explorar estratégias de melhoria e validação",
                                  "subSteps": [
                                    "Implemente μ-síntese adaptativa: ajuste online D-scales baseado em dados reais.",
                                    "Teste hibridizações: combine com LMIs para relaxações convexas (ex: YALMIP toolbox).",
                                    "Avalie alternativas: H∞ loop-shaping ou QFT para casos não-convergentes.",
                                    "Valide melhorias: compare métricas pré/pós-melhoria em simulações Monte Carlo.",
                                    "Proponha pipeline: diagnóstico → melhoria → reavaliação."
                                  ],
                                  "verification": "Demonstre melhoria em pelo menos um caso (redução de gap >20%) com código e plots.",
                                  "estimatedTime": "2.5 horas",
                                  "materials": [
                                    "YALMIP ou CVX para LMIs",
                                    "Python Control Systems Library como alternativa open-source"
                                  ],
                                  "tips": "Use paralelização para Monte Carlo em validações para eficiência.",
                                  "learningObjective": "Desenvolver estratégias acionáveis para mitigar limitações da μ-síntese.",
                                  "commonMistakes": [
                                    "Aplicar melhorias sem validar convergência baseline.",
                                    "Sobrestimar ganhos sem testes worst-case."
                                  ]
                                }
                              ],
                              "practicalExample": "Em um controlador de altitude para drone com incertezas em aerodinâmica (Δ massa 20%, Δ arrasto 15%), execute D-K iteration no MATLAB. Observe não-convergência após 20 iterações (gap 35%), diagnostique ill-conditioning, aplique D-adaptativo reduzindo gap para 12%, e valide robustez com 100 simulações.",
                              "finalVerifications": [
                                "Pode gerar e interpretar plots de μ-bounds para casos convergentes e não-convergentes.",
                                "Identifica corretamente 3 causas comuns de falha de convergência em logs D-K.",
                                "Quantifica conservadorismo com gap métrico e trade-offs associados.",
                                "Propõe pelo menos 2 estratégias de melhoria viáveis com justificativa.",
                                "Valida melhorias via análise worst-case ou Monte Carlo.",
                                "Explica limitações em contexto real-world como aeroespacial."
                              ],
                              "assessmentCriteria": [
                                "Precisão no diagnóstico de falhas (80% acerto em casos teste).",
                                "Profundidade na análise de conservadorismo (gap quantificado e causes listadas).",
                                "Criatividade e viabilidade das estratégias de melhoria (testadas numericamente).",
                                "Qualidade de visualizações e relatórios (plots claros, tabelas estruturadas).",
                                "Integração de teoria com prática (referências a teoremas e simulações).",
                                "Tempo de execução e eficiência computacional demonstrada."
                              ],
                              "crossCurricularConnections": [
                                "Matemática Numérica: Condicionamento de matrizes e iterações não-convexas.",
                                "Otimização: Problemas minimax e relaxações LMIs.",
                                "Inteligência Artificial: Adaptação online similar a reinforcement learning.",
                                "Engenharia de Software: Debugging numérico e análise de logs.",
                                "Física Aplicada: Modelagem de incertezas em sistemas dinâmicos."
                              ],
                              "realWorldApplication": "Na indústria aeroespacial (ex: Boeing), avaliar convergência da μ-síntese em controladores de flight envelope protection previne falhas em missões com incertezas de vento, reduzindo conservadorismo para otimizar combustível e segurança."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "76.4.4.3.1"
                            ]
                          },
                          {
                            "id": "76.4.4.3.4",
                            "name": "Aplicar μ-síntese em exemplo monovariável",
                            "description": "Projetar controlador para planta com incertezas estruturadas, validando robustez via simulações e comparação com H∞ puro.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Modelar a planta monovariável com incertezas estruturadas",
                                  "subSteps": [
                                    "Identifique a função de transferência nominal da planta G(s).",
                                    "Defina as incertezas estruturadas Δ(s), como blocos normais ou paramétricos convertidos em forma estruturada.",
                                    "Construa o modelo generalizado P com entradas/saídas para Δ, w (pesos de performance) e K (controlador).",
                                    "Verifique a estrutura do bloco Δ usando o Structured Singular Value (μ).",
                                    "Ajuste pesos de performance w_p e w_u para especificações de robustez e desempenho."
                                  ],
                                  "verification": "Modelo P é criado e μ_upper(P(jω)) é computável sem erro no MATLAB.",
                                  "estimatedTime": "1-2 horas",
                                  "materials": [
                                    "MATLAB com Robust Control Toolbox",
                                    "Documentação de μ-síntese (Skogestad & Postlethwaite)",
                                    "Exemplo de planta monovariável (e.g., G(s)=1/(s^2 + s +1))"
                                  ],
                                  "tips": "Use blkdiag para definir estrutura de Δ; comece com incertezas reais normais para simplicidade.",
                                  "learningObjective": "Compreender e implementar modelagem de incertezas estruturadas em problemas de controle robusto.",
                                  "commonMistakes": "Ignorar normalização das incertezas (||Δ||_∞ ≤1); definir pesos inadequados que levam a soluções infactíveis."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Formular o problema padrão de μ-síntese",
                                  "subSteps": [
                                    "Estruture o problema como encontrar K tal que sup_ω μ[T_{zw}(P,K)(jω)] < γ.",
                                    "Defina o interconnection system P com partições para Δ, K e sinais de performance.",
                                    "Implemente funções para calcular μ_upper e μ_lower bounds.",
                                    "Escolha γ inicial via análise de H∞ ou bisection search.",
                                    "Teste factibilidade inicial com K=0 ou controlador simples."
                                  ],
                                  "verification": "γ inicial é finita e μ(P,K=0) < γ para planta nominal.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "MATLAB Robust Control Toolbox (musv, mussv)",
                                    "Tutoriais MATLAB para μ-computação"
                                  ],
                                  "tips": "Use musyn para verificação rápida; plot μ vs ω para visualizar picos.",
                                  "learningObjective": "Formular corretamente o problema de síntese μ para minimizar o structured singular value.",
                                  "commonMistakes": "Confundir partições de P (erros em índices de entradas/saídas); escolher γ muito baixo inicialmente."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar o algoritmo D-K iterativo",
                                  "subSteps": [
                                    "Inicie com D0 = I e sintetize K0 via H∞ em planta D0*P*D0^{-1}.",
                                    "Atualize D1 otimizando μ(D*P*D^{-1}) via função dscale ou mu-tools.",
                                    "Itere alternando síntese de K (hinfsyn) e escalonamento D até convergência (||μ - γ|| < tol).",
                                    "Monitore γ_k, μ_upper e condição de estabilidade em cada iteração.",
                                    "Pare quando γ não diminui ou após max_iter (tipicamente 5-10)."
                                  ],
                                  "verification": "Algoritmo converge com γ_final < γ_inicial e μ(T)<1.",
                                  "estimatedTime": "2-3 horas",
                                  "materials": [
                                    "MATLAB sys robust toolbox (musyn, dscale)",
                                    "Código exemplo de D-K iteration"
                                  ],
                                  "tips": "Use tol=1e-2 para convergência; plote evolução de γ_k para diagnóstico.",
                                  "learningObjective": "Executar iterações D-K para síntese de controladores μ-ótimos.",
                                  "commonMistakes": "Não reescalonar D corretamente (D deve ser unitário em cada freq); ignorar não-convergência (aumentar max_iter)."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Validar robustez via simulações e comparar com H∞",
                                  "subSteps": [
                                    "Simule malha fechada com planta nominal e perturbada por Δ aleatório (||Δ||≤1).",
                                    "Calcule margens de robustez (μ_margem, ganho) e responda temporal.",
                                    "Sintetize controlador H∞ equivalente (γ_H∞ via hinfsyn em P).",
                                    "Compare desempenho: overshoot, tempo assentamento, robustez μ vs H∞.",
                                    "Gere plots de Bode, step response e μ-plot para análise."
                                  ],
                                  "verification": "Controlador μ estabiliza 95% das plantas Δ aleatórias; γ_μ < γ_H∞.",
                                  "estimatedTime": "1-2 horas",
                                  "materials": [
                                    "Simulink para simulações",
                                    "wcgain para análise worst-case"
                                  ],
                                  "tips": "Gere 100 Δ aleatórios para estatísticas; use loopgain para análise de estabilidade.",
                                  "learningObjective": "Avaliar superioridade da μ-síntese sobre H∞ em incertezas estruturadas.",
                                  "commonMistakes": "Simular apenas nominal (perder robustez); escalas erradas em plots."
                                }
                              ],
                              "practicalExample": "Para planta G(s) = 1/(s^2 + 0.2s + 1) com incerteza Δ_p = δ/ (1 + τ s), δ∈[-0.5,0.5], τ=0.1: modele Δ como bloco real normal, pese com w_Δ=0.5, w_p=1/(s+1), w_u=0.1; aplique D-K para γ≈1.2, valide estabilizando variações de polo em 20%.",
                              "finalVerifications": [
                                "Controlador Kμ estabiliza planta nominal e 95% das perturbações Δ estruturadas.",
                                "μ[T_{zw}]_∞ <1 para γ encontrado.",
                                "Resposta temporal atende specs (overshoot<20%, assentamento<5s).",
                                "γ_μ < γ_H∞ em pelo menos 10%.",
                                "Margens de fase/ganho >45°/6dB.",
                                "Simulações worst-case sem instabilidade."
                              ],
                              "assessmentCriteria": [
                                "Precisão da modelagem P (μ computado sem NaN).",
                                "Convergência D-K em <10 iterações com redução γ>15%.",
                                "Robustez demonstrada em simulações (estatísticas de performance).",
                                "Comparação quantitativa clara com H∞ (tabelas/plots).",
                                "Relatório com análise de erros e limitações.",
                                "Código reproduzível e comentado."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Valores singulares estruturados e otimização não-convexa.",
                                "Programação: Implementação numérica em MATLAB (otimizadores iterativos).",
                                "Física: Modelagem dinâmica de sistemas com incertezas paramétricas.",
                                "Engenharia de Software: Validação e testes de robustez em simulações."
                              ],
                              "realWorldApplication": "Projeto de controladores para atuadores aeroespaciais com variações de massa/fluidos (e.g., flaps de aeronaves), garantindo estabilidade apesar de incertezas estruturadas em parâmetros nominais."
                            },
                            "estimatedTime": "2.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "76.4.4.3.2"
                            ]
                          }
                        ]
                      }
                    ]
                  }
                ]
              },
              {
                "id": "10.1.6",
                "name": "Métodos Algorítmicos de Projeto",
                "description": "Abordagens baseadas em otimização de parâmetros para o projeto de controladores.",
                "totalSkills": 46,
                "atomicTopics": [
                  {
                    "id": "10.1.6.1",
                    "name": "Formulação Paramétrica do Controlador",
                    "description": "Representação do controlador em termos de parâmetros finitos para otimização em sistemas monovariáveis.",
                    "individualConcepts": [
                      {
                        "id": "10.1.6.1.1.1",
                        "name": "Parametrização de Controladores Estabilizadores",
                        "description": "Representação geral de todos os controladores que estabilizam uma planta monovariável utilizando parâmetros livres, baseada na parametrização de Youla-Kucera.",
                        "specificSkills": [
                          {
                            "id": "10.1.6.1.1.1.1",
                            "name": "Identificar a estrutura da parametrização de Youla-Kucera",
                            "description": "Explicar e derivar a forma Q-parametrizada para controladores estabilizadores de plantas LIT monovariáveis estáveis ou com estabilizadores conhecidos, incluindo o papel do filtro de Youla.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Fundamentos de Plantas LIT e Estabilizadores Nominais",
                                  "subSteps": [
                                    "Defina planta LIT monovariável estável ou com estabilizador conhecido (C0).",
                                    "Revise funções de transferência e estabilidade em malha fechada.",
                                    "Identifique fatores de coprimes à direita (N, D) e à esquerda (X, Y) da planta P = N D^{-1}.",
                                    "Construa identidades de Bezout: X N - Y D = I.",
                                    "Verifique estabilidade de C0 usando teorema de estabilização."
                                  ],
                                  "verification": "Desenhe diagrama de blocos da planta com C0 e confirme estabilidade via polos da malha fechada.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Livro de controle avançado (ex: Zhou, Doyle), MATLAB/Simulink para simulações"
                                  ],
                                  "tips": "Comece com plantas simples como P(s) = 1/(s+1) para intuição.",
                                  "learningObjective": "Compreender pré-requisitos para parametrização.",
                                  "commonMistakes": [
                                    "Confundir fatores coprimes à direita/esquerda",
                                    "Ignorar invertibilidade de D"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Introduzir o Teorema de Youla-Kucera",
                                  "subSteps": [
                                    "Enuncie o teorema: Todos os controladores estabilizadores são da forma C = (X + D Q)(Y - N Q)^{-1} para Q estável.",
                                    "Derive a dupla Bezout para o controlador nominal: U C0 N - V C0 D = I.",
                                    "Mostre que C estabiliza P iff Q é estável e ||Q||_∞ < 1/||T|| para robustez.",
                                    "Discuta o papel de Q como parâmetro livre estável.",
                                    "Implemente em diagrama de blocos a estrutura parametrizada."
                                  ],
                                  "verification": "Escreva a fórmula exata de C(Q) e substitua Q=0 para recuperar C0.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Notas de aula sobre Youla-Kucera",
                                    "Paper original de Youla (1976)"
                                  ],
                                  "tips": "Use LaTeX ou Mathcad para derivações simbólicas.",
                                  "learningObjective": "Enunciar e justificar o teorema fundamental.",
                                  "commonMistakes": [
                                    "Esquecer invertibilidade de (Y - N Q)",
                                    "Confundir parametrização com H-infinito"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Derivar a Forma Q-Parametrizada Detalhada",
                                  "subSteps": [
                                    "Comece com equação de malha fechada T = C P (1 + C P)^{-1}.",
                                    "Substitua C(Q) e simplifique para T = N (U + D Q) com estabilidade garantida por Q estável.",
                                    "Derive S = (1 + C P)^{-1} = (Y - N Q) D^{-1}.",
                                    "Construa o filtro de Youla como o bloco que insere Q na estrutura.",
                                    "Simule variação de Q e observe impacto em T e S."
                                  ],
                                  "verification": "Calcule T e S para Q específico e confirme estabilidade via Nyquist.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "MATLAB Control System Toolbox",
                                    "Exemplos numéricos de Francis et al."
                                  ],
                                  "tips": "Use função youla() no MATLAB para automação.",
                                  "learningObjective": "Derivar expressões fechadas para sensibilidade e complementar.",
                                  "commonMistakes": [
                                    "Erro algébrico em simplificação de frações",
                                    "Não normalizar fatores coprimes"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar o Papel do Filtro de Youla e Estrutura Geral",
                                  "subSteps": [
                                    "Desenhe o diagrama do filtro de Youla: entrada erro, saída injeção via Q.",
                                    "Explique como o filtro permite todos os controladores sem cancelamentos instáveis.",
                                    "Discuta propriedades: todos C(Q) têm mesmo grau de estabilidade que C0.",
                                    "Compare com parametrização de coprimes estáveis (Vidyasagar).",
                                    "Teste com planta instável usando estabilizador conhecido."
                                  ],
                                  "verification": "Implemente filtro em Simulink e varie Q para gerar família de controladores.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Simulink library para controle",
                                    "Tutoriais online sobre Youla"
                                  ],
                                  "tips": "Grave animação de variação de Q para visualização.",
                                  "learningObjective": "Identificar e diagramar a estrutura completa.",
                                  "commonMistakes": [
                                    "Confundir filtro de Youla com filtro de Kalman",
                                    "Ignorar causalidade de Q"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Verificar e Aplicar a Parametrização",
                                  "subSteps": [
                                    "Escolha planta exemplo e compute fatores coprimes via MATLAB coprime()",
                                    "Gere 3 controladores diferentes variando Q (ex: Q=0, Q=k/(s+a))",
                                    "Avalie desempenho via índices LQG ou robustez.",
                                    "Discuta limitações: Q deve ser próprio para implementação.",
                                    "Resuma estrutura: C(Q) = C0 + filtro_Q * erro."
                                  ],
                                  "verification": "Lista todos componentes da estrutura e simule estabilidade para Q arbitrário estável.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Código MATLAB pronto para Youla"
                                  ],
                                  "tips": "Salve scripts para reutilização em projetos maiores.",
                                  "learningObjective": "Aplicar estrutura em exemplo concreto.",
                                  "commonMistakes": [
                                    "Q instável levando a perda de estabilidade",
                                    "Não checar grau de Q"
                                  ]
                                }
                              ],
                              "practicalExample": "Para planta P(s) = 1/(s-1) (instável), use C0(s) = (s+2)/(s-0.5). Compute fatores coprimes, insira Q(s) = 0.5 e derive C(Q), simulando em MATLAB para mostrar estabilidade mantida.",
                              "finalVerifications": [
                                "Enuncie corretamente a fórmula C(Q) = (X + D Q)(Y - N Q)^{-1}.",
                                "Desenhe diagrama preciso do filtro de Youla.",
                                "Derive T(Q) e S(Q) sem erros algébricos.",
                                "Simule 2 controladores diferentes e confirme estabilidade.",
                                "Explique por que Q=0 recupera C0.",
                                "Identifique quando usar para plantas com estabilizador conhecido."
                              ],
                              "assessmentCriteria": [
                                "Precisão na derivação da parametrização (90% correto).",
                                "Correta identificação de fatores coprimes e Bezout.",
                                "Diagrama de estrutura completo e legível.",
                                "Exemplo prático com simulação funcional.",
                                "Explicação clara do papel do filtro de Youla.",
                                "Análise de limitações e robustez."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Álgebra de Youla (frações estritas, coprimes).",
                                "Programação: Implementação em MATLAB/Simulink para controle.",
                                "Física: Modelagem de sistemas dinâmicos LIT.",
                                "Otimização: Escolha de Q via H2/H∞.",
                                "Eletrônica: Implementação digital de controladores parametrizados."
                              ],
                              "realWorldApplication": "Projeto de controladores robustos em processos industriais como destilação química, onde plantas têm incertezas; usado em aeronáutica para autopilotos adaptáveis e em robótica para tracking com perturbações."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.6.1.1.1.2",
                            "name": "Calcular controladores estabilizadores parametrizados",
                            "description": "Dado uma planta P(s), computar um controlador central C0(s) estabilizador e gerar a família de controladores C(s) = (C0 + Q)/(1 - C0 Q P) para Q estável.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Modelar e analisar a planta P(s)",
                                  "subSteps": [
                                    "Obtenha a função de transferência P(s) da planta em fração própria coprima.",
                                    "Realize a decomposição em fatores para identificar polos e zeros.",
                                    "Verifique a estabilidade intrínseca da planta (polos no semiplano direito?).",
                                    "Coprime fatorize P(s) = N_p / D_p onde N_p e D_p são coprimos e estáveis.",
                                    "Documente propriedades como ordem, ganho DC e tipo do sistema."
                                  ],
                                  "verification": "Confirme que P(s) está em forma bipropria com fatores Bezout verificados (existe X, Y tais que X N_p + Y D_p = 1).",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Software MATLAB/Octave ou Python (Control Systems Library)",
                                    "Papel e calculadora para cálculos manuais",
                                    "Referência: Livro de Doyle ou Zhou sobre robust control"
                                  ],
                                  "tips": "Use tf() no MATLAB para funções de transferência; sempre normalize o denominador monico.",
                                  "learningObjective": "Dominar a representação bipropria da planta para parametrização.",
                                  "commonMistakes": [
                                    "Ignorar fatorização coprima levando a instabilidade",
                                    "Erros em polos/zeros causando análise errada",
                                    "Não verificar coprimidade"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Projetar o controlador estabilizador central C0(s)",
                                  "subSteps": [
                                    "Escolha uma estrutura inicial para C0(s), como PID ou lead-lag.",
                                    "Use métodos como root locus ou Nyquist para estabilizar o loop P C0.",
                                    "Ajuste parâmetros até que o laço unitário feedback seja estável.",
                                    "Coprime fatorize C0(s) = N_c0 / D_c0 bipropriamente.",
                                    "Verifique as equações de Bezout para o par (P, C0)."
                                  ],
                                  "verification": "Simule o diagrama de Bode ou step response do sistema fechado P/(1+P C0); todos polos no semiplano esquerdo.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "MATLAB Control System Toolbox (rlocus, nyquist, step)",
                                    "Templates de controladores PID",
                                    "Folha de especificações de performance (overshoot <20%, settling <5s)"
                                  ],
                                  "tips": "Comece com alto ganho proporcional; adicione integrador se necessário para rejeição de distúrbios.",
                                  "learningObjective": "Aplicar técnicas de design para obter um estabilizador C0(s) robusto.",
                                  "commonMistakes": [
                                    "Controlador de ordem muito alta causando cancelamentos frágeis",
                                    "Não testar estabilidade em múltiplas frequências",
                                    "Ignorar limites atuador"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Construir a parametrização da família C(s) = (C0 + Q)/(1 - C0 Q P)",
                                  "subSteps": [
                                    "Escolha Q(s) estável de ordem adequada (geralmente menor que P+C0).",
                                    "Substitua na fórmula: numerador = C0 + Q, denominador = 1 - C0 Q P.",
                                    "Simplifique a fração própria de C(s), cancelando fatores comuns estáveis.",
                                    "Expresse C(s) em termos biproprios: C = (X + D_p Q)(Y - N_p Q)^{-1}.",
                                    "Gere 2-3 exemplos de Q(s) variando parâmetros."
                                  ],
                                  "verification": "Para Q=0, recupera C(s)=C0; denominador sem zeros instáveis.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Symbolic Math Toolbox no MATLAB para simplificação",
                                    "Python SymPy para manipulação simbólica",
                                    "Planilha para rastrear parâmetros de Q"
                                  ],
                                  "tips": "Escolha Q com polos reais negativos para simplicidade; use low-pass filters para Q.",
                                  "learningObjective": "Implementar a parametrização de Youla-Kucera corretamente.",
                                  "commonMistakes": [
                                    "Fórmula invertida (confundir ordem P e C0)",
                                    "Não garantir Q estável",
                                    "Cancelamentos não-estáveis"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificar e analisar a família de controladores parametrizados",
                                  "subSteps": [
                                    "Simule step responses para diferentes Q(s).",
                                    "Analise robustez via margens de ganho/fase ou H-infinity norm.",
                                    "Compare performance: tempo de assentamento, overshoot entre C0 e outros C.",
                                    "Teste sensibilidade a perturbações em P(s).",
                                    "Documente trade-offs (ex: Q alto melhora tracking mas reduz robustez)."
                                  ],
                                  "verification": "Todos C(s) estabilizam P(s); pelo menos 3 Q mostram variação parametrizada.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Simulink para simulações não-lineares",
                                    "Bode plots para análise frequência",
                                    "Relatório template em LaTeX/Word"
                                  ],
                                  "tips": "Varie ganho de Q para ver efeitos; plote Nichols chart para robustez.",
                                  "learningObjective": "Avaliar propriedades da família parametrizada.",
                                  "commonMistakes": [
                                    "Não testar Q no limite de estabilidade",
                                    "Ignorar efeitos não-lineares",
                                    "Análise apenas em tempo discreto"
                                  ]
                                }
                              ],
                              "practicalExample": "Para P(s) = 1/(s(s+1)), encontre C0(s) = (0.5 s + 1)/(0.5 s + 2) estabilizador via root locus. Então, com Q(s) = 0.1/(s+0.1), compute C(s) = [C0 + Q]/[1 - C0 Q P]. Simule step response mostrando settling time reduzido de 10s para 4s.",
                              "finalVerifications": [
                                "C0(s) estabiliza P(s) (polos fechados no LHP).",
                                "Recuperação de C0 quando Q=0.",
                                "Todos C(s) na família têm denominador estável para Q estável.",
                                "Pelo menos 3 simulações mostram estabilidade e variação de performance.",
                                "Margens de fase >45° e ganho >6dB para membros da família.",
                                "Fatores biproprios coprimos verificados."
                              ],
                              "assessmentCriteria": [
                                "Precisão na fatorização bipropria (sem erros algébricos).",
                                "Estabilidade comprovada via simulação ou análise (RLC).",
                                "Correta implementação da fórmula parametrizada.",
                                "Análise quantitativa de performance (métricas ITSE, overshoot).",
                                "Robustez demonstrada para variações de Q.",
                                "Documentação clara com plots e equações.",
                                "Eficiência computacional (ordem C(s) razoável)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Álgebra de frações próprias e equações de Bezout.",
                                "Programação: Simulação numérica em MATLAB/Python (SISO tools).",
                                "Física: Modelagem de sistemas dinâmicos lineares invariantes no tempo.",
                                "Engenharia de Software: Implementação de algoritmos de controle parametrizado.",
                                "Estatística: Análise de sensibilidade e Monte Carlo para Q aleatórios."
                              ],
                              "realWorldApplication": "Em automação industrial, como estabilizar níveis de tanques em plantas químicas ou atitude de drones, onde a parametrização permite tunar performance (rápida resposta vs. robustez a incertezas modelo) sem redesign completo do controlador."
                            },
                            "estimatedTime": "3 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.6.1.1.1.3",
                            "name": "Analisar propriedades de robustez na parametrização",
                            "description": "Avaliar como a escolha de Q afeta a robustez do laço de controle fechado em face de incertezas aditivas ou multiplicativas na planta.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Fundamentos da Parametrização de Controladores Estabilizadores",
                                  "subSteps": [
                                    "Estude a estrutura padrão da parametrização: C(s) = Q(s) / (1 - P(s)Q(s)), onde P(s) é a planta nominal e Q(s) é o parâmetro livre.",
                                    "Identifique condições de estabilidade: ||Q||_∞ < 1/||P||_∞ para estabilidade interna.",
                                    "Revise definições de robustez: estabilidade e desempenho sob incertezas na planta.",
                                    "Liste tipos de incertezas: aditivas (δP) e multiplicativas (P(1 + Δ)).",
                                    "Desenhe diagramas de blocos para visualizar o laço fechado."
                                  ],
                                  "verification": "Resuma em um diagrama ou equação como Q estabiliza o sistema nominal.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Livro de controle avançado (ex: Zhou Robust Control), MATLAB/Simulink, notas de aula.",
                                  "tips": "Use coprime factorization para entender melhor a parametrização Youla.",
                                  "learningObjective": "Compreender a relação fundamental entre Q e estabilidade nominal.",
                                  "commonMistakes": "Confundir Q com o controlador direto; ignorar normalização de P."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Modelar Incertezas Aditivas e Multiplicativas na Planta",
                                  "subSteps": [
                                    "Defina incerteza aditiva: P_pert = P + W_a Δ_a, onde ||Δ_a||_∞ ≤ 1.",
                                    "Defina incerteza multiplicativa: P_pert = P (1 + W_m Δ_m), com ||Δ_m||_∞ ≤ 1.",
                                    "Escolha funções de peso W_a e W_m baseadas em dados da planta real.",
                                    "Calcule o conjunto de plantas perturbadas para um exemplo simples (ex: integrador).",
                                    "Implemente modelos no MATLAB usando uncertain objects ou LFTs."
                                  ],
                                  "verification": "Gere gráficos de singular values para plantas nominais e perturbadas.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "MATLAB Robust Control Toolbox, exemplos de plantas (ex: DC motor model).",
                                  "tips": "Comece com incertezas de baixa frequência para simplicidade.",
                                  "learningObjective": "Modelar realisticamente incertezas comuns em sistemas de controle.",
                                  "commonMistakes": "Escolher pesos W inadequados que não capturam incertezas reais; usar normas erradas (H2 vs H∞)."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar Impacto da Escolha de Q na Robustez do Laço Fechado",
                                  "subSteps": [
                                    "Calcule a função de robustez: ||T_zw||_∞ < 1 para estabilidade robusta, onde T_zw é o sistema generalizado.",
                                    "Avalie sensibilidade: ∂/∂Q da margem de ganho/fase sob perturbações.",
                                    "Simule respostas em malha fechada para diferentes Q (ex: Q baixo vs alto ganho).",
                                    "Compute normas H∞ de funções sensíveis: S, KS, T para aditiva/multiplicativa.",
                                    "Compare gráficos de Bode para nominal vs worst-case cenários."
                                  ],
                                  "verification": "Produza tabela comparativa de ||T||_∞ para 3 escolhas de Q.",
                                  "estimatedTime": "90 minutos",
                                  "materials": "Simulink para simulações, mu-toolbox para análise estrutural.",
                                  "tips": "Use Q com roll-off suave para melhorar robustez em altas frequências.",
                                  "learningObjective": "Quantificar como variações em Q afetam margens de robustez.",
                                  "commonMistakes": "Ignorar direção das incertezas; focar só em nominal sem worst-case."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Avaliar e Otimizar Q para Máxima Robustez",
                                  "subSteps": [
                                    "Defina métrica de robustez: minimizar γ = ||[W_p S; W_u KS; W_t T]||_∞.",
                                    "Otimize Q via iterações ou solvers H∞ (ex: hinfsyn).",
                                    "Teste robustez com Monte Carlo: gere 100 perturbações e verifique estabilidade.",
                                    "Ajuste trade-offs: robustez vs desempenho (risco de conservadorismo).",
                                    "Documente conclusões em relatório com gráficos."
                                  ],
                                  "verification": "Demonstre que o Q otimizado estabiliza 95% das perturbações simuladas.",
                                  "estimatedTime": "75 minutos",
                                  "materials": "MATLAB Optimization Toolbox, relatório template.",
                                  "tips": "Inclua penalidades em Q para evitar controladores irreais.",
                                  "learningObjective": "Aplicar análise para selecionar Q robusto otimizado.",
                                  "commonMistakes": "Sobre-otimizar levando a controlador frágil; negligenciar constraints físicas."
                                }
                              ],
                              "practicalExample": "Para um motor DC com planta P(s) = 1/(s(s+1)), adicione incerteza multiplicativa W_m(s) = 0.2 para frequências <10 rad/s. Teste Q1(s) = 1/(s+2) vs Q2(s) = 0.5/(s+1), simulando step response sob ±20% variação de ganho e verificando overshoot <20% em worst-case.",
                              "finalVerifications": [
                                "Calcular corretamente ||T_zw||_∞ <1 para incertezas modeladas.",
                                "Gerar gráficos Bode mostrando impacto de Q na estabilidade robusta.",
                                "Simular e confirmar estabilidade em pelo menos 3 cenários perturbados.",
                                "Explicar verbalmente trade-off entre ganho de Q e robustez.",
                                "Otimizar Q reduzindo γ em pelo menos 10%.",
                                "Documentar análise em relatório com evidências numéricas."
                              ],
                              "assessmentCriteria": [
                                "Precisão matemática nas normas H∞ e modelagem de incertezas (30%).",
                                "Qualidade das simulações e visualizações (25%).",
                                "Profundidade da análise de impacto de Q (20%).",
                                "Criatividade na otimização e trade-offs (15%).",
                                "Clareza do relatório e explicações (10%)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Análise de singular values e otimização convexa.",
                                "Programação: Implementação em MATLAB para simulações numéricas.",
                                "Física: Modelagem dinâmica de sistemas reais com perturbações.",
                                "Estatística: Análise Monte Carlo para robustez probabilística."
                              ],
                              "realWorldApplication": "Em controle de drones, analisar Q para robustez contra variações de massa (multiplicativa) ou vento (aditiva), garantindo estabilidade em voo autônomo apesar de incertezas de fabricação ou ambiente."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.6.1.1.2",
                        "name": "Representação com Parâmetros Finitos",
                        "description": "Aproximação do controlador parametrizado por uma estrutura de ordem finita com parâmetros reais para facilitar a otimização numérica.",
                        "specificSkills": [
                          {
                            "id": "10.1.6.1.1.2.1",
                            "name": "Escolher estruturas parametrizadas finitas",
                            "description": "Selecionar e justificar formas como PID, lead-lag ou polos-zero finitos para representar Q(s) ou C(s) com 3 a 6 parâmetros livres em sistemas monovariáveis.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar estruturas parametrizadas comuns para controladores",
                                  "subSteps": [
                                    "Estude a estrutura PID: Kp + Ki/s + Kd s, identificando seus 3 parâmetros livres.",
                                    "Analise compensadores lead-lag: formas como (s/z1 +1)/(s/p1 +1) * (s/z2 +1)/(s/p2 +1), contando parâmetros (4-6).",
                                    "Examine representações polos-zero finitas: numerador e denominador de ordem baixa com 3-6 coeficientes livres.",
                                    "Compare limitações: PID para sistemas de 1ª/2ª ordem, lead-lag para fase/amplitude, polos-zero para modelagem geral.",
                                    "Registre prós e contras de cada uma em uma tabela."
                                  ],
                                  "verification": "Tabela completa com pelo menos 3 estruturas, 3 prós/contras cada, e contagem de parâmetros.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Livro de Ogata ou Franklin (Teoria de Controle), notas de aula, MATLAB para plotar respostas em frequência.",
                                  "tips": "Use diagramas de Bode para visualizar efeitos de cada estrutura.",
                                  "learningObjective": "Identificar e descrever precisamente as estruturas PID, lead-lag e polos-zero finitas com contagem de parâmetros.",
                                  "commonMistakes": "Confundir parâmetros fixos (como s) com livres; ignorar ordem relativa num/den."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar o sistema monovariável Q(s) ou C(s)",
                                  "subSteps": [
                                    "Obtenha o modelo do planta: função de transferência Q(s), grau num/den.",
                                    "Identifique características: ordem do sistema, polos/dominantes zeros, requisitos de desempenho (fase margem, ganho).",
                                    "Calcule número de parâmetros necessários: mire 3-6 livres para flexibilidade sem overfitting.",
                                    "Avalie complexidade: baixa ordem → PID; necessidade de compensação → lead-lag; modelagem precisa → polos-zero.",
                                    "Plote respostas: degrau, rampa, Bode para diagnosticar problemas."
                                  ],
                                  "verification": "Relatório com análise do modelo: ordem, polos/zeros principais, plots de Bode/degrau.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "MATLAB/Simulink, função tf() para modelos, toolbox Control Systems.",
                                  "tips": "Sempre normalize o modelo para ganho DC=1 para comparações justas.",
                                  "learningObjective": "Diagnosticar características do sistema que influenciam a escolha da estrutura parametrizada.",
                                  "commonMistakes": "Não considerar estabilidade inerente ou ignorar não-minimum phase zeros."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Selecionar a estrutura apropriada",
                                  "subSteps": [
                                    "Defina critérios: nº parâmetros (3-6), capacidade de atender specs (overshoot <10%, PM>45°).",
                                    "Teste candidatas: PID se ordem≤2; lead-lag se precisa boost fase; polos-zero se >2 polos.",
                                    "Monte Q(s) ou C(s) candidato: ex. PID para 3 params, lead-lag duplo para 6.",
                                    "Simule sintonia inicial: Ziegler-Nichols ou manual para viabilidade.",
                                    "Escolha a mais simples que atende 80% specs."
                                  ],
                                  "verification": "Lista de 2-3 candidatas com simulações iniciais e seleção justificada.",
                                  "estimatedTime": "75 minutos",
                                  "materials": "MATLAB pidtune(), rlocus() para root locus, sisotool para análise.",
                                  "tips": "Priorize estruturas com menos parâmetros para robustez.",
                                  "learningObjective": "Aplicar critérios quantitativos para selecionar estrutura com parâmetros limitados.",
                                  "commonMistakes": "Escolher estrutura muito complexa levando a síntese instável."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Justificar e validar a escolha",
                                  "subSteps": [
                                    "Escreva justificativa: link entre análise do sistema e estrutura (ex. 'Lead-lag para +60° fase em ωc').",
                                    "Otimize parâmetros: use otimização (fmincon) ou loop manual para specs.",
                                    "Compare com alternativas: métricas como ITAE, tempo de estabilização.",
                                    "Analise sensibilidade: variação ±10% params e impacto em performance.",
                                    "Documente em relatório: estrutura final, params, plots."
                                  ],
                                  "verification": "Relatório com justificativa, params otimizados, comparação e análise de robustez.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "MATLAB Optimization Toolbox, stepinfo() para métricas.",
                                  "tips": "Use margens de ganho/fase como métrica principal de justificação.",
                                  "learningObjective": "Justificar seleção com evidências quantitativas e validar via simulação.",
                                  "commonMistakes": "Justificativa vaga sem números; não testar robustez."
                                }
                              ],
                              "practicalExample": "Para um motor DC com Q(s) = 1/(s(s+1)), selecione PID (3 params) para tracking rampa com erro nulo, justificando: ordem 2, necessidade integral para tipo 1→2, derivativo para amortecimento. Simule: Kp=2.4, Ki=1.2, Kd=1, PM=60°.",
                              "finalVerifications": [
                                "Estrutura escolhida tem exatamente 3-6 parâmetros livres.",
                                "Justificativa liga análise do sistema a specs atendidas (plots Bode/degrau).",
                                "Simulações mostram estabilidade e performance (overshoot<15%, settling<5s).",
                                "Comparação com pelo menos uma alternativa falha.",
                                "Análise de sensibilidade confirma robustez.",
                                "Relatório completo sem erros matemáticos."
                              ],
                              "assessmentCriteria": [
                                "Precisão na contagem e descrição de parâmetros livres (100%).",
                                "Qualidade da análise do sistema (plots corretos, diagnóstico).",
                                "Adequação da seleção (atende specs com estrutura mínima).",
                                "Profundidade da justificativa (quantitativa, com métricas).",
                                "Validação via simulação (múltiplos cenários testados).",
                                "Clareza e organização do relatório."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Análise de polos/zeros e funções racionais.",
                                "Programação: Implementação em MATLAB para otimização e simulação.",
                                "Física: Modelagem dinâmica de sistemas reais (motores, processos).",
                                "Estatística: Análise de sensibilidade e robustez probabilística."
                              ],
                              "realWorldApplication": "Em automação industrial, escolher PID para controladores PLC em fornos (temperatura estável com 3 params simples) ou lead-lag em servos de robótica para precisão de trajetória com compensação de fase, reduzindo custo de hardware complexo."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.6.1.1.2.2",
                            "name": "Implementar aproximação racional de Q(s)",
                            "description": "Aproximar funções estáveis Q(s) por frações racionais de ordem baixa usando métodos como padé ou otimização de mínimos quadrados.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar a função Q(s) e selecionar método de aproximação",
                                  "subSteps": [
                                    "Analise a estabilidade de Q(s) usando critérios como Routh-Hurwitz ou plot de pólo-zero.",
                                    "Defina a ordem desejada da fração racional (ex: ordem baixa, n=2-4).",
                                    "Escolha o método: Padé para delays ou LS para ajuste geral.",
                                    "Colete dados de frequência ou amostras temporais de Q(s).",
                                    "Defina tolerâncias de erro (ex: 1% em magnitude)."
                                  ],
                                  "verification": "Confirme estabilidade via toolbox (pzmap) e anote ordem e método escolhido em relatório.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "MATLAB com Control System Toolbox; função Q(s) simbólica ou numérica.",
                                  "tips": "Comece com Padé para simplicidade em delays; use tf() para representar Q(s).",
                                  "learningObjective": "Identificar requisitos e preparar dados para aproximação racional precisa.",
                                  "commonMistakes": "Ignorar instabilidades em Q(s); escolher ordem alta desnecessariamente."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar aproximação por Padé",
                                  "subSteps": [
                                    "Use pade(Q(s), n) no MATLAB para gerar numerador e denominador.",
                                    "Converta para tf(num, den) e plote Bode de Q(s) original vs. aproximação.",
                                    "Ajuste ordem n iterativamente até erro < tolerância.",
                                    "Salve modelo aproximado como Q_pade(s).",
                                    "Compare fase e magnitude em faixa de interesse."
                                  ],
                                  "verification": "Erro máximo em Bode < 5%; plots sobrepostos visualmente semelhantes.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "MATLAB; funções pade(), bode(), tf().",
                                  "tips": "[n,m] para Padé assimétrico se necessário para melhor ajuste de fase.",
                                  "learningObjective": "Aplicar método Padé para aproximações racionais de funções transcendentais.",
                                  "commonMistakes": "Usar ordem inadequada causando overshoot em fase; não normalizar ganhos."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar aproximação por mínimos quadrados",
                                  "subSteps": [
                                    "Gere dados de frequência com freqresp(Q(s), w).",
                                    "Defina modelo racional com invfreqs(num_order, den_order, w, peso).",
                                    "Otimize coeficientes minimizando ||Q - Q_rac||^2.",
                                    "Plote resíduos de erro e ajuste pesos para magnitude/fase.",
                                    "Exporte modelo como tf(Q_ls_num, Q_ls_den)."
                                  ],
                                  "verification": "Norma do erro LS < threshold; step response similar.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "MATLAB com System ID Toolbox; freqresp(), invfreqs().",
                                  "tips": "Use pesos altos em frequências críticas; normalize dados.",
                                  "learningObjective": "Usar otimização LS para aproximações flexíveis de ordem baixa.",
                                  "commonMistakes": "Sobreajuste (alta ordem); ignorar dados fora da banda de interesse."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Validar e comparar aproximações",
                                  "subSteps": [
                                    "Compare Q_pade, Q_ls e original via step(), impulse(), bode().",
                                    "Calcule métricas: RMSE, max error, estabilidade (pole()).",
                                    "Selecione melhor baseada em critério (ex: menor erro em banda).",
                                    "Teste em laço fechado simulado com controlador.",
                                    "Documente trade-offs em relatório."
                                  ],
                                  "verification": "Aproximação escolhida estável e erro < 2% em specs; simulação passa.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "MATLAB plots; feedback() para simulação.",
                                  "tips": "Use nichols() para análise em QFT se aplicável.",
                                  "learningObjective": "Avaliar e selecionar aproximação ótima para uso em controle.",
                                  "commonMistakes": "Não testar estabilidade final; focar só em magnitude ignorando fase."
                                }
                              ],
                              "practicalExample": "Aproximar Q(s) = exp(-s/10) / (1 + s/100) (filtro com delay) por frações de ordem 3 usando Padé e LS em MATLAB, validando para controlador de motor DC com delay de transmissão.",
                              "finalVerifications": [
                                "Q_rac(s) é estável (todos pólos em LHP).",
                                "Erro em magnitude < 3dB e fase < 10° na banda 0.1-10 rad/s.",
                                "Resposta ao degrau da aproximação coincide com original (erro <5%).",
                                "Modelo implementado roda sem warnings em simulações.",
                                "Relatório compara métodos com plots e métricas.",
                                "Aproximação selecionada integra em laço fechado sem instabilidade."
                              ],
                              "assessmentCriteria": [
                                "Precisão da aproximação (erro quantificado < tolerância).",
                                "Correta implementação de pelo menos um método (Padé ou LS).",
                                "Análise completa de validação com plots e métricas.",
                                "Escolha justificada da melhor aproximação.",
                                "Código limpo, comentado e reproduzível.",
                                "Entendimento demonstrado em relatório (explicação de trade-offs)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Análise numérica e aproximação de funções (Padé, LS).",
                                "Programação: Implementação numérica em MATLAB/Python (otimização).",
                                "Física: Modelagem de sistemas dinâmicos com delays.",
                                "Estatística: Avaliação de ajuste via resíduos e mínimos quadrados."
                              ],
                              "realWorldApplication": "Em design de controladores robustos (QFT), aproximar filtros não-racionais para síntese paramétrica em plantas industriais como fornos ou robôs com delays de rede, permitindo simulações e implementação em PLCs."
                            },
                            "estimatedTime": "2.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.6.1.1.2.3",
                            "name": "Verificar estabilidade da parametrização finita",
                            "description": "Usar critérios como Routh-Hurwitz ou simulações para garantir que a escolha dos parâmetros finitos resulte em controladores estabilizadores.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Formular o polinômio característico da malha fechada",
                                  "subSteps": [
                                    "Identifique o modelo do sistema em espaço de estados ou função de transferência.",
                                    "Defina a parametrização finita do controlador (ex: C(s) = K1 + K2/s).",
                                    "Calcule a função de transferência da malha fechada H(s) = G(s)C(s)/(1 + G(s)C(s)).",
                                    "Extraia o polinômio característico do denominador de H(s).",
                                    "Expresse o polinômio em termos dos parâmetros finitos (ex: p(s) = s^n + a_{n-1}(k1,k2)s^{n-1} + ...)."
                                  ],
                                  "verification": "Verifique se o polinômio é monico (coeficiente de s^n = 1) e todos os termos estão corretamente parametrizados.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Papel e calculadora; software como MATLAB ou Python (SymPy para manipulação simbólica).",
                                  "tips": "Use funções simbólicas para evitar erros de cálculo manual em ordens altas.",
                                  "learningObjective": "Dominar a derivação do polinômio característico parametrizado para análise de estabilidade.",
                                  "commonMistakes": "Esquecer o sinal de realimentação negativa; confundir numerador com denominador."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Aplicar o critério de Routh-Hurwitz",
                                  "subSteps": [
                                    "Construa a tabela de Routh para o polinômio parametrizado.",
                                    "Calcule os elementos da primeira coluna em função dos parâmetros.",
                                    "Determine as condições para que todos os elementos da primeira coluna sejam positivos.",
                                    "Resolva as desigualdades resultantes para encontrar a região de estabilidade no espaço dos parâmetros.",
                                    "Plote a região de estabilidade (ex: usando ferramentas de plotagem)."
                                  ],
                                  "verification": "Confirme que não há mudanças de sinal na primeira coluna para valores nominais e que as condições definem uma região não vazia.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Tabela de Routh impressa ou software (MATLAB routh() ou Python control library).",
                                  "tips": "Para parametrizações lineares, isole termos para simplificar desigualdades.",
                                  "learningObjective": "Aplicar Routh-Hurwitz para obter condições explícitas de estabilidade parametrizada.",
                                  "commonMistakes": "Erro em cálculos de divisões na tabela; ignorar casos de linha zero."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Realizar simulações numéricas para validação",
                                  "subSteps": [
                                    "Escolha pontos de teste dentro e fora da região de estabilidade prevista.",
                                    "Implemente o controlador parametrizado em simulador.",
                                    "Simule a resposta ao degrau ou rampa e analise polos ou trajetórias.",
                                    "Verifique convergência (polos no semiplano esquerdo) e ausência de oscilações divergentes.",
                                    "Compare com predições analíticas do Routh-Hurwitz."
                                  ],
                                  "verification": "Respostas simuladas devem ser estáveis dentro da região e instáveis fora dela.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "MATLAB Simulink, Python (control + matplotlib) ou Octave.",
                                  "tips": "Use grid de parâmetros para visualização rápida de estabilidade.",
                                  "learningObjective": "Validar análise teórica com simulações dinâmicas.",
                                  "commonMistakes": "Escala errada no tempo de simulação; não perturbar parâmetros o suficiente."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Interpretar resultados e documentar condições de estabilidade",
                                  "subSteps": [
                                    "Sintetize as condições de estabilidade (ex: k1 > 0, k2 > k1*tau).",
                                    "Avalie robustez com margens de variação de parâmetros.",
                                    "Documente limitações do método (ex: não captura não-linearidades).",
                                    "Recomende faixas seguras para projeto do controlador.",
                                    "Gere relatório com tabelas, plots e conclusões."
                                  ],
                                  "verification": "Condições devem ser consistentes entre análise e simulações; região de estabilidade não vazia.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Editor de texto ou LaTeX para relatório; ferramentas de plotagem.",
                                  "tips": "Inclua sensibilidade a perturbações para aplicações reais.",
                                  "learningObjective": "Integrar análises para decisões de design robustas.",
                                  "commonMistakes": "Generalizar condições sem validar numericamente; ignorar dependências não-lineares."
                                }
                              ],
                              "practicalExample": "Para um sistema G(s) = 1/(s(s+1)) com controlador PI parametrizado C(s) = k_p + k_i/s, derive p(s) = s^3 + (1+k_p)s^2 + k_i s + 0. Aplicando Routh-Hurwitz: k_p > 0, k_i > 0, k_p k_i > k_i (simplifica para k_p > 1). Simule em MATLAB para k_p=2, k_i=3 (estável) vs k_p=0.5 (instável).",
                              "finalVerifications": [
                                "Região de estabilidade no espaço de parâmetros é não vazia e bem definida.",
                                "Tabela Routh sem mudanças de sinal para pontos nominais.",
                                "Simulações confirmam estabilidade dentro da região e instabilidade fora.",
                                "Condições são expressas como desigualdades simples e interpretáveis.",
                                "Polos calculados estão todos no semiplano esquerdo para valores válidos.",
                                "Relatório inclui plots de regiões e respostas simuladas."
                              ],
                              "assessmentCriteria": [
                                "Precisão na derivação do polinômio característico (20%).",
                                "Correção na aplicação de Routh-Hurwitz e condições derivadas (30%).",
                                "Qualidade e consistência das simulações (25%).",
                                "Interpretação robusta e documentação clara (15%).",
                                "Uso adequado de ferramentas e visualizações (10%)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Álgebra polinomial e desigualdades lineares.",
                                "Programação: Implementação numérica em MATLAB/Python.",
                                "Física: Dinâmica de sistemas e estabilidade em osciladores.",
                                "Engenharia de Software: Validação de modelos por simulação."
                              ],
                              "realWorldApplication": "Em projetos de controladores para drones (estabilização de atitude), robótica industrial (posicionamento preciso) ou processos químicos (controle de temperatura), garantindo que variações de parâmetros de tuning não causem instabilidades catastróficas."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.6.1.1.3",
                        "name": "Formulação para Otimização Algorítmica",
                        "description": "Definição do vetor de parâmetros do controlador para minimização de critérios de desempenho e robustez via algoritmos de otimização.",
                        "specificSkills": [
                          {
                            "id": "10.1.6.1.1.3.1",
                            "name": "Definir funções custo parametrizadas",
                            "description": "Formular funções objetivo como integral do erro quadrático, norma H-infinito ou margens de robustez em termos dos parâmetros finitos do controlador.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar o modelo do sistema e estrutura parametrizada do controlador",
                                  "subSteps": [
                                    "Identifique o modelo dinâmico do sistema (funções de transferência ou espaço de estados).",
                                    "Defina a estrutura do controlador com parâmetros finitos (ex: ganhos PID θ = [Kp, Ki, Kd]).",
                                    "Analise a planta fechada em termos dos parâmetros θ.",
                                    "Verifique estabilidade inicial usando critérios como Routh-Hurwitz.",
                                    "Documente as equações do loop fechado."
                                  ],
                                  "verification": "Confirme que o diagrama de blocos da planta fechada está correto e expresso em função de θ.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Modelo do sistema (MATLAB/Simulink ou Python Control Systems Library)",
                                    "Folha de papel ou software de diagramação"
                                  ],
                                  "tips": "Comece com sistemas simples monovariáveis para evitar complexidade inicial.",
                                  "learningObjective": "Compreender como os parâmetros do controlador afetam a resposta do sistema fechado.",
                                  "commonMistakes": [
                                    "Ignorar dinâmicas não modeladas",
                                    "Confundir parâmetros de controlador com parâmetros do planta"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Selecionar e entender métricas de performance para a função custo",
                                  "subSteps": [
                                    "Estude o Integral do Erro Quadrático (ISE): ∫ e(t)^2 dt.",
                                    "Aprenda a norma H-infinito: ||T||_∞ = sup_ω |T(jω)| para robustez.",
                                    "Explore margens de robustez: ganho de fase e margem de ganho em função de θ.",
                                    "Compare trade-offs entre tracking, distúrbio e ruído para cada métrica.",
                                    "Escolha 2-3 métricas relevantes para o problema específico."
                                  ],
                                  "verification": "Explique verbalmente ou por escrito a interpretação física de cada métrica escolhida.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Livro de controle avançado (ex: Zhou - Robust Control)",
                                    "Ferramentas de análise de frequência (Bode plots no MATLAB)"
                                  ],
                                  "tips": "Use simulações iniciais para visualizar o impacto de cada métrica.",
                                  "learningObjective": "Dominar as principais funções custo usadas em otimização de controladores.",
                                  "commonMistakes": [
                                    "Confundir ISE com IAE",
                                    "Não considerar o horizonte de integração finito"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Formular a função custo parametrizada em termos de θ",
                                  "subSteps": [
                                    "Expresse o erro e(t) = r(t) - y(t) em função dos parâmetros θ.",
                                    "Derive a expressão analítica ou numérica para ISE(θ) = ∫ [r(t)-y(t,θ)]^2 dt.",
                                    "Calcule ||T(jω,θ)||_∞ usando ferramentas de otimização ou aproximações.",
                                    "Inclua termos de penalidade para controle u(t,θ) e robustez (ex: w1*ISE + w2*||K|| + w3*||S||_∞).",
                                    "Implemente a função custo em código para avaliação numérica."
                                  ],
                                  "verification": "Teste a função custo com valores conhecidos de θ e compare com simulações.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "MATLAB/Simulink ou Python (scipy.integrate, control library)",
                                    "Exemplos de código de otimização"
                                  ],
                                  "tips": "Use simulação em tempo discreto para aproximação prática do ISE.",
                                  "learningObjective": "Capacitar a derivação de funções objetivo dependentes explicitamente de parâmetros finitos.",
                                  "commonMistakes": [
                                    "Erros em substituição de y(t,θ)",
                                    "Ignorar pesos normalizados nas métricas"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Validar e refinar a função custo parametrizada",
                                  "subSteps": [
                                    "Simule respostas para diferentes θ e plote J(θ).",
                                    "Verifique sensibilidade a perturbações em θ (gradiente numérico).",
                                    "Ajuste pesos para equilibrar performance e robustez.",
                                    "Compare com métodos clássicos (ex: Ziegler-Nichols) para validação.",
                                    "Documente a função custo final pronta para otimização algorítmica."
                                  ],
                                  "verification": "A função custo deve ser suave, unimodal em regiões relevantes e computacionalmente eficiente.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Software de simulação e plotagem (MATLAB/Python)",
                                    "Templates de otimização (fmincon ou scipy.optimize)"
                                  ],
                                  "tips": "Monitore o tempo de computação; mire <1s por avaliação para otimizadores.",
                                  "learningObjective": "Garantir que a formulação seja adequada para solvers de otimização.",
                                  "commonMistakes": [
                                    "Função custo não diferenciável",
                                    "Sobrepenalização de termos levando a soluções triviais"
                                  ]
                                }
                              ],
                              "practicalExample": "Para um motor DC com modelo G(s) = 1/(s+1), defina controlador PID θ=[Kp,Ki,Kd]. Formule J(θ) = ∫_0^∞ e(t)^2 dt + 0.1 ∫_0^∞ u(t)^2 dt + ||S(jω,θ)||_∞, onde e(t)=r(t)-y(t), usando simulação em MATLAB para ISE e svd para H-inf.",
                              "finalVerifications": [
                                "Deriva corretamente J(θ) para um sistema dado.",
                                "Implementa J(θ) em código que roda em <1s.",
                                "Explica trade-offs entre ISE, H-inf e robustez.",
                                "Valida J(θ) contra simulações de resposta ao degrau.",
                                "Identifica parâmetros ótimos iniciais minimizando J(θ)."
                              ],
                              "assessmentCriteria": [
                                "Precisão analítica na expressão de J(θ) (90%+ match com simulação).",
                                "Eficiência computacional (avaliação em ms).",
                                "Cobertura de múltiplas métricas (pelo menos ISE + H-inf).",
                                "Inclusão de pesos ajustáveis e justificativa.",
                                "Validação com pelo menos 3 cenários (tracking, distúrbio, ruído).",
                                "Documentação clara com equações e código comentado."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Otimização não-linear e análise funcional (normas).",
                                "Programação: Implementação numérica com bibliotecas de controle (MATLAB/Python).",
                                "Física: Modelagem dinâmica de sistemas mecatrônicos.",
                                "Estatística: Análise de sensibilidade e Monte Carlo para robustez."
                              ],
                              "realWorldApplication": "Em automação industrial, define funções custo para otimizadores em PLCs controlando temperatura de reatores químicos, equilibrando rastreamento rápido com consumo energético mínimo e robustez a variações de carga."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.6.1.1.3.2",
                            "name": "Configurar restrições de estabilidade",
                            "description": "Incorporar constraints como estabilidade do laço fechado e limites em ganhos/sensibilidades diretamente nas variáveis parametrizadas para otimização.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Critérios de Estabilidade para Laços Fechados",
                                  "subSteps": [
                                    "Estude os teoremas fundamentais de estabilidade: Routh-Hurwitz e Nyquist.",
                                    "Analise a função de laço fechado T(s) = G(s)C(s)/(1 + G(s)C(s)) e seus pólos.",
                                    "Identifique condições de estabilidade em termos de coeficientes do polinômio característico.",
                                    "Pratique com exemplos simples de sistemas monovariáveis de baixa ordem.",
                                    "Discuta margens de estabilidade (ganho e fase) como extensões."
                                  ],
                                  "verification": "Resolva um problema de estabilidade manualmente e confirme todos os pólos no semiplano esquerdo usando software como MATLAB.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Livro de controle clássico (ex: Ogata)",
                                    "MATLAB ou Python com Control Systems Library",
                                    "Folhas de exercícios de Routh-Hurwitz"
                                  ],
                                  "tips": "Sempre verifique a ordem do polinômio para evitar erros em Routh.",
                                  "learningObjective": "Compreender e aplicar critérios analíticos de estabilidade em laços fechados parametrizados.",
                                  "commonMistakes": [
                                    "Confundir estabilidade de laço aberto com fechado",
                                    "Ignorar pólos no eixo imaginário",
                                    "Erros aritméticos em tabelas de Routh"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Parametrizar o Controlador e Identificar Variáveis Relevantes",
                                  "subSteps": [
                                    "Escolha uma estrutura parametrizada do controlador, como PID com ganhos Kp, Ki, Kd ou forma polinomial.",
                                    "Expresse a função de transferência do laço fechado em termos dos parâmetros θ = [θ1, θ2, ...].",
                                    "Derive o polinômio característico Δ(s, θ) = 1 + G(s)C(s, θ).",
                                    "Liste variáveis de interesse: ganhos de laço aberto, sensibilidades S(s) e T(s).",
                                    "Teste parametrização com um modelo de planta simples (ex: integrador com atraso)."
                                  ],
                                  "verification": "Gere o polinômio característico simbólico e confirme dependência linear/não-linear nos parâmetros.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Software simbólico: SymPy (Python) ou Symbolic Math Toolbox (MATLAB)",
                                    "Modelo de planta G(s) = 1/(s(s+1))"
                                  ],
                                  "tips": "Use formas canônicas para simplificar parametrizações (ex: Youla-Kucera).",
                                  "learningObjective": "Parametrizar controladores para facilitar a imposição de restrições de estabilidade.",
                                  "commonMistakes": [
                                    "Parametrizações não generalizáveis",
                                    "Omitir termos de atraso ou não-minimum phase",
                                    "Escala inadequada dos parâmetros"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Formular Restrições de Estabilidade em Termos de Parâmetros",
                                  "subSteps": [
                                    "Aplique Routh-Hurwitz aos coeficientes de Δ(s, θ), gerando inequalities como a_i(θ) > 0.",
                                    "Use critérios de Nyquist parametrizados: encasulamento do ponto -1 para todos θ.",
                                    "Incorpore condições de Hurwitz via LMIs (Linear Matrix Inequalities) se aplicável.",
                                    "Defina domínio de estabilidade: conjunto convexo ou não-convexo em θ.",
                                    "Valide com grid search numérico nos parâmetros."
                                  ],
                                  "verification": "Resolva um sistema de inequalities e confirme estabilidade para pontos amostrados.",
                                  "estimatedTime": "2.5 horas",
                                  "materials": [
                                    "Yalmip ou CVX para LMIs",
                                    "Exercícios com polinômios de 3ra/4ta ordem"
                                  ],
                                  "tips": "Para não-convexo, use relaxações ou decomposição em subproblemas.",
                                  "learningObjective": "Traduzir critérios de estabilidade em restrições matemáticas acionáveis para otimização.",
                                  "commonMistakes": [
                                    "Inequalities insuficientes para estabilidade robusta",
                                    "Linearizar excessivamente problemas não-lineares",
                                    "Ignorar dependências cruzadas entre parâmetros"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Incorporar Limites em Ganhos e Sensibilidades",
                                  "subSteps": [
                                    "Defina bounds em |C(jω)| < K_max para todos ω relevantes.",
                                    "Estabeleça restrições em ||S||_∞ < 1/|d| para rejeição de distúrbios.",
                                    "Inclua limites em picos de overshoot ou tempo de assentamento via normas H2/H∞.",
                                    "Expresse como funções de θ: max_ω |f(ω, θ)| ≤ limite.",
                                    "Integre com restrições de estabilidade em um conjunto unificado."
                                  ],
                                  "verification": "Plote respostas em frequência para θ ótimo e confirme cumprimento de todos os bounds.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Bode plots no MATLAB/Simulink",
                                    "Documentação de normas H∞"
                                  ],
                                  "tips": "Use aproximações por malha (grid ω) para max_ω computacionalmente eficientes.",
                                  "learningObjective": "Integrar restrições de performance (ganhos/sensibilidades) com estabilidade parametrizada.",
                                  "commonMistakes": [
                                    "Restrições muito conservadoras reduzindo o espaço viável",
                                    "Frequências ω inadequadas",
                                    "Confundir normas L1 e H∞"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Validar e Integrar Restrições na Otimização Algorítmica",
                                  "subSteps": [
                                    "Configure o problema de otimização: min J(θ) s.t. restrições de estabilidade/performance.",
                                    "Escolha solver (ex: fmincon, IPOPT) e teste factibilidade.",
                                    "Sensitize análise: verifique gradientes das restrições.",
                                    "Simule laço fechado com θ ótimo e compare com baselines.",
                                    "Documente o conjunto viável de θ."
                                  ],
                                  "verification": "Otimize e demonstre que o controlador resultante é estável e atende todos os limites.",
                                  "estimatedTime": "2.5 horas",
                                  "materials": [
                                    "MATLAB Optimization Toolbox ou CasADi (Python)",
                                    "Simulink para simulações"
                                  ],
                                  "tips": "Inicie com problemas factíveis para evitar falhas numéricas.",
                                  "learningObjective": "Preparar restrições parametrizadas para uso direto em algoritmos de otimização.",
                                  "commonMistakes": [
                                    "Solvers não adequados para não-convexo",
                                    "Numérica instável em boundaries",
                                    "Omitir validação temporal"
                                  ]
                                }
                              ],
                              "practicalExample": "Para uma planta G(s) = 1/(s^2 + s), parametrizar um PID C(s) = Kp + Ki/s + Kd s. Formular Routh-Hurwitz em [Kp, Ki, Kd]: todas hurwitz determinants >0, |Kp| < 10, ||S||_∞ < 2. Otimizar para tempo de assentamento mínimo usando fmincon, resultando em θ* estável e performante.",
                              "finalVerifications": [
                                "Polinômio característico hurwitz para θ no conjunto viável.",
                                "Margens de ganho/fase > 6dB/45° em simulações.",
                                "Ganhos de laço |L(jω)| dentro dos bounds para ω=0.1-10 rad/s.",
                                "Sensibilidades S/T com picos < especificado.",
                                "Simulação temporal sem oscilações ou instabilidade.",
                                "Otimização converge a θ factível e ótimo local."
                              ],
                              "assessmentCriteria": [
                                "Precisão na derivação de inequalities de estabilidade (90% corretas).",
                                "Correta integração de bounds em ganhos/sensibilidades.",
                                "Validação numérica robusta com múltiplos pontos θ.",
                                "Eficiência computacional: tempo de otimização < 1 min.",
                                "Relatório claro com plots de Bode e step response.",
                                "Tratamento de casos edge (ex: θ na boundary)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Otimização não-convexa e Programação Linear (LMIs).",
                                "Programação: Implementação em Python/MATLAB com solvers como SciPy ou CVXPY.",
                                "Física: Modelagem dinâmica de sistemas reais (ex: motores elétricos).",
                                "Estatística: Análise de sensibilidade e robustez probabilística.",
                                "Engenharia de Software: Modularidade em frameworks de controle como ROS."
                              ],
                              "realWorldApplication": "Em controle de drones, configurar restrições de estabilidade parametrizadas garante voo seguro sob variações de carga, otimizando attitude controllers para minimizar oscilações enquanto respeita limites de atuadores e sensores ruidosos."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.6.1.1.3.3",
                            "name": "Preparar para solvers de otimização",
                            "description": "Estruturar o problema como minimização não linear com gradientes analíticos ou numéricos, compatível com ferramentas como MATLAB fmincon ou gurobi.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Definir os componentes do problema de otimização",
                                  "subSteps": [
                                    "Identificar as variáveis de decisão, como parâmetros do controlador (ex: ganhos Kp, Ki, Kd).",
                                    "Especificar a função objetivo, tipicamente uma métrica de desempenho como IAE ou ISE.",
                                    "Listar restrições de igualdade (ex: condições de equilíbrio) e desigualdade (ex: limites de atuação).",
                                    "Definir bounds iniciais e limites para as variáveis.",
                                    "Documentar todos os componentes em pseudocódigo ou esquema."
                                  ],
                                  "verification": "Criar um documento ou estrutura de dados que liste claramente variáveis, objetivo e restrições, sem ambiguidades.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Editor de texto ou MATLAB Live Script",
                                    "Descrição original do problema de controle"
                                  ],
                                  "tips": "Use notação matemática padrão para clareza (ex: min J(θ) s.t. g(θ) ≤ 0).",
                                  "learningObjective": "Extrair e formalizar os elementos essenciais de um problema paramétrico de controle.",
                                  "commonMistakes": "Ignorar restrições implícitas como positividade de ganhos ou estabilidade."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Formular a função objetivo como minimização não linear",
                                  "subSteps": [
                                    "Expressar a função custo J(θ) em termos das variáveis θ, simulando o sistema fechado.",
                                    "Implementar J(θ) como função escalar que simula a resposta do sistema.",
                                    "Calcular gradiente analítico ∂J/∂θ usando chain rule ou syms no MATLAB.",
                                    "Se analítico difícil, preparar para gradiente numérico via finite differences.",
                                    "Testar J e ∇J em pontos conhecidos para valores esperados."
                                  ],
                                  "verification": "Executar J(θ0) e ∇J(θ0) para θ0 inicial e comparar com valores manuais.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "MATLAB com Control System Toolbox",
                                    "Modelo do sistema (função de transferência ou estado-espaço)"
                                  ],
                                  "tips": "Vetorize simulações para eficiência em loops de otimização.",
                                  "learningObjective": "Construir função objetivo diferenciável compatível com solvers não lineares.",
                                  "commonMistakes": "Não normalizar a escala de J, causando problemas numéricos em gradientes."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Formular restrições e suas derivadas",
                                  "subSteps": [
                                    "Classificar restrições: c(θ)=0 (igualdade), c(θ)≤0 (desigualdade), lb≤θ≤ub.",
                                    "Implementar vetores c(θ) e ceq(θ) com simulações do sistema.",
                                    "Computar Jacobianas ∇c e ∇ceq analiticamente ou numericamente.",
                                    "Verificar consistência em pontos factíveis iniciais.",
                                    "Incluir restrições de robustez se aplicável (ex: margens de ganho)."
                                  ],
                                  "verification": "Resolver um problema simples de factibilidade e checar se violações são zero.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "MATLAB Optimization Toolbox",
                                    "Funções de simulação do sistema"
                                  ],
                                  "tips": "Use fsolve para testar factibilidade antes da otimização completa.",
                                  "learningObjective": "Preparar restrições diferenciáveis para solvers como fmincon.",
                                  "commonMistakes": "Esquecer Jacobianas, forçando o solver a usar numéricas imprecisas."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Estruturar funções para o solver específico",
                                  "subSteps": [
                                    "Criar funções anônimas ou arquivos: fun = @(θ) [J(θ); ∇J(θ); c(θ); ∇c(θ); ceq(θ); ∇ceq(θ)].",
                                    "Configurar opções do solver (ex: options = optimoptions('fmincon','GradObj','on','Hessian','off')).",
                                    "Definir x0 inicial factível e bounds.",
                                    "Preparar para Gurobi se misto-inteiro: converter para formato Pyomo ou Gurobi MATLAB.",
                                    "Executar otimização de teste com tolerâncias baixas."
                                  ],
                                  "verification": "Rodar o solver com um problema toy e obter solução converge com erro <1e-6.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "MATLAB fmincon ou Gurobi interface",
                                    "Documentação do solver"
                                  ],
                                  "tips": "Ative display para monitorar iterações e convergência.",
                                  "learningObjective": "Adaptar a formulação para APIs de solvers padrão.",
                                  "commonMistakes": "Passar gradientes errados, causando falha imediata do solver."
                                }
                              ],
                              "practicalExample": "Para projetar um controlador PID ótimo para um motor DC com função de transferência G(s)=1/(s+1), defina θ=[Kp,Ki,Kd], J(θ)=∫|e(t)|dt para rampa de referência, restrições: Kp≤10, Ki≥0, overshoot≤20%. Implemente em fmincon: [θ_opt,fval] = fmincon(fun_obj,θ0,A,b,[],[],[],options); obtendo θ ótimo que minimiza J com gradientes analíticos via simulação.",
                              "finalVerifications": [
                                "Função objetivo retorna escalar e gradiente vetorial correto.",
                                "Restrições e Jacobianas são consistentes em x0.",
                                "Solver converge em <50 iterações com redução de custo >90%.",
                                "Solução final satisfaz todas restrições e bounds.",
                                "Simulação com θ_opt mostra desempenho melhorado vs. manual.",
                                "Gradientes numéricos aproximam analíticos dentro de 1e-4."
                              ],
                              "assessmentCriteria": [
                                "Clareza e completude na definição de componentes (20%).",
                                "Correção matemática da função objetivo e gradientes (25%).",
                                "Implementação precisa de restrições e derivadas (25%).",
                                "Compatibilidade e sucesso na execução do solver (20%).",
                                "Validação com testes e documentação (10%)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Otimização não linear e cálculo vetorial.",
                                "Programação: Desenvolvimento de funções em MATLAB/Python.",
                                "Engenharia de Controle: Síntese paramétrica de controladores.",
                                "Computação Científica: Uso de toolboxes de otimização."
                              ],
                              "realWorldApplication": "Na indústria, essa formulação é usada para otimizar controladores em processos químicos ou robótica, reduzindo tempo de settling em 30% e consumo energético, compatível com ferramentas empresariais como MATLAB no Simulink para prototipagem real."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.6.1.1.3.4",
                            "name": "Avaliar soluções otimizadas",
                            "description": "Validar o controlador otimizado parametricamente através de análise de Bode, Nyquist e simulações de resposta ao degrau em presença de incertezas.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Configurar o modelo do sistema com incertezas paramétricas",
                                  "subSteps": [
                                    "Identificar parâmetros nominais do sistema (ganho, constantes de tempo, etc.)",
                                    "Definir faixas de incerteza para cada parâmetro (ex: ±20% de variação)",
                                    "Implementar o modelo em software de simulação (MATLAB/Simulink ou Python Control Systems Library)",
                                    "Gerar conjunto de modelos perturbados usando Monte Carlo ou varredura paramétrica",
                                    "Verificar estabilidade nominal do sistema em malha fechada"
                                  ],
                                  "verification": "Confirmar que todos os modelos perturbados são gerados corretamente e o modelo nominal é estável via root locus ou eigenvalues",
                                  "estimatedTime": "1.5 horas",
                                  "materials": "MATLAB/Simulink ou Python (bibliotecas control, numpy, matplotlib); documentação do sistema",
                                  "tips": "Use scripts parametrizados para automação da geração de incertezas, evitando erros manuais",
                                  "learningObjective": "Dominar modelagem de sistemas com incertezas para análise robusta",
                                  "commonMistakes": "Ignorar acoplamentos entre parâmetros ou usar incertezas simétricas inadequadas para sistemas reais"
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Realizar análise de Bode do controlador otimizado",
                                  "subSteps": [
                                    "Plotar diagramas de Bode para ganho e fase do laço aberto com modelo nominal e perturbado",
                                    "Avaliar margens de ganho e fase em todas as frequências críticas",
                                    "Verificar atenuação de distúrbios em baixas e altas frequências",
                                    "Comparar com especificações de desempenho (ex: margem de fase > 45°)",
                                    "Documentar variações devido a incertezas"
                                  ],
                                  "verification": "Diagramas de Bode mostram margens estáveis (>6dB ganho, >45° fase) em 95% dos casos perturbados",
                                  "estimatedTime": "1 hora",
                                  "materials": "Software de controle (MATLAB bode() ou Python bode_plot()); planilhas para tabulação de margens",
                                  "tips": "Use logscale para frequências e superponha múltiplas curvas para visualização clara de robustez",
                                  "learningObjective": "Interpretar diagramas de Bode para validar robustez frecuencial",
                                  "commonMistakes": "Focar apenas no nominal sem analisar o pior caso de incerteza"
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Executar análise de Nyquist do sistema em malha fechada",
                                  "subSteps": [
                                    "Gerar diagrama de Nyquist para função de laço aberto nominal e perturbada",
                                    "Verificar encirculamentos do ponto crítico (-1,0) para estabilidade",
                                    "Calcular distância ao ponto crítico e ganho mínimo",
                                    "Analisar estabilidade relativa via número de encirculamentos",
                                    "Plotar contornos de Nyquist para conjunto de incertezas"
                                  ],
                                  "verification": "Nenhum encirculamento do ponto -1+j0 em todos os modelos perturbados, com ganho de estabilidade >1",
                                  "estimatedTime": "1 hora",
                                  "materials": "MATLAB nyquist() ou Python nyquist_plot(); ferramentas de plotagem complexa",
                                  "tips": "Aumente resolução de frequência em regiões críticas para precisão",
                                  "learningObjective": "Aplicar critério de Nyquist para validação de estabilidade robusta",
                                  "commonMistakes": "Confundir laço aberto com fechado ou ignorar quadrantes imaginários negativos"
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Simular respostas ao degrau com incertezas e analisar desempenho",
                                  "subSteps": [
                                    "Aplicar entrada degrau unitário em simulações time-domain para ensemble de modelos",
                                    "Medir overshoot, tempo de estabilização, erro estacionário e tempo de subida",
                                    "Plotar respostas temporais sobrepostas para visualização de variabilidade",
                                    "Comparar com métricas de especificação (ex: overshoot <20%, settling time <5s)",
                                    "Realizar análise de sensibilidade paramétrica"
                                  ],
                                  "verification": "Todas as simulações atendem critérios de desempenho em pelo menos 90% dos casos",
                                  "estimatedTime": "1.5 horas",
                                  "materials": "Simulink ou Python (scipy.signal.step()); scripts de Monte Carlo",
                                  "tips": "Inclua ruído e distúrbios reais nas simulações para realismo",
                                  "learningObjective": "Avaliar desempenho transitório robusto via simulações",
                                  "commonMistakes": "Usar degraus muito pequenos ou ignorar condições iniciais não zero"
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Integrar resultados e validar solução otimizada",
                                  "subSteps": [
                                    "Compilar métricas de Bode, Nyquist e step em tabela comparativa",
                                    "Avaliar trade-offs (ex: robustez vs. velocidade)",
                                    "Testar contra benchmarks alternativos (ex: PID clássico)",
                                    "Documentar conclusão: otimizado ou requer refinação",
                                    "Gerar relatório com plots e recomendações"
                                  ],
                                  "verification": "Relatório final confirma validação ou identifica falhas específicas",
                                  "estimatedTime": "1 hora",
                                  "materials": "Ferramentas de relatório (LaTeX, Jupyter Notebook); planilhas Excel",
                                  "tips": "Use índices compostos (ex: robustez média) para síntese quantitativa",
                                  "learningObjective": "Sintetizar análises múltiplas para decisão de engenharia",
                                  "commonMistakes": "Sobrestimar robustez baseada em nominal isolado"
                                }
                              ],
                              "practicalExample": "Para um controlador otimizado de posição de um braço robótico com incertezas de ±15% na massa e atrito, gerar 100 modelos perturbados, plotar Bodes mostrando margens >50°/8dB, Nyquists sem encirculamentos, e steps com overshoot médio 12% e settling <2s.",
                              "finalVerifications": [
                                "Margens de estabilidade robustas em análises de Bode e Nyquist para 95% dos casos",
                                "Respostas ao degrau dentro de especificações em ensemble de simulações",
                                "Ausência de instabilidades ou oscilações sustentadas",
                                "Comparação quantitativa com solução não otimizada",
                                "Relatório documentado com plots e métricas numéricas",
                                "Validação cruzada com método alternativo (ex: mu-síntese)"
                              ],
                              "assessmentCriteria": [
                                "Precisão na modelagem de incertezas (pontos por cobertura paramétrica)",
                                "Correta interpretação de diagramas (Bode/Nyquist com métricas exatas)",
                                "Qualidade das simulações time-domain (número de runs e estatísticas)",
                                "Análise integrada e conclusões lógicas",
                                "Clareza e completude do relatório (visualizações profissionais)",
                                "Identificação de trade-offs e sugestões de melhoria"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Análise complexa e funções de transferência",
                                "Programação: Automação de simulações em Python/MATLAB",
                                "Estatística: Análise Monte Carlo e sensibilidade",
                                "Física: Dinâmica de sistemas mecatrônicos"
                              ],
                              "realWorldApplication": "Validação de controladores em automação industrial, como estabilização de drones com variações de carga ou reguladores de velocidade em linhas de produção com desgaste de componentes."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.6.2",
                    "name": "Funções de Custo para Desempenho e Robustez",
                    "description": "Definição de critérios objetivos baseados em normas, margens de estabilidade e modelos de incerteza.",
                    "individualConcepts": [
                      {
                        "id": "10.1.6.2.1",
                        "name": "Normas para Quantificação de Desempenho",
                        "description": "Definição e aplicação de normas como L1, L2 e H∞ para avaliar o desempenho de sistemas de controle, incluindo erro de rastreamento, rejeição de distúrbios e consumo de energia do atuador.",
                        "specificSkills": [
                          {
                            "id": "10.1.6.2.1.1",
                            "name": "Calcular normas L2 e H∞ de funções de transferência",
                            "description": "Dado um sistema linear invariante no tempo (LIT) monovariável, calcular a norma L2 (energia) e H∞ (pico de ganho) usando ferramentas como MATLAB, interpretando os resultados em termos de desempenho transitório e em regime permanente.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar conceitos teóricos das normas L2 e H∞",
                                  "subSteps": [
                                    "Estudar a definição da norma L2 como a raiz quadrada da integral do quadrado da magnitude da resposta ao impulso ao longo do tempo.",
                                    "Compreender a norma H∞ como o valor máximo da magnitude da função de transferência no domínio da frequência.",
                                    "Diferenciar interpretações: L2 relacionada à energia total (desempenho transitório), H∞ ao pico de ganho (robustez e regime permanente).",
                                    "Analisar fórmulas matemáticas: ||G||_2 = sqrt(∫|g(t)|^2 dt), ||G||_∞ = sup_ω |G(jω)|.",
                                    "Explorar exemplos simples analíticos para funções de transferência de primeira e segunda ordem."
                                  ],
                                  "verification": "Resumir em um parágrafo as diferenças entre L2 e H∞ e fornecer um exemplo analítico resolvido.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Livro de controle avançado (ex: Zhou, Doyle), notas de aula, calculadora simbólica como SymPy ou MATLAB Symbolic Toolbox"
                                  ],
                                  "tips": "Use analogias físicas: L2 como energia total dissipada, H∞ como pior caso de amplificação.",
                                  "learningObjective": "Compreender as definições matemáticas e interpretações físicas das normas L2 e H∞ em sistemas LIT.",
                                  "commonMistakes": [
                                    "Confundir L2 com L1 (integral absoluta), ignorar normalização da função de transferência."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Modelar o sistema LIT como função de transferência no MATLAB",
                                  "subSteps": [
                                    "Definir a função de transferência G(s) usando tf(num, den) no MATLAB.",
                                    "Verificar estabilidade com pole() e zero() ou pzmap().",
                                    "Plotar diagrama de Bode com bode(G) para visualizar magnitude e fase.",
                                    "Converter para representação de estado se necessário com ss(G).",
                                    "Salvar o modelo em um script .m para reutilização."
                                  ],
                                  "verification": "Executar script e confirmar que o diagrama de Bode mostra picos corretos sem erros de sintaxe.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "MATLAB instalado, licença Control System Toolbox, exemplo de função de transferência como G(s) = 1/(s^2 + 2s + 1)"
                                  ],
                                  "tips": "Sempre normalize unidades de entrada/saída para evitar escalas erradas nas normas.",
                                  "learningObjective": "Criar e validar modelos de funções de transferência no ambiente MATLAB.",
                                  "commonMistakes": [
                                    "Esquecer de cancelar polos/zeros comuns, usar variáveis erradas no workspace."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular normas L2 e H∞ usando funções MATLAB",
                                  "subSteps": [
                                    "Calcular norma L2 com norm(G, 2) ou hinfnorm(G, []), confirmando com h2norm(G).",
                                    "Calcular norma H∞ com hinfnorm(G).",
                                    "Usar sigma(G, 'hinf') para plotar singular values e identificar o pico H∞.",
                                    "Comparar resultados numéricos com aproximações analíticas para validação.",
                                    "Registrar valores exatos e frequências associadas ao pico H∞."
                                  ],
                                  "verification": "Obter valores numéricos precisos (ex: L2=1.414, H∞=2.0) e plotar curvas de singular values.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "MATLAB com Robust Control Toolbox, script do Step 2"
                                  ],
                                  "tips": "Para sistemas de alta ordem, use opções de tolerância em hinfnorm para convergência.",
                                  "learningObjective": "Aplicar comandos MATLAB para computar normas de forma precisa e eficiente.",
                                  "commonMistakes": [
                                    "Usar norm(G,2) sem Control Toolbox (usa norma matricial errada), ignorar sistemas instáveis."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Interpretar resultados em termos de desempenho do sistema",
                                  "subSteps": [
                                    "Relacionar norma L2 baixa com bom desempenho transitório (decadência rápida de energia).",
                                    "Interpretar H∞ baixa como baixa sensibilidade a perturbações (robustez).",
                                    "Simular respostas ao impulso e degrau com step() e lsim() para validar interpretações.",
                                    "Discutir trade-offs: reduzir H∞ pode aumentar L2.",
                                    "Documentar relatório com plots, valores e conclusões."
                                  ],
                                  "verification": "Produzir relatório de 1 página com interpretações corretas e simulações alinhadas.",
                                  "estimatedTime": "1 hora e 30 minutos",
                                  "materials": [
                                    "MATLAB plots, templates de relatório LaTeX ou Word"
                                  ],
                                  "tips": "Compare com especificações de projeto: L2 < 1 para energia limitada, H∞ < 2 para ganho limitado.",
                                  "learningObjective": "Traduzir valores de normas em insights sobre desempenho transitório e permanente.",
                                  "commonMistakes": [
                                    "Interpretar H∞ como ganho DC (é sup over ω), ignorar efeitos não-lineares aproximados."
                                  ]
                                }
                              ],
                              "practicalExample": "Para G(s) = 1/(s^2 + 0.2s + 1), calcule no MATLAB: h2norm(G) ≈ 1.58 (energia transitória moderada), hinfnorm(G) ≈ 5.0 (pico em ressonância ~1 rad/s). Interprete: bom regime permanente, mas sensível a ruídos na frequência de pico.",
                              "finalVerifications": [
                                "Calcular corretamente normas para 3 funções de transferência diferentes.",
                                "Interpretar L2 como energia total e H∞ como pior ganho de frequência.",
                                "Gerar plots de Bode e singular values sem erros.",
                                "Validar resultados com simulações de tempo.",
                                "Explicar trade-offs em um sistema real."
                              ],
                              "assessmentCriteria": [
                                "Precisão numérica das normas (±1% erro).",
                                "Correção das interpretações físicas/desempenho.",
                                "Qualidade dos scripts MATLAB (comentados e reutilizáveis).",
                                "Profundidade das simulações e plots.",
                                "Clareza do relatório final.",
                                "Identificação de erros comuns evitados."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Análise funcional e teoria de integrais (L2), análise complexa (H∞).",
                                "Programação: Scripting em MATLAB, vetores e funções numéricas.",
                                "Física: Dinâmica de sistemas oscilatórios e energia em sinais.",
                                "Estatística: Análise de robustez e worst-case scenarios."
                              ],
                              "realWorldApplication": "Em controle de drones, calcular H∞ baixa garante robustez a ventos variáveis (pico de ganho limitado), enquanto L2 baixa assegura bateria eficiente (energia transitória mínima); usado em design de controladores PID/H∞ para aviões e robótica industrial."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.6.2.1.2",
                            "name": "Formular funções de custo baseadas em normas de erro",
                            "description": "Construir funções de custo objetivas J = ||e||_2^2 ou J = ||e||_∞ para penalizar desvios de referência e distúrbios, considerando pesos de frequência para priorizar bandas espectrais específicas.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender Normas de Erro L2 e L∞",
                                  "subSteps": [
                                    "Revise a definição matemática da norma L2: ||e||_2 = sqrt(∫|e(t)|^2 dt) ou sqrt(1/T ∫|E(jω)|^2 dω) em domínio de frequência.",
                                    "Estude a norma L∞: ||e||_∞ = sup |e(t)| ou ess sup |E(jω)|, representando o erro máximo.",
                                    "Compare penalizações: L2 penaliza erros RMS (energia total), L∞ foca em picos.",
                                    "Identifique aplicações: L2 para desempenho médio, L∞ para robustez a desvios extremos.",
                                    "Pratique com exemplos simples de sinais de erro unitários."
                                  ],
                                  "verification": "Explique verbalmente ou por escrito a diferença entre ||e||_2^2 e ||e||_∞ com fórmulas corretas.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Livro de controle avançado (ex: Zhou, Doyle), calculadora simbólica (MATLAB/SymPy), notas de aula sobre normas"
                                  ],
                                  "tips": "Use gráficos de magnitude para visualizar como L∞ captura picos e L2 a energia média.",
                                  "learningObjective": "Dominar definições e interpretações das normas L2 e L∞ aplicadas a erros de sistemas de controle.",
                                  "commonMistakes": [
                                    "Confundir L2 com média quadrática simples sem normalização",
                                    "Ignorar domínio (tempo vs frequência)",
                                    "Esquecer que L∞ é supremo, não máximo pontual"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Definir Sinal de Erro e Componentes do Sistema",
                                  "subSteps": [
                                    "Identifique o erro e(t) = r(t) - y(t), onde r é referência e y saída.",
                                    "Inclua distúrbios d(t) no modelo: y = G u + G_d d, e = r - y.",
                                    "Especifique bandas espectrais de interesse (baixas para rastreamento, altas para rejeição de ruído).",
                                    "Desenhe diagrama de bloco do sistema monovariável com referência, controlador C(s), planta G(s) e distúrbio.",
                                    "Calcule expressões simbólicas para E(s) em laço fechado."
                                  ],
                                  "verification": "Desenhe e rotule corretamente um diagrama de bloco com e(s) expresso em termos de r(s), d(s), C(s), G(s).",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Software de simulação (MATLAB Simulink), papel e lápis para diagramas, templates de sistemas SISO"
                                  ],
                                  "tips": "Sempre normalize frequências pela largura de banda desejada para contextualizar bandas espectrais.",
                                  "learningObjective": "Modelar o erro considerando referências e distúrbios em sistemas monovariáveis.",
                                  "commonMistakes": [
                                    "Omitir distúrbios na definição de erro",
                                    "Confundir entrada de referência com setpoint constante",
                                    "Ignorar efeitos dinâmicos em frequência"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Formular Funções de Custo Básicas J = ||e||_2^2 ou J = ||e||_∞",
                                  "subSteps": [
                                    "Construa J_2 = ||e||_2^2 = ∫|E(jω)|^2 dω / (2π) para penalização energética.",
                                    "Formule J_∞ = ||e||_∞ = sup_ω |E(jω)| para erro máximo em frequência.",
                                    "Implemente computacionalmente: use fft() em MATLAB para estimar normas de simulações.",
                                    "Teste com sistema simples: planta integrador, referência degrau.",
                                    "Analise trade-offs: J_2 suaviza, J_∞ conservador."
                                  ],
                                  "verification": "Calcule J para um sinal de erro simulado e compare com valores analíticos (erro <5%).",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "MATLAB ou Python (control library), exemplos de plantas SISO (.m files), tabela de fórmulas de normas"
                                  ],
                                  "tips": "Para L∞, use chebyshev norm em vetores discretos; discretize finamente para precisão.",
                                  "learningObjective": "Construir e computar funções de custo objetivas baseadas em normas puras de erro.",
                                  "commonMistakes": [
                                    "Usar ||e||_2 em vez de ||e||_2^2 para custo quadrático",
                                    "Calcular sup em tempo ao invés de frequência para L∞",
                                    "Esquecer fator de normalização em integrais"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Incorporar Pesos de Frequência para Priorização Espectral",
                                  "subSteps": [
                                    "Defina pesos W(s) ou W(jω): alto ganho em baixas ω para rastreamento, roll-off em altas para ruído.",
                                    "Formule J_w2 = ||W e||_2^2 e J_w∞ = ||W e||_∞.",
                                    "Escolha W: ex, W_r(s) = 1/(s/ω_b +1)^2 para referência em baixas frequências.",
                                    "Simule e otimize: ajuste W para minimizar J em bandas específicas.",
                                    "Valide: plote |W E(jω)| e verifique atenuação fora da banda."
                                  ],
                                  "verification": "Gere plots de Bode de |E(jω)| e |W E(jω)| mostrando priorização em banda desejada.",
                                  "estimatedTime": "75 minutos",
                                  "materials": [
                                    "MATLAB Control System Toolbox, banco de filtros Butterworth para pesos, scripts de otimização"
                                  ],
                                  "tips": "Comece com pesos de 1ª ordem e evolua; use logscale para ω em plots.",
                                  "learningObjective": "Refinar funções de custo com pesos para enfatizar bandas espectrais específicas.",
                                  "commonMistakes": [
                                    "Pesos com fase não mínima causando instabilidade",
                                    "Aplicar peso uniforme ignorando espectro do sinal",
                                    "Normalizar incorretamente W levando a escalas erradas"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um sistema de controle de posição de motor DC (planta G(s)=1/(s(s+1))), formule J = ||W_r (r - y)||_2^2 com W_r enfatizando erro <1 rad/s e adicione ||W_d d||_∞ para rejeitar distúrbios >10 rad/s. Simule degrau de referência e ruído, otimize C(s) minimizando J.",
                              "finalVerifications": [
                                "Formulação correta de J_2 e J_∞ com e(t) incluindo r e d.",
                                "Implementação numérica em software produz valores consistentes (±1%).",
                                "Plots de frequência mostram penalização priorizada em bandas específicas.",
                                "Trade-off análise: redução de J sem overshoot excessivo.",
                                "Explicação verbal de por que pesos melhoram desempenho espectral.",
                                "Código reutilizável para novos sistemas SISO."
                              ],
                              "assessmentCriteria": [
                                "Precisão matemática nas fórmulas de normas e pesos (100% corretas).",
                                "Adequação dos pesos às bandas espectrais especificadas (ganho >10 dB na banda).",
                                "Validade das simulações (estabilidade e convergência de J).",
                                "Profundidade da análise de trade-offs (quantitativa com números).",
                                "Clareza nos plots e documentação (legendas, escalas log).",
                                "Criatividade na escolha de W para cenários reais."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Análise funcional e teoria de normas em espaços Lp.",
                                "Programação: Implementação numérica com FFT e otimização em MATLAB/Python.",
                                "Física: Dinâmica de sistemas mecânicos/elétricos e espectros de sinais.",
                                "Estatística: Interpretação de RMS como variância de erro.",
                                "Design de Engenharia: Otimização multiobjetivo em controle."
                              ],
                              "realWorldApplication": "No controle de drones, formular J = ||W_pos (pos_ref - pos)||_2^2 + ||W_dist turb||_∞ para priorizar precisão em baixas frequências (estabilidade voo) e robustez a turbulências altas, usado em autopilotos como PX4."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.6.2.1.3",
                            "name": "Avaliar consumo de energia do atuador via normas",
                            "description": "Incorporar a norma L2 do sinal de controle u(t) em funções de custo para limitar o esforço de controle, balanceando desempenho e viabilidade prática em sistemas reais.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a norma L2 e o sinal de controle u(t)",
                                  "subSteps": [
                                    "Defina a norma L2 de um sinal contínuo: ||u||_2 = sqrt(∫ u(t)^2 dt de 0 a ∞).",
                                    "Explique o sinal de controle u(t) como a saída do controlador para o atuador.",
                                    "Calcule a norma L2 para sinais simples como degrau, rampa e senoide.",
                                    "Discuta propriedades da norma L2: quadrática, captura energia total do sinal.",
                                    "Compare com outras normas (L1, L∞) em termos de interpretação física."
                                  ],
                                  "verification": "Calcule corretamente a norma L2 para pelo menos três sinais de exemplo e explique sua significância.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Caderno e calculadora",
                                    "Software MATLAB ou Python com SymPy",
                                    "Referência: Franklin, Powell, Emami-Naeini - Feedback Control of Dynamic Systems"
                                  ],
                                  "tips": "Visualize a norma L2 como a 'energia' do sinal; use plots para intuitivamente entender.",
                                  "learningObjective": "Dominar a definição matemática e interpretação da norma L2 aplicada a sinais de controle.",
                                  "commonMistakes": [
                                    "Confundir norma L2 com L1 (soma absoluta)",
                                    "Esquecer a raiz quadrada na definição",
                                    "Ignorar limites de integração (0 a ∞ para sistemas estáveis)"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Relacionar norma L2 de u(t) ao consumo de energia do atuador",
                                  "subSteps": [
                                    "Identifique o consumo de energia em atuadores reais: ∫ u(t)^2 / R dt para resistivo, onde R é resistência.",
                                    "Mostre que ||u||_2^2 ≈ energia dissipada no atuador (para tensão u(t)).",
                                    "Analise limitações físicas: saturação, aquecimento, desgaste mecânico ligado à energia.",
                                    "Discuta viabilidade prática: atuadores com limites de potência contínua e pico.",
                                    "Calcule energia para um sinal u(t) de exemplo em um motor DC."
                                  ],
                                  "verification": "Derive a relação entre ||u||_2^2 e energia dissipada, aplicando a um modelo de atuador simples.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Modelo Simulink de motor DC",
                                    "Folha de dados de um atuador real (ex: servo motor)",
                                    "Python com SciPy para integração numérica"
                                  ],
                                  "tips": "Pense em u(t) como corrente ou tensão; consulte datasheets para valores reais de potência máxima.",
                                  "learningObjective": "Conectar norma L2 matematicamente ao consumo físico de energia em atuadores.",
                                  "commonMistakes": [
                                    "Assumir que norma L2 mede potência instantânea (é energia total)",
                                    "Ignorar fatores como eficiência do atuador",
                                    "Não considerar tempo finito vs. infinito"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Incorporar norma L2 em funções de custo",
                                  "subSteps": [
                                    "Estruture função de custo J = ∫ e(t)^2 dt + ρ ∫ u(t)^2 dt, onde ρ pondera esforço.",
                                    "Explique o trade-off: pequeno ρ prioriza desempenho (rastreamento), grande ρ limita energia.",
                                    "Implemente em LQR: Q para estado, R = ρ para controle (R relacionado a 1/ρ em alguns textos).",
                                    "Ajuste ρ via simulação para diferentes cenários de atuador.",
                                    "Otimize J minimizando via gradiente ou LQR solver."
                                  ],
                                  "verification": "Construa e minimize uma função de custo J com termo L2 de u(t) para um sistema de segunda ordem.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "MATLAB Control System Toolbox ou Python control library",
                                    "Exemplos de sistemas: massa-mola-amortecedor"
                                  ],
                                  "tips": "Comece com ρ=1 e ajuste logaritmicamente; plote J vs. ρ para visualizar trade-offs.",
                                  "learningObjective": "Formular funções de custo que penalizam consumo de energia via norma L2.",
                                  "commonMistakes": [
                                    "Confundir penalidade em e(t) vs u(t)",
                                    "Escolher ρ arbitrário sem justificativa física",
                                    "Esquecer normalização das integrais"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Balancear desempenho e viabilidade prática",
                                  "subSteps": [
                                    "Simule sistema fechado com diferentes ρ e avalie overshoot, tempo de assentamento e ||u||_2.",
                                    "Defina limites práticos: ||u||_2 < E_max baseado em bateria ou specs do atuador.",
                                    "Compare controladores: PID vs LQR com norma L2, quantificando economia de energia.",
                                    "Analise robustez: adicione ruído e perturbações, verificando se alto ρ preserva estabilidade.",
                                    "Documente trade-offs em tabela: desempenho vs. energia."
                                  ],
                                  "verification": "Gere relatório com simulações mostrando balanceamento ótimo de ρ para um caso realista.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Simulink ou Python (matplotlib para plots)",
                                    "Dados reais de um atuador (ex: drone motor)"
                                  ],
                                  "tips": "Use Pareto front para visualizar: menor energia com desempenho aceitável.",
                                  "learningObjective": "Avaliar e otimizar funções de custo balanceando normas de erro e controle.",
                                  "commonMistakes": [
                                    "Focar só em desempenho ignorando energia",
                                    "Não simular tempo longo para capturar energia total",
                                    "Sobre-otimizar ρ causando resposta lenta excessiva"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um drone estabilizador, u(t) é a tensão PWM para motores. Incorpore ||u||_2 em J para limitar bateria (E_max=100J por voo), balanceando com rastreamento de atitude (erro <5°). Simule rejeição de vento: ρ=0.1 dá bom voo de 10min sem superaquecimento.",
                              "finalVerifications": [
                                "Calcula ||u||_2 corretamente para sinal simulado.",
                                "Constrói J com termo ρ||u||_2^2 e minimiza via LQR.",
                                "Identifica ρ ótimo dado limite de energia do atuador.",
                                "Compara trade-offs em gráficos de desempenho vs. energia.",
                                "Explica limitações físicas em contexto real.",
                                "Aplica a um sistema não trivial com simulação."
                              ],
                              "assessmentCriteria": [
                                "Precisão matemática na definição e cálculo de normas L2 (80% correto).",
                                "Correta interpretação física de ||u||_2 como energia (com derivação).",
                                "Formulação válida de J com balanceamento via ρ (funcional em código).",
                                "Análise qualitativa/quantitativa de trade-offs (gráficos claros).",
                                "Aplicação prática viável, respeitando specs reais de atuadores.",
                                "Ausência de erros comuns como confusão de normas."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Análise funcional e integrais de Lebesgue.",
                                "Física: Conservação de energia e modelo elétrico de atuadores.",
                                "Informática: Programação numérica para otimização (LQR solvers).",
                                "Economia/Engenharia: Otimização custo-benefício em sistemas embarcados.",
                                "Sustentabilidade: Minimização de consumo energético em IoT."
                              ],
                              "realWorldApplication": "Em veículos autônomos, limita energia de atuadores hidráulicos para freios, evitando desgaste e otimizando autonomia da bateria; em HVAC industriais, reduz custo operacional balanceando conforto térmico com eficiência energética."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.6.2.2",
                        "name": "Margens de Estabilidade em Critérios Objetivos",
                        "description": "Uso de margens de ganho (GM), fase (PM) e estabilidade robusta para definir penalidades em funções de custo, garantindo estabilidade em presença de variações paramétricas.",
                        "specificSkills": [
                          {
                            "id": "10.1.6.2.2.1",
                            "name": "Quantificar margens de estabilidade clássicas",
                            "description": "Calcular GM e PM a partir de diagramas de Bode para laços de realimentação, e traduzi-las em restrições suaves para funções de custo via aproximações como 1/(1 + GM).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os conceitos de Margem de Ganho (GM) e Margem de Fase (PM) em diagramas de Bode",
                                  "subSteps": [
                                    "Explicar o diagrama de Bode: magnitude e fase em função da frequência logarítmica.",
                                    "Definir GM: frequência onde fase = -180°, GM = 1 / |G(jω_g)| (em linear) ou -20 log10(|G(jω_g)|) em dB.",
                                    "Definir PM: frequência onde |G(jω_p)| = 1 (0 dB), PM = 180° + ∠G(jω_p).",
                                    "Interpretar valores: GM > 1 e PM > 45° indicam boa estabilidade relativa.",
                                    "Analisar impacto em laços de realimentação unitária."
                                  ],
                                  "verification": "Resumir definições e critérios de estabilidade em um parágrafo e esboçar um diagrama de Bode anotado.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Diagramas de Bode de exemplo",
                                    "Folha de anotações",
                                    "Software de visualização como MATLAB ou Python (control library)"
                                  ],
                                  "tips": "Sempre verifique as unidades: dB para magnitude e graus para fase.",
                                  "learningObjective": "Dominar definições e interpretação qualitativa de GM e PM para estabilidade.",
                                  "commonMistakes": "Confundir frequência de cruzamento de fase (-180°) com ganho (0 dB); ignorar convenções de sinal."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Calcular GM e PM manualmente a partir de diagramas de Bode",
                                  "subSteps": [
                                    "Identificar ω_g no diagrama de fase onde ∠G(jω) = -180°.",
                                    "Ler |G(jω_g)| do diagrama de magnitude e calcular GM = 1 / |G(jω_g)| ou em dB.",
                                    "Identificar ω_p no diagrama de magnitude onde |G(jω_p)| = 0 dB.",
                                    "Ler ∠G(jω_p) do diagrama de fase e calcular PM = 180° + ∠G(jω_p).",
                                    "Validar cálculos com ferramentas numéricas se disponível."
                                  ],
                                  "verification": "Calcular GM e PM para 2 diagramas fornecidos e comparar com valores esperados (erro <5%).",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Diagramas de Bode impressos ou digitais",
                                    "Calculadora ou régua para leitura gráfica",
                                    "Planilha Excel para cálculos"
                                  ],
                                  "tips": "Use interpolação linear em escalas log para precisão em leituras gráficas.",
                                  "learningObjective": "Executar cálculos precisos de margens a partir de representações gráficas.",
                                  "commonMistakes": "Ler frequência errada ou esquecer de converter dB para linear (GM = 10^(-GM_dB/20))."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Traduzir margens de estabilidade em restrições suaves para funções de custo",
                                  "subSteps": [
                                    "Explicar limitações de restrições rígidas (ex: GM >= 2) em otimização.",
                                    "Apresentar aproximação suave para GM: f(GM) = 1 / (1 + GM), que penaliza GM baixo suavemente.",
                                    "Derivar ou justificar: f(GM) → 0 quando GM >>1, f(GM) →1 quando GM →0.",
                                    "Estender para PM: usar aproximações como 1 / (1 + tan(π/2 - PM/180 * π/2)) ou similar.",
                                    "Formular termo de custo: J_robustez = w_gm * f(GM) + w_pm * f(PM)."
                                  ],
                                  "verification": "Derivar f(GM) para um valor alvo e plotar curva de penalidade.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Papel e lápis para derivações",
                                    "Python/MATLAB para plotar funções suaves",
                                    "Referências teóricas de controle robusto"
                                  ],
                                  "tips": "Escolha pesos w para balancear desempenho e robustez no custo total.",
                                  "learningObjective": "Converter métricas clássicas em penalidades diferenciáveis para otimizadores.",
                                  "commonMistakes": "Usar GM em dB na fórmula linear; não normalizar funções para [0,1]."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Integrar margens quantificadas em uma função de custo completa e testar",
                                  "subSteps": [
                                    "Construir função de custo total: J = J_desempenho + λ * J_robustez.",
                                    "Implementar cálculo de GM/PM e restrições suaves em código.",
                                    "Simular um laço de realimentação e otimizar parâmetros minimizando J.",
                                    "Analisar sensibilidade: variar parâmetros e verificar robustez.",
                                    "Comparar com projeto clássico sem robustez suave."
                                  ],
                                  "verification": "Otimizar um sistema exemplo e demonstrar GM/PM melhorados sem perda excessiva de desempenho.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Software de simulação (MATLAB Control System Toolbox ou Python control/scipy)",
                                    "Sistema de exemplo (ex: planta G(s)=1/(s(s+1)))",
                                    "Computador"
                                  ],
                                  "tips": "Comece com λ pequeno e aumente iterativamente para tuning.",
                                  "learningObjective": "Aplicar quantificação de margens em loop de otimização algorítmica.",
                                  "commonMistakes": "Ignorar dinâmica em simulações; otimizar sem verificar estabilidade fechada."
                                }
                              ],
                              "practicalExample": "Para um laço de controle de velocidade de motor DC com G(s) = K/(s(τs+1)), plote Bode do laço aberto com K=10, τ=0.5. Calcule GM ≈ 8 dB (fator 2.5), PM ≈ 50°. Função de custo: J = ∫e² dt + 10 * (1/(1+2.5) + 1/(1 + tan(π/4))) ≈ desempenho + 0.22 + 0.17. Otimize K para minimizar J mantendo robustez.",
                              "finalVerifications": [
                                "GM e PM calculados com precisão gráfica (±10% ou 5°).",
                                "Restrições suaves f(GM) e f(PM) corretamente formuladas e plotadas.",
                                "Função de custo J inclui termos de robustez com pesos apropriados.",
                                "Simulação mostra estabilidade e robustez melhorada pós-otimização.",
                                "Comparação qualitativa com método clássico (ex: Ziegler-Nichols).",
                                "Relatório resume valores e trade-offs."
                              ],
                              "assessmentCriteria": [
                                "Precisão nos cálculos de GM/PM (erro <5%).",
                                "Correta derivação e implementação de aproximações suaves.",
                                "Adequação da função de custo: diferenciável e penaliza corretamente baixa robustez.",
                                "Resultados de simulação demonstram trade-off desempenho-robustez.",
                                "Interpretação clara de implicações para estabilidade real.",
                                "Uso eficiente de ferramentas e documentação de passos."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Análise de Fourier e funções complexas para Bode.",
                                "Programação: Implementação numérica em Python/MATLAB para automação.",
                                "Física: Modelagem dinâmica de sistemas mecatrônicos.",
                                "Otimização: Gradiente descendente ou algoritmos genéticos para min J.",
                                "Estatística: Análise de sensibilidade a perturbações paramétricas."
                              ],
                              "realWorldApplication": "Em controle de aeronaves ou robótica industrial, quantificar GM/PM via Bode permite incorporar robustez a variações (ex: massa alterada) em otimizadores de custo, evitando instabilidades catastróficas em operação real."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.6.2.2.2",
                            "name": "Incorporar margens em otimizações numéricas",
                            "description": "Formular termos de penalidade em funções de custo que minimizem a sensibilidade a variações, usando métricas como distância ao ponto crítico de Nyquist.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender métricas de robustez e estabilidade via diagrama de Nyquist",
                                  "subSteps": [
                                    "Revise o critério de Nyquist e o ponto crítico (-1,0).",
                                    "Calcule a distância do contorno de Nyquist ao ponto crítico para um sistema dado.",
                                    "Identifique margens de ganho e fase como métricas de robustez.",
                                    "Analise sensibilidade a variações paramétricas usando exemplos simples.",
                                    "Plote diagramas de Nyquist para sistemas nominais e perturbados."
                                  ],
                                  "verification": "Capacidade de plotar diagrama de Nyquist e calcular distância mínima ao ponto crítico com precisão < 5%.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": "MATLAB/Simulink ou Python (control/matplotlib), notas de controle avançado.",
                                  "tips": "Use logspace para frequências e foque em ω próxima à frequência de cruzamento.",
                                  "learningObjective": "Dominar cálculo de métricas de robustez baseadas em Nyquist.",
                                  "commonMistakes": "Confundir margem de ganho com distância euclidiana; ignorar direção do contorno."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Projetar função de custo básica para desempenho",
                                  "subSteps": [
                                    "Defina objetivos de desempenho: erro de rastreamento, tempo de estabilização.",
                                    "Formule integral quadrática do erro (ISE) ou similar para monovariáveis.",
                                    "Inclua termos para controle (energia de u(t)).",
                                    "Teste a função em um otimizador simples sem penalidades.",
                                    "Avalie trade-offs entre desempenho e esforço de controle."
                                  ],
                                  "verification": "Função de custo computada corretamente para um sistema de referência, com valores coerentes.",
                                  "estimatedTime": "2 horas",
                                  "materials": "Python (scipy.optimize), modelo de planta em estado-espaco.",
                                  "tips": "Normalise termos para evitar dominância de um sobre o outro.",
                                  "learningObjective": "Construir funções de custo que capturem especificações de desempenho.",
                                  "commonMistakes": "Escolha inadequada de pesos iniciais levando a otimização instável."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Formular termos de penalidade para margens de estabilidade",
                                  "subSteps": [
                                    "Defina métrica: distância mínima d(ω) ao ponto crítico de Nyquist.",
                                    "Crie penalidade inversa: P = 1 / (d(ω_min) - margem_desejada)^2 se d < threshold.",
                                    "Integre penalidade na função de custo total: J = J_desempenho + λ * P_robustez.",
                                    "Ajuste hiperparâmetro λ via simulações iniciais.",
                                    "Verifique monotonicidade da penalidade com redução de robustez."
                                  ],
                                  "verification": "Penalidade aumenta corretamente quando distância Nyquist cai abaixo de 0.5.",
                                  "estimatedTime": "2.5 horas",
                                  "materials": "Funções de Nyquist personalizadas em MATLAB/Python, exemplos de controladores LQG.",
                                  "tips": "Use penalidade suave (huber loss) para evitar singularidades.",
                                  "learningObjective": "Incorporar robustez diretamente na função de custo via penalidades.",
                                  "commonMistakes": "Penalidade muito agressiva que domina o desempenho."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Implementar otimização numérica e validar",
                                  "subSteps": [
                                    "Configure otimizador (fmincon ou scipy.minimize) com restrições de estabilidade.",
                                    "Otimize parâmetros do controlador com a função de custo composta.",
                                    "Simule sistema otimizado sob nominais e perturbado (±20% parâmetros).",
                                    "Compare métricas pré e pós-otimização: desempenho e robustez.",
                                    "Ajuste iterações para convergência."
                                  ],
                                  "verification": "Otimizador converge com redução >20% na sensibilidade mantendo desempenho.",
                                  "estimatedTime": "3 horas",
                                  "materials": "MATLAB Optimization Toolbox ou Python (scipy, cvxpy para restrições).",
                                  "tips": "Forneça bom chute inicial de parâmetros para aceleração.",
                                  "learningObjective": "Executar otimização numérica com margens embutidas.",
                                  "commonMistakes": "Violar restrições de estabilidade por falta de bounds."
                                }
                              ],
                              "practicalExample": "Para um controlador de posição de motor DC (planta G(s) = 1/(s(s+1))), formule J = ∫e² dt + 0.1∫u² dt + 10 / (d_Nyquist - 0.3)^2. Otimize ganhos Kp, Ki, Kd minimizando J, verificando d_Nyquist > 0.5 pós-otimização.",
                              "finalVerifications": [
                                "Distância ao ponto crítico de Nyquist > 0.5 em todas as frequências.",
                                "Função de custo total reduzida em pelo menos 15% vs baseline sem penalidade.",
                                "Simulações com ±15% variação paramétrica mantêm estabilidade e overshoot <20%.",
                                "Penalidade contribui <30% ao custo total em solução ótima.",
                                "Gradientes da função de custo computados corretamente para robustez.",
                                "Controller otimizado atende specs de desempenho (assentamento <2s)."
                              ],
                              "assessmentCriteria": [
                                "Precisão no cálculo de métricas Nyquist (erro <3%).",
                                "Formulação correta de penalidade com trade-off λ adequado.",
                                "Convergência da otimização em <50 iterações.",
                                "Análise de sensibilidade quantitativa com gráficos.",
                                "Capacidade de generalizar para outra planta monovariável.",
                                "Documentação clara da função de custo e resultados."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Otimização não-convexa e análise complexa.",
                                "Programação: Implementação numérica de funções de custo (Python/MATLAB).",
                                "Física: Modelagem dinâmica de sistemas mecânicos/elétricos.",
                                "Estatística: Análise de sensibilidade e Monte Carlo para variações."
                              ],
                              "realWorldApplication": "Em sistemas aeroespaciais, como controle de atitude de satélites, onde variações em massa/inércia exigem robustez; penalidades em funções de custo garantem estabilidade sob incertezas, evitando falhas catastróficas."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.6.2.3",
                        "name": "Modelos de Incerteza e Robustez em Funções de Custo",
                        "description": "Representação de incertezas (aditivas, multiplicativas, não estruturadas) e sua integração em funções de custo para síntese de controladores robustos via otimização.",
                        "specificSkills": [
                          {
                            "id": "10.1.6.2.3.1",
                            "name": "Modelar incertezas em plantas nominais",
                            "description": "Desenvolver modelos de incerteza Δ em forma padrão (P, C, M), como Δ multiplicativa ||W_Δ Δ||_∞ < 1, para capturar variações paramétricas e não paramétricas em sistemas monovariáveis.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a planta nominal e tipos de incerteza",
                                  "subSteps": [
                                    "Defina a planta nominal P como o modelo conhecido do sistema monovariável.",
                                    "Classifique incertezas em paramétricas (variações em parâmetros fixos) e não-paramétricas (efeitos dinâmicos não modelados).",
                                    "Estude exemplos de incertezas reais em sistemas de controle.",
                                    "Revise normas de robustez, especialmente ||Δ||_∞.",
                                    "Anote diferenças entre incertezas aditivas e multiplicativas."
                                  ],
                                  "verification": "Escreva um resumo de 200 palavras explicando planta nominal vs. incerta e tipos de Δ.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Livro 'Multivariable Feedback Control' de Skogestad",
                                    "Notas de aula sobre controle robusto",
                                    "Calculadora simbólica como MATLAB Symbolic Toolbox"
                                  ],
                                  "tips": "Use diagramas de bloco para visualizar P e Δ.",
                                  "learningObjective": "Identificar e diferenciar fontes de incerteza em plantas nominais.",
                                  "commonMistakes": [
                                    "Confundir incerteza paramétrica com estocástica",
                                    "Ignorar incertezas não-paramétricas em sistemas reais"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar fontes de incerteza na planta específica",
                                  "subSteps": [
                                    "Analise a planta real: colete dados de parâmetros nominais e variações observadas.",
                                    "Liste variações paramétricas (ex.: ganho ±20%).",
                                    "Identifique não-paramétricas (ex.: atrasos, não-linearidades).",
                                    "Meça desvios relativos ou absolutos em frequência.",
                                    "Crie uma tabela de fontes de incerteza com magnitudes."
                                  ],
                                  "verification": "Produza uma tabela com pelo menos 5 fontes de incerteza quantificadas.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Dados experimentais da planta",
                                    "Software Bode plot (MATLAB/Simulink)",
                                    "Folha de cálculo (Excel)"
                                  ],
                                  "tips": "Priorize incertezas em frequências de interesse do controlador.",
                                  "learningObjective": "Quantificar incertezas paramétricas e não-paramétricas de forma precisa.",
                                  "commonMistakes": [
                                    "Superestimar incertezas pequenas",
                                    "Não considerar faixa de frequência"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Selecionar configuração e tipo de modelo de incerteza",
                                  "subSteps": [
                                    "Escolha configuração: P (planta), C (controlador) ou M (loop aberto).",
                                    "Decida tipo: Δ multiplicativa para variações relativas, aditiva para absolutas.",
                                    "Desenhe diagrama de bloco com Δ inserida (ex.: P(1+W_Δ Δ)).",
                                    "Justifique escolha baseada em análise de frequência.",
                                    "Compare prós e contras de cada configuração."
                                  ],
                                  "verification": "Desenhe e explique o diagrama de bloco escolhido em um relatório curto.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Ferramenta de desenho (Draw.io ou Simulink)",
                                    "Referências teóricas sobre robustez H∞"
                                  ],
                                  "tips": "Para plantas, use Δ multiplicativa se ganho variar mais que fase.",
                                  "learningObjective": "Selecionar adequadamente estrutura (P/C/M) e tipo de Δ.",
                                  "commonMistakes": [
                                    "Usar configuração errada para o tipo de incerteza",
                                    "Ignorar impacto no loop fechado"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Construir perturbação Δ e peso W_Δ",
                                  "subSteps": [
                                    "Modele Δ como bloco dinâmico capturando desvios (ex.: ordem 1 para paramétrica).",
                                    "Sintetize W_Δ para englobar Δ: ||W_Δ Δ||_∞ < 1.",
                                    "Use plots de Bode para ajustar W_Δ às margens de incerteza.",
                                    "Simule Δ em diferentes cenários.",
                                    "Itere até satisfazer a condição de norma."
                                  ],
                                  "verification": "Gere plots Bode de Δ e W_Δ Δ mostrando ||.||_∞ < 1.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "MATLAB Control System Toolbox",
                                    "Exemplos de código para modelagem robusta"
                                  ],
                                  "tips": "Comece com W_Δ = 0.2 para 20% incerteza em baixa frequência.",
                                  "learningObjective": "Construir modelos Δ e W_Δ válidos para robustez.",
                                  "commonMistakes": [
                                    "W_Δ muito conservadora (reduz desempenho)",
                                    "Não verificar norma em todo o espectro"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Validar e documentar o modelo de incerteza",
                                  "subSteps": [
                                    "Verifique ||W_Δ Δ||_∞ < 1 via simulação numérica.",
                                    "Teste sensibilidade a variações extremas.",
                                    "Documente modelo com equações, plots e justificativas.",
                                    "Compare com métodos alternativos (ex.: μ-síntese).",
                                    "Prepare relatório final com limitações."
                                  ],
                                  "verification": "Execute simulações e confirme norma <1; produza relatório de 1 página.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "MATLAB hinfnorm() function",
                                    "Template de relatório"
                                  ],
                                  "tips": "Use grid de frequências log para precisão em ||.||_∞.",
                                  "learningObjective": "Validar e comunicar modelos de incerteza de forma profissional.",
                                  "commonMistakes": [
                                    "Pular validação numérica",
                                    "Não documentar suposições"
                                  ]
                                }
                              ],
                              "practicalExample": "Para um motor DC de posição com planta nominal P(s) = 1/(s(s+1)), ganho varia ±20% e atraso de 0.1s. Modele como configuração P com Δ multiplicativa: P = P_nom (1 + W_Δ Δ), onde W_Δ(s) = 0.2 (1 + 0.1s)/s, e Δ unitária ||Δ||_∞=1 captura variações.",
                              "finalVerifications": [
                                "Explica diferenças entre Δ paramétrica e não-paramétrica com exemplos.",
                                "Desenha corretamente diagrama para configuração P com Δ multiplicativa.",
                                "Constrói W_Δ tal que ||W_Δ Δ||_∞ <1 para incerteza dada.",
                                "Valida modelo via plots Bode e simulação.",
                                "Identifica limitações do modelo proposto.",
                                "Aplica a um sistema real simples."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de fontes de incerteza (30%)",
                                "Correção na escolha de configuração e tipo de Δ (20%)",
                                "Qualidade da síntese de W_Δ e verificação de norma (25%)",
                                "Clareza de documentação e plots (15%)",
                                "Validação via simulação e análise de sensibilidade (10%)"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Cálculo de normas H-infinito e análise em frequência",
                                "Probabilidade: Modelagem de variações estocásticas como bounds determinísticos",
                                "Física: Dinâmica de sistemas reais com não-linearidades",
                                "Informática: Programação numérica em MATLAB para controle",
                                "Engenharia de Software: Documentação de modelos para equipes"
                              ],
                              "realWorldApplication": "Em indústrias aeroespaciais, modela incertezas aerodinâmicas em plantas de aeronaves para sintetizar controladores robustos H∞ que mantêm estabilidade apesar de variações de vento ou desgaste."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.6.2.3.2",
                            "name": "Definir funções de custo para robustez H∞",
                            "description": "Construir J_robust = ||T_{zw}||_∞ onde z inclui erros e u, w entradas, garantindo robustez via minimização da norma H∞ do sistema generalizado.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os fundamentos da norma H∞ e controle robusto",
                                  "subSteps": [
                                    "Estudar a definição matemática da norma H∞ para sistemas lineares: sup_ω ||G(jω)||₂.",
                                    "Revisar o problema padrão de controle H∞ e sua interpretação como ganho induzido L₂.",
                                    "Analisar exemplos simples de sistemas não robustos versus robustos sob perturbações.",
                                    "Explorar o significado físico da minimização da norma H∞ para atenuar efeitos de distúrbios.",
                                    "Resolver exercícios básicos de cálculo de norma H∞ usando ferramentas computacionais."
                                  ],
                                  "verification": "Calcular corretamente a norma H∞ de um sistema dado simples e explicar seu significado.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Livro 'Robust and Optimal Control' de Zhou et al.",
                                    "MATLAB com toolbox Control System.",
                                    "Aulas gravadas sobre H∞ (YouTube ou Coursera)."
                                  ],
                                  "tips": "Visualize a resposta em frequência para entender picos que afetam a norma.",
                                  "learningObjective": "Dominar a definição e interpretação da norma H∞ em contextos de controle.",
                                  "commonMistakes": [
                                    "Confundir norma H∞ com H₂ (RMS vs. pior caso).",
                                    "Ignorar a frequência em análises de Bode."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Modelar o sistema generalizado com incertezas e entradas",
                                  "subSteps": [
                                    "Definir o modelo nominal do sistema G com entradas de controle u e saídas y.",
                                    "Incorporar incertezas Δ (estruturadas ou não) no framework de sistema generalizado P.",
                                    "Identificar entradas exógenas w (distúrbios, ruído) e saídas de performance z.",
                                    "Construir o diagrama de blocos do sistema generalizado P = [P11 P12; P21 P22].",
                                    "Validar o modelo com simulações iniciais de perturbações."
                                  ],
                                  "verification": "Desenhar corretamente o sistema generalizado P para um exemplo dado.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Software MATLAB/Simulink.",
                                    "Templates de modelos em LaTeX ou Draw.io para diagramas.",
                                    "Artigo 'H∞ Control Tutorial'."
                                  ],
                                  "tips": "Use blocos Δ para representar incertezas multiplicativas ou aditivas explicitamente.",
                                  "learningObjective": "Construir modelos generalizados que capturem incertezas e distúrbios.",
                                  "commonMistakes": [
                                    "Omitir conexões corretas entre w, z, u e y no diagrama.",
                                    "Confundir incertezas com distúrbios não modelados."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Definir as saídas de erro z e construir T_{zw}",
                                  "subSteps": [
                                    "Especificar z como vetor que inclui erros de tracking, controle effort e sensibilidade a Δ.",
                                    "Configurar w como vetor com distúrbios, referências e sinais de incerteza.",
                                    "Derivar a transferência T_{zw} = F_l(P, K) onde K é o controlador e F_l é conexão linear.",
                                    "Expressar pesos de performance W_e, W_u, W_Δ para ponderar componentes de z.",
                                    "Implementar em MATLAB para computar T_{zw}(s)."
                                  ],
                                  "verification": "Obter a matriz de transferência T_{zw} correta para um sistema de 2 entradas/2 saídas.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "MATLAB com funções hinfsyn e sigma.",
                                    "Folhas de exercícios com sistemas SISO/MIMO simples."
                                  ],
                                  "tips": "Escolha pesos iniciais conservadores para W_e >1 e W_u <1 para balancear performance.",
                                  "learningObjective": "Formular z e w adequadamente para capturar especificações de robustez.",
                                  "commonMistakes": [
                                    "Definir z sem incluir todos os canais de erro relevantes.",
                                    "Esquecer pesos de frequência em T_{zw}."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Formular J_robust = ||T_{zw}||_∞ e planejar minimização",
                                  "subSteps": [
                                    "Definir J_robust = sup_ω \bar{σ}(T_{zw}(jω)) onde \bar{σ} é valor singular máximo.",
                                    "Interpretar γ = ||T_{zw}||_∞ <1 como condição de robustez (small gain theorem).",
                                    "Discutir métodos de síntese: Algoritmo de Doyle ou LMI para minimizar γ.",
                                    "Simular o loop fechado e verificar estabilidade robusta com μ-analysis.",
                                    "Documentar a função de custo em relatório com gráficos de singular values."
                                  ],
                                  "verification": "Calcular ||T_{zw}||_∞ e propor um γ alvo <1 com justificativa.",
                                  "estimatedTime": "2.5 horas",
                                  "materials": [
                                    "MATLAB Robust Control Toolbox.",
                                    "Exemplos de código GitHub para H∞ synthesis."
                                  ],
                                  "tips": "Use gamma iteration para síntese prática; monitore condicionamento numérico.",
                                  "learningObjective": "Estabelecer J_robust como métrica de robustez e estratégias de otimização.",
                                  "commonMistakes": [
                                    "Usar norma errada (ex: trace em vez de singular value).",
                                    "Não verificar robustez estruturada com Δ normais."
                                  ]
                                }
                              ],
                              "practicalExample": "Em um sistema de controle de posição de um braço robótico com incerteza paramétrica de 20% na massa, defina w = [referência r; distúrbio d; sinal de incerteza v], z = [W_e(e); W_u(u); W_Δ(y)], construa T_{zw} e minimize ||T_{zw}||_∞ < 1.2 para garantir tracking apesar de variações.",
                              "finalVerifications": [
                                "Pode derivar T_{zw} a partir de P e K corretamente?",
                                "Calcula ||T_{zw}||_∞ usando sigma plot no MATLAB?",
                                "Explica o small gain theorem aplicado a robustez?",
                                "Identifica pesos adequados para um caso prático?",
                                "Verifica estabilidade robusta com simulações de Δ?",
                                "Formula J_robust explicitamente para MIMO?"
                              ],
                              "assessmentCriteria": [
                                "Correção matemática na definição de z, w e T_{zw} (30%).",
                                "Interpretação física de ||T_{zw}||_∞ e robustez (25%).",
                                "Implementação computacional precisa em MATLAB (20%).",
                                "Escolha e justificativa de pesos de performance (15%).",
                                "Análise de resultados com gráficos de Bode/singular values (10%)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Álgebra linear (valores singulares) e análise funcional.",
                                "Programação: Simulações numéricas em MATLAB/Simulink.",
                                "Física: Dinâmica de sistemas com perturbações estocásticas.",
                                "Otimização: Problemas de minimização com LMIs.",
                                "Engenharia de Software: Modelagem em Stateflow para validação."
                              ],
                              "realWorldApplication": "Projeto de controladores para aviões (ex: estabilização de flight envelope com variações aerodinâmicas) ou veículos autônomos, garantindo performance sob incertezas de modelo para segurança crítica."
                            },
                            "estimatedTime": "2.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.6.2.3.3",
                            "name": "Balancear desempenho e robustez em funções multiobjetivo",
                            "description": "Combinar termos de desempenho (||S||_∞, ||T||_∞) e robustez (||M||_∞) em funções de custo ponderadas, como J = α J_perf + (1-α) J_rob, para trade-offs em métodos algorítmicos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar normas de sensibilidade, complementar e robustez",
                                  "subSteps": [
                                    "Estude as definições de ||S||_∞ (norma de sensibilidade), ||T||_∞ (norma complementar) e ||M||_∞ (norma multiplicativa de robustez).",
                                    "Calcule essas normas para um sistema simples de segunda ordem usando MATLAB/Simulink ou Python (Control Systems Library).",
                                    "Interprete os valores: ||S||_∞ baixo indica bom rastreamento, ||T||_∞ baixo indica bom rejeição de distúrbios, ||M||_∞ <1 garante estabilidade robusta.",
                                    "Plote respostas em frequência para visualizar picos e trade-offs iniciais.",
                                    "Compare com especificações de desempenho padrão (ex: ||S||_∞ < 2, ||T||_∞ < 3)."
                                  ],
                                  "verification": "Gere gráficos de Bode com normas calculadas corretamente e interpretações escritas em um relatório curto.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "MATLAB/Simulink ou Python com control library",
                                    "Sistema de exemplo G(s) = 1/(s^2 + s + 1)",
                                    "Documentação de normas H-infinito"
                                  ],
                                  "tips": "Use comandos como norm(sys, inf) no MATLAB para cálculos rápidos; foque em picos de magnitude.",
                                  "learningObjective": "Compreender o significado físico e matemático das normas de desempenho e robustez em sistemas de controle.",
                                  "commonMistakes": [
                                    "Confundir S com T; ignorar unidades de frequência; não normalizar o modelo de planta."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Formular funções de custo individuais J_perf e J_rob",
                                  "subSteps": [
                                    "Defina J_perf = max( ||S||_∞, ||T||_∞ ) ou soma ponderada, priorizando bandas de frequência específicas (ex: baixa freq para rastreamento).",
                                    "Defina J_rob = ||M||_∞, considerando modelo de incerteza Δ (ex: Δ norm-bounded).",
                                    "Implemente essas funções em código, usando otimização para minimizar cada uma separadamente.",
                                    "Simule para um controlador PID inicial e compute valores numéricos de J_perf e J_rob.",
                                    "Analise sensibilidade a mudanças em parâmetros da planta (ex: variação de ganho)."
                                  ],
                                  "verification": "Código funcional que computa J_perf e J_rob com valores < thresholds definidos (ex: J_perf < 2.5).",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Software de simulação (MATLAB/Python)",
                                    "Modelos de planta com incerteza",
                                    "Funções de otimização como fmincon ou scipy.optimize"
                                  ],
                                  "tips": "Pondere bandas de frequência com pesos W_s, W_t para J_perf; teste múltiplos controladores.",
                                  "learningObjective": "Capacitar a quantificação isolada de desempenho e robustez via funções de custo escalares.",
                                  "commonMistakes": [
                                    "Não considerar incertezas corretamente em M; otimizar sem constraints realistas; ignorar normalização LTI."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Construir e parametrizar função multiobjetivo J = α J_perf + (1-α) J_rob",
                                  "subSteps": [
                                    "Introduza o parâmetro α ∈ [0,1] e formule J(α) = α J_perf + (1-α) J_rob.",
                                    "Implemente uma função de otimização que minimize J(α) para diferentes valores de α (ex: grid search de 0 a 1 em passos de 0.1).",
                                    "Plote curvas de Pareto aproximadas: J_perf vs J_rob para vários α.",
                                    "Selecione α ótimo baseado em requisitos (ex: α=0.7 para priorizar desempenho).",
                                    "Valide estabilidade com análise μ ou simulações em laço fechado."
                                  ],
                                  "verification": "Gráficos de trade-off com pelo menos 10 pontos de α, mostrando mínimo de J e estabilidade.",
                                  "estimatedTime": "2.5 horas",
                                  "materials": [
                                    "Código de otimização estendido",
                                    "Ferramentas de plotagem (matplotlib/plot)",
                                    "Modelos com Δ aleatória para testes"
                                  ],
                                  "tips": "Use otimização multi-objetivo como NSGA-II se disponível; normalize J_perf e J_rob para escalas comparáveis.",
                                  "learningObjective": "Dominar a combinação linear ponderada para capturar trade-offs multiobjetivo em design de controladores.",
                                  "commonMistakes": [
                                    "Escolha arbitrária de α sem simulação; não normalizar custos; otimizar sem verificar robustez global."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Avaliar trade-offs e otimizar o balanceamento",
                                  "subSteps": [
                                    "Simule respostas temporais para α selecionado vs casos extremos (α=0,1).",
                                    "Teste robustez com variações de planta (ex: ±20% ganho, polo variável).",
                                    "Compute métricas agregadas e compare com especificações industriais.",
                                    "Ajuste α iterativamente baseado em simulações Monte Carlo.",
                                    "Documente o trade-off final em um relatório com recomendações."
                                  ],
                                  "verification": "Relatório com simulações robustas mostrando J < threshold e violações mínimas.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Simulador estocástico",
                                    "Banco de plantas perturbadas",
                                    "Templates de relatório"
                                  ],
                                  "tips": "Automatize sweeps de α com loops; priorize α que minimize pior caso (max-min).",
                                  "learningObjective": "Aplicar análise de sensibilidade para selecionar α ótimo em cenários realistas.",
                                  "commonMistakes": [
                                    "Sobre-otimizar para nominal ignorando robustez; não testar gama completa de α; plots sem legendas."
                                  ]
                                }
                              ],
                              "practicalExample": "Em um drone de entrega, balanceie ||S||_∞ para rastreamento rápido de trajetória (J_perf) com ||M||_∞ para robustez a ventos variáveis (J_rob). Use α=0.6 para J mínima, simulando em Simulink com Δ modelando turbulência, resultando em controlador que mantém erro <5% sob incertezas.",
                              "finalVerifications": [
                                "Computa corretamente normas ||S||_∞, ||T||_∞, ||M||_∞ para sistema dado.",
                                "Formula J(α) e gera curva de Pareto com trade-offs visíveis.",
                                "Otimiza α com simulações robustas sem instabilidades.",
                                "Interpreta resultados alinhados a specs (ex: J < 2).",
                                "Documenta processo com código reproduzível.",
                                "Testa com incertezas reais e valida performance."
                              ],
                              "assessmentCriteria": [
                                "Precisão matemática nas definições e cálculos de normas (>95% correção).",
                                "Qualidade da curva de trade-off (resolução fina, múltiplos α testados).",
                                "Robustez demonstrada em simulações (sem violações >10%).",
                                "Clareza na interpretação e justificativa de α escolhido.",
                                "Eficiência do código e tempo de convergência da otimização.",
                                "Integração de todos elementos em relatório coeso."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Otimização multiobjetivo e normas funcionais (Análise Funcional).",
                                "Programação: Implementação numérica em Python/MATLAB (Engenharia de Software).",
                                "Física: Modelagem de dinâmicas com incertezas (Mecânica/ Dinâmica de Sistemas).",
                                "Estatística: Análise Monte Carlo para robustez (Probabilidade).",
                                "Design de Sistemas: Trade-offs em engenharia (Engenharia de Sistemas)."
                              ],
                              "realWorldApplication": "No design de controladores automotivos (ABS/ESC), balanceia desempenho de frenagem rápida (J_perf) com robustez a variações de pneus/estrada (J_rob), usando α≈0.7 para reduzir paradas em 20% sob condições adversas, conforme padrões ISO 26262."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.6.3",
                    "name": "Algoritmos de Otimização Não Linear",
                    "description": "Métodos numéricos como gradiente descendente, quasi-Newton e algoritmos genéticos para minimização de parâmetros.",
                    "individualConcepts": [
                      {
                        "id": "10.1.6.3.1",
                        "name": "Algoritmo de Gradiente Descendente",
                        "description": "Método iterativo de otimização que utiliza o gradiente da função objetivo para minimizar parâmetros de controladores, convergindo para um mínimo local através de atualizações proporcionais ao gradiente negativo.",
                        "specificSkills": [
                          {
                            "id": "10.1.6.3.1.1",
                            "name": "Compreender o princípio do gradiente descendente",
                            "description": "Explicar o funcionamento do algoritmo, incluindo a fórmula de atualização θ_{k+1} = θ_k - α ∇J(θ_k), escolha do passo α, condições de convergência e limitações em funções não convexas para otimização de controladores LIT.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Introdução ao Problema de Otimização e Conceito de Gradiente",
                                  "subSteps": [
                                    "Defina o problema de otimização não linear como minimizar uma função custo J(θ), onde θ são os parâmetros do controlador LIT.",
                                    "Explique o gradiente ∇J(θ) como o vetor que aponta na direção de maior aumento da função J.",
                                    "Visualize geometricamente o gradiente em uma superfície 2D ou 3D de J(θ).",
                                    "Discuta por que seguir o negativo do gradiente leva à descida mais íngreme.",
                                    "Relacione com controladores LIT: J(θ) pode ser erro quadrático médio em resposta ao degrau."
                                  ],
                                  "verification": "Desenhe e rotule o gradiente em um gráfico de uma função quadrática J(θ) = θ² e explique a direção de descida.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Caderno e lápis",
                                    "Gráficos impressos ou software como Desmos/GeoGebra",
                                    "Calculadora"
                                  ],
                                  "tips": "Use analogia de descer uma montanha: o gradiente indica a ladeira mais íngreme.",
                                  "learningObjective": "Compreender o papel do gradiente na otimização intuitivamente.",
                                  "commonMistakes": [
                                    "Confundir gradiente com derivada escalar em funções multivariáveis.",
                                    "Ignorar que ∇J aponta para aumento, não diminuição."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Fórmula de Atualização do Gradiente Descendente",
                                  "subSteps": [
                                    "Apresente a fórmula θ_{k+1} = θ_k - α ∇J(θ_k), identificando θ_k (parâmetros atuais), α (taxa de aprendizado) e ∇J(θ_k).",
                                    "Calcule manualmente ∇J para J(θ) = (1/2)θ² em 1D.",
                                    "Estenda para multivariável: ∇J(θ) = [∂J/∂θ1, ∂J/∂θ2, ...].",
                                    "Simule 3 iterações manualmente com α=0.1 e J(θ)=θ², θ0=2.",
                                    "Aplique a um exemplo de controlador LIT: minimize J(Kp) para ganho proporcional."
                                  ],
                                  "verification": "Aplique a fórmula em um exemplo numérico e compute θ1, θ2, θ3 corretamente.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Folha de cálculo ou Python/Jupyter Notebook",
                                    "Exemplos impressos de funções custo"
                                  ],
                                  "tips": "Comece com funções simples quadráticas para validar intuição antes de complexas.",
                                  "learningObjective": "Dominar a fórmula de atualização e computá-la manualmente.",
                                  "commonMistakes": [
                                    "Erro no sinal: usar +α em vez de -α.",
                                    "Calcular derivadas parciais incorretamente."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Escolha da Taxa de Aprendizado α e Condições de Convergência",
                                  "subSteps": [
                                    "Explique o papel de α: muito pequeno (lento), muito grande (oscila ou diverge).",
                                    "Teste diferentes α (0.01, 0.1, 1.0) em um exemplo numérico e observe convergência.",
                                    "Discuta condições de convergência: J convexa, α < 2/L (L Lipschitz constante).",
                                    "Implemente critério de parada: ||∇J|| < ε ou k > max_iter.",
                                    "Analise gráfico de convergência J vs. iterações para diferentes α."
                                  ],
                                  "verification": "Escolha α ótimo para convergir em <10 iterações em um exemplo dado.",
                                  "estimatedTime": "50 minutos",
                                  "materials": [
                                    "Python com NumPy/Matplotlib",
                                    "Gráficos de convergência pré-gerados"
                                  ],
                                  "tips": "Use backtracking line search para ajustar α dinamicamente em prática.",
                                  "learningObjective": "Selecionar α e prever comportamento de convergência.",
                                  "commonMistakes": [
                                    "Escolher α fixo sem testar, levando a divergência.",
                                    "Ignorar Lipschitz para funções não suaves."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Limitações em Funções Não Convexas e Aplicação em Controladores LIT",
                                  "subSteps": [
                                    "Explique limitações: convergência para mínimo local, não global em não convexas.",
                                    "Compare GD vs. métodos globais (ex: simulated annealing) em função com múltiplos mínimos.",
                                    "Aplique GD para otimizar controlador LIT: J(θ) = ∫ e(t)² dt para θ=[Kp, Ki].",
                                    "Simule em software e observe armadilhas como saddle points.",
                                    "Discuta momentum ou Adam como melhorias para não convexas."
                                  ],
                                  "verification": "Identifique e explique um mínimo local em um exemplo não convexo usando GD.",
                                  "estimatedTime": "55 minutos",
                                  "materials": [
                                    "MATLAB/Simulink ou Python com control library",
                                    "Funções não convexas como Rosenbrock"
                                  ],
                                  "tips": "Inicialize θ0 com valores físicos realistas para controladores.",
                                  "learningObjective": "Reconhecer limitações e contextualizar em engenharia de controle.",
                                  "commonMistakes": [
                                    "Assumir convergência global sem verificar convexidade.",
                                    "Não normalizar ∇J em escalas diferentes de θ."
                                  ]
                                }
                              ],
                              "practicalExample": "Otimize os ganhos de um controlador PID para um sistema LIT de segundo ordem minimizando J(Kp, Ki, Kd) = ∫[0^T] e(t)^2 dt + penalidade em controle u(t). Inicie com θ0=[1,0,0], α=0.01, rode 100 iterações em Python/Simulink até ||∇J||<0.01, compare resposta ao degrau antes/depois.",
                              "finalVerifications": [
                                "Explicar verbalmente a fórmula θ_{k+1} = θ_k - α ∇J(θ_k) com exemplo numérico.",
                                "Escolher α adequado e justificar convergência em função convexa.",
                                "Identificar limitação em não convexa e propor inicialização múltipla.",
                                "Simular GD para otimizar J em controlador LIT e plotar convergência.",
                                "Derivar ∇J para função custo quadrática multivariável.",
                                "Discutir condições Lipschitz para α."
                              ],
                              "assessmentCriteria": [
                                "Precisão na derivação e aplicação da fórmula de atualização (30%)",
                                "Compreensão intuitiva e visual do gradiente e descida (20%)",
                                "Análise correta de α, convergência e critérios de parada (20%)",
                                "Identificação precisa de limitações em não convexas (15%)",
                                "Aplicação contextual em controladores LIT com simulação (10%)",
                                "Clareza em explicações e avoidance de erros comuns (5%)"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Cálculo vetorial e otimização convexa.",
                                "Programação: Implementação numérica em Python/NumPy para loops iterativos.",
                                "Física: Analogia com dinâmica de partículas em potencial J(θ).",
                                "Engenharia de Software: Debugging de divergência em otimizadores.",
                                "Machine Learning: Base para treinamento de redes em controle adaptativo."
                              ],
                              "realWorldApplication": "No tuning automático de controladores PID para drones ou robôs industriais, onde GD minimiza erro de rastreamento em tempo real, ajustando ganhos online apesar de não convexidades introduzidas por saturação atuador."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.6.3.1.2",
                            "name": "Implementar gradiente descendente em MATLAB",
                            "description": "Codificar o algoritmo para minimizar uma função custo como erro quadrático médio em simulações de sistemas monovariáveis, ajustando parâmetros de um controlador PID com dados de simulação.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Definir o modelo do sistema e a simulação do controlador PID",
                                  "subSteps": [
                                    "Crie um modelo matemático simples de um sistema monovariável, como um motor DC de primeira ordem: G(s) = 1/(s+1).",
                                    "Implemente a simulação do controlador PID em tempo discreto usando a equação u(k) = Kp*e(k) + Ki*sum(e) + Kd*(e(k)-e(k-1)).",
                                    "Gere dados de referência (step input) e ruído para simulação em um vetor de tempo de 100 amostras com Ts=0.1s.",
                                    "Defina os parâmetros iniciais do PID: Kp=1, Ki=0.1, Kd=0.05.",
                                    "Escreva uma função MATLAB para simular a resposta fechada e calcular o erro."
                                  ],
                                  "verification": "Execute a função de simulação e confirme que gera saídas estáveis sem erros, plotando y(k) vs referência.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "MATLAB com Control System Toolbox",
                                    "Documentação PID básica"
                                  ],
                                  "tips": "Use vetores pré-alocados para eficiência; comece com um sistema simples para depuração rápida.",
                                  "learningObjective": "Compreender a modelagem discreta de sistemas de controle e simulação PID.",
                                  "commonMistakes": [
                                    "Não pré-alocar arrays levando a lentidão",
                                    "Ignorar delay de amostragem no PID",
                                    "Usar valores iniciais extremos causando instabilidade"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Formular a função custo e calcular os gradientes analíticos",
                                  "subSteps": [
                                    "Defina a função custo J(theta) = (1/N) * sum((r(k) - y(k))^2), onde theta = [Kp, Ki, Kd].",
                                    "Derive os gradientes parciais: dJ/dKp = (2/N)*sum(e(k)*de/dKp), similar para Ki e Kd, computando de/dtheta via simulação sensível.",
                                    "Implemente uma função MATLAB custo_gradiente(theta) que retorna [J, gradJ].",
                                    "Teste com theta inicial plotando J e gradientes.",
                                    "Ajuste para evitar divisão por zero ou NaNs em gradientes."
                                  ],
                                  "verification": "Chame a função com theta=[1,0.1,0.05] e verifique se J é positivo e gradientes são vetores 1x3 não-zero.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Cálculo multivariável básico",
                                    "Editor MATLAB"
                                  ],
                                  "tips": "Use syms para derivadas simbólicas iniciais, depois numéricas para precisão; finite differences como backup.",
                                  "learningObjective": "Dominar formulação de MSE e computação de gradientes para otimização em controle.",
                                  "commonMistakes": [
                                    "Erro no sinal dos gradientes (deve apontar para mínimo)",
                                    "Não normalizar por N",
                                    "Gradientes zero por simulação mal condicionada"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar o loop principal do algoritmo de gradiente descendente",
                                  "subSteps": [
                                    "Inicialize theta = [1, 0.1, 0.05], alpha=0.01 (learning rate), max_iter=1000, tol=1e-6.",
                                    "Em um loop while: compute J e grad = custo_gradiente(theta); theta = theta - alpha*grad; armazene histórico.",
                                    "Implemente decay de alpha: alpha = alpha * 0.99 por iteração.",
                                    "Adicione early stopping se |delta J| < tol.",
                                    "Salve histórico de theta, J em arrays para análise."
                                  ],
                                  "verification": "Execute o loop e confirme que J diminui em pelo menos 50% após 100 iterações, sem divergência.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Script MATLAB principal"
                                  ],
                                  "tips": "Monitore gradiente norma; se explodir, reduza alpha manualmente.",
                                  "learningObjective": "Codificar iterações de GD com safeguards para convergência estável.",
                                  "commonMistakes": [
                                    "Alpha muito alto causando overshoot e divergência",
                                    "Loop infinito sem tolerância",
                                    "Não armazenar histórico para debug"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Executar simulação final, visualizar resultados e validar convergência",
                                  "subSteps": [
                                    "Use theta otimizado para simular resposta PID final vs inicial.",
                                    "Plote: J vs iterações, trajetórias theta, resposta y(k) com referência.",
                                    "Calcule métricas: tempo de assentamento, overshoot, J_final.",
                                    "Teste robustez variando ruído ou referência.",
                                    "Compare com fminunc (otimizador MATLAB) para validação."
                                  ],
                                  "verification": "Plots mostram convergência suave, J_final < 0.01, e resposta PID melhorada (overshoot <10%).",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Funções plot, hold on",
                                    "fminunc para benchmark"
                                  ],
                                  "tips": "Use semilogy para J; adicione legendas claras.",
                                  "learningObjective": "Analisar e validar resultados de otimização em contexto de controle.",
                                  "commonMistakes": [
                                    "Plots confusos sem labels",
                                    "Ignorar validação cross-check com otimizadores built-in",
                                    "Conclusão prematura sem métricas"
                                  ]
                                }
                              ],
                              "practicalExample": "Ajuste PID para um tanque de nível: minimize MSE entre nível desejado (step de 1m) e medido, simulando com G(s)=1/(10s+1), reduzindo overshoot de 30% para 5% em 200s.",
                              "finalVerifications": [
                                "Função custo diminui monotonicamente para <1e-4.",
                                "Parâmetros PID convergem sem oscilações excessivas.",
                                "Resposta simulada tem overshoot <10% e assentamento <50 Ts.",
                                "Gradientes finais têm norma <1e-5.",
                                "Código executa em <10s para 1000 iterações.",
                                "Resultados coincidem com otimizador MATLAB em 5%."
                              ],
                              "assessmentCriteria": [
                                "Código completo e comentado roda sem erros.",
                                "Convergência em <500 iterações com J_final <0.01.",
                                "Gradientes corretos validados por diferenças finitas.",
                                "Visualizações claras mostram melhoria PID.",
                                "Robustez a variações de ruído/referência.",
                                "Eficiência: vetorizado, sem loops desnecessários."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Cálculo vetorial e otimização não linear.",
                                "Programação: Estruturas de loop, funções e vetorização em MATLAB.",
                                "Física: Modelagem dinâmica de sistemas de controle.",
                                "Estatística: Análise de erro quadrático e métricas de performance."
                              ],
                              "realWorldApplication": "Tuning automático de controladores PID em indústrias como automotiva (controle de motor) ou química (nível de tanques), reduzindo tempo de engenharia de dias para horas em PLCs industriais com MATLAB/Simulink."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.6.3.1.3",
                            "name": "Aplicar a tuning de controladores via gradiente descendente",
                            "description": "Usar o método para otimizar ganhos de um controlador em presença de incertezas, avaliando estabilidade e desempenho com critérios como overshoot e tempo de assentamento.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Modelar o Sistema e Inicializar o Controlador",
                                  "subSteps": [
                                    "Obtenha ou derive o modelo matemático do sistema (função de transferência ou equações diferenciais).",
                                    "Defina a estrutura do controlador (ex: PID) e seus ganhos iniciais (Kp, Ki, Kd).",
                                    "Incorpore incertezas no modelo (ex: variação de parâmetros ±20%).",
                                    "Implemente o modelo em software de simulação (MATLAB/Simulink ou Python com control library).",
                                    "Execute uma simulação inicial para baseline do desempenho."
                                  ],
                                  "verification": "Modelo simulado produz resposta estável com overshoot inicial quantificado.",
                                  "estimatedTime": "1-2 horas",
                                  "materials": [
                                    "Software de simulação (MATLAB, Python com libraries como control, scipy)",
                                    "Documentação do sistema real ou dados experimentais"
                                  ],
                                  "tips": "Comece com valores iniciais de ganhos via método de Ziegler-Nichols para baseline rápido.",
                                  "learningObjective": "Entender como representar sistemas com incertezas para tuning robusto.",
                                  "commonMistakes": [
                                    "Ignorar incertezas levando a tuning frágil",
                                    "Escolha errada de estrutura de controlador",
                                    "Modelo instável desde o início"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Definir a Função de Custo e Gradientes",
                                  "subSteps": [
                                    "Escolha métricas de desempenho: overshoot (Mp), tempo de assentamento (Ts), erro steady-state (ess).",
                                    "Formule a função de custo J(θ) = w1*Mp + w2*Ts + w3*ess, onde θ = [Kp, Ki, Kd].",
                                    "Derive analiticamente ou numéricamente os gradientes ∂J/∂θi via simulações repetidas.",
                                    "Normalize os pesos wi baseados em prioridades (ex: estabilidade > desempenho).",
                                    "Teste a função de custo com ganhos iniciais para validar."
                                  ],
                                  "verification": "Gradientes calculados produzem mudanças coerentes na J ao variar θ.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Ferramentas numéricas (gradient descent em Python ou Optimization Toolbox no MATLAB)"
                                  ],
                                  "tips": "Use step response para métricas; evite funções de custo não diferenciáveis.",
                                  "learningObjective": "Mapear objetivos de controle para uma função otimizável.",
                                  "commonMistakes": [
                                    "Pesos wi desbalanceados causando foco em métrica errada",
                                    "Gradientes numéricos imprecisos por passos muito grandes",
                                    "Ignorar restrições de estabilidade na J"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar e Executar o Algoritmo de Gradiente Descendente",
                                  "subSteps": [
                                    "Defina hiperparâmetros: learning rate α (ex: 0.01), número de iterações (ex: 100), tolerância.",
                                    "No loop: Calcule J e gradientes, atualize θ_new = θ_old - α * ∇J.",
                                    "Inclua momentum ou adaptação de α se oscilar.",
                                    "Monitore convergência plotando J vs iterações e respostas do sistema.",
                                    "Pare se J não diminuir ou estagna."
                                  ],
                                  "verification": "Ganhos convergem, J diminui monotonicamente em pelo menos 50%.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Código Python/MATLAB com loops de otimização",
                                    "Plots para monitoramento"
                                  ],
                                  "tips": "Use α pequeno inicial e decay; logue todas iterações para debug.",
                                  "learningObjective": "Aplicar GD iterativamente para otimização em espaço contínuo.",
                                  "commonMistakes": [
                                    "Learning rate alto causando divergência",
                                    "Poucas iterações sem convergência",
                                    "Não checar gradientes vanishing/exploding"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Avaliar Estabilidade, Desempenho e Robustez",
                                  "subSteps": [
                                    "Analise estabilidade com Nyquist/Bode ou eigenvalues para ganhos otimizados.",
                                    "Simule respostas para cenários nominais e com incertezas máximas.",
                                    "Compare métricas pré/pós-tuning: Mp <10%, Ts <2s, ess <1%.",
                                    "Teste sensibilidade variando parâmetros do sistema.",
                                    "Documente ganhos finais e plots comparativos."
                                  ],
                                  "verification": "Sistema estável em todos cenários, melhorias quantificadas >30% em métricas chave.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Ferramentas de análise de estabilidade (rlocus, nyquist)"
                                  ],
                                  "tips": "Sempre valide com simulações fechadas; considere LMI para robustez extra.",
                                  "learningObjective": "Avaliar se tuning atende critérios em presença de incertezas.",
                                  "commonMistakes": [
                                    "Foco só em nominal ignorando robustez",
                                    "Análise de estabilidade superficial",
                                    "Métricas não quantificadas"
                                  ]
                                }
                              ],
                              "practicalExample": "Tune um controlador PID para um motor DC com função de transferência G(s) = 1/(s(s+1)) e incerteza de 20% no polo. Otimize para rampa de referência, minimizando overshoot e settling time via GD em Python, alcançando Kp=2.5, Ki=1.2, Kd=0.8 após 50 iterações.",
                              "finalVerifications": [
                                "Função de custo J reduzida em pelo menos 40% dos valores iniciais.",
                                "Sistema estável (margens de ganho/fase >6dB/45°).",
                                "Overshoot <10% e settling time <3s em nominal e ±20% incerteza.",
                                "Gradientes e atualizações convergem sem oscilações.",
                                "Resposta robusta a distúrbios e mudanças de referência.",
                                "Código reproduzível com plots de convergência."
                              ],
                              "assessmentCriteria": [
                                "Precisão da modelagem e incorporação de incertezas (20%).",
                                "Correção da função de custo e gradientes (25%).",
                                "Implementação eficiente do GD com convergência (25%).",
                                "Análise completa de estabilidade e desempenho (20%).",
                                "Documentação clara com plots e justificativas (10%)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Cálculo vetorial e otimização não linear.",
                                "Programação: Implementação numérica de algoritmos iterativos.",
                                "Física: Dinâmica de sistemas e modelagem de plantas reais.",
                                "Estatística: Análise de sensibilidade e Monte Carlo para incertezas."
                              ],
                              "realWorldApplication": "Otimização de controladores em plantas industriais como fornos de temperatura (controle PID robusto apesar de variações térmicas) ou drones (tuning de atitude com ventos variáveis), reduzindo tempo de setup e melhorando eficiência energética."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.6.3.2",
                        "name": "Métodos Quasi-Newton",
                        "description": "Algoritmos de otimização que aproximam a Hessiana da função objetivo de forma eficiente, como o método BFGS, para acelerar a convergência na minimização não linear de parâmetros de sistemas de controle.",
                        "specificSkills": [
                          {
                            "id": "10.1.6.3.2.1",
                            "name": "Entender a aproximação da matriz Hessiana no BFGS",
                            "description": "Descrever a atualização da matriz B_k ≈ H(θ_k) usando fórmulas BFGS, vantagens sobre gradiente descendente puro e aplicação em problemas de robustez para controladores LIT escalares.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Fundamentos da Matriz Hessiana e Métodos Newton",
                                  "subSteps": [
                                    "Defina a matriz Hessiana H(θ) como a matriz de segundas derivadas parciais do custo J(θ).",
                                    "Explique por que o método de Newton usa H^{-1} para passos de busca: p_k = -H_k^{-1} ∇J(θ_k).",
                                    "Discuta limitações computacionais de calcular H exata em alta dimensão.",
                                    "Introduza métodos quasi-Newton como alternativa para aproximar H_k ≈ B_k.",
                                    "Revise gradiente descendente (GD) puro: p_k = -α ∇J(θ_k)."
                                  ],
                                  "verification": "Resuma em um parágrafo as diferenças entre Newton, quasi-Newton e GD, com fórmulas chave.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Livro 'Numerical Optimization' de Nocedal & Wright (Cap. 6)",
                                    "Notebook Jupyter com funções de custo simples"
                                  ],
                                  "tips": "Use visualizações de curvas de nível para ilustrar passos de Newton vs GD.",
                                  "learningObjective": "Compreender o papel da Hessiana na otimização e motivação para aproximações.",
                                  "commonMistakes": [
                                    "Confundir Hessiana com Jacobiana",
                                    "Ignorar custo computacional de inversão de H"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Derivar e Entender a Fórmula de Atualização BFGS",
                                  "subSteps": [
                                    "Apresente vetores de mudança: s_k = θ_{k+1} - θ_k e y_k = ∇J(θ_{k+1}) - ∇J(θ_k).",
                                    "Escreva a fórmula BFGS para B_{k+1}: B_{k+1} = B_k + (y_k y_k^T)/(y_k^T s_k) - (B_k s_k (B_k s_k)^T)/(s_k^T B_k s_k).",
                                    "Derive a condição de curvatura: y_k^T s_k > 0 para garantir positividade definida.",
                                    "Implemente a atualização em pseudocódigo ou Python para uma função quadrática.",
                                    "Verifique simetricidade e positividade definida da matriz atualizada."
                                  ],
                                  "verification": "Implemente e rode a atualização em código; confira se B_{k+1} é simétrica e positiva definida.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Paper original BFGS (Broyden 1970)",
                                    "Biblioteca SciPy.optimize para comparação",
                                    "Código Python com NumPy"
                                  ],
                                  "tips": "Inicialize B_0 como I (identidade) para simplicidade.",
                                  "learningObjective": "Dominar a fórmula exata de atualização BFGS e suas propriedades.",
                                  "commonMistakes": [
                                    "Esquecer transposições em y y^T",
                                    "Violar condição de curvatura sem skip"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar Vantagens do BFGS sobre Gradiente Descendente Puro",
                                  "subSteps": [
                                    "Compare convergência: superlinear no BFGS vs linear no GD.",
                                    "Discuta eficiência: BFGS usa gradientes apenas, sem segundas derivadas.",
                                    "Simule em função não convexa (ex: Rosenbrock) e plote trajetórias.",
                                    "Quantifique redução de iterações: BFGS tipicamente 2-10x mais rápido.",
                                    "Aborde armazém de informação: custo O(n^2) por iteração, mas viável para n<1000."
                                  ],
                                  "verification": "Gere gráficos comparativos de convergência para GD vs BFGS em uma função teste.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Notebook Jupyter com otimizadores",
                                    "Funções teste: quadratic, Rosenbrock"
                                  ],
                                  "tips": "Use learning rate adaptativa no GD para fair comparison.",
                                  "learningObjective": "Identificar cenários onde BFGS supera GD em velocidade e precisão.",
                                  "commonMistakes": [
                                    "Comparar sem line search comum",
                                    "Ignorar dimensões altas onde BFGS falha"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar BFGS em Problemas de Robustez para Controladores LIT Escalares",
                                  "subSteps": [
                                    "Defina controlador LIT (Linear Time-Invariant) escalar: C(s) = K / (1 + τ s).",
                                    "Formule custo de robustez: min_θ J(θ) com θ = [K, τ], sob perturbações Δ.",
                                    "Use BFGS para otimizar θ maximizando margem de estabilidade (ex: ganho de fase).",
                                    "Simule em planta incerta e compare com GD.",
                                    "Avalie robustez via métricas: ||S||_∞ < γ para sensibilidade S."
                                  ],
                                  "verification": "Otimize um controlador LIT com BFGS e verifique redução em J(θ) > 20%.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "MATLAB/Simulink ou Python Control Systems Library",
                                    "Exemplo de planta: 1/(s(s+1)) com Δ"
                                  ],
                                  "tips": "Inclua bounds em θ para evitar controladores instáveis.",
                                  "learningObjective": "Aplicar BFGS em otimização de controle para robustez.",
                                  "commonMistakes": [
                                    "Não linearizar custo para LIT",
                                    "Omitir validação em laço fechado"
                                  ]
                                }
                              ],
                              "practicalExample": "Otimize um controlador LIT C(s) = K/(1+τs) para planta P(s)=1/(s(s+1)) com incerteza ±20% em ganho. Use BFGS para min J(θ)=∫|S(jω)|^2 dω, onde θ=[K,τ]. Inicial B_0=I, converja em 15 iterações vs 50 no GD, melhorando margem de fase de 45° para 60°.",
                              "finalVerifications": [
                                "Derivar corretamente a fórmula BFGS completa.",
                                "Implementar atualização em código funcional.",
                                "Explicar 3 vantagens chave sobre GD com evidências simuladas.",
                                "Aplicar em exemplo de controlador LIT com resultados quantificados.",
                                "Verificar propriedades (simetria, PD) da B_k atualizada.",
                                "Comparar convergência em gráfico para função não quadrática."
                              ],
                              "assessmentCriteria": [
                                "Precisão na derivação da fórmula BFGS (100% match).",
                                "Correção da implementação (convergência sem erros numéricos).",
                                "Profundidade na análise de vantagens (quantitativa, não só qualitativa).",
                                "Relevância da aplicação em controle LIT robusto.",
                                "Clareza em verificações e propriedades matemáticas.",
                                "Criatividade no exemplo prático e conexões reais."
                              ],
                              "crossCurricularConnections": [
                                "Álgebra Linear: Propriedades de matrizes simétricas positivas definidas.",
                                "Programação Numérica: Implementação de otimizadores em Python/NumPy.",
                                "Engenharia de Controle: Síntese de controladores H∞ e robustez.",
                                "Cálculo Variacional: Derivação de condições de otimalidade."
                              ],
                              "realWorldApplication": "Em automação industrial, BFGS otimiza parâmetros de PIDs robustos para plantas com incertezas (ex: motores DC variáveis), reduzindo oscilações em 30-50% vs GD, usado em PLCs da Siemens ou MATLAB MPC Designer."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.6.3.2.2",
                            "name": "Implementar método quasi-Newton em software",
                            "description": "Programar o algoritmo BFGS em MATLAB para otimizar parâmetros de um controlador considerando normas H∞, utilizando funções como fminunc com opções quasi-Newton.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Definir o problema de otimização e modelar o sistema",
                                  "subSteps": [
                                    "Estude o sistema monovariável e o controlador parametrizado (ex: PID ou lead-lag).",
                                    "Defina a função objetivo baseada na norma H∞ do sistema em laço fechado.",
                                    "Especifique os limites iniciais e restrições para os parâmetros do controlador.",
                                    "Crie o modelo do plantio usando tf() ou ss() no MATLAB.",
                                    "Implemente a função para calcular a norma H∞ usando norm() ou hinfnorm()."
                                  ],
                                  "verification": "Modelo simulado corretamente e norma H∞ calculada sem erros.",
                                  "estimatedTime": "1-2 horas",
                                  "materials": "MATLAB com Control System Toolbox, documentação de tf() e norm().",
                                  "tips": "Use sys = feedback(P*C,1) para laço fechado.",
                                  "learningObjective": "Compreender a formulação do problema de otimização em controle H∞.",
                                  "commonMistakes": "Esquecer de linearizar o modelo ou definir mal os parâmetros iniciais."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar a função objetivo (custo)",
                                  "subSteps": [
                                    "Crie uma função anônima ou arquivo .m para funObj(x) que recebe parâmetros x.",
                                    "Calcule o controlador C(x) com base nos parâmetros.",
                                    "Forme o sistema em laço fechado T = feedback(P*C,1).",
                                    "Compute gamma = hinfnorm(T) ou norm(T,inf).",
                                    "Retorne [gamma; gradiente aproximado se necessário] para fminunc."
                                  ],
                                  "verification": "funObj(x0) retorna valor finito e correto para x inicial.",
                                  "estimatedTime": "2-3 horas",
                                  "materials": "MATLAB, Control System Toolbox (hinfnorm requer Robust Control Toolbox).",
                                  "tips": "Teste com x fixo antes de otimizar.",
                                  "learningObjective": "Desenvolver função custo diferenciável para normas H∞.",
                                  "commonMistakes": "Não tratar singularidades ou usar norm errada (L2 em vez de H∞)."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Configurar e executar o otimizador quasi-Newton (BFGS via fminunc)",
                                  "subSteps": [
                                    "Defina x0 como chute inicial dos parâmetros.",
                                    "Crie opções: options = optimoptions('fminunc','Algorithm','quasi-newton','HessianApproximation','bfgs').",
                                    "Chame [x,fval,exitflag] = fminunc(@funObj, x0, options).",
                                    "Adicione tolerâncias: 'OptimalityTolerance',1e-6, 'StepTolerance',1e-10.",
                                    "Implemente callbacks para monitorar iterações se necessário."
                                  ],
                                  "verification": "exitflag > 0 e fval reduzido significativamente.",
                                  "estimatedTime": "1-2 horas",
                                  "materials": "MATLAB Optimization Toolbox.",
                                  "tips": "Use 'Display','iter' para debug.",
                                  "learningObjective": "Configurar fminunc para BFGS em problemas de controle.",
                                  "commonMistakes": "Escolher algoritmo errado ou tolerâncias muito frouxas."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Validar resultados e analisar desempenho",
                                  "subSteps": [
                                    "Simule o sistema otimizado com step() ou bode().",
                                    "Verifique se norma H∞ final atende especificações (ex: <1).",
                                    "Compare com solução inicial e analise convergência.",
                                    "Teste robustez variando parâmetros ou ruído.",
                                    "Gere plots de custo vs iteração e respostas em malha fechada."
                                  ],
                                  "verification": "Norma H∞ otimizada < limite e simulações estáveis.",
                                  "estimatedTime": "1-2 horas",
                                  "materials": "MATLAB plotting functions, stepinfo().",
                                  "tips": "Salve workspace para reprodutibilidade.",
                                  "learningObjective": "Avaliar eficácia da otimização quasi-Newton em controle.",
                                  "commonMistakes": "Ignorar instabilidades pós-otimização ou overfitting."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Refinar e documentar a implementação",
                                  "subSteps": [
                                    "Ajuste hiperparâmetros baseados em múltiplas runs.",
                                    "Adicione restrições via fmincon se necessário.",
                                    "Escreva comentários no código e README.",
                                    "Teste em sistema diferente para generalidade.",
                                    "Exporte resultados para relatório (figures, tabelas)."
                                  ],
                                  "verification": "Código rodável por terceiros com resultados consistentes.",
                                  "estimatedTime": "1 hora",
                                  "materials": "Editor MATLAB, publish().",
                                  "tips": "Use vectorized code para speed.",
                                  "learningObjective": "Tornar implementação robusta e reutilizável.",
                                  "commonMistakes": "Não documentar ou testar edge cases."
                                }
                              ],
                              "practicalExample": "Otimize parâmetros [Kp, Ki, Kd] de um PID para um motor DC modelado como P(s)=1/(s(s+1)), visando norma H∞ do erro de rastreamento < 0.5, usando BFGS em fminunc. Inicial: [1,0.1,0.01], final converge para valores que estabilizam e atenuam distúrbios.",
                              "finalVerifications": [
                                "fminunc convergeu com exitflag >=1.",
                                "Norma H∞ final < especificação desejada.",
                                "Simulação em laço fechado estável (polos no esquerdo).",
                                "Gradiente final próximo de zero.",
                                "Custo reduzido >50% do inicial.",
                                "Código executa em <5 min."
                              ],
                              "assessmentCriteria": [
                                "Correção da função custo (norma H∞ precisa).",
                                "Configuração correta de BFGS em options.",
                                "Validação com plots e métricas.",
                                "Tratamento de erros e edge cases.",
                                "Eficiência computacional (poucas iterações).",
                                "Documentação clara no código."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Cálculo variacional e aproximação de Hessiana.",
                                "Programação: Desenvolvimento de funções otimizadas em MATLAB.",
                                "Engenharia de Controle: Síntese H∞ e robustez.",
                                "Otimização Numérica: Métodos sem derivadas de 2a ordem.",
                                "Análise de Sistemas: Normas e estabilidade."
                              ],
                              "realWorldApplication": "Desenvolvimento de controladores robustos para drones (atenuação de vibrações), processos químicos (controle de reatores) ou automotivo (suspensão ativa), onde normas H∞ garantem desempenho apesar de incertezas no modelo."
                            },
                            "estimatedTime": "2.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.6.3.2.3",
                            "name": "Comparar convergência quasi-Newton vs. gradiente descendente",
                            "description": "Analisar numericamente a taxa de convergência em exemplos de tuning de controladores com incertezas, medindo iterações e precisão para funções custo quadráticas e não lineares.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Fundamentos Teóricos de Convergência",
                                  "subSteps": [
                                    "Estude as taxas de convergência teóricas: gradiente descendente (O(1/k)) vs. quasi-Newton (superlinear).",
                                    "Revise fórmulas chave: atualização de gradiente descendente (x_{k+1} = x_k - α ∇f(x_k)) e aproximação de Hessiana em quasi-Newton (ex: BFGS).",
                                    "Analise condições de convergência para funções quadráticas (exatas em n passos para Newton) e não lineares.",
                                    "Identifique impactos de incertezas em controladores (ex: perturbações paramétricas).",
                                    "Anote diferenças em termos de iterações e precisão numérica."
                                  ],
                                  "verification": "Resuma em um quadro comparativo as taxas de convergência e condições, com referências bibliográficas.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Livro 'Numerical Optimization' de Nocedal & Wright (cap. 2-3)",
                                    "Notas de aula sobre métodos quasi-Newton",
                                    "Artigo sobre convergência em otimização não linear"
                                  ],
                                  "tips": "Use diagramas de fluxo para visualizar atualizações de parâmetros.",
                                  "learningObjective": "Compreender diferenças teóricas de convergência para justificar comparações numéricas.",
                                  "commonMistakes": [
                                    "Confundir taxa local com global",
                                    "Ignorar dependência em α (passo de aprendizado)",
                                    "Não considerar Lipschitz continuidade"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Definir Problema de Otimização em Tuning de Controladores",
                                  "subSteps": [
                                    "Modele um sistema monovariável com incertezas (ex: planta G(s) = 1/(s+1) com variação de ganho ±20%).",
                                    "Defina funções custo: quadrática J(θ) = ∫ e²(t) dt e não linear J(θ) = ∫ |e(t)| + θ² dt.",
                                    "Especifique variáveis de otimização θ (ex: ganhos PID: Kp, Ki, Kd).",
                                    "Gere dados de simulação com ruído e incertezas usando Simulink ou Python Control.",
                                    "Implemente gradiente analítico ou numérico (finite differences)."
                                  ],
                                  "verification": "Crie script inicial com modelo e funções custo validadas por simulação básica.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "MATLAB/Simulink ou Python (control, scipy.optimize)",
                                    "Documentação SciPy para otimização",
                                    "Exemplos de tuning PID"
                                  ],
                                  "tips": "Normalize θ para evitar escalas díspares; teste com seed fixo para reprodutibilidade.",
                                  "learningObjective": "Configurar problemas realistas de controle para benchmark de algoritmos.",
                                  "commonMistakes": [
                                    "Funções custo não diferenciáveis",
                                    "Incertezas não modeladas corretamente",
                                    "Escolha inadequada de horizonte de simulação"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar e Executar Gradiente Descendente",
                                  "subSteps": [
                                    "Code GD com line search (Armijo) ou momentum adaptativo.",
                                    "Rode 100+ iterações, registrando ||∇f||, iterações até ε=1e-6, J final.",
                                    "Teste em custo quadrático e não linear, variando α inicial.",
                                    "Plote curvas de convergência: J(k) vs k, ∇f vs k.",
                                    "Registre estatísticas: média iterações, desvio padrão sobre 10 runs com ruído."
                                  ],
                                  "verification": "Gere plots e tabela com métricas (iterações < 200 para quadrático?).",
                                  "estimatedTime": "2.5 horas",
                                  "materials": [
                                    "Python: numpy, matplotlib, control library",
                                    "Jupyter Notebook para experimentos"
                                  ],
                                  "tips": "Use backtracking para line search; monitore overflow em gradientes.",
                                  "learningObjective": "Implementar GD robusto e coletar dados de performance numérica.",
                                  "commonMistakes": [
                                    "α fixa levando a divergência",
                                    "Não parar em critério de precisão",
                                    "Ignorar conditioning da Hessiana"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Implementar Quasi-Newton (BFGS) e Comparar",
                                  "subSteps": [
                                    "Implemente BFGS: inicialize B0=I, atualize com fórmula two-loop recursion.",
                                    "Ou use scipy.optimize.minimize(method='BFGS'); rode com mesmas condições.",
                                    "Compare métricas: iterações, tempo CPU, precisão final (||∇f||<1e-8).",
                                    "Analise em cenários com incertezas: média sobre Monte Carlo (20 sims).",
                                    "Crie tabelas/plots lado a lado destacando superioridade quasi-Newton."
                                  ],
                                  "verification": "Relatório com tabelas comparativas e conclusão quantitativa (ex: quasi-Newton 3x mais rápido).",
                                  "estimatedTime": "2.5 horas",
                                  "materials": [
                                    "SciPy optimize docs",
                                    "Código base do step 3",
                                    "LaTeX/Markdown para relatório"
                                  ],
                                  "tips": "Reset Bk a cada run; compare com limited-memory BFGS para escalabilidade.",
                                  "learningObjective": "Demonstrar superioridade prática de quasi-Newton via experimentos.",
                                  "commonMistakes": [
                                    "Atualização BFGS inválida (não positiva definida)",
                                    "Comparação injusta (diferentes inicializações)",
                                    "Não reportar variância"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Analisar Resultados e Generalizar",
                                  "subSteps": [
                                    "Calcule speedup: iterações_QN / iterações_GD; teste significância (t-test).",
                                    "Discuta por que quasi-Newton é melhor em não lineares com incertezas.",
                                    "Teste sensibilidade a inicialização θ0 e ε.",
                                    "Documente código em repo GitHub com README.",
                                    "Prepare apresentação com key insights."
                                  ],
                                  "verification": "Relatório final com análise estatística e código versionado.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "GitHub",
                                    "Statsmodels ou scipy.stats para t-test",
                                    "PowerPoint/Keynote"
                                  ],
                                  "tips": "Use boxplots para variabilidade; generalize para multivariáveis.",
                                  "learningObjective": "Extrair insights acionáveis de comparações numéricas.",
                                  "commonMistakes": [
                                    "Cherry-picking runs favoráveis",
                                    "Não discutir limitações (ex: custo por iteração)",
                                    "Falta de reprodutibilidade"
                                  ]
                                }
                              ],
                              "practicalExample": "Em tuning de PID para um motor DC com incerteza de 20% no tempo de constante, otimize J = ∫(r(t)-y(t))² dt + 0.1∫u² dt (quadrática) e J_nl = ∫|r-y| + log(1+u²) dt (não linear). GD leva ~150 iterações (precisão 1e-5), quasi-Newton ~35, reduzindo overshoot de 25% para 8%.",
                              "finalVerifications": [
                                "Plots mostram convergência mais rápida do quasi-Newton em ambos custos.",
                                "Tabela com <50 iterações para QN vs >100 para GD em quadrático.",
                                "Análise estatística confirma speedup significativo (p<0.05).",
                                "Controlador tunado com QN tem menor erro em validação com incertezas.",
                                "Código executável reproduz resultados em <5min.",
                                "Relatório discute trade-offs (ex: memória em QN)."
                              ],
                              "assessmentCriteria": [
                                "Precisão das implementações (erro <1e-6 em benchmark conhecido).",
                                "Qualidade dos plots e tabelas (legendas, escalas log para convergência).",
                                "Análise quantitativa robusta (médias, desvios, testes stats).",
                                "Correta modelagem de incertezas em controle.",
                                "Clareza no relatório (conclusões suportadas por dados).",
                                "Reprodutibilidade total (seeds, params documentados)."
                              ],
                              "crossCurricularConnections": [
                                "Programação Numérica: Implementação em Python/MATLAB (CS).",
                                "Estatística: Análise de variância e testes de hipótese (Stats).",
                                "Engenharia de Software: Versionamento Git e docs (SE).",
                                "Física/Mecânica: Modelagem dinâmica de sistemas com incertezas.",
                                "Machine Learning: Paralelos com SGD e Adam (quase-Newton aproximado)."
                              ],
                              "realWorldApplication": "Em indústrias como automotiva (controle de motores EV) e aeroespacial (tuning de atuadores), quasi-Newton acelera calibração de controladores sob variações paramétricas, reduzindo tempo de desenvolvimento de dias para horas e melhorando robustez em produção."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.6.3.3",
                        "name": "Algoritmos Genéticos",
                        "description": "Métodos de otimização evolutiva baseados em seleção natural para explorar o espaço de parâmetros globalmente, ideais para funções multimodais na síntese de controladores robustos.",
                        "specificSkills": [
                          {
                            "id": "10.1.6.3.3.1",
                            "name": "Compreender os operadores genéticos básicos",
                            "description": "Explicar seleção, crossover, mutação e elitismo em algoritmos genéticos, codificação de cromossomos para parâmetros de controladores e função fitness baseada em desempenho e robustez.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender Seleção e Elitismo",
                                  "subSteps": [
                                    "Estudar a definição de seleção como mecanismo para escolher os melhores indivíduos da população.",
                                    "Analisar tipos comuns de seleção: roleta, torneio e seleção por ranking.",
                                    "Explicar elitismo como estratégia para preservar os melhores indivíduos para a próxima geração.",
                                    "Comparar vantagens e desvantagens de cada método de seleção.",
                                    "Simular um exemplo simples de seleção em uma população pequena."
                                  ],
                                  "verification": "Capacidade de listar e explicar pelo menos 3 métodos de seleção com exemplos numéricos.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Slides ou vídeo sobre algoritmos genéticos",
                                    "Papel e caneta para simulações",
                                    "Artigo introdutório sobre AG"
                                  ],
                                  "tips": "Use diagramas para visualizar o processo de seleção e elitismo.",
                                  "learningObjective": "Entender como a seleção e elitismo mantêm a qualidade da população em AG.",
                                  "commonMistakes": "Confundir seleção com mutação ou ignorar o risco de convergência prematura sem elitismo."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Compreender o Operador de Crossover",
                                  "subSteps": [
                                    "Definir crossover como recombinação genética entre dois pais para gerar filhos.",
                                    "Estudar tipos de crossover: de ponto único, de dois pontos e uniforme.",
                                    "Explicar como o crossover preserva características boas dos pais.",
                                    "Analisar a taxa de crossover e seu impacto na diversidade da população.",
                                    "Realizar um exemplo manual de crossover em cromossomos binários."
                                  ],
                                  "verification": "Executar crossover manualmente em um exemplo fornecido e explicar o resultado.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Ferramenta online de simulação de AG (ex: Python notebook)",
                                    "Quadro branco para desenhos"
                                  ],
                                  "tips": "Sempre verifique se os filhos são válidos após o crossover.",
                                  "learningObjective": "Dominar o processo de recombinação genética em AG.",
                                  "commonMistakes": "Aplicar crossover em pontos inadequados levando a cromossomos inválidos."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Compreender o Operador de Mutação",
                                  "subSteps": [
                                    "Definir mutação como alteração aleatória em um indivíduo para introduzir diversidade.",
                                    "Estudar tipos de mutação: bit flip para binário, Gaussian para real-valued.",
                                    "Explicar a taxa de mutação baixa para evitar destruição de boas soluções.",
                                    "Discutir o equilíbrio entre exploração e explotação via mutação.",
                                    "Simular mutação em um cromossomo de exemplo."
                                  ],
                                  "verification": "Identificar e aplicar mutação corretamente em 3 exemplos diferentes.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Código Python simples para mutação",
                                    "Exercícios impressos"
                                  ],
                                  "tips": "Mantenha a taxa de mutação baixa (ex: 0.01) para resultados eficazes.",
                                  "learningObjective": "Compreender o papel da mutação na diversidade populacional.",
                                  "commonMistakes": "Usar taxa de mutação alta causando perda de convergência."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Codificação de Cromossomos e Função Fitness para Controladores",
                                  "subSteps": [
                                    "Explicar codificação de parâmetros de controladores (ex: PID) em cromossomos reais ou binários.",
                                    "Definir função fitness baseada em métricas como erro quadrático, tempo de estabilização e robustez.",
                                    "Analisar exemplos de fitness para desempenho (overshoot, settling time) e robustez (variações de parâmetros).",
                                    "Integrar operadores anteriores com codificação e fitness em um fluxograma completo.",
                                    "Avaliar um exemplo de fitness em simulação de controlador."
                                  ],
                                  "verification": "Construir uma função fitness simples para um controlador PID e justificá-la.",
                                  "estimatedTime": "50 minutos",
                                  "materials": [
                                    "Software de simulação como MATLAB/Simulink ou Python Control",
                                    "Documentação de controladores PID"
                                  ],
                                  "tips": "Normalize os parâmetros do cromossomo para evitar valores extremos.",
                                  "learningObjective": "Aplicar conceitos de AG ao contexto de engenharia de controle.",
                                  "commonMistakes": "Definir fitness que ignora robustez, levando a soluções frágeis."
                                }
                              ],
                              "practicalExample": "Em um sistema de controle de temperatura de um forno, codifique os ganhos Kp, Ki, Kd de um PID como um cromossomo real [Kp, Ki, Kd]. Use fitness = 1/(MSE + overshoot + settling_time) para otimizar via AG com seleção por torneio, crossover uniforme e mutação Gaussiana.",
                              "finalVerifications": [
                                "Explicar verbalmente os 4 operadores genéticos com exemplos.",
                                "Desenhar fluxograma de um ciclo completo de AG.",
                                "Codificar manualmente um cromossomo para PID e calcular fitness.",
                                "Simular elitismo em uma população de 5 indivíduos.",
                                "Identificar erros comuns em crossover e mutação.",
                                "Discutir impacto da fitness em robustez de controladores."
                              ],
                              "assessmentCriteria": [
                                "Precisão conceitual dos operadores (90% correto).",
                                "Capacidade de exemplos práticos e simulações manuais.",
                                "Integração correta de codificação e fitness ao contexto de controle.",
                                "Profundidade nas explicações de prós/contras e equilíbrio de parâmetros.",
                                "Criatividade em aplicações reais demonstrada.",
                                "Ausência de erros comuns identificados."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Probabilidade e estatística em seleção e taxas de operadores.",
                                "Programação: Implementação de AG em Python ou MATLAB.",
                                "Engenharia de Controle: Otimização de controladores PID/PID-like.",
                                "Inteligência Artificial: Paralelos com aprendizado de máquina evolutivo.",
                                "Física: Modelagem de sistemas dinâmicos para fitness."
                              ],
                              "realWorldApplication": "Otimização automática de controladores em indústrias como automotiva (controle de motores), aeroespacial (estabilização de voo) e manufatura (robótica), onde AG encontram parâmetros ótimos robustos sem modelo analítico exato, reduzindo tempo de design em até 50%."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.6.3.3.2",
                            "name": "Implementar algoritmo genético em MATLAB",
                            "description": "Usar a toolbox ga() do Optimization Toolbox para minimizar uma função custo em sistemas monovariáveis com incertezas, definindo população inicial, limites e critérios de parada.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar o ambiente MATLAB e verificar toolbox",
                                  "subSteps": [
                                    "Abra o MATLAB e verifique se o Optimization Toolbox está instalado usando 'ver toolboxes'.",
                                    "Execute 'optimoptions('ga')' para confirmar disponibilidade da função ga().",
                                    "Crie um novo script .m para o projeto.",
                                    "Defina variáveis globais para o sistema monovariável, como modelo nominal e matriz de incertezas.",
                                    "Teste um comando simples de GA para validar setup."
                                  ],
                                  "verification": "Comando 'license('test', 'optimization_toolbox')' retorna 1 e ga() executa sem erro.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "MATLAB R2020a ou superior",
                                    "Optimization Toolbox",
                                    "Script .m novo"
                                  ],
                                  "tips": "Use 'doc ga' para acessar documentação integrada.",
                                  "learningObjective": "Configurar corretamente o ambiente para uso de algoritmos genéticos.",
                                  "commonMistakes": [
                                    "Não verificar licença do toolbox",
                                    "Usar versão MATLAB incompatível",
                                    "Ignorar dependências de path"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Definir a função custo para o sistema monovariável com incertezas",
                                  "subSteps": [
                                    "Modele o sistema como G(s) = 1/(s + a), onde a tem incerteza Δa ~ N(1, 0.2).",
                                    "Crie função handle @fun_cost que recebe vetor de parâmetros x e computa ISE (Integral Square Error) em simulações Monte Carlo.",
                                    "Inclua 100 simulações com amostras de incerteza para robustez.",
                                    "Teste a função com x inicial aleatório e plote custo.",
                                    "Ajuste normalização para custo entre 0-100."
                                  ],
                                  "verification": "fun_cost([1 1]) retorna valor finito e positivo; plot mostra erro quadrático.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Control System Toolbox",
                                    "Statistics Toolbox para Monte Carlo"
                                  ],
                                  "tips": "Vetorize simulações para eficiência; use parfor se Parallel Computing Toolbox disponível.",
                                  "learningObjective": "Formular problema de otimização robusta com incertezas.",
                                  "commonMistakes": [
                                    "Função não vetorizada causando lentidão",
                                    "Ignorar incertezas levando a soluções frágeis",
                                    "Escala de custo inadequada"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Configurar parâmetros iniciais, limites e opções do GA",
                                  "subSteps": [
                                    "Defina nvars = 2 (ex: ganhos Kp, Ki para PID).",
                                    "Estabeleça lb = [0 0], ub = [10 5] para limites realistas.",
                                    "Crie opções com optimoptions('ga', 'PopulationSize', 50, 'MaxGenerations', 100, 'Display', 'iter').",
                                    "Inclua critérios de parada: 'FunctionTolerance', 1e-6, 'MaxStallGenerations', 20.",
                                    "Defina população inicial com lhsdesign para diversidade."
                                  ],
                                  "verification": "options = optimoptions('ga', ...); validade com checkOptions(options).",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Documentação ga()",
                                    "Exemplos de optimoptions"
                                  ],
                                  "tips": "PopulaçãoSize 20-100; equilibre exploração vs. exploração.",
                                  "learningObjective": "Personalizar GA para convergência eficiente em problemas de controle.",
                                  "commonMistakes": [
                                    "Limites muito amplos causando divergência",
                                    "População pequena levando a convergência prematura",
                                    "Critérios de parada frouxos"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Executar o algoritmo genético e monitorar progresso",
                                  "subSteps": [
                                    "Chame [x, fval, exitflag] = ga(fun_cost, nvars, [], [], [], [], lb, ub, [], options).",
                                    "Monitore output em tempo real com 'PlotFcn' @gaplotbestf e @gaplotscores.",
                                    "Salve histórico com 'OutputFcn' customizado.",
                                    "Registre exitflag e reason para diagnóstico.",
                                    "Repita com sementes diferentes para reproducibilidade (rng(42))."
                                  ],
                                  "verification": "exitflag > 0 indica sucesso; fval < threshold desejado.",
                                  "estimatedTime": "1 hora (depende de hardware)",
                                  "materials": [
                                    "Hardware com >4GB RAM",
                                    "rng para reproducibilidade"
                                  ],
                                  "tips": "Use 'UseParallel', true se disponível para acelerar.",
                                  "learningObjective": "Executar e diagnosticar runs de GA.",
                                  "commonMistakes": [
                                    "Não setar rng causando resultados não reproduzíveis",
                                    "Ignorar warnings de toolbox",
                                    "Parar manualmente sem exitflag"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Analisar resultados, validar e visualizar",
                                  "subSteps": [
                                    "Plote convergência: semilogx(options.OutputFcn.history).",
                                    "Simule sistema fechado com x ótimo e incertezas para validar robustez.",
                                    "Compare com solução analítica ou gradient-based (fmincon).",
                                    "Calcule métricas: custo mínimo, variância em Monte Carlo pós-otimização.",
                                    "Documente em relatório com figures."
                                  ],
                                  "verification": "Plots mostram convergência; simulação robusta com overshoot <10%, settling time <5s.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Simulink ou lsim para simulação",
                                    "Exportgraphics para figures"
                                  ],
                                  "tips": "Use niching ou elitismo para multimodalidade.",
                                  "learningObjective": "Interpretar e validar soluções de otimização genética.",
                                  "commonMistakes": [
                                    "Não validar robustez ignorando incertezas",
                                    "Plots ilegíveis",
                                    "Confundir fitness com performance real"
                                  ]
                                }
                              ],
                              "practicalExample": "Otimizar ganhos Kp e Ki de um PID para estabilizar um motor DC monovariável G(s)=1/(s+1+Δ), Δ~U(-0.2,0.2), minimizando ISE sobre referência degrau em 100 cenários Monte Carlo. Use ga() para encontrar x=[Kp,Ki] com custo <0.5.",
                              "finalVerifications": [
                                "GA convergeu (exitflag=1) em <100 gerações.",
                                "Custo mínimo fval < threshold do problema (ex: 0.1).",
                                "Parâmetros x dentro de lb/ub e fazem sentido físico.",
                                "Simulações com incertezas mostram performance robusta (std(overshoot)<5%).",
                                "Plots de convergência e fitness population confirmam diversidade.",
                                "Código roda em <10min em laptop padrão."
                              ],
                              "assessmentCriteria": [
                                "Correção da função custo (testes unitários passam).",
                                "Eficiência de parâmetros GA (convergência rápida sem overfitting).",
                                "Robustez à incerteza (Monte Carlo variance baixa).",
                                "Qualidade de visualizações e documentação.",
                                "Reprodutibilidade (rng seed usado).",
                                "Comparação com baseline (ex: Ziegler-Nichols)."
                              ],
                              "crossCurricularConnections": [
                                "Programação Numérica (MATLAB scripting e vetorização).",
                                "Teoria de Controle (modelagem de sistemas com incertezas).",
                                "Estatística e Probabilidade (Monte Carlo, distribuições).",
                                "Inteligência Computacional (evolução, meta-heurísticas).",
                                "Engenharia de Software (modularidade, testes)."
                              ],
                              "realWorldApplication": "Em controle avançado de processos industriais, como tuning automático de controladores em plantas químicas com parâmetros incertos (ex: reatores), reduzindo tempo de comissionamento e melhorando robustez em fábricas da Petrobras ou indústrias automotivas."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.6.3.3.3",
                            "name": "Aplicar algoritmos genéticos a problemas de μ-síntese",
                            "description": "Otimizar controladores parametrizados considerando robustez μ, avaliando soluções globais versus locais de métodos gradient-based em simulações com perturbações estruturadas.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar o modelo do sistema e formular o problema de μ-síntese",
                                  "subSteps": [
                                    "Identificar a planta nominal e modelar perturbações estruturadas (Δ) usando blocos de incerteza.",
                                    "Definir a estrutura do controlador parametrizado (ex: PID ou H∞ com parâmetros livres).",
                                    "Estabelecer a função objetivo baseada no valor μ (μ_max < 1 para robustez).",
                                    "Configurar o framework de simulação (MATLAB Robust Control Toolbox ou similar).",
                                    "Validar o modelo com análise μ inicial sem otimização."
                                  ],
                                  "verification": "Modelo simulado retorna μ_max calculado corretamente; gráficos de singular values mostram robustez.",
                                  "estimatedTime": "4 horas",
                                  "materials": [
                                    "MATLAB com Robust Control Toolbox",
                                    "Documentação de μ-síntese (Skogestad & Postlethwaite)",
                                    "Exemplos de plantas como inverted pendulum ou aeroelastic wing."
                                  ],
                                  "tips": "Comece com perturbações simples (norm-bounded) antes de estruturadas para depuração rápida.",
                                  "learningObjective": "Compreender a formulação de problemas μ-síntese e sua integração com otimização.",
                                  "commonMistakes": [
                                    "Ignorar normalização de incertezas (leva a μ inflado)",
                                    "Confundir perturbações normais com estruturadas",
                                    "Não validar estabilidade nominal primeiro"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Projetar a representação cromossômica e parâmetros iniciais do GA",
                                  "subSteps": [
                                    "Escolher codificação real-valued para parâmetros do controlador (ex: gains Kp, Ki, Kd).",
                                    "Definir tamanho da população (50-200 indivíduos), comprimento cromossomo (número de params).",
                                    "Configurar parâmetros: taxa de crossover (0.8), mutação (0.01), elitismo (5%).",
                                    "Inicializar população aleatoriamente dentro de bounds realistas.",
                                    "Testar fitness em 10 indivíduos iniciais para calibrar escala."
                                  ],
                                  "verification": "População gerada com diversidade (std dev > 10% dos bounds); fitness computado sem erros.",
                                  "estimatedTime": "3 horas",
                                  "materials": [
                                    "Biblioteca GA em MATLAB (ga() do Global Optimization Toolbox)",
                                    "Código template para cromossomo real-valued"
                                  ],
                                  "tips": "Use bounds tightos baseados em conhecimento domínio para convergência rápida.",
                                  "learningObjective": "Dominar codificação de soluções de controle em GAs para problemas contínuos.",
                                  "commonMistakes": [
                                    "Codificação binária para params contínuos (baixa precisão)",
                                    "População muito pequena (convergência prematura)",
                                    "Sem bounds (explosão de valores)"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar operadores genéticos e função de fitness baseada em μ",
                                  "subSteps": [
                                    "Implementar seleção (tournament ou roulette wheel).",
                                    "Codificar crossover blend/simulado e mutação gaussiana.",
                                    "Definir fitness = 1 / (μ_max + penalidade instabilidade); incluir constraint handling.",
                                    "Adicionar reparo de soluções inválidas (clamp bounds, estabilização).",
                                    "Executar 5 gerações teste para depurar operadores."
                                  ],
                                  "verification": "Estatísticas por geração mostram melhoria média fitness; diversidade mantida.",
                                  "estimatedTime": "5 horas",
                                  "materials": [
                                    "MATLAB Genetic Algorithm Toolbox",
                                    "Função musyn() ou mussv() para μ-computação"
                                  ],
                                  "tips": "Paralelize fitness eval se possível (parpool) para aceleração.",
                                  "learningObjective": "Integrar análise μ como fitness em GAs, lidando com avaliações caras.",
                                  "commonMistakes": [
                                    "Fitness sem penalidade para instabilidade (soluções inviáveis dominam)",
                                    "Mutação muito alta (destrói convergência)",
                                    "Crossover sem blend (pouca exploração)"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Executar otimizações, simular perturbações e comparar com métodos gradient-based",
                                  "subSteps": [
                                    "Rodar GA por 100-500 gerações, salvando melhores soluções.",
                                    "Simular top-3 controladores com 100 realizações de perturbações estruturadas.",
                                    "Implementar baseline gradient-based (fmincon com μ como obj).",
                                    "Comparar: μ médio, variância, tempo computacional, basins de atração.",
                                    "Plotar evolução fitness e step responses."
                                  ],
                                  "verification": "GA atinge μ <1 em >80% simulações; superior a gradient em globalidade.",
                                  "estimatedTime": "6 horas",
                                  "materials": [
                                    "fmincon() para baseline",
                                    "MonteCarlo simulações via loop ou parfor"
                                  ],
                                  "tips": "Monitore overfitting com validação hold-out de perturbações.",
                                  "learningObjective": "Avaliar GAs vs. locais em μ-síntese sob incertezas.",
                                  "commonMistakes": [
                                    "Poucas simulações (resultados não estatísticos)",
                                    "Comparação injusta (mesmo tempo vs. iterações)",
                                    "Ignorar tempo computacional de μ (GA mais lento)"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Analisar resultados e refinar para soluções globais robustas",
                                  "subSteps": [
                                    "Analisar nichos: plot μ vs. params para multi-modalidade.",
                                    "Refinar GA com hybrid (GA + local search nos elites).",
                                    "Avaliar sensibilidade a params GA via grid search.",
                                    "Documentar trade-offs globais vs. locais.",
                                    "Preparar relatório com métricas e visualizações."
                                  ],
                                  "verification": "Relatório mostra GA escapando mínimos locais; hybrid melhora 10-20%.",
                                  "estimatedTime": "3 horas",
                                  "materials": [
                                    "Plots via MATLAB (surf, contour para landscape fitness)",
                                    "LaTeX ou Word para relatório"
                                  ],
                                  "tips": "Use niching (crowding) se multi-modalidade detectada.",
                                  "learningObjective": "Interpretar e melhorar performance de GAs em otimização robusta.",
                                  "commonMistakes": [
                                    "Assumir convergência sem análise landscape",
                                    "Não hybridizar (perde precisão local)",
                                    "Relatório sem quantificação estatística"
                                  ]
                                }
                              ],
                              "practicalExample": "Otimizar um controlador H∞ para uma asa flexível de aeronave (planta G(s)) com perturbações estruturadas em massa/aerodinâmica. GA evolui 6 params do controlador para μ_max=0.85 em 200 MonteCarlos, superando fmincon preso em mínimo local (μ=1.2).",
                              "finalVerifications": [
                                "μ_max médio <1 em 90% das simulações com perturbações estruturadas.",
                                "Solução GA tem variância μ 20% menor que gradient-based.",
                                "Tempo de step response dentro de specs (settling <5s).",
                                "Evolução fitness mostra platô evitado por diversidade.",
                                "Hybrid GA-local refina μ em 15%.",
                                "Comparação estatística (t-test) confirma superioridade global."
                              ],
                              "assessmentCriteria": [
                                "Precisão da formulação μ-síntese (μ calculado corretamente).",
                                "Implementação GA funcional com operadores corretos.",
                                "Função fitness integra robustez μ adequadamente.",
                                "Análise comparativa quantitativa e visual.",
                                "Tratamento de incertezas e estatísticas robustas.",
                                "Relatório claro com insights acionáveis."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Análise de valores singulares e otimização não-convexa.",
                                "Programação: Algoritmos evolutivos e simulação numérica (MATLAB/Python).",
                                "Inteligência Artificial: Meta-heurísticas e aprendizado por reforço em controle.",
                                "Física/Engenharia: Dinâmica de sistemas com incertezas (aeroespacial/mecânica).",
                                "Estatística: Análise MonteCarlo e testes de hipótese."
                              ],
                              "realWorldApplication": "Desenvolvimento de controladores robustos para drones em ventos turbulentos (perturbações estruturadas em aerodinâmica), veículos autônomos com variação de carga, ou plantas químicas com incertezas paramétricas, onde métodos gradient-based falham em soluções globais."
                            },
                            "estimatedTime": "3 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.6.3.3.4",
                            "name": "Avaliar trade-offs em otimização genética",
                            "description": "Analisar impacto de hiperparâmetros como tamanho da população e taxa de mutação no tempo computacional e qualidade da solução para projeto de controladores LIT.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Identificar e compreender hiperparâmetros chave em algoritmos genéticos",
                                  "subSteps": [
                                    "Liste os principais hiperparâmetros: tamanho da população (pop_size), taxa de mutação (mutation_rate), taxa de crossover e número de gerações.",
                                    "Estude o impacto teórico: pop_size grande melhora diversidade mas aumenta tempo; mutation_rate alta explora mais mas pode destruir boas soluções.",
                                    "Revise literatura ou documentação de bibliotecas como DEAP ou PyGAD para exemplos em otimização de controladores LIT.",
                                    "Defina faixas realistas para experimentos: pop_size [50, 100, 200]; mutation_rate [0.01, 0.05, 0.1].",
                                    "Documente hipóteses iniciais sobre trade-offs esperados."
                                  ],
                                  "verification": "Criar um documento ou tabela resumindo 4-6 hiperparâmetros com descrições, impactos teóricos e faixas propostas.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Documentação de bibliotecas GA (DEAP, PyGAD)",
                                    "Artigos sobre GAs em controle (IEEE Xplore)",
                                    "Notebook Jupyter para anotações"
                                  ],
                                  "tips": "Comece com teoria básica de GAs para contextualizar; use diagramas de fluxo genético para visualizar.",
                                  "learningObjective": "Compreender como hiperparâmetros influenciam exploração vs exploração e custo computacional.",
                                  "commonMistakes": [
                                    "Ignorar interações entre parâmetros (ex: mutação alta com pop pequena)",
                                    "Escolher faixas irreais que não escalam",
                                    "Confundir mutação com crossover"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Projetar experimentos de varredura de hiperparâmetros",
                                  "subSteps": [
                                    "Defina o problema de otimização: função custo para controlador LIT (ex: ISE para tracking de setpoint).",
                                    "Crie uma grade de experimentos: grid search com 3 valores por parâmetro (9-27 runs).",
                                    "Especifique métricas: tempo de execução (segundos), qualidade (fitness médio final), convergência (fitness por geração).",
                                    "Implemente logging: salve resultados em CSV com colunas para config, tempo, fitness_best, fitness_avg.",
                                    "Planeje repetições: 5-10 runs por config para estatísticas (média, desvio padrão)."
                                  ],
                                  "verification": "Gerar um plano escrito ou código skeleton com grid de parâmetros e métricas definidas.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Python com NumPy/Pandas",
                                    "Biblioteca GA (PyGAD ou DEAP)",
                                    "Modelo LIT simulado (controle library como control.matlab)"
                                  ],
                                  "tips": "Use loops aninhados ou itertools.product para grid search; priorize parâmetros mais impactantes primeiro.",
                                  "learningObjective": "Desenvolver capacidade de planejar experimentos controlados para isolar trade-offs.",
                                  "commonMistakes": [
                                    "Grid muito grande causando tempo excessivo",
                                    "Não incluir sementes aleatórias para reprodutibilidade",
                                    "Métricas incompletas (só fitness, sem tempo)"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Executar simulações e coletar dados de performance",
                                  "subSteps": [
                                    "Implemente o GA com função fitness para controlador LIT (ex: minimizar erro em resposta transitória).",
                                    "Execute o grid search, monitorando tempo e fitness por run.",
                                    "Colete dados: tempo total, melhor fitness, fitness final médio, número de gerações até convergência.",
                                    "Salve plots preliminares: fitness vs gerações para configs selecionadas.",
                                    "Registre anomalias: timeouts, não-convergências."
                                  ],
                                  "verification": "Obter dataset CSV com pelo menos 50 runs, incluindo métricas para cada config.",
                                  "estimatedTime": "3-4 horas (depende de hardware)",
                                  "materials": [
                                    "Jupyter Notebook",
                                    "Python: PyGAD/DEAP, control, matplotlib, pandas",
                                    "Hardware com GPU opcional para aceleração"
                                  ],
                                  "tips": "Paralelize runs com multiprocessing; defina timeout por run para evitar travamentos.",
                                  "learningObjective": "Executar otimizações práticas e coletar dados empíricos confiáveis.",
                                  "commonMistakes": [
                                    "Runs insuficientes levando a variância alta",
                                    "Não normalizar fitness para comparação",
                                    "Ignorar overhead de pop_size grande"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar trade-offs e visualizar resultados",
                                  "subSteps": [
                                    "Calcule estatísticas: médias, desvios para tempo e fitness por config.",
                                    "Crie visualizações: scatter plot (tempo vs fitness), heatmaps de fitness médio, curvas de Pareto.",
                                    "Identifique trade-offs: ex: pop_size 200 dobra tempo mas melhora fitness 15%.",
                                    "Quantifique: calcule eficiência (fitness / tempo) ou razão custo-benefício.",
                                    "Conclua recomendações: config ótima para cenários tempo-críticos vs qualidade-críticos."
                                  ],
                                  "verification": "Produzir relatório com 4-6 plots e tabela de trade-offs resumidos.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Pandas, Matplotlib/Seaborn, Plotly para interativos",
                                    "Excel ou Jupyter para análise"
                                  ],
                                  "tips": "Use log-escala para tempo; destaque fronteira de Pareto para multi-objetivo.",
                                  "learningObjective": "Interpretar dados empíricos para decisões baseadas em trade-offs.",
                                  "commonMistakes": [
                                    "Overfitting a uma run única",
                                    "Ignorar variância em análises",
                                    "Conclusões sem suporte visual/numérico"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um sistema LIT de motor DC, otimize parâmetros PID via GA. Varie pop_size [50,100,200] e mutation_rate [0.01,0.05]. Resultado: pop_size=100 e mutation=0.05 equilibra tempo (5min) com ISE=0.12, vs pop_size=200 (15min, ISE=0.08).",
                              "finalVerifications": [
                                "Explicar verbalmente como dobrar pop_size afeta tempo e diversidade.",
                                "Identificar config ótima para prazo apertado vs alta precisão.",
                                "Interpretar gráfico de Pareto corretamente.",
                                "Prever impacto de mutation_rate=0.2 baseado em resultados.",
                                "Recomendar ajustes para cenários reais."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de trade-offs (ex: impacto quantitativo correto).",
                                "Qualidade das visualizações (claras, legíveis, informativas).",
                                "Robustez dos experimentos (repetições adequadas, reprodutibilidade).",
                                "Profundidade da análise (considera interações paramétricas).",
                                "Recomendações práticas e justificadas.",
                                "Eficiência computacional demonstrada."
                              ],
                              "crossCurricularConnections": [
                                "Estatística: Análise de variância e testes de significância em resultados.",
                                "Programação: Implementação eficiente de grid search e paralelismo.",
                                "Matemática: Teoria de otimização multi-objetivo e fronteiras de Pareto.",
                                "Engenharia de Software: Logging e reprodutibilidade em experimentos."
                              ],
                              "realWorldApplication": "No design de controladores para drones ou robôs industriais, onde tempo de tuning deve balancear com performance: pop_size moderada para prototipagem rápida, alta para produção crítica."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.6.4",
                    "name": "Implementação e Análise Numérica",
                    "description": "Uso de ferramentas como MATLAB para síntese, simulação e validação de controladores otimizados.",
                    "individualConcepts": [
                      {
                        "id": "10.1.6.4.1",
                        "name": "Síntese de Controladores Otimizados via MATLAB",
                        "description": "Implementação numérica de métodos algorítmicos para síntese de controladores robustos utilizando funções do Robust Control Toolbox, como otimização de parâmetros e síntese H∞.",
                        "specificSkills": [
                          {
                            "id": "10.1.6.4.1.1",
                            "name": "Configurar modelo de planta com incertezas no MATLAB",
                            "description": "Definir modelos LIT de sistemas monovariáveis com incertezas aditivas ou multiplicativas usando comandos como `ureal`, `ultidyn` e `usys` para preparar a síntese robusta.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Configurar o modelo nominal da planta no MATLAB",
                                  "subSteps": [
                                    "Abra o MATLAB e inicie um novo script.",
                                    "Defina a função de transferência nominal do sistema monovariável usando tf() ou ss().",
                                    "Atribua o modelo a uma variável, ex: P_nominal = tf([1 1],[1 2 1]);",
                                    "Plote a resposta em frequência com bode(P_nominal) para visualização inicial."
                                  ],
                                  "verification": "Execute o script e confirme que o gráfico de Bode do modelo nominal é exibido corretamente sem erros.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "MATLAB com Robust Control Toolbox instalado",
                                    "Script .m novo"
                                  ],
                                  "tips": "Use sysic para sistemas em espaço de estados se o modelo for mais complexo.",
                                  "learningObjective": "Entender e implementar o modelo base LIT sem incertezas.",
                                  "commonMistakes": [
                                    "Esquecer de instalar o toolbox",
                                    "Usar sintaxe incorreta em tf() levando a polos errados"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Definir incertezas paramétricas aditivas ou multiplicativas com ureal",
                                  "subSteps": [
                                    "Crie um objeto ureal para o parâmetro incerto: delta_k = ureal('delta_k', 'Percentage', 20);",
                                    "Defina o range: delta_k.Range = [0.8 1.2];",
                                    "Construa o modelo multiplicativo: P_mult = P_nominal * (1 + delta_k);",
                                    "Para aditiva: P_add = P_nominal + ureal('delta_add', 'Range', [-0.1 0.1]);"
                                  ],
                                  "verification": "Use usample() para amostrar valores e plotar múltiplas curvas de Bode para verificar variação.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Robust Control Toolbox",
                                    "Modelo nominal do Step 1"
                                  ],
                                  "tips": "Especifique 'Percentage' para incertezas relativas em ureal.",
                                  "learningObjective": "Modelar variações paramétricas conhecidas em parâmetros do sistema.",
                                  "commonMistakes": [
                                    "Definir Range incorreto (ex: valores absolutos em vez de percentuais)",
                                    "Não nomear o ureal adequadamente"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Modelar incertezas dinâmicas não paramétricas com ultidyn",
                                  "subSteps": [
                                    "Crie ultidyn: W_delta = ultidyn('W_delta', [1 5]); // ordem 1, frequência até 5 rad/s",
                                    "Defina o modelo com incerteza dinâmica: P_dyn = P_nominal * (1 + W_delta);",
                                    "Ajuste a magnitude de W_delta com normas: W_delta.Magnitude = 0.2;",
                                    "Combine com ureal se necessário: P_combined = P_mult * (1 + W_delta);"
                                  ],
                                  "verification": "Plote sigma(W_delta) e confirme que a incerteza dinâmica está dentro dos limites desejados.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Modelo com ureal do Step 2",
                                    "Documentação ultidyn"
                                  ],
                                  "tips": "Escolha a ordem e frequência baseada na dinâmica esperada do sistema.",
                                  "learningObjective": "Representar incertezas de alta frequência ou não modeladas parametricamente.",
                                  "commonMistakes": [
                                    "Ordem muito alta causando computação lenta",
                                    "Magnitude excessiva levando a instabilidade"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Construir e validar o modelo de planta com usys",
                                  "subSteps": [
                                    "Use usys para interconectar: P_plant = usys('P_plant', P_nominal, delta_k, W_delta);",
                                    "Especifique entradas/saídas: P_plant.InputName = 'u'; P_plant.OutputName = 'y';",
                                    "Gere amostras: usamp_P = usample(P_plant, 100);",
                                    "Plote todas as respostas: bodeplot(usamp_P); grid on;"
                                  ],
                                  "verification": "O plot de Bode mostra um envelope de incerteza ao redor do nominal sem erros de sintaxe.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Modelos dos steps anteriores",
                                    "Função usample"
                                  ],
                                  "tips": "Use uinfo(P_plant) para inspecionar as incertezas incorporadas.",
                                  "learningObjective": "Integrar todas as incertezas em um modelo único para síntese robusta.",
                                  "commonMistakes": [
                                    "Ordem errada nos argumentos de usys",
                                    "Não definir nomes de I/O causando confusão"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Verificar robustez e preparar para síntese",
                                  "subSteps": [
                                    "Calcule o ganho máximo: [mu, mu_rand] = musv(P_plant);",
                                    "Analise estabilidade com robuststab(P_plant);",
                                    "Exporte o modelo para workspace ou arquivo .mat.",
                                    "Documente o modelo com comentários no script."
                                  ],
                                  "verification": "mu < 1 indica robustez; relatório de robuststab confirma estabilidade.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Modelo usys final",
                                    "Funções musv e robuststab"
                                  ],
                                  "tips": "Ajuste incertezas se mu > 1 para evitar controladores inviáveis.",
                                  "learningObjective": "Avaliar se o modelo com incertezas está pronto para projeto de controlador.",
                                  "commonMistakes": [
                                    "Ignorar warnings de toolbox ausente",
                                    "Amostras insuficientes em usample"
                                  ]
                                }
                              ],
                              "practicalExample": "Para um motor DC com planta nominal P(s) = 1/(s+1), adicione ureal delta_k ('Range' [0.9 1.1]) multiplicativo e ultidyn W_delta (ordem 1, mag 0.1). Construa P_plant = usys('P_motor', P, delta_k, W_delta), amostre 50 realizações e plote bodeplot para ver o envelope de incerteza de ±10% em ganho e dinâmica não modelada.",
                              "finalVerifications": [
                                "Modelo usys executa sem erros e uinfo() lista todas as incertezas corretamente.",
                                "Bode plot de amostras mostra variação esperada ao redor do nominal.",
                                "musv(P_plant) retorna valor <1 indicando robustez.",
                                "robuststab(P_plant) confirma estabilidade para todas as incertezas.",
                                "Script é reproduzível e comentado.",
                                "Modelo exportado para uso em sysic ou ltiarray."
                              ],
                              "assessmentCriteria": [
                                "Correto uso de ureal, ultidyn e usys com sintaxe precisa.",
                                "Incertezas definidas realisticamente (range/magnitude adequados).",
                                "Visualizações (bode, sigma) interpretadas corretamente.",
                                "Verificações de robustez (mu, robuststab) realizadas e analisadas.",
                                "Eficiência computacional (amostras razoáveis, sem loops desnecessários).",
                                "Documentação clara no código."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Análise de sistemas LIT e teoria de incertezas (H-infinito).",
                                "Programação: Scripting avançado em MATLAB e manipulação de objetos toolbox.",
                                "Física: Modelagem de plantas reais com variações (ex: parâmetros de motores).",
                                "Engenharia de Software: Validação e testes unitários de modelos numéricos.",
                                "Estatística: Amostragem de incertezas e análise de variância."
                              ],
                              "realWorldApplication": "Em indústrias como aeroespacial e automotiva, configura modelos de plantas com incertezas (ex: variação de massa em drones ou atrito em veículos) para sintetizar controladores robustos via H-infinito ou mu-síntese, garantindo performance apesar de variações de fabricação ou envelhecimento."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.6.4.1.2",
                            "name": "Implementar otimização de parâmetros de controladores",
                            "description": "Utilizar `sisotool` ou `tune` para otimização de ganhos PID ou controladores de ordem superior, definindo pesos de desempenho e robustez conforme a forma padrão.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar o Modelo do Sistema e Controlador Inicial",
                                  "subSteps": [
                                    "Obtenha ou crie o modelo de planta em MATLAB usando funções como tf() ou ss() para sistemas SISO.",
                                    "Defina a estrutura do controlador inicial (ex: PID com ganhos iniciais via Ziegler-Nichols).",
                                    "Linearize o modelo se necessário usando linmod() ou linearize().",
                                    "Plote respostas em malha aberta e fechada iniciais com step() e bode().",
                                    "Salve o modelo em uma variável workspace para uso posterior."
                                  ],
                                  "verification": "Confirme que o modelo responde corretamente a step() e que o controlador inicial é estável via pole().",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "MATLAB com Control System Toolbox",
                                    "Documentação de tf() e pid()"
                                  ],
                                  "tips": "Use sysic() para conectar inicial controller à planta e visualize com stepinfo().",
                                  "learningObjective": "Entender modelagem SISO e setup inicial de controladores para otimização.",
                                  "commonMistakes": [
                                    "Ignorar linearização em modelos não-lineares",
                                    "Ganhos iniciais muito altos causando instabilidade",
                                    "Esquecer de definir entradas/saídas corretas"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Configurar o Ambiente de Otimização com sisotool ou tune",
                                  "subSteps": [
                                    "Inicie sisotool(modelo) ou use pidtune(sys, 'PID') para PID simples.",
                                    "Para controladores avançados, configure tune() com systuneOptions().",
                                    "Defina loops de feedback e imports do controlador no diagrama do sisotool.",
                                    "Explore interfaces: selecione Design > Tuning para automação.",
                                    "Exporte o controlador otimizado inicial para workspace com getIOTransfer()."
                                  ],
                                  "verification": "Verifique se a interface abre sem erros e mostra o diagrama de laço unitário.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "sisotool GUI",
                                    "Control System Toolbox",
                                    "Exemplos de help sisotool"
                                  ],
                                  "tips": "Use o modo 'Tune' no sisotool para automação rápida; prefira tune() para scripts.",
                                  "learningObjective": "Dominar ferramentas gráficas e programáticas de tuning em MATLAB.",
                                  "commonMistakes": [
                                    "Não importar controlador corretamente",
                                    "Confundir planta com controlador no diagrama",
                                    "Ignorar avisos de singularidade"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Definir Pesos de Desempenho e Robustez e Executar Otimização",
                                  "subSteps": [
                                    "Configure pesos conforme forma padrão: Wp para desempenho (tracking), Wu para controle effort.",
                                    "Em sisotool, arraste templates ou edite weights no menu Design > Edit Compensator.",
                                    "Para tune(), defina TuningGoal como TrackingGoal e RobustnessGoal com pesos numéricos.",
                                    "Execute otimização clicando 'Tune' ou tune(controller, sys).",
                                    "Monitore métricas: overshoot, settling time, margins via toolbox views."
                                  ],
                                  "verification": "Confirme que singular values de pesos moldam o loop shape desejado em bode plot.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Documentação TuningGoal",
                                    "Exemplos de systune",
                                    "sisotool templates"
                                  ],
                                  "tips": "Comece com pesos conservadores; itere ajustando magnitudes em decades.",
                                  "learningObjective": "Aplicar teoria de forma padrão para balancear desempenho vs. robustez.",
                                  "commonMistakes": [
                                    "Pesos mal escalados causando otimização falha",
                                    "Esquecer Wu levando a controle saturado",
                                    "Não iterar após primeira tune"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar Resultados, Validar e Refinar",
                                  "subSteps": [
                                    "Avalie step response, sensitivity functions (sens, T) e stability margins.",
                                    "Simule em malha fechada com lsim() ou feedback() para distúrbios/referências.",
                                    "Compare métricas pré/pós-otimização com stepinfo() e robuststab().",
                                    "Refine pesos se necessário e re-tune; exporte controlador final.",
                                    "Documente ganhos otimizados e plots em relatório."
                                  ],
                                  "verification": "Sistema fechado tem GM>6dB, PM>45°, settling<5s sem overshoot excessivo.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "bode(), nichols(), stepinfo()",
                                    "Simulink para validação (opcional)"
                                  ],
                                  "tips": "Use view('horizon') no sisotool para overview rápido de trade-offs.",
                                  "learningObjective": "Interpretar análises de frequência/tempo para validação de controladores.",
                                  "commonMistakes": [
                                    "Aceitar tuning sem checar robustez a variações",
                                    "Não simular distúrbios reais",
                                    "Exportar sem salvar workspace"
                                  ]
                                }
                              ],
                              "practicalExample": "Otimize um PID para um motor DC modelado como G(s) = 1000/(s(s+10)), definindo Wp para tracking rápido (settling 0.1s) e Wu para limitar u<10V, resultando em Kp=2.5, Ki=15, Kd=0.8 com overshoot<10%.",
                              "finalVerifications": [
                                "Controlador exportado estabiliza planta com margins adequados (PM>45°, GM>8dB).",
                                "Resposta ao degrau atende specs: rise time <1s, overshoot <15%.",
                                "Sensitivity functions mostram bom rejection de distúrbios.",
                                "Simulação com ruído/processo variado mantém performance.",
                                "Ganhos/Pesos documentados e reproduzíveis via script.",
                                "Plots de Bode/Step salvos comparando before/after."
                              ],
                              "assessmentCriteria": [
                                "Pesos de desempenho/robustez alinhados à forma padrão e specs.",
                                "Otimização converge sem warnings de inviabilidade.",
                                "Métricas finais melhoram >20% vs. inicial (ex: settling time).",
                                "Análise inclui freq domain (loop shapes) e time domain.",
                                "Código/script reproduz resultados independentemente.",
                                "Trade-offs discutidos (ex: robustez vs. speed)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Otimização não-linear e análise de singular values.",
                                "Programação: Scripting MATLAB, GUI interaction e automação.",
                                "Física: Dinâmica de sistemas mecatrônicos (motores, processos).",
                                "Engenharia de Software: Validação e testes unitários em simulações.",
                                "Estatística: Análise de robustez via Monte Carlo ou mu-synthesis."
                              ],
                              "realWorldApplication": "Em indústrias automotiva/aeroespacial, otimiza controladores de throttle em veículos autônomos ou estabilizadores de flight, reduzindo oscilações e melhorando eficiência energética sob variações de carga."
                            },
                            "estimatedTime": "3 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.6.4.1.3",
                            "name": "Sintetizar controladores H∞ e μ usando hinfsyn e musyn",
                            "description": "Aplicar comandos `hinfsyn` para síntese H∞ e `musyn` para μ-síntese, especificando funções de peso para estabilidade e desempenho em sistemas escalares.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar o modelo da planta e o framework de síntese",
                                  "subSteps": [
                                    "Linearize o modelo não linear da planta para obter G(s) em espaço de estados ou função de transferência.",
                                    "Defina as entradas e saídas relevantes: referências, perturbações, ruídos e medições.",
                                    "Construa o sistema generalizado P usando funções como 'augw' ou manualmente com ss.",
                                    "Verifique a estabilidade e minimalidade do modelo com comandos como 'isstable' e 'minreal'."
                                  ],
                                  "verification": "Execute 'bode(P)' e confirme que o diagrama de Bode exibe comportamento esperado sem polos instáveis.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "MATLAB com Robust Control Toolbox",
                                    "Documentação do Robust Control Toolbox",
                                    "Modelo da planta em .m ou Simulink"
                                  ],
                                  "tips": "Sempre normalize as funções de transferência para evitar problemas numéricos em magnitudes extremas.",
                                  "learningObjective": "Compreender a estrutura do sistema generalizado P para síntese robusta.",
                                  "commonMistakes": [
                                    "Esquecer de incluir saídas de erro e atuadores corretamente",
                                    "Não remover modos não observáveis/controláveis",
                                    "Usar modelo não linearizado"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Definir funções de peso para síntese H∞",
                                  "subSteps": [
                                    "Escolha Wp para peso de desempenho em rastreamento (ex: integral do erro).",
                                    "Defina Wu para limitação de controle (ex: alto-passagem para evitar ação em baixas frequências).",
                                    "Inclua Wn para ruído de sensores e Wt para robustez (ex: inverso do modelo nominal).",
                                    "Monte o sistema P com pesos: P_weighted = lft(P, blkdiag(Wp, Wu, Wn)).",
                                    "Ajuste iterativamente os pesos plotando singular values com 'sigma'."
                                  ],
                                  "verification": "Plot 'sigma(Wp), sigma(Wu)' e confirme que cobrem as bandas de frequência desejadas.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Funções MATLAB: lft, blkdiag, sigma",
                                    "Templates de pesos do RCT",
                                    "Referências teóreas de Skogestad"
                                  ],
                                  "tips": "Comece com pesos simples e refine; use 'sisotool' para inspiração visual.",
                                  "learningObjective": "Selecionar pesos que capturem especificações de desempenho e robustez.",
                                  "commonMistakes": [
                                    "Pesos com roll-off inadequado",
                                    "Não inverter modelo para Wt",
                                    "Ignorar unidades inconsistentes"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Sintetizar controlador H∞ com hinfsyn",
                                  "subSteps": [
                                    "Chame [K_hinf, CL, gamma] = hinfsyn(P_weighted, ny, nu); onde ny/nu são dims de y/u.",
                                    "Analise o valor ótimo gamma; se >1, ajuste pesos e re-sintetize.",
                                    "Construa o loop fechado: T = feedback(P * K_hinf, 1).",
                                    "Avalie desempenho: plot sigma(T), step responses e margens com 'robuststab'."
                                  ],
                                  "verification": "Confirme gamma < 1.2 e estabilidade robusta com 'robuststab(CL) > 0.9'.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Comando hinfsyn",
                                    "Funções analysis: sigma, robuststab, stepinfo"
                                  ],
                                  "tips": "Use opções hinfsyn('display','iter') para monitorar convergência.",
                                  "learningObjective": "Aplicar hinfsyn para obter controlador ótimo H∞ minimizando norma infinito.",
                                  "commonMistakes": [
                                    "Dimensões erradas de ny/nu",
                                    "Não checar gamma inicial alto",
                                    "Esquecer normalização de estados"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Sintetizar controlador μ com musyn e validar",
                                  "subSteps": [
                                    "Defina estrutura de incertezas Δ (norm-bounded) e monte P_mu com lft.",
                                    "Chame [K_mu, CL_mu, info] = musyn(P_mu, ny, nu);",
                                    "Analise μ-upper/lower bounds com mu(CL_mu) e confirme μ <1.",
                                    "Compare com H∞: simulações em malha aberta/fechada e sensibilidade a Δ.",
                                    "Otimize se necessário com musyn options como 'MaxIter'."
                                  ],
                                  "verification": "μ-peak <1 em frequências críticas e simulações robustas a ±20% variação de parâmetros.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Comando musyn",
                                    "μ-analysis tools: mu, musv",
                                    "Exemplos RCT demos"
                                  ],
                                  "tips": "musyn é computacionalmente intensivo; use modelos de ordem baixa primeiro.",
                                  "learningObjective": "Sintetizar controladores robustos a incertezas estruturadas via μ-síntese.",
                                  "commonMistakes": [
                                    "Estrutura Δ incompatível com P",
                                    "Não escalar blocos Δ adequadamente",
                                    "Ignorar condição de pequeno ganho"
                                  ]
                                }
                              ],
                              "practicalExample": "Para um sistema massa-mola-amortecedor G(s)=1/(s²+0.1s+1), adicione incerteza Δ=0.2. Defina Wp=0.1/(s/10+1), Wu=0.1(s/100+1), Wt=1/G. Sintetize K_hinf com hinfsyn obtendo gamma=1.1, então K_mu com musyn para μ=0.8. Simule step response com/ sem Δ mostrando robustez.",
                              "finalVerifications": [
                                "Controlador H∞ sintetizado com gamma ≤1.2 e loop fechado estável.",
                                "μ-controlador com peak μ <1 sobre faixa de frequência.",
                                "Simulações mostram desempenho robusto a perturbações e incertezas.",
                                "Código MATLAB executável e reproduzível sem erros numéricos.",
                                "Análise de Bode/sigma confirma especificações de peso atendidas.",
                                "Margens de robustez >45° fase e 6dB ganho."
                              ],
                              "assessmentCriteria": [
                                "Correta montagem de P e pesos refletindo specs de desempenho/robustez.",
                                "Sucesso na síntese com gamma/μ próximos de 1 sem ajustes excessivos.",
                                "Análises pós-síntese incluem plots de singular values, μ-bounds e simulações.",
                                "Identificação e mitigação de erros comuns como ill-conditioning.",
                                "Documentação clara do código com comentários e justificativas de pesos.",
                                "Comparação quantitativa H∞ vs μ em cenários nominais/perturbados."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Álgebra linear (valores singulares, normas), otimização convexa.",
                                "Programação: Scripting avançado MATLAB, manipulação de LTI systems.",
                                "Física: Modelagem dinâmica de sistemas mecânicos/elétricos.",
                                "Engenharia de Software: Validação numérica e análise de sensibilidade.",
                                "Estatística: Tratamento de incertezas e análise de Monte Carlo."
                              ],
                              "realWorldApplication": "Em controle de flaps de aeronaves (Boeing 787), onde hinfsyn/musyn garantem estabilidade robusta contra variações aerodinâmicas e falhas de sensores, minimizando oscilações e otimizando combustível."
                            },
                            "estimatedTime": "4 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.6.4.2",
                        "name": "Simulação Numérica de Sistemas em Malha Fechada",
                        "description": "Execução de simulações temporais e frecuenciais para avaliar o desempenho de controladores otimizados em resposta a entradas de referência e distúrbios.",
                        "specificSkills": [
                          {
                            "id": "10.1.6.4.2.1",
                            "name": "Construir e simular malha fechada com LTI systems",
                            "description": "Usar `feedback` e `lsim` para simular respostas transitórias de sistemas em malha fechada, plotando curvas de tempo para overshoot, tempo de estabilização e erro estacionário.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Definir os modelos LTI da planta e do controlador",
                                  "subSteps": [
                                    "Crie o modelo de transferência da planta G(s) usando tf() ou ss().",
                                    "Defina o controlador C(s) com base no projeto (ex: PID ou lead-lag).",
                                    "Verifique as propriedades dos modelos com pole(), zero() e bode().",
                                    "Salve os modelos em variáveis como sys_planta e sys_controlador.",
                                    "Confirme estabilidade individual com nyquist() ou step()."
                                  ],
                                  "verification": "Execute o script e confirme que pole() retorna polos no semiplano esquerdo para ambos os sistemas.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "MATLAB com Control System Toolbox",
                                    "Documentação de tf() e ss()"
                                  ],
                                  "tips": "Sempre normalize ganhos para evitar escalas numéricas inadequadas.",
                                  "learningObjective": "Compreender representação de sistemas LTI em MATLAB.",
                                  "commonMistakes": [
                                    "Esquecer de converter para LTI com tf()",
                                    "Ignorar unidades de tempo e ganho",
                                    "Não verificar estabilidade inicial"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Construir o sistema em malha fechada usando feedback()",
                                  "subSteps": [
                                    "Use feedback(sys_planta * sys_controlador, 1) para malha unitária negativa.",
                                    "Salve o sistema fechado em sys_fechada.",
                                    "Confirme a estrutura com feedback(sys_planta, sys_controlador, +1) se positivo.",
                                    "Plote diagrama de blocos com sys2tf() para visualização.",
                                    "Calcule polos fechados com pole(sys_fechada)."
                                  ],
                                  "verification": "pole(sys_fechada) deve mostrar todos os polos no semiplano esquerdo.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Função feedback()",
                                    "Exemplos da documentação MATLAB"
                                  ],
                                  "tips": "Especifique o sinal de realimentação como -1 para negativa.",
                                  "learningObjective": "Dominar a função feedback() para loops de controle.",
                                  "commonMistakes": [
                                    "Usar sinal positivo em vez de negativo",
                                    "Esquecer multiplicação planta*controlador",
                                    "Não salvar o objeto sys_fechada"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Gerar entrada e simular resposta transitória com lsim()",
                                  "subSteps": [
                                    "Defina tempo de simulação com t = 0:0.01:20.",
                                    "Crie entrada degrau com u = ones(size(t)) ou rampa com u = t.",
                                    "Execute [y,t] = lsim(sys_fechada, u, t).",
                                    "Inicialize condições zero com lsim(sys_fechada, u, t, x0).",
                                    "Repita para diferentes entradas se necessário."
                                  ],
                                  "verification": "y deve convergir para valor final sem NaN ou Inf.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Função lsim()",
                                    "Vetores de tempo e entrada"
                                  ],
                                  "tips": "Use dt pequeno (0.01) para precisão em sistemas rápidos.",
                                  "learningObjective": "Aplicar lsim() para respostas forçadas em malha fechada.",
                                  "commonMistakes": [
                                    "Tempo insuficiente para estabilização",
                                    "Entrada não compatível com tamanho(t)",
                                    "Condições iniciais não zeradas"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Plotar curvas e analisar métricas de desempenho",
                                  "subSteps": [
                                    "Plote y vs t com plot(t,y), grid on, xlabel, ylabel.",
                                    "Calcule overshoot manualmente: max(y)/yss -1 onde yss=dcgain(sys_fechada).",
                                    "Determine tempo de estabilização (5% banda) com loop ou stepinfo().",
                                    "Calcule erro estacionário: abs(yss - y(end)).",
                                    "Compare com stepinfo(sys_fechada) para validação."
                                  ],
                                  "verification": "Plots mostram overshoot <30%, settling time <5s e erro <5%.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Funções plot(), stepinfo()",
                                    "dcgain()"
                                  ],
                                  "tips": "Use stepinfo() para métricas automáticas após validação manual.",
                                  "learningObjective": "Interpretar respostas transitórias e quantificar desempenho.",
                                  "commonMistakes": [
                                    "Escala errada no plot ocultando overshoot",
                                    "Erro estacionário calculado sem dcgain",
                                    "Ignorar ruído numérico em lsim"
                                  ]
                                }
                              ],
                              "practicalExample": "Para um servomotor com planta G(s)=1/(s(s+2)) e controlador C(s)=5(s+1), construa malha fechada, simule resposta a degrau unitário por 10s, plote y(t) e verifique overshoot~15%, settling time~3s, erro~0.",
                              "finalVerifications": [
                                "Sistema fechado estável com polos no semiplano esquerdo.",
                                "Simulação lsim() executada sem erros numéricos.",
                                "Plots de tempo exibem overshoot, settling time e steady-state visíveis.",
                                "Métricas calculadas coincidem com stepinfo() (±5%).",
                                "Análise escrita identifica limitações do controlador.",
                                "Script reproduzível salva como .m funcional."
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição de LTI (sem erros de sintaxe).",
                                "Correto uso de feedback() com sinal negativo.",
                                "Simulação lsim() com entradas apropriadas e tempo adequado.",
                                "Cálculo exato de overshoot, settling time e erro estacionário.",
                                "Plots profissionais com labels, grid e legendas.",
                                "Interpretação coerente das métricas de desempenho."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Transformada de Laplace e análise de polos/zeros.",
                                "Programação: Desenvolvimento de scripts em MATLAB/Octave.",
                                "Física: Modelagem dinâmica de sistemas mecânicos/elétricos.",
                                "Engenharia de Software: Validação e testes numéricos automatizados.",
                                "Estatística: Análise de incertezas em simulações numéricas."
                              ],
                              "realWorldApplication": "Em automação industrial, como controle de velocidade de motores em linhas de produção, estabilização de drones ou regulação de temperatura em reatores químicos, onde simulações em malha fechada otimizam controladores antes da implementação física."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.6.4.2.2",
                            "name": "Analisar diagramas de Bode e Nyquist numéricos",
                            "description": "Gerar e interpretar diagramas de Bode com `bode` e Nyquist com `nyquist` para verificar margens de ganho e fase em controladores robustos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Configurar o modelo do sistema em malha fechada",
                                  "subSteps": [
                                    "Defina a função de transferência da planta G(s) usando tf() no MATLAB.",
                                    "Defina o controlador C(s), por exemplo, um PID com pid().",
                                    "Calcule a função de loop aberto L(s) = C(s)*G(s).",
                                    "Calcule a função de malha fechada T(s) = L(s)/(1 + L(s)).",
                                    "Verifique a estabilidade inicial com pole(T)."
                                  ],
                                  "verification": "Execute o script e confirme que não há polos no semiplano direito (real(pole(T)) < 0).",
                                  "estimatedTime": "20 minutes",
                                  "materials": [
                                    "MATLAB ou Octave",
                                    "Documentação Control System Toolbox"
                                  ],
                                  "tips": "Sempre normalize unidades de frequência para rad/s; use s = tf('s') para simplicidade.",
                                  "learningObjective": "Compreender como montar modelos de sistemas de controle em MATLAB para análise.",
                                  "commonMistakes": [
                                    "Esquecer de definir variáveis como s",
                                    "Confundir loop aberto com fechado",
                                    "Ignorar delays ou zeros no numerador"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Gerar e interpretar o diagrama de Bode",
                                  "subSteps": [
                                    "Gere o diagrama de Bode com bode(L) ou bodeplot(L).",
                                    "Identifique o ganho em baixa frequência (DC gain).",
                                    "Marque a frequência de cruzamento de ganho (ω_cg onde |L(jω)| = 0 dB).",
                                    "Marque a frequência de cruzamento de fase (ω_cp onde ∠L(jω) = -180°).",
                                    "Calcule manualmente a margem de fase: 180° + ∠L(jω_cg)."
                                  ],
                                  "verification": "Anote valores de Gm e Pm do grid ou use margin(L); Gm > 6 dB e Pm > 45° indicam robustez.",
                                  "estimatedTime": "30 minutes",
                                  "materials": [
                                    "MATLAB Control System Toolbox",
                                    "Exemplo de script Bode"
                                  ],
                                  "tips": "Use grid on e zoom para precisão; compare com rlocus para validação.",
                                  "learningObjective": "Gerar diagramas de Bode e extrair margens de ganho e fase corretamente.",
                                  "commonMistakes": [
                                    "Confundir magnitude em dB com fase",
                                    "Ler frequência errada no eixo log",
                                    "Ignorar assimetrias em sistemas não-mínimos"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Gerar e interpretar o diagrama de Nyquist",
                                  "subSteps": [
                                    "Gere o diagrama de Nyquist com nyquist(L).",
                                    "Observe o número de encirclements do ponto crítico (-1,0).",
                                    "Identifique a distância do ponto crítico à curva para margem de ganho.",
                                    "Meça o ângulo da tangente à curva no ponto crítico para margem de fase.",
                                    "Use nyquistplot(L) com options para plotar margens."
                                  ],
                                  "verification": "Confirme estabilidade pelo critério de Nyquist: N = P (encirclements = polos instáveis abertos).",
                                  "estimatedTime": "25 minutes",
                                  "materials": [
                                    "MATLAB",
                                    "Função nyquist e margin"
                                  ],
                                  "tips": "Aumente wmax com nyquist(L, logspace(-2,3,1000)) para curvas completas; verifique quadrantes.",
                                  "learningObjective": "Aplicar o critério de Nyquist para estabilidade e robustez.",
                                  "commonMistakes": [
                                    "Contar encirclements no sentido errado (CW vs CCW)",
                                    "Ignorar arco no infinito",
                                    "Confundir Nyquist com inverso"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Comparar margens e concluir sobre robustez",
                                  "subSteps": [
                                    "Extraia margens com [Gm, Pm, Wcg, Wcp] = margin(L).",
                                    "Compare Gm e Pm de Bode com medidas gráficas de Nyquist.",
                                    "Avalie robustez: Gm > 2 (6 dB), Pm > 30° para controladores robustos.",
                                    "Simule step(T) para validar performance.",
                                    "Documente discrepâncias e ajustes necessários no controlador."
                                  ],
                                  "verification": "Relatório escrito com valores numéricos e interpretação coerente entre Bode e Nyquist.",
                                  "estimatedTime": "25 minutes",
                                  "materials": [
                                    "Script completo",
                                    "Folha de cálculos"
                                  ],
                                  "tips": "Use allmargin(L) para múltiplas margens; priorize Nyquist para sistemas com delays.",
                                  "learningObjective": "Integrar análises de Bode e Nyquist para avaliação completa de robustez.",
                                  "commonMistakes": [
                                    "Aceitar margens marginais sem contexto",
                                    "Não considerar incertezas na planta",
                                    "Ignorar sensibilidade (1/(1+L))"
                                  ]
                                }
                              ],
                              "practicalExample": "Considere um motor DC com G(s) = 1/(s(s+1)), controlador PID C(s) = Kp + Ki/s + Kd s. Monte L(s), gere bode(L) e nyquist(L). Verifique Gm ≈ 10 dB e Pm ≈ 60° para robustez contra variações de 20% em parâmetros.",
                              "finalVerifications": [
                                "Margens de ganho e fase extraídas corretamente via margin() coincidem com leituras gráficas.",
                                "Diagrama de Nyquist mostra zero encirclements para sistema estável.",
                                "Interpretação correta de robustez baseada em Gm > 6 dB e Pm > 45°.",
                                "Simulação de resposta ao degrau confirma ausência de overshoot excessivo.",
                                "Relatório lista pelo menos 3 insights sobre o controlador."
                              ],
                              "assessmentCriteria": [
                                "Precisão na geração de diagramas (sem erros de escala ou plot).",
                                "Correta identificação e cálculo de margens (erro < 5%).",
                                "Interpretação qualitativa e quantitativa coerente.",
                                "Uso adequado de comandos MATLAB e opções avançadas.",
                                "Análise de robustez com referências a normas (ex: Doyle).",
                                "Clareza no relatório com gráficos anotados."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Funções complexas e mapeamento conforme teorema de Nyquist.",
                                "Programação: Manipulação de objetos tf/ss no MATLAB.",
                                "Física: Modelagem dinâmica de sistemas (ex: motores, circuitos).",
                                "Estatística: Análise de incertezas e Monte Carlo para robustez.",
                                "Engenharia de Software: Validação numérica de designs de controle."
                              ],
                              "realWorldApplication": "Em aviões autônomos, analisa-se Bode/Nyquist de controladores de voo para garantir estabilidade apesar de variações de vento/massa, evitando oscilações catastróficas; similar em PLCs industriais para robustez contra falhas de sensores."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.6.4.2.3",
                            "name": "Simular respostas sob incertezas paramétricas",
                            "description": "Aplicar `usim` para simulações de sistemas incertos, gerando envelopes de resposta e analisando variabilidade de desempenho.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Definir o modelo do sistema com parâmetros incertos",
                                  "subSteps": [
                                    "Identifique o sistema monovariável em malha fechada e sua função de transferência nominal.",
                                    "Liste os parâmetros sujeitos a incerteza (ex: ganhos, constantes de tempo) e defina intervalos de variação (ex: ±20%).",
                                    "Modele as incertezas paramétricas usando distribuições uniformes ou normais.",
                                    "Implemente o modelo no ambiente de simulação (MATLAB/Simulink ou equivalente).",
                                    "Teste o modelo nominal para referência de baseline."
                                  ],
                                  "verification": "Execute simulação nominal e confirme que a resposta atende especificações básicas (ex: tempo de estabilização < 5s).",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Ambiente MATLAB/Simulink, documentação do sistema, funções de transferência.",
                                  "tips": "Comece com incertezas pequenas para validar o setup antes de expandir.",
                                  "learningObjective": "Compreender como representar incertezas paramétricas em modelos dinâmicos.",
                                  "commonMistakes": "Esquecer de normalizar unidades de parâmetros ou usar intervalos irrealistas."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Configurar o simulador usim para simulações incertas",
                                  "subSteps": [
                                    "Instale e importe a toolbox usim ou função equivalente para simulação sob incerteza.",
                                    "Defina o objeto de simulação com o modelo, entrada de referência (ex: degrau unitário) e intervalos paramétricos.",
                                    "Configure opções de usim: número de Monte Carlo runs (ex: 1000), tipo de envelope (mín/máx ou percentis).",
                                    "Especifique saídas de interesse (ex: overshoot, settling time).",
                                    "Salve a configuração para reutilização."
                                  ],
                                  "verification": "Execute uma simulação teste com poucos runs e visualize envelope preliminar sem erros.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Toolbox usim, script MATLAB inicial, exemplos da documentação usim.",
                                  "tips": "Use paralelização se disponível para acelerar runs múltiplos.",
                                  "learningObjective": "Dominar a sintaxe e parâmetros da função usim para setups incertos.",
                                  "commonMistakes": "Configurar runs insuficientes levando a envelopes não confiáveis."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Executar simulações e gerar envelopes de resposta",
                                  "subSteps": [
                                    "Inicie a simulação usim com os parâmetros configurados.",
                                    "Monitore progresso e ajuste runs se necessário para convergência.",
                                    "Extraia envelopes de resposta (bandas superior/inferior para tempo/resposta).",
                                    "Plote respostas: nominal, envelopes e amostras aleatórias.",
                                    "Exporte dados para análise posterior."
                                  ],
                                  "verification": "Confirme que envelopes são gerados corretamente e cobrem 95% das simulações.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Script usim pronto, hardware com boa performance computacional.",
                                  "tips": "Salve plots em alta resolução para relatórios.",
                                  "learningObjective": "Gerar visualizações robustas de respostas sob incerteza.",
                                  "commonMistakes": "Ignorar warnings de não-convergência ou overflow numérico."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar variabilidade de desempenho e interpretar resultados",
                                  "subSteps": [
                                    "Calcule métricas estatísticas: média, desvio padrão, percentis de overshoot/settling time.",
                                    "Identifique regiões críticas de variabilidade (ex: picos de overshoot >20%).",
                                    "Compare com especificações de desempenho e avalie robustez.",
                                    "Gere relatório com insights: sensibilidade a parâmetros específicos.",
                                    "Proponha ajustes no controlador para mitigar variabilidade."
                                  ],
                                  "verification": "Produza um relatório resumindo variabilidade e recomendações.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Ferramentas de plotagem (plot, histogram), planilha para métricas.",
                                  "tips": "Use boxplots para visualizar distribuições de métricas.",
                                  "learningObjective": "Interpretar envelopes e quantificar impactos de incertezas no desempenho.",
                                  "commonMistakes": "Confundir envelope com limite de estabilidade ou ignorar correlações paramétricas."
                                }
                              ],
                              "practicalExample": "Simule um controlador PID para um motor DC com ganho Kp variando ±15% e constante de tempo τ ±10%. Use usim para gerar envelope de resposta a um degrau de velocidade, analisando variabilidade em overshoot (de 5% a 25%) e tempo de assentamento.",
                              "finalVerifications": [
                                "Envelopes de resposta gerados corretamente cobrindo todas as simulações.",
                                "Métricas de variabilidade calculadas com estatísticas precisas (média, desvios).",
                                "Plots incluem nominal, envelopes e amostras representativas.",
                                "Relatório identifica parâmetros mais sensíveis à incerteza.",
                                "Recomendações para robustez propostas com base nos resultados.",
                                "Simulação reproduzível com seed fixo para runs aleatórios."
                              ],
                              "assessmentCriteria": [
                                "Precisão na configuração de incertezas paramétricas (intervalos realistas).",
                                "Correta geração e plotagem de envelopes usim.",
                                "Análise quantitativa completa de variabilidade (métricas estatísticas).",
                                "Interpretação correta de robustez e sensibilidade.",
                                "Eficiência computacional (runs otimizados sem perda de precisão).",
                                "Clareza no relatório e visualizações profissionais."
                              ],
                              "crossCurricularConnections": [
                                "Estatística e Probabilidade: distribuições de incerteza e análise Monte Carlo.",
                                "Programação Numérica: scripts MATLAB para automação de simulações.",
                                "Projeto de Sistemas: robustez em controle e análise de sensibilidade.",
                                "Física Aplicada: modelagem dinâmica de sistemas reais com ruído paramétrico."
                              ],
                              "realWorldApplication": "Em indústrias aeroespacial e automotiva, simulações sob incertezas paramétricas com usim garantem que controladores de voo ou freios ABS mantenham desempenho estável apesar de variações em componentes (ex: tolerâncias de fabricação), evitando falhas catastróficas."
                            },
                            "estimatedTime": "3 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.6.4.3",
                        "name": "Validação e Análise de Robustez Numérica",
                        "description": "Verificação quantitativa de estabilidade robusta e cumprimento de especificações usando métricas como norma H∞ e valor μ.",
                        "specificSkills": [
                          {
                            "id": "10.1.6.4.3.1",
                            "name": "Calcular normas H∞ e margens de robustez",
                            "description": "Usar `norm` e `robuststab` para computar norma H∞ do sistema generalizado e testar estabilidade robusta sob incertezas estruturadas.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar o modelo do sistema generalizado",
                                  "subSteps": [
                                    "Instale e carregue o Robust Control Toolbox no MATLAB.",
                                    "Defina o modelo nominal da planta P(s) usando tf ou ss.",
                                    "Crie o controlador K(s) e forme o sistema generalizado G = lft(P, K).",
                                    "Verifique a estabilidade interna do sistema nominal com isstable(G).",
                                    "Plote as respostas em frequência de G para inspeção inicial."
                                  ],
                                  "verification": "Confirme que G é estável e as respostas em frequência são visualizadas corretamente sem erros de modelagem.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "MATLAB com Robust Control Toolbox",
                                    "Documentação de tf, ss e lft"
                                  ],
                                  "tips": "Sempre normalize os modelos para evitar problemas numéricos; use pidtune para um K inicial se necessário.",
                                  "learningObjective": "Construir e validar o sistema generalizado P-K corretamente.",
                                  "commonMistakes": [
                                    "Esquecer de conectar entradas/saídas corretamente em lft",
                                    "Usar modelos não próprios",
                                    "Ignorar sinais de erro de estabilidade inicial"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Computar a norma H∞ do sistema",
                                  "subSteps": [
                                    "Execute [gamma, info] = norm(G, inf) para calcular a norma H∞.",
                                    "Analise o valor gamma: se gamma < 1, o desempenho é garantido.",
                                    "Examine info.Wg para identificar o pico de ganho e frequências críticas.",
                                    "Use sigma(G, w) para plotar singular values e validar o pico.",
                                    "Itere ajustando K se gamma > 1 para reduzir a norma."
                                  ],
                                  "verification": "Obtenha gamma numérico preciso e plots de singular values coincidem com info.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Função norm do MATLAB",
                                    "Comandos sigma e bode para plots"
                                  ],
                                  "tips": "Especifique opções com norm(G, inf, opt) para controle de tolerâncias numéricas.",
                                  "learningObjective": "Calcular e interpretar a norma H∞ para análise de desempenho.",
                                  "commonMistakes": [
                                    "Não checar estabilidade antes da norma",
                                    "Confundir norma H∞ com H2",
                                    "Ignorar info para diagnóstico"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Definir e modelar incertezas estruturadas",
                                  "subSteps": [
                                    "Identifique incertezas: aditivas (W_a * Delta_a), multiplicativas (W_m * Delta_m), etc.",
                                    "Crie blocos de incerteza com ureal('Delta', 'FullComplex', size).",
                                    "Monte o Delta = stack(Delta1, Delta2, ...) com uss.",
                                    "Forme o sistema incerto G_pert = lft(G, Delta).",
                                    "Valide o modelo com usubs para casos extremos."
                                  ],
                                  "verification": "Delta tem estrutura correta e G_pert é bem definido sem erros de dimensão.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Funções ureal, stack, uss",
                                    "Documentação de incertezas estruturadas"
                                  ],
                                  "tips": "Use pesos W conservadores iniciais baseados em dados experimentais.",
                                  "learningObjective": "Modelar incertezas realistas com estrutura bloqueada.",
                                  "commonMistakes": [
                                    "Tamanhos de Delta incompatíveis",
                                    "Usar '%norm' em vez de 'FullComplex'",
                                    "Esquecer normalização das incertezas"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Testar estabilidade robusta com robuststab",
                                  "subSteps": [
                                    "[r, info] = robuststab(G_pert) para margens de robustez.",
                                    "Interprete r: r < 1 implica instabilidade para alguma Delta com ||Delta||∞ ≤ 1.",
                                    "Analise info.MuValue e info.WorstDelta para pior caso.",
                                    "Plote respostas do pior caso com stepinfo ou bode.",
                                    "Ajuste pesos ou K para melhorar r > 0.5."
                                  ],
                                  "verification": "r é calculado, plots do pior caso são gerados e interpretados.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Função robuststab",
                                    "Comandos para análise de info"
                                  ],
                                  "tips": "Aumente MaxIterations em opções para convergência em casos difíceis.",
                                  "learningObjective": "Avaliar e quantificar margens de estabilidade robusta.",
                                  "commonMistakes": [
                                    "Aplicar robuststab em G nominal sem Delta",
                                    "Ignorar análise do pior Delta",
                                    "Confundir r com gamma"
                                  ]
                                }
                              ],
                              "practicalExample": "Para um sistema de controle de posição de um braço robótico com incerteza na massa (20% variabilidade), defina P(s) = 1/(s^2 + s), K(s) = PID, adicione Delta_m multiplicativo na planta. Compute norm H∞ <1 para desempenho e robuststab r=0.7 para estabilidade sob variação de massa.",
                              "finalVerifications": [
                                "Norma H∞ calculada corretamente e abaixo de 1 para o exemplo.",
                                "Margem de robustez r > 0.5 com análise do pior caso.",
                                "Plots de singular values e respostas do pior Delta validados.",
                                "Sistema ajustado iteraivamente para melhorar métricas.",
                                "Relatório com gamma, r, info.MuValue e interpretação.",
                                "Reproduzibilidade: código roda sem erros em MATLAB limpo."
                              ],
                              "assessmentCriteria": [
                                "Precisão numérica das normas (erro < 1e-3).",
                                "Correta modelagem de incertezas estruturadas.",
                                "Interpretação qualitativa e quantitativa de resultados.",
                                "Uso eficiente de funções norm e robuststab com opções.",
                                "Capacidade de iterar para otimizar robustez.",
                                "Documentação clara de passos e conclusões."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria de operadores e valores singulares.",
                                "Programação: Manipulação avançada de objetos em MATLAB.",
                                "Física: Modelagem dinâmica de sistemas com incertezas.",
                                "Estatística: Análise de pior caso e bounds probabilísticos."
                              ],
                              "realWorldApplication": "Em controle de aeronaves, calcular H∞ garante atenuação de distúrbios como turbulência, enquanto robuststab verifica estabilidade sob variações estruturais (ex: fadiga de asas), essencial para certificação FAA."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.6.4.3.2",
                            "name": "Realizar análise μ e validação com wcgain",
                            "description": "Aplicar `mu` e `wcgain` para análise de robustez estruturada, interpretando picos μ e ganhos worst-case para validar controladores.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar o modelo do sistema com incertezas estruturadas",
                                  "subSteps": [
                                    "Definir o sistema nominal G(s) usando funções como tf ou ss no MATLAB.",
                                    "Modelar incertezas como blocos Δ (normais, paramétricas ou afins) com uss ou ureal.",
                                    "Construir o sistema generalizado M = [P; Q] * [I Δ] usando starprod ou lft.",
                                    "Verificar estabilidade nominal com funções como pole ou isstable."
                                  ],
                                  "verification": "Executar sys = lft(P, Delta); pole(sys).real < 0 confirma estabilidade nominal sem incertezas.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "MATLAB com Robust Control Toolbox, documentação de uss/ureal, exemplo de planta de controle (e.g., motor DC).",
                                  "tips": "Use normalize=True para incertezas unitárias para simplificar cálculos.",
                                  "learningObjective": "Construir representações precisas de sistemas com incertezas para análise de robustez.",
                                  "commonMistakes": "Esquecer de incluir blocos de performance ou confundir entradas/saídas do sistema generalizado."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Configurar e executar análise μ",
                                  "subSteps": [
                                    "Criar o objeto muanalysis com musyn('analysis', Delta) especificando estrutura de Δ.",
                                    "Executar mu = musyn(M, k) para diferentes níveis de incerteza k.",
                                    "Plotar gráficos de μ upper/lower bound vs. frequência com muplot.",
                                    "Identificar picos μ >1 indicando falta de robustez."
                                  ],
                                  "verification": "Gráfico muplot mostra μ <1 em todas as frequências para robustez garantida.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "MATLAB Robust Control Toolbox, funções musyn/muplot, sistema generalizado do Step 1.",
                                  "tips": "Aumente o número de pontos de frequência (w=linspace) para resolução fina em regiões críticas.",
                                  "learningObjective": "Aplicar μ-synthesis para quantificar robustez estruturada contra incertezas.",
                                  "commonMistakes": "Não especificar corretamente a estrutura de Δ levando a bounds incorretos."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Realizar validação com wcgain",
                                  "subSteps": [
                                    "Preparar sistema com controlador K: sys = lft(P, blkdiag(K, Delta)).",
                                    "Executar [wcg, wcperf] = wcgain(sys) para worst-case gain de robustez e performance.",
                                    "Analisar picos de wcg >1 indicando violação de robustez.",
                                    "Plotar wcnorm(sys) para visualização de ganhos worst-case vs. frequência."
                                  ],
                                  "verification": "wcg <1 em todas as frequências confirma robustez worst-case.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "MATLAB Robust Control Toolbox, funções wcgain/wcnorm, modelo com controlador do contexto.",
                                  "tips": "Use wcgain(..., 'Display','on') para logs detalhados de simulações Monte Carlo.",
                                  "learningObjective": "Validar controladores usando ganhos worst-case para incertezas não estruturadas.",
                                  "commonMistakes": "Confundir wcgain com norm (H-infinity) sem incertezas."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Interpretar resultados e validar controlador",
                                  "subSteps": [
                                    "Comparar picos μ e wcg com margens desejadas (e.g., μ_peak < 0.8).",
                                    "Simular Monte Carlo com usim para validar bounds empiricamente.",
                                    "Ajustar controlador se necessário (e.g., via loopshaping).",
                                    "Documentar conclusões em relatório com gráficos."
                                  ],
                                  "verification": "Relatório mostra μ_max <1 e wcg_max <1 com simulações confirmando.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Gráficos gerados, usim para simulações, template de relatório.",
                                  "tips": "Salve sessões com save('analise_robustez.mat') para reprodutibilidade.",
                                  "learningObjective": "Interpretar análises μ/wcgain para decisões de design de controladores robustos.",
                                  "commonMistakes": "Ignorar discrepâncias entre upper/lower bounds sem simulações."
                                }
                              ],
                              "practicalExample": "Para um controlador PID em um motor DC com incerteza de 20% no ganho Kp, construa P(s) = 1/(s(Js+B)+Kp), adicione Δ=ureal('Kp_unc',1,'Percentage',20), execute μ-analysis e wcgain no laço fechado; se μ_peak=1.2 em 10 rad/s, ajuste PID para robustez.",
                              "finalVerifications": [
                                "μ upper bound <1 em todo o espectro de frequência.",
                                "Worst-case gain wcg <1 para todas as incertezas consideradas.",
                                "Simulações Monte Carlo mostram desvios <5% das especificações nominais.",
                                "Picos identificados com causas (e.g., frequência de crossover).",
                                "Relatório inclui gráficos muplot e wcnorm.",
                                "Controlador ajustado se necessário com nova validação."
                              ],
                              "assessmentCriteria": [
                                "Precisão na modelagem de incertezas (estrutura correta: 20%).",
                                "Execução correta de μ-analysis e interpretação de bounds (30%).",
                                "Validação wcgain com análise de picos e simulações (25%).",
                                "Qualidade da interpretação e recomendações (15%).",
                                "Documentação e reprodutibilidade do código (10%)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Álgebra linear (singular values) e otimização convexa.",
                                "Programação: MATLAB scripting e toolbox de controle robusto.",
                                "Física: Dinâmica de sistemas lineares com perturbações.",
                                "Engenharia de Software: Validação numérica e testes unitários."
                              ],
                              "realWorldApplication": "Em design de controladores para aviões (incertezas aerodinâmicas), veículos autônomos (variações de massa/carga) ou processos industriais (variações paramétricas), garantindo estabilidade apesar de incertezas para segurança e performance."
                            },
                            "estimatedTime": "3 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.6.4.3.3",
                            "name": "Executar simulações Monte Carlo para validação",
                            "description": "Implementar loops Monte Carlo com `usample` para gerar amostras de incertezas e estatisticamente validar desempenho e estabilidade.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Definir o modelo do sistema e identificar parâmetros incertos",
                                  "subSteps": [
                                    "Carregue o modelo do sistema no ambiente MATLAB/Simulink (ex: uss ou tf).",
                                    "Identifique parâmetros sujeitos a incerteza, como ganhos, constantes de tempo ou atrasos.",
                                    "Defina distribuições probabilísticas para cada parâmetro (ex: ureal com 'Percent', 'Interval' ou 'Normal').",
                                    "Crie uma estrutura de dados (struct ou tabela) para registrar as definições de incerteza.",
                                    "Documente as faixas de variação baseadas em dados reais ou especificações."
                                  ],
                                  "verification": "Lista documentada de parâmetros incertos com suas distribuições probabilísticas.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "MATLAB com Control System Toolbox e Robust Control Toolbox; modelo do sistema em arquivo .mat ou Simulink.",
                                  "tips": "Priorize incertezas com maior impacto no desempenho via análise de sensibilidade prévia.",
                                  "learningObjective": "Identificar e modelar fontes de incerteza paramétrica em sistemas de controle.",
                                  "commonMistakes": "Definir distribuições inadequadas (ex: normal para parâmetros físicos limitados) ou ignorar correlações entre parâmetros."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Gerar amostras de incerteza com usample",
                                  "subSteps": [
                                    "Construa o modelo incerto usando ureal para cada parâmetro (ex: P = tf(1,[1 1]) * ureal('K',1,'Percentage',10)).",
                                    "Gere N amostras (ex: 1000-5000) com usample(modelo_incerto, N).",
                                    "Armazene as amostras em uma cell array ou matriz para uso no loop.",
                                    "Plote histogramas das amostras individuais para validar as distribuições.",
                                    "Verifique estatísticas das amostras (média, desvio padrão) contra as especificadas."
                                  ],
                                  "verification": "Cell array de amostras gerada e histogramas confirmam fidelidade às distribuições.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Robust Control Toolbox; funções usample e histogram.",
                                  "tips": "Escolha N baseado em convergência (teste com 100, 500, 1000 para observar estabilização).",
                                  "learningObjective": "Implementar geração de amostras aleatórias de modelos incertos com usample.",
                                  "commonMistakes": "Gerar poucas amostras levando a variância alta ou usar usample incorretamente em modelos não-incertos."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Executar o loop de simulações Monte Carlo",
                                  "subSteps": [
                                    "Configure o loop for ou parfor sobre as N amostras.",
                                    "Para cada amostra, realize simulação em malha fechada (ex: feedback e step ou lsim).",
                                    "Colete métricas chave: overshoot, tempo de assentamento, erro estacionário, polos.",
                                    "Armazene métricas em vetores (ex: overshoots(i) = max(y)-yss).",
                                    "Implemente barra de progresso e salvamento periódico para evitar perda de dados."
                                  ],
                                  "verification": "Vetores de métricas completos com N entradas e sem erros de simulação.",
                                  "estimatedTime": "45-90 minutos (depende de N e complexidade do modelo)",
                                  "materials": "Simulink ou funções step/lsim; Parallel Computing Toolbox para parfor.",
                                  "tips": "Paralelize com parfor para aceleração em múltiplos núcleos.",
                                  "learningObjective": "Realizar simulações em lote para análise estatística de desempenho.",
                                  "commonMistakes": "Não tratar instabilidades em amostras (use try-catch) ou coletar métricas inconsistentes."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar resultados estatisticamente e validar robustez",
                                  "subSteps": [
                                    "Calcule estatísticas: média, mediana, desvio padrão, percentis (5%, 95%) com mean, std, prctile.",
                                    "Gere plots: histogramas, boxplots e QQ-plots das métricas.",
                                    "Avalie critérios: % de simulações com overshoot < 20%, todos polos estáveis.",
                                    "Teste convergência variando N e compare estatísticas.",
                                    "Elabore relatório com conclusões sobre estabilidade e desempenho robusto."
                                  ],
                                  "verification": "Relatório com gráficos, tabelas estatísticas e afirmações de validação gerado.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Funções MATLAB: histogram, boxplot, prctile, pole.",
                                  "tips": "Use violinplot ou swarmchart para visualizações avançadas de distribuições.",
                                  "learningObjective": "Interpretar resultados Monte Carlo para inferir robustez estatística.",
                                  "commonMistakes": "Confundir média com mediana em distribuições assimétricas ou ignorar caudas da distribuição."
                                }
                              ],
                              "practicalExample": "Em um sistema de controle de posição de um motor DC com controlador PID, defina incertezas de ±15% nos ganhos Kp, Ki, Kd como ureal('Percentage',15). Gere 2000 amostras com usample, simule respostas ao degrau coletando overshoot e tempo de subida. Analise: verifique se 95% das simulações têm overshoot <25% e tempo de subida <2s, plotando boxplot para validar estabilidade sob variação.",
                              "finalVerifications": [
                                "N ≥ 1000 amostras geradas e simuladas sem falhas.",
                                "Estatísticas descritivas (média, dp, percentis) calculadas para todas métricas chave.",
                                "Gráficos (histograma/boxplot) mostram distribuições sem anomalias.",
                                "Percentual de simulações atendendo specs ≥90%.",
                                "Conclusão explícita sobre robustez (ex: 'Sistema estável em 98% dos casos').",
                                "Teste de convergência confirma independência de N."
                              ],
                              "assessmentCriteria": [
                                "Uso correto de usample para modelos incertos.",
                                "Número de amostras adequado e justificado.",
                                "Coleta consistente de métricas de desempenho.",
                                "Análise estatística rigorosa com percentis e testes.",
                                "Interpretação alinhada aos resultados (sem viés).",
                                "Código documentado e reproduzível."
                              ],
                              "crossCurricularConnections": [
                                "Estatística e Probabilidade: simulação de variáveis aleatórias e inferência.",
                                "Programação Numérica: loops eficientes e vetoriação em MATLAB.",
                                "Análise de Dados: visualização e estatísticas descritivas.",
                                "Matemática Aplicada: teoria de robustez e análise de sensibilidade."
                              ],
                              "realWorldApplication": "Na indústria automotiva, simulações Monte Carlo validam controladores de tração em veículos elétricos sob variações de bateria e atrito da estrada, garantindo desempenho seguro em 99% dos cenários reais e reduzindo custos de testes físicos."
                            },
                            "estimatedTime": "3 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.6.5",
                    "name": "Exemplos de Aplicação em Sistemas LIT Escalares",
                    "description": "Casos práticos de projeto de controladores via otimização paramétrica com análise de resultados.",
                    "individualConcepts": [
                      {
                        "id": "10.1.6.5.1",
                        "name": "Formulação de Problemas de Otimização Paramétrica em Sistemas LIT Escalares",
                        "description": "Definição de exemplos práticos para sistemas lineares invariantes no tempo (LIT) escalares, incluindo a escolha de parâmetros do controlador, critérios de desempenho e modelagem de incertezas para otimização.",
                        "specificSkills": [
                          {
                            "id": "10.1.6.5.1.1",
                            "name": "Identificar e modelar um sistema LIT escalar para projeto de controlador",
                            "description": "Selecionar um sistema físico simples (ex: sistema de segundo ordem como um motor DC) e representá-lo em forma de transferência padrão, incorporando modelos de incertezas aditivas ou multiplicativas conforme a parametrização de controladores estabilizadores.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Selecionar e descrever o sistema físico simples escalar",
                                  "subSteps": [
                                    "Pesquisar sistemas físicos comuns de segunda ordem, como motor DC, massa-mola-amortecedor ou circuito RLC.",
                                    "Escolher um sistema monovariável (uma entrada, uma saída) com dinâmica escalar.",
                                    "Descrever verbalmente o sistema, identificando entrada (ex: tensão), saída (ex: velocidade) e variáveis de estado.",
                                    "Esboçar um diagrama esquemático do sistema.",
                                    "Justificar a escolha com base na simplicidade e relevância para controle"
                                  ],
                                  "verification": "Relatório com descrição, diagrama e justificativa do sistema selecionado.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Livros de controle (ex: Ogata), internet para diagramas, papel e caneta"
                                  ],
                                  "tips": "Priorize sistemas com parâmetros conhecidos para facilitar derivações futuras.",
                                  "learningObjective": "Identificar sistemas LIT escalares adequados para modelagem e projeto de controladores.",
                                  "commonMistakes": [
                                    "Selecionar sistemas multivariáveis ou não lineares complexos desde o início.",
                                    "Ignorar a natureza escalar do sistema."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Derivar as equações dinâmicas não-lineares",
                                  "subSteps": [
                                    "Aplicar leis físicas fundamentais (ex: 2ª Lei de Newton para motor DC: J θ'' + b θ' = K i).",
                                    "Identificar equações diferenciais envolvendo entrada u(t) e saída y(t).",
                                    "Expressar em termos de variáveis de estado (ex: posição, velocidade).",
                                    "Verificar unidades e consistência das equações.",
                                    "Documentar suposições feitas (ex: atrito viscoso constante)"
                                  ],
                                  "verification": "Conjunto de equações diferenciais não-lineares derivadas e balanceadas.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Folha de cálculos, calculadora, referências teóricas de dinâmica"
                                  ],
                                  "tips": "Use diagramas de corpo livre para forças/torques.",
                                  "learningObjective": "Desenvolver modelo matemático físico preciso do sistema.",
                                  "commonMistakes": [
                                    "Esquecer termos de amortecimento ou inércia.",
                                    "Confundir entrada com variáveis de estado."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Linearizar o modelo ao redor de um ponto de operação",
                                  "subSteps": [
                                    "Definir ponto de equilíbrio (ex: velocidade constante ω0 com tensão u0).",
                                    "Calcular Jacobiano ou usar expansão de Taylor para variáveis δx = x - x0, δu = u - u0.",
                                    "Obter modelo linear: δẋ = A δx + B δu; δy = C δx.",
                                    "Verificar estabilidade do ponto linearizado.",
                                    "Simplificar se possível, assumindo pequenas perturbações"
                                  ],
                                  "verification": "Matrizes A, B, C do modelo linearizado computadas corretamente.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Software simbólico como MATLAB/SymPy, papel para derivações"
                                  ],
                                  "tips": "Teste com valores numéricos pequenos para validar linearização.",
                                  "learningObjective": "Obter aproximação linear válida para análise de controle.",
                                  "commonMistakes": [
                                    "Linearizar incorretamente o Jacobiano.",
                                    "Não definir adequadamente o ponto de operação."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Converter para forma de transferência padrão",
                                  "subSteps": [
                                    "Aplicar transformada de Laplace ao modelo de estado: G(s) = C(sI - A)^(-1) B.",
                                    "Simplificar para forma padrão de segunda ordem: G(s) = ω_n² / (s² + 2ζω_n s + ω_n²).",
                                    "Identificar ganho estático K, polos e zeros.",
                                    "Plotar diagrama de blocos da função de transferência.",
                                    "Validar com simulação passo simples"
                                  ],
                                  "verification": "Função de transferência G(s) em forma canônica com parâmetros identificados.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "MATLAB/Simulink ou Python (Control library), tabelas de Laplace"
                                  ],
                                  "tips": "Use controle + espaço para computar tf diretamente.",
                                  "learningObjective": "Representar o sistema em domínio s para projeto de controladores.",
                                  "commonMistakes": [
                                    "Erros em simplificação algébrica.",
                                    "Ignorar ganho DC."
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Incorporar modelos de incertezas aditivas ou multiplicativas",
                                  "subSteps": [
                                    "Identificar fontes de incerteza (ex: variação de parâmetros ±20%).",
                                    "Modelar incerteza aditiva: G(s) = G0(s) (1 + Δ(s)); multiplicativa: G(s) = G0(s) (1 + W(s)Δ(s)).",
                                    "Parametrizar para estabilização (ex: usando μ-síntese basics).",
                                    "Simular impacto das incertezas na resposta.",
                                    "Documentar bounds de incerteza (||Δ||∞ <1)"
                                  ],
                                  "verification": "Modelo robusto com incertezas explicitadas e simulado.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "MATLAB Robust Control Toolbox, referências em controle robusto"
                                  ],
                                  "tips": "Comece com incertezas paramétricas simples antes de dinâmicas.",
                                  "learningObjective": "Preparar modelo para projeto de controladores estabilizadores robustos.",
                                  "commonMistakes": [
                                    "Sobrestimar incertezas sem justificativa.",
                                    "Confundir aditiva com multiplicativa."
                                  ]
                                }
                              ],
                              "practicalExample": "Sistema: Motor DC. Equações: J ω' + b ω = K_t i; L i' + R i = v - K_e ω. Linearizado em ω0: G(s) = K / (s(τ_m s +1)), com incerteza multiplicativa Δ = ±10% em b (W(s)=0.1).",
                              "finalVerifications": [
                                "Função de transferência G(s) correta e em forma padrão.",
                                "Modelo linearizado validado por simulação.",
                                "Incertezas parametrizadas com bounds definidos.",
                                "Diagrama de blocos completo.",
                                "Resposta ao degrau simulada coincide com física esperada.",
                                "Relatório com todas derivações documentadas."
                              ],
                              "assessmentCriteria": [
                                "Precisão matemática das derivações (sem erros algébricos).",
                                "Correta identificação de ponto de linearização.",
                                "Adequação da forma de transferência para segunda ordem.",
                                "Realismo das incertezas modeladas.",
                                "Qualidade da simulação e validação.",
                                "Clareza na documentação e justificativas."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Equações diferenciais, transformada de Laplace e álgebra linear.",
                                "Física: Dinâmica newtoniana e eletromagnetismo.",
                                "Programação: Simulações em MATLAB/Python para validação.",
                                "Engenharia Mecânica: Modelagem de atuadores como motores.",
                                "Estatística: Análise de incertezas paramétricas."
                              ],
                              "realWorldApplication": "Modelagem de motores em drones para controle de atitude, sistemas de tração veicular em carros elétricos ou reguladores de temperatura em processos industriais, garantindo estabilidade apesar de variações de carga."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.6.5.1.2",
                            "name": "Definir função objetivo paramétrica para otimização",
                            "description": "Construir uma função custo que minimize erros de rastreamento, maximize robustez (ex: margens de ganho e fase) e atenda especificações H∞ ou μ, utilizando métricas como norma H∞ para sistemas LIT escalares.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Analisar Especificações do Problema de Otimização",
                                  "subSteps": [
                                    "Identificar requisitos de performance de rastreamento, como erro máximo em resposta transitória e regime permanente",
                                    "Listar especificações de robustez, incluindo margens de ganho e fase mínimas, e limites de norma H∞ para funções de sensibilidade",
                                    "Definir a faixa de frequências de interesse (ex: 0 a ω_c, onde ω_c é a frequência de corte)",
                                    "Documentar restrições em parâmetros do controlador (ex: limites em ganhos) e incertezas do modelo (ex: ±20% em constantes de tempo)",
                                    "Mapear especificações para objetivos quantificáveis de minimização"
                                  ],
                                  "verification": "Lista completa de especificações documentada em tabela, com unidades e referências ao problema LIT escalar.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Especificações do sistema LIT",
                                    "Ferramentas como MATLAB Bode plots",
                                    "Referências teóricas (Skogestad & Postlethwaite)"
                                  ],
                                  "tips": "Priorize especificações de segurança e robustez sobre performance pura para evitar controladores frágeis.",
                                  "learningObjective": "Compreender e quantificar os trade-offs entre rastreamento e robustez no contexto de otimização paramétrica.",
                                  "commonMistakes": [
                                    "Ignorar especificações de alta frequência levando a violações H∞",
                                    "Não considerar incertezas reais do sistema",
                                    "Definir faixas de frequência muito amplas, aumentando complexidade computacional"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Selecionar e Formalizar Métricas de Performance e Robustez",
                                  "subSteps": [
                                    "Definir métrica de rastreamento: ex. J_track = ∫_0^∞ e(t)^2 dt ou ||W_e S||_∞ para referência r(t)",
                                    "Selecionar métricas de robustez: norma H∞ de sensibilidade S (||S||_∞ < γ), complemento sensibilidade T, e margens GM/PM",
                                    "Incluir normas μ para incertezas estruturadas se aplicável (ex: μ_Δ(KS) < 1/γ_μ)",
                                    "Expressar todas as métricas como funções dos parâmetros θ do controlador (ex: K(s,θ))",
                                    "Verificar consistência dimensional e escalabilidade das métricas"
                                  ],
                                  "verification": "Cada métrica expressa matematicamente como função contínua de θ, testada com valores simbólicos.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "MATLAB Control System Toolbox",
                                    "Documentação de normas H∞/μ (Zhou, Doyle)",
                                    "Papel e lápis para derivações simbólicas"
                                  ],
                                  "tips": "Use pesos de frequência W(s) para enfatizar regiões críticas e evitar picos desnecessários.",
                                  "learningObjective": "Selecionar métricas adequadas para sistemas LIT escalares que capturem tanto performance quanto robustez.",
                                  "commonMistakes": [
                                    "Confundir norma H2 (energia) com H∞ (pico)",
                                    "Não linearizar métricas marginais para otimização suave",
                                    "Omitir termos de controle effort (||KS||_∞) levando a atuadores saturados"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Construir Termos Individuais da Função Custo",
                                  "subSteps": [
                                    "Formular termo de rastreamento: J1(θ) = max_ω |W_e(jω) S(jω,θ)| ou aproximação integral",
                                    "Desenvolver termos de robustez: J2(θ) = ||W_s S||_∞ + J3(θ) = -min(GM, PM) para penalizar margens baixas",
                                    "Adicionar penalidades para normas μ: J4(θ) = μ_Δ(KS(θ))^2 se computável",
                                    "Normalizar termos por escalas (ex: dividir por valor nominal) para balanceamento inicial",
                                    "Implementar aproximação numérica para termos não-convexos (ex: grid de frequências para H∞)"
                                  ],
                                  "verification": "Cada J_i(θ) computável numericamente para θ teste, com valores finitos e positivos.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "MATLAB/Simulink para simulações de frequência",
                                    "Python com control library (python-control)",
                                    "Funções hinfsyn ou musyn para benchmarks"
                                  ],
                                  "tips": "Comece com termos convexos (H∞) e adicione não-lineares gradualmente para manter tractabilidade.",
                                  "learningObjective": "Construir componentes modulares da função custo que reflitam especificações multi-objetivo.",
                                  "commonMistakes": [
                                    "Termos não escalados causando dominação de um sobre outros",
                                    "Usar métricas absolutas em vez de normalizadas",
                                    "Ignorar dependência paramétrica explícita em θ"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Formular e Validar Função Objetivo Paramétrica Completa",
                                  "subSteps": [
                                    "Combinar termos: J(θ) = ∑_{i=1}^N w_i J_i(θ) + λ ∑ violações(constraints)",
                                    "Escolher pesos iniciais w_i via trial-and-error ou otimização hierárquica",
                                    "Implementar gradientes analíticos ou numéricos para ∂J/∂θ se necessário",
                                    "Testar sensibilidade: variar θ em ±10% e verificar monotonia de J",
                                    "Documentar J(θ) final com pseudocódigo para avaliação em otimizador"
                                  ],
                                  "verification": "J(θ) minimizada em simulação reduz erros e atende specs; gradiente computável.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Otimizadores como fmincon (MATLAB) ou scipy.optimize",
                                    "Scripts de validação personalizados",
                                    "Gráficos de Bode para inspeção visual"
                                  ],
                                  "tips": "Use pesos logarítmicos para H∞ (log(||.||_∞)) para suavizar não-convexidade.",
                                  "learningObjective": "Integrar métricas em uma função custo paramétrica otimizável e validada.",
                                  "commonMistakes": [
                                    "Pesos mal balanceados levando a soluções subótimas",
                                    "Não penalizar violações soft com λ baixo",
                                    "Função não diferenciável impedindo gradiente descendente"
                                  ]
                                }
                              ],
                              "practicalExample": "Para um sistema LIT escalar de controle de posição de um braço robótico (planta G(s) = 1/(s(s+1))), defina J(θ) = w1 ∫ e^2 dt + w2 ||S||_∞ + w3 (1/GM)^2, onde θ = [k_p, k_i, k_d] do PID, com w1=1, w2=10, w3=5, visando erro <5% e ||S||_∞ <2.",
                              "finalVerifications": [
                                "J(θ) minimiza erro de rastreamento em simulação de degrau unitário (< especificado)",
                                "Norma H∞ da sensibilidade S satisfaz γ especificada em toda faixa ω",
                                "Margens de ganho/fase ≥ 6dB/45° em análise de Bode",
                                "Robustez a ±20% variação em polo da planta mantida",
                                "Gradiente ∂J/∂θ finito e útil para otimizador",
                                "Sem violações de constraints em atuador (u(t) < limite)"
                              ],
                              "assessmentCriteria": [
                                "Precisão na formulação matemática de J(θ) (100% alinhada com specs)",
                                "Balanceamento de termos (nenhum domina >80% do valor total)",
                                "Tractabilidade computacional (avaliação <1s por iteração)",
                                "Cobertura completa de specs (rastreamento, robustez, H∞/μ)",
                                "Validação numérica inicial (redução J >20% em θ perturbado)",
                                "Documentação clara com expressões e justificativas"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Otimização multi-objetivo e normas de Hardy (H∞)",
                                "Programação: Implementação numérica em MATLAB/Python para avaliação de J(θ)",
                                "Física: Modelagem dinâmica LIT e análise de estabilidade",
                                "Estatística: Análise de sensibilidade paramétrica e Monte Carlo para robustez",
                                "Engenharia de Software: Modularidade em funções custo para reutilização"
                              ],
                              "realWorldApplication": "No design de controladores para aviões autônomos (drones), onde J(θ) minimiza erro de trajetória GPS enquanto garante robustez H∞ contra turbulências e falhas de sensores, permitindo pousos precisos em condições variáveis."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.6.5.1.3",
                            "name": "Configurar restrições de estabilidade e robustez",
                            "description": "Aplicar condições de estabilidade via teorema de Nyquist ou LMI para garantir que os parâmetros otimizados estabilizem o sistema com incertezas, formatando a malha de realimentação.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Fundamentos de Estabilidade com Nyquist e LMI",
                                  "subSteps": [
                                    "Estude o teorema de Nyquist: entenda o critério de estabilidade baseado no número de encirclements do ponto -1 no plano complexo.",
                                    "Revise LMI (Linear Matrix Inequalities): aprenda como representar condições de estabilidade quadrática via desigualdades matriciais lineares.",
                                    "Compare Nyquist (frequencial) vs. LMI (tempo-discreto/robustez): identifique quando usar cada um para sistemas LIT com incertezas.",
                                    "Pratique com diagramas de Nyquist simples usando ferramentas como MATLAB.",
                                    "Anote equações chave: G(jω) e condições de Lyapunov para LMI."
                                  ],
                                  "verification": "Resuma em um diagrama ou tabela as diferenças entre Nyquist e LMI, com exemplos de fórmulas.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Livro de controle avançado (ex: Ogata), MATLAB/Simulink, notas de aula.",
                                  "tips": "Desenhe diagramas à mão para visualizar encirclements antes de simular.",
                                  "learningObjective": "Compreender as bases teóricas para aplicar restrições de estabilidade.",
                                  "commonMistakes": "Confundir estabilidade absoluta com relativa; ignorar direção de encirclement no Nyquist."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Modelar o Sistema LIT Escalar com Incertezas",
                                  "subSteps": [
                                    "Defina a função de transferência do sistema LIT escalar G(s).",
                                    "Incorpore incertezas: adicione termos aditivos/multiplicativos (ex: ΔG(s) com norma bounded).",
                                    "Formule a malha de realimentação: C(s) controlador paramétrico com ganhos K a otimizar.",
                                    "Calcule a função de laço aberto L(s) = C(s)G(s)(1 + ΔG(s)).",
                                    "Discretize se necessário para LMI usando c2d no MATLAB."
                                  ],
                                  "verification": "Gere plots de Bode para G(s) nominal e com incertezas máximas.",
                                  "estimatedTime": "1 hora",
                                  "materials": "MATLAB Control System Toolbox, papel para esboços.",
                                  "tips": "Use structunc para modelar incertezas no MATLAB Robust Control Toolbox.",
                                  "learningObjective": "Representar o sistema real com incertezas paramétricas.",
                                  "commonMistakes": "Esquecer de normalizar incertezas; usar modelo sem realimentação."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Formular Restrições de Estabilidade via Nyquist ou LMI",
                                  "subSteps": [
                                    "Para Nyquist: defina restrições como distância mínima do ponto -1 para todos L(jω) com incertezas.",
                                    "Implemente ganho de fase/margem: gm_phase_margin > valores mínimos.",
                                    "Para LMI: formule P > 0 tal que A_cl^T P + P A_cl < 0 para matrizes fechadas com incertezas.",
                                    "Use YALMIP ou MATLAB LMI Toolbox para setup das desigualdades.",
                                    "Converta em restrições lineares nos parâmetros K."
                                  ],
                                  "verification": "Solucione uma LMI simples e verifique se P é positivo definido.",
                                  "estimatedTime": "1 hora 30 minutos",
                                  "materials": "YALMIP toolbox, MATLAB Optimization Toolbox.",
                                  "tips": "Comece com Nyquist para intuição visual antes de LMI computacional.",
                                  "learningObjective": "Traduzir teoremas em constraints acionáveis para otimização.",
                                  "commonMistakes": "Violar conservadorismo em LMI sem escalonamento; plots Nyquist sem zoom no -1."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Integrar Restrições na Otimização Paramétrica e Verificar",
                                  "subSteps": [
                                    "Inclua constraints no problema de otimização: min J(K) s.t. Nyquist/LMI holds.",
                                    "Use fmincon ou YALMIP para otimizar K.",
                                    "Simule resposta em malha fechada com step/ramp e incertezas.",
                                    "Analise robustez: Monte Carlo com variações aleatórias de parâmetros.",
                                    "Ajuste e re-otimize se falhar estabilidade."
                                  ],
                                  "verification": "Sistema fechado estável para 100% das simulações com incertezas.",
                                  "estimatedTime": "1 hora",
                                  "materials": "MATLAB, scripts de simulação personalizados.",
                                  "tips": "Salve seeds para reprodutibilidade em Monte Carlo.",
                                  "learningObjective": "Incorporar estabilidade na síntese de controladores.",
                                  "commonMistakes": "Otimizar sem bounds em K; ignorar overshoot em simulações."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Formatar e Documentar a Malha de Realimentação",
                                  "subSteps": [
                                    "Desenhe diagrama de blocos da malha com C(s) otimizado.",
                                    "Gere relatório: plots Nyquist, step responses, métricas de robustez.",
                                    "Exporte controlador para código embarcado se aplicável.",
                                    "Teste sensibilidade a variações de parâmetros.",
                                    "Revise com pares para feedback."
                                  ],
                                  "verification": "Relatório completo com todos plots e métricas passando thresholds.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "LaTeX/MATLAB Publisher para relatório.",
                                  "tips": "Use legendas claras em plots para facilitar revisão.",
                                  "learningObjective": "Profissionalizar a aplicação em projetos reais.",
                                  "commonMistakes": "Plots sem unidades; relatório sem conclusões quantitativas."
                                }
                              ],
                              "practicalExample": "Em um sistema de controle de posição de um motor DC com incerteza de 20% no ganho, aplique Nyquist para garantir margem de fase >45° e LMI para estabilidade quadrática, otimizando PID gains via fmincon. Simule step response mostrando settling time <2s mesmo com ΔK=±20%.",
                              "finalVerifications": [
                                "Diagrama Nyquist não encircles -1 para todas incertezas.",
                                "LMI resolvida com P>0 e eigenvalues negativos.",
                                "Step response estável com overshoot <20% e settling <5s.",
                                "Monte Carlo: 95% das runs estáveis.",
                                "Margens de ganho/fase >6dB/45°.",
                                "Controlador implementável em hardware simulado."
                              ],
                              "assessmentCriteria": [
                                "Precisão na formulação de constraints (Nyquist/LMI corretas).",
                                "Efetividade da otimização (J mínima com estabilidade).",
                                "Robustez comprovada via simulações.",
                                "Clareza na documentação e plots.",
                                "Eficiência computacional (tempo de solve <10min).",
                                "Criatividade em handling de incertezas específicas."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Álgebra linear para LMIs e análise complexa para Nyquist.",
                                "Programação: Otimização numérica em MATLAB/Python.",
                                "Física: Modelagem dinâmica de sistemas mecatrônicos.",
                                "Engenharia de Software: Validação e testes unitários em simulações."
                              ],
                              "realWorldApplication": "Configuração de controladores robustos em drones para estabilização apesar de ventos variáveis (incertezas aerodinâmicas), ou em linhas de produção industriais para manter precisão com desgaste de atuadores."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.6.5.2",
                        "name": "Implementação Algorítmica de Otimização em Exemplos Práticos",
                        "description": "Execução de métodos numéricos de otimização paramétrica em ferramentas como MATLAB, para projetar controladores em casos reais de sistemas LIT escalares.",
                        "specificSkills": [
                          {
                            "id": "10.1.6.5.2.1",
                            "name": "Implementar otimização paramétrica usando funções MATLAB",
                            "description": "Utilizar comandos como fmincon ou Robust Control Toolbox para otimizar parâmetros de um controlador PID ou lead-lag em um sistema LIT com incertezas, simulando respostas temporais e diagramas de Bode.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Modelar o sistema LIT e definir estrutura do controlador",
                                  "subSteps": [
                                    "Obtenha ou crie o modelo de transferência do sistema LIT usando tf() ou ss() no MATLAB.",
                                    "Defina a estrutura do controlador PID (Kp, Ki, Kd) ou lead-lag com variáveis simbólicas ou vetores iniciais.",
                                    "Inclua incertezas no modelo usando uss() ou ureal() do Robust Control Toolbox.",
                                    "Crie um loop fechado inicial com feedback() para testes preliminares.",
                                    "Salve o modelo em uma workspace para reutilização."
                                  ],
                                  "verification": "Execute o script e confirme que o modelo responde a step() sem erros, visualizando step response básica.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "MATLAB com Control System Toolbox",
                                    "Robust Control Toolbox (opcional)",
                                    "Exemplo de sistema LIT como motor DC G(s) = 1/(s+1)"
                                  ],
                                  "tips": "Comece com valores iniciais razoáveis para parâmetros do controlador para evitar singularidades na otimização posterior.",
                                  "learningObjective": "Compreender modelagem de sistemas LIT com incertezas e estruturas de controladores básicos.",
                                  "commonMistakes": [
                                    "Esquecer de linearizar modelos não-lineares",
                                    "Não definir incertezas adequadamente levando a otimização irrealista"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Definir a função objetivo para otimização",
                                  "subSteps": [
                                    "Crie uma função anônima ou arquivo .m que compute o custo baseado em métricas como IAE, overshoot ou robustez.",
                                    "Inclua simulações de resposta temporal usando lsim() ou step() em conjunto com o controlador parametrizado.",
                                    "Adicione penalidades para violações de restrições (ex: ganho de fase mínimo).",
                                    "Teste a função custo com parâmetros iniciais para garantir valores finitos.",
                                    "Incorpore análise de Bode com bode() para penalizar picos de frequência."
                                  ],
                                  "verification": "Chame a função custo com valores iniciais e verifique se retorna um escalar positivo sem NaN ou Inf.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Documentação MATLAB fmincon",
                                    "Funções step(), bode(), norm()"
                                  ],
                                  "tips": "Use peso relativo nas métricas (ex: 0.7*IAE + 0.3*peak) para balancear performance temporal e frequência.",
                                  "learningObjective": "Desenvolver funções de custo que reflitam especificações de controle reais.",
                                  "commonMistakes": [
                                    "Função custo não diferenciável",
                                    "Ignorar incertezas na simulação levando a soluções frágeis"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Configurar e executar otimização paramétrica com fmincon",
                                  "subSteps": [
                                    "Defina variáveis de otimização x0 (vetor inicial), lb/ub (limites) e A/b para restrições lineares.",
                                    "Configure opções com optimoptions('fmincon', 'Display', 'iter', 'Algorithm', 'interior-point').",
                                    "Invoque [x_otim, fval] = fmincon(@custo_fun, x0, A, b, [], [], lb, ub, [], options).",
                                    "Para Robust Control, use loop shaping ou mu-síntese se aplicável.",
                                    "Registre histórico de iterações para análise."
                                  ],
                                  "verification": "Confirme convergência (fval finito e baixo) e parâmetros dentro de limites.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Optimization Toolbox",
                                    "Exemplos de fmincon na documentação MathWorks"
                                  ],
                                  "tips": "Forneça bom x0 via Ziegler-Nichols para aceleração; use 'MaxIterations' alto para convergência.",
                                  "learningObjective": "Aplicar solvers de otimização não-lineares em problemas de controle.",
                                  "commonMistakes": [
                                    "Restrições muito apertadas causando falha",
                                    "Gradientes numéricos imprecisos sem 'SpecifyObjectiveGradient'"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Simular, analisar e validar resultados otimizados",
                                  "subSteps": [
                                    "Monte controlador otimizado e loop fechado com feedback().",
                                    "Gere plots: step response, Bode magnitude/fase para nominal e com incertezas.",
                                    "Compare com controlador não-otimizado usando métricas como settling time e margem de fase.",
                                    "Teste robustez perturbando incertezas e re-simulando.",
                                    "Documente resultados em figure com legendas e salve workspace."
                                  ],
                                  "verification": "Plots mostram melhoria (ex: overshoot <10%, PM >45°) e robustez mantida.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Funções step(), bode(), margin()",
                                    "Export graphics para relatório"
                                  ],
                                  "tips": "Use grid() e zoom em plots para clareza; salve como .fig para edição.",
                                  "learningObjective": "Interpretar simulações para validar otimizações em controle.",
                                  "commonMistakes": [
                                    "Não testar com incertezas",
                                    "Escalas erradas em plots ocultando problemas"
                                  ]
                                }
                              ],
                              "practicalExample": "Otimize parâmetros PID para um motor DC modelado como G(s) = 1000/(s^2 + 10s + 20) com incerteza de 20% no ganho, minimizando IAE em step response e garantindo PM > 60° via fmincon.",
                              "finalVerifications": [
                                "Função custo converge para valor < threshold definido (ex: 1.0).",
                                "Resposta temporal otimizada atende specs: rise time <2s, overshoot <5%.",
                                "Diagramas de Bode mostram estabilidade robusta (GM>6dB, PM>45°).",
                                "Simulações com incertezas máximas mantêm performance dentro de 20%.",
                                "Código roda sem erros e é reproduzível com seed rand.",
                                "Relatório com plots compara antes/depois."
                              ],
                              "assessmentCriteria": [
                                "Precisão da modelagem LIT com incertezas (correto uso de ureal()).",
                                "Definição robusta da função custo integrando temporal e frequência.",
                                "Configuração correta de fmincon com convergência em <50 iterações.",
                                "Análise completa com plots e métricas quantitativas.",
                                "Código limpo, comentado e modular.",
                                "Demonstração de robustez via simulações variadas."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Otimização não-linear e cálculo de gradientes.",
                                "Programação: Desenvolvimento de funções MATLAB e debugging.",
                                "Física: Dinâmica de sistemas mecânicos/elétricos LIT.",
                                "Estatística: Análise de incertezas e Monte Carlo para robustez.",
                                "Engenharia de Software: Boas práticas em scripts de simulação."
                              ],
                              "realWorldApplication": "Em automação industrial, otimizar controladores PID para robôs manipuladores ou HVAC systems, garantindo performance robusta apesar de variações em cargas ou parâmetros de planta, reduzindo tempo de comissionamento e downtime."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.6.5.2.2",
                            "name": "Simular controladores otimizados em cenários com incertezas",
                            "description": "Gerar simulações de Monte Carlo para validar robustez do controlador projetado contra variações paramétricas, analisando desempenho em malha fechada.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Definir o Modelo do Sistema e Controlador Otimizado",
                                  "subSteps": [
                                    "Especificar a função de transferência ou modelo estado-espaço do sistema LIT escalar.",
                                    "Implementar o controlador otimizado (ex: PID ou LQR) previamente projetado em software como MATLAB/Simulink.",
                                    "Configurar a malha fechada, incluindo planta, controlador, referência e realimentação.",
                                    "Definir condições iniciais e sinal de referência padrão (ex: degrau unitário).",
                                    "Testar simulação nominal sem incertezas para baseline."
                                  ],
                                  "verification": "Executar simulação nominal e confirmar que overshoot < 10%, tempo de estabilização < 5s e erro estacionário zero.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "MATLAB/Simulink",
                                    "Função de transferência do sistema",
                                    "Parâmetros do controlador otimizado"
                                  ],
                                  "tips": "Use blocos prontos no Simulink para agilizar; documente todos os parâmetros em um script.",
                                  "learningObjective": "Entender a configuração básica da malha fechada para análise de robustez.",
                                  "commonMistakes": [
                                    "Esquecer de linearizar o modelo se não for LIT",
                                    "Configurar malha aberta por engano",
                                    "Ignorar unidades nos parâmetros"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar Parâmetros com Incertezas e Definir Distribuições",
                                  "subSteps": [
                                    "Listar parâmetros sensíveis (ex: ganho da planta Kp, constante de tempo τ).",
                                    "Escolher distribuições probabilísticas realistas (ex: normal com μ=valor nominal, σ=10-20%).",
                                    "Definir bounds para variações (ex: ±30% do nominal).",
                                    "Gerar amostras iniciais com randn() ou mvnrnd() para validar distribuições.",
                                    "Documentar histograma das distribuições geradas."
                                  ],
                                  "verification": "Gerar 1000 amostras e plotar histograma; confirmar média ≈ nominal e desvio padrão correto.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "MATLAB (funções randn, hist)",
                                    "Lista de parâmetros sensíveis do sistema"
                                  ],
                                  "tips": "Use variações paramétricas baseadas em datasheets reais de sensores/atuadores.",
                                  "learningObjective": "Modelar incertezas paramétricas de forma estatística realista.",
                                  "commonMistakes": [
                                    "Usar distribuições uniformes quando gaussiana é mais apropriada",
                                    "Definir desvios padrão muito pequenos",
                                    "Ignorar correlações entre parâmetros"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Configurar e Executar Simulações Monte Carlo",
                                  "subSteps": [
                                    "Criar loop principal para N=1000-5000 iterações Monte Carlo.",
                                    "Em cada iteração: samplear parâmetros, atualizar modelo, simular malha fechada, extrair métricas (ITAE, overshoot, settling time).",
                                    "Implementar paralelização com parfor para eficiência.",
                                    "Armazenar métricas em vetores/matrices para análise posterior.",
                                    "Monitorar progresso e salvar dados intermediários."
                                  ],
                                  "verification": "Completar N simulações sem erros; tempo total < 10min com paralelização.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "MATLAB Parallel Computing Toolbox",
                                    "Script de simulação da malha fechada"
                                  ],
                                  "tips": "Pré-aloque arrays com zeros(N,1) para performance; use tic/toc para benchmark.",
                                  "learningObjective": "Implementar simulações estocásticas eficientes em larga escala.",
                                  "commonMistakes": [
                                    "Loops não vetorizados causando lentidão",
                                    "Não salvar seeds do rand para reprodutibilidade",
                                    "Sobrecarga de simulações (N>10k sem necessidade)"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar Resultados e Métricas de Desempenho",
                                  "subSteps": [
                                    "Calcular estatísticas: média, mediana, desvios, percentis (5%, 95%) das métricas.",
                                    "Plotar histogramas, boxplots e scatter plots (ex: ITAE vs. variação Kp).",
                                    "Avaliar robustez: % de casos com overshoot >20%, settling time > limite.",
                                    "Comparar com baseline nominal via testes estatísticos (ex: t-test).",
                                    "Gerar relatório com tabelas e figuras."
                                  ],
                                  "verification": "Produzir plots com legendas e rótulos; confirmar que >95% das simulações atendem specs nominais.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "MATLAB (histogram, boxplot, statistics toolbox)",
                                    "Dados das simulações"
                                  ],
                                  "tips": "Use subplot para múltiplos gráficos; exporte figs como PNG/PDF.",
                                  "learningObjective": "Interpretar dados estocásticos para validar robustez.",
                                  "commonMistakes": [
                                    "Ignorar outliers nas estatísticas",
                                    "Escalas erradas nos plots obscurecendo insights",
                                    "Confundir média com mediana em distribuições assimétricas"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Interpretar Robustez e Recomendar Ações",
                                  "subSteps": [
                                    "Classificar robustez: alta se desvios <10% nominais, baixa se >30%.",
                                    "Identificar parâmetros mais impactantes via análise de sensibilidade.",
                                    "Sugerir trade-offs ou redesign (ex: controlador robusto H-infinito).",
                                    "Documentar conclusões em relatório final com evidências.",
                                    "Testar cenários extremos para worst-case."
                                  ],
                                  "verification": "Relatório escrito com recomendações acionáveis e backed by data.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Resultados analíticos",
                                    "Template de relatório"
                                  ],
                                  "tips": "Priorize parâmetros com maior variância no impacto.",
                                  "learningObjective": "Tomar decisões baseadas em análise probabilística.",
                                  "commonMistakes": [
                                    "Generalizar de poucas simulações",
                                    "Ignorar worst-case em favor de médias",
                                    "Não quantificar trade-offs"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um sistema de controle de posição de um motor DC (G(s)=1/(s(s+1))), com controlador PID otimizado, simule 2000 cenários onde o ganho K varia ±20% (normal μ=1, σ=0.1) e τ ±15% (normal μ=1, σ=0.075). Analise se 95% das simulações mantêm overshoot <15% e settling time <4s.",
                              "finalVerifications": [
                                "Simulações Monte Carlo executadas com N≥1000 iterações convergentes.",
                                "Estatísticas das métricas mostram desvios <20% do nominal em 90% dos casos.",
                                "Plots e relatórios documentam robustez claramente.",
                                "Análise de sensibilidade identifica top-3 parâmetros críticos.",
                                "Recomendações incluem ações para mitigar incertezas identificadas.",
                                "Código é reprodutível com seed fixo."
                              ],
                              "assessmentCriteria": [
                                "Precisão na modelagem de distribuições paramétricas (erro <5% em stats).",
                                "Eficiência computacional (tempo <15min para N=5000).",
                                "Qualidade dos plots e visualizações (legendas, escalas adequadas).",
                                "Profundidade da análise estatística (percentis, testes de hipótese).",
                                "Clareza e ação nas conclusões de robustez.",
                                "Código modular e comentado."
                              ],
                              "crossCurricularConnections": [
                                "Probabilidade e Estatística: Distribuições, Monte Carlo, análise de variância.",
                                "Programação Computacional: Loops paralelos, vetorização em MATLAB/Python.",
                                "Engenharia de Software: Modularidade, reprodutibilidade, versionamento.",
                                "Análise de Dados: Visualização, estatística inferencial.",
                                "Otimização: Sensibilidade paramétrica."
                              ],
                              "realWorldApplication": "Validação de controladores em drones autônomos contra variações de massa/bateria, ou em plantas químicas com incertezas em constantes de reação, garantindo estabilidade em produção industrial e aeroespacial."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.6.5.2.3",
                            "name": "Aplicar técnicas H∞ em otimização paramétrica escalar",
                            "description": "Integrar síntese H∞ em um framework paramétrico para minimizar a norma H∞ da função de sensibilidade, comparando com μ-síntese em exemplos escalares.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Configurar o modelo do sistema LIT escalar e definir a função de sensibilidade",
                                  "subSteps": [
                                    "Modelar a planta nominal como função de transferência G(s) com parâmetros incertos (e.g., ganho K e polo p).",
                                    "Definir o conjunto de plantas P = {G(s, θ) | θ ∈ Θ}, onde θ são parâmetros escalares.",
                                    "Construir a função de sensibilidade S(s, θ) = [I + G(s, θ)K(s)]^{-1}.",
                                    "Especificar gamma alvo para ||S||_∞ < γ.",
                                    "Implementar em MATLAB usando tf() e uncertain() do Robust Control Toolbox."
                                  ],
                                  "verification": "Verificar estabilidade do laço unitário aberto e fechado via nyquist() ou bode().",
                                  "estimatedTime": "1-2 horas",
                                  "materials": [
                                    "MATLAB com Robust Control Toolbox",
                                    "Documentação de modelagem LIT (e.g., Skogestad & Postlethwaite)",
                                    "Exemplo de planta: massa-mola G(s) = 1/(s^2 + θ s + ω^2)"
                                  ],
                                  "tips": [
                                    "Use uss (uncertain state-space) para eficiência numérica.",
                                    "Plotar conjunto de plantas com showplot para visualização."
                                  ],
                                  "learningObjective": "Compreender parametrização de sistemas LIT e formulação de sensibilidade paramétrica.",
                                  "commonMistakes": [
                                    "Ignorar incertezas no modelo nominal.",
                                    "Confundir sensibilidade com complementar."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar síntese H∞ padrão para benchmark",
                                  "subSteps": [
                                    "Definir estrutura padrão de controle com pesos Wp (performance) e Wu (controle).",
                                    "Usar hinfsyn() para sintetizar K∞ tal que ||Tzw||_∞ < γ.",
                                    "Analisar ||S||_∞ para planta nominal e conjunto Θ.",
                                    "Plotar singular values de S(s, θ) via sigma().",
                                    "Verificar robustez com robuststab()."
                                  ],
                                  "verification": "γ ótimo < γ alvo e estabilidade robusta confirmada.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "MATLAB Robust Control Toolbox (hinfsyn, robuststab)",
                                    "Templates de pesos H∞ (e.g., Wp = (s/Ms + ωb)/(s + ωb A))",
                                    "Notebook Jupyter ou script .m"
                                  ],
                                  "tips": [
                                    "Comece com γ inicial alto e itere com hinfstruct() se necessário.",
                                    "Use grid() para amostrar Θ e plotar worst-case."
                                  ],
                                  "learningObjective": "Dominar síntese H∞ clássica e análise de performance robusta.",
                                  "commonMistakes": [
                                    "Pesos mal escalados levando a γ inflado.",
                                    "Não verificar ordem do controlador (reduzir com balreal())."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Formular e implementar otimização paramétrica H∞",
                                  "subSteps": [
                                    "Definir função objetivo f(θ) = max_ω σ_max(S(jω, θ)) sobre Θ discretizado.",
                                    "Parametrizar estrutura do controlador K(s, α) com α escalar (e.g., filtro notch).",
                                    "Usar fmincon() ou loop para minimizar max_θ ||S(θ)||_∞.",
                                    "Incorporar constraints: estabilidade e ||Ku||_∞ < limite.",
                                    "Iterar: sintetizar K(α), avaliar robustez, otimizar α."
                                  ],
                                  "verification": "Convergência de f(θ) com residual < 1e-3 e γ reduzido vs. benchmark.",
                                  "estimatedTime": "3-4 horas",
                                  "materials": [
                                    "MATLAB Optimization Toolbox (fmincon)",
                                    "Função auxiliar para ||S||_∞: norm(usub(S,θ), inf)",
                                    "Exemplo: θ = ganho de damping em G(s)"
                                  ],
                                  "tips": [
                                    "Discretize Θ finamente (e.g., 50 pontos) para aproximação precisa.",
                                    "Use parallel computing (parfor) para aceleração."
                                  ],
                                  "learningObjective": "Integrar síntese H∞ em framework de otimização paramétrica escalar.",
                                  "commonMistakes": [
                                    "Otimização local: use multi-starts com diferentes α0.",
                                    "Não lidar com não-convexidade (tratar como min-max)."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Comparar com μ-síntese e analisar resultados",
                                  "subSteps": [
                                    "Implementar μ-síntese via mussv() e musyn() para mesmo problema.",
                                    "Comparar γ_H∞ vs. γ_μ, robustez e custo computacional.",
                                    "Plotar μ upper/lower bounds vs. ||S||_∞ worst-case.",
                                    "Avaliar trade-offs: performance vs. ordem do controlador.",
                                    "Documentar em relatório: tabelas e figuras."
                                  ],
                                  "verification": "μ < 1 confirma robustez; γ_μ ≤ γ_H∞ paramétrica.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "MATLAB Mu Toolbox (mussv, musyn)",
                                    "Dados do Step 3 para benchmark",
                                    "LaTeX ou Word para relatório"
                                  ],
                                  "tips": [
                                    "μ-síntese é mais conservadora; destaque ganhos da paramétrica.",
                                    "Use DK-iteration com D-K tools para precisão."
                                  ],
                                  "learningObjective": "Criticar e comparar H∞ paramétrica vs. μ-síntese em cenários escalares.",
                                  "commonMistakes": [
                                    "Comparação injusta: igualar estruturas de pesos.",
                                    "Ignorar escalaridade: μ degenera para H∞ em LIT puro."
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Validar implementação e simular em cenários reais",
                                  "subSteps": [
                                    "Simular step response para θ nominal e extremal.",
                                    "Testar com ruído e distúrbios reais via lsim().",
                                    "Verificar violações de specs via checkTuning().",
                                    "Exportar controlador para hardware (e.g., Simulink Real-Time).",
                                    "Arquivar código e resultados versionados."
                                  ],
                                  "verification": "Overshoot < 20%, settling time < 5s em todos θ.",
                                  "estimatedTime": "1-2 horas",
                                  "materials": [
                                    "Simulink para simulação fechada",
                                    "Dados experimentais de planta real (opcional)"
                                  ],
                                  "tips": [
                                    "Use sitdemo_robust para inspiração.",
                                    "Sensibilidade a discretização: refinar grid Θ."
                                  ],
                                  "learningObjective": "Aplicar e validar otimizador H∞ paramétrico em prática.",
                                  "commonMistakes": [
                                    "Simulação só nominal: sempre worst-case.",
                                    "Não linearizar corretamente para validação."
                                  ]
                                }
                              ],
                              "practicalExample": "Considere um sistema massa-mola-amortecedor G(s) = 1/(s^2 + θ s + 1), θ ∈ [0.5, 1.5]. Otimize filtro lead K(s,α) = α (s/z +1)/(s/p +1) para min max_θ ||S||_∞ < 2, comparando γ=1.8 (H∞ param.) vs. γ=2.1 (μ).",
                              "finalVerifications": [
                                "||S(θ)||_∞ minimizado < γ benchmark para todo Θ.",
                                "Controlador K estabiliza robustamente (robuststab=1).",
                                "Simulações step mostram performance uniforme.",
                                "Código reproduzível com seed rand.",
                                "Relatório compara métricas H∞ vs. μ.",
                                "Trade-off custo computacional documentado."
                              ],
                              "assessmentCriteria": [
                                "Corretude matemática: derivação de S(θ) e obj. fun. (30%)",
                                "Implementação numérica eficiente e robusta (25%)",
                                "Análise comparativa profunda H∞ vs. μ (20%)",
                                "Visualizações claras (plots sigma, step) (15%)",
                                "Documentação e reprodutibilidade (10%)"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Otimização não-convexa (min-max), análise funcional (normas H∞)",
                                "Programação: MATLAB OOP para classes uncertain, paralelização",
                                "Física/Engenharia Mecânica: Modelagem dinâmica LIT com params. físicos",
                                "Estatística: Análise de sensibilidade paramétrica e Monte Carlo",
                                "Inteligência Artificial: Otimizadores como base para RL em controle"
                              ],
                              "realWorldApplication": "Otimização de controladores em atuadores aeroespaciais (e.g., flaps com variação térmica de damping), reduzindo overshoot em 15% vs. H∞ fixo, ou em robótica industrial para precisão apesar de desgaste paramétrico."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.6.5.3",
                        "name": "Análise e Comparação de Resultados de Projetos",
                        "description": "Avaliação crítica dos controladores obtidos via otimização paramétrica versus métodos clássicos, com foco em estabilidade, desempenho e robustez em sistemas LIT escalares.",
                        "specificSkills": [
                          {
                            "id": "10.1.6.5.3.1",
                            "name": "Avaliar métricas de desempenho dos controladores projetados",
                            "description": "Calcular índices como tempo de assentamento, overshoot, margens de estabilidade e norma H∞ para comparar resultados da otimização com controladores clássicos (ex: Ziegler-Nichols).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar os modelos de controladores para simulação",
                                  "subSteps": [
                                    "Carregue o modelo do sistema LIT escalar no ambiente de simulação (ex: MATLAB/Simulink).",
                                    "Implemente o controlador otimizado (ex: via otimização LMI ou H∞) e o controlador clássico (ex: PID via Ziegler-Nichols).",
                                    "Configure entradas de teste padrão (degrau unitário, rampa) e condições iniciais.",
                                    "Execute simulações preliminares para validar estabilidade básica.",
                                    "Documente parâmetros chave de cada controlador (ganhos Kp, Ki, Kd para PID)."
                                  ],
                                  "verification": "Modelos simulados produzem respostas estáveis sem erros de execução; gráficos iniciais gerados.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "MATLAB/Simulink",
                                    "Funções de controle (pidtune, lmi-control toolbox)",
                                    "Modelo do sistema LIT (ex: planta de segundo ordem)"
                                  ],
                                  "tips": "Use scripts .m para automação; verifique unidades consistentes em tempo e amplitude.",
                                  "learningObjective": "Entender a configuração comparativa de controladores para análise métrica.",
                                  "commonMistakes": [
                                    "Esquecer de linearizar o modelo não-linear",
                                    "Usar entradas inadequadas que mascaram diferenças",
                                    "Ignorar saturação de atuadores"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Calcular métricas de desempenho temporal",
                                  "subSteps": [
                                    "Simule respostas ao degrau e extraia tempo de assentamento (Ts: tempo para |e(t)| < 2% do setpoint).",
                                    "Calcule overshoot percentual (Mp = (ymax - ysetpoint)/ysetpoint * 100%).",
                                    "Determine tempo de subida (Tr: 10% a 90% do setpoint) e erro em regime permanente.",
                                    "Repita para ambos controladores e tabule os valores.",
                                    "Gere gráficos de resposta temporal com anotações das métricas."
                                  ],
                                  "verification": "Tabela com Ts, Mp, Tr e erro permanente preenchida para ambos controladores; gráficos anotados.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "MATLAB stepinfo() ou stepresponse()",
                                    "Função customizada para overshoot",
                                    "Ferramentas de plot (plot, grid, legend)"
                                  ],
                                  "tips": "Use stepinfo() automático no MATLAB para precisão; normalize entradas para comparação justa.",
                                  "learningObjective": "Dominar cálculo e interpretação de métricas temporais em respostas de sistemas controlados.",
                                  "commonMistakes": [
                                    "Definir assentamento com tolerância errada (use 2% ou 5%)",
                                    "Calcular overshoot em respostas não oscilatórias",
                                    "Ignorar ruído na medição de picos"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular métricas de estabilidade e robustez",
                                  "subSteps": [
                                    "Gere diagramas de Bode para laços abertos e calcule margens de ganho (GM) e fase (PM).",
                                    "Calcule a norma H∞ do sistema fechado usando hinfnorm() ou métodos numéricos.",
                                    "Avalie picos de sensibilidade (||S||∞ e ||T||∞) para robustez.",
                                    "Compare valores com benchmarks (ex: PM > 45°, GM > 6dB).",
                                    "Documente em tabela e plote Nyquist se aplicável."
                                  ],
                                  "verification": "Valores de GM, PM e ||G||∞ computados e tabulados; diagramas de Bode com margens marcadas.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "MATLAB Control System Toolbox (bode(), margin(), hinfnorm())",
                                    "Scripts para análise de robustez"
                                  ],
                                  "tips": "Ajuste frequências de interesse; use robustcontrol toolbox para H∞ avançado.",
                                  "learningObjective": "Aplicar análise em frequência para quantificar estabilidade e robustez.",
                                  "commonMistakes": [
                                    "Confundir margens de laço aberto vs fechado",
                                    "Usar aproximações analíticas sem validação numérica",
                                    "Ignorar cruzamentos múltiplos em Bode"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Comparar resultados e interpretar",
                                  "subSteps": [
                                    "Compile tabela comparativa: métricas temporais, estabilidade e H∞ para ambos controladores.",
                                    "Calcule melhorias percentuais (ex: Ts_otimizado / Ts_ZN * 100%).",
                                    "Analise trade-offs (ex: menor overshoot vs menor PM).",
                                    "Conclua superioridade do otimizado com evidências quantitativas.",
                                    "Gere relatório com gráficos e recomendações."
                                  ],
                                  "verification": "Relatório com tabela comparativa, gráficos e conclusões claras gerado.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Excel ou MATLAB table para comparação",
                                    "LaTeX/Markdown para relatório"
                                  ],
                                  "tips": "Use métricas compostas como ITAE para ranking global; discuta limitações.",
                                  "learningObjective": "Interpretar e comunicar resultados de comparação de controladores.",
                                  "commonMistakes": [
                                    "Viés na interpretação sem dados quantitativos",
                                    "Generalizar de um exemplo sem sensibilidade",
                                    "Omitir contexto do sistema específico"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um sistema de controle de posição de motor DC (G(s) = 1/(s(s+1))), compare um PID tunado por Ziegler-Nichols (Kp=2.4, Ti=0.5, Td=0.125) com um controlador H∞ otimizado. Simule degrau de 1 rad, calcule Ts=1.2s e Mp=8% para H∞ vs Ts=2.5s e Mp=25% para ZN; GM=10dB e ||H∞||=1.5 vs GM=5dB e ||H∞||=3.2.",
                              "finalVerifications": [
                                "Tabela comparativa completa com todas métricas calculadas corretamente.",
                                "Gráficos de resposta temporal e Bode com anotações precisas.",
                                "Conclusão quantitativa mostrando vantagens do controlador otimizado.",
                                "Valores de H∞ abaixo de benchmarks para robustez.",
                                "Ausência de erros numéricos nas simulações (ver logs).",
                                "Relatório interpretativo sem contradições."
                              ],
                              "assessmentCriteria": [
                                "Precisão dos cálculos métricos (±5% de métodos padrão).",
                                "Qualidade dos gráficos e tabelas (legíveis, anotados).",
                                "Profundidade da interpretação e trade-offs discutidos.",
                                "Correta aplicação de ferramentas (ex: stepinfo, hinfnorm).",
                                "Evidências quantitativas na comparação.",
                                "Clareza e estrutura do relatório final."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Análise numérica e otimização (normas, integrais).",
                                "Programação: Scripts MATLAB para automação de simulações.",
                                "Física: Dinâmica de sistemas mecânicos/elétricos.",
                                "Estatística: Análise de sensibilidade e incertezas.",
                                "Gestão de Projetos: Documentação de resultados técnicos."
                              ],
                              "realWorldApplication": "Na indústria automotiva, avaliar controladores de suspensão ativa: otimizado H∞ reduz overshoot em 20% vs PID clássico, melhorando conforto e estabilidade em estradas reais, evitando oscilações perigosas."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.6.5.3.2",
                            "name": "Analisar robustez via gráficos e simulações",
                            "description": "Gerar diagramas de Bode robustos, curvas de Nyquist e simulações com incertezas para interpretar vantagens da otimização paramétrica sobre técnicas clássicas.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar o modelo do sistema com incertezas paramétricas",
                                  "subSteps": [
                                    "Identifique as funções de transferência do sistema LIT escalar nominal.",
                                    "Defina faixas de incerteza para parâmetros chave (ex: ganho, constantes de tempo).",
                                    "Modele incertezas usando funções de transferência multiplicativas ou aditivas.",
                                    "Implemente o modelo no software (MATLAB/Simulink).",
                                    "Valide o modelo nominal contra dados conhecidos."
                                  ],
                                  "verification": "Modelo simulado reproduz resposta nominal esperada sem erros.",
                                  "estimatedTime": "1-2 horas",
                                  "materials": [
                                    "MATLAB ou Octave",
                                    "Documentação do sistema LIT",
                                    "Tutoriais de Uncertain Systems no MATLAB"
                                  ],
                                  "tips": [
                                    "Use 'ureal' para parâmetros incertos no MATLAB para simplicidade.",
                                    "Comece com incertezas pequenas (10-20%) para testes iniciais."
                                  ],
                                  "learningObjective": "Compreender e modelar incertezas paramétricas em sistemas de controle.",
                                  "commonMistakes": [
                                    "Ignorar normalização de incertezas.",
                                    "Confundir incertezas aditivas com multiplicativas.",
                                    "Não validar o modelo nominal primeiro."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Gerar e analisar diagramas de Bode robustos",
                                  "subSteps": [
                                    "Projete controladores paramétricos e clássicos (ex: PID).",
                                    "Gere diagramas de Bode para conjunto de plantas incertas usando 'bodeplot'.",
                                    "Analise margens de ganho e fase no pior caso.",
                                    "Compare estabilidade robusta entre otimizado e clássico.",
                                    "Documente insights sobre largura de banda e rejeição de distúrbios."
                                  ],
                                  "verification": "Diagramas mostram margens robustas >6dB ganho e >45° fase.",
                                  "estimatedTime": "2-3 horas",
                                  "materials": [
                                    "MATLAB Robust Control Toolbox",
                                    "Função bodeplot",
                                    "Exemplos de sistemas LIT"
                                  ],
                                  "tips": [
                                    "Use 'robustplot' para visualização clara do conjunto.",
                                    "Foque no pior caso para robustez conservadora."
                                  ],
                                  "learningObjective": "Gerar e interpretar diagramas de Bode para análise de robustez.",
                                  "commonMistakes": [
                                    "Analisar apenas planta nominal.",
                                    "Ignorar picos de ressonância em incertezas.",
                                    "Não plotar loops abertos e fechados."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Gerar e analisar curvas de Nyquist robustas",
                                  "subSteps": [
                                    "Configure o loop aberto com incertezas.",
                                    "Plote curvas de Nyquist para conjunto incerto usando 'nyquistplot'.",
                                    "Verifique critério de Nyquist para estabilidade robusta.",
                                    "Meça distâncias ao ponto crítico (-1,0).",
                                    "Compare raios de disco de incerteza entre métodos."
                                  ],
                                  "verification": "Curvas não encapsulam ponto crítico no pior caso.",
                                  "estimatedTime": "1-2 horas",
                                  "materials": [
                                    "MATLAB Robust Control Toolbox",
                                    "nyquistplot com usample para amostragem"
                                  ],
                                  "tips": [
                                    "Aumente número de amostras para contorno preciso.",
                                    "Use zoom para analisar proximidade ao ponto crítico."
                                  ],
                                  "learningObjective": "Aplicar curvas de Nyquist para validar estabilidade robusta.",
                                  "commonMistakes": [
                                    "Plotar apenas nominal.",
                                    "Confundir direção de contorno.",
                                    "Não considerar frequência infinita."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Executar simulações com incertezas e comparar resultados",
                                  "subSteps": [
                                    "Configure simulações de resposta ao degrau com variações paramétricas.",
                                    "Rode Monte Carlo ou usimulate para 100+ cenários.",
                                    "Gere histogramas de overshoot, tempo de estabilização e erro steady-state.",
                                    "Compare métricas estatísticas: otimização paramétrica vs. clássico.",
                                    "Interprete vantagens (ex: menor variância em desempenho)."
                                  ],
                                  "verification": "Simulações mostram desempenho robusto superior (ex: overshoot <20% em 95% casos).",
                                  "estimatedTime": "2-3 horas",
                                  "materials": [
                                    "Simulink",
                                    "usimulate ou loop Monte Carlo",
                                    "Scripts de análise estatística"
                                  ],
                                  "tips": [
                                    "Use paralelização para simulações rápidas.",
                                    "Foquem em métricas normalizadas para comparação justa."
                                  ],
                                  "learningObjective": "Realizar simulações robustas e extrair conclusões quantitativas.",
                                  "commonMistakes": [
                                    "Poucas amostras (use >100).",
                                    "Não incluir ruído realista.",
                                    "Ignorar distribuições não uniformes."
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Interpretar vantagens da otimização paramétrica sobre técnicas clássicas",
                                  "subSteps": [
                                    "Sintetize resultados de Bode, Nyquist e simulações em tabela comparativa.",
                                    "Quantifique melhorias (ex: +30% margem robusta).",
                                    "Discuta trade-offs (complexidade vs. performance).",
                                    "Relacione com teoria de robustez (H-infinito aproximado).",
                                    "Prepare relatório com gráficos e conclusões."
                                  ],
                                  "verification": "Relatório destaca pelo menos 3 vantagens claras com evidências.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Excel ou MATLAB para tabelas",
                                    "Templates de relatório"
                                  ],
                                  "tips": [
                                    "Use métricas normalizadas para imparcialidade.",
                                    "Inclua limitações das simulações."
                                  ],
                                  "learningObjective": "Sintetizar análises para defender superioridade de métodos avançados.",
                                  "commonMistakes": [
                                    "Viés para um método sem dados.",
                                    "Omitir contexto teórico.",
                                    "Relatório sem visualizações."
                                  ]
                                }
                              ],
                              "practicalExample": "Em um sistema de controle de posição de motor DC com incertezas de 20% no ganho e tempo constante, gere diagramas de Bode mostrando margens robustas de 8dB (otimização paramétrica) vs. 4dB (PID clássico), Nyquist sem encirclement no pior caso, e simulações Monte Carlo com overshoot médio de 12% vs. 25%.",
                              "finalVerifications": [
                                "Diagramas de Bode e Nyquist gerados corretamente para conjunto incerto.",
                                "Simulações executadas com pelo menos 100 cenários variando parâmetros.",
                                "Margens robustas quantificadas e comparadas.",
                                "Relatório interpreta vantagens com evidências gráficas.",
                                "Erros de modelagem corrigidos e validados.",
                                "Métricas de desempenho estatísticas calculadas."
                              ],
                              "assessmentCriteria": [
                                "Precisão na modelagem de incertezas (sem erros de sintaxe).",
                                "Correta geração e interpretação de gráficos robustos.",
                                "Análise quantitativa comparativa profunda.",
                                "Clareza na documentação e relatórios.",
                                "Identificação de trade-offs realistas.",
                                "Eficiência no uso de ferramentas (tempo dentro do estimado)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Análise de funções complexas e teoria de estabilidade.",
                                "Programação: Scripts MATLAB para automação e análise estatística.",
                                "Física: Modelagem dinâmica de sistemas reais com ruído.",
                                "Estatística: Análise Monte Carlo e intervalos de confiança."
                              ],
                              "realWorldApplication": "Em indústrias como aeroespacial (controle de flaps com variações de massa) ou automotiva (controle de suspensão com incertezas de carga), onde otimização paramétrica garante estabilidade apesar de variações de fabricação, reduzindo falhas e custos de recalibração."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.6.5.3.3",
                            "name": "Documentar e interpretar resultados práticos",
                            "description": "Elaborar relatórios com tabelas comparativas, destacando limitações e recomendações para transição a sistemas multivariáveis, referenciando bibliografia como Skogestad e Zhou.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Coletar e Organizar Dados dos Resultados Práticos",
                                  "subSteps": [
                                    "Reúna todos os dados de simulações ou experimentos reais de controladores monovariáveis (ex.: PID, LQR).",
                                    "Classifique os dados por métricas chave: tempo de estabilização, overshoot, erro estacionário e robustez.",
                                    "Crie um banco de dados preliminar em planilha ou software (Excel/MATLAB) com colunas para cada cenário testado.",
                                    "Identifique outliers ou dados inconsistentes e decida sobre exclusão ou tratamento.",
                                    "Documente fontes e condições experimentais para cada conjunto de dados."
                                  ],
                                  "verification": "Verifique se o banco de dados está completo, com pelo menos 5-10 conjuntos de resultados comparáveis e sem lacunas evidentes.",
                                  "estimatedTime": "1-2 horas",
                                  "materials": "Planilhas (Excel/Google Sheets), software de simulação (MATLAB/Simulink), notas de experimentos anteriores.",
                                  "tips": "Use formatação condicional nas planilhas para destacar valores extremos rapidamente.",
                                  "learningObjective": "Dominar a organização sistemática de dados experimentais para análise comparativa.",
                                  "commonMistakes": "Ignorar unidades de medida ou condições iniciais diferentes entre testes."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Construir Tabelas Comparativas",
                                  "subSteps": [
                                    "Selecione métricas principais para comparação: desempenho transitório, estacionário e robustez.",
                                    "Crie tabelas com linhas para diferentes controladores (PID, Pole Placement, etc.) e colunas para métricas.",
                                    "Inclua colunas para cenários nominais e perturbados (ex.: +20% ganho de planta).",
                                    "Adicione estatísticas descritivas como média, desvio padrão e intervalos de confiança.",
                                    "Formate tabelas com legibilidade: negrito em destaques, cores para bom/ruim."
                                  ],
                                  "verification": "Confirme que todas as tabelas têm legendas claras, unidades consistentes e pelo menos 3 controladores comparados.",
                                  "estimatedTime": "1 hora",
                                  "materials": "Software de edição (LaTeX, Word, MATLAB publish), planilhas para protótipos.",
                                  "tips": "Use ferramentas como MATLAB's table() para exportar diretamente para LaTeX.",
                                  "learningObjective": "Aprender a visualizar dados multivariados de forma comparativa e intuitiva.",
                                  "commonMistakes": "Sobrecarregar tabelas com dados irrelevantes, reduzindo clareza."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Interpretar Resultados e Destacar Limitações",
                                  "subSteps": [
                                    "Analise tendências nas tabelas: identifique o melhor controlador por métrica.",
                                    "Discuta limitações monovariáveis: ignorar acoplamentos, sensibilidade a não-linearidades.",
                                    "Compare com teoria: valide se resultados atendem especificações de Skogestad (cap. 3-4).",
                                    "Quantifique limitações com métricas como índice de robustez ou simulações de Monte Carlo.",
                                    "Escreva parágrafos interpretativos com referências visuais às tabelas."
                                  ],
                                  "verification": "Revise se a seção inclui pelo menos 3 limitações específicas e citações bibliográficas iniciais.",
                                  "estimatedTime": "2 horas",
                                  "materials": "Livros: Skogestad & Postlethwaite 'Multivariable Feedback Control'; Zhou et al. 'Robust and Optimal Control'; software de análise estatística.",
                                  "tips": "Use gráficos auxiliares (Bode, step response) para apoiar interpretações textuais.",
                                  "learningObjective": "Desenvolver habilidade crítica para identificar e articular fraquezas em modelos monovariáveis.",
                                  "commonMistakes": "Atribuir causalidade sem evidência estatística ou ignorar viés de seleção."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Formular Recomendações para Transição Multivariável",
                                  "subSteps": [
                                    "Baseado em limitações, sugira controladores MIMO (ex.: MPC de Skogestad cap. 9).",
                                    "Liste passos concretos: modelagem de acoplamentos, síntese LTI multivariable (Zhou cap. 10).",
                                    "Priorize recomendações por impacto: alta para sistemas com forte acoplamento.",
                                    "Inclua cronograma estimado e requisitos computacionais.",
                                    "Integre ao relatório com seção dedicada e referências cruzadas."
                                  ],
                                  "verification": "Verifique se recomendações são acionáveis, com pelo menos 3 opções e ligações bibliográficas.",
                                  "estimatedTime": "1 hora",
                                  "materials": "Bibliografia: Skogestad (cap. 7-9), Zhou (cap. 11-12); templates de relatório.",
                                  "tips": "Estruture recomendações em bullet points numerados para fácil seguimento.",
                                  "learningObjective": "Conectar análise monovariável a designs avançados multivariable.",
                                  "commonMistakes": "Fazer recomendações genéricas sem base nos resultados específicos."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Finalizar Relatório com Referências e Formatação",
                                  "subSteps": [
                                    "Compile todas as seções em um documento coeso com sumário e abstract.",
                                    "Adicione lista de referências completa (APA/IEEE) incluindo Skogestad e Zhou.",
                                    "Revise por consistência: numeração de tabelas/figuras, linguagem técnica precisa.",
                                    "Inclua apêndices com dados brutos ou códigos de simulação.",
                                    "Faça proofread para gramática e clareza."
                                  ],
                                  "verification": "Relatório final tem estrutura completa, referências citadas corretamente e exportado em PDF.",
                                  "estimatedTime": "1 hora",
                                  "materials": "Editor LaTeX/Word, gerenciador de referências (Zotero/Mendeley), PDF viewer.",
                                  "tips": "Use Overleaf para LaTeX colaborativo e templates IEEE para engenharia.",
                                  "learningObjective": "Mestrar redação técnica profissional em relatórios de engenharia.",
                                  "commonMistakes": "Esquecer citações in-text ou usar abreviações não definidas."
                                }
                              ],
                              "practicalExample": "Em um sistema LIT escalar de tanque de nível (modelo G(s)=1/(10s+1)), compare PID, Pole Placement e LQR em cenários nominais e com perturbação de ganho +25%. Crie tabela mostrando overshoot PID=15% vs LQR=5%, destaque limitação de PID em rejeição de distúrbios, recomende transição para MPC multivariable citando Skogestad p. 289.",
                              "finalVerifications": [
                                "Relatório contém pelo menos 2 tabelas comparativas com métricas padronizadas.",
                                "Limitações monovariáveis são explicitamente listadas (mínimo 3).",
                                "Recomendações incluem pelo menos 2 estratégias multivariable com referências.",
                                "Bibliografia cita Skogestad e Zhou com páginas específicas.",
                                "Documento é formatado profissionalmente com sumário e apêndices.",
                                "Interpretação liga resultados a teoria de controle avançado."
                              ],
                              "assessmentCriteria": [
                                "Clareza e precisão das tabelas comparativas (30%).",
                                "Profundidade na interpretação de limitações (25%).",
                                "Relevância e acionabilidade das recomendações (20%).",
                                "Correção das referências bibliográficas (15%).",
                                "Qualidade geral de redação e formatação (10%)."
                              ],
                              "crossCurricularConnections": [
                                "Estatística: Cálculo de desvios e confiança nos dados.",
                                "Comunicação Técnica: Redação de relatórios científicos.",
                                "Programação: Scripts MATLAB para automação de tabelas.",
                                "Ética em Engenharia: Transparência em limitações e recomendações."
                              ],
                              "realWorldApplication": "Na indústria petroquímica, engenheiros usam relatórios assim para justificar upgrades de controladores monovariáveis em plantas de destilação para MIMO, reduzindo downtime em 20% como em casos da Skogestad em refinarias norueguesas."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      }
                    ]
                  }
                ]
              },
              {
                "id": "10.1.7",
                "name": "Introdução aos Sistemas Multivariáveis",
                "description": "Visão introdutória aos conceitos e desafios do controle em sistemas multivariáveis.",
                "totalSkills": 43,
                "atomicTopics": [
                  {
                    "id": "10.1.7.1",
                    "name": "Definição de Sistemas Multivariáveis",
                    "description": "Conceito de sistemas com múltiplas entradas e múltiplas saídas (MIMO), contrastando com sistemas monovariáveis (SISO).",
                    "individualConcepts": [
                      {
                        "id": "76.1.1.1",
                        "name": "Sistemas Monovariáveis (SISO)",
                        "description": "Revisão do conceito de sistemas com uma única entrada e uma única saída (Single Input Single Output), base para contrastar com sistemas multivariáveis.",
                        "specificSkills": [
                          {
                            "id": "76.1.1.1.1",
                            "name": "Definir sistema SISO",
                            "description": "Explicar que um sistema SISO possui uma única entrada u(t) e uma única saída y(t), representado por funções de transferência escalares G(s), com análise clássica via diagramas de Bode e Nyquist.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender conceitos básicos de entradas e saídas em sistemas dinâmicos",
                                  "subSteps": [
                                    "Identificar o que é uma entrada u(t) em um sistema de controle.",
                                    "Explicar o papel da saída y(t) como resposta do sistema à entrada.",
                                    "Diferenciar sistemas com múltiplas entradas/saídas de sistemas simples.",
                                    "Reconhecer exemplos cotidianos de entradas e saídas únicas.",
                                    "Estudar a notação temporal contínua u(t) e y(t)."
                                  ],
                                  "verification": "Resumir em uma frase o que são entrada e saída, com um exemplo pessoal.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Video introdutório sobre sistemas de controle (YouTube ou Khan Academy)",
                                    "Papel e caneta para anotações"
                                  ],
                                  "tips": "Use analogias como 'entrada é o acelerador do carro, saída é a velocidade'.",
                                  "learningObjective": "Entender os fundamentos de entradas e saídas em sistemas dinâmicos.",
                                  "commonMistakes": [
                                    "Confundir entrada com saída",
                                    "Ignorar a dependência temporal u(t)"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Definir formalmente um sistema SISO",
                                  "subSteps": [
                                    "Definir SISO como Single Input Single Output (uma única entrada e uma única saída).",
                                    "Explicar que SISO é monovariável, contrastando com MIMO.",
                                    "Escrever a definição: 'Sistema com u(t) entrada única e y(t) saída única'.",
                                    "Discutir características como escalaridade das variáveis.",
                                    "Criar um diagrama simples de bloco SISO."
                                  ],
                                  "verification": "Escrever a definição completa de SISO e desenhar um diagrama de bloco básico.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Software de desenho (Draw.io ou papel)",
                                    "Slides ou PDF sobre classificação de sistemas"
                                  ],
                                  "tips": "Memorize o acrônimo: SISO = Single Input, Single Output.",
                                  "learningObjective": "Capacitar-se a definir precisamente um sistema SISO.",
                                  "commonMistakes": [
                                    "Confundir SISO com sistemas multivariáveis",
                                    "Omitir 'única' na definição"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Representar sistemas SISO por funções de transferência G(s)",
                                  "subSteps": [
                                    "Introduzir a transformada de Laplace para domínio s.",
                                    "Definir G(s) = Y(s)/U(s) como função de transferência escalar.",
                                    "Explicar que G(s) é válida para sistemas lineares invariantes no tempo (LTI).",
                                    "Calcular G(s) para um exemplo simples como integrador.",
                                    "Interpretar polos e zeros em G(s)."
                                  ],
                                  "verification": "Derivar G(s) para um sistema RC simples e plotar resposta.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "MATLAB ou Python (SymPy) para Laplace",
                                    "Tabela de transformadas de Laplace"
                                  ],
                                  "tips": "Sempre verifique unidades: G(s) tem unidades de saída/entrada.",
                                  "learningObjective": "Dominar a representação em domínio de frequência via G(s).",
                                  "commonMistakes": [
                                    "Esquecer condições LTI",
                                    "Confundir G(s) com equação diferencial"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Explorar análise clássica via diagramas de Bode e Nyquist",
                                  "subSteps": [
                                    "Descrever diagrama de Bode: magnitude e fase vs. frequência log.",
                                    "Explicar diagrama de Nyquist: traçado polar de G(jω).",
                                    "Entender uso para estabilidade e desempenho (ganho, fase).",
                                    "Gerar Bode/Nyquist para um G(s) exemplo usando software.",
                                    "Interpretar margens de ganho e fase."
                                  ],
                                  "verification": "Gerar e interpretar diagramas para G(s) = 1/(s+1).",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "MATLAB Control System Toolbox ou Octave",
                                    "Exemplos de G(s) prontos"
                                  ],
                                  "tips": "Comece com frequências decádicas para Bode.",
                                  "learningObjective": "Aplicar ferramentas clássicas de análise em SISO.",
                                  "commonMistakes": [
                                    "Ignorar direção no Nyquist",
                                    "Confundir magnitude com fase"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um controlador de temperatura de um forno: entrada u(t) é o sinal de aquecimento (volts), saída y(t) é a temperatura (°C). Representado por G(s) = K/(τs + 1), analisado via Bode para ajuste de PID.",
                              "finalVerifications": [
                                "Definir SISO com entrada u(t) e saída y(t) únicas.",
                                "Escrever G(s) = Y(s)/U(s) corretamente.",
                                "Desenhar diagrama de bloco SISO.",
                                "Gerar diagrama de Bode para exemplo simples.",
                                "Explicar diferença entre análise Bode e Nyquist.",
                                "Identificar aplicação real de SISO."
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição de SISO (100% match com conceitos chave).",
                                "Correta derivação de G(s) para sistema dado.",
                                "Interpretação adequada de diagramas Bode/Nyquist.",
                                "Uso correto de terminologia (LTI, monovariável).",
                                "Criatividade em exemplos práticos.",
                                "Clareza em diagramas e explicações."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Transformada de Laplace e funções complexas.",
                                "Física: Dinâmica de sistemas lineares e equações diferenciais.",
                                "Informática: Simulação em MATLAB/Python para análise.",
                                "Engenharia Elétrica: Circuitos RC/RL como exemplos SISO."
                              ],
                              "realWorldApplication": "Controle de velocidade de um motor DC em drones: entrada u(t) é tensão aplicada, saída y(t) é velocidade angular, usando G(s) para sintonizar controlador e garantir estabilidade via Bode."
                            },
                            "estimatedTime": "0.25 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "76.1.1.1.2",
                            "name": "Identificar características de SISO",
                            "description": "Descrever propriedades como estabilidade, desempenho transitório e em regime permanente, usando critérios como ganho de fase e margem de estabilidade em projetos clássicos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Fundamentos de Sistemas SISO",
                                  "subSteps": [
                                    "Defina SISO como sistema com uma entrada única e uma saída única.",
                                    "Desenhe um diagrama de blocos básico de um sistema SISO em laço fechado.",
                                    "Identifique componentes chave: planta, controlador, sensor e atuador.",
                                    "Explique a função de realimentação em SISO.",
                                    "Liste funções de transferência típicas para plantas comuns (ex: integrador, oscilador)."
                                  ],
                                  "verification": "Desenhe corretamente um diagrama de blocos SISO e explique verbalmente sua função.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Papel e lápis, software de diagramação como Draw.io ou MATLAB Simulink.",
                                  "tips": "Use setas claras para entradas, saídas e realimentações no diagrama.",
                                  "learningObjective": "Compreender a estrutura básica e representação matemática de sistemas SISO.",
                                  "commonMistakes": "Confundir SISO com MIMO; ignorar a realimentação no diagrama."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar Estabilidade Usando Critérios Clássicos",
                                  "subSteps": [
                                    "Calcule a função de transferência em malha fechada.",
                                    "Gere diagramas de Bode para ganho e fase.",
                                    "Identifique a frequência de cruzamento de ganho e fase.",
                                    "Meça margem de ganho (distância em dB da magnitude 0dB à linha de fase -180°).",
                                    "Meça margem de fase (distância da fase -180° à linha de magnitude 0dB).",
                                    "Classifique o sistema como estável se margens > 6dB e 45°."
                                  ],
                                  "verification": "Plote diagramas de Bode e anote valores corretos de margens de estabilidade.",
                                  "estimatedTime": "40 minutos",
                                  "materials": "MATLAB ou Python (control library), calculadora científica.",
                                  "tips": "Use log-log para Bode; verifique unidades em dB e graus.",
                                  "learningObjective": "Aplicar critérios de Nyquist/Bode para determinar estabilidade.",
                                  "commonMistakes": "Confundir margem de ganho com margem de fase; ignorar frequência de ganho unitário."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Avaliar Desempenho Transitório",
                                  "subSteps": [
                                    "Simule resposta ao degrau unitário da função de transferência.",
                                    "Meça tempo de subida (10-90%), tempo de estabilização e sobressinal (%).",
                                    "Analise picos e oscilações na resposta temporal.",
                                    "Compare com especificações desejadas (ex: sobressinal < 10%).",
                                    "Ajuste parâmetros do controlador para melhorar transitório."
                                  ],
                                  "verification": "Gere gráfico de resposta ao degrau com métricas anotadas corretamente.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "MATLAB (step response), Python (matplotlib e control).",
                                  "tips": "Escolha escala de tempo adequada para capturar transitórios rápidos.",
                                  "learningObjective": "Quantificar e interpretar dinâmica transitória em SISO.",
                                  "commonMistakes": "Usar degrau não unitário; medir sobressinal incorretamente."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Avaliar Desempenho em Regime Permanente",
                                  "subSteps": [
                                    "Calcule erro em regime permanente para entradas degrau, rampa e parabólica.",
                                    "Use teorema do valor final: lim s->0 s E(s).",
                                    "Classifique tipo do sistema (0,1,2) pelo número de integradores.",
                                    "Verifique ganho de estado estacionário Kv, Ka.",
                                    "Compare com requisitos de precisão (ex: erro < 5% para degrau)."
                                  ],
                                  "verification": "Tabela com erros calculados para diferentes entradas, matching simulação.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Folha de cálculos, MATLAB para teorema do valor final.",
                                  "tips": "Lembre: erro zero para degrau em sistemas tipo 1+.",
                                  "learningObjective": "Determinar precisão em steady-state usando análise clássica.",
                                  "commonMistakes": "Confundir tipo do sistema; erro no limite do teorema."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Integrar Características em Projeto Clássico",
                                  "subSteps": [
                                    "Selecione um sistema SISO exemplo (ex: servo motor).",
                                    "Combine análises: estabilidade, transitório e permanente.",
                                    "Proponha tuning de PID baseado em margens e specs.",
                                    "Valide com simulação completa.",
                                    "Documente trade-offs (ex: estabilidade vs. velocidade)."
                                  ],
                                  "verification": "Relatório resumido com gráficos e conclusões integradas.",
                                  "estimatedTime": "35 minutos",
                                  "materials": "MATLAB PID Tuner, template de relatório.",
                                  "tips": "Priorize specs: estabilidade primeiro, depois desempenho.",
                                  "learningObjective": "Sintetizar características para design de controladores SISO.",
                                  "commonMistakes": "Ignorar trade-offs entre specs; over-tuning levando a instabilidade."
                                }
                              ],
                              "practicalExample": "Em um sistema de controle de velocidade de um motor DC SISO, plote Bode da planta 1/(s(Js+B)), meça margens (fase 60°, ganho 10dB), simule resposta ao degrau (sobressinal 5%, Ts=2s), erro steady-state 2% para referência constante.",
                              "finalVerifications": [
                                "Diagramas de Bode corretos com margens anotadas.",
                                "Resposta transitória com métricas precisas.",
                                "Cálculos de erro permanente validados por simulação.",
                                "Classificação completa de estabilidade e desempenho.",
                                "Relatório integrando todas as características.",
                                "Identificação de trade-offs em projeto."
                              ],
                              "assessmentCriteria": [
                                "Precisão nos cálculos de margens (>95% correto).",
                                "Qualidade dos gráficos e simulações (legíveis, anotados).",
                                "Completude da análise (todas características cobertas).",
                                "Correta interpretação de resultados e trade-offs.",
                                "Clareza na documentação e explicações.",
                                "Aplicação prática em exemplo realista."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Transformada de Laplace e análise em frequência.",
                                "Física: Dinâmica de sistemas mecânicos/elétricos.",
                                "Programação: Simulações em MATLAB/Python para controle.",
                                "Engenharia de Software: Modelagem e validação de sistemas."
                              ],
                              "realWorldApplication": "Projeto de controladores PID em drones para estabilização de atitude, onde margens garantem robustez a ventos, transitório rápido para manobras e erro mínimo em hover."
                            },
                            "estimatedTime": "0.25 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "76.1.1.1.3",
                            "name": "Fornecer exemplo de SISO",
                            "description": "Apresentar um exemplo prático, como controle de velocidade de um motor DC, modelado por G(s) = K/(s(τs+1)), e discutir técnicas de sintonia de PID.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Introduzir o conceito de sistema SISO e descrever o exemplo do motor DC",
                                  "subSteps": [
                                    "Definir SISO como sistema com uma única entrada e uma única saída, contrastando com MIMO.",
                                    "Descrever o motor DC: componentes principais (armadura, campo magnético, rotor), entrada (tensão de armadura Va), saída (velocidade angular ω).",
                                    "Explicar o objetivo de controle: regular ω para seguir uma referência apesar de distúrbios como carga.",
                                    "Desenhar diagrama esquemático do motor e diagrama de blocos básico (entrada Va → planta → ω).",
                                    "Discutir simplificações: assumir linearidade em torno de um ponto de operação estacionário."
                                  ],
                                  "verification": "Aluno explica verbalmente o sistema e apresenta diagrama de blocos rotulado corretamente.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Papel e lápis",
                                    "Imagens de motor DC (buscar online)",
                                    "Notas de aula sobre sistemas de controle"
                                  ],
                                  "tips": "Use analogia com um carro: acelerador (entrada) controla velocidade (saída), ignorando inicialmente mudanças de marcha.",
                                  "learningObjective": "Compreender a estrutura fundamental de um sistema SISO através de um exemplo físico concreto.",
                                  "commonMistakes": [
                                    "Confundir entrada/saída (ex: torque como saída)",
                                    "Ignorar que SISO é monovariável por definição"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Derivar o modelo de transferência G(s) do motor DC",
                                  "subSteps": [
                                    "Recordar equações físicas: tensão Va = Ra Ia + Kb ω; torque T = Kt Ia = J dω/dt + B ω.",
                                    "Combinar equações para obter equação diferencial de segunda ordem.",
                                    "Linearizar em torno de ponto de operação (ω0, Ia0).",
                                    "Aplicar transformada de Laplace: obter G(s) = ω(s)/Va(s) = K / (s (τ s + 1)), identificando K = Kt/(Ra B + Kt Kb) e τ = J/B.",
                                    "Verificar unidades e constantes típicas (ex: K ≈ 1000 rpm/V, τ ≈ 0.1 s)."
                                  ],
                                  "verification": "Aluno deriva e escreve G(s) corretamente, explicando origens de K e τ.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Folha com equações do motor DC",
                                    "Calculadora",
                                    "Software simbólico como SymPy (opcional)"
                                  ],
                                  "tips": "Comece pelas equações DC motor padrão de um textbook para validar.",
                                  "learningObjective": "Modelar dinamicamente um sistema físico no domínio de Laplace.",
                                  "commonMistakes": [
                                    "Esquecer o integrador 1/s do torque para velocidade",
                                    "Confundir constantes Kt e Kb"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Introduzir controlador PID e discutir técnicas de sintonia",
                                  "subSteps": [
                                    "Explicar estrutura PID: u(t) = Kp e(t) + Ki ∫e(t)dt + Kd de(t)/dt, onde e = referência - ω.",
                                    "Desenhar diagrama de laço fechado: referência → PID → G(s) → ω.",
                                    "Aplicar método de sintonia Ziegler-Nichols: encontrar Ku (ganho ultimate), Tu (período oscilação), calcular Kp=0.6Ku, etc.",
                                    "Para exemplo: assumir Ku=10, Tu=0.5s → Kp=6, Ki=12/Tu≈24, Kd=0.125 Ku Tu≈0.625.",
                                    "Discutir trade-offs: Kp alto → rápido mas oscilante; Ki elimina erro steady-state; Kd reduz overshoot."
                                  ],
                                  "verification": "Aluno apresenta equação PID, parâmetros calculados e diagrama de laço fechado.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Tabela Ziegler-Nichols impressa",
                                    "Papel para cálculos",
                                    "Simulador online básico"
                                  ],
                                  "tips": "Teste sintonia manualmente ajustando um por vez: primeiro Kp, depois Ki, por último Kd.",
                                  "learningObjective": "Projetar um controlador PID básico para estabilizar e regular o sistema SISO.",
                                  "commonMistakes": [
                                    "Usar sintonia para sistemas de segunda ordem sem adaptação",
                                    "Ignorar saturação do atuador"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Simular, analisar e verificar o desempenho do sistema controlado",
                                  "subSteps": [
                                    "Implementar modelo em software: definir G(s), adicionar PID em realimentação.",
                                    "Simular resposta ao degrau (referência de 1000 rpm) e distúrbio (carga súbita).",
                                    "Plotar ω(t), u(t): analisar rise time, overshoot, settling time, erro steady-state.",
                                    "Ajustar parâmetros PID iterativamente para otimizar (ex: overshoot <10%, settling <2s).",
                                    "Comparar com sistema em malha aberta para destacar benefícios do controle."
                                  ],
                                  "verification": "Gráficos de simulação mostram desempenho aceitável (sem instabilidade, erro zero em steady-state).",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "MATLAB/Simulink ou Python (bibliotecas control, matplotlib, scipy)",
                                    "Computador"
                                  ],
                                  "tips": "Use step response plot built-in para validação rápida.",
                                  "learningObjective": "Avaliar numericamente a eficácia do controle PID em um SISO realista.",
                                  "commonMistakes": [
                                    "Escala errada nos eixos dos gráficos",
                                    "Não testar com distúrbios"
                                  ]
                                }
                              ],
                              "practicalExample": "Considere um motor DC em uma impressora 3D: entrada é tensão Va aplicada à armadura para controlar velocidade ω do eixo extrusor. Modelo G(s) = 1500 / (s (0.2 s + 1)). Usando PID com Kp=5, Ki=20, Kd=0.5, o sistema segue referência de 2000 rpm com overshoot <5% apesar de variações de carga filament.",
                              "finalVerifications": [
                                "Descreve corretamente entradas/saídas e diagrama do motor DC SISO.",
                                "Deriva G(s) = K/(s(τs+1)) com equações físicas justificadas.",
                                "Propõe e justifica parâmetros PID via método de sintonia.",
                                "Simula laço fechado com gráficos interpretados (tempos de resposta, estabilidade).",
                                "Compara desempenho controlado vs. não controlado.",
                                "Discute limitações reais (não-linearidades, ruído)."
                              ],
                              "assessmentCriteria": [
                                "Correção do modelo G(s) e derivação (30%)",
                                "Adequação da sintonia PID e justificativa (25%)",
                                "Qualidade da simulação e análise de desempenho (20%)",
                                "Clareza na apresentação e diagramas (15%)",
                                "Compreensão conceitual de SISO vs. controle (10%)"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Transformada de Laplace e análise de sistemas lineares.",
                                "Física: Dinâmica rotacional, eletromagnetismo (leis de Faraday e Lenz).",
                                "Engenharia Elétrica: Modelagem de máquinas elétricas DC.",
                                "Computação: Programação de simulações (Python/MATLAB scripting)."
                              ],
                              "realWorldApplication": "Controle de velocidade de motores DC em robôs industriais, drones (estabilização de hélices), veículos elétricos (controle de tração), sistemas HVAC (ventiladores) e automação fabril (esteiras transportadoras), onde precisão e robustez a distúrbios são críticas."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "76.1.1.2",
                        "name": "Sistemas Multivariáveis (MIMO)",
                        "description": "Definição formal de sistemas com múltiplas entradas e múltiplas saídas (Multiple Input Multiple Output), representados por matrizes de funções de transferência.",
                        "specificSkills": [
                          {
                            "id": "76.1.1.2.1",
                            "name": "Definir sistema MIMO",
                            "description": "Explicar que um sistema MIMO tem m entradas u(t) ∈ ℝ^m e p saídas y(t) ∈ ℝ^p, modelado por G(s) ∈ ℂ^{p×m}, onde cada elemento G_{ij}(s) representa a transferência da i-ésima entrada para a j-ésima saída.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar conceitos básicos de sistemas de controle univariáveis (SISO)",
                                  "subSteps": [
                                    "Recordar a definição de um sistema SISO: uma entrada u(t) e uma saída y(t), modelado por G(s).",
                                    "Identificar limitações do SISO em cenários reais com múltiplas interações.",
                                    "Comparar SISO com MIMO usando diagramas simples de blocos.",
                                    "Listar exemplos cotidianos de sistemas SISO, como um termostato simples.",
                                    "Preparar anotações sobre a transição para multivariáveis."
                                  ],
                                  "verification": "Criar um diagrama comparativo SISO vs MIMO e explicar verbalmente as diferenças.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Acesso a slides ou vídeo introdutório sobre SISO"
                                  ],
                                  "tips": "Use desenhos para visualizar fluxos de sinal; foque em interações cruzadas.",
                                  "learningObjective": "Diferenciar SISO de MIMO e entender a necessidade de sistemas multivariáveis.",
                                  "commonMistakes": [
                                    "Confundir entradas com saídas",
                                    "Ignorar acoplamentos entre variáveis"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Definir entradas e saídas em sistemas MIMO",
                                  "subSteps": [
                                    "Explicar que um sistema MIMO possui m entradas u(t) ∈ ℝ^m.",
                                    "Descrever p saídas y(t) ∈ ℝ^p, destacando dimensões vetoriais.",
                                    "Escrever notação matemática: u(t) = [u1(t), ..., um(t)]^T.",
                                    "Discutir independência e acoplamento entre entradas/saídas.",
                                    "Praticar com exemplos numéricos pequenos (m=2, p=2)."
                                  ],
                                  "verification": "Escrever corretamente as expressões vetoriais para u(t) e y(t) com m=3 e p=2.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Caderno de anotações",
                                    "Calculadora ou software simbólico como SymPy"
                                  ],
                                  "tips": "Sempre use transposta ^T para vetores coluna; visualize como vetores em espaços multidimensionais.",
                                  "learningObjective": "Dominar a notação vetorial para entradas e saídas MIMO.",
                                  "commonMistakes": [
                                    "Esquecer dimensões ℝ^m e ℝ^p",
                                    "Confundir escalares com vetores"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Introduzir a função de transferência matricial G(s)",
                                  "subSteps": [
                                    "Definir G(s) ∈ ℂ^{p×m} como a matriz de funções de transferência.",
                                    "Explicar a relação Y(s) = G(s) U(s) no domínio de Laplace.",
                                    "Construir uma matriz G(s) exemplo 2x2 com elementos simbólicos.",
                                    "Verificar propriedades: G(s) é retangular se p ≠ m.",
                                    "Simular multiplicação matricial simples."
                                  ],
                                  "verification": "Montar e multiplicar G(s) U(s) para um caso 2x2 e obter Y(s).",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Papel quadriculado",
                                    "MATLAB ou Octave para verificação opcional"
                                  ],
                                  "tips": "Lembre-se: linhas de G(s) correspondem a saídas, colunas a entradas.",
                                  "learningObjective": "Entender G(s) como modelo dinâmico multivariável.",
                                  "commonMistakes": [
                                    "Invertar dimensões p×m",
                                    "Usar ℝ em vez de ℂ para G(s)"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Explicar os elementos individuais G_{ij}(s)",
                                  "subSteps": [
                                    "Definir G_{ij}(s) como transferência da j-ésima entrada para i-ésima saída.",
                                    "Destacar acoplamento: G_{ij}(s) ≠ 0 indica interação.",
                                    "Analisar um exemplo: impacto de u_j em y_i.",
                                    "Discutir diagonal vs off-diagonal em sistemas desacoplados.",
                                    "Resumir a definição completa de MIMO."
                                  ],
                                  "verification": "Para uma G(s) 2x2, descrever o que cada G_{ij}(s) representa.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Exemplo impresso de matriz G(s)",
                                    "Marcadores para diagrama"
                                  ],
                                  "tips": "Índice i para saída (linha), j para entrada (coluna); memorize 'da entrada j para saída i'.",
                                  "learningObjective": "Interpretar elementos matriciais como transferências específicas.",
                                  "commonMistakes": [
                                    "Trocar i e j nos índices",
                                    "Ignorar acoplamentos off-diagonal"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um drone quadricóptero, as 4 entradas u(t) ∈ ℝ^4 são as velocidades das hélices, e as 4 saídas y(t) ∈ ℝ^4 são posição x,y,z e yaw. G(s) ∈ ℂ^{4×4} modela como cada hélice afeta todas as saídas, com G_{13}(s) representando o efeito da hélice 3 na posição z.",
                              "finalVerifications": [
                                "Definir verbalmente um sistema MIMO com m=3, p=2.",
                                "Escrever Y(s) = G(s) U(s) corretamente.",
                                "Explicar G_{ij}(s) para i≠j.",
                                "Diferenciar MIMO de SISO com exemplo.",
                                "Montar matriz G(s) simples 2x2.",
                                "Identificar acoplamento em um sistema real."
                              ],
                              "assessmentCriteria": [
                                "Precisão na notação matemática (ℝ^m, ℂ^{p×m}).",
                                "Correta interpretação de elementos G_{ij}(s).",
                                "Uso apropriado de conceitos vetoriais e matriciais.",
                                "Capacidade de relacionar a definição a exemplos práticos.",
                                "Clareza na explicação de acoplamentos.",
                                "Ausência de confusão com SISO."
                              ],
                              "crossCurricularConnections": [
                                "Álgebra Linear: Multiplicação matricial e funções de transferência.",
                                "Análise Matemática: Domínio de Laplace e transformadas.",
                                "Física: Dinâmica de sistemas multicomponentes.",
                                "Programação: Simulação de G(s) em Python/MATLAB.",
                                "Engenharia Mecânica: Modelagem de atuadores múltiplos."
                              ],
                              "realWorldApplication": "Sistemas MIMO são fundamentais no controle de aviões (múltiplos flaps e superfícies para roll, pitch e yaw), processos químicos (múltiplas válvulas afetando temperaturas e pressões) e redes 5G (antenas múltiplas para transmissão de dados)."
                            },
                            "estimatedTime": "0.25 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "76.1.1.1"
                            ]
                          },
                          {
                            "id": "76.1.1.2.2",
                            "name": "Representar MIMO matricalmente",
                            "description": "Descrever a representação em espaço de estados ẋ = Ax + Bu, y = Cx + Du, e a relação com funções de transferência matriciais via transformada de Laplace.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Fundamentos da Representação em Espaço de Estados para Sistemas MIMO",
                                  "subSteps": [
                                    "Defina um sistema MIMO como tendo múltiplas entradas (m) e saídas (p).",
                                    "Recapitule a forma geral: ẋ = Ax + Bu, y = Cx + Du, onde x é vetor de estados (n x 1), u entradas (m x 1), y saídas (p x 1).",
                                    "Identifique dimensões das matrizes: A (n x n), B (n x m), C (p x n), D (p x m).",
                                    "Compare com SISO (m=p=1, D escalar).",
                                    "Esboce um diagrama de blocos conceitual do sistema."
                                  ],
                                  "verification": "Escreva as equações e dimensões corretas para um exemplo MIMO 2x2.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Livro de controle (Ogata ou similar)",
                                    "Folha de papel ou software de desenho (Draw.io)"
                                  ],
                                  "tips": "Sempre anote as dimensões das matrizes para evitar erros de multiplicação.",
                                  "learningObjective": "Compreender a estrutura matricial básica de sistemas MIMO em espaço de estados.",
                                  "commonMistakes": [
                                    "Confundir dimensões de B e C",
                                    "Esquecer que D pode ser não-nulo em MIMO"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Construir Matrizes A, B, C, D a partir de Equações Diferenciais",
                                  "subSteps": [
                                    "Parta de equações diferenciais lineares do sistema físico MIMO.",
                                    "Escolha estados x (minimal realization).",
                                    "Forme matriz A a partir dos coeficientes dos estados derivados.",
                                    "Monte B com coeficientes das entradas u.",
                                    "Defina C e D para mapear estados e entradas para saídas y.",
                                    "Verifique se as dimensões são consistentes (multiplicação matricial válida)."
                                  ],
                                  "verification": "Converta um conjunto dado de EDOs MIMO em matrizes e confira ẋ = Ax + Bu.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Exemplos de EDOs MIMO impressos",
                                    "MATLAB ou Python (NumPy/SciPy) para verificação"
                                  ],
                                  "tips": "Use canonical forms como controllable ou observable para simplificar.",
                                  "learningObjective": "Capacitar a modelagem matricial de sistemas MIMO físicos.",
                                  "commonMistakes": [
                                    "Estados não independentes levando a A singular",
                                    "Ignorar feedthrough D em sistemas rápidos"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Derivar Função de Transferência Matricial via Transformada de Laplace",
                                  "subSteps": [
                                    "Aplique Laplace nas equações: sX(s) = A X(s) + B U(s), Y(s) = C X(s) + D U(s).",
                                    "Resolva para X(s): X(s) = (sI - A)^{-1} B U(s).",
                                    "Substitua em Y(s): Y(s) = [C (sI - A)^{-1} B + D] U(s).",
                                    "Defina G(s) = C (sI - A)^{-1} B + D, a função de transferência matricial (p x m).",
                                    "Expanda G(s) para entradas/saídas individuais G_ij(s).",
                                    "Verifique com caso SISO conhecido."
                                  ],
                                  "verification": "Compute G(s) para o exemplo do step 2 e compare elementos com simulação.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Calculadora simbólica (MATLAB Symbolic ou SymPy)",
                                    "Papel para álgebra matricial"
                                  ],
                                  "tips": "Use identidade matricial (sI - A)^{-1} = adj(sI - A)/det(sI - A) para compreensão.",
                                  "learningObjective": "Estabelecer a ponte entre espaço de estados e domínio de frequência para MIMO.",
                                  "commonMistakes": [
                                    "Esquecer o termo +D",
                                    "Erro na inversa: deve ser (sI - A), não (s - A)"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Validar e Aplicar a Representação em um Exemplo Prático",
                                  "subSteps": [
                                    "Selecione um sistema MIMO real simples (ex: acoplamento de dois motores).",
                                    "Modele em espaço de estados e compute G(s).",
                                    "Simule resposta a degrau em software.",
                                    "Compare resposta temporal com função de transferência.",
                                    "Analise desacoplamento ou interações via elementos off-diagonal.",
                                    "Documente o processo completo."
                                  ],
                                  "verification": "Simulação reproduz equações e G(s) corretamente.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "MATLAB/Simulink ou Python (Control library)",
                                    "Exemplo de sistema MIMO pronto"
                                  ],
                                  "tips": "Comece com sistema de baixa ordem (n=2, m=p=2) para depuração fácil.",
                                  "learningObjective": "Integrar representação MIMO em análise prática.",
                                  "commonMistakes": [
                                    "Normalização incorreta de estados",
                                    "Simulação com sampling inadequado"
                                  ]
                                }
                              ],
                              "practicalExample": "Considere um sistema de dois tanques acoplados: entradas u1 (vazão tanque1), u2 (vazão tanque2); saídas y1 (nível tanque1), y2 (nível tanque2). Equações: dh1/dt = -a1 h1 + b1 u1 + c h2; dh2/dt = c h1 -a2 h2 + b2 u2. Estados x=[h1;h2], A=[-a1, c; c, -a2], B=[b1,0;0,b2], C=I, D=0. G(s)=C(sI-A)^{-1}B.",
                              "finalVerifications": [
                                "Escreve corretamente ẋ=Ax+Bu, y=Cx+Du com dimensões.",
                                "Constrói matrizes A,B,C,D de EDOs MIMO sem erros dimensionais.",
                                "Deriva G(s)=C(sI-A)^{-1}B + D.",
                                "Simula e valida exemplo MIMO 2x2.",
                                "Explica relação espaço de estados vs. frequência.",
                                "Identifica interações via off-diagonais de G(s)."
                              ],
                              "assessmentCriteria": [
                                "Precisão das dimensões e equações matriciais (30%)",
                                "Correção na derivação de G(s) via Laplace (25%)",
                                "Qualidade da modelagem de exemplo físico (20%)",
                                "Validação via simulação numérica (15%)",
                                "Clareza na explicação de conceitos (10%)"
                              ],
                              "crossCurricularConnections": [
                                "Matemática Linear: autovalores de A, decomposição matricial.",
                                "Álgebra: transformada de Laplace multivariável.",
                                "Física: modelagem dinâmica de sistemas acoplados.",
                                "Computação: simulação em MATLAB/Python para controle.",
                                "Engenharia de Software: implementação de solvers numéricos."
                              ],
                              "realWorldApplication": "Em aviões, representa o controle multivariable de flaps e lemes (MIMO) para estabilidade, onde G(s) guia o design de controladores desacopladores em flight control systems."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "76.1.1.1"
                            ]
                          },
                          {
                            "id": "76.1.1.2.3",
                            "name": "Fornecer exemplo de MIMO",
                            "description": "Apresentar exemplo como controle de um processo químico com duas entradas (vazões) e duas saídas (concentrações), destacando acoplamentos entre canais.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os fundamentos de sistemas MIMO",
                                  "subSteps": [
                                    "Defina sistema MIMO como Multiple Input Multiple Output (múltiplas entradas e saídas).",
                                    "Explique a diferença entre SISO (uma entrada, uma saída) e MIMO.",
                                    "Identifique características chave: acoplamentos entre canais e interdependências.",
                                    "Revise representação matricial básica de sistemas MIMO (matriz de transferência).",
                                    "Discuta por que MIMO é essencial em processos industriais complexos."
                                  ],
                                  "verification": "Resuma em 3 frases os conceitos chave de MIMO e cite um exemplo simples.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Livro-texto de Controle Avançado",
                                    "Slides sobre sistemas multivariáveis",
                                    "Caneta e papel para anotações"
                                  ],
                                  "tips": "Use diagramas simples para visualizar entradas e saídas múltiplas.",
                                  "learningObjective": "Entender a definição e importância de sistemas MIMO.",
                                  "commonMistakes": "Confundir MIMO com SISO ou ignorar acoplamentos entre variáveis."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Selecionar e descrever um processo químico como exemplo",
                                  "subSteps": [
                                    "Escolha um processo químico real: misturador de dois reagentes em tanques.",
                                    "Descreva o sistema: dois tanques em série com vazões de entrada controláveis.",
                                    "Identifique entradas: vazão de reagente A (Q1) e vazão de reagente B (Q2).",
                                    "Defina saídas: concentração de A no tanque 1 (C1) e concentração de B no tanque 2 (C2).",
                                    "Explique o contexto industrial: produção de solução química balanceada."
                                  ],
                                  "verification": "Esboce um diagrama esquemático do processo com entradas e saídas rotuladas.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Software de desenho (Draw.io ou papel)",
                                    "Referências sobre processos químicos",
                                    "Vídeo tutorial de tanques em série"
                                  ],
                                  "tips": "Comece com um diagrama de blocos para clareza visual.",
                                  "learningObjective": "Selecionar um exemplo concreto de processo químico MIMO.",
                                  "commonMistakes": "Escolher processo muito simples (SISO) em vez de multivariável."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Identificar e destacar acoplamentos entre canais",
                                  "subSteps": [
                                    "Analise como mudança em Q1 afeta C1 diretamente e C2 indiretamente (acoplamento).",
                                    "Descreva impacto de Q2 em C2 e spillover para C1 via mistura.",
                                    "Modele matematicamente: matriz de transferência G(s) = [[G11(s), G12(s)], [G21(s), G22(s)]].",
                                    "Explique acoplamento: G12 ≠ 0 e G21 ≠ 0 indicam interdependências.",
                                    "Simule cenários: incremente Q1 e observe efeitos em ambas saídas."
                                  ],
                                  "verification": "Construa uma matriz de transferência simplificada e interprete os elementos off-diagonal.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "MATLAB ou Python (SymPy para matrizes)",
                                    "Planilha Excel para simulações numéricas",
                                    "Artigo sobre controle de reatores químicos"
                                  ],
                                  "tips": "Use simulações numéricas para visualizar acoplamentos dinamicamente.",
                                  "learningObjective": "Reconhecer e quantificar acoplamentos em MIMO.",
                                  "commonMistakes": "Assumir independência entre canais, ignorando termos cruzados."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Apresentar o exemplo de forma clara e estruturada",
                                  "subSteps": [
                                    "Estruture a apresentação: introdução, diagrama, entradas/saídas, acoplamentos, conclusão.",
                                    "Crie um diagrama de blocos mostrando loops acoplados.",
                                    "Forneça equações diferenciais simplificadas para o modelo.",
                                    "Discuta desafios de controle: necessidade de desacopladores ou MIMO controllers.",
                                    "Prepare uma narrativa oral ou slide resumindo o exemplo."
                                  ],
                                  "verification": "Grave um vídeo de 2 minutos explicando o exemplo ou escreva um parágrafo completo.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "PowerPoint ou Google Slides",
                                    "Ferramenta de gravação de vídeo",
                                    "Modelo matemático impresso"
                                  ],
                                  "tips": "Use cores diferentes para entradas e saídas no diagrama para destacar acoplamentos.",
                                  "learningObjective": "Comunicar efetivamente um exemplo de MIMO.",
                                  "commonMistakes": "Omitir diagrama ou falhar em destacar acoplamentos explicitamente."
                                }
                              ],
                              "practicalExample": "Em um processo químico de mistura em dois tanques em série: Entradas são vazões Q1 (ácido nítrico) e Q2 (base sódica); Saídas são concentrações C1 (no tanque 1) e C2 (no tanque 2). Alterar Q1 afeta C1 diretamente e C2 via fluxo, enquanto Q2 causa spillover para C1, demonstrando acoplamento forte (G12 e G21 significativos).",
                              "finalVerifications": [
                                "Pode desenhar o diagrama do processo químico com entradas e saídas corretas?",
                                "Explica verbalmente os acoplamentos entre canais?",
                                "Constrói uma matriz de transferência 2x2 simples?",
                                "Identifica pelo menos dois desafios de controle nesse exemplo MIMO?",
                                "Apresenta o exemplo em menos de 3 minutos de forma clara?",
                                "Distingue esse MIMO de um sistema SISO equivalente?"
                              ],
                              "assessmentCriteria": [
                                "Clareza na identificação de entradas (vazões) e saídas (concentrações).",
                                "Precisão na descrição de acoplamentos entre canais.",
                                "Uso de representação visual (diagrama ou matriz).",
                                "Relevância do exemplo ao contexto químico-industrial.",
                                "Capacidade de explicar impactos cruzados quantitativamente.",
                                "Estrutura lógica da apresentação (introdução, corpo, conclusão)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Álgebra linear (matrizes de transferência).",
                                "Química: Dinâmica de reatores e balanços de massa.",
                                "Física: Modelagem de fluidos e dinâmica de sistemas.",
                                "Informática: Simulação em MATLAB/Python para análise MIMO."
                              ],
                              "realWorldApplication": "Controle de plantas petroquímicas, como destilação dupla em refinarias, onde vazões de refluxo e vapor controlam composições de dois produtos, exigindo controladores MIMO para lidar com acoplamentos e otimizar produção."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "76.1.1.1.1"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "76.1.1.3",
                        "name": "Contraste entre SISO e MIMO",
                        "description": "Comparação das limitações e desafios dos sistemas SISO versus as interações e complexidades nos MIMO, motivando técnicas avançadas.",
                        "specificSkills": [
                          {
                            "id": "76.1.1.3.1",
                            "name": "Identificar diferenças principais",
                            "description": "Comparar ausência de interações em SISO com acoplamentos em MIMO, onde uma entrada afeta múltiplas saídas, exigindo análise de normas matriciais como singular values.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar conceitos fundamentais de sistemas SISO",
                                  "subSteps": [
                                    "Defina sistema SISO como Single Input Single Output (uma entrada, uma saída).",
                                    "Explique que em SISO não há interações cruzadas entre variáveis.",
                                    "Descreva a função de transferência simples G(s) = Y(s)/U(s).",
                                    "Ilustre com diagrama de bloco básico.",
                                    "Discuta ausência de acoplamento: entrada afeta apenas saída direta."
                                  ],
                                  "verification": "Desenhe diagrama de bloco SISO e explique verbalmente a ausência de interações.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Papel e caneta, software de simulação como MATLAB/Simulink, livro-texto de controle.",
                                  "tips": "Use exemplos cotidianos como controle de velocidade de um motor DC para fixar o conceito.",
                                  "learningObjective": "Compreender a simplicidade e ausência de interações em sistemas monovariáveis.",
                                  "commonMistakes": "Confundir SISO com sistemas com ruído ou perturbações não modeladas como acoplamentos."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Introduzir sistemas MIMO e acoplamentos",
                                  "subSteps": [
                                    "Defina MIMO como Multiple Input Multiple Output (múltiplas entradas/saídas).",
                                    "Apresente matriz de função de transferência G(s) onde G_ij(s) mostra efeito da i-ésima entrada na j-ésima saída.",
                                    "Explique acoplamento: uma entrada afeta múltiplas saídas.",
                                    "Discuta interações cruzadas e necessidade de análise multivariable.",
                                    "Compare com SISO via exemplo matricial simples 2x2."
                                  ],
                                  "verification": "Construa matriz G(s) para um sistema 2x2 e identifique elementos off-diagonal como acoplamentos.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "MATLAB para plotar matrizes, quadro branco, notas de aula sobre álgebra linear.",
                                  "tips": "Visualize acoplamentos como 'vazamentos' de sinal entre canais.",
                                  "learningObjective": "Reconhecer a estrutura matricial e interações em MIMO.",
                                  "commonMistakes": "Ignorar elementos off-diagonal como zero, assumindo independência."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Comparar diferenças principais entre SISO e MIMO",
                                  "subSteps": [
                                    "Liste diferenças: SISO (1x1, sem acoplamento) vs. MIMO (nxn, com acoplamento).",
                                    "Analise impacto: em SISO, design simples; em MIMO, necessidade de desacoplamento.",
                                    "Discuta estabilidade: polos escalares vs. valores singulares.",
                                    "Compare respostas: step response isolada vs. interações múltiplas.",
                                    "Crie tabela comparativa de características chave."
                                  ],
                                  "verification": "Preencha tabela comparativa e discuta com colega ou tutor.",
                                  "estimatedTime": "40 minutos",
                                  "materials": "Planilha Excel ou LaTeX para tabela, exemplos de Simulink.",
                                  "tips": "Foque em 'uma entrada afeta múltiplas saídas' como diferença chave.",
                                  "learningObjective": "Identificar e articular diferenças principais de forma clara.",
                                  "commonMistakes": "Superestimar similaridades, esquecendo análise multivariable em MIMO."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar normas matriciais como singular values",
                                  "subSteps": [
                                    "Explique normas matriciais: ||G|| como medida de ganho máximo.",
                                    "Introduza valores singulares σ_i de G(jω) via SVD (Singular Value Decomposition).",
                                    "Discuta σ_max (ganho máximo) e σ_min (ganho mínimo) para robustez.",
                                    "Compare com SISO: norma escalar |G(jω)| vs. espectro singular em MIMO.",
                                    "Aplique em software para calcular e plotar."
                                  ],
                                  "verification": "Compute e plote singular values para matriz MIMO exemplo usando MATLAB.",
                                  "estimatedTime": "50 minutos",
                                  "materials": "MATLAB com toolbox Control System, tutoriais SVD online.",
                                  "tips": "Lembre: singular values quantificam 'força' das interações.",
                                  "learningObjective": "Usar ferramentas matemáticas para analisar diferenças quantitativamente.",
                                  "commonMistakes": "Confundir valores singulares com autovalores, ignorando não-normalidade."
                                }
                              ],
                              "practicalExample": "Considere um quadricóptero (MIMO): comando de roll afeta pitch e yaw devido a acoplamentos dinâmicos, analisados via singular values da matriz G(s). Em contraste, um termostato simples (SISO) ajusta apenas temperatura sem interações cruzadas.",
                              "finalVerifications": [
                                "Explique verbalmente 3 diferenças principais entre SISO e MIMO.",
                                "Desenhe matriz G(s) 2x2 e identifique acoplamentos.",
                                "Calcule singular values para exemplo dado e interprete σ_max.",
                                "Compare respostas em step test SISO vs. MIMO.",
                                "Crie tabela resumida de prós/contras de cada.",
                                "Discuta quando usar análise MIMO em projeto real."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de acoplamentos (off-diagonais).",
                                "Correta interpretação de singular values como normas.",
                                "Clareza na comparação qualitativa e quantitativa.",
                                "Uso adequado de ferramentas como MATLAB para verificação.",
                                "Capacidade de ligar diferenças a impactos no design de controladores.",
                                "Ausência de confusão entre conceitos SISO/MIMO."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Álgebra linear (SVD, normas matriciais).",
                                "Física: Dinâmica de sistemas multi-DOF (graus de liberdade).",
                                "Engenharia de Software: Simulações em MATLAB/Simulink.",
                                "Estatística: Análise de robustez e incertezas em normas.",
                                "Economia: Otimização multivariable em processos industriais."
                              ],
                              "realWorldApplication": "No controle de aviões comerciais (MIMO), análise de singular values garante que comandos de leme não causem instabilidades cruzadas em ailerons, evitando acidentes e otimizando combustível."
                            },
                            "estimatedTime": "0.25 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "76.1.1.1",
                              "76.1.1.2"
                            ]
                          },
                          {
                            "id": "76.1.1.3.2",
                            "name": "Discutir desafios em MIMO",
                            "description": "Explicar problemas como não-diagonalidade da matriz G(s), direções fortes e fracas de controle, e necessidade de desacoplamento ou controle multivariable.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Fundamentos de Sistemas MIMO e Matriz de Transferência G(s)",
                                  "subSteps": [
                                    "Defina sistema MIMO como tendo múltiplas entradas e saídas, contrastando com SISO.",
                                    "Explique a matriz de transferência G(s) como uma matriz onde elementos diagonais são transferências principais e off-diagonais representam acoplamentos.",
                                    "Identifique exemplos simples de plantas MIMO, como dois motores acoplados.",
                                    "Desenhe uma matriz G(s) 2x2 genérica e rotule elementos.",
                                    "Discuta implicações iniciais da estrutura matricial em análise de frequência."
                                  ],
                                  "verification": "Construa e explique uma matriz G(s) 2x2 para um sistema hipotético, identificando elementos off-diagonais.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Livro de controle avançado (ex: Skogestad), MATLAB ou Octave para simulação básica, quadro branco.",
                                  "tips": "Use notação LaTeX para matrizes para clareza em discussões.",
                                  "learningObjective": "Compreender a representação matricial de sistemas MIMO e identificar acoplamentos iniciais.",
                                  "commonMistakes": "Confundir G(s) com função de transferência escalar de SISO; ignorar off-diagonais como 'ruído'."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar Não-Diagonalidade da Matriz G(s) e Interações Cruzadas",
                                  "subSteps": [
                                    "Explique não-diagonalidade: elementos G_ij (i≠j) ≠ 0 causam interações entre loops.",
                                    "Calcule respostas em frequência para entradas unitárias e observe acoplamentos.",
                                    "Use diagramas de Bode multivariáveis para visualizar efeitos off-diagonais.",
                                    "Quantifique interações com métricas como índice de Bristol ou condição de matriz.",
                                    "Discuta impactos em controle: limitação de desempenho em laços desacoplados."
                                  ],
                                  "verification": "Para uma G(s) dada, plote respostas e destaque como uma entrada afeta múltiplas saídas.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Software MATLAB (funções sisotool ou bode), exemplos de G(s) de literatura.",
                                  "tips": "Comece com sistemas simétricos para intuitividade antes de assimétricos.",
                                  "learningObjective": "Identificar e quantificar problemas causados pela não-diagonalidade em análise de sistemas.",
                                  "commonMistakes": "Assumir diagonalidade perfeita em plantas reais; subestimar magnitude de off-diagonais em baixas frequências."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explorar Direções Fortes e Fracas de Controle via Valores Singulares",
                                  "subSteps": [
                                    "Introduza decomposição em valores singulares (SVD): G(s) = U Σ V^H.",
                                    "Defina direção forte como associada ao maior valor singular (σ_max), fraca ao menor (σ_min).",
                                    "Analise ganho MIMO: ||G|| = σ_max, sensibilidade em direção fraca.",
                                    "Use gráficos de valores singulares para identificar frequências críticas.",
                                    "Discuta implicações: controle ineficaz em direções fracas limita robustez."
                                  ],
                                  "verification": "Compute SVD de uma G(jω) em frequência crítica e interprete direções u1, v1 como fortes.",
                                  "estimatedTime": "50 minutos",
                                  "materials": "MATLAB (svd função), tutoriais online sobre SVD em controle.",
                                  "tips": "Visualize vetores singulares como 'modos' do sistema para intuição geométrica.",
                                  "learningObjective": "Aplicar SVD para revelar assimetrias direcionais em controle MIMO.",
                                  "commonMistakes": "Confundir valores singulares com autovalores; ignorar fase em direções."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Discutir Estratégias de Mitigação: Desacoplamento vs Controle Multivariável",
                                  "subSteps": [
                                    "Explique desacoplamento: design de pré-compensadores D(s) para diagonalizar G(s)D(s).",
                                    "Limitações do desacoplamento: não funciona em todas as frequências, sensível a modelo.",
                                    "Introduza controle multivariable: LQG, H∞, MPC que lidam com acoplamentos nativamente.",
                                    "Compare prós/contras: desacoplamento simples mas frágil; multivariable robusto mas complexo.",
                                    "Pratique argumentação: quando usar cada um baseado em σ_max/σ_min e interações."
                                  ],
                                  "verification": "Escreva um parágrafo discutindo desafios e soluções para um caso MIMO específico.",
                                  "estimatedTime": "40 minutos",
                                  "materials": "Artigos sobre controle decoupling (ex: Bristol), exemplos MPC em Simulink.",
                                  "tips": "Use analogia de 'carro com reboque' para direções fortes/fracas na discussão.",
                                  "learningObjective": "Avaliar e propor soluções para desafios MIMO de forma crítica.",
                                  "commonMistakes": "Promover desacoplamento como panaceia; ignorar custo computacional de multivariable."
                                }
                              ],
                              "practicalExample": "Em um sistema de dois tanques acoplados (nível em tanque A afeta B via fluxo), a matriz G(s) tem off-diagonais fortes. Aplicando SVD, direção forte é elevar ambos níveis igualmente (v1), fraca é diferencial. Desacoplamento falha em baixas frequências; MPC resolve controlando multivariablemente para seguir referências independentes.",
                              "finalVerifications": [
                                "Explicar verbalmente não-diagonalidade com exemplo matricial.",
                                "Plotar valores singulares e identificar direção fraca.",
                                "Discutir limitação de ganho ||G||_∞ em contexto de robustez.",
                                "Propor pelo menos duas estratégias de controle e trade-offs.",
                                "Analisar um G(s) real e listar 3 desafios principais.",
                                "Comparar desempenho SISO descentralizado vs MIMO centralizado."
                              ],
                              "assessmentCriteria": [
                                "Precisão na descrição de não-diagonalidade e SVD (80% conceitos corretos).",
                                "Profundidade na análise de direções fortes/fracas com cálculos.",
                                "Clareza na discussão de soluções, com exemplos quantitativos.",
                                "Capacidade de conectar desafios a limitações físicas do sistema.",
                                "Uso correto de terminologia (ex: σ_bar, RGA).",
                                "Estrutura lógica na discussão oral/escrita."
                              ],
                              "crossCurricularConnections": [
                                "Álgebra Linear: Decomposição SVD e normas de matrizes.",
                                "Processos Industriais: Modelagem de plantas químicas acopladas.",
                                "Otimização: Trade-offs em MPC e H∞ design.",
                                "Física: Dinâmica de fluidos em sistemas hidráulicos MIMO."
                              ],
                              "realWorldApplication": "No controle de aviões (flaps e ailerons acoplados), direções fracas limitam manobras; controle multivariable como em fly-by-wire da Boeing usa SVD para robustez contra falhas."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "76.1.1.2"
                            ]
                          },
                          {
                            "id": "76.1.1.3.3",
                            "name": "Exemplificar limitações do SISO em MIMO",
                            "description": "Mostrar como aproximar MIMO por múltiplos SISO falha devido a interações, usando exemplo de planta com RGA (Relative Gain Array) ≠ I.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Fundamentos de Sistemas SISO e MIMO",
                                  "subSteps": [
                                    "Defina SISO como sistema com uma entrada e uma saída, ideal para controle descentralizado simples.",
                                    "Defina MIMO como sistema com múltiplas entradas e saídas, sujeito a interações cruzadas.",
                                    "Explique a aproximação descentralizada: tratar MIMO como pares SISO independentes.",
                                    "Discuta por que interações podem invalidar essa aproximação.",
                                    "Liste exemplos reais de MIMO, como plantas químicas."
                                  ],
                                  "verification": "Explique verbalmente ou por escrito as diferenças chave entre SISO e MIMO, citando pelo menos dois exemplos de interações.",
                                  "estimatedTime": "30-45 minutos",
                                  "materials": [
                                    "Notas de aula sobre controle básico",
                                    "Livro-texto de controle (ex: Ogata ou Franklin)",
                                    "Diagrama comparativo SISO vs MIMO"
                                  ],
                                  "tips": [
                                    "Use diagramas de blocos para visualizar interações.",
                                    "Lembre-se: SISO assume diagonal dominante na matriz de transferência."
                                  ],
                                  "learningObjective": "Compreender as diferenças fundamentais e assumir a aproximação SISO em MIMO.",
                                  "commonMistakes": [
                                    "Confundir MIMO com MISO (múltiplas entradas, uma saída).",
                                    "Ignorar que SISO funciona apenas sem acoplamentos fortes."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Modelar um Sistema MIMO Simples com Interações",
                                  "subSteps": [
                                    "Escolha exemplo: planta de dois tanques acoplados ou coluna de destilação com y1 (composição topo), y2 (fundo), u1 (refluxo), u2 (vapor).",
                                    "Defina a matriz de transferência G(s) = [[g11, g12], [g21, g22]], com valores numéricos realistas (ex: g11=1/(10s+1), g12=0.5/(12s+1), etc.).",
                                    "Identifique elementos fora da diagonal como fontes de interação.",
                                    "Calcule ganhos estáticos (G(0)) para preparar RGA.",
                                    "Desenhe diagrama esquemático da planta."
                                  ],
                                  "verification": "Construa e justifique a matriz G(s) para o exemplo escolhido, confirmando presença de acoplamentos.",
                                  "estimatedTime": "45-60 minutos",
                                  "materials": [
                                    "Software de simulação (MATLAB/Simulink ou Python com control library)",
                                    "Papel e lápis para esboços",
                                    "Referências sobre modelagem de plantas químicas"
                                  ],
                                  "tips": [
                                    "Use modelos de primeira ordem para simplicidade inicial.",
                                    "Verifique unidades consistentes nas transferências."
                                  ],
                                  "learningObjective": "Modelar quantitativamente um sistema MIMO com interações evidentes.",
                                  "commonMistakes": [
                                    "Negligenciar delays ou não-linearidades no modelo inicial.",
                                    "Escolher matriz diagonal por engano (sem interações)."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular e Interpretar o Relative Gain Array (RGA)",
                                  "subSteps": [
                                    "Lembre fórmula RGA: Λ = G(0) .* (G(0)^(-1))^T, onde .* é Hadamard (elemento a elemento).",
                                    "Calcule ganhos estáticos G(0) da matriz do passo anterior.",
                                    "Compute inversa de G(0) e aplique fórmula passo a passo.",
                                    "Analise: se Λ ≠ I (identidade), há interações; valores >1 ou <0 indicam pares inadequados.",
                                    "Interprete para pares de controle (ex: diagonal se λ11 próximo de 1)."
                                  ],
                                  "verification": "Apresente cálculo manual ou via software do RGA, com interpretação numérica (ex: λ12 = 1.5 indica forte interação).",
                                  "estimatedTime": "60-90 minutos",
                                  "materials": [
                                    "MATLAB ou Python (numpy/scipy para matrizes)",
                                    "Calculadora matricial ou Excel",
                                    "Tabela de referência RGA de livros de controle multivariable"
                                  ],
                                  "tips": [
                                    "Teste RGA em frequência se avançado, mas foque em DC gain primeiro.",
                                    "Valide cálculo com software para evitar erros aritméticos."
                                  ],
                                  "learningObjective": "Aplicar RGA para quantificar interações em MIMO.",
                                  "commonMistakes": [
                                    "Erro na inversa matricial ou no produto Hadamard.",
                                    "Interpretar erroneamente λ=0 como sem interação (é ill-conditioned)."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Demonstrar Falha da Aproximação SISO Descentralizada",
                                  "subSteps": [
                                    "Projete controladores PI descentralizados assumindo pares diagonais (SISO).",
                                    "Simule resposta em malha fechada para mudança em u1: observe spillover em y2 devido a g21.",
                                    "Compare com caso ideal sem interações (RGA=I).",
                                    "Ajuste setpoints cruzados ou use RGA para reemparelhar e mostre melhoria parcial.",
                                    "Conclua limitações: instabilidade, desempenho pobre em presença de interações fortes."
                                  ],
                                  "verification": "Execute simulação mostrando oscilações ou overshoot excessivo no canal cruzado, contrastando com MIMO centralizado.",
                                  "estimatedTime": "90-120 minutos",
                                  "materials": [
                                    "Simulink/MATLAB para simulação dinâmica",
                                    "Ferramentas de tuning PID (ex: Ziegler-Nichols)",
                                    "Gráficos de resposta temporal"
                                  ],
                                  "tips": [
                                    "Use step responses para entradas unitárias isoladas.",
                                    "Registre métricas como ITSE para quantificar falha."
                                  ],
                                  "learningObjective": "Evidenciar empiricamente por que SISO falha em MIMO interativos.",
                                  "commonMistakes": [
                                    "Tunar controladores sem considerar interações, levando a tuning irrealista.",
                                    "Ignorar efeitos de perturbações em simulações."
                                  ]
                                }
                              ],
                              "practicalExample": "Em uma coluna de destilação binária, entradas u1 (refluxo) afeta principalmente y1 (composição topo), mas também y2 (fundo) via g21. Projetando PI só para diagonal (SISO), uma mudança em u1 causa overshoot em y2 (devido RGA λ12=2.3 >1), resultando em instabilidade operacional. Simulação em MATLAB mostra resposta cruzada oscilante vs. controle MIMO decoupling estável.",
                              "finalVerifications": [
                                "Calculou RGA corretamente para o exemplo, com interpretação precisa de interações.",
                                "Simulou e demonstrou falha descentralizada SISO com gráficos de resposta.",
                                "Explicou verbalmente por que RGA ≠ I invalida aproximação SISO.",
                                "Identificou pares alternativos via RGA e testou melhoria.",
                                "Listou pelo menos três limitações práticas (ex: robustez, rejeição de distúrbios)."
                              ],
                              "assessmentCriteria": [
                                "Precisão no cálculo de RGA (erro <1%).",
                                "Clareza na interpretação de interações e limitações SISO.",
                                "Qualidade das simulações (gráficos legíveis, cenários múltiplos).",
                                "Profundidade da análise (quantitativa + qualitativa).",
                                "Conexão explícita com conceitos teóricos de MIMO.",
                                "Criatividade no exemplo prático escolhido."
                              ],
                              "crossCurricularConnections": [
                                "Matemática Linear: operações matriciais, inversas e produtos Hadamard.",
                                "Programação/Simulação: uso de MATLAB/Python para análise dinâmica.",
                                "Física/Química: modelagem de processos industriais acoplados.",
                                "Estatística: análise de sensibilidade e robustez em simulações."
                              ],
                              "realWorldApplication": "Na indústria petroquímica, colunas de destilação MIMO com RGA indicando fortes interações requerem controladores multivariable (MPC) para estabilidade; aproximações SISO causam perdas de produção por oscilações, como visto em refinarias onde decoupling via RGA otimiza yields."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "76.1.1.1.3",
                              "76.1.1.2.3"
                            ]
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.7.2",
                    "name": "Diferenças entre Controle SISO e MIMO",
                    "description": "Comparação das abordagens de modelagem, análise e projeto entre sistemas escalares e multivariáveis.",
                    "individualConcepts": [
                      {
                        "id": "10.1.7.2.1",
                        "name": "Controle Clássico de Sistemas SISO",
                        "description": "Revisão dos conceitos fundamentais de estabilidade, desempenho e técnicas clássicas de projeto para sistemas lineares invariantes no tempo (LIT) monovariáveis, incluindo modelos de incertezas e robustez.",
                        "specificSkills": [
                          {
                            "id": "10.1.7.2.1.1",
                            "name": "Identificar critérios de estabilidade em sistemas SISO",
                            "description": "Aplicar critérios como Routh-Hurwitz, Nyquist e Bode para analisar a estabilidade de sistemas de controle SISO lineares, reconhecendo margens de ganho e fase.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os fundamentos de estabilidade em sistemas SISO",
                                  "subSteps": [
                                    "Definir estabilidade absoluta, relativa e condicional em sistemas lineares invariantes no tempo (LTI).",
                                    "Explicar o papel das raízes do polinômio característico na estabilidade.",
                                    "Diferenciar sistemas estáveis, instáveis e marginalmente estáveis com exemplos gráficos de resposta ao degrau.",
                                    "Revisar função de transferência e diagrama de blocos para sistemas SISO.",
                                    "Identificar condições necessárias para estabilidade (ex: todos os coeficientes positivos)."
                                  ],
                                  "verification": "O aluno explica verbalmente ou por escrito os tipos de estabilidade e identifica estabilidade em um polinômio simples.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Livro-texto de Controle (ex: Ogata), calculadora, folhas de papel"
                                  ],
                                  "tips": "Use o teste de Descartes para coeficientes iniciais; visualize polos no plano s.",
                                  "learningObjective": "Compreender os conceitos básicos de estabilidade e sua relação com polos do sistema.",
                                  "commonMistakes": [
                                    "Confundir estabilidade com convergência rápida.",
                                    "Ignorar polos no semiplano imaginário puro."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Aplicar o Critério de Routh-Hurwitz",
                                  "subSteps": [
                                    "Montar a tabela de Routh para um polinômio característico dado.",
                                    "Identificar mudanças de sinal na primeira coluna para contar polos instáveis.",
                                    "Tratar casos especiais: linha zero, linha inteira zero e auxiliar.",
                                    "Determinar o número de polos no semiplano direito (RHP).",
                                    "Verificar estabilidade: zero mudanças de sinal = estável."
                                  ],
                                  "verification": "Montar corretamente a tabela Routh para um polinômio de 3ª ordem e concluir sobre estabilidade.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Software MATLAB ou Python (control library), exemplos de polinômios impressos"
                                  ],
                                  "tips": "Substitua linha zero por derivada da anterior; pratique com polinômios de baixa ordem primeiro.",
                                  "learningObjective": "Dominar o algoritmo Routh-Hurwitz para análise algébrica de estabilidade.",
                                  "commonMistakes": [
                                    "Erro em cálculos de elementos da tabela.",
                                    "Esquecer tratamento de linha zero."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Aplicar o Critério de Nyquist",
                                  "subSteps": [
                                    "Construir o diagrama de Nyquist para a função de malha aberta G(s)H(s).",
                                    "Contar encirclements (N) do ponto crítico (-1,0) no plano complexo.",
                                    "Calcular Z = P + N, onde Z=0 para estabilidade (sem polos abertos instáveis).",
                                    "Analisar para ω de -∞ a +∞, considerando simetria.",
                                    "Interpretar para sistemas com polos/jzeros no imaginário."
                                  ],
                                  "verification": "Desenhar diagrama Nyquist para G(s)=K/(s(s+1)) e determinar faixa de K estável.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "MATLAB (nyquist() command), papel milimetrado, tabela de valores de frequência"
                                  ],
                                  "tips": "Use simulação para plotar; verifique direção de contorno (sentido horário).",
                                  "learningObjective": "Usar análise em frequência via Nyquist para estabilidade.",
                                  "commonMistakes": [
                                    "Contagem errada de encirclements.",
                                    "Ignorar polos de malha aberta."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar estabilidade via Diagrama de Bode e margens",
                                  "subSteps": [
                                    "Plotar diagramas de Bode (magnitude e fase) para G(s)H(s).",
                                    "Identificar frequência de ganho unitário (ω_g) e fase unitária (ω_p).",
                                    "Calcular margem de ganho (MG = 1/|G(jω_p)|) e margem de fase (MF = 180° + φ(ω_g)).",
                                    "Interpretar: MG>6dB e MF>45° indicam boa estabilidade relativa.",
                                    "Comparar resultados com Routh e Nyquist para validação."
                                  ],
                                  "verification": "Para um sistema dado, calcular MG e MF corretamente e recomendar compensação se necessário.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "MATLAB (bode() command), software como Python Control Systems Library"
                                  ],
                                  "tips": "Aproximações assintóticas aceleram o plot manual; foque em cruzamentos críticos.",
                                  "learningObjective": "Avaliar estabilidade relativa e robustez via margens de Bode.",
                                  "commonMistakes": [
                                    "Confundir ω_g e ω_p.",
                                    "Erro na conversão dB para magnitude."
                                  ]
                                }
                              ],
                              "practicalExample": "Analise a estabilidade do sistema com G(s) = 10 / (s(s+1)(s+2)). Use Routh-Hurwitz para confirmar estabilidade absoluta, Nyquist para contorno e Bode para MG=8dB e MF=60°, garantindo robustez.",
                              "finalVerifications": [
                                "Lista e explica os três critérios principais de estabilidade.",
                                "Aplica Routh-Hurwitz corretamente em polinômio de 4ª ordem.",
                                "Desenha e interpreta diagrama Nyquist sem erros de contagem.",
                                "Calcula margens de ganho e fase a partir de Bode com precisão.",
                                "Compara resultados dos critérios para um sistema unificado.",
                                "Identifica instabilidade em exemplos marginais."
                              ],
                              "assessmentCriteria": [
                                "Precisão matemática nos cálculos (sem erros aritméticos).",
                                "Correta interpretação qualitativa dos resultados.",
                                "Uso adequado de ferramentas computacionais (plots idênticos aos manuais).",
                                "Capacidade de tratar casos especiais (linha zero, polos imaginários).",
                                "Integração de múltiplos critérios para análise completa.",
                                "Clareza na documentação de passos e conclusões."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Análise de polinômios e funções complexas.",
                                "Física: Dinâmica de sistemas mecânicos e elétricos.",
                                "Informática: Programação em MATLAB/Python para simulações.",
                                "Engenharia Elétrica: Circuitos de feedback e amplificadores.",
                                "Estatística: Análise de robustez e variância em parâmetros."
                              ],
                              "realWorldApplication": "Em controle de velocidade de motores DC em robótica industrial, onde Routh garante estabilidade básica, Nyquist verifica em presença de não-linearidades e Bode otimiza margens para rejeição de distúrbios, evitando oscilações que danificam equipamentos."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.7.2.1.2",
                            "name": "Avaliar desempenho de controladores SISO clássicos",
                            "description": "Calcular especificações de desempenho como erro em regime permanente, tempo de subida e sobressinal em malhas de controle SISO usando diagramas de Bode e root locus.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Modelar o sistema SISO e o controlador",
                                  "subSteps": [
                                    "Identificar a função de transferência do planta G(s) a partir de equações diferenciais ou dados experimentais.",
                                    "Selecionar o tipo de controlador clássico (P, PI, PID) com base nas especificações iniciais.",
                                    "Formar a função de transferência da malha fechada T(s) = C(s)G(s)/(1 + C(s)G(s)).",
                                    "Verificar a ordem do sistema e condições de estabilidade básica.",
                                    "Documentar todas as funções de transferência em formato simbólico ou numérico."
                                  ],
                                  "verification": "Conferir se T(s) está corretamente derivada comparando com simulação passo inicial em software.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Papel e lápis ou software simbólico (SymPy, MATLAB Symbolic)",
                                    "Documentação do sistema físico",
                                    "Calculadora científica"
                                  ],
                                  "tips": [
                                    "Sempre normalize G(s) para ganho unitário se possível.",
                                    "Use expansões parciais para simplificar frações racionais."
                                  ],
                                  "learningObjective": "Dominar a representação matemática precisa de malhas SISO para análise posterior.",
                                  "commonMistakes": [
                                    "Esquecer o denominador 1 + loop gain.",
                                    "Confundir função de transferência aberta com fechada.",
                                    "Ignorar pólos em zero ou instabilidades iniciais."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Construir e analisar o Root Locus",
                                  "subSteps": [
                                    "Plotar o root locus da função de loop aberto L(s) = C(s)G(s) variando ganho K.",
                                    "Identificar ramos do locus, centroside e ângulos de partida/chegada.",
                                    "Selecionar ponto de operação no locus baseado em damping ratio ζ para sobressinal Mp = e^(-πζ/√(1-ζ²)).",
                                    "Calcular tempo de subida aproximado tr ≈ 1.8 / ωn, onde ωn da posição do polo dominante.",
                                    "Verificar cruzamentos com eixo imaginário para estabilidade."
                                  ],
                                  "verification": "Gerar gráfico de root locus e confirmar valores de K para ζ=0.7 com erro <5%.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "MATLAB (rlocus, rlocfind) ou Python (control.matlab.rlocus)",
                                    "Gráficos impressos para anotação manual"
                                  ],
                                  "tips": [
                                    "Use regra de magnitude e ângulo para pontos específicos.",
                                    "Foquem em pólos dominantes; ignore modos rápidos."
                                  ],
                                  "learningObjective": "Interpretar root locus para prever sobressinal e tempo de subida dinamicamente.",
                                  "commonMistakes": [
                                    "Confundir root locus com zero locus.",
                                    "Calcular Mp sem considerar ζ corretamente.",
                                    "Ignorar efeitos de zeros no locus."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Construir e analisar diagramas de Bode",
                                  "subSteps": [
                                    "Plotar diagramas de magnitude e fase de L(s) = C(s)G(s).",
                                    "Determinar o tipo do sistema pelo número de integradores em G(s) para erro em regime permanente (ess, step=1/(1+Kp), ramp=∞ se tipo<2).",
                                    "Medir margens de ganho e fase no ponto de fase -180° e magnitude 0dB.",
                                    "Identificar frequências de pico e corte para correlações com tempo de subida.",
                                    "Anotar assimptotas e correções para curvas reais."
                                  ],
                                  "verification": "Confirmar margens >6dB ganho e >45° fase, com ess calculado matching simulação.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "MATLAB (bode, margin) ou Python (control.bode_plot)",
                                    "Tabelas de assimptotas Bode"
                                  ],
                                  "tips": [
                                    "Use log-log para magnitude; semi-log para fase.",
                                    "Tipo do sistema dita ess: memorize fórmulas por entrada (step, ramp, parabólica)."
                                  ],
                                  "learningObjective": "Usar Bode para quantificar erro permanente e estabilidade relativa.",
                                  "commonMistakes": [
                                    "Contar integradores errado no tipo.",
                                    "Medir margens em frequência errada.",
                                    "Esquecer fator de 20log10 para magnitude."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Calcular e avaliar especificações de desempenho",
                                  "subSteps": [
                                    "Compilar valores: ess de Bode, tr e Mp de root locus.",
                                    "Simular resposta ao degrau em software para validar cálculos analíticos.",
                                    "Comparar specs com requisitos (ex: Mp<20%, tr<2s, ess<5%).",
                                    "Ajustar parâmetros do controlador se necessário e recalcular.",
                                    "Gerar relatório com tabelas e gráficos comparativos."
                                  ],
                                  "verification": "Resposta simulada matches specs calculadas dentro de 10% de erro.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "MATLAB (step, lsim) ou Python (control.step_response)",
                                    "Planilhas para tabulação"
                                  ],
                                  "tips": [
                                    "Sempre valide analítico com numérico.",
                                    "Priorize specs críticas: ess para precisão, Mp para oscilação."
                                  ],
                                  "learningObjective": "Integrar análises para avaliação holística e decisão de tuning.",
                                  "commonMistakes": [
                                    "Usar fórmulas erradas para segunda ordem em sistemas de ordem superior.",
                                    "Ignorar não-linearidades em simulações.",
                                    "Não normalizar tempo/escala nos gráficos."
                                  ]
                                }
                              ],
                              "practicalExample": "Para um servomotor de posição com G(s) = 100/(s(s+10)) e controlador PI C(s) = Kp + Ki/s, calcule ess para rampa (deve ser 1/Kv onde Kv=lim sL(s)), tr≈1.8/ωn do polo dominante no root locus com ζ=0.6, e Mp≈16%. Simule em MATLAB para confirmar Mp<20% com Kp=5, Ki=50.",
                              "finalVerifications": [
                                "Cálculo correto de ess para entrada degrau/rampa/parabólica.",
                                "Root locus mostra pólos com ζ adequado e K selecionado.",
                                "Bode plots com margens de estabilidade quantificadas.",
                                "Simulação de resposta temporal matches specs analíticas.",
                                "Relatório identifica se controlador atende requisitos.",
                                "Ajustes propostos melhoram desempenho mensuravelmente."
                              ],
                              "assessmentCriteria": [
                                "Precisão dos cálculos analíticos (>95% match com simulação).",
                                "Qualidade e legibilidade dos gráficos (Bode e root locus).",
                                "Interpretação correta de specs em contexto de requisitos.",
                                "Identificação de trade-offs (ex: Mp vs ess).",
                                "Uso adequado de ferramentas sem erros de sintaxe.",
                                "Relatório estruturado com conclusões acionáveis."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Análise de funções complexas e transformadas de Laplace.",
                                "Programação: Simulações numéricas em MATLAB/Python para validação.",
                                "Física: Modelagem dinâmica de sistemas mecânicos/elétricos.",
                                "Estatística: Análise de incertezas em margens de estabilidade.",
                                "Engenharia de Software: Documentação de análises de controle."
                              ],
                              "realWorldApplication": "Em indústrias automotivas, avaliar controladores PID em sistemas de cruise control SISO para garantir erro de velocidade <1km/h em rampa (ess), resposta rápida tr<1s e sem oscilações excessivas Mp<10%, usando Bode para tuning e root locus para robustez."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.7.2.1.3",
                            "name": "Analisar robustez em sistemas SISO LIT",
                            "description": "Modelar incertezas aditivas e multiplicativas em sistemas SISO e avaliar robustez usando a forma padrão e teoremas de robustez para controladores estabilizadores.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Fundamentos de Sistemas SISO LIT e Conceitos de Robustez",
                                  "subSteps": [
                                    "Estude a representação de sistemas SISO LIT em domínio de frequência usando funções de transferência.",
                                    "Identifique fontes comuns de incertezas em sistemas reais, como variações paramétricas e não-linearidades aproximadas.",
                                    "Defina robustez como a capacidade do sistema de manter estabilidade e desempenho apesar de incertezas.",
                                    "Revise o loop de feedback fechado para sistemas SISO com controlador C(s) e planta P(s).",
                                    "Pratique diagramas de bloco para representar o sistema nominal."
                                  ],
                                  "verification": "Descreva verbalmente ou por escrito os componentes de um sistema SISO LIT e liste 3 exemplos de incertezas reais.",
                                  "estimatedTime": "1-2 hours",
                                  "materials": [
                                    "Livro-texto de Controle Moderno (Dorf ou Ogata)",
                                    "Notas de aula sobre funções de transferência",
                                    "Software MATLAB/Simulink"
                                  ],
                                  "tips": "Comece com exemplos simples como um RLC para fixar conceitos antes de incertezas.",
                                  "learningObjective": "Compreender a base teórica de sistemas SISO LIT e o que significa robustez no contexto de controle.",
                                  "commonMistakes": [
                                    "Confundir estabilidade com robustez",
                                    "Ignorar o impacto de incertezas não modeladas",
                                    "Esquecer normalizações em funções de transferência"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Modelar Incertezas Aditivas em Sistemas SISO",
                                  "subSteps": [
                                    "Represente incertezas aditivas como Δ(s) somadas à saída da planta nominal P(s), formando P(s) + Δ(s).",
                                    "Use o diagrama de bloco para o sistema em laço fechado com incerteza aditiva.",
                                    "Calcule a função de sensibilidade S(s) = 1/(1 + P(s)C(s)) e mostre como ela amplifica incertezas.",
                                    "Plote diagramas de Bode para planta nominal e com incerteza aditiva.",
                                    "Simule respostas no tempo para validar o modelo."
                                  ],
                                  "verification": "Construa e simule um modelo com incerteza aditiva de 20% e verifique se o sistema permanece estável.",
                                  "estimatedTime": "2 hours",
                                  "materials": [
                                    "MATLAB com Control System Toolbox",
                                    "Folhas de cálculo para cálculos manuais",
                                    "Exemplos de código para Bode plots"
                                  ],
                                  "tips": "Use magnitudes normalizadas para incertezas (||Δ||∞ < 1) para facilitar análises.",
                                  "learningObjective": "Modelar e visualizar o impacto de incertezas aditivas em sistemas SISO LIT.",
                                  "commonMistakes": [
                                    "Representar aditiva como multiplicativa",
                                    "Não normalizar incertezas",
                                    "Esquecer de analisar estabilidade fechada"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Modelar Incertezas Multiplicativas em Sistemas SISO",
                                  "subSteps": [
                                    "Modele incertezas multiplicativas como P(s)(1 + W(s)Δ(s)), onde W(s) é o peso de incerteza.",
                                    "Desenhe o diagrama de bloco equivalente para laço fechado.",
                                    "Derive a condição de estabilidade usando o teorema do valor pequeno (small gain theorem).",
                                    "Gere pesos W(s) baseados em dados experimentais ou pior caso.",
                                    "Compare plots de Bode de incertezas aditivas vs. multiplicativas."
                                  ],
                                  "verification": "Crie um modelo com incerteza multiplicativa e confirme que ||T(s)W(s)||∞ < 1 garante robustez.",
                                  "estimatedTime": "2-3 hours",
                                  "materials": [
                                    "MATLAB Robust Control Toolbox",
                                    "Templates de modelagem de incertezas",
                                    "Referências: Skogestad 'Multivariable Feedback Control'"
                                  ],
                                  "tips": "Escolha W(s) que envolva a incerteza real em todos os frequências para precisão.",
                                  "learningObjective": "Dominar modelagem de incertezas multiplicativas e sua representação estruturada.",
                                  "commonMistakes": [
                                    "Confundir peso W(s) com a incerteza Δ(s)",
                                    "Usar normas erradas (L1 vs H∞)",
                                    "Ignorar fase nas incertezas"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Introduzir a Forma Padrão para Análise de Robustez",
                                  "subSteps": [
                                    "Estruture o sistema na forma padrão M(s)Δ(s) com ||Δ||∞ ≤ 1 e M(s) incluindo sensibilidade e complementar.",
                                    "Calcule M(s) = [S(s), CS(s); P S(s), T(s)] para o caso geral.",
                                    "Aplique o teorema: sistema robusto se ||M||∞ < 1.",
                                    "Use mu-toolbox ou comandos MATLAB para calcular ||M||∞.",
                                    "Analise singular values de M(s) via svd ou sigma plots."
                                  ],
                                  "verification": "Transforme um sistema dado na forma padrão e compute ||M||∞ para verificar robustez.",
                                  "estimatedTime": "2 hours",
                                  "materials": [
                                    "MATLAB com Robust Control Toolbox (mussv, vplot)",
                                    "Exercícios resolvidos de forma padrão"
                                  ],
                                  "tips": "Verifique sempre a estrutura de Δ como bloco diagonal para MIMO-like, mas foque SISO.",
                                  "learningObjective": "Aplicar a forma padrão para estruturar problemas de robustez em SISO.",
                                  "commonMistakes": [
                                    "Erro na montagem da matriz M(s)",
                                    "Confundir T(s) com S(s)",
                                    "Não interpolar singular values"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Avaliar Robustez Usando Teoremas para Controladores Estabilizadores",
                                  "subSteps": [
                                    "Revise teoremas chave: small-gain para ||L||∞ < 1/||Δ||∞ e robustez H∞.",
                                    "Para controlador estabilizador nominal, teste margens de robustez estruturada.",
                                    "Simule violações de robustez alterando Δ(s) e observe instabilidades.",
                                    "Otimize o controlador ajustando para maximizar ||M||∞^{-1}.",
                                    "Documente relatório com plots e conclusões."
                                  ],
                                  "verification": "Avalie um PID estabilizador em um sistema com incertezas e proponha melhorias se não robusto.",
                                  "estimatedTime": "2-3 hours",
                                  "materials": [
                                    "Simulink para simulações",
                                    "Ferramentas de síntese H∞ no MATLAB",
                                    "Casos de estudo industriais"
                                  ],
                                  "tips": "Use loops de otimização para tuning automático de controladores robustos.",
                                  "learningObjective": "Avaliar e certificar robustez de controladores estabilizadores usando teoremas formais.",
                                  "commonMistakes": [
                                    "Assumir estabilidade nominal implica robustez",
                                    "Não testar casos extremos de Δ",
                                    "Ignorar trade-offs desempenho vs. robustez"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um sistema de controle de velocidade de um motor DC SISO, modele incertezas aditivas no torque de carga (Δ_add = 0.1 N.m) e multiplicativas no ganho (W_mult(s) = 0.2). Use um controlador PI estabilizador nominal. Na forma padrão, verifique ||M||∞ < 1 e simule respostas com perturbações para confirmar estabilidade robusta.",
                              "finalVerifications": [
                                "Modela corretamente incertezas aditivas e multiplicativas em diagrama de blocos.",
                                "Constrói a forma padrão M(s)Δ(s) sem erros.",
                                "Calcula ||M||∞ usando ferramentas apropriadas e interpreta resultados.",
                                "Aplica small-gain theorem para prever robustez.",
                                "Simula e valida estabilidade sob incertezas variadas.",
                                "Identifica limitações e sugere melhorias no controlador."
                              ],
                              "assessmentCriteria": [
                                "Precisão na modelagem de incertezas (30%)",
                                "Correta aplicação da forma padrão e cálculo de normas (25%)",
                                "Interpretação teórica de teoremas de robustez (20%)",
                                "Qualidade de simulações e plots (15%)",
                                "Clareza no relatório e conexões com estabilidade (10%)"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Análise funcional em espaços de Hardy (H∞)",
                                "Programação: Simulações numéricas em MATLAB/Python (Control libraries)",
                                "Física: Modelagem dinâmica de sistemas mecânicos/elétricos",
                                "Estatística: Análise de Monte Carlo para incertezas estocásticas",
                                "Engenharia de Software: Validação de modelos em ferramentas como Simulink"
                              ],
                              "realWorldApplication": "Na indústria aeroespacial, análise de robustez garante que controladores de flaps em aviões mantenham estabilidade apesar de variações em aerodinâmica devido a desgaste ou condições climáticas, evitando falhas catastróficas."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.7.2.2",
                        "name": "Introdução ao Controle de Sistemas MIMO",
                        "description": "Conceitos iniciais de modelagem, análise e projeto para sistemas multivariáveis, destacando representações matriciais e ferramentas como valores singulares.",
                        "specificSkills": [
                          {
                            "id": "10.1.7.2.2.1",
                            "name": "Representar sistemas MIMO em forma de transferência matricial",
                            "description": "Converter equações diferenciais de sistemas multivariáveis em matrizes de transferência G(s) e entender interações entre entradas e saídas múltiplas.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender Fundamentos de Sistemas MIMO e Representação por Equações Diferenciais",
                                  "subSteps": [
                                    "Identificar entradas (u) e saídas (y) em um sistema multivariável.",
                                    "Revisar equações diferenciais lineares invariantes no tempo para múltiplas variáveis.",
                                    "Diferenciar MIMO de SISO destacando acoplamentos entre canais.",
                                    "Estudar notação matricial para vetores de entrada U(s) e saída Y(s).",
                                    "Explorar exemplos simples de sistemas 2x2."
                                  ],
                                  "verification": "Liste corretamente as entradas, saídas e acoplamentos de um sistema MIMO dado em exercício.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Livro-texto de Controle Moderno (ex: Ogata ou Franklin)",
                                    "Folha de papel e calculadora",
                                    "Video-aula sobre Laplace e MIMO"
                                  ],
                                  "tips": "Sempre desenhe um diagrama de blocos esquemático para visualizar interações.",
                                  "learningObjective": "Compreender a estrutura básica de sistemas MIMO e sua representação diferencial.",
                                  "commonMistakes": [
                                    "Confundir entradas com saídas",
                                    "Ignorar termos de acoplamento off-diagonal"
                                  ]
                                },
                                "stepNumber2:titleConstruirFunçõeseTransferênciaparaCadaparEntrada-Saída",
                                "subSteps:[",
                                "subStepsLinearizaraseequaçõesdiferenciaisdoparaformaestándardevectorial",
                                "AplicaratransformadadeLaplacesimbolicasobrequadaequaçãoindividual",
                                "Isolaraterminfluênciadecadaentrada(u_i)nas saída(y_j)",
                                "ComputarG_{ji}(s)=Y_j(s)/U_i(s)assumindou_k=0fork≠i",
                                "Verificarestabilidadedepólosindividuais"
                              ],
                              "verification": "Explique interações em um G(s) exemplo e sugira método de controle.",
                              "estimatedTime": "1.5 horas",
                              "materials": [
                                "Simulink ou Python para simulação de respostas",
                                "Artigos sobre controle MIMO"
                              ],
                              "tips": "Foco em frequências DC para acoplamento relativo simples.",
                              "learningObjective": "Interpretar matriz G(s) para entender dinâmicas multivariáveis.",
                              "commonMistakes": [
                                "Ignorar fases nas interações",
                                "Assumir simetria na matriz sem verificação"
                              ],
                              "stepNumber": 4,
                              "title": "Analisar Interações e Acoplamentos na Matriz G(s)",
                              "subSteps": [
                                "Identificar elementos diagonais (canais principais) vs off-diagonal (acoplamentos).",
                                "Calcular razões de acoplamento como |G12/G11| em baixas frequências.",
                                "Discutir implicações para controle: necessidade de desacopladores.",
                                "Simular resposta a degrau em uma entrada e observar efeitos cruzados.",
                                "Explorar decomposição SVD para análise de direções principais."
                              ]
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.7.2.2.2",
                            "name": "Aplicar análise de valores singulares em MIMO",
                            "description": "Calcular valores singulares mínimos e máximos (σ_bar e σ) para avaliar ganho, estabilidade e robustez em funções de transferência MIMO.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Fundamentos de Decomposição em Valores Singulares (SVD)",
                                  "subSteps": [
                                    "Estude a definição de SVD para matrizes retangulares: A = U Σ V^H.",
                                    "Identifique os valores singulares como as raízes quadradas dos autovalores de A A^H ou A^H A.",
                                    "Pratique SVD manual para matrizes 2x2 simples.",
                                    "Entenda propriedades: σ1 ≥ σ2 ≥ ... ≥ σr > 0.",
                                    "Explore interpretação geométrica: alongamento e contração."
                                  ],
                                  "verification": "Resolva SVD de uma matriz 2x2 e liste os valores singulares corretamente.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Livro de Álgebra Linear (ex: Strang), calculadora ou Python (numpy.linalg.svd), papel e lápis"
                                  ],
                                  "tips": "Comece com matrizes reais e simétricas para simplificar.",
                                  "learningObjective": "Compreender SVD e extrair valores singulares de matrizes.",
                                  "commonMistakes": [
                                    "Confundir valores singulares com autovalores",
                                    "Ignorar a matriz hermitiana V^H",
                                    "Esquecer ordenação decrescente"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Entender Valores Singulares em Contextos MIMO",
                                  "subSteps": [
                                    "Defina σ(G(jω)) como valores singulares da matriz de transferência G(jω).",
                                    "Explique σ_max = maior ganho direcional, σ_min = menor ganho direcional.",
                                    "Discuta relevância para sistemas multivariáveis vs SISO.",
                                    "Analise gráficos de σ_max e σ_min vs frequência.",
                                    "Compare com normas como H-infinito."
                                  ],
                                  "verification": "Descreva verbalmente o que σ_bar representa em um sistema MIMO.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Apostila de Controle MIMO, software MATLAB (svd) ou Python Control Systems Library"
                                  ],
                                  "tips": "Visualize com sigma plots no MATLAB para intuição.",
                                  "learningObjective": "Associar valores singulares a propriedades dinâmicas de sistemas MIMO.",
                                  "commonMistakes": [
                                    "Confundir σ com magnitude de elementos individuais",
                                    "Ignorar dependência em frequência",
                                    "Aplicar SVD diretamente em G(s) sem avaliar em jω"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular Valores Singulares Mínimo e Máximo (σ_bar e σ)",
                                  "subSteps": [
                                    "Avalie G(jω) numericamente para frequências específicas.",
                                    "Compute SVD de G(jω): [U, S, V] = svd(G(jω)).",
                                    "Extraia σ = S(1,1), σ_bar = S(end,end).",
                                    "Automatize com script para varredura de ω.",
                                    "Valide com propriedades: ||G||_2 = σ_max."
                                  ],
                                  "verification": "Calcule σ e σ_bar para G(jω) dada e compare com norma 2.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "MATLAB ou Octave com toolbox Control, Python (scipy.signal, control.matlab), exemplos de matrizes MIMO"
                                  ],
                                  "tips": "Use freqresp() no MATLAB para G(jω) em múltiplas ω.",
                                  "learningObjective": "Executar cálculos precisos de σ e σ_bar para funções de transferência MIMO.",
                                  "commonMistakes": [
                                    "Erro numérico em altas frequências",
                                    "Usar svd em G(s) simbólico",
                                    "Confundir σ_min com inverso de σ_max"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Interpretar para Avaliação de Ganho, Estabilidade e Robustez",
                                  "subSteps": [
                                    "Avalie ganho: σ_max indica ganho máximo possível.",
                                    "Estabilidade: picos em σ_max sugerem ressonância.",
                                    "Robustez: σ_min baixo indica direções frágeis.",
                                    "Construa gráficos de Bode com σ_max/σ_min.",
                                    "Compare com margens de estabilidade clássicas."
                                  ],
                                  "verification": "Interprete um gráfico de σ vs ω, identificando riscos de robustez.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Gráficos de sigma plots de exemplos reais, simulador como Simulink"
                                  ],
                                  "tips": "Foque em cruzamentos de ganho de 0dB em σ_max para largura de banda.",
                                  "learningObjective": "Aplicar σ e σ_bar na análise qualitativa de desempenho MIMO.",
                                  "commonMistakes": [
                                    "Interpretar σ_min como ganho médio",
                                    "Ignorar fase em análises singulares",
                                    "Superestimar estabilidade por σ_max baixo"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Praticar com Exemplo Completo e Verificações",
                                  "subSteps": [
                                    "Escolha um sistema MIMO 2x2 exemplo.",
                                    "Compute σ(ω) para faixa de frequências.",
                                    "Analise implicações para design de controlador.",
                                    "Simule perturbações e verifique robustez via σ_min.",
                                    "Documente relatório com plots e conclusões."
                                  ],
                                  "verification": "Produza relatório com cálculos corretos e análise coerente.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Exemplo pronto (ex: planta química MIMO), MATLAB/Simulink"
                                  ],
                                  "tips": "Salve scripts para reutilização em problemas semelhantes.",
                                  "learningObjective": "Integrar todos os conceitos em uma análise completa.",
                                  "commonMistakes": [
                                    "Escala errada em plots (dB vs linear)",
                                    "Falta de normalização de entradas",
                                    "Omitir análise em baixas frequências"
                                  ]
                                }
                              ],
                              "practicalExample": "Para G(s) = [[1/(s+1), 0.5/(s+2)]; [0.5/(s+3), 1/(s+4)]], avalie em ω=1 rad/s: G(j1) ≈ [[0.43+0.9j, 0.22+0.86j]; [0.16+0.98j, 0.25+0.97j]]. SVD dá σ_max ≈ 1.35, σ_min ≈ 0.45. Interprete: ganho máximo moderado, robustez razoável.",
                              "finalVerifications": [
                                "Calcula corretamente SVD de G(jω) para ω dada.",
                                "Identifica σ_max e σ_min com precisão numérica <1%.",
                                "Descreve impacto de σ_min baixo em robustez.",
                                "Gera sigma plot coerente com análise.",
                                "Compara σ com normas H2/H∞ adequadamente.",
                                "Aplica em exemplo real sem erros conceituais."
                              ],
                              "assessmentCriteria": [
                                "Precisão matemática nos cálculos de SVD (90%+ correto).",
                                "Qualidade da interpretação para ganho/estabilidade (rubrica 4/5).",
                                "Uso correto de ferramentas computacionais.",
                                "Profundidade da análise de robustez.",
                                "Clareza em relatórios e plots.",
                                "Integração de conceitos MIMO vs SISO."
                              ],
                              "crossCurricularConnections": [
                                "Matemática Linear: SVD e normas de matrizes.",
                                "Processamento de Sinais: Análise em frequência.",
                                "Engenharia Mecânica: Controle de vibrações multivariáveis.",
                                "Inteligência Artificial: Robustez em redes neurais MIMO.",
                                "Física: Sistemas dinâmicos acoplados."
                              ],
                              "realWorldApplication": "Em controle de aeronaves (ex: fly-by-wire), análise de valores singulares avalia robustez contra falhas de sensores/atuadores, garantindo estabilidade em manobras com acoplamentos MIMO."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.7.2.2.3",
                            "name": "Explorar técnicas avançadas como H∞ para MIMO",
                            "description": "Entender a parametrização de controladores estabilizadores e o projeto H∞ para minimizar normas de robustez em sistemas MIMO.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Fundamentos de Sistemas MIMO e Estabilização",
                                  "subSteps": [
                                    "Estudar representações de plantas MIMO em espaço de estados e funções de transferência.",
                                    "Revisar o conceito de estabilidade em sistemas MIMO usando margens de ganho e fase generalizadas.",
                                    "Explorar a parametrização de Youla-Kucera para todos os controladores estabilizadores.",
                                    "Derivar a estrutura coprima para uma planta MIMO estável.",
                                    "Implementar um exemplo simples de estabilização em MATLAB."
                                  ],
                                  "verification": "Capacidade de listar todos os controladores estabilizadores para uma planta dada e plotar respostas em malha fechada.",
                                  "estimatedTime": "4 hours",
                                  "materials": [
                                    "Livro 'Robust and Optimal Control' de Zhou et al.",
                                    "MATLAB com Control System Toolbox",
                                    "Notas de aula sobre coprimos"
                                  ],
                                  "tips": "Comece com plantas 2x2 para visualizar acoplamentos; use comandos como 'coprim' no MATLAB.",
                                  "learningObjective": "Compreender a parametrização completa de controladores estabilizadores para sistemas MIMO.",
                                  "commonMistakes": [
                                    "Confundir coprimos esquerdos e direitos",
                                    "Ignorar normalizações biproprias",
                                    "Não verificar estabilidade interna"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Entender Normas H∞ e Problema de Robustez",
                                  "subSteps": [
                                    "Definir norma H∞ para operadores e seu significado em termos de ganho induzido.",
                                    "Estudar o lema de bounded real para sistemas estáveis.",
                                    "Formular o problema padrão H∞: minimizar ||Tzw||∞ sujeito a estabilidade.",
                                    "Analisar incertezas estruturadas (norma μ) vs. não estruturadas em MIMO.",
                                    "Calcular normas H∞ de funções de transferência MIMO usando singular values."
                                  ],
                                  "verification": "Computar a norma H∞ de um sistema MIMO dado e interpretar seu valor físico.",
                                  "estimatedTime": "5 hours",
                                  "materials": [
                                    "Documentação MATLAB Robust Control Toolbox",
                                    "Paper 'H∞ Control for MIMO Systems' de Doyle",
                                    "Software SigmaPlot para SV plots"
                                  ],
                                  "tips": "Use 'norm' e 'sigma' no MATLAB para visualização; foque em picos de valores singulares.",
                                  "learningObjective": "Dominar a interpretação de normas H∞ como medida de robustez em sistemas MIMO.",
                                  "commonMistakes": [
                                    "Confundir norma H2 com H∞",
                                    "Não considerar frequência em análises",
                                    "Ignorar o pior caso de perturbação"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Projeto de Controladores H∞ via Equações de Riccati",
                                  "subSteps": [
                                    "Formular o problema H∞ padrão com generalizados P, K, W1, W2, W3.",
                                    "Resolver as equações de Riccati diferenciais para condições de Hamilton-Jacobi.",
                                    "Implementar o algoritmo padrão de síntese H∞ no MATLAB (hinfsyn).",
                                    "Verificar estabilidade e performance do controlador sintetizado.",
                                    "Ajustar pesos de performance para trade-offs desejados."
                                  ],
                                  "verification": "Sintetizar um controlador H∞ para uma planta MIMO e plotar curvas de Bode de loops abertos.",
                                  "estimatedTime": "6 hours",
                                  "materials": [
                                    "MATLAB Robust Control Toolbox (hinfsyn)",
                                    "Exemplos do livro de Skogestad 'Multivariable Feedback Control'",
                                    "Computador com licença MATLAB"
                                  ],
                                  "tips": "Escolha pesos iniciais conservadores; itere com simulações para refinar.",
                                  "learningObjective": "Aplicar métodos numéricos para sintetizar controladores H∞ ótimos em MIMO.",
                                  "commonMistakes": [
                                    "Pesos mal escalados levando a soluções inviáveis",
                                    "Não centralizar a planta adequadamente",
                                    "Esquecer normalização de estados"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Simulação, Análise de Robustez e Validação",
                                  "subSteps": [
                                    "Simular respostas em malha fechada com perturbações e ruídos.",
                                    "Analisar robustez usando testes de estabilidade estruturada (μ-analysis).",
                                    "Comparar com controladores LQG ou H2 para trade-offs.",
                                    "Otimizar o controlador via loop shaping ou μ-synthesis se necessário.",
                                    "Documentar resultados com gráficos de singular values e simulações temporais."
                                  ],
                                  "verification": "Demonstrar que o sistema atende γ < 1 para robustez garantida em simulações.",
                                  "estimatedTime": "5 hours",
                                  "materials": [
                                    "MATLAB Mu Toolbox",
                                    "Simulink para simulações não lineares",
                                    "Templates de relatório LaTeX"
                                  ],
                                  "tips": "Use 'musyn' para μ-synthesis avançado; valide com Monte Carlo para não linearidades.",
                                  "learningObjective": "Avaliar e validar controladores H∞ em cenários realistas MIMO.",
                                  "commonMistakes": [
                                    "Sobre-otimizar ignorando complexidade do controlador",
                                    "Não testar com incertezas reais",
                                    "Interpretações erradas de μ-values"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Explorar Extensões e Aplicações Práticas",
                                  "subSteps": [
                                    "Estudar H∞ com restrições (gain-scheduling, anti-windup).",
                                    "Implementar em hardware como planta de laboratório MIMO.",
                                    "Analisar sensibilidade a atrasos e não linearidades.",
                                    "Comparar com métodos modernos como MPC ou data-driven.",
                                    "Preparar um case study completo."
                                  ],
                                  "verification": "Apresentar um relatório com controlador H∞ aplicado a um sistema real, mostrando robustez.",
                                  "estimatedTime": "4 hours",
                                  "materials": [
                                    "Quanser ou dSPACE para experimentos",
                                    "Papers IEEE sobre H∞ em aeroespacial",
                                    "Python Control Systems Library para cross-check"
                                  ],
                                  "tips": "Integre com Kalman filter para estimação; foque em ordem redução do controlador.",
                                  "learningObjective": "Conectar teoria H∞ a implementações práticas e extensões em MIMO.",
                                  "commonMistakes": [
                                    "Ignorar ordem alta do controlador",
                                    "Não considerar custo computacional",
                                    "Generalizações prematuras sem validação"
                                  ]
                                }
                              ],
                              "practicalExample": "Projeto de um controlador H∞ para um sistema de controle de atitude de um quadrotor (4 entradas torque, 3 saídas ângulos), minimizando efeitos de vento turbulento (incertezas aditivas) e garantindo rastreamento de trajetória com γ∞ < 1.2, usando MATLAB hinfsyn em uma planta 3x4 normalizada.",
                              "finalVerifications": [
                                "Explicar verbalmente a parametrização Youla e seu papel em H∞.",
                                "Sintetizar e simular um controlador H∞ para planta MIMO 2x2 fornecida.",
                                "Interpretar gráficos de singular values e confirmar ||Tzw||∞ < γ.",
                                "Discutir trade-offs entre performance e robustez em um exemplo.",
                                "Identificar quando H∞ é preferível a outros métodos.",
                                "Demonstrar μ-analysis para robustez estruturada."
                              ],
                              "assessmentCriteria": [
                                "Precisão na derivação de equações de Riccati (80% correto).",
                                "Qualidade das simulações: curvas suaves, análises completas (plots de tempo/freq).",
                                "Profundidade conceitual: explicações claras de normas e robustez.",
                                "Criatividade em pesos e extensões (além do básico).",
                                "Documentação: relatório estruturado com conclusões acionáveis.",
                                "Eficiência: tempo dentro do estimado, sem erros graves."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Álgebra linear (valores singulares), Equações diferenciais (Riccati).",
                                "Física: Dinâmica de sistemas multi-DOF, Modelagem de incertezas.",
                                "Programação: Otimização numérica (LMIs), Simulação (MATLAB/Simulink/Python).",
                                "Engenharia de Software: Validação e testes de controladores embarcados.",
                                "Economia: Trade-offs custo-performance em design robusto."
                              ],
                              "realWorldApplication": "Controle robusto de turbinas eólicas em fazendas offshore (MIMO com acoplamentos aerodinâmicos e falhas de atuadores), ou estabilização de satélites com perturbações gravitacionais, minimizando desvios de potência/orientação apesar de variações climáticas."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.7.2.3",
                        "name": "Diferenças Chave entre Abordagens SISO e MIMO",
                        "description": "Comparação detalhada das metodologias de modelagem, análise de estabilidade/desempenho e projeto de controladores entre sistemas escalares e multivariáveis.",
                        "specificSkills": [
                          {
                            "id": "10.1.7.2.3.1",
                            "name": "Comparar modelagem em SISO versus MIMO",
                            "description": "Contrastar funções de transferência escalares com matrizes de transferência em MIMO, destacando acoplamentos e necessidade de descentralização.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Fundamentos de Modelagem SISO",
                                  "subSteps": [
                                    "Defina SISO como sistema com uma entrada e uma saída única.",
                                    "Derive a função de transferência G(s) para um sistema simples, como um circuito RLC série.",
                                    "Represente o sistema no domínio do tempo e transforme para o domínio de Laplace.",
                                    "Analise pólos e zeros da função de transferência escalar.",
                                    "Simule a resposta a uma entrada degrau usando ferramentas como MATLAB."
                                  ],
                                  "verification": "Construa e plote a resposta de um sistema SISO simples, confirmando que coincide com a teoria.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Livro de controle clássico (ex: Ogata)",
                                    "MATLAB ou Python (Control Systems Library)",
                                    "Papel e lápis para derivações"
                                  ],
                                  "tips": [
                                    "Comece com sistemas de primeira ordem para simplicidade.",
                                    "Sempre verifique unidades nas equações diferenciais."
                                  ],
                                  "learningObjective": "Compreender a modelagem escalar em SISO e sua representação via funções de transferência.",
                                  "commonMistakes": [
                                    "Confundir entrada com saída no diagrama de blocos.",
                                    "Esquecer de linearizar equações não-lineares."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Introduzir Modelagem MIMO",
                                  "subSteps": [
                                    "Defina MIMO como sistema com múltiplas entradas e saídas.",
                                    "Derive a matriz de transferência G(s) para um sistema 2x2, como dois tanques acoplados.",
                                    "Identifique elementos diagonais (ganhos diretos) e fora da diagonal (acoplamentos).",
                                    "Represente o sistema em espaço de estados e converta para forma de transferência.",
                                    "Simule respostas cruzadas em software para visualizar interações."
                                  ],
                                  "verification": "Obtenha uma matriz de transferência 2x2 válida e plote respostas para entradas individuais.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Software MATLAB/Simulink",
                                    "Exemplos de sistemas multivariáveis (artigos ou notas de aula)",
                                    "Calculadora matricial"
                                  ],
                                  "tips": [
                                    "Use notação matricial consistente (ex: G_{11}(s) para canal 1->1).",
                                    "Verifique simetria em sistemas físicos reais."
                                  ],
                                  "learningObjective": "Dominar a construção de matrizes de transferência em sistemas MIMO.",
                                  "commonMistakes": [
                                    "Ignorar termos de acoplamento fora da diagonal.",
                                    "Confundir ordem das entradas/saídas na matriz."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Comparar Estruturas de Modelagem SISO vs MIMO",
                                  "subSteps": [
                                    "Liste diferenças: escalar G(s) vs matriz G(s) [m x n].",
                                    "Compare análise de estabilidade: Routh-Hurwitz escalar vs critérios para matrizes.",
                                    "Discuta acoplamentos: ausentes em SISO, presentes em MIMO via G_{12}, G_{21}.",
                                    "Analise controle descentralizado: controladores diagonais em MIMO.",
                                    "Crie uma tabela comparativa de prós/contras de cada abordagem."
                                  ],
                                  "verification": "Preencha uma tabela comparativa precisa e discuta com um colega ou grave uma explicação.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Planilha ou documento para tabela",
                                    "Ferramentas de plotagem (MATLAB)",
                                    "Referências teóricas sobre MIMO"
                                  ],
                                  "tips": [
                                    "Use exemplos numéricos para ilustrar diferenças.",
                                    "Foque em implicações práticas, não só matemáticas."
                                  ],
                                  "learningObjective": "Identificar e contrastar diferenças fundamentais na modelagem SISO e MIMO.",
                                  "commonMistakes": [
                                    "Subestimar impacto dos acoplamentos em estabilidade.",
                                    "Aplicar métodos SISO diretamente a MIMO sem ajustes."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar Implicações e Necessidade de Descentralização",
                                  "subSteps": [
                                    "Quantifique acoplamento usando índices como Bristol relative gain.",
                                    "Simule controle centralizado vs descentralizado em um exemplo MIMO.",
                                    "Discuta quando descentralização é viável (acoplamentos fracos).",
                                    "Explore limitações: singularidades em matrizes de transferência MIMO.",
                                    "Avalie trade-offs em robustez e complexidade computacional."
                                  ],
                                  "verification": "Simule e compare desempenho de loops descentralizados vs centralizados em um caso estudo.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Simulink para simulações MIMO",
                                    "Artigos sobre controle descentralizado",
                                    "Software de análise de acoplamento (ex: MATLAB Relative Gain Array)"
                                  ],
                                  "tips": [
                                    "Escolha exemplos com acoplamento moderado para demonstrar efeitos.",
                                    "Registre métricas como overshoot e tempo de estabilização."
                                  ],
                                  "learningObjective": "Compreender necessidades de estratégias de controle em MIMO devido a acoplamentos.",
                                  "commonMistakes": [
                                    "Assumir independência de canais sem verificação.",
                                    "Ignorar efeitos não-lineares em simulações lineares."
                                  ]
                                }
                              ],
                              "practicalExample": "Considere dois tanques acoplados por uma tubulação: em SISO, modele apenas nível de um tanque (G(s) escalar); em MIMO, modele níveis de ambos com matriz 2x2 mostrando fluxo cruzado. Simule entrada de vazão em tanque 1 afetando nível do tanque 2.",
                              "finalVerifications": [
                                "Explique verbalmente diferenças entre função de transferência escalar e matricial.",
                                "Construa matriz de transferência para um sistema MIMO 2x2 simples.",
                                "Identifique acoplamentos em uma matriz dada e proponha descentralização.",
                                "Compare estabilidade de SISO vs MIMO usando exemplos.",
                                "Simule e interprete respostas cruzadas corretamente.",
                                "Discuta limitações da modelagem SISO para sistemas reais multivariáveis."
                              ],
                              "assessmentCriteria": [
                                "Precisão na derivação de funções/matrizes de transferência (80% correto).",
                                "Identificação correta de acoplamentos e implicações (ex: RGA > 0.5).",
                                "Análise qualitativa/quantitativa comparativa clara e estruturada.",
                                "Uso adequado de simulações para validar comparações.",
                                "Compreensão de descentralização: quando usar e limitações.",
                                "Tabela ou diagrama comparativo completo e lógico."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Álgebra linear (matrizes, autovalores para análise MIMO).",
                                "Física: Dinâmica de sistemas fluidos/mecânicos com múltiplas variáveis.",
                                "Informática: Programação em MATLAB/Python para simulações multivariáveis.",
                                "Engenharia de Processos: Modelagem de plantas industriais acopladas."
                              ],
                              "realWorldApplication": "Em uma planta química com reatores acoplados, modelagem MIMO permite prever interações entre temperaturas/pressões, guiando controladores descentralizados para operação segura e eficiente, evitando oscilações devido a acoplamentos ignorados em abordagens SISO."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.7.2.3.2",
                            "name": "Analisar diferenças em critérios de estabilidade",
                            "description": "Comparar testes escalares (Nyquist/Bode) com MIMO (valores singulares, μ-análise), identificando desafios de direccionalidade em MIMO.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Critérios de Estabilidade em Sistemas SISO",
                                  "subSteps": [
                                    "Relembrar os diagramas de Bode e critérios de Nyquist para estabilidade SISO.",
                                    "Calcular margens de ganho e fase usando Bode para um sistema exemplo.",
                                    "Aplicar teste de Nyquist para contornar o ponto crítico (-1,0).",
                                    "Identificar condições de estabilidade absoluta e relativa em SISO.",
                                    "Praticar com um laço de feedback unitário simples."
                                  ],
                                  "verification": "Gerar diagramas Bode/Nyquist corretos sem erros de encirculamento para um sistema dado.",
                                  "estimatedTime": "1 hora",
                                  "materials": "MATLAB/Simulink, MATLAB Control System Toolbox, notas de aula sobre controle SISO.",
                                  "tips": "Sempre normalize o ganho para facilitar a análise visual nos diagramas.",
                                  "learningObjective": "Compreender e aplicar testes escalares de estabilidade em sistemas monovariáveis.",
                                  "commonMistakes": "Confundir margem de fase com ganho; ignorar a direção do contorno no Nyquist."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Introduzir Critérios de Estabilidade em Sistemas MIMO",
                                  "subSteps": [
                                    "Calcular valores singulares de uma matriz de transferência MIMO usando SVD.",
                                    "Explicar o papel do valor singular máximo (σ_max) na robustez de estabilidade.",
                                    "Introduzir μ-análise para incertezas estruturadas em MIMO.",
                                    "Comparar singular values com normas H-infinito para estabilidade.",
                                    "Simular uma planta MIMO simples e plotar singular values."
                                  ],
                                  "verification": "Plotar valores singulares corretos e identificar σ_max <1 para estabilidade.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": "MATLAB Robust Control Toolbox, exemplos de matrizes MIMO de textbooks como Skogestad.",
                                  "tips": "Use svd() no MATLAB para decomposição rápida; foque em frequências críticas.",
                                  "learningObjective": "Dominar ferramentas MIMO como valores singulares e μ para análise de estabilidade.",
                                  "commonMistakes": "Confundir valores singulares com autovalores; negligenciar a dependência de frequência."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Comparar Critérios SISO vs MIMO",
                                  "subSteps": [
                                    "Mapear equivalências: Bode/Nyquist escalares vs singular values MIMO.",
                                    "Analisar limitações dos métodos SISO em sistemas acoplados MIMO.",
                                    "Realizar análise comparativa em um sistema 2x2 MIMO.",
                                    "Destacar quando SISO falha em capturar interações MIMO.",
                                    "Documentar tabela de diferenças chave (escalar vs matricial)."
                                  ],
                                  "verification": "Criar tabela comparativa precisa com exemplos numéricos validados.",
                                  "estimatedTime": "1 hora",
                                  "materials": "Planilha Excel ou LaTeX para tabela, MATLAB para simulações paralelas.",
                                  "tips": "Escolha sistemas com acoplamento forte para evidenciar diferenças.",
                                  "learningObjective": "Identificar discrepâncias fundamentais entre abordagens escalares e MIMO.",
                                  "commonMistakes": "Superestimar a aplicabilidade de SISO em MIMO; ignorar não-minimum phase."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar Desafios de Direccionalidade em MIMO",
                                  "subSteps": [
                                    "Explicar direccionalidade via vetores singulares esquerdo/direito.",
                                    "Simular direções sensíveis em uma matriz MIMO com incertezas.",
                                    "Aplicar μ-análise para quantificar direccionalidade em estabilidade.",
                                    "Discutir impactos em design de controladores descentralizados vs multivariáveis.",
                                    "Testar com exemplo real: acoplamento em um processo químico 2x2."
                                  ],
                                  "verification": "Identificar e mitigar uma direção instável via análise de vetores singulares.",
                                  "estimatedTime": "1 hora",
                                  "materials": "MATLAB com mu toolbox, paper exemplo de direccionalidade (e.g., Bristol RGA).",
                                  "tips": "Visualize vetores singulares com quiver plots para intuição geométrica.",
                                  "learningObjective": "Reconhecer e analisar desafios de direccionalidade exclusivos de MIMO.",
                                  "commonMistakes": "Ignorar fase nos valores singulares; assumir isotropia direcional."
                                }
                              ],
                              "practicalExample": "Considere um sistema MIMO 2x2 de um tanque duplo em série (modelo clássico): compare estabilidade via Bode diagonal (SISO approx.) vs singular values completos. Note como Nyquist SISO erra direções acopladas, mas μ detecta instabilidade direcional em 10 rad/s.",
                              "finalVerifications": [
                                "Diagramas Bode/Nyquist gerados corretamente para SISO e validados.",
                                "Valores singulares e μ plotados com σ_max <1 em todo espectro.",
                                "Tabela comparativa completa sem erros conceituais.",
                                "Análise de direccionalidade identifica pelo menos uma direção crítica.",
                                "Simulação confirma estabilidade/ instabilidade prevista.",
                                "Relatório resume diferenças chave com evidências numéricas."
                              ],
                              "assessmentCriteria": [
                                "Precisão na distinção entre testes escalares e MIMO (90%+ correto).",
                                "Uso correto de ferramentas (SVD, μ) sem erros computacionais.",
                                "Profundidade na análise de direccionalidade com vetores singulares.",
                                "Clareza na tabela comparativa e exemplos práticos.",
                                "Capacidade de identificar falhas SISO em cenários MIMO reais.",
                                "Aplicação conceitual a novos sistemas sem orientação."
                              ],
                              "crossCurricularConnections": [
                                "Álgebra Linear: Decomposição SVD e normas matriciais.",
                                "Matemática Numérica: Análise de valores singulares em software.",
                                "Engenharia de Software: Implementação em MATLAB para simulações.",
                                "Física: Modelagem de sistemas acoplados dinâmicos."
                              ],
                              "realWorldApplication": "Em controle de aeronaves, análise MIMO com singular values garante estabilidade direcional contra rajadas de vento assimétricas, onde métodos SISO falhariam ao ignorar acoplamento roll-yaw."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.7.2.3.3",
                            "name": "Contrastar técnicas de projeto e robustez",
                            "description": "Diferenciar projeto clássico (PID, lead-lag) de SISO com métodos como LQG, H∞ e μ-síntese em MIMO, enfatizando robustez a incertezas estruturadas.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Fundamentos de Controle Clássico SISO",
                                  "subSteps": [
                                    "Estudar o controlador PID: componentes proporcional, integral e derivativo, e sua aplicação em laços de feedback unitário.",
                                    "Analisar compensadores lead-lag: design via diagramas de Bode para melhoria de fase e ganho.",
                                    "Derivar funções de transferência SISO simples e plotar respostas em malha fechada.",
                                    "Simular um sistema SISO básico em software como MATLAB/Simulink.",
                                    "Identificar limitações inerentes do SISO em sistemas acoplados."
                                  ],
                                  "verification": "Plotar e interpretar diagramas de Bode e Nyquist para um controlador PID/lead-lag projetado.",
                                  "estimatedTime": "2 horas",
                                  "materials": "Livro de Ogata 'Engenharia de Controle Moderno', MATLAB/Simulink, tutoriais online de controle clássico.",
                                  "tips": "Comece com exemplos simples como controle de posição de um motor DC para fixar conceitos.",
                                  "learningObjective": "Compreender os princípios de design clássico SISO e suas ferramentas gráficas.",
                                  "commonMistakes": "Confundir estabilidade com desempenho; ignorar saturação de atuadores em simulações."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Introduzir Métodos Avançados de Controle MIMO",
                                  "subSteps": [
                                    "Estudar LQG: combinação de LQR com filtro de Kalman para otimização estocástica.",
                                    "Explorar H∞: síntese ótima em norma H-infinito para minimizar pior caso de perturbações.",
                                    "Analisar μ-síntese: robustez a incertezas estruturadas via análise de valor estrutural μ.",
                                    "Comparar representações: de funções de transferência SISO para matrizes de transferência MIMO.",
                                    "Implementar um exemplo MIMO simples em MATLAB usando toolbox Robust Control."
                                  ],
                                  "verification": "Gerar um controlador LQG ou H∞ para um sistema MIMO 2x2 e verificar estabilidade via singular values.",
                                  "estimatedTime": "3 horas",
                                  "materials": "Livro de Skogestad 'Multivariable Feedback Control', MATLAB Robust Control Toolbox, artigos introdutórios sobre LQG/H∞.",
                                  "tips": "Use funções prontas como 'lqg' e 'hinfsyn' no MATLAB para focar no entendimento conceitual.",
                                  "learningObjective": "Dominar os princípios matemáticos e computacionais dos métodos MIMO avançados.",
                                  "commonMistakes": "Negligenciar o modelo de ruído em LQG; confundir norma H2 com H∞."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Comparar Técnicas de Projeto SISO vs MIMO",
                                  "subSteps": [
                                    "Listar diferenças chave: univariável vs multivariável, design sequencial vs simultâneo.",
                                    "Contrastar critérios: ganho/fase margins (SISO) vs singular values e condicionamento (MIMO).",
                                    "Avaliar trade-offs: simplicidade SISO vs performance MIMO em acoplamento.",
                                    "Criar tabela comparativa de PID/lead-lag vs LQG/H∞/μ.",
                                    "Simular o mesmo sistema em ambas abordagens e comparar respostas."
                                  ],
                                  "verification": "Produzir uma tabela e gráficos comparativos mostrando superioridade MIMO em cenários acoplados.",
                                  "estimatedTime": "2.5 horas",
                                  "materials": "Planilhas Excel/Google Sheets para tabelas, Simulink para simulações comparativas.",
                                  "tips": "Escolha um benchmark como o sistema de Wien automatic control para comparações padronizadas.",
                                  "learningObjective": "Identificar e justificar diferenças no processo de design entre SISO e MIMO.",
                                  "commonMistakes": "Superestimar robustez SISO em sistemas com acoplamento forte; ignorar custo computacional MIMO."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Enfatizar Robustez a Incertezas Estruturadas",
                                  "subSteps": [
                                    "Definir incertezas estruturadas: blocos normais vs não-normais, perturbações dinâmicas.",
                                    "Comparar análise: margins clássicos limitados vs μ-analysis para robustez estruturada.",
                                    "Aplicar μ-síntese: iterar D-K para sintetizar controlador robusto.",
                                    "Testar sensibilidade: introduzir variações paramétricas e medir desempenho.",
                                    "Avaliar estabilidade robusta via lower bound de μ."
                                  ],
                                  "verification": "Calcular μ para um sistema MIMO com incertezas e confirmar robustez <1.",
                                  "estimatedTime": "3 horas",
                                  "materials": "MATLAB Mu Toolbox, exemplos do livro de Doyle 'Robust and Optimal Control'.",
                                  "tips": "Comece com incertezas escalares para transitar para estruturadas.",
                                  "learningObjective": "Compreender como métodos MIMO quantificam e garantem robustez superior.",
                                  "commonMistakes": "Confundir incertezas não-estruturadas com estruturadas; subestimar conservadorismo da μ-síntese."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Sintetizar e Aplicar o Contraste",
                                  "subSteps": [
                                    "Resumir prós/contras: SISO para simplicidade, MIMO para robustez em complexidade.",
                                    "Discutir critérios de escolha: baseado em acoplamento, incertezas e requisitos.",
                                    "Criar fluxograma de decisão para seleção de método.",
                                    "Aplicar em case study: converter SISO para MIMO em um processo industrial.",
                                    "Autoavaliar compreensão via quiz comparativo."
                                  ],
                                  "verification": "Desenvolver um fluxograma e explicar verbalmente ou por escrito as diferenças chave.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": "Ferramentas de diagramação como Draw.io, quiz online auto-gerado.",
                                  "tips": "Use mnemônicos como 'SISO: Simples, Isolado; MIMO: Multivariado, Robusto'.",
                                  "learningObjective": "Integrar conhecimentos para contrastar efetivamente técnicas e robustez.",
                                  "commonMistakes": "Generalizar demais sem contexto específico do sistema."
                                }
                              ],
                              "practicalExample": "Em um braço robótico de 2 juntas (MIMO 2x2), use PID SISO por junta (falha em acoplamento) vs LQG/H∞ (mantém trajetória apesar de variações de massa/inércia). Simule no Simulink com perturbações estruturadas.",
                              "finalVerifications": [
                                "Explicar verbalmente 3 diferenças chave entre PID e H∞ em robustez.",
                                "Calcular margins clássicos vs μ para um sistema dado.",
                                "Simular e comparar step responses SISO vs MIMO com incertezas.",
                                "Identificar quando μ-síntese é preferível sobre lead-lag.",
                                "Criar tabela comparativa precisa sem consulta.",
                                "Discutir limitações de cada método em um cenário real."
                              ],
                              "assessmentCriteria": [
                                "Precisão conceitual: distinção correta entre métodos SISO/MIMO (30%).",
                                "Profundidade em robustez: análise de incertezas estruturadas (25%).",
                                "Uso de ferramentas: simulações e cálculos corretos (20%).",
                                "Síntese comparativa: tabela/fluxograma clara e completa (15%).",
                                "Aplicação prática: exemplo relevante e insights (10%)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Álgebra linear (matrizes de transferência, valores singulares).",
                                "Programação: MATLAB/Simulink para síntese e análise de controle.",
                                "Física: Dinâmica de sistemas multivariáveis e teoria de controle ótimo.",
                                "Engenharia de Software: Modelagem e validação de modelos incertos."
                              ],
                              "realWorldApplication": "Na indústria aeroespacial, como controle de atitude de satélites (MIMO com μ-síntese para robustez a incertezas de massa não-estruturadas), superando PID SISO que falha em acoplamentos dinâmicos."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.7.2.3.4",
                            "name": "Avaliar impacto de interações em MIMO",
                            "description": "Identificar e quantificar efeitos de acoplamento em sistemas MIMO ausentes em SISO, usando ferramentas como Bristol relative gain array (RGA).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender Fundamentos de Sistemas SISO e MIMO",
                                  "subSteps": [
                                    "Revise definições de sistemas SISO (Single Input Single Output) e MIMO (Multiple Input Multiple Output).",
                                    "Identifique diferenças chave: ausência de interações em SISO vs presença de acoplamentos em MIMO.",
                                    "Estude exemplos simples de matrizes de transferência para MIMO.",
                                    "Analise como interações afetam a controlabilidade e estabilidade.",
                                    "Compare diagramas de bloco SISO e MIMO."
                                  ],
                                  "verification": "Resuma em um parágrafo as diferenças principais e liste 3 exemplos de interações em MIMO.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Livro de controle avançado (ex: Ogata ou Franklin)",
                                    "Notas de aula sobre PS-76",
                                    "Vídeos introdutórios no YouTube sobre MIMO"
                                  ],
                                  "tips": "Use diagramas visuais para mapear interações; foque em loops cruzados.",
                                  "learningObjective": "Diferenciar interações em SISO vs MIMO e reconhecer seus impactos iniciais.",
                                  "commonMistakes": [
                                    "Confundir acoplamento com não-linearidade",
                                    "Ignorar direções de interações (feedforward vs feedback)"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Aprender o Conceito de Bristol Relative Gain Array (RGA)",
                                  "subSteps": [
                                    "Estude a definição de RGA: λ_ij = (∂y_i/∂u_j)_loop off / (∂y_i/∂u_j)_steady state.",
                                    "Entenda a interpretação: λ=1 (independente), λ>1 (interação positiva), 0<λ<1 (interação negativa).",
                                    "Revise propriedades: soma de linhas e colunas =1, RGA(I)=I.",
                                    "Assista tutoriais sobre cálculo de RGA para matrizes 2x2 e nx n.",
                                    "Pratique interpretação qualitativa de RGAs de exemplo."
                                  ],
                                  "verification": "Explique verbalmente ou por escrito o significado de λ=0.5 e λ=2 em um pairing.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Artigo original de Bristol (1966)",
                                    "MATLAB ou Python (Control Systems Toolbox)",
                                    "Slides sobre análise de interações MIMO"
                                  ],
                                  "tips": "Memorize fórmula elementar; pratique com calculadora matricial.",
                                  "learningObjective": "Dominar a teoria e interpretação do RGA como métrica de interação.",
                                  "commonMistakes": [
                                    "Esquecer normalização pela condição estacionária",
                                    "Interpretar magnitude sem sinal"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular RGA para um Sistema MIMO Simples",
                                  "subSteps": [
                                    "Selecione um sistema MIMO 2x2 com matriz de transferência conhecida (ex: dois tanques acoplados).",
                                    "Calcule a matriz de ganhos em estado estacionário (G(0)).",
                                    "Aplique fórmula RGA: elemento a elemento, λ_ij = g_ij * (G^{-1})_ji.",
                                    "Implemente em software: MATLAB (rga(G)) ou Python (control.rga).",
                                    "Valide cálculo manual vs software."
                                  ],
                                  "verification": "Produza RGA correta para um sistema dado e compare com referência.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "MATLAB/Octave ou Python com numpy/control",
                                    "Exemplos de matrizes G de tutoriais",
                                    "Calculadora matricial online"
                                  ],
                                  "tips": "Comece com 2x2; inverta matriz manualmente para entender.",
                                  "learningObjective": "Executar cálculos precisos de RGA manual e computacionalmente.",
                                  "commonMistakes": [
                                    "Erro na inversão de matriz",
                                    "Usar frequência errada (sempre DC para RGA clássico)"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Interpretar RGA e Avaliar Impacto de Interações",
                                  "subSteps": [
                                    "Analise RGA para recomendar pares de loops (maior λ próximo de 1).",
                                    "Quantifique impacto: interações fortes se |λ| >>1 ou próximo de 0.",
                                    "Compare com SISO: simule descentralizado vs centralizado.",
                                    "Avalie robustez: RGA em diferentes frequências se aplicável.",
                                    "Documente relatório com conclusões sobre viabilidade de controle descentralizado."
                                  ],
                                  "verification": "Recomende pairing para um RGA dado e justifique com thresholds (ex: |λ|<0.5 evitar).",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Simulador Simulink para MIMO",
                                    "Templates de relatório",
                                    "Casos de estudo industriais"
                                  ],
                                  "tips": "Use regra: evite pairings com λ negativo; priorize diagonais se RGA diagonal dominante.",
                                  "learningObjective": "Avaliar quantitativamente impactos e propor soluções de controle.",
                                  "commonMistakes": [
                                    "Ignorar condicionalidade de RGA em operação",
                                    "Sobre-generalizar de um exemplo"
                                  ]
                                }
                              ],
                              "practicalExample": "Considere um sistema de dois tanques acoplados quimicamente: G(s) = [[1/(s+1), 0.5/(s+1)]; [0.5/(s+2), 1/(s+2)]]. Calcule RGA em s=0, obtenha λ11=1.33, indicando interação positiva forte no pairing diagonal. Avalie que controle descentralizado pode ser desafiador devido a acoplamento.",
                              "finalVerifications": [
                                "Calcula RGA corretamente para matriz 2x2 manualmente.",
                                "Interpreta todos elementos de RGA com precisão.",
                                "Identifica pairings ótimos e ruins baseados em RGA.",
                                "Compara impacto em MIMO vs aproximação SISO.",
                                "Simula e valida efeitos de interações em software.",
                                "Documenta análise com gráficos de RGA."
                              ],
                              "assessmentCriteria": [
                                "Precisão no cálculo de RGA (erro <1%).",
                                "Interpretação correta de interações (thresholds aplicados).",
                                "Recomendações de pairing justificadas (>80% alinhadas com referências).",
                                "Integração de SISO vs MIMO em análise.",
                                "Uso eficaz de ferramentas computacionais.",
                                "Relatório claro e estruturado."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Álgebra linear (inversão de matrizes, multiplicação elemento-sabida).",
                                "Programação: Implementação em MATLAB/Python para automação de análises.",
                                "Física: Modelagem de sistemas dinâmicos reais (fluidos, química).",
                                "Engenharia de Software: Validação numérica e simulação.",
                                "Estatística: Análise de sensibilidade em parâmetros."
                              ],
                              "realWorldApplication": "Em plantas químicas, como destilação binária, RGA avalia interações entre níveis e composições para design de controladores descentralizados, evitando instabilidades em refinarias ou processos petroquímicos."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.7.3",
                    "name": "Acoplamento entre Canais",
                    "description": "Explicação do fenômeno de interação entre entradas e saídas em sistemas multivariáveis.",
                    "individualConcepts": [
                      {
                        "id": "10.1.7.3.1",
                        "name": "Definição de Acoplamento entre Canais",
                        "description": "Conceito fundamental que descreve a interação não desejada entre entradas e saídas em sistemas multivariáveis, onde uma entrada afeta múltiplas saídas e vice-versa.",
                        "specificSkills": [
                          {
                            "id": "10.1.7.3.1.1",
                            "name": "Definir acoplamento em sistemas multivariáveis",
                            "description": "Explicar o fenômeno de acoplamento como a dependência entre canais de entrada e saída, diferenciando de sistemas escalares independentes, com exemplos simples como plantas químicas.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Sistemas Monovariáveis e Introduzir Multivariáveis",
                                  "subSteps": [
                                    "Defina um sistema monovariável: uma entrada controla uma saída única sem interferências.",
                                    "Descreva a representação matemática básica (função de transferência G(s)).",
                                    "Introduza sistemas multivariáveis: múltiplas entradas (u1, u2) e saídas (y1, y2).",
                                    "Discuta matriz de transferência G(s) = [G11 G12; G21 G22].",
                                    "Compare independência em sistemas escalares vs potenciais dependências."
                                  ],
                                  "verification": "Crie um diagrama simples distinguindo monovariável de multivariável e explique verbalmente.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Software de diagramação como Draw.io",
                                    "Video introdutório sobre controle de sistemas (YouTube)"
                                  ],
                                  "tips": "Use setas para entradas/saídas para visualizar interações.",
                                  "learningObjective": "Diferenciar sistemas monovariáveis de multivariáveis conceitualmente.",
                                  "commonMistakes": [
                                    "Confundir número de entradas com acoplamento",
                                    "Ignorar representação matricial"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Definir o Conceito de Acoplamento",
                                  "subSteps": [
                                    "Defina acoplamento: dependência entre canais onde uma entrada afeta múltiplas saídas (G12 ≠ 0, G21 ≠ 0).",
                                    "Explique acoplamento direto (off-diagonal elements) vs diagonal dominante.",
                                    "Discuta fenômenos: mudança em u1 afeta y2 inesperadamente.",
                                    "Classifique: forte (off-diagonais grandes) vs fraco (off-diagonais pequenos).",
                                    "Relacione com equações diferenciais multivariáveis."
                                  ],
                                  "verification": "Escreva a definição em suas palavras e identifique off-diagonais em uma matriz de exemplo.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Folha de cálculo MATLAB ou Python (NumPy)",
                                    "Livro de controle como Ogata"
                                  ],
                                  "tips": "Pense em 'vazamento' de sinal entre canais.",
                                  "learningObjective": "Compreender acoplamento como dependência inter-canal.",
                                  "commonMistakes": [
                                    "Confundir com não-linearidade",
                                    "Assumir acoplamento só em não-lineares"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Diferenciar de Sistemas Escalares Independentes",
                                  "subSteps": [
                                    "Descreva sistema independente: G12 = G21 = 0, controle descentralizado possível.",
                                    "Compare respostas: em independentes, SISO isolados; em acoplados, MIMO interdependente.",
                                    "Analise impacto no controle: loops cruzados em acoplados requerem compensação.",
                                    "Use ganho relativo (RGA) para quantificar: λij = Gij * (adj G)ji / det G.",
                                    "Discuta quando ignorar acoplamento (fraco).",
                                    "Simule numericamente uma matriz diagonal vs acoplada."
                                  ],
                                  "verification": "Calcule RGA para matrizes exemplo e interprete.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "MATLAB/Simulink ou Octave",
                                    "Calculadora matricial online"
                                  ],
                                  "tips": "RGA >1 indica acoplamento forte.",
                                  "learningObjective": "Distinguir acoplamento de independência com métricas.",
                                  "commonMistakes": [
                                    "Ignorar sinal de off-diagonais",
                                    "Confundir com estabilidade"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar com Exemplos Simples como Plantas Químicas",
                                  "subSteps": [
                                    "Exemplo: Tanque duplo série - fluxo u1 afeta níveis y1 e y2 (acoplado).",
                                    "Desenhe diagrama de blocos para planta química (destilador: pressão u1 afeta composição y2).",
                                    "Simule resposta passo: mostre spillover entre canais.",
                                    "Compare com sistema independente hipotético.",
                                    "Discuta implicações em automação industrial."
                                  ],
                                  "verification": "Desenhe e explique um exemplo químico com acoplamento identificado.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Simulink ou Python (control library)",
                                    "Imagens de plantas químicas"
                                  ],
                                  "tips": "Use exemplos físicos intuitivos como engrenagens conectadas.",
                                  "learningObjective": "Ilustrar acoplamento com casos reais.",
                                  "commonMistakes": [
                                    "Escolher exemplos não-multivariáveis",
                                    "Não quantificar acoplamento"
                                  ]
                                }
                              ],
                              "practicalExample": "Em uma planta química de dois tanques em série, a vazão de entrada no tanque 1 (u1) controla o nível y1, mas também afeta o nível y2 no tanque 2 devido ao fluxo contínuo (G12 ≠ 0). Ajustar u1 causa oscilação em y2, demonstrando acoplamento.",
                              "finalVerifications": [
                                "Explique acoplamento sem olhar notas.",
                                "Identifique off-diagonais em matriz de transferência dada.",
                                "Diferencie de sistema independente com exemplo.",
                                "Calcule RGA simples e interprete.",
                                "Descreva impacto em controle descentralizado.",
                                "Forneça exemplo químico com diagrama."
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição de acoplamento (dependência inter-canal).",
                                "Correta diferenciação monovariável/multivariável.",
                                "Uso apropriado de matrizes e RGA.",
                                "Exemplos relevantes e diagramas claros.",
                                "Compreensão de implicações no controle.",
                                "Ausência de confusões comuns (ex: linearidade)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Álgebra linear (matrizes, determinantes).",
                                "Física: Dinâmica de fluidos em plantas químicas.",
                                "Química: Processos de reatores e destiladores.",
                                "Informática: Simulação em MATLAB/Python.",
                                "Economia: Otimização de processos industriais."
                              ],
                              "realWorldApplication": "No controle de refinarias de petróleo, acoplamento entre temperatura e pressão em colunas de destilação requer controladores MIMO para evitar instabilidades, otimizando produção e segurança."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.7.3.1.2",
                            "name": "Identificar ausência de acoplamento",
                            "description": "Reconhecer sistemas desacoplados onde a matriz de transferência é diagonal, e contrastar com sistemas acoplados reais, usando diagramas de bloco.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os Fundamentos de Sistemas Multivariáveis e Matriz de Transferência",
                                  "subSteps": [
                                    "Revise o conceito de sistemas multivariáveis com múltiplas entradas (u) e saídas (y).",
                                    "Estude a matriz de transferência G(s), onde G_ij(s) relaciona a saída i à entrada j.",
                                    "Identifique que em sistemas desacoplados, G(s) é diagonal (G_ij = 0 para i ≠ j).",
                                    "Pratique escrevendo uma matriz de transferência diagonal simples para 2x2.",
                                    "Compare com matriz não-diagonal para visualizar cross-coupling."
                                  ],
                                  "verification": "Construa uma matriz de transferência diagonal e explique por que os elementos fora da diagonal são zero.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Livro-texto de Controle Multivariável (cap. 1)",
                                    "Software MATLAB/Simulink para plotar matrizes",
                                    "Papel e caneta para esboços"
                                  ],
                                  "tips": "Use notação G(s) = diag[G11(s), G22(s)] para memorizar diagonalidade.",
                                  "learningObjective": "Entender a representação matemática da ausência de acoplamento via matriz diagonal.",
                                  "commonMistakes": [
                                    "Confundir matriz de transferência com matriz de estado",
                                    "Ignorar o domínio de Laplace (s)"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Definir e Contrastar Acoplamento e Desacoplamento",
                                  "subSteps": [
                                    "Defina acoplamento: quando mudança em uma entrada afeta saídas não correspondentes.",
                                    "Descreva ausência de acoplamento: cada entrada afeta apenas sua saída correspondente.",
                                    "Estude exemplos reais: subsistemas independentes vs. interdependentes.",
                                    "Crie uma tabela comparativa: desacoplado (diagonal) vs. acoplado (off-diagonal).",
                                    "Discuta implicações: controle mais simples em desacoplados."
                                  ],
                                  "verification": "Explique verbalmente ou por escrito a diferença entre sistemas acoplados e desacoplados com um exemplo.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Slides ou vídeo sobre acoplamento em controles (YouTube/Khan Academy)",
                                    "Tabela comparativa em Excel/Google Sheets"
                                  ],
                                  "tips": "Pense em 'independência' como ausência de setas cruzadas em diagramas.",
                                  "learningObjective": "Reconhecer conceitualmente a ausência de acoplamento como independência entre canais.",
                                  "commonMistakes": [
                                    "Assumir desacoplamento baseado apenas em diagramas sem matriz",
                                    "Confundir com linearidade do sistema"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar Diagramas de Bloco para Identificar Ausência de Acoplamento",
                                  "subSteps": [
                                    "Desenhe diagramas de bloco para sistemas 2x2 desacoplados (sem caminhos cruzados).",
                                    "Identifique caminhos de sinal: ausência de conexões entre canais diferentes.",
                                    "Converta diagrama de bloco em matriz de transferência e verifique diagonalidade.",
                                    "Analise um diagrama acoplado e remova cross-paths para simular desacoplamento.",
                                    "Use software para simular respostas e confirmar independência."
                                  ],
                                  "verification": "Desenhe um diagrama de bloco desacoplado e derive sua matriz diagonal.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Ferramenta de desenho (Draw.io ou Visio)",
                                    "MATLAB para simulação de blocos",
                                    "Exemplos de diagramas impressos"
                                  ],
                                  "tips": "Procure por 'setas cruzadas' nos diagramas; sua ausência indica desacoplamento.",
                                  "learningObjective": "Usar diagramas de bloco para visualmente detectar ausência de acoplamento.",
                                  "commonMistakes": [
                                    "Ignorar realimentações que criam acoplamento indireto",
                                    "Não normalizar entradas/saídas"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Praticar Identificação em Exemplos e Exercícios",
                                  "subSteps": [
                                    "Resolva 3 exercícios: classifique matrizes/diagramas como acoplados ou não.",
                                    "Simule em software: aplique entrada em u1 e verifique impacto só em y1.",
                                    "Crie seu próprio exemplo desacoplado (ex: dois motores independentes).",
                                    "Compare respostas em malha aberta para confirmar diagonalidade.",
                                    "Registre observações em um relatório curto."
                                  ],
                                  "verification": "Classifique corretamente 5 exemplos mistos (acoplados/desacoplados) com justificativa.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Lista de exercícios (PDF com 10 problemas)",
                                    "Simulink/MATLAB para testes dinâmicos"
                                  ],
                                  "tips": "Teste perturbando uma entrada e observando todas as saídas.",
                                  "learningObjective": "Aplicar conhecimento para identificar ausência de acoplamento em cenários variados.",
                                  "commonMistakes": [
                                    "Não considerar efeitos dinâmicos (transientes)",
                                    "Confundir com desacoplamento em malha fechada"
                                  ]
                                }
                              ],
                              "practicalExample": "Considere um sistema de controle de temperatura em dois cômodos independentes: entrada u1 controla aquecedor do cômodo 1 (saída y1 = temp1), u2 para cômodo 2 (y2 = temp2). A matriz G(s) é diagonal pois aquecer cômodo 1 não afeta temp2. Diagrama: dois blocos paralelos sem conexões cruzadas. Simule: perturbe u1, y2 permanece inalterada.",
                              "finalVerifications": [
                                "Explicar verbalmente o que significa matriz de transferência diagonal.",
                                "Desenhar diagrama de bloco para sistema desacoplado 2x2.",
                                "Identificar corretamente acoplamento em uma matriz dada.",
                                "Simular resposta e confirmar ausência de cross-effect.",
                                "Contrastar com exemplo acoplado (ex: tanques conectados por tubo)."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de diagonalidade (100% correto em testes).",
                                "Clareza nos diagramas de bloco desenhados.",
                                "Correta derivação de matriz de transferência de diagramas.",
                                "Profundidade no contraste com sistemas acoplados.",
                                "Uso adequado de simulações para verificação.",
                                "Relatório com justificativas lógicas e sem erros conceituais."
                              ],
                              "crossCurricularConnections": [
                                "Álgebra Linear: Propriedades de matrizes diagonais e decomposição.",
                                "Física: Sistemas dinâmicos independentes (ex: osciladores desacoplados).",
                                "Programação: Simulações em MATLAB/Python para análise de sistemas.",
                                "Matemática Aplicada: Funções de transferência e transformada de Laplace."
                              ],
                              "realWorldApplication": "Em plantas industriais como linhas de produção com estações independentes (ex: robôs cartesianos desacoplados em eixos X/Y), permitindo controle PID simples por canal sem compensadores de desacoplamento, reduzindo complexidade e custo."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.7.3.1.3",
                            "name": "Explicar origens do acoplamento físico",
                            "description": "Descrever causas físicas como dinâmica compartilhada, não-linearidades e acoplamentos mecânicos em processos industriais multivariáveis.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os conceitos fundamentais de acoplamento físico",
                                  "subSteps": [
                                    "Ler a definição de acoplamento físico como interdependência entre variáveis em sistemas multivariáveis.",
                                    "Identificar diferenças entre sistemas monovariáveis e multivariáveis.",
                                    "Revisar equações diferenciais básicas que modelam interações físicas.",
                                    "Discutir exemplos cotidianos de acoplamento, como pêndulos acoplados.",
                                    "Anotar as principais origens físicas listadas na descrição da habilidade."
                                  ],
                                  "verification": "Resumir em 3 frases o que é acoplamento físico e suas origens principais.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Livro de Engenharia de Controle (capítulo sobre sistemas multivariáveis)",
                                    "Vídeo introdutório sobre acoplamento em YouTube (ex: 'Coupled Oscillators')",
                                    "Caderno para anotações"
                                  ],
                                  "tips": "Use diagramas para visualizar interdependências entre canais.",
                                  "learningObjective": "Definir acoplamento físico e listar suas origens fundamentais.",
                                  "commonMistakes": "Confundir acoplamento físico com acoplamento matemático ou de controle."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Explorar a dinâmica compartilhada como causa de acoplamento",
                                  "subSteps": [
                                    "Estudar sistemas com massas, molas e amortecedores compartilhados.",
                                    "Derivar equações de movimento para dois graus de liberdade acoplados.",
                                    "Simular numericamente a resposta de um sistema com dinâmica compartilhada usando software como MATLAB.",
                                    "Analisar modos normais de vibração resultantes do acoplamento.",
                                    "Comparar respostas desacopladas vs. acopladas em gráficos."
                                  ],
                                  "verification": "Plotar e interpretar gráficos de resposta temporal de um sistema acoplado.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Software MATLAB ou Octave",
                                    "Tutorial online sobre equações de acoplamento dinâmico",
                                    "Artigo sobre 'Dynamic Coupling in Mechanical Systems'"
                                  ],
                                  "tips": "Comece com sistemas lineares simples para construir intuição.",
                                  "learningObjective": "Explicar como dinâmica compartilhada gera acoplamento via equações de estado.",
                                  "commonMistakes": "Ignorar os termos de acoplamento nas matrizes de massa e rigidez."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar não-linearidades como origem de acoplamento",
                                  "subSteps": [
                                    "Revisar tipos de não-linearidades: quadráticas, cúbicas e fricção.",
                                    "Modelar um sistema com não-linearidades que induzem acoplamento entre canais.",
                                    "Executar simulações para observar como não-linearidades criam interdependências.",
                                    "Comparar linearização em torno de pontos de operação com comportamento real.",
                                    "Discutir impacto em processos industriais como reatores químicos."
                                  ],
                                  "verification": "Descrever um exemplo onde não-linearidade causa acoplamento inesperado.",
                                  "estimatedTime": "50 minutos",
                                  "materials": [
                                    "Simulador online como Simulink ou Python (SciPy)",
                                    "Livro 'Nonlinear Systems' de Khalil (capítulo introdutório)",
                                    "Planilha Excel para cálculos simples"
                                  ],
                                  "tips": "Use expansões em série de Taylor para aproximar não-linearidades.",
                                  "learningObjective": "Identificar e modelar não-linearidades que geram acoplamento físico.",
                                  "commonMistakes": "Assumir linearidade em sistemas reais com grandes excursões."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Investigar acoplamentos mecânicos em processos industriais multivariáveis",
                                  "subSteps": [
                                    "Estudar casos reais: plantas de destilação, turbinas ou braços robóticos.",
                                    "Mapear canais de entrada/saída e identificar acoplamentos mecânicos.",
                                    "Derivar modelos simplificados mostrando termos de acoplamento.",
                                    "Analisar efeitos em laços de controle descentralizado vs. multivariable.",
                                    "Sintetizar as três causas (dinâmica compartilhada, não-linearidades, mecânicos) em um diagrama unificado."
                                  ],
                                  "verification": "Criar um diagrama de blocos ilustrando acoplamento em um processo industrial.",
                                  "estimatedTime": "55 minutos",
                                  "materials": [
                                    "Caso de estudo: 'Multivariable Control in Distillation Columns'",
                                    "Software de modelagem como SysML ou Draw.io",
                                    "Artigos IEEE sobre acoplamento em processos industriais"
                                  ],
                                  "tips": "Foco em exemplos concretos para conectar teoria à prática.",
                                  "learningObjective": "Descrever acoplamentos mecânicos em contextos industriais multivariáveis.",
                                  "commonMistakes": "Subestimar acoplamento em sistemas aparentemente desacoplados."
                                }
                              ],
                              "practicalExample": "Em uma planta de destilação binária, o fluxo de refluxo (canal 1) afeta a composição do topo via dinâmica compartilhada de vapor-líquido, não-linearidades na eficiência de pratos e acoplamento mecânico através de válvulas compartilhadas, causando que uma mudança em um canal altere o outro.",
                              "finalVerifications": [
                                "Explicar verbalmente as três principais origens de acoplamento físico.",
                                "Identificar acoplamento em um diagrama de processo industrial fornecido.",
                                "Simular e mostrar gráficos de resposta acoplada vs. desacoplada.",
                                "Listar 3 exemplos reais de processos com acoplamento físico.",
                                "Derivar uma equação simples de acoplamento dinâmico.",
                                "Discutir impactos em controle multivariable."
                              ],
                              "assessmentCriteria": [
                                "Precisão na descrição de dinâmica compartilhada (ex: termos de acoplamento em EDOs).",
                                "Compreensão de não-linearidades e seu papel em induzir acoplamento.",
                                "Exemplos relevantes de acoplamentos mecânicos industriais.",
                                "Uso correto de terminologia técnica (ex: modos normais, matriz de acoplamento).",
                                "Capacidade de integrar causas em uma explicação coesa.",
                                "Qualidade de simulações ou diagramas produzidos."
                              ],
                              "crossCurricularConnections": [
                                "Física: Mecânica clássica e vibrações (modos normais).",
                                "Matemática: Equações diferenciais não-lineares e linearização.",
                                "Química Industrial: Processos de separação com acoplamento.",
                                "Informática: Simulação numérica em MATLAB/Python."
                              ],
                              "realWorldApplication": "No controle de usinas nucleares ou aeronaves, entender origens de acoplamento físico permite projetar controladores multivariable (MIMO) robustos, evitando instabilidades como em incidentes de acoplamento não compensado em turbinas eólicas."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.7.3.2",
                        "name": "Representação Matemática do Acoplamento",
                        "description": "Modelagem do acoplamento através da função de transferência multivariável em forma de matriz, destacando elementos fora da diagonal.",
                        "specificSkills": [
                          {
                            "id": "10.1.7.3.2.1",
                            "name": "Interpretar matriz de transferência G(s)",
                            "description": "Analisar a matriz G(s) = [g_ij(s)], onde g_ij ≠ 0 para i≠j indica acoplamento, e calcular respostas de saída para entradas unitárias isoladas.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a estrutura da matriz de transferência G(s)",
                                  "subSteps": [
                                    "Revise o conceito de função de transferência para sistemas monovariáveis: Y(s)/U(s).",
                                    "Entenda que para sistemas multivariáveis, G(s) é uma matriz onde cada elemento g_ij(s) representa a transferência do input j para output i.",
                                    "Identifique dimensões: para m entradas e p saídas, G(s) é p x m.",
                                    "Anote a forma geral: G(s) = [g_ij(s)] com g_ii(s) como canais principais e g_ij(s) i≠j como acoplamentos.",
                                    "Desenhe um diagrama de blocos representando o sistema MIMO (Multi-Input Multi-Output)."
                                  ],
                                  "verification": "Escreva a definição de G(s) e desenhe um exemplo 2x2 sem erros.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Livro de controle (capítulo MIMO)",
                                    "Calculadora simbólica ou MATLAB para referência"
                                  ],
                                  "tips": "Comece com sistemas SISO familiares para analogia; visualize como 'vazamento' de sinal entre canais.",
                                  "learningObjective": "Dominar a representação matricial de funções de transferência em sistemas multivariáveis.",
                                  "commonMistakes": [
                                    "Confundir g_ij com g_ji (não simétrica necessariamente)",
                                    "Ignorar polos/zeros comuns entre elementos"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar elementos de acoplamento na matriz G(s)",
                                  "subSteps": [
                                    "Examine cada elemento off-diagonal (i≠j): se g_ij(s) ≠ 0, há acoplamento do canal j para i.",
                                    "Classifique o acoplamento: forte (ganho similar a diagonal) ou fraco (ganho pequeno).",
                                    "Calcule o grau de acoplamento relativo: |g_ij(0)| / |g_ii(0)| para ganho DC.",
                                    "Verifique simetria: se G(s) é simétrica, acoplamento bidirecional.",
                                    "Registre uma tabela resumindo acoplamentos detectados."
                                  ],
                                  "verification": "Para uma matriz dada, liste todos os acoplamentos com seus graus relativos corretos.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Matriz de exemplo impressa",
                                    "Planilha Excel ou MATLAB para cálculos numéricos",
                                    "Gráficos de Bode pré-calculados"
                                  ],
                                  "tips": "Use valores em s=0 (ganho estático) para quantificar rapidamente; plote magnitudes para frequência.",
                                  "learningObjective": "Detectar e quantificar acoplamento entre canais a partir de G(s).",
                                  "commonMistakes": [
                                    "Assumir acoplamento zero se g_ij pequeno em DC mas não em altas frequências",
                                    "Confundir diagonal com off-diagonal"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular respostas de saída para entradas unitárias isoladas",
                                  "subSteps": [
                                    "Aplique entrada unitária em um canal j: U(s) = [0, ..., 1/s, ... 0]^T (degrau unitário).",
                                    "Compute Y(s) = G(s) U(s), isolando a coluna j de G(s).",
                                    "Para cada saída i, y_i(t) = L^{-1}{g_ij(s)/s}, usando transformada inversa.",
                                    "Simule numericamente se analítico complexo, usando step response em MATLAB.",
                                    "Plote respostas temporais para todas saídas ao excitar canal j."
                                  ],
                                  "verification": "Gere plots de step response mostrando saída pretendida e acopladas corretamente.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Software MATLAB/Simulink ou Python (control library)",
                                    "Tabelas de transformadas de Laplace",
                                    "Computador"
                                  ],
                                  "tips": "Use 'lsim' ou 'step' no MATLAB para colunas individuais; normalize tempo para comparação.",
                                  "learningObjective": "Executar cálculos de resposta para entradas isoladas em MIMO.",
                                  "commonMistakes": [
                                    "Esquecer de multiplicar pela entrada 1/s",
                                    "Não isolar colunas corretamente"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Interpretar resultados e implicações do acoplamento",
                                  "subSteps": [
                                    "Analise overshoot/settling time na saída diagonal vs. off-diagonal.",
                                    "Quantifique spillover: pico máximo na saída acoplada / pico na principal.",
                                    "Discuta efeitos: oscilações indesejadas, redução de desempenho.",
                                    "Proponha decoplamento qualitativo (ex: pré-compensadores).",
                                    "Resuma em relatório: grau de acoplamento e recomendações."
                                  ],
                                  "verification": "Escreva um parágrafo interpretativo com métricas quantitativas sem erros conceituais.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Plots gerados no step 3",
                                    "Templates de relatório",
                                    "Referências de livros de controle MIMO"
                                  ],
                                  "tips": "Compare com sistema diagonal ideal; pense em controle descentralizado vs. multivariable.",
                                  "learningObjective": "Interpretar acoplamento em termos de desempenho do sistema.",
                                  "commonMistakes": [
                                    "Ignorar dinâmica em frequência alta",
                                    "Superestimar acoplamento fraco"
                                  ]
                                }
                              ],
                              "practicalExample": "Considere G(s) = [[1/(s+1), 0.1/(s+1)]; [0.1/(s+1), 1/(s+1)]] para um sistema de dois motores acoplados mecanicamente. Aplicando degrau unitário no motor 1 (u1=1/s, u2=0), y1(t) ≈ 1- e^{-t} (resposta principal), y2(t) ≈ 0.1(1-e^{-t}) (acoplamento 10%). Isso indica acoplamento fraco bidirecional, visível nos plots de step response.",
                              "finalVerifications": [
                                "Identifica corretamente todos os elementos off-diagonal não-nulos.",
                                "Calcula respostas y_i para u_j unitário isolado sem erros aritméticos.",
                                "Quantifica grau de acoplamento com métricas como ganho relativo.",
                                "Interpreta implicações para controle (ex: necessidade de decoplador).",
                                "Gera plots de step response mostrando acoplamento.",
                                "Discute limitações de controle descentralizado."
                              ],
                              "assessmentCriteria": [
                                "Precisão nos cálculos de Y(s) = G(s)U(s) (100% correto).",
                                "Qualidade dos plots: eixos rotulados, múltiplas respostas sobrepostas.",
                                "Profundidade da interpretação: inclui métricas quantitativas e qualitativas.",
                                "Identificação correta de acoplamento forte/fraco com justificativa.",
                                "Relatório claro e estruturado, sem erros conceituais.",
                                "Criatividade em conexões com aplicações reais."
                              ],
                              "crossCurricularConnections": [
                                "Álgebra Linear: multiplicação matricial e análise de eigenvalores para modos.",
                                "Análise de Sistemas: funções de transferência e respostas em tempo/frequência.",
                                "Programação: simulação em MATLAB/Python para validação numérica.",
                                "Física: modelagem de sistemas acoplados (ex: massas com molas).",
                                "Engenharia de Software: implementação de controladores MIMO."
                              ],
                              "realWorldApplication": "Em aviões comerciais, a matriz G(s) modela como comandos de aileron (roll) acoplam com elevator (pitch) devido a aerodinâmica. Interpretar acoplamento permite projetar compensadores para estabilidade, evitando oscilações perigosas durante manobras automáticas."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.7.3.1"
                            ]
                          },
                          {
                            "id": "10.1.7.3.2.2",
                            "name": "Calcular respostas acopladas",
                            "description": "Dado G(s), computar y(s) = G(s)u(s) para entrada em um canal e observar impacto nos demais canais, usando ferramentas como MATLAB.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender e representar a matriz de transferência G(s)",
                                  "subSteps": [
                                    "Identifique a estrutura da matriz G(s) para um sistema multivariável (ex: 2x2 ou 3x3).",
                                    "Descreva os elementos diagonais (ganhos diretos) e off-diagonais (acoplamentos).",
                                    "Converta o modelo em domínio s usando transformada de Laplace, se necessário.",
                                    "Anote as entradas u(s) e saídas y(s) correspondentes aos canais.",
                                    "Verifique dimensionalidade: G(s) deve ser quadrada (nxn)."
                                  ],
                                  "verification": "Matriz G(s) corretamente anotada com labels para canais de entrada/saída.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e caneta ou editor de texto",
                                    "Documentação do sistema (ex: PDF do modelo)"
                                  ],
                                  "tips": [
                                    "Use notação padrão: G_{ij}(s) onde i=saída, j=entrada.",
                                    "Desenhe um diagrama de blocos para visualizar canais."
                                  ],
                                  "learningObjective": "Compreender a representação matemática do acoplamento em sistemas multivariáveis.",
                                  "commonMistakes": [
                                    "Confundir linhas (saídas) com colunas (entradas).",
                                    "Ignorar pólos/zeros que afetam acoplamento."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Definir a entrada u(s) para um canal específico",
                                  "subSteps": [
                                    "Escolha um canal de entrada j (ex: u_1(s) = 1/s para rampa).",
                                    "Defina u(s) como vetor com valor não-zero apenas no canal j e zeros nos outros.",
                                    "Especifique o tipo de entrada: degrau (1/s), impulso (1), seno, etc.",
                                    "Justifique a escolha baseada no objetivo de análise de acoplamento.",
                                    "Expresse u(s) em domínio Laplace."
                                  ],
                                  "verification": "Vetor u(s) com entrada unitária isolada em um canal e zeros nos demais.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Calculadora simbólica ou software como SymPy",
                                    "Folha de exercícios com exemplos"
                                  ],
                                  "tips": [
                                    "Comece com degrau unitário para simplicidade: u_j(s) = 1/s.",
                                    "Normalize entradas para comparar acoplamentos."
                                  ],
                                  "learningObjective": "Preparar entrada excitadora para isolar efeitos de acoplamento.",
                                  "commonMistakes": [
                                    "Definir entradas em múltiplos canais acidentalmente.",
                                    "Usar domínio tempo em vez de s."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Computar y(s) = G(s) u(s)",
                                  "subSteps": [
                                    "Realize multiplicação matricial: y_i(s) = sum_j G_{ij}(s) u_j(s) para cada saída i.",
                                    "Simplifique expressões algébricas, cancelando termos comuns.",
                                    "Identifique contribuições: termo direto (i=j) vs. acoplado (i≠j).",
                                    "Calcule numericamente para valores específicos de s (ex: s=jω).",
                                    "Verifique simetria ou propriedades do sistema."
                                  ],
                                  "verification": "Vetor y(s) computado com elementos corretos, destacando off-diagonais.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "MATLAB ou Octave instalado",
                                    "Script base para multiplicação matricial"
                                  ],
                                  "tips": [
                                    "Use tf() no MATLAB para funções de transferência.",
                                    "Automatize com loop for i=1:n."
                                  ],
                                  "learningObjective": "Executar cálculo matricial no domínio Laplace para respostas acopladas.",
                                  "commonMistakes": [
                                    "Erro em multiplicação matricial (invertendo índices).",
                                    "Não simplificar frações racionais."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar e visualizar impacto nos canais usando MATLAB",
                                  "subSteps": [
                                    "Implemente G(s) e u(s) em MATLAB com tf(num,den).",
                                    "Compute y(s) = G*u e plote respostas no tempo com step() ou lsim().",
                                    "Observe overshoot ou atraso nos canais acoplados.",
                                    "Calcule métricas: ganho de acoplamento |G_{ij}(0)| / |G_{ii}(0)|.",
                                    "Gere relatório com plots e conclusões sobre intensidade do acoplamento."
                                  ],
                                  "verification": "Plots gerados mostrando resposta direta e acoplada; métricas calculadas.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "MATLAB com Control System Toolbox",
                                    "Exemplo de script .m"
                                  ],
                                  "tips": [
                                    "Use subplot para múltiplos canais.",
                                    "Adicione legendas claras: 'Canal direto' vs 'Acoplado'."
                                  ],
                                  "learningObjective": "Simular e quantificar acoplamento via ferramentas computacionais.",
                                  "commonMistakes": [
                                    "Escala errada nos plots ocultando acoplamento.",
                                    "Não linearizar modelo não-linear."
                                  ]
                                }
                              ],
                              "practicalExample": "Considere G(s) 2x2 para um misturador químico: G11=1/(s+1), G12=0.5/(10s+1), G21=0.3/(5s+1), G22=1/(s+2). Aplique u1(s)=1/s (degrau no canal 1). Compute y2(s) para observar acoplamento de fluxo1 em nível2. No MATLAB: G=tf({...}); y=step(G*[1/s;0]);",
                              "finalVerifications": [
                                "y(s) calculado corretamente para todos canais.",
                                "Impacto acoplado identificado em canais off-diagonal.",
                                "Simulação MATLAB reproduz cálculo analítico.",
                                "Métricas de acoplamento (ganho relativo) reportadas.",
                                "Plots mostram resposta transitória e estacionária.",
                                "Conclusões sobre força do acoplamento justificadas."
                              ],
                              "assessmentCriteria": [
                                "Precisão matemática na multiplicação G*u (90%+ correto).",
                                "Identificação correta de efeitos acoplados (qualitativa e quantitativa).",
                                "Uso correto de MATLAB (sem erros de sintaxe; plots legíveis).",
                                "Análise interpretativa profunda (não só cálculo).",
                                "Eficiência temporal (dentro de 90 minutos totais).",
                                "Relatório claro com evidências visuais."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Álgebra linear (multiplicação matricial) e Transformadas de Laplace.",
                                "Programação: Implementação em MATLAB/Simulink para análise numérica.",
                                "Física: Dinâmica de sistemas acoplados (ex: vibrações modais).",
                                "Engenharia de Processos: Modelagem de plantas industriais multivariáveis."
                              ],
                              "realWorldApplication": "Em controle de aviões, calcular acoplamento entre comandos de elevador (pitch) e rolamento (aileron) para evitar instabilidades; em indústrias químicas, analisar como mudança de vazão em um reator afeta temperatura em outro via tubulações compartilhadas, otimizando desacopladores."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.7.3.1"
                            ]
                          },
                          {
                            "id": "10.1.7.3.2.3",
                            "name": "Visualizar acoplamento em diagramas",
                            "description": "Construir e interpretar diagramas de Nyquist ou Bode multivariáveis para evidenciar interações entre canais.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar diagramas de Nyquist e Bode para sistemas monovariáveis",
                                  "subSteps": [
                                    "Relembrar a definição de função de transferência G(s) e sua avaliação em jω.",
                                    "Plotar diagrama de Nyquist: traçar Re[G(jω)] vs Im[G(jω)] para ω de 0 a ∞.",
                                    "Construir diagrama de Bode: calcular magnitude 20log|G(jω)| e fase arg[G(jω)] vs log(ω).",
                                    "Identificar características como ganho em baixa frequência, cruzamentos e estabilidade.",
                                    "Praticar com um exemplo simples como G(s) = 1/(s+1)."
                                  ],
                                  "verification": "Gerar plots corretos de Nyquist e Bode para um sistema monovariável dado e rotulá-los adequadamente.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Software MATLAB/Python (control library), papel e lápis para esboços manuais.",
                                  "tips": "Use comandos como nyquist() ou bode() no MATLAB para validação rápida.",
                                  "learningObjective": "Dominar a construção e interpretação básica de diagramas de frequência monovariáveis.",
                                  "commonMistakes": "Esquecer de plotar o espelho para Nyquist (ω negativo) ou inverter eixos no Bode."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Entender representação de sistemas multivariáveis",
                                  "subSteps": [
                                    "Definir matriz de transferência G(s) = [G11(s) G12(s); G21(s) G22(s)] para sistema 2x2.",
                                    "Explicar acoplamento: elementos off-diagonal (G12, G21) ≠ 0 indicam interações entre canais.",
                                    "Discutir normalização relativa ganho (RGA) para quantificar acoplamento.",
                                    "Calcular singular values σ(G(jω)) para análise robusta.",
                                    "Estudar exemplo de sistema de dois motores acoplados mecanicamente."
                                  ],
                                  "verification": "Escrever a matriz G(s) para um sistema físico simples e identificar elementos de acoplamento.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Livro-texto de controle multivariável (Skogestad), calculadora simbólica como SymPy.",
                                  "tips": "Comece com sistemas 2x2 para simplicidade antes de generalizar.",
                                  "learningObjective": "Compreender como matrizes de transferência capturam interações multivariáveis.",
                                  "commonMistakes": "Confundir entradas/saídas ou assumir diagonal dominante sem verificação."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Construir diagramas de Nyquist e Bode multivariáveis",
                                  "subSteps": [
                                    "Plotar Nyquist para cada elemento Gij(jω) individualmente.",
                                    "Gerar Bode plots para todos os elementos da matriz, destacando off-diagonals.",
                                    "Calcular e plotar valores singulares μ(G(jω)) ou σ_max/min para visão agregada.",
                                    "Usar ferramentas para singular value plots (sigma() no MATLAB).",
                                    "Comparar com sistema diagonal para visualizar acoplamento."
                                  ],
                                  "verification": "Produzir um conjunto completo de plots (elementos individuais + singulares) para uma matriz G(s) dada.",
                                  "estimatedTime": "90 minutos",
                                  "materials": "MATLAB Robust Control Toolbox ou Python control-systems-library, exemplos de código prontos.",
                                  "tips": "Escalone frequências logarítmicas para resolução fina em cruzamentos.",
                                  "learningObjective": "Habilitar a geração precisa de diagramas de frequência para matrizes de transferência.",
                                  "commonMistakes": "Ignorar fase nos Bode plots ou plotar apenas magnitude dos singulares."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Interpretar acoplamento nos diagramas",
                                  "subSteps": [
                                    "Analisar magnitude/fase dos off-diagonals: alto ganho indica forte acoplamento.",
                                    "Verificar RGA(ω) = G(jω) .* (I - G(jω))^{-1} para pares preferidos.",
                                    "Identificar frequências de crossover onde acoplamento é crítico.",
                                    "Avaliar estabilidade condicional via Nyquist multivariável (encirclements de singulares).",
                                    "Concluir sobre descentralização viável baseado em proximidade diagonal."
                                  ],
                                  "verification": "Escrever relatório curto interpretando acoplamento em plots gerados, com conclusões quantitativas.",
                                  "estimatedTime": "75 minutos",
                                  "materials": "Folha de verificação RGA, software para cálculo automático.",
                                  "tips": "Foque em ω onde |Gii| ≈ |Gjj| para acoplamento relativo.",
                                  "learningObjective": "Desenvolver habilidades para diagnosticar e quantificar interações entre canais.",
                                  "commonMistakes": "Sobrepor interpretações monovariáveis sem considerar singulares."
                                }
                              ],
                              "practicalExample": "Considere um sistema 2x2 de dois tanques acoplados: G(s) = [1/(10s+1) 0.5/(10s+1); 0.5/(10s+1) 1/(10s+1)]. Plote Nyquist/Bode para todos Gij e singulares; observe acoplamento moderado nos off-diagonals em baixas frequências, implicando necessidade de compensadores desacopladores.",
                              "finalVerifications": [
                                "Plots de Nyquist/Bode para todos elementos da matriz estão corretos e rotulados.",
                                "Valores singulares σ(G(jω)) mostram picos de acoplamento claramente.",
                                "RGA calculado identifica pares de controle adequados.",
                                "Interpretação escrita explica impacto do acoplamento na estabilidade.",
                                "Comparação com sistema desacoplado destaca diferenças.",
                                "Conclusões incluem recomendações para design de controlador."
                              ],
                              "assessmentCriteria": [
                                "Precisão na construção dos diagramas (sem erros de escala ou fase).",
                                "Correta identificação e quantificação de acoplamento via off-diagonals e RGA.",
                                "Profundidade na interpretação, ligando plots a propriedades do sistema.",
                                "Uso apropriado de ferramentas computacionais com validação manual.",
                                "Clareza na documentação de plots e conclusões.",
                                "Criatividade em exemplos reais ou extensões."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Análise de valores singulares e funções complexas.",
                                "Programação: Implementação de plots em MATLAB/Python para análise numérica.",
                                "Física: Modelagem dinâmica de sistemas acoplados (e.g., mecânica vibracional).",
                                "Estatística: Análise de robustez via margens de ganho/fase multivariáveis."
                              ],
                              "realWorldApplication": "Em plantas químicas, como destiladores com múltiplos bandejas, diagramas multivariáveis revelam acoplamento entre pressão e composição, guiando controladores MIMO para operação estável e eficiente."
                            },
                            "estimatedTime": "0.75 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.7.3.1"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "10.1.7.3.3",
                        "name": "Implicações e Medidas de Acoplamento",
                        "description": "Análise dos efeitos no controle e introdução a métricas quantitativas como o Relative Gain Array (RGA) para medir o grau de interação.",
                        "specificSkills": [
                          {
                            "id": "10.1.7.3.3.1",
                            "name": "Descrever impactos no desempenho de controle",
                            "description": "Explicar como o acoplamento degrada estabilidade, robustez e desempenho em malhas de controle descentralizadas, comparando com revisão de sistemas LIT escalares.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Fundamentos de Sistemas de Controle LTI Univariáveis",
                                  "subSteps": [
                                    "Relembrar definições de estabilidade, robustez e desempenho em sistemas LTI univariáveis (ex.: margens de ganho/fase, tempo de assentamento).",
                                    "Analisar exemplos simples de malhas de controle univariáveis usando diagramas de Bode e Nyquist.",
                                    "Calcular métricas de desempenho para um sistema univariável padrão (ex.: seguidor de setpoint).",
                                    "Identificar como o projeto descentralizado funciona perfeitamente em sistemas univariáveis.",
                                    "Documentar diferenças chave entre univariável e multivariável."
                                  ],
                                  "verification": "Criar um relatório resumido com cálculos e gráficos de um exemplo univariável, confirmando métricas corretas.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Livro de Ogata ou Franklin (capítulos iniciais), MATLAB/Simulink para simulações, papel e caneta para diagramas.",
                                  "tips": "Comece com um sistema de segunda ordem clássico para fixar conceitos antes de complexificar.",
                                  "learningObjective": "Compreender baselines de desempenho em controles univariáveis para comparação posterior.",
                                  "commonMistakes": "Confundir estabilidade com robustez; ignorar efeitos de não-linearidades iniciais."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Introduzir Conceitos de Acoplamento em Sistemas Multivariáveis",
                                  "subSteps": [
                                    "Definir acoplamento como interdependência entre canais (matriz de transferência com elementos fora da diagonal).",
                                    "Estudar representações em espaço de estados e funções de transferência multivariáveis.",
                                    "Calcular o índice de Bristol ou RGA (Relative Gain Array) para quantificar acoplamento.",
                                    "Simular um sistema 2x2 com acoplamento forte vs. fraco.",
                                    "Visualizar efeitos em respostas temporais e frequenciais."
                                  ],
                                  "verification": "Gerar matriz RGA para um exemplo 2x2 e interpretar valores >1 ou <0 como acoplamento forte.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "MATLAB com Control System Toolbox, exemplos de Skogestad (Multivariable Feedback Control), planilhas para RGA.",
                                  "tips": "Use funções prontas como 'rga' no MATLAB para validar cálculos manuais.",
                                  "learningObjective": "Quantificar e visualizar acoplamento como pré-requisito para impactos no desempenho.",
                                  "commonMistakes": "Interpretar incorretamente RGA; assumir acoplamento simétrico sem verificação."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar Impactos do Acoplamento na Estabilidade e Robustez",
                                  "subSteps": [
                                    "Explicar degradação de estabilidade: redução de margens em direções cruzadas via análise SVD ou μ-síntese.",
                                    "Discutir robustez: sensibilidade aumentada a perturbações não modeladas entre canais.",
                                    "Simular cenários de instabilidade em malhas descentralizadas devido a acoplamento (ex.: interação loop-loop).",
                                    "Comparar com LTI univariáveis onde acoplamento é zero.",
                                    "Quantificar com métricas como condição número da matriz de planta."
                                  ],
                                  "verification": "Simular e plotar respostas instáveis em um sistema acoplado descentralizado vs. desacoplado.",
                                  "estimatedTime": "75 minutos",
                                  "materials": "Simulink para modelos MIMO, toolbox Robust Control, artigos sobre interação em controles.",
                                  "tips": "Foquem em frequências onde RGA é máximo para prever problemas de estabilidade.",
                                  "learningObjective": "Identificar mecanismos específicos pelos quais acoplamento compromete estabilidade e robustez.",
                                  "commonMistakes": "Atribuir instabilidade apenas a ganhos altos, ignorando direções de acoplamento."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Explorar Degradação no Desempenho de Malhas Descentralizadas",
                                  "subSteps": [
                                    "Descrever desempenho: overshoot aumentado, acoplamento de rejeição de distúrbios entre canais.",
                                    "Comparar tuning descentralizado (ex.: Ziegler-Nichols por canal) vs. ideal MIMO.",
                                    "Analisar trade-offs em robustez vs. desempenho sob acoplamento forte.",
                                    "Revisar exemplos onde descentralizado falha (ex.: destilação binária).",
                                    "Sintetizar comparação quantitativa com LTI univariáveis."
                                  ],
                                  "verification": "Produzir tabela comparativa de métricas (ITAE, margens) para descentralizado vs. centralizado.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Exemplos de benchmarks industriais, MATLAB scripts para tuning, quadro branco para discussões.",
                                  "tips": "Use pares de loops para ilustrar interações destrutivas em tuning sequencial.",
                                  "learningObjective": "Articular como acoplamento força compromissos em malhas descentralizadas.",
                                  "commonMistakes": "Superestimar desempenho descentralizado sem simulações de carga cruzada."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Sintetizar e Comparar com Sistemas LTI Univariáveis",
                                  "subSteps": [
                                    "Resumir impactos: acoplamento introduz zeros/direções ruins ausentes em univariáveis.",
                                    "Criar diagrama comparativo de desempenho (estabilidade/robustez/desempenho).",
                                    "Discutir quando descentralizado é viável (acoplamento fraco).",
                                    "Preparar explicação verbal com analogias (ex.: orquestra vs. solistas).",
                                    "Testar compreensão com perguntas de autoavaliação."
                                  ],
                                  "verification": "Gravar vídeo de 2 minutos explicando impactos, com gráficos de suporte.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Ferramenta de gravação (Zoom), resumo anterior, software de edição básica.",
                                  "tips": "Use metáforas para fixar conceitos abstratos em memória de longo prazo.",
                                  "learningObjective": "Dominar descrição completa e comparativa dos impactos do acoplamento.",
                                  "commonMistakes": "Generalizar demais sem dados quantitativos de suporte."
                                }
                              ],
                              "practicalExample": "Considere um processo de dois tanques acoplados em série (nível em tanque 1 afeta tanque 2 via overflow). Projetar malha descentralizada: controlador PI em cada válvula. Simule entrada em setpoint do tanque 1 causando overshoot no tanque 2 (acoplamento degrada desempenho); compare com sistema univariável isolado onde resposta é limpa.",
                              "finalVerifications": [
                                "Explicar verbalmente como RGA > 0.5 indica acoplamento forte impactando estabilidade.",
                                "Simular e identificar instabilidade em malha descentralizada com ganho cruzado >10%.",
                                "Listar 3 métricas degradadas (ex.: margem de fase reduzida em 30%, ITAE dobrado).",
                                "Comparar diagrama de Nyquist univariável vs. MIMO mostrando loops cruzados.",
                                "Desenhar fluxograma de interações em sistema 2x2 descentralizado.",
                                "Calcular condição número >20 como evidência de baixa robustez."
                              ],
                              "assessmentCriteria": [
                                "Precisão conceitual: Correta distinção entre estabilidade, robustez e desempenho (30%).",
                                "Uso de evidências quantitativas: Inclusão de RGA, margens, simulações (25%).",
                                "Completude da comparação: Explicitar diferenças com LTI univariáveis (20%).",
                                "Clareza na explicação: Linguagem acessível com analogias e visuais (15%).",
                                "Aplicação prática: Ligação a exemplo real com análise (10%)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Álgebra linear (autovalores, SVD para análise de acoplamento).",
                                "Física: Dinâmica de fluidos/multifísica em processos acoplados.",
                                "Programação: Simulações em MATLAB/Python para validação numérica.",
                                "Engenharia de Software: Modelagem em ferramentas como Modelica para sistemas reais."
                              ],
                              "realWorldApplication": "Em plantas químicas como colunas de destilação, acoplamento entre temperatura e composição causa instabilidade em controles descentralizados de válvulas, exigindo MIMO ou desacopladores para manter produção segura e eficiente, evitando shutdowns caros."
                            },
                            "estimatedTime": "0.75 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.7.3.1",
                              "10.1.7.3.2"
                            ]
                          },
                          {
                            "id": "10.1.7.3.3.2",
                            "name": "Calcular Relative Gain Array (RGA)",
                            "description": "Computar a matriz RGA = G(0) .* (G(0)^(-T)) elemento a elemento, interpretando valores próximos a 1 como baixo acoplamento e valores negativos como problemas graves.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Obter e preparar a matriz de ganho estático G(0)",
                                  "subSteps": [
                                    "Identifique o sistema multivariável e suas funções de transferência.",
                                    "Linearize o modelo não linear em torno do ponto de operação para obter G(s).",
                                    "Substitua s=0 para calcular G(0), a matriz de ganhos DC.",
                                    "Verifique se G(0) é quadrada e não singular (determinante ≠ 0).",
                                    "Armazene G(0) em formato matricial (ex: NumPy array ou MATLAB matrix)."
                                  ],
                                  "verification": "Confirme que G(0) é uma matriz quadrada com elementos numéricos corretos e det(G(0)) ≠ 0.",
                                  "estimatedTime": "15-20 minutos",
                                  "materials": [
                                    "Software de computação numérica (MATLAB, Python com NumPy/SciPy)",
                                    "Modelo do sistema multivariável"
                                  ],
                                  "tips": "Use funções prontas como tf(plant) em MATLAB para extrair G(0); teste com sistemas 2x2 simples primeiro.",
                                  "learningObjective": "Compreender o significado físico e matemático de G(0) como ganhos em regime permanente.",
                                  "commonMistakes": [
                                    "Esquecer de linearizar modelos não lineares",
                                    "Usar frequência errada (não zero)",
                                    "Ignorar singularidade da matriz"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Calcular a transposta da matriz G(0), denotada como G(0)^T",
                                  "subSteps": [
                                    "Identifique os elementos da matriz G(0) = [g_ij].",
                                    "Aplique a operação de transposição: G(0)^T = [g_ji].",
                                    "Use função built-in: np.transpose() em Python ou ' em MATLAB.",
                                    "Verifique manualmente para matrizes pequenas (ex: 2x2).",
                                    "Salve o resultado como uma nova matriz."
                                  ],
                                  "verification": "Compare elementos: o (i,j) de G^T deve igualar (j,i) de G(0).",
                                  "estimatedTime": "10 minutos",
                                  "materials": [
                                    "Software numérico (NumPy/MATLAB)"
                                  ],
                                  "tips": "Para matrizes simétricas, G^T = G; sempre valide com print ou disp.",
                                  "learningObjective": "Dominar a transposição matricial e sua importância em análise simétrica de sistemas.",
                                  "commonMistakes": [
                                    "Confundir transposta com inversa",
                                    "Erros de indexação em código"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular a inversa da transposta, G(0)^(-T)",
                                  "subSteps": [
                                    "Confirme que G(0)^T é invertível (det ≠ 0).",
                                    "Use solver numérico: np.linalg.inv() ou inv() em MATLAB.",
                                    "Para validação analítica em 2x2: inv(A) = (1/det)[[d,-b],[-c,a]].",
                                    "Verifique a inversa multiplicando G(0)^T * inv(G(0)^T) ≈ I.",
                                    "Armazene como matriz separada."
                                  ],
                                  "verification": "G(0)^T * G(0)^(-T) deve resultar na matriz identidade (erro < 1e-10).",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Software numérico com solvers lineares"
                                  ],
                                  "tips": "Use decomposição LU ou QR para matrizes grandes/condicionadas; cond(G) < 1e6 ideal.",
                                  "learningObjective": "Aplicar inversão matricial numericamente com verificação de precisão.",
                                  "commonMistakes": [
                                    "Tentar inverter matriz singular",
                                    "Ignorar erros numéricos de condicionamento"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Computar o produto elemento a elemento (Hadamard) para obter RGA",
                                  "subSteps": [
                                    "Aloque matriz resultado do mesmo tamanho de G(0).",
                                    "Calcule RGA_ij = G(0)_ij * G(0)^(-T)_ij para cada i,j.",
                                    "Use .* em MATLAB ou np.multiply() em Python (não * matricial).",
                                    "Arredonde para precisão desejada (ex: 3 casas decimais).",
                                    "Exiba e salve a matriz RGA."
                                  ],
                                  "verification": "Diagonal da RGA soma a 1 por linha/coluna; valores off-diagonal somam a 0.",
                                  "estimatedTime": "10-15 minutos",
                                  "materials": [
                                    "Software numérico"
                                  ],
                                  "tips": "Evite loops em código vetorizado para eficiência; teste com exemplo conhecido.",
                                  "learningObjective": "Executar multiplicação Hadamard e validar propriedades da RGA.",
                                  "commonMistakes": [
                                    "Usar multiplicação matricial (*) em vez de elemento a elemento",
                                    "Erros de broadcasting em arrays"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Interpretar os valores da matriz RGA",
                                  "subSteps": [
                                    "Examine elementos diagonais: ~1 indica bom pareamento de loops.",
                                    "Verifique off-diagonais: próximos a 0 = baixo acoplamento; negativos = instabilidade potencial.",
                                    "|RGA_ij| > 0.5 em off-diagonal sugere forte acoplamento.",
                                    "Some linhas/colunas para confirmar propriedades (soma=1).",
                                    "Recomende ações: reordenação de entradas/saídas se necessário."
                                  ],
                                  "verification": "Explique verbalmente implicações para um sistema dado (ex: 'RGA_12=-0.2 indica problema').",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Matriz RGA computada",
                                    "Tabela de critérios de Bristol"
                                  ],
                                  "tips": "Use magnitude e sinal; consulte Bristol (1966) para thresholds detalhados.",
                                  "learningObjective": "Interpretar RGA para decisões de design de controladores descentralizados.",
                                  "commonMistakes": [
                                    "Ignorar sinal negativo",
                                    "Confundir com NI (Niederlinski Index)"
                                  ]
                                }
                              ],
                              "practicalExample": "Para G(0) = [[2, 1], [1, 2]] (sistema 2x2 simétrico):\n- G(0)^T = [[2, 1], [1, 2]]\n- det=3, inv(G^T)= (1/3)[[2,-1],[-1,2]]\n- RGA = [[2*(2/3), 1*(-1/3)], [1*(-1/3), 2*(2/3)]] = [[1.333, -0.333], [-0.333, 1.333]]\nInterpretação: Off-diagonais negativas indicam cautela em pareamento diagonal.",
                              "finalVerifications": [
                                "RGA computada corretamente para G(0) exemplo.",
                                "Propriedades de soma por linha/coluna validadas (soma=1).",
                                "Interpretação correta: diagonais ~1 boas, negativos ruins.",
                                "Código reproduzível e verificado numericamente.",
                                "Recomendação de pareamento de loops justificada.",
                                "Análise de sensibilidade a perturbações em G(0)."
                              ],
                              "assessmentCriteria": [
                                "Precisão numérica da RGA (erro < 1e-8).",
                                "Correta distinção entre operações matriciais (transpose, inv, Hadamard).",
                                "Interpretação qualitativa alinhada com teoria de Bristol.",
                                "Validação de propriedades intrínsecas da RGA.",
                                "Eficiência e legibilidade do código/implementação.",
                                "Capacidade de generalizar para sistemas >2x2."
                              ],
                              "crossCurricularConnections": [
                                "Álgebra Linear: Transposta, inversa e produtos Hadamard.",
                                "Cálculo Numérico: Solução de sistemas lineares e condicionamento.",
                                "Engenharia Química: Análise de acoplamento em colunas de destilação.",
                                "Processos Industriais: Design de pares de loops em PLCs.",
                                "Programação Científica: Uso de bibliotecas NumPy/SciPy/MATLAB."
                              ],
                              "realWorldApplication": "No controle de plantas químicas como colunas de destilação, RGA guia o pareamento de controladores PID descentralizados, evitando instabilidades por acoplamento forte, otimizando eficiência energética e segurança operacional."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.7.3.2"
                            ]
                          },
                          {
                            "id": "10.1.7.3.3.3",
                            "name": "Avaliar exemplos reais de acoplamento",
                            "description": "Analisar casos de Skogestad & Postlethwaite, como destiladores ou reatores, identificando pares de entrada-saída ideais via RGA.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Conceitos Fundamentais de Acoplamento e RGA",
                                  "subSteps": [
                                    "Ler as seções relevantes de Skogestad & Postlethwaite sobre acoplamento em sistemas multivariáveis.",
                                    "Definir acoplamento: interação entre canais de entrada-saída.",
                                    "Explicar Relative Gain Array (RGA): fórmula Λ = G(0) .* (G(0)^(-T)), onde .* é produto elemento a elemento.",
                                    "Entender interpretação: λ_ij ≈ 1 indica par ideal; λ_ij < 0 indica acoplamento forte negativo.",
                                    "Estudar exemplos introdutórios no livro para fixar noções."
                                  ],
                                  "verification": "Resumir em 1 página os conceitos chave e fórmula RGA, com um exemplo simples resolvido.",
                                  "estimatedTime": "1.5 hours",
                                  "materials": "Livro 'Multivariable Feedback Control' de Skogestad & Postlethwaite (capítulos sobre RGA), caderno de anotações.",
                                  "tips": "Use diagramas para visualizar interações entre loops.",
                                  "learningObjective": "Compreender a teoria por trás do RGA e sua utilidade na análise de acoplamento.",
                                  "commonMistakes": "Confundir RGA com Bristol array ou ignorar o produto elemento a elemento."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Selecionar e Descrever um Exemplo Real: Destilador Binário",
                                  "subSteps": [
                                    "Escolher o exemplo de destilador binário do livro (Seção 3.4 ou similar).",
                                    "Identificar entradas (fluxo de refluxo L, vapor V) e saídas (composições xD, xB).",
                                    "Desenhar diagrama esquemático do processo.",
                                    "Listar suposições: operação em estado estacionário, modelo 2x2.",
                                    "Obter matriz de ganhos em estado estacionário G(0) do livro ou simular."
                                  ],
                                  "verification": "Produzir diagrama e tabela com entradas/saídas e matriz G(0) anotada.",
                                  "estimatedTime": "1 hour",
                                  "materials": "Livro Skogestad & Postlethwaite, software de desenho (Draw.io ou papel), MATLAB/Python para matriz.",
                                  "tips": "Foque em exemplos 2x2 para simplicidade inicial.",
                                  "learningObjective": "Contextualizar o acoplamento em um processo químico real.",
                                  "commonMistakes": "Ignorar não-linearidades ou condições de operação específicas."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular a Matriz RGA para o Exemplo",
                                  "subSteps": [
                                    "Implementar G(0) numericamente (ex: [[0.8, -0.4], [-0.5, 1.2]] para destilador típico).",
                                    "Calcular inversa G(0)^(-1) manualmente ou via software.",
                                    "Computar G(0)^(-T) (transposta da inversa).",
                                    "Realizar produto elemento a elemento para obter Λ.",
                                    "Verificar se soma de cada linha/coluna é 1 (propriedade de RGA)."
                                  ],
                                  "verification": "Apresentar cálculos passo a passo e matriz Λ final.",
                                  "estimatedTime": "2 hours",
                                  "materials": "MATLAB (função rga()), Python (NumPy/SciPy), calculadora matricial.",
                                  "tips": "Use funções prontas como rga() no MATLAB para validar cálculos manuais.",
                                  "learningObjective": "Dominar o cálculo prático do RGA.",
                                  "commonMistakes": "Erro em transposição ou inversão de matrizes."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar Resultados e Identificar Pares Ideais",
                                  "subSteps": [
                                    "Interpretar elementos de Λ: valores próximos a 1 para pares preferenciais.",
                                    "Para destilador: confirmar par diagonal (L-xD, V-xB) com λ11 ≈ 2-3.",
                                    "Discutir implicações: acoplamento forte (λ >1) requer compensação.",
                                    "Comparar com outro exemplo (reator CSTR) se tempo permitir.",
                                    "Rascunhar recomendação de pareamento."
                                  ],
                                  "verification": "Relatório de 1 página com interpretação e pares recomendados.",
                                  "estimatedTime": "1.5 hours",
                                  "materials": "Matriz Λ calculada, livro para comparações.",
                                  "tips": "Elementos >0.5 ou <0 indicam problemas; priorize pares com λ mais próximo de 1.",
                                  "learningObjective": "Aplicar RGA para seleção de pares entrada-saída.",
                                  "commonMistakes": "Interpretar λ>1 como 'ruim' sem contexto de acoplamento."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Avaliar Implicações e Generalizar",
                                  "subSteps": [
                                    "Discutir sensibilidade a mudanças operacionais.",
                                    "Comparar com outros métodos (singular values, etc.).",
                                    "Analisar caso de reatores do livro.",
                                    "Concluir lições para design de controladores multivariáveis.",
                                    "Preparar síntese para verificação final."
                                  ],
                                  "verification": "Síntese escrita ligando análise ao contexto maior de controle.",
                                  "estimatedTime": "1 hour",
                                  "materials": "Notas anteriores, livro.",
                                  "tips": "Pense em descentralizado vs. MIMO controllers.",
                                  "learningObjective": "Generalizar análise para outros sistemas reais.",
                                  "commonMistakes": "Focar só no cálculo sem implicações práticas."
                                }
                              ],
                              "practicalExample": "No destilador binário de Skogestad (G(0) ≈ [[2, -1.8], [-2.1, 2.5]]), calcular RGA resulta em λ11 ≈ 2.4, indicando acoplamento forte no par diagonal (refluxo-composição topo), recomendando controle multivariable ou pareamento alternativo.",
                              "finalVerifications": [
                                "Calcular corretamente RGA para destilador com erro <5%.",
                                "Identificar pares ideais com justificativa baseada em λ.",
                                "Explicar implicações de acoplamento forte em 3 frases.",
                                "Comparar com reator CSTR do livro.",
                                "Desenhar diagrama de loops com pares recomendados.",
                                "Verificar propriedades de RGA (soma linhas=1)."
                              ],
                              "assessmentCriteria": [
                                "Precisão nos cálculos matriciais (70% peso).",
                                "Profundidade na interpretação de RGA (20%).",
                                "Clareza na documentação e diagramas (10%).",
                                "Conexão com teoria do livro.",
                                "Identificação correta de riscos de acoplamento.",
                                "Generalização para outros exemplos."
                              ],
                              "crossCurricularConnections": [
                                "Matemática Linear: operações com matrizes e eigenvalores.",
                                "Engenharia Química: modelagem de processos contínuos.",
                                "Otimização: seleção pareto-otimal de pares.",
                                "Estatística: análise de sensibilidade em ganhos."
                              ],
                              "realWorldApplication": "Em plantas petroquímicas, como refinarias, usar RGA para parear controladores de destiladores evita instabilidades, reduzindo downtime e melhorando eficiência energética em bilhões de dólares anuais."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.7.3.2"
                            ]
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.7.4",
                    "name": "Desafios no Controle Multivariável",
                    "description": "Principais problemas como direções fortes e fracas, robustez e desempenho em presença de incertezas.",
                    "individualConcepts": [
                      {
                        "id": "10.1.7.4.1",
                        "name": "Direções Fortes e Fracas",
                        "description": "Conceito fundamental nos sistemas multivariáveis que descreve as direções de entrada e saída onde o sistema apresenta ganhos máximos (direção forte) e mínimos (direção fraca), identificadas pelos valores singulares máximos (σ̄) e mínimos (σ̲) da função de transferência, impactando diretamente a limitação de desempenho no controle.",
                        "specificSkills": [
                          {
                            "id": "10.1.7.4.1.1",
                            "name": "Calcular valores singulares de uma matriz de transferência",
                            "description": "Realizar o cálculo dos valores singulares máximo e mínimo (σ̄(G) e σ̲(G)) para uma função de transferência multivariável G(s) em frequências específicas, utilizando decomposição em valores singulares (SVD) para identificar direções fortes e fracas.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Selecionar frequência e formar a matriz de transferência G(jω)",
                                  "subSteps": [
                                    "Escolha uma frequência ω específica de interesse (ex: ω = 1 rad/s).",
                                    "Substitua s = jω na função de transferência multivariável G(s) para obter G(jω), uma matriz complexa.",
                                    "Verifique se G(jω) é uma matriz quadrada ou retangular adequada (ex: 2x2 para simplicidade).",
                                    "Anote os elementos da matriz em forma retangular (real + imaginário).",
                                    "Confirme dimensionalidade e unidades consistentes."
                                  ],
                                  "verification": "Matriz G(jω) formada corretamente e elementos validados por substituição manual ou software.",
                                  "estimatedTime": "30-45 minutos",
                                  "materials": [
                                    "Função de transferência G(s)",
                                    "Calculadora ou software como MATLAB/SciPy",
                                    "Papel e lápis para anotações"
                                  ],
                                  "tips": "Comece com matrizes 2x2 para prática; use sympy ou MATLAB para automação em casos complexos.",
                                  "learningObjective": "Formar a avaliação estática da matriz de transferência em frequência específica.",
                                  "commonMistakes": [
                                    "Esquecer o j em s = jω",
                                    "Erros de cálculo em partes real/imaginária",
                                    "Ignorar conjugados complexos"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Realizar decomposição em valores singulares (SVD) da matriz G(jω)",
                                  "subSteps": [
                                    "Implemente SVD: G(jω) = U Σ V^*, onde U e V são unitárias, Σ diagonal com valores singulares σ_i.",
                                    "Use software (svd() no MATLAB ou numpy.linalg.svd no Python) ou calcule manualmente para matrizes pequenas.",
                                    "Obtenha a matriz Σ com σ_1 ≥ σ_2 ≥ ... ≥ σ_n ≥ 0.",
                                    "Verifique ortogonalidade de U e V (UU^* = I, VV^* = I).",
                                    "Armazene os valores singulares em ordem decrescente."
                                  ],
                                  "verification": "SVD computada com Σ diagonal não-negativa e G ≈ U Σ V^* (erro < 1e-10).",
                                  "estimatedTime": "45-60 minutos",
                                  "materials": [
                                    "Software: MATLAB, Python (NumPy/SciPy)",
                                    "Documentação SVD",
                                    "Matriz G(jω) do passo anterior"
                                  ],
                                  "tips": "Sempre use SVD para valores singulares de matrizes complexas; evite autovalores para não-simétricas.",
                                  "learningObjective": "Executar SVD corretamente em matrizes complexas de transferência.",
                                  "commonMistakes": [
                                    "Usar autovalores em vez de SVD",
                                    "Não ordenar σ_i decrescente",
                                    "Ignorar parte imaginária em software"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Extrair valores singulares máximo e mínimo",
                                  "subSteps": [
                                    "Identifique σ̄(G) = σ_max = maior diagonal de Σ (primeiro elemento).",
                                    "Identifique σ̲(G) = σ_min = menor diagonal de Σ (último elemento não-zero).",
                                    "Calcule razão de condição γ = σ_max / σ_min para avaliar acoplamento.",
                                    "Registre valores numéricos com precisão (ex: 3 casas decimais).",
                                    "Compare com limites teóricos ou gráficos de Bode multivariável."
                                  ],
                                  "verification": "σ̄(G) e σ̲(G) extraídos corretamente de Σ, com γ computada.",
                                  "estimatedTime": "20-30 minutos",
                                  "materials": [
                                    "Matriz Σ do SVD",
                                    "Calculadora",
                                    "Gráficos de magnitude se disponíveis"
                                  ],
                                  "tips": "Para sistemas não quadrados, σ_min é o menor não-zero; ignore zeros padding.",
                                  "learningObjective": "Identificar σ_max e σ_min e sua implicação em ganho direçãoal.",
                                  "commonMistakes": [
                                    "Confundir σ_max com norma 2",
                                    "Não considerar zeros em Σ",
                                    "Erro em divisão para γ"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Interpretar direções fortes e fracas usando vetores singulares",
                                  "subSteps": [
                                    "Direção forte: primeira coluna de u_1 (de U) para entrada v_1 (de V), associada a σ_max.",
                                    "Direção fraca: última coluna de u_n (de U) para v_n (de V), associada a σ_min.",
                                    "Visualize vetores em diagrama de direção (plot u e v).",
                                    "Analise implicações: forte = ganho alto, fraca = sensibilidade baixa.",
                                    "Documente para relatório ou simulação de controle."
                                  ],
                                  "verification": "Vetores u_1, v_1, u_n, v_n identificados e plotados corretamente.",
                                  "estimatedTime": "30-45 minutos",
                                  "materials": [
                                    "Vetores U e V do SVD",
                                    "Software de plotagem (MATLAB plot, Python matplotlib)"
                                  ],
                                  "tips": "Normalize vetores para interpretação física; teste invertendo entradas para validar.",
                                  "learningObjective": "Associar valores singulares a direções de ganho máximo/mínimo.",
                                  "commonMistakes": [
                                    "Confundir colunas de U e V",
                                    "Não usar V^* (conjugado transposto)",
                                    "Ignorar normalização"
                                  ]
                                }
                              ],
                              "practicalExample": "Para G(s) = [1/(s+1)  0.5/(s+1); 0.5/(s+1)  1/(s+1)] em ω=1 rad/s: G(j1) ≈ [0.6-0.8j  0.3-0.4j; 0.3-0.4j  0.6-0.8j]. SVD dá σ_max≈1.09, σ_min≈0.32, direção forte alinhada com diagonal principal.",
                              "finalVerifications": [
                                "σ̄(G) e σ̲(G) calculados com precisão numérica.",
                                "SVD reconstrói G(jω) com erro residual mínimo.",
                                "Razão de condição γ consistente com acoplamento esperado.",
                                "Direções fortes/fracas identificadas e visualizadas.",
                                "Resultados reproduzíveis em software diferente.",
                                "Interpretação física coerente com teoria multivariável."
                              ],
                              "assessmentCriteria": [
                                "Precisão dos cálculos SVD (erro < 1e-8).",
                                "Correta identificação de σ_max/σ_min e γ.",
                                "Descrição clara de direções com vetores unitários.",
                                "Uso adequado de ferramentas computacionais.",
                                "Análise de implicações para controle (ex: robustez).",
                                "Documentação completa com passos reproduzíveis."
                              ],
                              "crossCurricularConnections": [
                                "Álgebra Linear: Decomposição SVD e propriedades de matrizes complexas.",
                                "Programação Numérica: Implementação em MATLAB/Python para análise de sistemas.",
                                "Engenharia de Controle: Análise de robustez e design de controladores H∞.",
                                "Matemática Aplicada: Funções analíticas e contorno de frequência.",
                                "Física: Modelagem de sistemas dinâmicos vibracionais."
                              ],
                              "realWorldApplication": "Em plantas químicas como destiladores, calcular σ_max/σ_min identifica direções de controle robusto, evitando acoplamento forte que causa instabilidade em processos industriais como refino de petróleo."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.7.4.1.2",
                            "name": "Interpretar o impacto das direções fortes e fracas no controle",
                            "description": "Analisar como as direções fortes limitam o desempenho de rejeição de distúrbios e as direções fracas afetam a robustez a incertezas, relacionando com teoremas de limitação de Bode em sistemas multivariáveis.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender valores singulares e direções singulares em sistemas multivariáveis",
                                  "subSteps": [
                                    "Revise a decomposição em valores singulares (SVD) de uma matriz de transferência G(s): G(s) = U(s) Σ(s) V*(s).",
                                    "Identifique o valor singular máximo (σ_max) como direção forte e mínimo (σ_min) como direção fraca.",
                                    "Calcule manualmente SVD para uma matriz 2x2 estática simples.",
                                    "Plote os valores singulares de magnitude |G(jω)| em função da frequência.",
                                    "Discuta como direções fortes e fracas variam com a frequência."
                                  ],
                                  "verification": "Plotar gráfico de σ_max e σ_min corretamente e explicar direções associadas.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Software MATLAB/Simulink ou Python (control library), matriz de exemplo 2x2.",
                                  "tips": "Use funções prontas como svd() no MATLAB para validar cálculos manuais.",
                                  "learningObjective": "Dominar SVD e identificar direções fortes/fracas em plantas multivariáveis.",
                                  "commonMistakes": "Confundir σ_max com ganho nominal ou ignorar dependência em frequência."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar impacto das direções fortes na rejeição de distúrbios",
                                  "subSteps": [
                                    "Lembre que rejeição de distúrbio é dada por T_d = G K (I + G K)^{-1}, aproximada por σ_min(G) em direções fortes.",
                                    "Simule um distúrbio na direção forte (vetor singular direito de σ_max).",
                                    "Compare resposta com distúrbio na direção fraca e discuta limitação.",
                                    "Relacione com teorema de limitação: ||T_d||_∞ ≥ 1 / σ_min(K) em certas frequências.",
                                    "Quantifique o trade-off: alta rejeição em uma direção amplifica em outra."
                                  ],
                                  "verification": "Simulação mostra pico na resposta de distúrbio alinhado com direção forte.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "MATLAB/Simulink para simulação, modelo de planta 2x2 (ex: acoplamento de motores).",
                                  "tips": "Escolha distúrbios unitários nos vetores singulares para clareza.",
                                  "learningObjective": "Explicar como σ_max limita supressão de distúrbios localmente.",
                                  "commonMistakes": "Ignorar que controlador não pode compensar inerente não-minimum phase ou acoplamento."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar impacto das direções fracas na robustez a incertezas",
                                  "subSteps": [
                                    "Defina robustez via margem de estabilidade: ||Δ|| < 1 / ||T|| onde T = (I + GK)^{-1} GK.",
                                    "Simule incerteza multiplicativa Δ na direção fraca (vetor de σ_min).",
                                    "Observe como pequenas Δ causam grandes ||T|| devido a 1/σ_min(G).",
                                    "Discuta teorema de Bode integral multivariável: limitação em loop shaping por σ_min.",
                                    "Compare com sistema SISO para destacar diferença multivariável."
                                  ],
                                  "verification": "Gráfico de Nyquist mostra instabilidade para Δ pequena na direção fraca.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Ferramentas de análise de robustez (mu-toolbox no MATLAB), modelo com incerteza.",
                                  "tips": "Use μ-síntese ou loop shaping para visualizar trade-offs.",
                                  "learningObjective": "Entender como σ_min dita sensibilidade a modelagem erros.",
                                  "commonMistakes": "Subestimar amplificação em direções fracas como apenas 'ganho baixo'."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Relacionar com teoremas de limitação de Bode multivariáveis",
                                  "subSteps": [
                                    "Estude teorema de Bode para MIMO: ∫ log(σ_min(G(jω))) dω limitado.",
                                    "Aplique a exemplos: explique por que não se pode ter bom tracking e rejeição simultâneos.",
                                    "Deriva qualitativamente limitação de Freudenberg e Looze em direções singulares.",
                                    "Crie diagrama resumindo impactos: forte → distúrbios, fraca → robustez.",
                                    "Discuta estratégias de design: desacoplamento ou LQG."
                                  ],
                                  "verification": "Resumo escrito conectando SVD, impactos e teoremas com referências corretas.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Livro 'Multivariable Feedback Control' de Skogestad, notas de aula.",
                                  "tips": "Memorize: 'forte ruim para distúrbios, fraca ruim para robustez'.",
                                  "learningObjective": "Integrar conceitos em framework teórico de limitações fundamentais.",
                                  "commonMistakes": "Confundir com limites SISO ou ignorar não-linearidades em SVD."
                                }
                              ],
                              "practicalExample": "Em um sistema de controle de dois motores acoplados (matriz G(s) com σ_max alta em ω=1 rad/s), um distúrbio torque na direção forte causa oscilação persistente apesar de controlador ótimo, enquanto incerteza de 10% no ganho da direção fraca (σ_min) destrói estabilidade.",
                              "finalVerifications": [
                                "Explicar verbalmente o papel de σ_max na rejeição de distúrbios com exemplo numérico.",
                                "Plotar SVD de uma planta e identificar direções fortes/fracas corretamente.",
                                "Simular robustez falhando para Δ na direção fraca.",
                                "Citar teorema de Bode MIMO e implicações para design.",
                                "Discutir trade-off em um caso real como controle de aeronave.",
                                "Resolver exercício: dado G, prever impacto qualitativo."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de direções via SVD (90% correção).",
                                "Correta interpretação de impactos (distúrbios vs robustez).",
                                "Uso apropriado de simulações e teoremas (evidência visual).",
                                "Profundidade em substeps (cobertura completa).",
                                "Clareza em explicações e avoidance de erros comuns.",
                                "Integração interdisciplinar e aplicação real."
                              ],
                              "crossCurricularConnections": [
                                "Álgebra Linear: Decomposição SVD e propriedades de matrizes.",
                                "Matemática Aplicada: Análise de singularidades e integrais de Bode.",
                                "Física: Dinâmica de sistemas acoplados e estabilidade.",
                                "Engenharia de Software: Implementação em MATLAB/Python para análise.",
                                "Estatística: Modelagem de incertezas e análise de sensibilidade."
                              ],
                              "realWorldApplication": "No controle de flight de drones, direções fortes limitam rejeição de rajadas de vento assimétricas, enquanto direções fracas causam instabilidade com variações de massa de carga, guiando designs de controladores H∞ para robustez."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.7.4.1.3",
                            "name": "Aplicar SVD em exemplos práticos multivariáveis",
                            "description": "Resolver um exemplo numérico de um sistema 2x2, plotando singular values e vetores singulares para visualizar direções fortes e fracas e discutir implicações para o projeto de controladores.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Selecionar e preparar o exemplo numérico de sistema multivariável 2x2",
                                  "subSteps": [
                                    "Escolha uma matriz de ganho DC 2x2 representativa de um sistema MIMO, como A = [[1, 0.2], [0.2, 1]], que simula acoplamento moderado em um processo industrial.",
                                    "Verifique as propriedades da matriz: dimensões, simetria e condicionalidade inicial usando norma.",
                                    "Defina o contexto de controle: entradas (u1, u2) como atuadores e saídas (y1, y2) como sensores em um sistema como um tanque duplo.",
                                    "Anote as entradas e saídas esperadas para direções fortes (alta ganho) e fracas (baixa ganho).",
                                    "Prepare um ambiente de computação com software pronto (MATLAB ou Python)."
                                  ],
                                  "verification": "Matriz A documentada com contexto físico escrito e ambiente de software aberto com matriz carregada.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Matriz numérica 2x2",
                                    "Software: MATLAB ou Python (NumPy)",
                                    "Papel e caneta para anotações"
                                  ],
                                  "tips": "Escolha matrizes assimétricas para destacar acoplamento realista; teste cond(A) > 10 para ill-conditioned.",
                                  "learningObjective": "Compreender como modelar um sistema multivariável real como matriz 2x2 para análise SVD.",
                                  "commonMistakes": [
                                    "Usar matrizes singulares (det=0), invalidando SVD completo",
                                    "Ignorar contexto físico, perdendo motivação prática"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Calcular a decomposição SVD da matriz",
                                  "subSteps": [
                                    "Compute os valores singulares σ1 ≥ σ2 usando svd(A) no software ou manualmente via autovalores de A^T A.",
                                    "Encontre as matrizes U e V: U de autovetores de A A^T, V de A^T A.",
                                    "Verifique a decomposição: A ≈ U Σ V^T, computando o erro de reconstrução ||A - U Σ V^T|| < 1e-10.",
                                    "Ordene singular values decrescente e identifique σ_max (direção forte) e σ_min (direção fraca).",
                                    "Salve U, Σ, V em variáveis para plotting."
                                  ],
                                  "verification": "SVD computada corretamente com erro de reconstrução < 1e-10 e singular values listados.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Software: MATLAB (svd()) ou Python (numpy.linalg.svd())",
                                    "Calculadora para verificação manual opcional"
                                  ],
                                  "tips": "Use full_matrices=False em NumPy para economia computacional em 2x2; sempre normalize colunas de U/V.",
                                  "learningObjective": "Executar SVD numericamente e validar precisão da decomposição.",
                                  "commonMistakes": [
                                    "Confundir ordem de U e V (U para saídas, V para entradas)",
                                    "Não ordenar singular values decrescente"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Plotar singular values e vetores singulares para visualização",
                                  "subSteps": [
                                    "Plote barra de singular values σ1 e σ2 para comparar magnitudes (eixo y log se necessário).",
                                    "Visualize vetores singulares: plote V[:,1] como direção forte de entrada e U[:,1] como direção forte de saída em plano 2D.",
                                    "Plote direção fraca V[:,2] e U[:,2] no mesmo gráfico com setas coloridas e legendas.",
                                    "Adicione elipse de singular values: plote Σ elipse para mostrar stretching das direções.",
                                    "Exporte plots com títulos como 'Direções Fortes/Fracas via SVD de A'."
                                  ],
                                  "verification": "Gráficos gerados mostrando σ1 > σ2, direções ortogonais e elipse de deformação.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Software: MATLAB (svd, plot, quiver) ou Python (matplotlib, numpy.meshgrid para elipse)"
                                  ],
                                  "tips": "Use quiver() para vetores unitários; escala logs para σ_min pequeno; rotule eixos como 'Entrada 1/2' vs 'Saída 1/2'.",
                                  "learningObjective": "Visualizar geometricamente como SVD revela direções de ganho máximo/mínimo.",
                                  "commonMistakes": [
                                    "Plotar vetores não normalizados (comprimento >1)",
                                    "Esquecer legendas, confundindo forte/fraca"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar direções fortes/fracas e discutir implicações para controladores",
                                  "subSteps": [
                                    "Interprete: direção forte V1 indica entrada mais efetiva para saída U1; cond(A)=σ1/σ2 mede dificuldade de controle.",
                                    "Discuta desafios: em direção fraca, ruído amplificado; necessidade de pré-compensadores V ou LTR.",
                                    "Proponha design: alinhe loops de controle com direções singulares para desacoplamento.",
                                    "Simule resposta: aplique entrada ao longo V1 vs V2 e compare ||y||.",
                                    "Escreva relatório de 1 página com plots, valores e recomendações."
                                  ],
                                  "verification": "Relatório escrito com interpretação quantitativa (cond(A)) e pelo menos 2 implicações para controle MIMO.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Plots do step 3",
                                    "Editor de texto para relatório"
                                  ],
                                  "tips": "Calcule cond(A) explicitamente; relacione com robustez H-infinito para controle avançado.",
                                  "learningObjective": "Conectar análise SVD a estratégias práticas de projeto de controladores multivariáveis.",
                                  "commonMistakes": [
                                    "Ignorar cond(A) >20 como ill-conditioned",
                                    "Não ligar a aplicações reais como desacoplamento"
                                  ]
                                }
                              ],
                              "practicalExample": "Para matriz A = [[1, 0.2], [0.2, 1]] (ganhos cruzados em dois tanques acoplados): SVD dá σ1≈1.08, σ2≈0.92; direção forte V1=[0.85, 0.53], fraca V2=[-0.53, 0.85]. Plot mostra stretching principal ao longo diagonal, implicando controle diagonal eficiente mas ajuste para fraca.",
                              "finalVerifications": [
                                "SVD de A reconstruída com erro <1e-10.",
                                "Plots exibem σ1>σ2, vetores ortogonais e elipse de singular values.",
                                "Condição cond(A)=σ1/σ2 calculada e interpretada (>1 indica acoplamento).",
                                "Relatório discute pelo menos duas implicações para controladores (ex: alinhamento de loops, sensibilidade).",
                                "Simulação de resposta em direções forte/fraca confirma análise.",
                                "Conexão explícita com desafios multivariáveis (acoplamento, robustez)."
                              ],
                              "assessmentCriteria": [
                                "Precisão numérica da SVD (erro de reconstrução mínima).",
                                "Qualidade visual dos plots (clareza, legendas, escalas adequadas).",
                                "Profundidade da interpretação (quantitativa: valores σ; qualitativa: direções).",
                                "Relevância das implicações para engenharia de controle (desacoplamento, LQG).",
                                "Completude do relatório (plots integrados, recomendações acionáveis).",
                                "Criatividade na extensão (ex: simulação dinâmica ou variação de A)."
                              ],
                              "crossCurricularConnections": [
                                "Álgebra Linear: autovalores e decomposições matriciais.",
                                "Programação Numérica: uso de NumPy/MATLAB para SVD e visualização.",
                                "Física/Dinâmica: modelagem de sistemas acoplados como massas-molas.",
                                "Estatística: análise de variância principal (PCA) via SVD.",
                                "Otimização: minimização de norma via direções singulares."
                              ],
                              "realWorldApplication": "Em controle de aeronaves MIMO (roll/pitch), SVD identifica direções fortes (elevador para pitch) vs fracas (aleron cruzado), guiando design de leis de controle desacopladas e alocação de atuadores em flight controllers como no Boeing 787."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.7.4.2",
                        "name": "Robustez em Sistemas Multivariáveis",
                        "description": "Desafios associados à robustez em presença de acoplamentos entre canais, onde incertezas não estruturadas podem amplificar efeitos em direções fracas, exigindo métricas como margens de estabilidade estruturadas e análise μ.",
                        "specificSkills": [
                          {
                            "id": "10.1.7.4.2.1",
                            "name": "Avaliar robustez usando norma H-infinito",
                            "description": "Calcular a norma H∞ do sistema em malha fechada com incertezas aditivas ou multiplicativas, verificando se ||T||∞ < 1/||Δ||∞ para estabilidade robusta em sistemas LIT multivariáveis.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Modelar o sistema em malha fechada com incertezas aditivas ou multiplicativas",
                                  "subSteps": [
                                    "Identifique o controlador K(s), a planta nominal P(s) e as incertezas Δ (aditiva: P = P0 + Δ; multiplicativa: P = P0(1 + Δ))",
                                    "Derive a função de transferência em malha fechada T(s) = (P K)/(1 + P K) para o sinal de saída relevante",
                                    "Defina a estrutura de incerteza: para robustez, considere Tzw onde z é saída de performance e w entrada de perturbação/incerteza",
                                    "Represente o sistema generalizado usando blocos de incerteza normalizados (||Δ||∞ ≤ 1)",
                                    "Verifique dimensionalidade para sistemas multivariáveis (MIMO)"
                                  ],
                                  "verification": "Confirme que o diagrama de blocos mostra corretamente Tzw conectada a Δ, com singular values definidos",
                                  "estimatedTime": "1-2 horas",
                                  "materials": [
                                    "MATLAB/Simulink",
                                    "Livro 'Essentials of Robust Control' de Kemin Zhou",
                                    "Folha de papel para diagramas"
                                  ],
                                  "tips": "Sempre normalize Δ para ||Δ||∞ ≤ 1 para simplificar a condição de robustez",
                                  "learningObjective": "Compreender a estrutura padrão de análise μ para robustez H∞ em sistemas com incertezas estruturadas",
                                  "commonMistakes": [
                                    "Confundir incerteza aditiva com multiplicativa",
                                    "Esquecer de considerar MIMO (usar sigma_bar em vez de |G(jω)|)"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Derivar e computar a função complementar de sensibilidade T(jω)",
                                  "subSteps": [
                                    "Calcule T(s) = P K (I + P K)^{-1} ou equivalentemente para o closed-loop",
                                    "Para robustez: foque em T (complementary sensitivity) para incertezas multiplicativas de alto ganho",
                                    "Use transformada de Laplace e expresse em termos de frequência jω",
                                    "Plote as curvas de ganho singular σ_bar(T(jω)) vs. ω usando ferramentas numéricas",
                                    "Identifique picos de ganho que indicam potenciais violações de robustez"
                                  ],
                                  "verification": "Gere plot de Bode de σ_bar(T(jω)) e confirme que o pico máximo é visível",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "MATLAB Control System Toolbox (norm, sigma)",
                                    "Python Control Library (control.norm)"
                                  ],
                                  "tips": "Use logspace para ω para cobrir todo o espectro de frequências eficientemente",
                                  "learningObjective": "Dominar o cálculo da complementary sensitivity e sua interpretação em termos de ganho singular",
                                  "commonMistakes": [
                                    "Usar ganho de pico em vez de norma H∞ (sup σ_bar)",
                                    "Ignorar wrap-around em MATLAB plot"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular a norma H∞ de T e de Δ",
                                  "subSteps": [
                                    "Compute ||T||∞ = sup_ω σ_bar(T(jω)) usando função hinfnorm() no MATLAB",
                                    "Estime ||Δ||∞ a partir de dados experimentais ou bounds: ||Δ||∞ = max singular value over uncertainty set",
                                    "Para Δ aditiva/multiplicativa, derive bounds analíticos ou use Monte Carlo para amostragem",
                                    "Valide numericamente com grid de frequências denso: norm(T, inf)",
                                    "Registre o valor exato de ||T||∞ e seu ω_peak"
                                  ],
                                  "verification": "Execute comando [gamma, wp] = hinfnorm(T) e anote gamma < 1 para estabilidade nominal",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "MATLAB Robust Control Toolbox",
                                    "Documentação de hinfnorm",
                                    "Notebook Jupyter para logs"
                                  ],
                                  "tips": "Para MIMO, sempre use sigma(T,jw) para máxima singular value",
                                  "learningObjective": "Aplicar computação numérica precisa da norma H∞ em sistemas LIT MIMO",
                                  "commonMistakes": [
                                    "Confundir ||T||∞ com ||S||∞ (sensibilidade)",
                                    "Usar norma 2 em vez de H∞"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificar a condição de robustez ||T||∞ < 1/||Δ||∞ e interpretar resultados",
                                  "subSteps": [
                                    "Calcule threshold = 1 / ||Δ||∞",
                                    "Compare: se ||T||∞ < threshold, sistema é robustamente estável",
                                    "Analise margens: distance to instability = 1/||T||∞ para ||Δ||∞",
                                    "Gere relatório com plots de σ_bar(T) e linha horizontal 1/||Δ||∞",
                                    "Teste sensibilidade com variações de Δ para validação"
                                  ],
                                  "verification": "Confirme boolean: robusto = (hinfnorm(T) < 1/hinfnorm(Delta)) e documente",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "MATLAB para plotting (bodeplot, sigma)",
                                    "Relatório template LaTeX ou Word"
                                  ],
                                  "tips": "Se ||T||∞ > 1/||Δ||∞, sugira redesign do controlador (ex: loop shaping)",
                                  "learningObjective": "Interpretar a condição small-gain theorem para garantia de estabilidade robusta",
                                  "commonMistakes": [
                                    "Inverter a condição (querer ||T||∞ > 1/||Δ||∞)",
                                    "Esquecer normalização de Δ"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um sistema de controle multivariable de um reator químico com 2 entradas (fluxos) e 2 saídas (temperaturas), modelado como P(s) MIMO 2x2 com incerteza multiplicativa Δ de 20% (||Δ||∞=0.2). Calcule ||T||∞=4.5; threshold=5. Verificação: 4.5<5 → robusto. Use MATLAB: sys = pck(P,K); T=feedback(sys,1); gamma=hinfnorm(T).",
                              "finalVerifications": [
                                "||T||∞ calculado corretamente com valor e frequência pico",
                                "||Δ||∞ estimado de dados reais ou bounds",
                                "Condição ||T||∞ < 1/||Δ||∞ satisfeita e justificada",
                                "Plots de σ_bar(T(jω)) e threshold exibidos",
                                "Análise para aditiva e multiplicativa confirmada",
                                "Relatório com interpretação de robustez gerado"
                              ],
                              "assessmentCriteria": [
                                "Precisão no cálculo de normas H∞ (erro <1%)",
                                "Correta modelagem de incertezas aditivas/multiplicativas",
                                "Interpretação física da condição small-gain",
                                "Uso apropriado de ferramentas numéricas para MIMO",
                                "Clareza nos plots e relatório final",
                                "Identificação de erros comuns evitados"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Análise funcional e valores singulares (SVD)",
                                "Programação: Implementação numérica em MATLAB/Python (Control Toolbox)",
                                "Física: Modelagem dinâmica de sistemas reais com perturbações",
                                "Estatística: Amostragem Monte Carlo para bounds de incerteza",
                                "Engenharia de Software: Validação e verificação de modelos"
                              ],
                              "realWorldApplication": "Na indústria aeroespacial, avaliar robustez H∞ garante que controladores de flight envelope protejam contra variações de aerodinâmica (Δ multiplicativa) em jatos comerciais, evitando instabilidades durante turbulência, como nos sistemas fly-by-wire do Boeing 787."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.7.4.2.2",
                            "name": "Analisar margens de robustez multivariáveis",
                            "description": "Determinar margens de ganho e fase generalizadas para MIMO usando singular values, comparando com abordagens escalares e identificando degradação devido a acoplamentos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Fundamentos de Sistemas MIMO e Valores Singulares",
                                  "subSteps": [
                                    "Estude a representação matricial de plantas MIMO e o conceito de função de transferência multivariável.",
                                    "Revise decomposição em valores singulares (SVD) e defina valores singulares máximos (σ_max) e mínimos (σ_min).",
                                    "Entenda como σ_max(G(jω)) relaciona-se à norma H∞ para robustez.",
                                    "Identifique diferenças entre análise SISO e MIMO em termos de acoplamento dinâmico.",
                                    "Pratique SVD manual em matrizes 2x2 simples."
                                  ],
                                  "verification": "Resolva um exercício de SVD em uma matriz MIMO de baixa dimensão e confirme σ_max e σ_min.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Livro de Skogestad 'Multivariable Feedback Control'",
                                    "MATLAB ou Octave para SVD",
                                    "Notas de aula sobre MIMO"
                                  ],
                                  "tips": "Comece com matrizes pequenas para visualizar o impacto do acoplamento.",
                                  "learningObjective": "Compreender os blocos de construção matemáticos para análise de robustez MIMO.",
                                  "commonMistakes": [
                                    "Confundir σ_max com ganho DC",
                                    "Ignorar frequência ω na análise SVD",
                                    "Não normalizar matrizes antes do SVD"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Calcular Margens de Ganho e Fase Generalizadas",
                                  "subSteps": [
                                    "Defina margem de ganho generalizada como 1/σ_max(G(jω_c)) onde ω_c é frequência de crossover.",
                                    "Calcule margem de fase generalizada usando arg(min σ_max(G(jω))) para estabilidade.",
                                    "Implemente em software: plote σ_max e σ_min de G(jω) usando singular value plots (svd plot).",
                                    "Determine frequência de crossover multivariable ω_cg como onde σ_max(G(jω)) = 1.",
                                    "Compare com margens SISO tradicionais (ganho e fase margins)."
                                  ],
                                  "verification": "Gere plots de valores singulares para uma planta MIMO padrão e identifique margens numéricas.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "MATLAB Control System Toolbox (sigma command)",
                                    "Exemplos de plantas MIMO como Wood-Berry",
                                    "Calculadora simbólica para SVD analítica"
                                  ],
                                  "tips": "Use log scale para frequências e normalize ganhos para facilitar interpretação.",
                                  "learningObjective": "Dominar o cálculo quantitativo de margens generalizadas via SVD.",
                                  "commonMistakes": [
                                    "Usar σ_min em vez de σ_max para margem de ganho",
                                    "Esquecer de considerar direções de entrada/saída",
                                    "Não plotar Bode multivariable"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Comparar Abordagens Escalares e Identificar Degradação por Acoplamento",
                                  "subSteps": [
                                    "Analise o mesmo sistema MIMO pareando entradas/saídas para simular SISO (pairing analysis).",
                                    "Calcule margens SISO para pares selecionados e compare com margens generalizadas.",
                                    "Quantifique degradação: Δm = m_SISO - m_MIMO devido a acoplamento off-diagonal.",
                                    "Use Relative Gain Array (RGA) para avaliar acoplamento e correlacionar com perda de robustez.",
                                    "Simule perturbações em canais cruzados e observe impacto nas margens."
                                  ],
                                  "verification": "Produza tabela comparativa de margens SISO vs MIMO e explique diferenças em relatório curto.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "MATLAB rga command",
                                    "Simulink para simulações de loop aberto",
                                    "Planilhas para tabulação de resultados"
                                  ],
                                  "tips": "Escolha pares com RGA próximo de 1 para minimizar degradação.",
                                  "learningObjective": "Avaliar limitações das análises escalares em contextos multivariáveis.",
                                  "commonMistakes": [
                                    "Parear canais errados sem RGA",
                                    "Ignorar acoplamento em baixas frequências",
                                    "Comparar margens sem normalizar ganhos"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar Análise em Caso Prático e Sintetizar Insights",
                                  "subSteps": [
                                    "Selecione um benchmark MIMO (ex: destilador ou quadruped rotor).",
                                    "Calcule todas as margens e identifique bottlenecks de robustez.",
                                    "Proponha mitigações como desacopladores ou controladores robustos (H∞).",
                                    "Documente trade-offs entre performance e robustez.",
                                    "Valide com simulação de incertezas paramétricas."
                                  ],
                                  "verification": "Submeta relatório com plots, cálculos e recomendações para o sistema analisado.",
                                  "estimatedTime": "2.5 horas",
                                  "materials": [
                                    "Benchmark models do MATLAB (ex: distil.c)",
                                    "Simulink Control Design",
                                    "Referências de artigos IEEE sobre MIMO robustez"
                                  ],
                                  "tips": "Foque em frequências críticas para controle (0.1-10 rad/s).",
                                  "learningObjective": "Integrar análise de robustez em design de controle prático.",
                                  "commonMistakes": [
                                    "Sobrestimar robustez ignorando incertezas não modeladas",
                                    "Não considerar ruído em singular values",
                                    "Generalizar resultados de um caso só"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um sistema de controle de destilador binário (2x2 MIMO), calcule σ_max(G(jω)) revelando margem de ganho de 2.5 dB vs 6 dB em análise SISO pareada, atribuindo degradação de 3.5 dB ao acoplamento hidrodinâmico entre tops e bottoms.",
                              "finalVerifications": [
                                "Calcule corretamente margens generalizadas para um sistema MIMO dado.",
                                "Gere e interprete singular value plots com crossover frequencies.",
                                "Compare quantitativamente margens SISO vs MIMO com RGA.",
                                "Identifique fontes de degradação por acoplamento em exemplo prático.",
                                "Explique impacto em estabilidade robusta com perturbações.",
                                "Proponha melhorias baseadas na análise."
                              ],
                              "assessmentCriteria": [
                                "Precisão nos cálculos de SVD e margens (erro <5%).",
                                "Qualidade e legibilidade dos plots de valores singulares.",
                                "Profundidade na comparação SISO-MIMO com métricas quantitativas.",
                                "Correta identificação e quantificação de degradação por acoplamento.",
                                "Clareza na explicação de conceitos e insights práticos.",
                                "Uso adequado de ferramentas e validação por simulação."
                              ],
                              "crossCurricularConnections": [
                                "Álgebra Linear: Decomposição SVD e normas matriciais.",
                                "Programação Numérica: Implementação em MATLAB/Python para análise de sistemas.",
                                "Processos Industriais: Aplicação em plantas químicas e aeroespaciais.",
                                "Otimização: Trade-offs em design H∞ robusto.",
                                "Estatística: Análise de incertezas e variância em singular values."
                              ],
                              "realWorldApplication": "Na indústria aeroespacial, análise de margens multivariáveis em flight control systems de aeronaves garante estabilidade robusta apesar de acoplamentos aerodinâmicos e variações de massa, prevenindo instabilidades como Dutch roll."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.7.4.2.3",
                            "name": "Introduzir análise μ para robustez estruturada",
                            "description": "Aplicar o valor μ estruturado para avaliar robustez contra incertezas blocais em sistemas multivariáveis, utilizando upper e lower bounds via μ-tools ou MATLAB Robust Control Toolbox.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os Conceitos Fundamentais da Análise μ",
                                  "subSteps": [
                                    "Estude a definição de Structured Singular Value (μ) como medida de robustez contra incertezas estruturadas.",
                                    "Revise o teorema básico de robustez: estabilidade robusta se μ < 1.",
                                    "Diferencie robustez não-estruturada (norma H∞) de robustez estruturada (μ).",
                                    "Explore exemplos simples de perturbações blocais (normais, diagonais).",
                                    "Analise o diagrama padrão de robustez com Δ (bloco de incerteza)."
                                  ],
                                  "verification": "Explique em suas palavras a diferença entre μ e norma H∞, e desenhe um diagrama de robustez com Δ.",
                                  "estimatedTime": "1-2 hours",
                                  "materials": [
                                    "Livro 'Multivariable Feedback Control' de Skogestad",
                                    "Documentação MATLAB Robust Control Toolbox",
                                    "Notas de aula sobre controle robusto"
                                  ],
                                  "tips": "Comece com exemplos 2x2 para visualizar intuição antes de generalizar.",
                                  "learningObjective": "Dominar os conceitos teóricos de μ e sua importância na robustez estruturada.",
                                  "commonMistakes": [
                                    "Confundir μ com valores singulares máximos sem estrutura.",
                                    "Ignorar a dependência da estrutura do bloco Δ."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Modelar Incertezas Estruturas como Blocos",
                                  "subSteps": [
                                    "Identifique tipos de incertezas blocais: reais, complexas, normais, estruturadas.",
                                    "Construa o bloco Δ representando incertezas em sistemas multivariáveis.",
                                    "Conecte o modelo nominal M com Δ no framework (M-Δ).",
                                    "Defina upper e lower bounds para μ(Δ): μ_upper via otimização, μ_lower via bounds conservativos.",
                                    "Pratique modelagem em um sistema simples como um controlador MIMO com incertezas paramétricas."
                                  ],
                                  "verification": "Crie um modelo Δ para um sistema 2x2 com incertezas em ganhos e demonstre a conexão com M.",
                                  "estimatedTime": "2 hours",
                                  "materials": [
                                    "MATLAB Robust Control Toolbox (funções musyn, mu]",
                                    "Tutoriais online de μ-analysis",
                                    "Paper 'μ-Synthesis' de Doyle"
                                  ],
                                  "tips": "Use blocos LFT (Linear Fractional Transformation) para representar incertezas de forma hierárquica.",
                                  "learningObjective": "Capacitar a modelagem precisa de incertezas blocais em sistemas reais.",
                                  "commonMistakes": [
                                    "Modelar incertezas como não-estruturadas quando há correlações.",
                                    "Esquecer normalização de Δ para ||Δ|| ≤ 1."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular Bounds de μ Usando Ferramentas Computacionais",
                                  "subSteps": [
                                    "Instale e configure μ-tools ou MATLAB Robust Control Toolbox.",
                                    "Implemente cálculo de μ_lower usando valores singulares de M.",
                                    "Calcule μ_upper via otimização D-K (iterativa).",
                                    "Execute simulações para um sistema exemplo e plote μ vs. frequência.",
                                    "Compare gaps entre upper e lower bounds e interprete quando são apertados."
                                  ],
                                  "verification": "Gere um plot de μ(frequência) para um sistema teste e confirme μ < 1 em banda de interesse.",
                                  "estimatedTime": "2-3 hours",
                                  "materials": [
                                    "MATLAB com Robust Control Toolbox",
                                    "μ-Tools (se disponível)",
                                    "Script exemplo de μ-analysis"
                                  ],
                                  "tips": "Use seltool() no MATLAB para visualizar seleções estruturais e escalonamentos D.",
                                  "learningObjective": "Habilitar o uso prático de ferramentas para computação de μ.",
                                  "commonMistakes": [
                                    "Não escalonar adequadamente com escalas D para bounds apertados.",
                                    "Interpretar μ_upper como bound exato sem verificar gap."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar e Interpretar Análise μ em Sistemas Multivariáveis",
                                  "subSteps": [
                                    "Selecione um sistema multivariável real (ex: planta química ou aeroespacial).",
                                    "Avalie robustez: verifique se μ < 1/γ onde γ é o ganho desejado.",
                                    "Analise sensibilidade a estruturas de Δ específicas.",
                                    "Itere design do controlador se μ > 1 em certas frequências.",
                                    "Documente conclusões e sensibilidade a mudanças em parâmetros."
                                  ],
                                  "verification": "Produza relatório com plots μ, conclusão de robustez e recomendações de design.",
                                  "estimatedTime": "2-3 hours",
                                  "materials": [
                                    "Exemplo de benchmark MIMO (ex: East plant)",
                                    "MATLAB Simulink para simulação",
                                    "Ferramentas de plotagem"
                                  ],
                                  "tips": "Foque em frequências crossover para decisões críticas de design.",
                                  "learningObjective": "Integrar análise μ em fluxos de design de controle robusto.",
                                  "commonMistakes": [
                                    "Sobrepor robustez em todo espectro sem priorizar bandas operacionais.",
                                    "Ignorar trade-offs com performance nominal."
                                  ]
                                }
                              ],
                              "practicalExample": "Em um sistema de controle multivariable para estabilização de um satélite, modele incertezas blocais nos atuadores de thrusters (Δ com estrutura diagonal real). Use MATLAB para calcular μ e verificar se o controlador mantém estabilidade robusta apesar de variações de 20% nos ganhos, plotando μ < 0.8 em frequências abaixo de 1 rad/s.",
                              "finalVerifications": [
                                "Defina corretamente μ e sua relação com estabilidade robusta.",
                                "Modele um bloco Δ para incertezas estruturadas em um sistema 2x2.",
                                "Gere plots de upper/lower μ usando MATLAB.",
                                "Interprete resultados: robusto se μ < 1.",
                                "Identifique quando bounds são conservativos.",
                                "Aplique em um exemplo real e proponha melhorias."
                              ],
                              "assessmentCriteria": [
                                "Precisão conceitual: explicação clara de μ vs. H∞ (30%).",
                                "Modelagem correta de Δ e framework M-Δ (25%).",
                                "Execução computacional sem erros em MATLAB (20%).",
                                "Interpretação quantitativa de bounds e robustez (15%).",
                                "Relatório estruturado com plots e conclusões (10%)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Álgebra linear (valores singulares estruturados) e otimização convexa.",
                                "Programação: Scripting avançado em MATLAB e uso de toolboxes numéricas.",
                                "Física: Dinâmica de sistemas multivariáveis e modelagem de incertezas reais.",
                                "Estatística: Análise de sensibilidade e bounds probabilísticos."
                              ],
                              "realWorldApplication": "Na indústria aeroespacial, análise μ é essencial para certificação de controladores de voo em aeronaves comerciais (ex: Boeing 787), garantindo estabilidade robusta contra incertezas estruturais, aerodinâmicas e de fabricação, evitando falhas catastróficas como flutter."
                            },
                            "estimatedTime": "2.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.7.4.3",
                        "name": "Desempenho em Presença de Incertezas",
                        "description": "Manter especificações de desempenho (como rastreamento e rejeição de distúrbios) em sistemas multivariáveis sob incertezas paramétricas e dinâmicas, destacando trade-offs entre desempenho nominal e robusto.",
                        "specificSkills": [
                          {
                            "id": "10.1.7.4.3.1",
                            "name": "Modelar incertezas em sistemas multivariáveis",
                            "description": "Construir modelos de incertezas na forma padrão (P, K, Δ) para sistemas MIMO, incluindo perturbações normais e não-normais, e analisar sensibilidade via funções T e S.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender a forma padrão do loop de controle para sistemas MIMO",
                                  "subSteps": [
                                    "Revise os conceitos básicos de sistemas MIMO e suas matrizes de transferência P(s).",
                                    "Identifique os componentes da forma padrão: planta nominal P, controlador K e incerteza Δ.",
                                    "Estude as interconexões: série (P K), feedback e entradas de incerteza.",
                                    "Aprenda a representar perturbações em entradas e saídas usando diagramas de bloco.",
                                    "Pratique desenhando a forma padrão para um sistema MIMO 2x2 simples."
                                  ],
                                  "verification": "Desenhe corretamente o diagrama da forma padrão para um sistema MIMO exemplo e explique cada componente.",
                                  "estimatedTime": "1-2 horas",
                                  "materials": [
                                    "Livro de Skogestad 'Multivariable Feedback Control'",
                                    "MATLAB/Simulink para simulações",
                                    "Notas de aula sobre controle multivariável"
                                  ],
                                  "tips": [
                                    "Use singular values para visualizar normas de matrizes MIMO.",
                                    "Comece com sistemas 2x2 para intuição antes de generalizar."
                                  ],
                                  "learningObjective": "Compreender e representar visualmente a estrutura padrão de loop de controle MIMO com incertezas.",
                                  "commonMistakes": [
                                    "Confundir incertezas aditivas com multiplicativas.",
                                    "Ignorar a direção das setas em diagramas de bloco MIMO."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Modelar incertezas normais (H-infinito) em sistemas MIMO",
                                  "subSteps": [
                                    "Defina incertezas normais: aditivas (Δ_a), multiplicativas de entrada/saída (Δ_i, Δ_o).",
                                    "Calcule normas H-infinito das incertezas usando funções svd em MATLAB.",
                                    "Construa Δ como bloco diagonal normalizado: ||Δ||_∞ ≤ 1.",
                                    "Incorpore perturbações normais no modelo P K Δ.",
                                    "Simule respostas nominais e com incertezas para validar."
                                  ],
                                  "verification": "Gere um modelo Δ normalizado para uma planta MIMO dada e verifique ||Δ||_∞ ≤ 1 via simulação.",
                                  "estimatedTime": "2-3 horas",
                                  "materials": [
                                    "MATLAB Control System Toolbox",
                                    "Exemplos de Skogestad Capítulo 9",
                                    "Notebook Jupyter para cálculos"
                                  ],
                                  "tips": [
                                    "Normalizar incertezas facilita análise de robustez.",
                                    "Use sigma plot para visualizar singular values."
                                  ],
                                  "learningObjective": "Modelar e normalizar incertezas normais em representação padrão para análise H-infinito.",
                                  "commonMistakes": [
                                    "Não normalizar Δ corretamente, levando a ||Δ||_∞ > 1.",
                                    "Confundir normas 2 e infinito."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Modelar incertezas não-normais e perturbações especiais",
                                  "subSteps": [
                                    "Estude incertezas não-normais: norma L1 para perturbações com atraso ou não-mínimo fase.",
                                    "Inclua perturbações em entradas de referência, ruído e distúrbios não-normais.",
                                    "Construa Δ não-normal para casos como atrasos (Pade approximation).",
                                    "Integre ao modelo padrão e compare com casos normais.",
                                    "Avalie impacto em estabilidade via μ-analysis básico."
                                  ],
                                  "verification": "Crie um modelo com incerteza não-normal (ex: atraso) e mostre diferença nas normas.",
                                  "estimatedTime": "2-3 horas",
                                  "materials": [
                                    "MATLAB Robust Control Toolbox",
                                    "Artigo sobre μ-synthesis",
                                    "Simulink para modelar atrasos"
                                  ],
                                  "tips": [
                                    "Aproximações Pade para atrasos são essenciais em prática.",
                                    "Foque em perturbações realistas como ruído colorido."
                                  ],
                                  "learningObjective": "Incorporar e modelar incertezas não-normais no framework padrão MIMO.",
                                  "commonMistakes": [
                                    "Tratar todas incertezas como normais, subestimando robustez.",
                                    "Ignorar efeitos de fase em perturbações."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar sensibilidade e robustez via funções T e S",
                                  "subSteps": [
                                    "Defina funções de sensibilidade S = (I + P K)^(-1) e complementar T = P K S.",
                                    "Calcule singular values de S e T para análise de desempenho/robustez.",
                                    "Verifique condições de robustez: ||T Δ||_∞ < 1 para estabilidade.",
                                    "Analise trade-offs: alto loop gain reduz S mas aumenta T.",
                                    "Simule e plote Bode/sigma para um caso completo."
                                  ],
                                  "verification": "Para um modelo P K Δ, confirme estabilidade robusta plotando sigma(S) e sigma(T) vs sigma(Δ).",
                                  "estimatedTime": "2-4 horas",
                                  "materials": [
                                    "MATLAB functions: sigma, norm, bode",
                                    "Exemplos de Doyle 'Robust and Optimal Control'",
                                    "Gráficos interativos via Control Toolbox"
                                  ],
                                  "tips": [
                                    "Use sigma plots em frequência para intuição MIMO.",
                                    "Verifique crossover frequencies para design."
                                  ],
                                  "learningObjective": "Analisar sensibilidade e robustez usando funções T e S em sistemas com incertezas.",
                                  "commonMistakes": [
                                    "Analisar apenas ganho escalar em MIMO.",
                                    "Esquecer de usar valores singulares max/min."
                                  ]
                                }
                              ],
                              "practicalExample": "Considere um sistema MIMO 2x2 de um misturador químico com planta P(s) = [1/(s+1) 0.5/(s+1); 0.5/(s+1) 1/(s+2)]. Modele incerteza multiplicativa de saída Δ_o com norma H∞=0.2, incluindo perturbação não-normal de atraso de 0.1s em um canal. Construa P K Δ com K diagonal PID, e analise robustez via sigma(T) e sigma(S), confirmando estabilidade para ||Δ||∞<1.",
                              "finalVerifications": [
                                "Conseguiu desenhar e simular a forma padrão P K Δ para um sistema MIMO 2x2.",
                                "Modelou corretamente incertezas normais e não-normais com normas apropriadas.",
                                "Calculou e plotou funções S e T, identificando frequências críticas.",
                                "Verificou condição de robustez ||T Δ||∞ < 1 via simulação.",
                                "Identificou trade-offs em desempenho vs robustez.",
                                "Aplicou análise a um exemplo prático completo."
                              ],
                              "assessmentCriteria": [
                                "Precisão na modelagem de Δ (normalização correta: 100% dos casos).",
                                "Qualidade dos plots de sigma(S), sigma(T) e análise de robustez (clareza e interpretação).",
                                "Correção na verificação de estabilidade robusta (sem falsos positivos).",
                                "Profundidade na discussão de perturbações não-normais.",
                                "Capacidade de simular e iterar designs K para atender specs.",
                                "Integração de todos elementos em um relatório coeso."
                              ],
                              "crossCurricularConnections": [
                                "Probabilidade e Estatística: Modelagem estocástica de perturbações.",
                                "Otimização: Design de K via H-infinito ou LMI.",
                                "Processos Industriais: Aplicação em PLC/SCADA multivariáveis.",
                                "Física/Mecânica: Modelos dinâmicos de plantas MIMO reais.",
                                "Programação Numérica: Uso de toolboxes MATLAB para análise."
                              ],
                              "realWorldApplication": "Em controle de aeronaves MIMO (roll-pitch-yaw), modela-se incertezas aerodinâmicas (Δ em coeficientes lift/drag) e atrasos de atuadores; análise T/S garante robustez a variações de velocidade/massa, evitando instabilidades em manobras."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.7.4.3.2",
                            "name": "Avaliar trade-offs desempenho-robustez",
                            "description": "Usar gráficos de Nichols ou singular values para quantificar conflitos entre desempenho em banda passante e robustez em frequências altas, aplicando limites de Skogestad-Postlethwaite.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Conceitos Fundamentais de Trade-offs em Controle Multivariável",
                                  "subSteps": [
                                    "Estude a definição de desempenho (banda passante) e robustez (margens em frequências altas).",
                                    "Revise gráficos de Nichols: entenda como crossover frequency e phase margins indicam trade-offs.",
                                    "Aprenda sobre singular values: máximo e mínimo singular values para quantificar incertezas.",
                                    "Leia sobre limites de Skogestad-Postlethwaite: γ(ω) ≤ 1/|T(jω)| para robustez.",
                                    "Identifique conflitos típicos: alta banda passante reduz robustez em altas frequências."
                                  ],
                                  "verification": "Resuma em um parágrafo os trade-offs e desenhe um esboço manual de um gráfico de Nichols com anotações.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Livro 'Multivariable Feedback Control' de Skogestad e Postlethwaite (capítulos iniciais), notas de aula, MATLAB para visualização básica.",
                                  "tips": "Use analogias como equilibrar velocidade e segurança em um carro para fixar conceitos.",
                                  "learningObjective": "Compreender qualitativamente os trade-offs entre desempenho e robustez usando ferramentas gráficas multivariáveis.",
                                  "commonMistakes": "Confundir singular values com Bode plots univariáveis; ignorar o papel das incertezas estruturadas."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Preparar o Modelo do Sistema Multivariável",
                                  "subSteps": [
                                    "Selecione um sistema MIMO exemplo (ex: planta 2x2 com matriz de transferência).",
                                    "Incorpore incertezas: adicione modelo multiplicativo Δ em frequências altas.",
                                    "Linearize o modelo se necessário e defina especificações de desempenho (ω_crossover desejado).",
                                    "Calcule a função loop aberta L(s) = G(s)C(s).",
                                    "Valide o modelo simulando respostas nominais em step."
                                  ],
                                  "verification": "Gere e plote a matriz de transferência em MATLAB; confirme estabilidade com pole-zero map.",
                                  "estimatedTime": "1 hora",
                                  "materials": "MATLAB/Simulink, toolbox Control System, arquivo .m com modelo exemplo (ex: wood-stove ou distillation column).",
                                  "tips": "Comece com sistemas benchmark como os do livro de Skogestad para evitar erros de modelagem.",
                                  "learningObjective": "Preparar um modelo realista que capture incertezas para análise de trade-offs.",
                                  "commonMistakes": "Esquecer normalização das entradas/saídas; usar modelos SISO em vez de MIMO."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Gerar Gráficos de Nichols e Singular Values",
                                  "subSteps": [
                                    "Plote o gráfico de Nichols para L(jω): identifique M_circles para desempenho.",
                                    "Calcule e plote singular values σ_max e σ_min de L(jω) e T(jω).",
                                    "Sobreponha curvas de incerteza |Δ(jω)| para visualizar conflitos.",
                                    "Analise visualmente: onde alta banda passante (σ_max alto) invade regiões de baixa robustez.",
                                    "Exporte figuras com legendas claras."
                                  ],
                                  "verification": "Identifique pelo menos duas regiões de conflito nos gráficos gerados.",
                                  "estimatedTime": "1 hora e 15 minutos",
                                  "materials": "MATLAB scripts para nichols() e sigma(), funções como loopshaping.",
                                  "tips": "Use logspace para frequências densas em altas ω para precisão.",
                                  "learningObjective": "Dominar a geração e interpretação gráfica de ferramentas para quantificar trade-offs.",
                                  "commonMistakes": "Escalas erradas nos eixos (use dB e deg corretamente); ignorar σ_min para robustez."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar Limites de Skogestad-Postlethwaite e Quantificar Trade-offs",
                                  "subSteps": [
                                    "Calcule o limite estruturado γ(ω) = σ_max[Δ(jω) T(jω)].",
                                    "Verifique condição: γ(ω) < 1 para robustez em todo ω.",
                                    "Ajuste controlador para mover crossover: aumente ganho para desempenho, cheque robustez.",
                                    "Quantifique trade-off: meça Δω_crossover vs. piora em peak γ.",
                                    "Documente iterações em tabela: desempenho vs. robustez métrica."
                                  ],
                                  "verification": "Produza um relatório com γ(ω) plot e tabela numérica mostrando trade-offs quantificados.",
                                  "estimatedTime": "1 hora e 30 minutos",
                                  "materials": "MATLAB mu-toolbox ou funções custom para structured singular value (μ-analysis).",
                                  "tips": "Itere com pidtune() inicial para baseline rápida.",
                                  "learningObjective": "Aplicar limites quantitativos para avaliar e otimizar trade-offs.",
                                  "commonMistakes": "Aplicar limites conservadores sem incertezas reais; confundir γ com ||T||_∞."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Sintetizar Análise e Propor Compromissos",
                                  "subSteps": [
                                    "Compare múltiplos controladores: tabule desempenho (ITAE) vs. robustez (peak γ).",
                                    "Desenhe fronteira de trade-off (Pareto-like).",
                                    "Recomende design ótimo baseado em pesos (ex: 70% robustez).",
                                    "Simule closed-loop com incertezas para validar.",
                                    "Escreva conclusões acionáveis."
                                  ],
                                  "verification": "Apresente gráfico Pareto e simulações que confirmem análise.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Simulink para simulações, Excel/MATLAB para tabelas.",
                                  "tips": "Priorize robustez em aplicações reais; use sensibilidade para tuning.",
                                  "learningObjective": "Sintetizar análise em decisões de design práticas.",
                                  "commonMistakes": "Overfitting ao nominal sem incertezas; ignorar não-linearidades."
                                }
                              ],
                              "practicalExample": "Em um processo de destilação 2x2 (coluna de destilação), use Nichols para L(jω) mostrando que aumentar ganho para ω_c = 1 rad/s eleva γ_peak de 0.8 para 1.5 em ω=10 rad/s, violando robustez; ajuste filtro notch para resolver.",
                              "finalVerifications": [
                                "Gráficos de Nichols/singular values corretamente gerados e anotados.",
                                "Cálculo de γ(ω) <1 confirmado em todo banda relevante.",
                                "Trade-off quantificado numericamente (ex: +20% desempenho custa -15% robustez).",
                                "Simulações com Δ mostram estabilidade mantida.",
                                "Relatório resume conflitos e recomendações.",
                                "Fronteira Pareto desenhada."
                              ],
                              "assessmentCriteria": [
                                "Precisão na geração e interpretação de gráficos multivariáveis (30%).",
                                "Correta aplicação de limites Skogestad-Postlethwaite (25%).",
                                "Quantificação clara de trade-offs com métricas (20%).",
                                "Validação via simulação com incertezas (15%).",
                                "Clareza e completude do relatório (10%)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Álgebra linear (decomposição SVD para singular values).",
                                "Programação: MATLAB/Simulink para análise numérica e visualização.",
                                "Física: Modelagem dinâmica de sistemas reais com incertezas.",
                                "Otimização: Análise Pareto para design multi-objetivo."
                              ],
                              "realWorldApplication": "No controle de aviões (aeroespacial), trade-offs garantem alta manobrabilidade (desempenho) sem oscilações perigosas sob turbulência (robustez), usando μ-síntese em flight controllers da Boeing."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.7.4.3.3",
                            "name": "Simular desempenho sob incertezas",
                            "description": "Implementar simulações em MATLAB de um sistema multivariável com incertezas aleatórias, medindo desvios em métricas de desempenho como tempo de assentamento e overshoot em diferentes canais.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Modelar o sistema multivariável",
                                  "subSteps": [
                                    "Definir a estrutura do sistema multivariável (ex: 2x2 ou 3x3) com matriz de transferência ou modelo em espaço de estados.",
                                    "Identificar parâmetros nominais do sistema (ganhos, constantes de tempo, acoplamentos).",
                                    "Implementar o modelo base no MATLAB usando funções como tf() ou ss().",
                                    "Testar a resposta nominal do sistema sem incertezas com step() ou lsim().",
                                    "Documentar o modelo em um script MATLAB."
                                  ],
                                  "verification": "Executar simulação nominal e verificar se as respostas em step coincidem com expectativas teóricas (ex: overshoot < 20%).",
                                  "estimatedTime": "1.5 horas",
                                  "materials": "MATLAB com Control System Toolbox; documentação de tf() e ss().",
                                  "tips": "Use sys = tf(num, den) para matrizes MIMO; visualize com step(sys).",
                                  "learningObjective": "Construir e validar um modelo matemático preciso de sistema multivariável.",
                                  "commonMistakes": "Ignorar acoplamentos entre canais; unidades inconsistentes nos parâmetros."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Introduzir incertezas aleatórias nos parâmetros",
                                  "subSteps": [
                                    "Identificar parâmetros sujeitos a incerteza (ex: ganhos ±10%, constantes de tempo ±5%).",
                                    "Gerar distribuições aleatórias usando randn() ou normrnd() para variações gaussianas.",
                                    "Criar uma função que gera N conjuntos de parâmetros perturbados (ex: N=100).",
                                    "Atualizar o modelo dinamicamente com novos parâmetros em loop.",
                                    "Salvar matriz de parâmetros perturbados em uma estrutura ou array."
                                  ],
                                  "verification": "Gerar histograma dos parâmetros perturbados e confirmar distribuição (média=0, desvio=esperado).",
                                  "estimatedTime": "1 hora",
                                  "materials": "MATLAB Statistics Toolbox; funções randn(), hist().",
                                  "tips": "Use rng('default') para reprodutibilidade; limite desvios para realismo (±20% máx).",
                                  "learningObjective": "Modelar incertezas paramétricas realistas e gerá-las computacionalmente.",
                                  "commonMistakes": "Gerar desvios assimétricos sem justificativa; N muito pequeno (<50)."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar simulações Monte Carlo no MATLAB",
                                  "subSteps": [
                                    "Configurar controlador multivariável (ex: MIMO PID ou LQR).",
                                    "Criar loop principal: para cada conjunto perturbado, simular resposta a entrada de referência.",
                                    "Usar lsim() ou sim() para simulações com tempo fixo (ex: 100s).",
                                    "Armazenar respostas temporais de todos canais em arrays 3D (tempo x canal x simulação).",
                                    "Otimizar código com parfor() se Parallel Computing Toolbox disponível."
                                  ],
                                  "verification": "Todas N simulações completam sem erros; tempo total <5min para N=100.",
                                  "estimatedTime": "2 horas",
                                  "materials": "MATLAB com Control e Parallel Toolbox; exemplos de sim().",
                                  "tips": "Pré-aloque arrays com zeros(); use figure para plots intermediários.",
                                  "learningObjective": "Executar simulações estocásticas eficientes para análise robusta.",
                                  "commonMistakes": "Não sincronizar tempos de simulação; loops ineficientes causando lentidão."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Medir e analisar desvios em métricas de desempenho",
                                  "subSteps": [
                                    "Extrair métricas por simulação: tempo de assentamento (settlingtime), overshoot (%) por canal.",
                                    "Calcular estatísticas: média, desvio padrão, percentil 95% das métricas.",
                                    "Plotar boxplots ou histogramas das métricas por canal.",
                                    "Comparar desvios nominais vs. perturbados (ex: Δovershoot >10%?).",
                                    "Gerar relatório com tabelas e conclusões sobre robustez."
                                  ],
                                  "verification": "Métricas calculadas para todos canais e simulações; plots legíveis com labels.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": "MATLAB com Signal Processing Toolbox; stepinfo() para métricas automáticas.",
                                  "tips": "Use stepinfo(t,y) para automação; exporte figs com saveas().",
                                  "learningObjective": "Quantificar impactos de incertezas em desempenho via estatísticas.",
                                  "commonMistakes": "Métricas erradas (ex: overshoot sem normalizar); ignorar canais acoplados."
                                }
                              ],
                              "practicalExample": "Simule um sistema 2x2 de dois tanques acoplados (matriz G(s) com ganhos K11=1, K12=0.5, etc.). Introduza incerteza ±15% nos ganhos. Aplique controlador diagonal PID, simule 200 runs Monte Carlo com rampa de referência, meça Δsettling time e overshoot no canal 1 vs. 2.",
                              "finalVerifications": [
                                "Simulações rodam sem erros para N≥100 casos.",
                                "Métricas (settling time, overshoot) calculadas corretamente para todos canais.",
                                "Estatísticas mostram desvios realistas (ex: σ_overshoot <15%).",
                                "Plots incluem boxplots e comparações nominal/perturbado.",
                                "Código comentado e reprodutível com rng seed.",
                                "Relatório resume robustez do sistema."
                              ],
                              "assessmentCriteria": [
                                "Precisão do modelo MIMO (resposta nominal <5% erro).",
                                "Adequação das incertezas (distribuição gaussiana, desvios realistas).",
                                "Eficiência computacional (tempo <10min para N=200).",
                                "Completude das métricas (todos canais, múltiplas stats).",
                                "Qualidade visual e interpretativa dos resultados.",
                                "Clareza do código e documentação."
                              ],
                              "crossCurricularConnections": [
                                "Probabilidade e Estatística: distribuições aleatórias e análise estatística.",
                                "Programação Computacional: loops eficientes e vetoriação em MATLAB.",
                                "Matemática Aplicada: modelos lineares e análise de robustez.",
                                "Física/Engenharia: dinâmica de sistemas reais com ruído."
                              ],
                              "realWorldApplication": "Em plantas químicas, simulações Monte Carlo avaliam robustez de controladores MIMO sob variações paramétricas (ex: temperatura afetando ganhos), prevendo falhas em overshoot que poderiam danificar equipamentos ou violar specs de qualidade."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.7.5",
                    "name": "Representação Matemática Básica",
                    "description": "Introdução a funções de transferência matriciais e modelos em espaço de estados para MIMO.",
                    "individualConcepts": [
                      {
                        "id": "10.1.7.5.1",
                        "name": "Funções de Transferência Matriciais para Sistemas MIMO",
                        "description": "Representação de sistemas lineares invariantes no tempo (LIT) multivariáveis utilizando matrizes cujos elementos são funções de transferência escalares, destacando a generalização do caso SISO para entradas e saídas múltiplas.",
                        "specificSkills": [
                          {
                            "id": "10.1.7.5.1.1",
                            "name": "Definir e identificar matriz de funções de transferência MIMO",
                            "description": "Explicar o conceito de matriz de transferência G(s) ∈ ℂ^{p×m}, onde p é o número de saídas e m o de entradas, e identificar sua estrutura a partir de equações diferenciais ou diagramas de blocos conectados em paralelo.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Funções de Transferência SISO e Introduzir Conceitos MIMO",
                                  "subSteps": [
                                    "Relembrar a definição de função de transferência SISO: G(s) = Y(s)/U(s) em domínio de Laplace.",
                                    "Explicar extensão para MIMO: múltiplas entradas U(s) ∈ ℂ^m e saídas Y(s) ∈ ℂ^p.",
                                    "Discutir que G(s) é uma matriz p×m onde cada elemento G_ij(s) relaciona a i-ésima saída à j-ésima entrada.",
                                    "Identificar condições: sistema linear invariante no tempo (LTI), conexões sem feedback cruzado inicial.",
                                    "Visualizar diagrama simples de sistema MIMO desacoplado."
                                  ],
                                  "verification": "Resumir em um parágrafo a diferença entre SISO e MIMO, com exemplo de dimensões.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Livro de controle (Ogata ou Franklin)",
                                    "Folha de papel e caneta",
                                    "Software MATLAB/Simulink para visualização"
                                  ],
                                  "tips": "Use analogias como 'um mixer de áudio com múltiplos canais' para entradas/saídas.",
                                  "learningObjective": "Compreender a transição conceitual de SISO para MIMO e dimensões da matriz G(s).",
                                  "commonMistakes": [
                                    "Confundir entradas com saídas",
                                    "Ignorar domínio complexo ℂ",
                                    "Esquecer LTI"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Definir Formalmente a Matriz de Funções de Transferência G(s)",
                                  "subSteps": [
                                    "Escrever Y(s) = G(s) U(s), onde G(s) ∈ ℂ^{p×m}.",
                                    "Explicar cada G_ij(s) = Y_i(s)/U_j(s) com todas outras entradas zero.",
                                    "Derivar estrutura para sistemas em paralelo: diagonal se desacoplado.",
                                    "Discutir polos e zeros da matriz (valores próprios).",
                                    "Praticar notação: p saídas, m entradas."
                                  ],
                                  "verification": "Escrever a equação matricial Y(s) = G(s) U(s) e definir dimensões para p=3, m=2.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Quadro branco ou software LaTeX para equações",
                                    "Notas de aula sobre Laplace"
                                  ],
                                  "tips": "Sempre especifique 'com entradas nulas exceto a j-ésima' para G_ij.",
                                  "learningObjective": "Definir precisamente G(s) e sua representação matricial.",
                                  "commonMistakes": [
                                    "Escrever G(s) como escalar",
                                    "Inverter p e m",
                                    "Omitir ∈ ℂ^{p×m}"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Identificar G(s) a partir de Equações Diferenciais",
                                  "subSteps": [
                                    "Dada equações como ÿ1 + a ẏ1 + b y1 = c u1 + d u2, aplicar Laplace assumindo condições iniciais zero.",
                                    "Transformar para Y1(s) = G11(s) U1(s) + G12(s) U2(s).",
                                    "Repetir para todas saídas, montando matriz G(s).",
                                    "Verificar coeficientes: numerador/denominador para cada G_ij.",
                                    "Simplificar frações racionais comuns."
                                  ],
                                  "verification": "Converter um sistema de 2 eqs diff em G(s) 2x2 e validar.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Calculadora simbólica (MATLAB Symbolic ou Wolfram Alpha)",
                                    "Exercícios impressos"
                                  ],
                                  "tips": "Transforme termo a termo, isolando cada Y_i em função de U's.",
                                  "learningObjective": "Extrair matriz G(s) diretamente de modelo diferencial.",
                                  "commonMistakes": [
                                    "Esquecer fatores s^k em derivadas",
                                    "Não zerar condições iniciais",
                                    "Erros em Laplace de produtos"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Identificar G(s) a partir de Diagramas de Blocos em Paralelo",
                                  "subSteps": [
                                    "Analisar diagrama: entradas u1..um para blocos G1j..Gpj em paralelo por saída.",
                                    "Para cada saída yi, somar contribuições: Yi(s) = sum G_ik(s) Uk(s).",
                                    "Montar matriz lendo colunas (fixa entrada, varia saídas).",
                                    "Verificar conexões cruzadas ou desacopladas.",
                                    "Simular em software para confirmação."
                                  ],
                                  "verification": "Dado diagrama 2x2, escrever G(s) e simular resposta a u1 step.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Simulink ou software de blocos (Scilab Xcos)",
                                    "Diagramas exemplo"
                                  ],
                                  "tips": "Siga setas de sinal: entrada -> bloco -> soma para saída.",
                                  "learningObjective": "Reconhecer e extrair G(s) de representação gráfica.",
                                  "commonMistakes": [
                                    "Confundir soma de blocos",
                                    "Ler linhas em vez de colunas",
                                    "Ignorar ganhos constantes"
                                  ]
                                }
                              ],
                              "practicalExample": "Sistema de controle de temperatura em tanque duplo: entradas u1 (aquecedor1), u2 (aquecedor2); saídas y1 (temp tanque1), y2 (temp tanque2). Equações: (s^2 + 2s + 1)y1 = 3u1 + u2; (s^2 + s + 1)y2 = 2u1 + 4u2. Assim G(s) = [[3/(s^2+2s+1), 1/(s^2+2s+1)], [2/(s^2+s+1), 4/(s^2+s+1)]]. Diagrama: blocos paralelos para cada saída.",
                              "finalVerifications": [
                                "Definir corretamente G(s) ∈ ℂ^{p×m} com notação precisa.",
                                "Converter equações diferenciais lineares em G(s) sem erros de Laplace.",
                                "Extrair G(s) de diagrama de blocos paralelo, identificando G_ij.",
                                "Explicar independência de G_ij (outras u_k=0).",
                                "Simular resposta MIMO simples e matching com G(s).",
                                "Identificar se sistema é desacoplado (G diagonal)."
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição e dimensões (30%)",
                                "Correção na transformação Laplace de eqs diff (25%)",
                                "Acurácia na leitura de diagramas de blocos (20%)",
                                "Completude de elementos G_ij com simplificação (15%)",
                                "Capacidade de verificação/simulação (10%)"
                              ],
                              "crossCurricularConnections": [
                                "Álgebra Linear: operações matriciais e decomposições.",
                                "Análise de Sistemas: transformadas de Laplace e funções racionais.",
                                "Programação: implementação em MATLAB para simulação MIMO.",
                                "Física: modelagem de sistemas dinâmicos multi-físicos."
                              ],
                              "realWorldApplication": "Em processos químicos como destilação multicomponente (múltiplas vazões/ temperaturas), controle de aeronaves (entradas: motores/ flaps; saídas: roll/pitch/yaw), ou robótica colaborativa com múltiplos joints/ sensores."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.7.5.1.2",
                            "name": "Calcular funções de transferência matriciais básicas",
                            "description": "Derivar a matriz G(s) para configurações MIMO simples, como sistemas com 2 entradas e 2 saídas desacopladas ou acopladas, utilizando transformada de Laplace e regras de blocos em série/paralelo.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Construir o Diagrama de Blocos do Sistema MIMO Simples",
                                  "subSteps": [
                                    "Identifique as entradas (u1, u2) e saídas (y1, y2) do sistema 2x2.",
                                    "Desenhe os blocos de transferência individuais para cada caminho entrada-saída.",
                                    "Inclua elementos de acoplamento off-diagonal se o sistema for acoplado.",
                                    "Marque pontos de soma e nós de sinal para conexões série/paralelo.",
                                    "Valide a topologia contra exemplos padrão de MIMO desacoplado/acoplado."
                                  ],
                                  "verification": "Diagrama de blocos completo e rotulado corretamente, sem erros de conexão.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Papel quadriculado ou software de diagrama (Draw.io, MATLAB Simulink)",
                                    "Exemplos de diagramas MIMO 2x2"
                                  ],
                                  "tips": "Use setas direcionais claras para fluxos de sinal e comece com configurações desacopladas.",
                                  "learningObjective": "Modelar visualmente configurações MIMO simples para análise de transferência.",
                                  "commonMistakes": [
                                    "Inverter entradas/saídas",
                                    "Esquecer nós de soma em acoplamentos",
                                    "Ignorar direções de sinal"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Aplicar Transformada de Laplace aos Blocos Individuais",
                                  "subSteps": [
                                    "Escreva as funções de transferência elementares Gij(s) para cada bloco usando Laplace unilateral.",
                                    "Assuma condições iniciais zero para simplificação.",
                                    "Converta equações diferenciais do sistema físico em domínio s, se aplicável.",
                                    "Verifique dimensionalidade: cada Gij(s) deve ser razão polinomial própria.",
                                    "Anote os pólos e zeros iniciais de cada elemento."
                                  ],
                                  "verification": "Todas as FTs elementares corretas no domínio Laplace, com tabelas de Laplace consultadas.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Tabela de transformadas de Laplace",
                                    "Calculadora simbólica (Wolfram Alpha ou MATLAB)",
                                    "Folha de equações diferenciais do sistema"
                                  ],
                                  "tips": "Sempre aplique Laplace a partir de t=0+ e ignore transientes iniciais para FT padrão.",
                                  "learningObjective": "Dominar a transição do tempo para o domínio frequência em blocos MIMO.",
                                  "commonMistakes": [
                                    "Esquecer fator 1/s em integrais",
                                    "Misturar Laplace bilateral/unilateral",
                                    "Não zerar condições iniciais"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Derivar Elementos da Matriz G(s) Usando Regras de Blocos",
                                  "subSteps": [
                                    "Para série: multiplique FTs consecutivas (G(s) = G1(s) * G2(s)).",
                                    "Para paralelo: some FTs (G(s) = G1(s) + G2(s)).",
                                    "Para acoplado: isole caminhos cruzados usando superposição de sinais.",
                                    "Calcule cada G11(s), G12(s), G21(s), G22(s) isoladamente.",
                                    "Aplique regras de realimentação simples se presentes nos nós."
                                  ],
                                  "verification": "Cada elemento Gij(s) derivado corretamente, comparado com solução manual.",
                                  "estimatedTime": "1 hora e 30 minutos",
                                  "materials": [
                                    "Regras de manipulação de blocos em série/paralelo (folha de referência)",
                                    "Exemplos resolvidos de MIMO 2x2"
                                  ],
                                  "tips": "Use superposição para acoplamentos: fixe uma entrada e zero a outra.",
                                  "learningObjective": "Aplicar regras de blocos para compor matrizes de transferência MIMO.",
                                  "commonMistakes": [
                                    "Confundir multiplicação com soma em série",
                                    "Ignorar coeficientes de acoplamento off-diagonal",
                                    "Erro em superposição de sinais"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Montar, Simplificar e Verificar a Matriz G(s) Completa",
                                  "subSteps": [
                                    "Organize os elementos em forma matricial: G(s) = [[G11, G12], [G21, G22]].",
                                    "Simplifique frações racionais comuns (fatore numerador/denominador).",
                                    "Verifique invertibilidade ou propriedades (ex: det G(s) ≠ 0).",
                                    "Simule numericamente em software para validação.",
                                    "Documente suposições e limitações (ex: linearidade, estacionariedade)."
                                  ],
                                  "verification": "Matriz G(s) final simplificada e validada por simulação ou cálculo manual.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Software de álgebra simbólica (MATLAB Symbolic, SymPy)",
                                    "Simulador (Simulink ou Python Control Systems)"
                                  ],
                                  "tips": "Fatore o denominador comum para matrizes com estrutura similar.",
                                  "learningObjective": "Finalizar e validar representações matriciais de sistemas MIMO.",
                                  "commonMistakes": [
                                    "Erro na ordenação da matriz",
                                    "Não simplificar polinômios",
                                    "Ignorar cancelamentos de pólos/zeros"
                                  ]
                                }
                              ],
                              "practicalExample": "Sistema 2x2 acoplado: dois motores em tandem onde u1 controla velocidade motor1 (G11=1/(s+1)), u2 motor2 (G22=1/(s+2)), acoplamento G12=0.5/(s+1.5), G21=0.3/(s+1.2). Desenhe blocos, aplique Laplace, derive cada Gij usando superposição/paralelo, monte G(s) = [[1/(s+1), 0.5/(s+1.5)], [0.3/(s+1.2), 1/(s+2)]] e simplifique det G(s).",
                              "finalVerifications": [
                                "Deriva corretamente G(s) para sistema 2x2 desacoplado em <10 min.",
                                "Inclui acoplamentos off-diagonal sem erros de sinal.",
                                "Aplica Laplace corretamente a blocos dinâmicos.",
                                "Simplifica matriz com denominador comum fatorado.",
                                "Valida via simulação numérica básica.",
                                "Explica impacto de acoplamento em controle."
                              ],
                              "assessmentCriteria": [
                                "Precisão na derivação de cada Gij(s) (100% correto).",
                                "Uso adequado de regras de blocos série/paralelo/superposição.",
                                "Simplificação algébrica completa e sem erros.",
                                "Diagrama de blocos claro e profissional.",
                                "Validação cruzada com software ou método alternativo.",
                                "Explicação clara de passos em relatório."
                              ],
                              "crossCurricularConnections": [
                                "Álgebra Linear: manipulação de matrizes e determinantes.",
                                "Análise de Sistemas: transformadas de Laplace e funções racionais.",
                                "Física Aplicada: modelagem dinâmica de sistemas mecânicos/elétricos.",
                                "Programação: simulação em MATLAB/Python para verificação.",
                                "Engenharia de Software: documentação de modelos matemáticos."
                              ],
                              "realWorldApplication": "Em automação industrial, como controle de um braço robótico com 2 juntas (entradas: torques; saídas: posições), onde acoplamentos dinâmicos afetam precisão; ou em processos químicos com reatores interconectados, permitindo design de controladores desacopladores para estabilidade."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "Conhecimento de funções de transferência SISO"
                            ]
                          },
                          {
                            "id": "10.1.7.5.1.3",
                            "name": "Reconhecer propriedades específicas de matrizes MIMO",
                            "description": "Identificar e descrever fenômenos como polos e zeros não mínimos, direções de transmissão zero e direções de entrada/saída, ilustrando com exemplos numéricos simples.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Conceitos Fundamentais de Matrizes de Transferência MIMO",
                                  "subSteps": [
                                    "Defina matriz de transferência MIMO como G(s) onde cada entrada g_ij(s) é uma função de transferência escalar.",
                                    "Explique a diferença entre sistemas SISO e MIMO em termos de representação matricial.",
                                    "Identifique os elementos diagonais e fora da diagonal como canais principais e cruzados.",
                                    "Desenhe um diagrama de blocos simples para um sistema MIMO 2x2.",
                                    "Calcule a função de transferência para um exemplo básico de 2 entradas e 2 saídas."
                                  ],
                                  "verification": "Crie um diagrama de blocos e escreva a matriz G(s) para um sistema MIMO simples; verifique se todos os elementos estão corretamente identificados.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Papel e lápis",
                                    "Livro de Teoria de Controle (ex: Ogata)",
                                    "Software MATLAB ou Octave"
                                  ],
                                  "tips": "Comece com sistemas pequenos (2x2) para visualizar interações entre canais.",
                                  "learningObjective": "Compreender a estrutura matricial básica de funções de transferência MIMO.",
                                  "commonMistakes": [
                                    "Confundir funções de transferência MIMO com escalares SISO",
                                    "Ignorar elementos fora da diagonal"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar Polos e Zeros Não Mínimos",
                                  "subSteps": [
                                    "Defina polos não mínimos como polos do denominador comum que não cancelam zeros em todos os canais.",
                                    "Calcule determinantes e numeradores para detectar zeros não mínimos.",
                                    "Use o conceito de fase mínima para explicar impactos em robustez.",
                                    "Plote polos e zeros em um plano complexo para uma matriz exemplo.",
                                    "Discuta implicações para estabilidade e desempenho do sistema."
                                  ],
                                  "verification": "Para uma matriz G(s) dada, liste polos e zeros não mínimos e justifique por que são 'não mínimos'.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "MATLAB para plotar polos/zeros",
                                    "Calculadora simbólica (SymPy ou similar)",
                                    "Notas de aula sobre análise de sistemas"
                                  ],
                                  "tips": "Verifique cancelamentos apenas se ocorrerem em todos os elementos da matriz.",
                                  "learningObjective": "Reconhecer e calcular polos e zeros não mínimos em matrizes MIMO.",
                                  "commonMistakes": [
                                    "Assumir cancelamento mínimo se ocorrer em um canal apenas",
                                    "Confundir zeros de transmissão com zeros não mínimos"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar Direções de Transmissão Zero e Direções de Entrada/Saída",
                                  "subSteps": [
                                    "Defina direção de transmissão zero como vetor de entrada que resulta em saída zero para frequência específica.",
                                    "Encontre direções de entrada/saída resolvendo G(s0)v = 0 para vetor v.",
                                    "Explique direções de saída como aquelas não observáveis de certas entradas.",
                                    "Calcule singular values para identificar direções fracas.",
                                    "Interprete geometricamente no contexto de decomposição SVD."
                                  ],
                                  "verification": "Para uma matriz numérica em s=0, encontre e descreva uma direção de transmissão zero.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "MATLAB para SVD e eigenvalores",
                                    "Folha de exercícios com matrizes exemplo",
                                    "Referência: Zhou 'Robust and Optimal Control'"
                                  ],
                                  "tips": "Use SVD: G(s) = U Σ V* para identificar direções via colunas de V e U.",
                                  "learningObjective": "Identificar e descrever direções especiais em matrizes MIMO.",
                                  "commonMistakes": [
                                    "Ignorar dependência de frequência s",
                                    "Confundir direções de entrada com saídas"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Ilustrar Propriedades com Exemplos Numéricos Simples",
                                  "subSteps": [
                                    "Escolha matriz exemplo: G(s) = [[(s-1)/(s+1), 2/(s+1)]; [3/(s+1), (s-1)/(s+1)]]",
                                    "Calcule polos não mínimos (s=-1 comum) e zeros não mínimos (s=1 em diagonal).",
                                    "Encontre direção de transmissão zero: v = [1, -1]^T em s=1.",
                                    "Descreva direções de entrada/saída para s=0.",
                                    "Gere gráficos de Bode para canais e discuta propriedades."
                                  ],
                                  "verification": "Produza relatório com cálculos, plots e descrições das propriedades identificadas.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "MATLAB/Simulink para simulações",
                                    "Templates de relatório",
                                    "Exemplos de livros de controle avançado"
                                  ],
                                  "tips": "Simule respostas a entradas em direções específicas para validar.",
                                  "learningObjective": "Aplicar reconhecimento de propriedades em exemplos concretos.",
                                  "commonMistakes": [
                                    "Erros aritméticos em vetores nulos",
                                    "Não normalizar direções"
                                  ]
                                }
                              ],
                              "practicalExample": "Considere G(s) = [[1/(s+1), 1/(s+2)]; [1/(s+3), 1/(s+4)]]. Polo não mínimo em s≈-2.5 (raiz det(denom)). Zero não mínimo detectado via numeradores. Direção de transmissão zero em s=0: v=[1,-1]^T resulta em y=0.",
                              "finalVerifications": [
                                "Liste polos e zeros não mínimos para uma matriz 2x2 dada.",
                                "Identifique uma direção de transmissão zero e verifique G(s0)v=0.",
                                "Descreva impactos de propriedades em controle MIMO.",
                                "Plote singular values e interprete direções fracas.",
                                "Compare propriedades com sistema SISO equivalente.",
                                "Explique com diagrama como direções afetam acoplamento."
                              ],
                              "assessmentCriteria": [
                                "Precisão nos cálculos de polos, zeros e direções (90% correto).",
                                "Completude das descrições e justificativas teóricas.",
                                "Qualidade dos exemplos numéricos e plots gerados.",
                                "Correta interpretação de implicações para sistemas reais.",
                                "Clareza na comunicação de propriedades identificadas.",
                                "Uso adequado de ferramentas como SVD e análise de Bode."
                              ],
                              "crossCurricularConnections": [
                                "Álgebra Linear: Decomposição em valores singulares (SVD) e autovalores.",
                                "Sinais e Sistemas: Análise de frequência e estabilidade.",
                                "Matemática Computacional: Uso de MATLAB para manipulação matricial.",
                                "Engenharia de Controle: Integração com design de controladores LQG/H∞.",
                                "Física: Modelagem de sistemas acoplados como em mecânica vibracional."
                              ],
                              "realWorldApplication": "Em controle de aeronaves MIMO, reconhecer zeros não mínimos evita designs instáveis; direções de transmissão zero em processos químicos otimizam alocação de atuadores para máxima observabilidade."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.7.5.2",
                        "name": "Modelos em Espaço de Estados para Sistemas MIMO",
                        "description": "Representação de sistemas multivariáveis no domínio do tempo usando equações diferenciais matriciais, com ênfase nas matrizes A, B, C e D para descrições de ordem mínima.",
                        "specificSkills": [
                          {
                            "id": "10.1.7.5.2.1",
                            "name": "Escrever equações de estado matriciais para MIMO",
                            "description": "Formular o modelo ẋ = Ax + Bu, y = Cx + Du a partir de descrições físicas ou equações diferenciais lineares com múltiplas variáveis de estado, entrada e saída.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Analisar a descrição do sistema e identificar variáveis principais",
                                  "subSteps": [
                                    "Leia atentamente a descrição física ou as equações diferenciais fornecidas.",
                                    "Identifique as variáveis dependentes (ex: posições, velocidades, níveis de tanque).",
                                    "Liste todas as entradas de controle (u), saídas desejadas (y) e variáveis de estado candidatas (x).",
                                    "Determine o número de estados (n), entradas (m) e saídas (p) para definir dimensões.",
                                    "Desenhe um diagrama esquemático do sistema para visualizar interações."
                                  ],
                                  "verification": "Confirme que você tem n variáveis de estado independentes, m entradas e p saídas listadas corretamente.",
                                  "estimatedTime": "20-30 minutos",
                                  "materials": [
                                    "Papel e caneta para diagrama",
                                    "Descrição do sistema impressa"
                                  ],
                                  "tips": "Escolha estados mínimos que capturem toda a dinâmica; evite redundâncias.",
                                  "learningObjective": "Compreender a estrutura do sistema MIMO e selecionar variáveis de estado adequadas.",
                                  "commonMistakes": [
                                    "Confundir entradas com perturbações",
                                    "Escolher estados dependentes",
                                    "Ignorar acoplamentos entre variáveis"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Escrever as equações diferenciais lineares em termos dos estados",
                                  "subSteps": [
                                    "Expresse as derivadas dos estados (ẋ_i) como funções lineares dos estados x e entradas u.",
                                    "Use as leis físicas (ex: 2ª lei de Newton, conservação de massa) para derivar cada equação.",
                                    "Linearize o sistema se partir de modelo não-linear, usando ponto de equilíbrio.",
                                    "Escreva explicitamente cada equação escalar: ẋ_i = soma a_{ij} x_j + soma b_{ik} u_k.",
                                    "Verifique consistência dimensional em cada termo."
                                  ],
                                  "verification": "Substitua valores numéricos simples e confira se as derivadas fazem sentido fisicamente.",
                                  "estimatedTime": "30-45 minutos",
                                  "materials": [
                                    "Calculadora",
                                    "Tabela de parâmetros do sistema"
                                  ],
                                  "tips": "Mantenha coeficientes simbólicos inicialmente para clareza.",
                                  "learningObjective": "Formular equações diferenciais lineares multivariáveis corretamente.",
                                  "commonMistakes": [
                                    "Erros de sinal em termos de acoplamento",
                                    "Omitir termos de entrada",
                                    "Não linearizar adequadamente"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Converter equações escalares para forma matricial ẋ = Ax + Bu",
                                  "subSteps": [
                                    "Agrupe os termos de estados em uma matriz A (n x n), onde a_{ij} é coeficiente de x_j em ẋ_i.",
                                    "Agrupe os termos de entradas em matriz B (n x m), onde b_{ik} é coeficiente de u_k em ẋ_i.",
                                    "Escreva a equação vetorial ẋ = Ax + Bu explicitamente.",
                                    "Preencha as matrizes linha por linha, correspondendo às equações escalares.",
                                    "Confirme que as dimensões batem: ẋ (n x 1), A (n x n), x (n x 1), B (n x m), u (m x 1)."
                                  ],
                                  "verification": "Multiplique as matrizes manualmente para uma entrada simples e compare com equação escalar.",
                                  "estimatedTime": "25-40 minutos",
                                  "materials": [
                                    "Folha quadriculada para matrizes",
                                    "Software como MATLAB ou Python (opcional)"
                                  ],
                                  "tips": "Use notação consistente: linhas para equações de estado, colunas para variáveis.",
                                  "learningObjective": "Construir matrizes A e B a partir de equações diferenciais.",
                                  "commonMistakes": [
                                    "Transpor incorretamente matrizes",
                                    "Erros de índice em acoplamentos",
                                    "Confundir A com B"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Definir equações de saída y = Cx + Du e validar o modelo completo",
                                  "subSteps": [
                                    "Identifique relações algébricas entre saídas y e estados/entradas.",
                                    "Forme matriz C (p x n) para y = Cx e D (p x m) para termos diretos de u.",
                                    "Escreva o modelo completo: ẋ = Ax + Bu, y = Cx + Du.",
                                    "Simule numericamente com valores de exemplo para verificar estabilidade ou resposta.",
                                    "Compare com descrição original para garantir fidelidade."
                                  ],
                                  "verification": "Implemente em simulador e plote respostas a entradas degrau; deve coincidir com esperado.",
                                  "estimatedTime": "20-35 minutos",
                                  "materials": [
                                    "MATLAB/Simulink ou Python com numpy/scipy",
                                    "Valores numéricos de exemplo"
                                  ],
                                  "tips": "D é frequentemente zero em sistemas físicos sem alimentação direta.",
                                  "learningObjective": "Completar o modelo em espaço de estados MIMO com saídas.",
                                  "commonMistakes": [
                                    "Ignorar feedthrough D",
                                    "C incorreta para saídas não-estados",
                                    "Não validar simulação"
                                  ]
                                }
                              ],
                              "practicalExample": "Considere duas massas m1 e m2 conectadas por mola k, com forças de entrada f1 e f2. Estados: x = [x1, x2, v1, v2]^T, u = [f1, f2]^T, y = [x1, x2]^T. Equações: m1 v1_dot = -k(x1-x2) + f1; m2 v2_dot = -k(x2-x1) + f2. Assim, A = [[0,0,1,0],[0,0,0,1],[-k/m1, k/m1, 0,0],[k/m2, -k/m2, 0,0]], B = [[0,0],[0,0],[1/m1, 0],[0, 1/m2]], C = [[1,0,0,0],[0,1,0,0]], D = [[0,0],[0,0]].",
                              "finalVerifications": [
                                "Dimensões das matrizes A(nxn), B(nxm), C(pxn), D(pxm) estão corretas.",
                                "Multiplicação matricial reproduz exatamente as equações diferenciais escalares.",
                                "Simulação numérica com entradas unitárias produz respostas fisicamente plausíveis.",
                                "O modelo captura todos os acoplamentos MIMO identificados.",
                                "Linearização (se aplicável) é precisa no ponto de equilíbrio.",
                                "Estados são minimais e observáveis/controláveis em princípio."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de variáveis e dimensões (30%)",
                                "Correção das matrizes A, B, C, D derivadas das equações (40%)",
                                "Validação via expansão matricial e simulação (20%)",
                                "Clareza na apresentação e documentação do processo (10%)"
                              ],
                              "crossCurricularConnections": [
                                "Álgebra Linear: Manipulação de vetores e matrizes, autovalores para análise.",
                                "Física: Leis de dinâmica newtoniana ou conservação para derivação de equações.",
                                "Programação: Implementação em MATLAB/Python para simulação e visualização.",
                                "Engenharia Mecânica/Elétrica: Modelagem de sistemas reais como robôs ou circuitos."
                              ],
                              "realWorldApplication": "Em controle de drones, onde equações MIMO modelam atitudes (roll, pitch, yaw) com entradas de motores e saídas de sensores IMU, permitindo design de controladores robustos para voo estável."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "Revisão de espaço de estados SISO"
                            ]
                          },
                          {
                            "id": "10.1.7.5.2.2",
                            "name": "Representar sistemas MIMO em forma canônica",
                            "description": "Converter modelos MIMO para formas canônicas como controllability ou observability canonical form, verificando realizabilidade e minimalidade.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Conceitos Fundamentais de Modelos MIMO em Espaço de Estado",
                                  "subSteps": [
                                    "Relembrar a representação padrão de um sistema MIMO: ẋ = Ax + Bu, y = Cx + Du.",
                                    "Entender o que são formas canônicas: representações simplificadas que revelam propriedades como controllability e observability.",
                                    "Diferenciar controllability canonical form (CCF) e observability canonical form (OCF).",
                                    "Estudar critérios de realizabilidade: rank([B AB ... A^{n-1}B]) = n para controllability.",
                                    "Discutir minimalidade: sistema mínimo se controllável e observável."
                                  ],
                                  "verification": "Resumir em um diagrama as diferenças entre CCF e OCF, e listar critérios de controllability/observability.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Livro-texto de Controle Moderno (ex: Ogata), notas de aula, calculadora.",
                                  "tips": "Use matrizes de exemplo 2x2 para visualizar transformações.",
                                  "learningObjective": "Compreender as bases teóricas das formas canônicas em sistemas MIMO.",
                                  "commonMistakes": "Confundir controllability com observability; ignorar o papel da matriz D."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Converter para Controllability Canonical Form (CCF)",
                                  "subSteps": [
                                    "Calcular a matriz de controllability Qc = [B AB A²B ... A^{n-1}B].",
                                    "Verificar se rank(Qc) = n; se não, sistema não controllável.",
                                    "Computar a transformação T = Qc^{-1} para obter Ã = T A T^{-1}, B̃ = T B.",
                                    "Ajustar C̃ = C T^{-1} e D̃ = D para a nova forma.",
                                    "Verificar se B̃ tem a estrutura canônica (escalonada)."
                                  ],
                                  "verification": "Obter matrizes Ã, B̃, C̃, D̃ idênticas às do sistema original em simulação numérica.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Software MATLAB ou Python (control library), papel quadriculado.",
                                  "tips": "Para sistemas pequenos (n=2), faça cálculos manuais primeiro.",
                                  "learningObjective": "Dominar o algoritmo de transformação para CCF.",
                                  "commonMistakes": "Erro no cálculo de potências de A; inverter Qc incorretamente."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Converter para Observability Canonical Form (OCF)",
                                  "subSteps": [
                                    "Calcular a matriz de observability Qo = [C^T A C^T ... A^{n-1} C^T]^T.",
                                    "Verificar rank(Qo) = n.",
                                    "Computar T = Qo^{-1} para Ã = T A T^{-1}, C̃ = C T.",
                                    "Ajustar B̃ = T B e D̃ = D.",
                                    "Confirmar estrutura canônica em C̃ (escalonada por fileiras)."
                                  ],
                                  "verification": "Simular resposta ao impulso e comparar com sistema original.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "MATLAB/Simulink, exemplos numéricos impressos.",
                                  "tips": "Transponha o sistema para usar ferramentas de controllability.",
                                  "learningObjective": "Aplicar transformação para OCF com precisão.",
                                  "commonMistakes": "Confundir ordem das colunas em Qo; esquecer transposição."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificar Realizabilidade e Minimalidade",
                                  "subSteps": [
                                    "Testar controllability: calcular rank(Qc) == n.",
                                    "Testar observability: rank(Qo) == n.",
                                    "Verificar realizabilidade: existência de T não-singular tal que formas canônicas sejam obtidas.",
                                    "Determinar ordem mínima: n se mínimo, senão reduzir modelo.",
                                    "Comparar polos e zeros do sistema original e canônico."
                                  ],
                                  "verification": "Relatório com ranks computados e conclusão sobre minimalidade.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Ferramenta de cálculo simbólico (SymPy ou MATLAB Symbolic).",
                                  "tips": "Use svd() para ranks numéricos estáveis.",
                                  "learningObjective": "Avaliar propriedades intrínsecas do sistema MIMO.",
                                  "commonMistakes": "Usar det() em vez de rank para singularidade; ignorar modos não controlláveis."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Praticar Integração e Análise Completa",
                                  "subSteps": [
                                    "Aplicar pipeline completo (CCF + OCF + verificações) em um exemplo novo.",
                                    "Analisar impacto de não-minimalidade em controle.",
                                    "Explorar formas Jordan canônicas como extensão.",
                                    "Documentar processo em um template padronizado.",
                                    "Discutir limitações computacionais para sistemas grandes."
                                  ],
                                  "verification": "Resolver problema completo com acurácia >95% em simulação.",
                                  "estimatedTime": "75 minutos",
                                  "materials": "Exercícios de livro, Jupyter Notebook.",
                                  "tips": "Grave vídeo curto explicando um passo chave.",
                                  "learningObjective": "Integrar todo o processo em fluxos de trabalho reais.",
                                  "commonMistakes": "Pular verificações intermediárias; erros de arredondamento numérico."
                                }
                              ],
                              "practicalExample": "Considere o sistema MIMO 2x2: A = [[0,1],[0,0]], B = [[0,1],[1,0]], C = [[1,0],[0,1]], D=0. Converta para CCF: Qc = [[0,1],[1,0]], T=Qc^{-1}, obtenha Ã companion form. Verifique rank(Qc)=2 (controllável). Repita para OCF.",
                              "finalVerifications": [
                                "Rank(Qc) = n e rank(Qo) = n confirmados.",
                                "Matrizes transformadas preservam dinâmica (eigenvalues iguais).",
                                "Simulação de resposta coincide com original.",
                                "Estrutura canônica visualmente confirmada (B̃ ou C̃ escalonados).",
                                "Relatório documenta todos os passos sem erros algébricos.",
                                "Sistema classificado corretamente como mínimo ou não."
                              ],
                              "assessmentCriteria": [
                                "Precisão nos cálculos de Qc/Qo e ranks (100% correto).",
                                "Correta aplicação de transformações T (verificação por simulação).",
                                "Identificação precisa de minimalidade e realizabilidade.",
                                "Explicação clara de estruturas canônicas.",
                                "Eficiência temporal e uso de ferramentas adequadas.",
                                "Análise de erros comuns evitados."
                              ],
                              "crossCurricularConnections": [
                                "Álgebra Linear: autovalores, similaridade, ranks de matrizes.",
                                "Programação Numérica: implementação em MATLAB/Python para automação.",
                                "Física: modelagem dinâmica de sistemas multi-físicos.",
                                "Otimização: redução de ordem para controle ótimo."
                              ],
                              "realWorldApplication": "Em controle de aeronaves MIMO (roll, pitch, yaw), formas canônicas simplificam design de controladores LQR/LQG, verificando se todos os modos são controláveis/observáveis para estabilidade de voo autônomo."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.7.5.2.3",
                            "name": "Relacionar espaço de estados com funções de transferência",
                            "description": "Derivar a matriz de transferência G(s) = C(sI - A)^{-1}B + D a partir de um modelo em espaço de estado MIMO, e vice-versa para sistemas de baixa ordem.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Representação em Espaço de Estado para Sistemas MIMO",
                                  "subSteps": [
                                    "Defina os vetores de estado x(t), entrada u(t), saída y(t) e as matrizes A, B, C, D para um sistema MIMO.",
                                    "Escreva as equações diferenciais: dx/dt = A x + B u e y = C x + D u.",
                                    "Identifique dimensões: n estados, m entradas, p saídas.",
                                    "Pratique com um exemplo 2x2 MIMO simples."
                                  ],
                                  "verification": "Construa corretamente o modelo em espaço de estado para um sistema dado e verifique se as matrizes têm dimensões compatíveis.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Livro de controle (ex: Ogata), MATLAB ou Python (Control Systems Library), caderno para anotações.",
                                  "tips": "Sempre verifique as dimensões das matrizes antes de prosseguir para evitar erros de multiplicação.",
                                  "learningObjective": "Compreender e representar precisamente modelos MIMO em espaço de estado.",
                                  "commonMistakes": "Confundir ordem das matrizes B e C ou ignorar o termo feedthrough D."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Derivar a Matriz de Transferência G(s) a partir do Espaço de Estado",
                                  "subSteps": [
                                    "Aplique a transformada de Laplace às equações de estado assumindo condições iniciais zero: sX(s) = A X(s) + B U(s).",
                                    "Resolva para X(s): X(s) = (sI - A)^{-1} B U(s).",
                                    "Substitua em Y(s) = C X(s) + D U(s) para obter G(s) = C (sI - A)^{-1} B + D.",
                                    "Compute o determinante ou expanda para sistemas de baixa ordem (n≤2)."
                                  ],
                                  "verification": "Derive G(s) para um sistema MIMO 2x2 dado e confirme com simulação em MATLAB (função ss2tf).",
                                  "estimatedTime": "60 minutos",
                                  "materials": "MATLAB/Simulink ou Octave, calculadora simbólica (SymPy), exemplos de matrizes MIMO.",
                                  "tips": "Use identidade matricial para simplificar (sI - A)^{-1}; pratique expansão manual para ordens baixas.",
                                  "learningObjective": "Dominar a derivação analítica da função de transferência de modelos em espaço de estado MIMO.",
                                  "commonMistakes": "Esquecer o termo +D ou inverter a ordem em C(sI-A)^{-1}B."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Reconstruir o Modelo em Espaço de Estado a partir da Função de Transferência G(s)",
                                  "subSteps": [
                                    "Para sistemas de baixa ordem (n=1 ou 2), realize decomposição em frações parciais de G(s).",
                                    "Escolha uma forma canônica realizável (ex: forma controlável ou observável).",
                                    "Extraia matrizes A, B, C, D da expansão polinomial de G(s).",
                                    "Verifique a equivalência transformando de volta para G(s)."
                                  ],
                                  "verification": "Dado G(s) 2x2, construa um modelo em espaço de estado e confirme que ss2tf reproduz G(s) original.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Software de álgebra simbólica (MATLAB Symbolic Toolbox ou SymPy), tabelas de formas canônicas.",
                                  "tips": "Comece com SISO para prática, depois estenda para MIMO; use minimal realization para evitar estados desnecessários.",
                                  "learningObjective": "Realizar conversão reversa de G(s) para espaço de estado em sistemas de baixa ordem.",
                                  "commonMistakes": "Escolher forma não mínima ou erros em coeficientes de polinômios característicos."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Praticar Integração e Verificação com Exemplos MIMO",
                                  "subSteps": [
                                    "Selecione um exemplo realista (ex: sistema de controle multivariable).",
                                    "Converta em ambas as direções e compare resultados.",
                                    "Analise propriedades como polos e zeros compartilhados.",
                                    "Simule respostas em malha aberta para validação."
                                  ],
                                  "verification": "Resolva 3 exercícios completos com erros <1% entre métodos.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Exercícios de livros (Franklin ou Dorf), simulador (MATLAB Control Toolbox).",
                                  "tips": "Use comandos como tf2ss no MATLAB para automação e aprendizado por comparação.",
                                  "learningObjective": "Aplicar bidirecionalmente as relações entre representações para validação.",
                                  "commonMistakes": "Ignorar desacoplamentos em MIMO ou assumir SISO."
                                }
                              ],
                              "practicalExample": "Considere um sistema MIMO 2x2 com A = [[-1, 0], [0, -2]], B = [[1, 0], [0, 1]], C = [[1, 0], [0, 1]], D = [[0,0],[0,0]]. Derive G(s) = diag(1/(s+1), 1/(s+2)). Inversamente, de G(s) reconstrua as matrizes originais usando forma diagonal.",
                              "finalVerifications": [
                                "Derive corretamente G(s) para 2 exemplos MIMO 2x2 sem erros dimensionais.",
                                "Reconstrua espaço de estado de G(s) de ordem 2 e verifique identidade.",
                                "Simule e compare respostas impulsivas das duas representações (erro <0.5%).",
                                "Explique verbalmente a fórmula G(s) = C(sI-A)^{-1}B + D.",
                                "Identifique polos comuns entre representações."
                              ],
                              "assessmentCriteria": [
                                "Precisão na derivação analítica (100% match com software).",
                                "Correta manipulação matricial e resolução simbólica.",
                                "Validação numérica via simulação (gráficos sobrepostos).",
                                "Explicação clara de passos em relatório curto.",
                                "Tratamento de casos com D ≠ 0 e ordens mistas."
                              ],
                              "crossCurricularConnections": [
                                "Álgebra Linear: Resolução de sistemas lineares e inversas matriciais.",
                                "Cálculo: Transformadas de Laplace e equações diferenciais matriciais.",
                                "Programação: Uso de bibliotecas numéricas (MATLAB, Python Control).",
                                "Física: Modelagem dinâmica de sistemas acoplados (ex: mecânica multivariável)."
                              ],
                              "realWorldApplication": "Em automação industrial, como controle multivariable de reatores químicos ou drones, onde espaço de estado facilita análise de estabilidade MIMO e G(s) permite design de controladores clássicos como PID desacoplados."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.7.5.1"
                            ]
                          }
                        ]
                      }
                    ]
                  }
                ]
              }
            ],
            "totalSkills": 326
          }
        ],
        "totalSkills": 326
      }
    ]
  }
}